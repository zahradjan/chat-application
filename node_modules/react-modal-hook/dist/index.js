'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var ReactDOM = require('react-dom');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);
var ReactDOM__namespace = /*#__PURE__*/_interopNamespace(ReactDOM);

/**
 * Throw error when ModalContext is used outside of context provider
 */
var invariantViolation = function () {
    throw new Error("Attempted to call useModal outside of modal context. Make sure your app is rendered inside ModalProvider.");
};
/**
 * Modal Context Object
 */
var ModalContext = React__namespace.createContext({
    showModal: invariantViolation,
    hideModal: invariantViolation
});
ModalContext.displayName = 'ModalContext';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/**
 * Component responsible for rendering the modal.
 *
 * The identity of `Component` may change dependeing on the inputs passed to
 * `useModal`. If we simply rendered `<Component />` then the modal would be
 * susceptible to rerenders whenever one of the inputs change.
 */
var ModalRenderer = React.memo(function (_a) {
    var component = _a.component, rest = __rest(_a, ["component"]);
    return component(rest);
});
/**
 * Modal Root
 *
 * Renders modals using react portal.
 */
var ModalRoot = React.memo(function (_a) {
    var modals = _a.modals, container = _a.container, _b = _a.component, RootComponent = _b === void 0 ? React__namespace.Fragment : _b;
    var _c = React.useState(undefined), mountNode = _c[0], setMountNode = _c[1];
    // This effect will not be ran in the server environment
    React.useEffect(function () { return setMountNode(container || document.body); });
    return mountNode
        ? ReactDOM__namespace.createPortal(React__namespace.createElement(RootComponent, null, Object.keys(modals).map(function (key) { return (React__namespace.createElement(ModalRenderer, { key: key, component: modals[key] })); })), mountNode)
        : null;
});

/**
 * Modal Provider
 *
 * Provides modal context and renders ModalRoot.
 */
var ModalProvider = function (_a) {
    var container = _a.container, rootComponent = _a.rootComponent, children = _a.children;
    if (container && !(container instanceof HTMLElement)) {
        throw new Error("Container must specify DOM element to mount modal root into.\n\n    This behavior has changed in 3.0.0. Please use `rootComponent` prop instead.\n    See: https://github.com/mpontus/react-modal-hook/issues/18");
    }
    var _b = React.useState({}), modals = _b[0], setModals = _b[1];
    var showModal = React.useCallback(function (key, modal) {
        return setModals(function (modals) {
            var _a;
            return (__assign(__assign({}, modals), (_a = {}, _a[key] = modal, _a)));
        });
    }, []);
    var hideModal = React.useCallback(function (key) {
        return setModals(function (modals) {
            if (!modals[key]) {
                return modals;
            }
            var newModals = __assign({}, modals);
            delete newModals[key];
            return newModals;
        });
    }, []);
    var contextValue = React.useMemo(function () { return ({ showModal: showModal, hideModal: hideModal }); }, []);
    return (React__namespace.createElement(ModalContext.Provider, { value: contextValue },
        React__namespace.createElement(React__namespace.Fragment, null,
            children,
            React__namespace.createElement(ModalRoot, { modals: modals, component: rootComponent, container: container }))));
};

/**
 * Utility function to generate unique number per component instance
 */
var generateModalKey = (function () {
    var count = 0;
    return function () { return "".concat(++count); };
})();
/**
 * Check whether the argument is a stateless component.
 *
 * We take advantage of the stateless nature of functional components to be
 * inline the rendering of the modal component as part of another immutable
 * component.
 *
 * This is necessary for allowing the modal to update based on the inputs passed
 * as the second argument to useModal without unmounting the previous version of
 * the modal component.
 */
var isFunctionalComponent = function (Component) {
    var prototype = Component.prototype;
    return !prototype || !prototype.isReactComponent;
};
/**
 * React hook for showing modal windows
 */
var useModal = function (component, inputs) {
    if (inputs === void 0) { inputs = []; }
    if (!isFunctionalComponent(component)) {
        throw new Error("Only stateless components can be used as an argument to useModal. You have probably passed a class component where a function was expected.");
    }
    var key = React.useMemo(generateModalKey, []);
    var modal = React.useMemo(function () { return component; }, inputs);
    var context = React.useContext(ModalContext);
    var _a = React.useState(false), isShown = _a[0], setShown = _a[1];
    var showModal = React.useCallback(function () { return setShown(true); }, []);
    var hideModal = React.useCallback(function () { return setShown(false); }, []);
    React.useEffect(function () {
        if (isShown) {
            context.showModal(key, modal);
        }
        else {
            context.hideModal(key);
        }
        // Hide modal when parent component unmounts
        return function () { return context.hideModal(key); };
    }, [modal, isShown]);
    return [showModal, hideModal];
};

exports.ModalContext = ModalContext;
exports.ModalProvider = ModalProvider;
exports.useModal = useModal;
//# sourceMappingURL=index.js.map
