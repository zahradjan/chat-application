{"ast":null,"code":"\"use strict\";\n/*! noble-secp256k1 - MIT License (c) Paul Miller (paulmillr.com) */\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.SignResult = exports.Signature = exports.Point = exports.CURVE = void 0;\nvar CURVE = {\n  a: 0n,\n  b: 7n,\n  P: Math.pow(2n, 256n) - Math.pow(2n, 32n) - 977n,\n  n: Math.pow(2n, 256n) - 432420386565659656852420866394968145599n,\n  h: 1n,\n  Gx: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,\n  Gy: 32670510020758816978083085130507043184471273380659243275938904335757337482424n,\n  beta: 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501een\n};\nexports.CURVE = CURVE;\n\nfunction weistrass(x) {\n  var a = CURVE.a,\n      b = CURVE.b;\n  return mod(Math.pow(x, 3n) + a * x + b);\n}\n\nvar USE_ENDOMORPHISM = CURVE.a === 0n;\n\nvar JacobianPoint = /*#__PURE__*/function () {\n  function JacobianPoint(x, y, z) {\n    _classCallCheck(this, JacobianPoint);\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  _createClass(JacobianPoint, [{\n    key: \"equals\",\n    value: function equals(other) {\n      var a = this;\n      var b = other;\n      var az2 = mod(a.z * a.z);\n      var az3 = mod(a.z * az2);\n      var bz2 = mod(b.z * b.z);\n      var bz3 = mod(b.z * bz2);\n      return mod(a.x * bz2) === mod(az2 * b.x) && mod(a.y * bz3) === mod(az3 * b.y);\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n  }, {\n    key: \"double\",\n    value: function double() {\n      var X1 = this.x;\n      var Y1 = this.y;\n      var Z1 = this.z;\n      var A = mod(Math.pow(X1, 2n));\n      var B = mod(Math.pow(Y1, 2n));\n      var C = mod(Math.pow(B, 2n));\n      var D = mod(2n * (mod(mod(Math.pow(X1 + B, 2n))) - A - C));\n      var E = mod(3n * A);\n      var F = mod(Math.pow(E, 2n));\n      var X3 = mod(F - 2n * D);\n      var Y3 = mod(E * (D - X3) - 8n * C);\n      var Z3 = mod(2n * Y1 * Z1);\n      return new JacobianPoint(X3, Y3, Z3);\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      if (!(other instanceof JacobianPoint)) {\n        throw new TypeError('JacobianPoint#add: expected JacobianPoint');\n      }\n\n      var X1 = this.x;\n      var Y1 = this.y;\n      var Z1 = this.z;\n      var X2 = other.x;\n      var Y2 = other.y;\n      var Z2 = other.z;\n      if (X2 === 0n || Y2 === 0n) return this;\n      if (X1 === 0n || Y1 === 0n) return other;\n      var Z1Z1 = mod(Math.pow(Z1, 2n));\n      var Z2Z2 = mod(Math.pow(Z2, 2n));\n      var U1 = mod(X1 * Z2Z2);\n      var U2 = mod(X2 * Z1Z1);\n      var S1 = mod(Y1 * Z2 * Z2Z2);\n      var S2 = mod(mod(Y2 * Z1) * Z1Z1);\n      var H = mod(U2 - U1);\n      var r = mod(S2 - S1);\n\n      if (H === 0n) {\n        if (r === 0n) {\n          return this.double();\n        } else {\n          return JacobianPoint.ZERO;\n        }\n      }\n\n      var HH = mod(Math.pow(H, 2n));\n      var HHH = mod(H * HH);\n      var V = mod(U1 * HH);\n      var X3 = mod(Math.pow(r, 2n) - HHH - 2n * V);\n      var Y3 = mod(r * (V - X3) - S1 * HHH);\n      var Z3 = mod(Z1 * Z2 * H);\n      return new JacobianPoint(X3, Y3, Z3);\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      return this.add(other.negate());\n    }\n  }, {\n    key: \"multiplyUnsafe\",\n    value: function multiplyUnsafe(scalar) {\n      if (!isValidScalar(scalar)) throw new TypeError('Point#multiply: expected valid scalar');\n      var n = mod(BigInt(scalar), CURVE.n);\n\n      if (!USE_ENDOMORPHISM) {\n        var p = JacobianPoint.ZERO;\n\n        var _d = this;\n\n        while (n > 0n) {\n          if (n & 1n) p = p.add(_d);\n          _d = _d.double();\n          n >>= 1n;\n        }\n\n        return p;\n      }\n\n      var _splitScalarEndo = splitScalarEndo(n),\n          _splitScalarEndo2 = _slicedToArray(_splitScalarEndo, 4),\n          k1neg = _splitScalarEndo2[0],\n          k1 = _splitScalarEndo2[1],\n          k2neg = _splitScalarEndo2[2],\n          k2 = _splitScalarEndo2[3];\n\n      var k1p = JacobianPoint.ZERO;\n      var k2p = JacobianPoint.ZERO;\n      var d = this;\n\n      while (k1 > 0n || k2 > 0n) {\n        if (k1 & 1n) k1p = k1p.add(d);\n        if (k2 & 1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= 1n;\n        k2 >>= 1n;\n      }\n\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n      return k1p.add(k2p);\n    }\n  }, {\n    key: \"precomputeWindow\",\n    value: function precomputeWindow(W) {\n      var windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n      var points = [];\n      var p = this;\n      var base = p;\n\n      for (var window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n\n        for (var i = 1; i < Math.pow(2, W - 1); i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n\n        p = base.double();\n      }\n\n      return points;\n    }\n  }, {\n    key: \"wNAF\",\n    value: function wNAF(n, affinePoint) {\n      if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n      var W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n\n      if (256 % W) {\n        throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n      }\n\n      var precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n\n      if (!precomputes) {\n        precomputes = this.precomputeWindow(W);\n\n        if (affinePoint && W !== 1) {\n          precomputes = JacobianPoint.normalizeZ(precomputes);\n          pointPrecomputes.set(affinePoint, precomputes);\n        }\n      }\n\n      var p = JacobianPoint.ZERO;\n      var f = JacobianPoint.ZERO;\n      var windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n      var windowSize = Math.pow(2, W - 1);\n      var mask = BigInt(Math.pow(2, W) - 1);\n      var maxNumber = Math.pow(2, W);\n      var shiftBy = BigInt(W);\n\n      for (var window = 0; window < windows; window++) {\n        var offset = window * windowSize;\n        var wbits = Number(n & mask);\n        n >>= shiftBy;\n\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += 1n;\n        }\n\n        if (wbits === 0) {\n          f = f.add(window % 2 ? precomputes[offset].negate() : precomputes[offset]);\n        } else {\n          var cached = precomputes[offset + Math.abs(wbits) - 1];\n          p = p.add(wbits < 0 ? cached.negate() : cached);\n        }\n      }\n\n      return [p, f];\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar, affinePoint) {\n      if (!isValidScalar(scalar)) throw new TypeError('Point#multiply: expected valid scalar');\n      var n = mod(BigInt(scalar), CURVE.n);\n      var point;\n      var fake;\n\n      if (USE_ENDOMORPHISM) {\n        var _splitScalarEndo3 = splitScalarEndo(n),\n            _splitScalarEndo4 = _slicedToArray(_splitScalarEndo3, 4),\n            k1neg = _splitScalarEndo4[0],\n            k1 = _splitScalarEndo4[1],\n            k2neg = _splitScalarEndo4[2],\n            k2 = _splitScalarEndo4[3];\n\n        var k1p, k2p, f1p, f2p;\n\n        var _this$wNAF = this.wNAF(k1, affinePoint);\n\n        var _this$wNAF2 = _slicedToArray(_this$wNAF, 2);\n\n        k1p = _this$wNAF2[0];\n        f1p = _this$wNAF2[1];\n\n        var _this$wNAF3 = this.wNAF(k2, affinePoint);\n\n        var _this$wNAF4 = _slicedToArray(_this$wNAF3, 2);\n\n        k2p = _this$wNAF4[0];\n        f2p = _this$wNAF4[1];\n        if (k1neg) k1p = k1p.negate();\n        if (k2neg) k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        var _ref = [k1p.add(k2p), f1p.add(f2p)];\n        point = _ref[0];\n        fake = _ref[1];\n      } else {\n        var _this$wNAF5 = this.wNAF(n, affinePoint);\n\n        var _this$wNAF6 = _slicedToArray(_this$wNAF5, 2);\n\n        point = _this$wNAF6[0];\n        fake = _this$wNAF6[1];\n      }\n\n      return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n  }, {\n    key: \"toAffine\",\n    value: function toAffine() {\n      var invZ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : invert(this.z);\n      var invZ2 = Math.pow(invZ, 2n);\n      var x = mod(this.x * invZ2);\n      var y = mod(this.y * invZ2 * invZ);\n      return new Point(x, y);\n    }\n  }], [{\n    key: \"fromAffine\",\n    value: function fromAffine(p) {\n      if (!(p instanceof Point)) {\n        throw new TypeError('JacobianPoint#fromAffine: expected Point');\n      }\n\n      return new JacobianPoint(p.x, p.y, 1n);\n    }\n  }, {\n    key: \"toAffineBatch\",\n    value: function toAffineBatch(points) {\n      var toInv = invertBatch(points.map(function (p) {\n        return p.z;\n      }));\n      return points.map(function (p, i) {\n        return p.toAffine(toInv[i]);\n      });\n    }\n  }, {\n    key: \"normalizeZ\",\n    value: function normalizeZ(points) {\n      return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n  }]);\n\n  return JacobianPoint;\n}();\n\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, 1n);\nJacobianPoint.ZERO = new JacobianPoint(0n, 1n, 0n);\nvar pointPrecomputes = new WeakMap();\n\nvar Point = /*#__PURE__*/function () {\n  function Point(x, y) {\n    _classCallCheck(this, Point);\n\n    this.x = x;\n    this.y = y;\n  }\n\n  _createClass(Point, [{\n    key: \"_setWindowSize\",\n    value: function _setWindowSize(windowSize) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return hexToBytes(this.toHex(isCompressed));\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var x = pad64(this.x);\n\n      if (isCompressed) {\n        return \"\".concat(this.y & 1n ? '03' : '02').concat(x);\n      } else {\n        return \"04\".concat(x).concat(pad64(this.y));\n      }\n    }\n  }, {\n    key: \"toHexX\",\n    value: function toHexX() {\n      return this.toHex(true).slice(2);\n    }\n  }, {\n    key: \"toRawX\",\n    value: function toRawX() {\n      return this.toRawBytes(true).slice(1);\n    }\n  }, {\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var msg = 'Point is not on elliptic curve';\n      var P = CURVE.P;\n      var x = this.x,\n          y = this.y;\n      if (x === 0n || y === 0n || x >= P || y >= P) throw new Error(msg);\n      var left = mod(y * y);\n      var right = weistrass(x);\n      if ((left - right) % P !== 0n) throw new Error(msg);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.x === other.x && this.y === other.y;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return new Point(this.x, mod(-this.y));\n    }\n  }, {\n    key: \"double\",\n    value: function double() {\n      return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      return this.add(other.negate());\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar) {\n      return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n  }], [{\n    key: \"fromCompressedHex\",\n    value: function fromCompressedHex(bytes) {\n      var isShort = bytes.length === 32;\n      var x = bytesToNumber(isShort ? bytes : bytes.slice(1));\n      var y2 = weistrass(x);\n      var y = sqrtMod(y2);\n      var isYOdd = (y & 1n) === 1n;\n\n      if (isShort) {\n        if (isYOdd) y = mod(-y);\n      } else {\n        var isFirstByteOdd = (bytes[0] & 1) === 1;\n        if (isFirstByteOdd !== isYOdd) y = mod(-y);\n      }\n\n      var point = new Point(x, y);\n      point.assertValidity();\n      return point;\n    }\n  }, {\n    key: \"fromUncompressedHex\",\n    value: function fromUncompressedHex(bytes) {\n      var x = bytesToNumber(bytes.slice(1, 33));\n      var y = bytesToNumber(bytes.slice(33));\n      var point = new Point(x, y);\n      point.assertValidity();\n      return point;\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      var bytes = ensureBytes(hex);\n      var header = bytes[0];\n\n      if (bytes.length === 32 || bytes.length === 33 && (header === 0x02 || header === 0x03)) {\n        return this.fromCompressedHex(bytes);\n      }\n\n      if (bytes.length === 65 && header === 0x04) return this.fromUncompressedHex(bytes);\n      throw new Error(\"Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not \".concat(bytes.length));\n    }\n  }, {\n    key: \"fromPrivateKey\",\n    value: function fromPrivateKey(privateKey) {\n      return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n  }, {\n    key: \"fromSignature\",\n    value: function fromSignature(msgHash, signature, recovery) {\n      var h = msgHash instanceof Uint8Array ? bytesToNumber(msgHash) : hexToNumber(msgHash);\n      var sig = normalizeSignature(signature);\n      var r = sig.r,\n          s = sig.s;\n\n      if (recovery !== 0 && recovery !== 1) {\n        throw new Error('Cannot recover signature: invalid yParity bit');\n      }\n\n      var prefix = 2 + (recovery & 1);\n      var P_ = Point.fromHex(\"0\".concat(prefix).concat(pad64(r)));\n      var sP = JacobianPoint.fromAffine(P_).multiplyUnsafe(s);\n      var hG = JacobianPoint.BASE.multiply(h);\n      var rinv = invert(r, CURVE.n);\n      var Q = sP.subtract(hG).multiplyUnsafe(rinv);\n      var point = Q.toAffine();\n      point.assertValidity();\n      return point;\n    }\n  }]);\n\n  return Point;\n}();\n\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(0n, 0n);\n\nfunction sliceDer(s) {\n  return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\n\nvar Signature = /*#__PURE__*/function () {\n  function Signature(r, s) {\n    _classCallCheck(this, Signature);\n\n    this.r = r;\n    this.s = s;\n  }\n\n  _createClass(Signature, [{\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var r = this.r,\n          s = this.s;\n      if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');\n      if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n  }, {\n    key: \"toDERRawBytes\",\n    value: function toDERRawBytes() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return hexToBytes(this.toDERHex(isCompressed));\n    }\n  }, {\n    key: \"toDERHex\",\n    value: function toDERHex() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var sHex = sliceDer(numberToHex(this.s));\n      if (isCompressed) return sHex;\n      var rHex = sliceDer(numberToHex(this.r));\n      var rLen = numberToHex(rHex.length / 2);\n      var sLen = numberToHex(sHex.length / 2);\n      var length = numberToHex(rHex.length / 2 + sHex.length / 2 + 4);\n      return \"30\".concat(length, \"02\").concat(rLen).concat(rHex, \"02\").concat(sLen).concat(sHex);\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      return this.toDERRawBytes();\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return this.toDERHex();\n    }\n  }, {\n    key: \"toCompactRawBytes\",\n    value: function toCompactRawBytes() {\n      return hexToBytes(this.toCompactHex());\n    }\n  }, {\n    key: \"toCompactHex\",\n    value: function toCompactHex() {\n      return pad64(this.r) + pad64(this.s);\n    }\n  }], [{\n    key: \"fromCompact\",\n    value: function fromCompact(hex) {\n      if (typeof hex !== 'string' && !(hex instanceof Uint8Array)) {\n        throw new TypeError(\"Signature.fromCompact: Expected string or Uint8Array\");\n      }\n\n      var str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;\n      if (str.length !== 128) throw new Error('Signature.fromCompact: Expected 64-byte hex');\n      var sig = new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n      sig.assertValidity();\n      return sig;\n    }\n  }, {\n    key: \"fromDER\",\n    value: function fromDER(hex) {\n      var fn = 'Signature.fromDER';\n\n      if (typeof hex !== 'string' && !(hex instanceof Uint8Array)) {\n        throw new TypeError(\"\".concat(fn, \": Expected string or Uint8Array\"));\n      }\n\n      var str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;\n      var length = parseByte(str.slice(2, 4));\n\n      if (str.slice(0, 2) !== '30' || length !== str.length - 4 || str.slice(4, 6) !== '02') {\n        throw new Error(\"\".concat(fn, \": Invalid signature \").concat(str));\n      }\n\n      var rLen = parseByte(str.slice(6, 8));\n      var rEnd = 8 + rLen;\n      var rr = str.slice(8, rEnd);\n\n      if (rr.startsWith('00') && parseByte(rr.slice(2, 4)) <= 0x7f) {\n        throw new Error(\"\".concat(fn, \": Invalid r with trailing length\"));\n      }\n\n      var r = hexToNumber(rr);\n      var separator = str.slice(rEnd, rEnd + 2);\n\n      if (separator !== '02') {\n        throw new Error(\"\".concat(fn, \": Invalid r-s separator\"));\n      }\n\n      var sLen = parseByte(str.slice(rEnd + 2, rEnd + 4));\n      var diff = length - sLen - rLen - 10;\n\n      if (diff > 0 || diff === -4) {\n        throw new Error(\"\".concat(fn, \": Invalid total length\"));\n      }\n\n      if (sLen > length - rLen - 4) {\n        throw new Error(\"\".concat(fn, \": Invalid s\"));\n      }\n\n      var sStart = rEnd + 4;\n      var ss = str.slice(sStart, sStart + sLen);\n\n      if (ss.startsWith('00') && parseByte(ss.slice(2, 4)) <= 0x7f) {\n        throw new Error(\"\".concat(fn, \": Invalid s with trailing length\"));\n      }\n\n      var s = hexToNumber(ss);\n      var sig = new Signature(r, s);\n      sig.assertValidity();\n      return sig;\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      return this.fromDER(hex);\n    }\n  }]);\n\n  return Signature;\n}();\n\nexports.Signature = Signature;\nexports.SignResult = Signature;\n\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  if (arrays.length === 1) return arrays[0];\n  var length = arrays.reduce(function (a, arr) {\n    return a + arr.length;\n  }, 0);\n  var result = new Uint8Array(length);\n\n  for (var i = 0, pad = 0; i < arrays.length; i++) {\n    var arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n\n  return result;\n}\n\nfunction bytesToHex(uint8a) {\n  var hex = '';\n\n  for (var i = 0; i < uint8a.length; i++) {\n    hex += uint8a[i].toString(16).padStart(2, '0');\n  }\n\n  return hex;\n}\n\nfunction pad64(num) {\n  return num.toString(16).padStart(64, '0');\n}\n\nfunction pad32b(num) {\n  return hexToBytes(pad64(num));\n}\n\nfunction numberToHex(num) {\n  var hex = num.toString(16);\n  return hex.length & 1 ? \"0\".concat(hex) : hex;\n}\n\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n  }\n\n  return BigInt(\"0x\".concat(hex));\n}\n\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  var array = new Uint8Array(hex.length / 2);\n\n  for (var i = 0; i < array.length; i++) {\n    var j = i * 2;\n    array[i] = Number.parseInt(hex.slice(j, j + 2), 16);\n  }\n\n  return array;\n}\n\nfunction ensureBytes(hex) {\n  return hex instanceof Uint8Array ? hex : hexToBytes(hex);\n}\n\nfunction bytesToNumber(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\n\nfunction parseByte(str) {\n  return Number.parseInt(str, 16) * 2;\n}\n\nfunction isValidScalar(num) {\n  if (typeof num === 'bigint' && num > 0n) return true;\n  if (typeof num === 'number' && num > 0 && Number.isSafeInteger(num)) return true;\n  return false;\n}\n\nfunction mod(a) {\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  var result = a % b;\n  return result >= 0 ? result : b + result;\n}\n\nfunction pow2(x, power) {\n  var P = CURVE.P;\n  var res = x;\n\n  while (power-- > 0n) {\n    res *= res;\n    res %= P;\n  }\n\n  return res;\n}\n\nfunction sqrtMod(x) {\n  var P = CURVE.P;\n  var b2 = x * x * x % P;\n  var b3 = b2 * b2 * x % P;\n  var b6 = pow2(b3, 3n) * b3 % P;\n  var b9 = pow2(b6, 3n) * b3 % P;\n  var b11 = pow2(b9, 2n) * b2 % P;\n  var b22 = pow2(b11, 11n) * b11 % P;\n  var b44 = pow2(b22, 22n) * b22 % P;\n  var b88 = pow2(b44, 44n) * b44 % P;\n  var b176 = pow2(b88, 88n) * b88 % P;\n  var b220 = pow2(b176, 44n) * b44 % P;\n  var b223 = pow2(b220, 3n) * b3 % P;\n  var t1 = pow2(b223, 23n) * b22 % P;\n  var t2 = pow2(t1, 6n) * b2 % P;\n  return pow2(t2, 2n);\n}\n\nfunction invert(number) {\n  var modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n\n  if (number === 0n || modulo <= 0n) {\n    throw new Error(\"invert: expected positive integers, got n=\".concat(number, \" mod=\").concat(modulo));\n  }\n\n  var a = mod(number, modulo);\n  var b = modulo;\n  var x = 0n,\n      y = 1n,\n      u = 1n,\n      v = 0n;\n\n  while (a !== 0n) {\n    var q = b / a;\n    var r = b % a;\n    var m = x - u * q;\n    var n = y - v * q;\n    var _ref2 = [a, r];\n    b = _ref2[0];\n    a = _ref2[1];\n    x = u;\n    y = v;\n    u = m;\n    v = n;\n  }\n\n  var gcd = b;\n  if (gcd !== 1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction invertBatch(nums) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  var len = nums.length;\n  var scratch = new Array(len);\n  var acc = 1n;\n\n  for (var i = 0; i < len; i++) {\n    if (nums[i] === 0n) continue;\n    scratch[i] = acc;\n    acc = mod(acc * nums[i], n);\n  }\n\n  acc = invert(acc, n);\n\n  for (var _i = len - 1; _i >= 0; _i--) {\n    if (nums[_i] === 0n) continue;\n    var tmp = mod(acc * nums[_i], n);\n    nums[_i] = mod(acc * scratch[_i], n);\n    acc = tmp;\n  }\n\n  return nums;\n}\n\nvar divNearest = function divNearest(a, b) {\n  return (a + b / 2n) / b;\n};\n\nvar POW_2_128 = Math.pow(2n, 128n);\n\nfunction splitScalarEndo(k) {\n  var n = CURVE.n;\n  var a1 = 0x3086d221a7d46bcde86c90e49284eb15n;\n  var b1 = -0xe4437ed6010e88286f547fa90abfe4c3n;\n  var a2 = 0x114ca50f7a8e2f3f657c1108d9d44cfd8n;\n  var b2 = a1;\n  var c1 = divNearest(b2 * k, n);\n  var c2 = divNearest(-b1 * k, n);\n  var k1 = mod(k - c1 * a1 - c2 * a2, n);\n  var k2 = mod(-c1 * b1 - c2 * b2, n);\n  var k1neg = k1 > POW_2_128;\n  var k2neg = k2 > POW_2_128;\n  if (k1neg) k1 = n - k1;\n  if (k2neg) k2 = n - k2;\n  if (k1 > POW_2_128 || k2 > POW_2_128) throw new Error('splitScalarEndo: Endomorphism failed');\n  return [k1neg, k1, k2neg, k2];\n}\n\nfunction truncateHash(hash) {\n  if (typeof hash !== 'string') hash = bytesToHex(hash);\n  var msg = hexToNumber(hash || '0');\n  var byteLength = hash.length / 2;\n  var delta = byteLength * 8 - 256;\n\n  if (delta > 0) {\n    msg = msg >> BigInt(delta);\n  }\n\n  if (msg >= CURVE.n) {\n    msg -= CURVE.n;\n  }\n\n  return msg;\n}\n\nfunction _abc6979(msgHash, privateKey) {\n  if (msgHash == null) throw new Error(\"sign: expected valid msgHash, not \\\"\".concat(msgHash, \"\\\"\"));\n  var num = typeof msgHash === 'string' ? hexToNumber(msgHash) : bytesToNumber(msgHash);\n  var h1 = pad32b(num);\n  var h1n = bytesToNumber(h1);\n  var x = pad32b(privateKey);\n  var v = new Uint8Array(32).fill(1);\n  var k = new Uint8Array(32).fill(0);\n  var b0 = Uint8Array.from([0x00]);\n  var b1 = Uint8Array.from([0x01]);\n  return [h1, h1n, x, v, k, b0, b1];\n}\n\nfunction getQRSrfc6979(_x, _x2) {\n  return _getQRSrfc.apply(this, arguments);\n}\n\nfunction _getQRSrfc() {\n  _getQRSrfc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(msgHash, privateKey) {\n    var privKey, _abc3, _abc4, h1, h1n, x, v, k, b0, b1, hmac, i, qrs;\n\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            privKey = normalizePrivateKey(privateKey);\n            _abc3 = _abc6979(msgHash, privKey), _abc4 = _slicedToArray(_abc3, 7), h1 = _abc4[0], h1n = _abc4[1], x = _abc4[2], v = _abc4[3], k = _abc4[4], b0 = _abc4[5], b1 = _abc4[6];\n            hmac = exports.utils.hmacSha256;\n            _context3.next = 5;\n            return hmac(k, v, b0, x, h1);\n\n          case 5:\n            k = _context3.sent;\n            _context3.next = 8;\n            return hmac(k, v);\n\n          case 8:\n            v = _context3.sent;\n            _context3.next = 11;\n            return hmac(k, v, b1, x, h1);\n\n          case 11:\n            k = _context3.sent;\n            _context3.next = 14;\n            return hmac(k, v);\n\n          case 14:\n            v = _context3.sent;\n            i = 0;\n\n          case 16:\n            if (!(i < 1000)) {\n              _context3.next = 32;\n              break;\n            }\n\n            _context3.next = 19;\n            return hmac(k, v);\n\n          case 19:\n            v = _context3.sent;\n            qrs = calcQRSFromK(v, h1n, privKey);\n\n            if (!qrs) {\n              _context3.next = 23;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", qrs);\n\n          case 23:\n            _context3.next = 25;\n            return hmac(k, v, b0);\n\n          case 25:\n            k = _context3.sent;\n            _context3.next = 28;\n            return hmac(k, v);\n\n          case 28:\n            v = _context3.sent;\n\n          case 29:\n            i++;\n            _context3.next = 16;\n            break;\n\n          case 32:\n            throw new TypeError('secp256k1: Tried 1,000 k values for sign(), all were invalid');\n\n          case 33:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getQRSrfc.apply(this, arguments);\n}\n\nfunction getQRSrfc6979Sync(msgHash, privateKey) {\n  var privKey = normalizePrivateKey(privateKey);\n\n  var _abc = _abc6979(msgHash, privKey),\n      _abc2 = _slicedToArray(_abc, 7),\n      h1 = _abc2[0],\n      h1n = _abc2[1],\n      x = _abc2[2],\n      v = _abc2[3],\n      k = _abc2[4],\n      b0 = _abc2[5],\n      b1 = _abc2[6];\n\n  var hmac = exports.utils.hmacSha256Sync;\n  if (!hmac) throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\n  k = hmac(k, v, b0, x, h1);\n  if (k instanceof Promise) throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\n  v = hmac(k, v);\n  k = hmac(k, v, b1, x, h1);\n  v = hmac(k, v);\n\n  for (var i = 0; i < 1000; i++) {\n    v = hmac(k, v);\n    var qrs = calcQRSFromK(v, h1n, privKey);\n    if (qrs) return qrs;\n    k = hmac(k, v, b0);\n    v = hmac(k, v);\n  }\n\n  throw new TypeError('secp256k1: Tried 1,000 k values for sign(), all were invalid');\n}\n\nfunction isWithinCurveOrder(num) {\n  return 0 < num && num < CURVE.n;\n}\n\nfunction calcQRSFromK(v, msg, priv) {\n  var k = bytesToNumber(v);\n  if (!isWithinCurveOrder(k)) return;\n  var max = CURVE.n;\n  var q = Point.BASE.multiply(k);\n  var r = mod(q.x, max);\n  var s = mod(invert(k, max) * (msg + r * priv), max);\n  if (r === 0n || s === 0n) return;\n  return [q, r, s];\n}\n\nfunction normalizePrivateKey(key) {\n  var num;\n\n  if (typeof key === 'bigint') {\n    num = key;\n  } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n    num = BigInt(key);\n  } else if (typeof key === 'string') {\n    if (key.length !== 64) throw new Error('Expected 32 bytes of private key');\n    num = hexToNumber(key);\n  } else if (key instanceof Uint8Array) {\n    if (key.length !== 32) throw new Error('Expected 32 bytes of private key');\n    num = bytesToNumber(key);\n  } else {\n    throw new TypeError('Expected valid private key');\n  }\n\n  if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');\n  return num;\n}\n\nfunction normalizePublicKey(publicKey) {\n  if (publicKey instanceof Point) {\n    publicKey.assertValidity();\n    return publicKey;\n  } else {\n    return Point.fromHex(publicKey);\n  }\n}\n\nfunction normalizeSignature(signature) {\n  if (signature instanceof Signature) {\n    signature.assertValidity();\n    return signature;\n  } else {\n    return Signature.fromDER(signature);\n  }\n}\n\nfunction getPublicKey(privateKey) {\n  var isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var point = Point.fromPrivateKey(privateKey);\n\n  if (typeof privateKey === 'string') {\n    return point.toHex(isCompressed);\n  }\n\n  return point.toRawBytes(isCompressed);\n}\n\nexports.getPublicKey = getPublicKey;\n\nfunction recoverPublicKey(msgHash, signature, recovery) {\n  var point = Point.fromSignature(msgHash, signature, recovery);\n  return typeof msgHash === 'string' ? point.toHex() : point.toRawBytes();\n}\n\nexports.recoverPublicKey = recoverPublicKey;\n\nfunction isPub(item) {\n  var arr = item instanceof Uint8Array;\n  var str = typeof item === 'string';\n  var len = (arr || str) && item.length;\n  if (arr) return len === 33 || len === 65;\n  if (str) return len === 66 || len === 130;\n  if (item instanceof Point) return true;\n  return false;\n}\n\nfunction getSharedSecret(privateA, publicB) {\n  var isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (isPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');\n  if (!isPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');\n  var b = normalizePublicKey(publicB);\n  b.assertValidity();\n  var shared = b.multiply(normalizePrivateKey(privateA));\n  return typeof privateA === 'string' ? shared.toHex(isCompressed) : shared.toRawBytes(isCompressed);\n}\n\nexports.getSharedSecret = getSharedSecret;\n\nfunction QRSToSig(qrs, opts) {\n  var str = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var _qrs = _slicedToArray(qrs, 3),\n      q = _qrs[0],\n      r = _qrs[1],\n      s = _qrs[2];\n\n  var canonical = opts.canonical,\n      der = opts.der,\n      recovered = opts.recovered;\n  var recovery = (q.x === r ? 0 : 2) | Number(q.y & 1n);\n  var adjustedS = s;\n  var HIGH_NUMBER = CURVE.n >> 1n;\n\n  if (s > HIGH_NUMBER && canonical) {\n    adjustedS = CURVE.n - s;\n    recovery ^= 1;\n  }\n\n  var sig = new Signature(r, adjustedS);\n  sig.assertValidity();\n  var hex = der === false ? sig.toCompactHex() : sig.toDERHex();\n  var hashed = str ? hex : hexToBytes(hex);\n  return recovered ? [hashed, recovery] : hashed;\n}\n\nfunction sign(_x3, _x4) {\n  return _sign.apply(this, arguments);\n}\n\nfunction _sign() {\n  _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(msgHash, privKey) {\n    var opts,\n        _args4 = arguments;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n            _context4.t0 = QRSToSig;\n            _context4.next = 4;\n            return getQRSrfc6979(msgHash, privKey);\n\n          case 4:\n            _context4.t1 = _context4.sent;\n            _context4.t2 = opts;\n            _context4.t3 = typeof msgHash === 'string';\n            return _context4.abrupt(\"return\", (0, _context4.t0)(_context4.t1, _context4.t2, _context4.t3));\n\n          case 8:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _sign.apply(this, arguments);\n}\n\nexports.sign = sign;\n\nfunction signSync(msgHash, privKey) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return QRSToSig(getQRSrfc6979Sync(msgHash, privKey), opts, typeof msgHash === 'string');\n}\n\nexports.signSync = signSync;\n\nfunction verify(signature, msgHash, publicKey) {\n  var n = CURVE.n;\n  var sig;\n\n  try {\n    sig = normalizeSignature(signature);\n  } catch (error) {\n    return false;\n  }\n\n  var _sig = sig,\n      r = _sig.r,\n      s = _sig.s;\n  var h = truncateHash(msgHash);\n  if (h === 0n) return false;\n  var pubKey = JacobianPoint.fromAffine(normalizePublicKey(publicKey));\n  var s1 = invert(s, n);\n  var u1 = mod(h * s1, n);\n  var u2 = mod(r * s1, n);\n  var Ghs1 = JacobianPoint.BASE.multiply(u1);\n  var Prs1 = pubKey.multiplyUnsafe(u2);\n  var R = Ghs1.add(Prs1).toAffine();\n  var v = mod(R.x, n);\n  return v === r;\n}\n\nexports.verify = verify;\n\nfunction taggedHash(_x5) {\n  return _taggedHash.apply(this, arguments);\n}\n\nfunction _taggedHash() {\n  _taggedHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(tag) {\n    var tagB,\n        tagH,\n        _len2,\n        messages,\n        _key2,\n        h,\n        _args5 = arguments;\n\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            tagB = new Uint8Array(tag.split('').map(function (c) {\n              return c.charCodeAt(0);\n            }));\n            _context5.next = 3;\n            return exports.utils.sha256(tagB);\n\n          case 3:\n            tagH = _context5.sent;\n\n            for (_len2 = _args5.length, messages = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n              messages[_key2 - 1] = _args5[_key2];\n            }\n\n            _context5.next = 7;\n            return exports.utils.sha256(concatBytes.apply(void 0, [tagH, tagH].concat(messages)));\n\n          case 7:\n            h = _context5.sent;\n            return _context5.abrupt(\"return\", bytesToNumber(h));\n\n          case 9:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _taggedHash.apply(this, arguments);\n}\n\nfunction createChallenge(_x6, _x7, _x8) {\n  return _createChallenge.apply(this, arguments);\n}\n\nfunction _createChallenge() {\n  _createChallenge = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(x, P, message) {\n    var rx, t;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            rx = pad32b(x);\n            _context6.next = 3;\n            return taggedHash('BIP0340/challenge', rx, P.toRawX(), message);\n\n          case 3:\n            t = _context6.sent;\n            return _context6.abrupt(\"return\", mod(t, CURVE.n));\n\n          case 5:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _createChallenge.apply(this, arguments);\n}\n\nfunction hasEvenY(point) {\n  return mod(point.y, 2n) === 0n;\n}\n\nvar SchnorrSignature = /*#__PURE__*/function () {\n  function SchnorrSignature(r, s) {\n    _classCallCheck(this, SchnorrSignature);\n\n    this.r = r;\n    this.s = s;\n    if (r <= 0n || s <= 0n || r >= CURVE.P || s >= CURVE.n) throw new Error('Invalid signature');\n  }\n\n  _createClass(SchnorrSignature, [{\n    key: \"toHex\",\n    value: function toHex() {\n      return pad64(this.r) + pad64(this.s);\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      return hexToBytes(this.toHex());\n    }\n  }], [{\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      var bytes = ensureBytes(hex);\n\n      if (bytes.length !== 64) {\n        throw new TypeError(\"SchnorrSignature.fromHex: expected 64 bytes, not \".concat(bytes.length));\n      }\n\n      var r = bytesToNumber(bytes.slice(0, 32));\n      var s = bytesToNumber(bytes.slice(32));\n      return new SchnorrSignature(r, s);\n    }\n  }]);\n\n  return SchnorrSignature;\n}();\n\nfunction schnorrGetPublicKey(privateKey) {\n  var P = Point.fromPrivateKey(privateKey);\n  return typeof privateKey === 'string' ? P.toHexX() : P.toRawX();\n}\n\nfunction schnorrSign(_x9, _x10) {\n  return _schnorrSign.apply(this, arguments);\n}\n\nfunction _schnorrSign() {\n  _schnorrSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(msgHash, privateKey) {\n    var auxRand,\n        n,\n        m,\n        d0,\n        rand,\n        P,\n        d,\n        t0h,\n        t,\n        k0h,\n        k0,\n        R,\n        k,\n        e,\n        sig,\n        isValid,\n        _args7 = arguments;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            auxRand = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : exports.utils.randomBytes();\n\n            if (!(msgHash == null)) {\n              _context7.next = 3;\n              break;\n            }\n\n            throw new TypeError(\"sign: Expected valid message, not \\\"\".concat(msgHash, \"\\\"\"));\n\n          case 3:\n            if (!privateKey) privateKey = 0n;\n            n = CURVE.n;\n            m = ensureBytes(msgHash);\n            d0 = normalizePrivateKey(privateKey);\n            rand = ensureBytes(auxRand);\n\n            if (!(rand.length !== 32)) {\n              _context7.next = 10;\n              break;\n            }\n\n            throw new TypeError('sign: Expected 32 bytes of aux randomness');\n\n          case 10:\n            P = Point.fromPrivateKey(d0);\n            d = hasEvenY(P) ? d0 : n - d0;\n            _context7.next = 14;\n            return taggedHash('BIP0340/aux', rand);\n\n          case 14:\n            t0h = _context7.sent;\n            t = d ^ t0h;\n            _context7.next = 18;\n            return taggedHash('BIP0340/nonce', pad32b(t), P.toRawX(), m);\n\n          case 18:\n            k0h = _context7.sent;\n            k0 = mod(k0h, n);\n\n            if (!(k0 === 0n)) {\n              _context7.next = 22;\n              break;\n            }\n\n            throw new Error('sign: Creation of signature failed. k is zero');\n\n          case 22:\n            R = Point.fromPrivateKey(k0);\n            k = hasEvenY(R) ? k0 : n - k0;\n            _context7.next = 26;\n            return createChallenge(R.x, P, m);\n\n          case 26:\n            e = _context7.sent;\n            sig = new SchnorrSignature(R.x, mod(k + e * d, n));\n            _context7.next = 30;\n            return schnorrVerify(sig.toRawBytes(), m, P.toRawX());\n\n          case 30:\n            isValid = _context7.sent;\n\n            if (isValid) {\n              _context7.next = 33;\n              break;\n            }\n\n            throw new Error('sign: Invalid signature produced');\n\n          case 33:\n            return _context7.abrupt(\"return\", typeof msgHash === 'string' ? sig.toHex() : sig.toRawBytes());\n\n          case 34:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _schnorrSign.apply(this, arguments);\n}\n\nfunction schnorrVerify(_x11, _x12, _x13) {\n  return _schnorrVerify.apply(this, arguments);\n}\n\nfunction _schnorrVerify() {\n  _schnorrVerify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(signature, msgHash, publicKey) {\n    var sig, m, P, e, sG, eP, R;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            sig = signature instanceof SchnorrSignature ? signature : SchnorrSignature.fromHex(signature);\n            m = typeof msgHash === 'string' ? hexToBytes(msgHash) : msgHash;\n            P = normalizePublicKey(publicKey);\n            _context8.next = 5;\n            return createChallenge(sig.r, P, m);\n\n          case 5:\n            e = _context8.sent;\n            sG = Point.fromPrivateKey(sig.s);\n            eP = P.multiply(e);\n            R = sG.subtract(eP);\n\n            if (!(R.equals(Point.BASE) || !hasEvenY(R) || R.x !== sig.r)) {\n              _context8.next = 11;\n              break;\n            }\n\n            return _context8.abrupt(\"return\", false);\n\n          case 11:\n            return _context8.abrupt(\"return\", true);\n\n          case 12:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _schnorrVerify.apply(this, arguments);\n}\n\nexports.schnorr = {\n  Signature: SchnorrSignature,\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify\n};\n\nPoint.BASE._setWindowSize(8);\n\nvar crypto = function () {\n  var webCrypto = typeof self === 'object' && 'crypto' in self ? self.crypto : undefined;\n  var nodeRequire = typeof module !== 'undefined' && typeof require === 'function';\n  return {\n    node: nodeRequire && !webCrypto ? require('crypto') : undefined,\n    web: webCrypto\n  };\n}();\n\nexports.utils = {\n  isValidPrivateKey: function isValidPrivateKey(privateKey) {\n    try {\n      normalizePrivateKey(privateKey);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  },\n  randomBytes: function randomBytes() {\n    var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      var randomBytes = crypto.node.randomBytes;\n      return new Uint8Array(randomBytes(bytesLength).buffer);\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: function randomPrivateKey() {\n    var i = 8;\n\n    while (i--) {\n      var b32 = exports.utils.randomBytes(32);\n      var num = bytesToNumber(b32);\n      if (isWithinCurveOrder(num) && num !== 1n) return b32;\n    }\n\n    throw new Error('Valid private key was not found in 8 iterations. PRNG is broken');\n  },\n  sha256: function () {\n    var _sha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(message) {\n      var buffer, createHash;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!crypto.web) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 3;\n              return crypto.web.subtle.digest('SHA-256', message.buffer);\n\n            case 3:\n              buffer = _context.sent;\n              return _context.abrupt(\"return\", new Uint8Array(buffer));\n\n            case 7:\n              if (!crypto.node) {\n                _context.next = 12;\n                break;\n              }\n\n              createHash = crypto.node.createHash;\n              return _context.abrupt(\"return\", Uint8Array.from(createHash('sha256').update(message).digest()));\n\n            case 12:\n              throw new Error(\"The environment doesn't have sha256 function\");\n\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function sha256(_x14) {\n      return _sha.apply(this, arguments);\n    }\n\n    return sha256;\n  }(),\n  hmacSha256: function () {\n    var _hmacSha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key) {\n      var _len3,\n          messages,\n          _key3,\n          ckey,\n          message,\n          buffer,\n          createHmac,\n          hash,\n          _iterator,\n          _step,\n          _message,\n          _args2 = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              for (_len3 = _args2.length, messages = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                messages[_key3 - 1] = _args2[_key3];\n              }\n\n              if (!crypto.web) {\n                _context2.next = 12;\n                break;\n              }\n\n              _context2.next = 4;\n              return crypto.web.subtle.importKey('raw', key, {\n                name: 'HMAC',\n                hash: {\n                  name: 'SHA-256'\n                }\n              }, false, ['sign']);\n\n            case 4:\n              ckey = _context2.sent;\n              message = concatBytes.apply(void 0, messages);\n              _context2.next = 8;\n              return crypto.web.subtle.sign('HMAC', ckey, message);\n\n            case 8:\n              buffer = _context2.sent;\n              return _context2.abrupt(\"return\", new Uint8Array(buffer));\n\n            case 12:\n              if (!crypto.node) {\n                _context2.next = 20;\n                break;\n              }\n\n              createHmac = crypto.node.createHmac;\n              hash = createHmac('sha256', key);\n              _iterator = _createForOfIteratorHelper(messages);\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  _message = _step.value;\n                  hash.update(_message);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n\n              return _context2.abrupt(\"return\", Uint8Array.from(hash.digest()));\n\n            case 20:\n              throw new Error(\"The environment doesn't have hmac-sha256 function\");\n\n            case 21:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function hmacSha256(_x15) {\n      return _hmacSha.apply(this, arguments);\n    }\n\n    return hmacSha256;\n  }(),\n  sha256Sync: undefined,\n  hmacSha256Sync: undefined,\n  precompute: function precompute() {\n    var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n    var cached = point === Point.BASE ? point : new Point(point.x, point.y);\n\n    cached._setWindowSize(windowSize);\n\n    cached.multiply(3n);\n    return cached;\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","utils","schnorr","verify","signSync","sign","getSharedSecret","recoverPublicKey","getPublicKey","SignResult","Signature","Point","CURVE","a","b","P","n","h","Gx","Gy","beta","weistrass","x","mod","USE_ENDOMORPHISM","JacobianPoint","y","z","other","az2","az3","bz2","bz3","X1","Y1","Z1","A","B","C","D","E","F","X3","Y3","Z3","TypeError","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","H","r","double","ZERO","HH","HHH","V","add","negate","scalar","isValidScalar","BigInt","p","d","splitScalarEndo","k1neg","k1","k2neg","k2","k1p","k2p","W","windows","points","base","window","push","i","affinePoint","equals","BASE","_WINDOW_SIZE","Error","precomputes","pointPrecomputes","get","precomputeWindow","normalizeZ","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","cached","Math","abs","point","fake","f1p","f2p","wNAF","invZ","invert","invZ2","toInv","invertBatch","map","toAffine","toAffineBatch","fromAffine","WeakMap","delete","isCompressed","hexToBytes","toHex","pad64","slice","toRawBytes","msg","left","right","multiply","bytes","isShort","length","bytesToNumber","y2","sqrtMod","isYOdd","isFirstByteOdd","assertValidity","hex","ensureBytes","header","fromCompressedHex","fromUncompressedHex","privateKey","normalizePrivateKey","msgHash","signature","recovery","Uint8Array","hexToNumber","sig","normalizeSignature","s","prefix","P_","fromHex","sP","multiplyUnsafe","hG","rinv","Q","subtract","sliceDer","parseInt","isWithinCurveOrder","toDERHex","sHex","numberToHex","rHex","rLen","sLen","toDERRawBytes","toCompactHex","str","bytesToHex","fn","parseByte","rEnd","rr","startsWith","separator","diff","sStart","ss","fromDER","concatBytes","arrays","reduce","arr","result","pad","uint8a","toString","padStart","num","pad32b","array","j","isSafeInteger","pow2","power","res","b2","b3","b6","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","number","modulo","u","v","q","m","gcd","nums","len","scratch","Array","acc","tmp","divNearest","POW_2_128","k","a1","b1","a2","c1","c2","truncateHash","hash","byteLength","delta","_abc6979","h1","h1n","fill","b0","from","getQRSrfc6979","privKey","hmac","hmacSha256","qrs","calcQRSFromK","getQRSrfc6979Sync","hmacSha256Sync","Promise","priv","max","key","normalizePublicKey","publicKey","fromPrivateKey","fromSignature","isPub","item","privateA","publicB","shared","QRSToSig","opts","canonical","der","recovered","adjustedS","HIGH_NUMBER","hashed","error","pubKey","s1","u1","u2","Ghs1","Prs1","R","taggedHash","tag","tagB","split","c","charCodeAt","sha256","tagH","messages","createChallenge","message","rx","toRawX","t","hasEvenY","SchnorrSignature","schnorrGetPublicKey","toHexX","schnorrSign","auxRand","randomBytes","d0","rand","t0h","k0h","k0","e","schnorrVerify","isValid","sG","eP","_setWindowSize","crypto","webCrypto","self","undefined","nodeRequire","module","require","node","web","isValidPrivateKey","bytesLength","getRandomValues","buffer","randomPrivateKey","b32","subtle","digest","createHash","update","importKey","name","ckey","createHmac","sha256Sync","precompute"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/noble-secp256k1/index.js"],"sourcesContent":["\"use strict\";\n/*! noble-secp256k1 - MIT License (c) Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.SignResult = exports.Signature = exports.Point = exports.CURVE = void 0;\nconst CURVE = {\n    a: 0n,\n    b: 7n,\n    P: 2n ** 256n - 2n ** 32n - 977n,\n    n: 2n ** 256n - 432420386565659656852420866394968145599n,\n    h: 1n,\n    Gx: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,\n    Gy: 32670510020758816978083085130507043184471273380659243275938904335757337482424n,\n    beta: 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501een,\n};\nexports.CURVE = CURVE;\nfunction weistrass(x) {\n    const { a, b } = CURVE;\n    return mod(x ** 3n + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === 0n;\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        return new JacobianPoint(p.x, p.y, 1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        const a = this;\n        const b = other;\n        const az2 = mod(a.z * a.z);\n        const az3 = mod(a.z * az2);\n        const bz2 = mod(b.z * b.z);\n        const bz3 = mod(b.z * bz2);\n        return mod(a.x * bz2) === mod(az2 * b.x) && mod(a.y * bz3) === mod(az3 * b.y);\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const A = mod(X1 ** 2n);\n        const B = mod(Y1 ** 2n);\n        const C = mod(B ** 2n);\n        const D = mod(2n * (mod(mod((X1 + B) ** 2n)) - A - C));\n        const E = mod(3n * A);\n        const F = mod(E ** 2n);\n        const X3 = mod(F - 2n * D);\n        const Y3 = mod(E * (D - X3) - 8n * C);\n        const Z3 = mod(2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        if (!(other instanceof JacobianPoint)) {\n            throw new TypeError('JacobianPoint#add: expected JacobianPoint');\n        }\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const X2 = other.x;\n        const Y2 = other.y;\n        const Z2 = other.z;\n        if (X2 === 0n || Y2 === 0n)\n            return this;\n        if (X1 === 0n || Y1 === 0n)\n            return other;\n        const Z1Z1 = mod(Z1 ** 2n);\n        const Z2Z2 = mod(Z2 ** 2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(Y1 * Z2 * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === 0n) {\n            if (r === 0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H ** 2n);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r ** 2n - HHH - 2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        if (!isValidScalar(scalar))\n            throw new TypeError('Point#multiply: expected valid scalar');\n        let n = mod(BigInt(scalar), CURVE.n);\n        if (!USE_ENDOMORPHISM) {\n            let p = JacobianPoint.ZERO;\n            let d = this;\n            while (n > 0n) {\n                if (n & 1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= 1n;\n            }\n            return p;\n        }\n        let [k1neg, k1, k2neg, k2] = splitScalarEndo(n);\n        let k1p = JacobianPoint.ZERO;\n        let k2p = JacobianPoint.ZERO;\n        let d = this;\n        while (k1 > 0n || k2 > 0n) {\n            if (k1 & 1n)\n                k1p = k1p.add(d);\n            if (k2 & 1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= 1n;\n            k2 >>= 1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        let points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.ZERO;\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += 1n;\n            }\n            if (wbits === 0) {\n                f = f.add(window % 2 ? precomputes[offset].negate() : precomputes[offset]);\n            }\n            else {\n                const cached = precomputes[offset + Math.abs(wbits) - 1];\n                p = p.add(wbits < 0 ? cached.negate() : cached);\n            }\n        }\n        return [p, f];\n    }\n    multiply(scalar, affinePoint) {\n        if (!isValidScalar(scalar))\n            throw new TypeError('Point#multiply: expected valid scalar');\n        let n = mod(BigInt(scalar), CURVE.n);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const [k1neg, k1, k2neg, k2] = splitScalarEndo(n);\n            let k1p, k2p, f1p, f2p;\n            [k1p, f1p] = this.wNAF(k1, affinePoint);\n            [k2p, f2p] = this.wNAF(k2, affinePoint);\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n            [point, fake] = [k1p.add(k2p), f1p.add(f2p)];\n        }\n        else {\n            [point, fake] = this.wNAF(n, affinePoint);\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const invZ2 = invZ ** 2n;\n        const x = mod(this.x * invZ2);\n        const y = mod(this.y * invZ2 * invZ);\n        return new Point(x, y);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, 1n);\nJacobianPoint.ZERO = new JacobianPoint(0n, 1n, 0n);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.slice(1));\n        const y2 = weistrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & 1n) === 1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.slice(1, 33));\n        const y = bytesToNumber(bytes.slice(33));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const header = bytes[0];\n        if (bytes.length === 32 || (bytes.length === 33 && (header === 0x02 || header === 0x03))) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (bytes.length === 65 && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${bytes.length}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        let h = msgHash instanceof Uint8Array ? bytesToNumber(msgHash) : hexToNumber(msgHash);\n        const sig = normalizeSignature(signature);\n        const { r, s } = sig;\n        if (recovery !== 0 && recovery !== 1) {\n            throw new Error('Cannot recover signature: invalid yParity bit');\n        }\n        const prefix = 2 + (recovery & 1);\n        const P_ = Point.fromHex(`0${prefix}${pad64(r)}`);\n        const sP = JacobianPoint.fromAffine(P_).multiplyUnsafe(s);\n        const hG = JacobianPoint.BASE.multiply(h);\n        const rinv = invert(r, CURVE.n);\n        const Q = sP.subtract(hG).multiplyUnsafe(rinv);\n        const point = Q.toAffine();\n        point.assertValidity();\n        return point;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = pad64(this.x);\n        if (isCompressed) {\n            return `${this.y & 1n ? '03' : '02'}${x}`;\n        }\n        else {\n            return `04${x}${pad64(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { P } = CURVE;\n        const { x, y } = this;\n        if (x === 0n || y === 0n || x >= P || y >= P)\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weistrass(x);\n        if ((left - right) % P !== 0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(0n, 0n);\nfunction sliceDer(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n    }\n    static fromCompact(hex) {\n        if (typeof hex !== 'string' && !(hex instanceof Uint8Array)) {\n            throw new TypeError(`Signature.fromCompact: Expected string or Uint8Array`);\n        }\n        const str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error('Signature.fromCompact: Expected 64-byte hex');\n        const sig = new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n        sig.assertValidity();\n        return sig;\n    }\n    static fromDER(hex) {\n        const fn = 'Signature.fromDER';\n        if (typeof hex !== 'string' && !(hex instanceof Uint8Array)) {\n            throw new TypeError(`${fn}: Expected string or Uint8Array`);\n        }\n        const str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;\n        const length = parseByte(str.slice(2, 4));\n        if (str.slice(0, 2) !== '30' || length !== str.length - 4 || str.slice(4, 6) !== '02') {\n            throw new Error(`${fn}: Invalid signature ${str}`);\n        }\n        const rLen = parseByte(str.slice(6, 8));\n        const rEnd = 8 + rLen;\n        const rr = str.slice(8, rEnd);\n        if (rr.startsWith('00') && parseByte(rr.slice(2, 4)) <= 0x7f) {\n            throw new Error(`${fn}: Invalid r with trailing length`);\n        }\n        const r = hexToNumber(rr);\n        const separator = str.slice(rEnd, rEnd + 2);\n        if (separator !== '02') {\n            throw new Error(`${fn}: Invalid r-s separator`);\n        }\n        const sLen = parseByte(str.slice(rEnd + 2, rEnd + 4));\n        const diff = length - sLen - rLen - 10;\n        if (diff > 0 || diff === -4) {\n            throw new Error(`${fn}: Invalid total length`);\n        }\n        if (sLen > length - rLen - 4) {\n            throw new Error(`${fn}: Invalid s`);\n        }\n        const sStart = rEnd + 4;\n        const ss = str.slice(sStart, sStart + sLen);\n        if (ss.startsWith('00') && parseByte(ss.slice(2, 4)) <= 0x7f) {\n            throw new Error(`${fn}: Invalid s with trailing length`);\n        }\n        const s = hexToNumber(ss);\n        const sig = new Signature(r, s);\n        sig.assertValidity();\n        return sig;\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    toDERRawBytes(isCompressed = false) {\n        return hexToBytes(this.toDERHex(isCompressed));\n    }\n    toDERHex(isCompressed = false) {\n        const sHex = sliceDer(numberToHex(this.s));\n        if (isCompressed)\n            return sHex;\n        const rHex = sliceDer(numberToHex(this.r));\n        const rLen = numberToHex(rHex.length / 2);\n        const sLen = numberToHex(sHex.length / 2);\n        const length = numberToHex(rHex.length / 2 + sHex.length / 2 + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return pad64(this.r) + pad64(this.s);\n    }\n}\nexports.Signature = Signature;\nexports.SignResult = Signature;\nfunction concatBytes(...arrays) {\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction bytesToHex(uint8a) {\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += uint8a[i].toString(16).padStart(2, '0');\n    }\n    return hex;\n}\nfunction pad64(num) {\n    return num.toString(16).padStart(64, '0');\n}\nfunction pad32b(num) {\n    return hexToBytes(pad64(num));\n}\nfunction numberToHex(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        array[i] = Number.parseInt(hex.slice(j, j + 2), 16);\n    }\n    return array;\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? hex : hexToBytes(hex);\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction parseByte(str) {\n    return Number.parseInt(str, 16) * 2;\n}\nfunction isValidScalar(num) {\n    if (typeof num === 'bigint' && num > 0n)\n        return true;\n    if (typeof num === 'number' && num > 0 && Number.isSafeInteger(num))\n        return true;\n    return false;\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= 0 ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > 0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, 3n) * b3) % P;\n    const b9 = (pow2(b6, 3n) * b3) % P;\n    const b11 = (pow2(b9, 2n) * b2) % P;\n    const b22 = (pow2(b11, 11n) * b11) % P;\n    const b44 = (pow2(b22, 22n) * b22) % P;\n    const b88 = (pow2(b44, 44n) * b44) % P;\n    const b176 = (pow2(b88, 88n) * b88) % P;\n    const b220 = (pow2(b176, 44n) * b44) % P;\n    const b223 = (pow2(b220, 3n) * b3) % P;\n    const t1 = (pow2(b223, 23n) * b22) % P;\n    const t2 = (pow2(t1, 6n) * b2) % P;\n    return pow2(t2, 2n);\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === 0n || modulo <= 0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let [x, y, u, v] = [0n, 1n, 1n, 0n];\n    while (a !== 0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        [b, a] = [a, r];\n        [x, y] = [u, v];\n        [u, v] = [m, n];\n    }\n    const gcd = b;\n    if (gcd !== 1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, n = CURVE.P) {\n    const len = nums.length;\n    const scratch = new Array(len);\n    let acc = 1n;\n    for (let i = 0; i < len; i++) {\n        if (nums[i] === 0n)\n            continue;\n        scratch[i] = acc;\n        acc = mod(acc * nums[i], n);\n    }\n    acc = invert(acc, n);\n    for (let i = len - 1; i >= 0; i--) {\n        if (nums[i] === 0n)\n            continue;\n        const tmp = mod(acc * nums[i], n);\n        nums[i] = mod(acc * scratch[i], n);\n        acc = tmp;\n    }\n    return nums;\n}\nconst divNearest = (a, b) => (a + b / 2n) / b;\nconst POW_2_128 = 2n ** 128n;\nfunction splitScalarEndo(k) {\n    const { n } = CURVE;\n    const a1 = 0x3086d221a7d46bcde86c90e49284eb15n;\n    const b1 = -0xe4437ed6010e88286f547fa90abfe4c3n;\n    const a2 = 0x114ca50f7a8e2f3f657c1108d9d44cfd8n;\n    const b2 = a1;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\n    const k1neg = k1 > POW_2_128;\n    const k2neg = k2 > POW_2_128;\n    if (k1neg)\n        k1 = n - k1;\n    if (k2neg)\n        k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128)\n        throw new Error('splitScalarEndo: Endomorphism failed');\n    return [k1neg, k1, k2neg, k2];\n}\nfunction truncateHash(hash) {\n    if (typeof hash !== 'string')\n        hash = bytesToHex(hash);\n    let msg = hexToNumber(hash || '0');\n    const byteLength = hash.length / 2;\n    const delta = byteLength * 8 - 256;\n    if (delta > 0) {\n        msg = msg >> BigInt(delta);\n    }\n    if (msg >= CURVE.n) {\n        msg -= CURVE.n;\n    }\n    return msg;\n}\nfunction _abc6979(msgHash, privateKey) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid msgHash, not \"${msgHash}\"`);\n    const num = typeof msgHash === 'string' ? hexToNumber(msgHash) : bytesToNumber(msgHash);\n    const h1 = pad32b(num);\n    const h1n = bytesToNumber(h1);\n    const x = pad32b(privateKey);\n    let v = new Uint8Array(32).fill(1);\n    let k = new Uint8Array(32).fill(0);\n    const b0 = Uint8Array.from([0x00]);\n    const b1 = Uint8Array.from([0x01]);\n    return [h1, h1n, x, v, k, b0, b1];\n}\nasync function getQRSrfc6979(msgHash, privateKey) {\n    const privKey = normalizePrivateKey(privateKey);\n    let [h1, h1n, x, v, k, b0, b1] = _abc6979(msgHash, privKey);\n    const hmac = exports.utils.hmacSha256;\n    k = await hmac(k, v, b0, x, h1);\n    v = await hmac(k, v);\n    k = await hmac(k, v, b1, x, h1);\n    v = await hmac(k, v);\n    for (let i = 0; i < 1000; i++) {\n        v = await hmac(k, v);\n        let qrs = calcQRSFromK(v, h1n, privKey);\n        if (qrs)\n            return qrs;\n        k = await hmac(k, v, b0);\n        v = await hmac(k, v);\n    }\n    throw new TypeError('secp256k1: Tried 1,000 k values for sign(), all were invalid');\n}\nfunction getQRSrfc6979Sync(msgHash, privateKey) {\n    const privKey = normalizePrivateKey(privateKey);\n    let [h1, h1n, x, v, k, b0, b1] = _abc6979(msgHash, privKey);\n    const hmac = exports.utils.hmacSha256Sync;\n    if (!hmac)\n        throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\n    k = hmac(k, v, b0, x, h1);\n    if (k instanceof Promise)\n        throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\n    v = hmac(k, v);\n    k = hmac(k, v, b1, x, h1);\n    v = hmac(k, v);\n    for (let i = 0; i < 1000; i++) {\n        v = hmac(k, v);\n        let qrs = calcQRSFromK(v, h1n, privKey);\n        if (qrs)\n            return qrs;\n        k = hmac(k, v, b0);\n        v = hmac(k, v);\n    }\n    throw new TypeError('secp256k1: Tried 1,000 k values for sign(), all were invalid');\n}\nfunction isWithinCurveOrder(num) {\n    return 0 < num && num < CURVE.n;\n}\nfunction calcQRSFromK(v, msg, priv) {\n    const k = bytesToNumber(v);\n    if (!isWithinCurveOrder(k))\n        return;\n    const max = CURVE.n;\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, max);\n    const s = mod(invert(k, max) * (msg + r * priv), max);\n    if (r === 0n || s === 0n)\n        return;\n    return [q, r, s];\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 64)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== 32)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    else {\n        return Signature.fromDER(signature);\n    }\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n    const point = Point.fromPrivateKey(privateKey);\n    if (typeof privateKey === 'string') {\n        return point.toHex(isCompressed);\n    }\n    return point.toRawBytes(isCompressed);\n}\nexports.getPublicKey = getPublicKey;\nfunction recoverPublicKey(msgHash, signature, recovery) {\n    const point = Point.fromSignature(msgHash, signature, recovery);\n    return typeof msgHash === 'string' ? point.toHex() : point.toRawBytes();\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction isPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === 33 || len === 65;\n    if (str)\n        return len === 66 || len === 130;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    const shared = b.multiply(normalizePrivateKey(privateA));\n    return typeof privateA === 'string'\n        ? shared.toHex(isCompressed)\n        : shared.toRawBytes(isCompressed);\n}\nexports.getSharedSecret = getSharedSecret;\nfunction QRSToSig(qrs, opts, str = false) {\n    const [q, r, s] = qrs;\n    let { canonical, der, recovered } = opts;\n    let recovery = (q.x === r ? 0 : 2) | Number(q.y & 1n);\n    let adjustedS = s;\n    const HIGH_NUMBER = CURVE.n >> 1n;\n    if (s > HIGH_NUMBER && canonical) {\n        adjustedS = CURVE.n - s;\n        recovery ^= 1;\n    }\n    const sig = new Signature(r, adjustedS);\n    sig.assertValidity();\n    const hex = der === false ? sig.toCompactHex() : sig.toDERHex();\n    const hashed = str ? hex : hexToBytes(hex);\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    return QRSToSig(await getQRSrfc6979(msgHash, privKey), opts, typeof msgHash === 'string');\n}\nexports.sign = sign;\nfunction signSync(msgHash, privKey, opts = {}) {\n    return QRSToSig(getQRSrfc6979Sync(msgHash, privKey), opts, typeof msgHash === 'string');\n}\nexports.signSync = signSync;\nfunction verify(signature, msgHash, publicKey) {\n    const { n } = CURVE;\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    const h = truncateHash(msgHash);\n    if (h === 0n)\n        return false;\n    const pubKey = JacobianPoint.fromAffine(normalizePublicKey(publicKey));\n    const s1 = invert(s, n);\n    const u1 = mod(h * s1, n);\n    const u2 = mod(r * s1, n);\n    const Ghs1 = JacobianPoint.BASE.multiply(u1);\n    const Prs1 = pubKey.multiplyUnsafe(u2);\n    const R = Ghs1.add(Prs1).toAffine();\n    const v = mod(R.x, n);\n    return v === r;\n}\nexports.verify = verify;\nasync function taggedHash(tag, ...messages) {\n    const tagB = new Uint8Array(tag.split('').map((c) => c.charCodeAt(0)));\n    const tagH = await exports.utils.sha256(tagB);\n    const h = await exports.utils.sha256(concatBytes(tagH, tagH, ...messages));\n    return bytesToNumber(h);\n}\nasync function createChallenge(x, P, message) {\n    const rx = pad32b(x);\n    const t = await taggedHash('BIP0340/challenge', rx, P.toRawX(), message);\n    return mod(t, CURVE.n);\n}\nfunction hasEvenY(point) {\n    return mod(point.y, 2n) === 0n;\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        if (r <= 0n || s <= 0n || r >= CURVE.P || s >= CURVE.n)\n            throw new Error('Invalid signature');\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64) {\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        }\n        const r = bytesToNumber(bytes.slice(0, 32));\n        const s = bytesToNumber(bytes.slice(32));\n        return new SchnorrSignature(r, s);\n    }\n    toHex() {\n        return pad64(this.r) + pad64(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    const P = Point.fromPrivateKey(privateKey);\n    return typeof privateKey === 'string' ? P.toHexX() : P.toRawX();\n}\nasync function schnorrSign(msgHash, privateKey, auxRand = exports.utils.randomBytes()) {\n    if (msgHash == null)\n        throw new TypeError(`sign: Expected valid message, not \"${msgHash}\"`);\n    if (!privateKey)\n        privateKey = 0n;\n    const { n } = CURVE;\n    const m = ensureBytes(msgHash);\n    const d0 = normalizePrivateKey(privateKey);\n    const rand = ensureBytes(auxRand);\n    if (rand.length !== 32)\n        throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    const P = Point.fromPrivateKey(d0);\n    const d = hasEvenY(P) ? d0 : n - d0;\n    const t0h = await taggedHash('BIP0340/aux', rand);\n    const t = d ^ t0h;\n    const k0h = await taggedHash('BIP0340/nonce', pad32b(t), P.toRawX(), m);\n    const k0 = mod(k0h, n);\n    if (k0 === 0n)\n        throw new Error('sign: Creation of signature failed. k is zero');\n    const R = Point.fromPrivateKey(k0);\n    const k = hasEvenY(R) ? k0 : n - k0;\n    const e = await createChallenge(R.x, P, m);\n    const sig = new SchnorrSignature(R.x, mod(k + e * d, n));\n    const isValid = await schnorrVerify(sig.toRawBytes(), m, P.toRawX());\n    if (!isValid)\n        throw new Error('sign: Invalid signature produced');\n    return typeof msgHash === 'string' ? sig.toHex() : sig.toRawBytes();\n}\nasync function schnorrVerify(signature, msgHash, publicKey) {\n    const sig = signature instanceof SchnorrSignature ? signature : SchnorrSignature.fromHex(signature);\n    const m = typeof msgHash === 'string' ? hexToBytes(msgHash) : msgHash;\n    const P = normalizePublicKey(publicKey);\n    const e = await createChallenge(sig.r, P, m);\n    const sG = Point.fromPrivateKey(sig.s);\n    const eP = P.multiply(e);\n    const R = sG.subtract(eP);\n    if (R.equals(Point.BASE) || !hasEvenY(R) || R.x !== sig.r)\n        return false;\n    return true;\n}\nexports.schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = (() => {\n    const webCrypto = typeof self === 'object' && 'crypto' in self ? self.crypto : undefined;\n    const nodeRequire = typeof module !== 'undefined' && typeof require === 'function';\n    return {\n        node: nodeRequire && !webCrypto ? require('crypto') : undefined,\n        web: webCrypto,\n    };\n})();\nexports.utils = {\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        let i = 8;\n        while (i--) {\n            const b32 = exports.utils.randomBytes(32);\n            const num = bytesToNumber(b32);\n            if (isWithinCurveOrder(num) && num !== 1n)\n                return b32;\n        }\n        throw new Error('Valid private key was not found in 8 iterations. PRNG is broken');\n    },\n    sha256: async (message) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            return Uint8Array.from(createHash('sha256').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            for (let message of messages) {\n                hash.update(message);\n            }\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(3n);\n        return cached;\n    },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}