{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:registrar'), {\n  error: debug('libp2p:registrar:err')\n});\n\nconst errcode = require('err-code');\n\nconst {\n  codes: {\n    ERR_INVALID_PARAMETERS\n  }\n} = require('./errors');\n\nconst Topology = require('libp2p-interfaces/src/topology');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./peer-store')} PeerStore\n * @typedef {import('./connection-manager')} ConnectionManager\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('./').HandlerProps} HandlerProps\n */\n\n/**\n *\n */\n\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\n\n\nclass Registrar {\n  /**\n   * @param {Object} props\n   * @param {PeerStore} props.peerStore\n   * @param {ConnectionManager} props.connectionManager\n   * @class\n   */\n  constructor(_ref) {\n    let {\n      peerStore,\n      connectionManager\n    } = _ref;\n    // Used on topology to listen for protocol changes\n    this.peerStore = peerStore;\n    this.connectionManager = connectionManager;\n    /**\n     * Map of topologies\n     *\n     * @type {Map<string, Topology>}\n     */\n\n    this.topologies = new Map();\n    /** @type {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void} */\n    // @ts-ignore handle is not optional\n\n    this._handle = undefined;\n    this._onDisconnect = this._onDisconnect.bind(this);\n    this.connectionManager.on('peer:disconnect', this._onDisconnect);\n  }\n  /**\n   * @returns {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void}\n   */\n\n\n  get handle() {\n    return this._handle;\n  }\n  /**\n   * @param {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void} handle\n   */\n\n\n  set handle(handle) {\n    this._handle = handle;\n  }\n  /**\n   * Get a connection with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection | null}\n   */\n\n\n  getConnection(peerId) {\n    return this.connectionManager.get(peerId);\n  }\n  /**\n   * Register handlers for a set of multicodecs given\n   *\n   * @param {Topology} topology - protocol topology\n   * @returns {string} registrar identifier\n   */\n\n\n  register(topology) {\n    if (!Topology.isTopology(topology)) {\n      log.error('topology must be an instance of interfaces/topology');\n      throw errcode(new Error('topology must be an instance of interfaces/topology'), ERR_INVALID_PARAMETERS);\n    } // Create topology\n\n\n    const id = (Math.random() * 1e9).toString(36) + Date.now();\n    this.topologies.set(id, topology); // Set registrar\n\n    topology.registrar = this;\n    return id;\n  }\n  /**\n   * Unregister topology.\n   *\n   * @param {string} id - registrar identifier\n   * @returns {boolean} unregistered successfully\n   */\n\n\n  unregister(id) {\n    return this.topologies.delete(id);\n  }\n  /**\n   * Remove a disconnected peer from the record\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n\n\n  _onDisconnect(connection) {\n    for (const [, topology] of this.topologies) {\n      topology.disconnect(connection.remotePeer);\n    }\n  }\n\n}\n\nmodule.exports = Registrar;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errcode","codes","ERR_INVALID_PARAMETERS","Topology","Registrar","constructor","peerStore","connectionManager","topologies","Map","_handle","undefined","_onDisconnect","bind","on","handle","getConnection","peerId","get","register","topology","isTopology","Error","id","Math","random","toString","Date","now","set","registrar","unregister","delete","connection","disconnect","remotePeer","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/registrar.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:registrar'), {\n  error: debug('libp2p:registrar:err')\n})\nconst errcode = require('err-code')\n\nconst {\n  codes: { ERR_INVALID_PARAMETERS }\n} = require('./errors')\nconst Topology = require('libp2p-interfaces/src/topology')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./peer-store')} PeerStore\n * @typedef {import('./connection-manager')} ConnectionManager\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('./').HandlerProps} HandlerProps\n */\n\n/**\n *\n */\n\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\nclass Registrar {\n  /**\n   * @param {Object} props\n   * @param {PeerStore} props.peerStore\n   * @param {ConnectionManager} props.connectionManager\n   * @class\n   */\n  constructor ({ peerStore, connectionManager }) {\n    // Used on topology to listen for protocol changes\n    this.peerStore = peerStore\n\n    this.connectionManager = connectionManager\n\n    /**\n     * Map of topologies\n     *\n     * @type {Map<string, Topology>}\n     */\n    this.topologies = new Map()\n\n    /** @type {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void} */\n    // @ts-ignore handle is not optional\n    this._handle = undefined\n\n    this._onDisconnect = this._onDisconnect.bind(this)\n    this.connectionManager.on('peer:disconnect', this._onDisconnect)\n  }\n\n  /**\n   * @returns {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void}\n   */\n  get handle () {\n    return this._handle\n  }\n\n  /**\n   * @param {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void} handle\n   */\n  set handle (handle) {\n    this._handle = handle\n  }\n\n  /**\n   * Get a connection with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection | null}\n   */\n  getConnection (peerId) {\n    return this.connectionManager.get(peerId)\n  }\n\n  /**\n   * Register handlers for a set of multicodecs given\n   *\n   * @param {Topology} topology - protocol topology\n   * @returns {string} registrar identifier\n   */\n  register (topology) {\n    if (!Topology.isTopology(topology)) {\n      log.error('topology must be an instance of interfaces/topology')\n      throw errcode(new Error('topology must be an instance of interfaces/topology'), ERR_INVALID_PARAMETERS)\n    }\n\n    // Create topology\n    const id = (Math.random() * 1e9).toString(36) + Date.now()\n\n    this.topologies.set(id, topology)\n\n    // Set registrar\n    topology.registrar = this\n\n    return id\n  }\n\n  /**\n   * Unregister topology.\n   *\n   * @param {string} id - registrar identifier\n   * @returns {boolean} unregistered successfully\n   */\n  unregister (id) {\n    return this.topologies.delete(id)\n  }\n\n  /**\n   * Remove a disconnected peer from the record\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n  _onDisconnect (connection) {\n    for (const [, topology] of this.topologies) {\n      topology.disconnect(connection.remotePeer)\n    }\n  }\n}\n\nmodule.exports = Registrar\n"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcJ,KAAK,CAAC,kBAAD,CAAnB,EAAyC;EACnDK,KAAK,EAAEL,KAAK,CAAC,sBAAD;AADuC,CAAzC,CAAZ;;AAGA,MAAMM,OAAO,GAAGL,OAAO,CAAC,UAAD,CAAvB;;AAEA,MAAM;EACJM,KAAK,EAAE;IAAEC;EAAF;AADH,IAEFP,OAAO,CAAC,UAAD,CAFX;;AAGA,MAAMQ,QAAQ,GAAGR,OAAO,CAAC,gCAAD,CAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMS,SAAN,CAAgB;EACd;AACF;AACA;AACA;AACA;AACA;EACEC,WAAW,OAAoC;IAAA,IAAlC;MAAEC,SAAF;MAAaC;IAAb,CAAkC;IAC7C;IACA,KAAKD,SAAL,GAAiBA,SAAjB;IAEA,KAAKC,iBAAL,GAAyBA,iBAAzB;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,UAAL,GAAkB,IAAIC,GAAJ,EAAlB;IAEA;IACA;;IACA,KAAKC,OAAL,GAAeC,SAAf;IAEA,KAAKC,aAAL,GAAqB,KAAKA,aAAL,CAAmBC,IAAnB,CAAwB,IAAxB,CAArB;IACA,KAAKN,iBAAL,CAAuBO,EAAvB,CAA0B,iBAA1B,EAA6C,KAAKF,aAAlD;EACD;EAED;AACF;AACA;;;EACY,IAANG,MAAM,GAAI;IACZ,OAAO,KAAKL,OAAZ;EACD;EAED;AACF;AACA;;;EACY,IAANK,MAAM,CAAEA,MAAF,EAAU;IAClB,KAAKL,OAAL,GAAeK,MAAf;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEC,aAAa,CAAEC,MAAF,EAAU;IACrB,OAAO,KAAKV,iBAAL,CAAuBW,GAAvB,CAA2BD,MAA3B,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEE,QAAQ,CAAEC,QAAF,EAAY;IAClB,IAAI,CAACjB,QAAQ,CAACkB,UAAT,CAAoBD,QAApB,CAAL,EAAoC;MAClCxB,GAAG,CAACG,KAAJ,CAAU,qDAAV;MACA,MAAMC,OAAO,CAAC,IAAIsB,KAAJ,CAAU,qDAAV,CAAD,EAAmEpB,sBAAnE,CAAb;IACD,CAJiB,CAMlB;;;IACA,MAAMqB,EAAE,GAAG,CAACC,IAAI,CAACC,MAAL,KAAgB,GAAjB,EAAsBC,QAAtB,CAA+B,EAA/B,IAAqCC,IAAI,CAACC,GAAL,EAAhD;IAEA,KAAKpB,UAAL,CAAgBqB,GAAhB,CAAoBN,EAApB,EAAwBH,QAAxB,EATkB,CAWlB;;IACAA,QAAQ,CAACU,SAAT,GAAqB,IAArB;IAEA,OAAOP,EAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEQ,UAAU,CAAER,EAAF,EAAM;IACd,OAAO,KAAKf,UAAL,CAAgBwB,MAAhB,CAAuBT,EAAvB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEX,aAAa,CAAEqB,UAAF,EAAc;IACzB,KAAK,MAAM,GAAGb,QAAH,CAAX,IAA2B,KAAKZ,UAAhC,EAA4C;MAC1CY,QAAQ,CAACc,UAAT,CAAoBD,UAAU,CAACE,UAA/B;IACD;EACF;;AA/Fa;;AAkGhBC,MAAM,CAACC,OAAP,GAAiBjC,SAAjB"},"metadata":{},"sourceType":"script"}