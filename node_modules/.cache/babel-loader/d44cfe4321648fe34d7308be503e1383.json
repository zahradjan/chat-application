{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require('multiformats/hashes/sha2'),\n    sha256 = _require.sha256;\n\nvar errcode = require('err-code');\n\nvar _require2 = require('uint8arrays/equals'),\n    uint8ArrayEquals = _require2.equals;\n\nvar _require3 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require3.toString;\n\nrequire('node-forge/lib/sha512');\n\nvar forge = require('node-forge/lib/forge');\n\nvar crypto = require('./rsa');\n\nvar pbm = require('./keys');\n\nvar exporter = require('./exporter');\n\nvar RsaPublicKey = /*#__PURE__*/function () {\n  function RsaPublicKey(key) {\n    _classCallCheck(this, RsaPublicKey);\n\n    this._key = key;\n  }\n\n  _createClass(RsaPublicKey, [{\n    key: \"verify\",\n    value: function () {\n      var _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data, sig) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", crypto.hashAndVerify(this._key, sig, data));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function verify(_x, _x2) {\n        return _verify.apply(this, arguments);\n      }\n\n      return verify;\n    }()\n  }, {\n    key: \"marshal\",\n    value: function marshal() {\n      return crypto.utils.jwkToPkix(this._key);\n    }\n  }, {\n    key: \"bytes\",\n    get: function get() {\n      return pbm.PublicKey.encode({\n        Type: pbm.KeyType.RSA,\n        Data: this.marshal()\n      }).finish();\n    }\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(bytes) {\n      return crypto.encrypt(this._key, bytes);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(key) {\n      return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n  }, {\n    key: \"hash\",\n    value: function () {\n      var _hash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _yield$sha256$digest, bytes;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return sha256.digest(this.bytes);\n\n              case 2:\n                _yield$sha256$digest = _context2.sent;\n                bytes = _yield$sha256$digest.bytes;\n                return _context2.abrupt(\"return\", bytes);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function hash() {\n        return _hash.apply(this, arguments);\n      }\n\n      return hash;\n    }()\n  }]);\n\n  return RsaPublicKey;\n}();\n\nvar RsaPrivateKey = /*#__PURE__*/function () {\n  // key       - Object of the jwk format\n  // publicKey - Uint8Array of the spki format\n  function RsaPrivateKey(key, publicKey) {\n    _classCallCheck(this, RsaPrivateKey);\n\n    this._key = key;\n    this._publicKey = publicKey;\n  }\n\n  _createClass(RsaPrivateKey, [{\n    key: \"genSecret\",\n    value: function genSecret() {\n      return crypto.getRandomValues(16);\n    }\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(message) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", crypto.hashAndSign(this._key, message));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function sign(_x3) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n  }, {\n    key: \"public\",\n    get: function get() {\n      if (!this._publicKey) {\n        throw errcode(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED');\n      }\n\n      return new RsaPublicKey(this._publicKey);\n    }\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(bytes) {\n      return crypto.decrypt(this._key, bytes);\n    }\n  }, {\n    key: \"marshal\",\n    value: function marshal() {\n      return crypto.utils.jwkToPkcs1(this._key);\n    }\n  }, {\n    key: \"bytes\",\n    get: function get() {\n      return pbm.PrivateKey.encode({\n        Type: pbm.KeyType.RSA,\n        Data: this.marshal()\n      }).finish();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(key) {\n      return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n  }, {\n    key: \"hash\",\n    value: function () {\n      var _hash2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _yield$sha256$digest2, bytes;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return sha256.digest(this.bytes);\n\n              case 2:\n                _yield$sha256$digest2 = _context4.sent;\n                bytes = _yield$sha256$digest2.bytes;\n                return _context4.abrupt(\"return\", bytes);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function hash() {\n        return _hash2.apply(this, arguments);\n      }\n\n      return hash;\n    }()\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @returns {Promise<string>}\n     */\n\n  }, {\n    key: \"id\",\n    value: function () {\n      var _id = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var hash;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.public.hash();\n\n              case 2:\n                hash = _context5.sent;\n                return _context5.abrupt(\"return\", uint8ArrayToString(hash, 'base58btc'));\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function id() {\n        return _id.apply(this, arguments);\n      }\n\n      return id;\n    }()\n    /**\n     * Exports the key into a password protected PEM format\n     *\n     * @param {string} password - The password to read the encrypted PEM\n     * @param {string} [format=pkcs-8] - The format in which to export as\n     */\n\n  }, {\n    key: \"export\",\n    value: function () {\n      var _export2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(password) {\n        var format,\n            buffer,\n            asn1,\n            privateKey,\n            options,\n            _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                format = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : 'pkcs-8';\n\n                if (!(format === 'pkcs-8')) {\n                  _context6.next = 9;\n                  break;\n                }\n\n                buffer = new forge.util.ByteBuffer(this.marshal());\n                asn1 = forge.asn1.fromDer(buffer);\n                privateKey = forge.pki.privateKeyFromAsn1(asn1);\n                options = {\n                  algorithm: 'aes256',\n                  count: 10000,\n                  saltSize: 128 / 8,\n                  prfAlgorithm: 'sha512'\n                };\n                return _context6.abrupt(\"return\", forge.pki.encryptRsaPrivateKey(privateKey, password, options));\n\n              case 9:\n                if (!(format === 'libp2p-key')) {\n                  _context6.next = 13;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", exporter.export(this.bytes, password));\n\n              case 13:\n                throw errcode(new Error(\"export format '\".concat(format, \"' is not supported\")), 'ERR_INVALID_EXPORT_FORMAT');\n\n              case 14:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _export(_x4) {\n        return _export2.apply(this, arguments);\n      }\n\n      return _export;\n    }()\n  }]);\n\n  return RsaPrivateKey;\n}();\n\nfunction unmarshalRsaPrivateKey(_x5) {\n  return _unmarshalRsaPrivateKey.apply(this, arguments);\n}\n\nfunction _unmarshalRsaPrivateKey() {\n  _unmarshalRsaPrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(bytes) {\n    var jwk, keys;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            jwk = crypto.utils.pkcs1ToJwk(bytes);\n            _context7.next = 3;\n            return crypto.unmarshalPrivateKey(jwk);\n\n          case 3:\n            keys = _context7.sent;\n            return _context7.abrupt(\"return\", new RsaPrivateKey(keys.privateKey, keys.publicKey));\n\n          case 5:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _unmarshalRsaPrivateKey.apply(this, arguments);\n}\n\nfunction unmarshalRsaPublicKey(bytes) {\n  var jwk = crypto.utils.pkixToJwk(bytes);\n  return new RsaPublicKey(jwk);\n}\n\nfunction fromJwk(_x6) {\n  return _fromJwk.apply(this, arguments);\n}\n\nfunction _fromJwk() {\n  _fromJwk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(jwk) {\n    var keys;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return crypto.unmarshalPrivateKey(jwk);\n\n          case 2:\n            keys = _context8.sent;\n            return _context8.abrupt(\"return\", new RsaPrivateKey(keys.privateKey, keys.publicKey));\n\n          case 4:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _fromJwk.apply(this, arguments);\n}\n\nfunction generateKeyPair(_x7) {\n  return _generateKeyPair.apply(this, arguments);\n}\n\nfunction _generateKeyPair() {\n  _generateKeyPair = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(bits) {\n    var keys;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.next = 2;\n            return crypto.generateKey(bits);\n\n          case 2:\n            keys = _context9.sent;\n            return _context9.abrupt(\"return\", new RsaPrivateKey(keys.privateKey, keys.publicKey));\n\n          case 4:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return _generateKeyPair.apply(this, arguments);\n}\n\nmodule.exports = {\n  RsaPublicKey: RsaPublicKey,\n  RsaPrivateKey: RsaPrivateKey,\n  unmarshalRsaPublicKey: unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey: unmarshalRsaPrivateKey,\n  generateKeyPair: generateKeyPair,\n  fromJwk: fromJwk\n};","map":{"version":3,"names":["require","sha256","errcode","uint8ArrayEquals","equals","uint8ArrayToString","toString","forge","crypto","pbm","exporter","RsaPublicKey","key","_key","data","sig","hashAndVerify","utils","jwkToPkix","PublicKey","encode","Type","KeyType","RSA","Data","marshal","finish","bytes","encrypt","digest","RsaPrivateKey","publicKey","_publicKey","getRandomValues","message","hashAndSign","Error","decrypt","jwkToPkcs1","PrivateKey","public","hash","password","format","buffer","util","ByteBuffer","asn1","fromDer","privateKey","pki","privateKeyFromAsn1","options","algorithm","count","saltSize","prfAlgorithm","encryptRsaPrivateKey","export","unmarshalRsaPrivateKey","jwk","pkcs1ToJwk","unmarshalPrivateKey","keys","unmarshalRsaPublicKey","pkixToJwk","fromJwk","generateKeyPair","bits","generateKey","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-delegated-content-routing/node_modules/libp2p-crypto/src/keys/rsa-class.js"],"sourcesContent":["'use strict'\n\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst errcode = require('err-code')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nrequire('node-forge/lib/sha512')\nconst forge = require('node-forge/lib/forge')\n\nconst crypto = require('./rsa')\nconst pbm = require('./keys')\nconst exporter = require('./exporter')\n\nclass RsaPublicKey {\n  constructor (key) {\n    this._key = key\n  }\n\n  async verify (data, sig) { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkix(this._key)\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish()\n  }\n\n  encrypt (bytes) {\n    return crypto.encrypt(this._key, bytes)\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Uint8Array of the spki format\n  constructor (key, publicKey) {\n    this._key = key\n    this._publicKey = publicKey\n  }\n\n  genSecret () {\n    return crypto.getRandomValues(16)\n  }\n\n  async sign (message) { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public () {\n    if (!this._publicKey) {\n      throw errcode(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED')\n    }\n\n    return new RsaPublicKey(this._publicKey)\n  }\n\n  decrypt (bytes) {\n    return crypto.decrypt(this._key, bytes)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkcs1(this._key)\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish()\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n  async id () {\n    const hash = await this.public.hash()\n    return uint8ArrayToString(hash, 'base58btc')\n  }\n\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {string} [format=pkcs-8] - The format in which to export as\n   */\n  async export (password, format = 'pkcs-8') { // eslint-disable-line require-await\n    if (format === 'pkcs-8') {\n      const buffer = new forge.util.ByteBuffer(this.marshal())\n      const asn1 = forge.asn1.fromDer(buffer)\n      const privateKey = forge.pki.privateKeyFromAsn1(asn1)\n\n      const options = {\n        algorithm: 'aes256',\n        count: 10000,\n        saltSize: 128 / 8,\n        prfAlgorithm: 'sha512'\n      }\n      return forge.pki.encryptRsaPrivateKey(privateKey, password, options)\n    } else if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password)\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nasync function unmarshalRsaPrivateKey (bytes) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes)\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nfunction unmarshalRsaPublicKey (bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes)\n  return new RsaPublicKey(jwk)\n}\n\nasync function fromJwk (jwk) {\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nasync function generateKeyPair (bits) {\n  const keys = await crypto.generateKey(bits)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}