{"ast":null,"code":"'use strict';\n\nconst {\n  Adapter,\n  Key,\n  Errors\n} = require('interface-datastore');\n\nconst sh = require('./shard');\n\nconst KeytransformStore = require('./keytransform');\n\nconst shardKey = new Key(sh.SHARDING_FN);\nconst shardReadmeKey = new Key(sh.README_FN);\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').QueryFilter} QueryFilter\n * @typedef {import('interface-datastore').QueryOrder} QueryOrder\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').KeyQueryFilter} KeyQueryFilter\n * @typedef {import('interface-datastore').KeyQueryOrder} KeyQueryOrder\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('./types').Shard} Shard\n *\n */\n\n/**\n * @template TValue\n * @typedef {import('interface-store').Await<TValue> } Await\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\n\nclass ShardingDatastore extends Adapter {\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  constructor(store, shard) {\n    super();\n    this.child = new KeytransformStore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    });\n    this.shard = shard;\n  }\n\n  async open() {\n    await this.child.open();\n    this.shard = await ShardingDatastore.create(this.child, this.shard);\n  }\n  /**\n   * @param {Key} key\n   */\n\n\n  _convertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    const parent = new Key(this.shard.fun(s));\n    return parent.child(key);\n  }\n  /**\n   * @param {Key} key\n   */\n\n\n  _invertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    return Key.withNamespaces(key.list().slice(1));\n  }\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n\n\n  static async createOrOpen(store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard);\n    } catch (err) {\n      if (err && err.message !== 'datastore exists') throw err;\n    }\n\n    return ShardingDatastore.open(store);\n  }\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   */\n\n\n  static async open(store) {\n    const shard = await sh.readShardFun('/', store);\n    return new ShardingDatastore(store, shard);\n  }\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n\n\n  static async create(store, shard) {\n    const hasShard = await store.has(shardKey);\n\n    if (!hasShard && !shard) {\n      throw Errors.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'));\n    }\n\n    if (!hasShard) {\n      // @ts-ignore i have no idea what putRaw is or saw any implementation\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n      await Promise.all([put(shardKey, new TextEncoder().encode(shard.toString() + '\\n')), put(shardReadmeKey, new TextEncoder().encode(sh.readme))]);\n      return shard;\n    } // test shards\n\n\n    const diskShard = await sh.readShardFun('/', store);\n    const a = (diskShard || '').toString();\n    const b = shard.toString();\n\n    if (a !== b) {\n      throw new Error(`specified fun ${b} does not match repo shard fun ${a}`);\n    }\n\n    return diskShard;\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} val\n   * @param {Options} [options]\n   */\n\n\n  put(key, val, options) {\n    return this.child.put(key, val, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  get(key, options) {\n    return this.child.get(key, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  has(key, options) {\n    return this.child.has(key, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  delete(key, options) {\n    return this.child.delete(key, options);\n  }\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n\n\n  async *putMany(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.child.putMany(source, options);\n  }\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Uint8Array>}\n   */\n\n\n  async *getMany(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.child.getMany(source, options);\n  }\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n\n\n  async *deleteMany(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    yield* this.child.deleteMany(source, options);\n  }\n\n  batch() {\n    return this.child.batch();\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    const tq = {\n      offset: q.offset,\n      limit: q.limit,\n\n      /** @type {QueryOrder[]} */\n      orders: [],\n\n      /** @type {QueryFilter[]} */\n      filters: [\n      /** @type {QueryFilter} */\n      e => e.key.toString() !== shardKey.toString(),\n      /** @type {QueryFilter} */\n      e => e.key.toString() !== shardReadmeKey.toString()]\n    };\n    const {\n      prefix\n    } = q;\n\n    if (prefix != null) {\n      tq.filters.push(e => {\n        return this._invertKey(e.key).toString().startsWith(prefix);\n      });\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map(f => {\n        /** @type {QueryFilter} */\n        const filter = _ref => {\n          let {\n            key,\n            value\n          } = _ref;\n          return f({\n            key: this._invertKey(key),\n            value\n          });\n        };\n\n        return filter;\n      });\n      tq.filters = tq.filters.concat(filters);\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map(o => {\n        /** @type {QueryOrder} */\n        const order = (a, b) => {\n          return o({\n            key: this._invertKey(a.key),\n            value: a.value\n          }, {\n            key: this._invertKey(b.key),\n            value: b.value\n          });\n        };\n\n        return order;\n      });\n    }\n\n    return this.child.query(tq, options);\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n\n\n  queryKeys(q, options) {\n    const tq = {\n      offset: q.offset,\n      limit: q.limit,\n\n      /** @type {KeyQueryOrder[]} */\n      orders: [],\n\n      /** @type {KeyQueryFilter[]} */\n      filters: [\n      /** @type {KeyQueryFilter} */\n      key => key.toString() !== shardKey.toString(),\n      /** @type {KeyQueryFilter} */\n      key => key.toString() !== shardReadmeKey.toString()]\n    };\n    const {\n      prefix\n    } = q;\n\n    if (prefix != null) {\n      tq.filters.push(key => {\n        return this._invertKey(key).toString().startsWith(prefix);\n      });\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map(f => {\n        /** @type {KeyQueryFilter} */\n        const filter = key => {\n          return f(this._invertKey(key));\n        };\n\n        return filter;\n      });\n      tq.filters = tq.filters.concat(filters);\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map(o => {\n        /** @type {KeyQueryOrder} */\n        const order = (a, b) => o(this._invertKey(a), this._invertKey(b));\n\n        return order;\n      });\n    }\n\n    return this.child.queryKeys(tq, options);\n  }\n\n  close() {\n    return this.child.close();\n  }\n\n}\n\nmodule.exports = ShardingDatastore;","map":{"version":3,"names":["Adapter","Key","Errors","require","sh","KeytransformStore","shardKey","SHARDING_FN","shardReadmeKey","README_FN","ShardingDatastore","constructor","store","shard","child","convert","_convertKey","bind","invert","_invertKey","open","create","key","s","toString","parent","fun","withNamespaces","list","slice","createOrOpen","err","message","readShardFun","hasShard","has","dbOpenFailedError","Error","put","putRaw","Promise","all","TextEncoder","encode","readme","diskShard","a","b","val","options","get","delete","putMany","source","getMany","deleteMany","batch","query","q","tq","offset","limit","orders","filters","e","prefix","push","startsWith","map","f","filter","value","concat","o","order","queryKeys","close","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/datastore-core/src/sharding.js"],"sourcesContent":["'use strict'\n\nconst { Adapter, Key, Errors } = require('interface-datastore')\nconst sh = require('./shard')\nconst KeytransformStore = require('./keytransform')\n\nconst shardKey = new Key(sh.SHARDING_FN)\nconst shardReadmeKey = new Key(sh.README_FN)\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').QueryFilter} QueryFilter\n * @typedef {import('interface-datastore').QueryOrder} QueryOrder\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').KeyQueryFilter} KeyQueryFilter\n * @typedef {import('interface-datastore').KeyQueryOrder} KeyQueryOrder\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('./types').Shard} Shard\n *\n */\n/**\n * @template TValue\n * @typedef {import('interface-store').Await<TValue> } Await\n */\n\n/**\n * @template TEntry\n * @typedef {import('interface-store').AwaitIterable<TEntry>} AwaitIterable\n */\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\nclass ShardingDatastore extends Adapter {\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  constructor (store, shard) {\n    super()\n\n    this.child = new KeytransformStore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    })\n    this.shard = shard\n  }\n\n  async open () {\n    await this.child.open()\n\n    this.shard = await ShardingDatastore.create(this.child, this.shard)\n  }\n\n  /**\n   * @param {Key} key\n   */\n  _convertKey (key) {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n\n    const parent = new Key(this.shard.fun(s))\n    return parent.child(key)\n  }\n\n  /**\n   * @param {Key} key\n   */\n  _invertKey (key) {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n    return Key.withNamespaces(key.list().slice(1))\n  }\n\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  static async createOrOpen (store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard)\n    } catch (err) {\n      if (err && err.message !== 'datastore exists') throw err\n    }\n    return ShardingDatastore.open(store)\n  }\n\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   */\n  static async open (store) {\n    const shard = await sh.readShardFun('/', store)\n    return new ShardingDatastore(store, shard)\n  }\n\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  static async create (store, shard) {\n    const hasShard = await store.has(shardKey)\n    if (!hasShard && !shard) {\n      throw Errors.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'))\n    }\n    if (!hasShard) {\n      // @ts-ignore i have no idea what putRaw is or saw any implementation\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store)\n      await Promise.all([\n        put(shardKey, new TextEncoder().encode(shard.toString() + '\\n')),\n        put(shardReadmeKey, new TextEncoder().encode(sh.readme))\n      ])\n\n      return shard\n    }\n\n    // test shards\n    const diskShard = await sh.readShardFun('/', store)\n    const a = (diskShard || '').toString()\n    const b = shard.toString()\n    if (a !== b) {\n      throw new Error(`specified fun ${b} does not match repo shard fun ${a}`)\n    }\n    return diskShard\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} val\n   * @param {Options} [options]\n   */\n  put (key, val, options) {\n    return this.child.put(key, val, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  get (key, options) {\n    return this.child.get(key, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  has (key, options) {\n    return this.child.has(key, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  delete (key, options) {\n    return this.child.delete(key, options)\n  }\n\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n  async * putMany (source, options = {}) {\n    yield * this.child.putMany(source, options)\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Uint8Array>}\n   */\n  async * getMany (source, options = {}) {\n    yield * this.child.getMany(source, options)\n  }\n\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n  async * deleteMany (source, options = {}) {\n    yield * this.child.deleteMany(source, options)\n  }\n\n  batch () {\n    return this.child.batch()\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query (q, options) {\n    const tq = {\n      offset: q.offset,\n      limit: q.limit,\n      /** @type {QueryOrder[]} */\n      orders: [],\n      /** @type {QueryFilter[]} */\n      filters: [\n        /** @type {QueryFilter} */\n        e => e.key.toString() !== shardKey.toString(),\n        /** @type {QueryFilter} */\n        e => e.key.toString() !== shardReadmeKey.toString()\n      ]\n    }\n\n    const { prefix } = q\n    if (prefix != null) {\n      tq.filters.push((e) => {\n        return this._invertKey(e.key).toString().startsWith(prefix)\n      })\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map(f => {\n        /** @type {QueryFilter} */\n        const filter = ({ key, value }) => {\n          return f({\n            key: this._invertKey(key),\n            value\n          })\n        }\n\n        return filter\n      })\n      tq.filters = tq.filters.concat(filters)\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map(o => {\n        /** @type {QueryOrder} */\n        const order = (a, b) => {\n          return o({\n            key: this._invertKey(a.key),\n            value: a.value\n          }, {\n            key: this._invertKey(b.key),\n            value: b.value\n          })\n        }\n\n        return order\n      })\n    }\n\n    return this.child.query(tq, options)\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys (q, options) {\n    const tq = {\n      offset: q.offset,\n      limit: q.limit,\n      /** @type {KeyQueryOrder[]} */\n      orders: [],\n      /** @type {KeyQueryFilter[]} */\n      filters: [\n        /** @type {KeyQueryFilter} */\n        key => key.toString() !== shardKey.toString(),\n        /** @type {KeyQueryFilter} */\n        key => key.toString() !== shardReadmeKey.toString()\n      ]\n    }\n\n    const { prefix } = q\n    if (prefix != null) {\n      tq.filters.push((key) => {\n        return this._invertKey(key).toString().startsWith(prefix)\n      })\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map(f => {\n        /** @type {KeyQueryFilter} */\n        const filter = (key) => {\n          return f(this._invertKey(key))\n        }\n\n        return filter\n      })\n      tq.filters = tq.filters.concat(filters)\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map(o => {\n        /** @type {KeyQueryOrder} */\n        const order = (a, b) => o(this._invertKey(a), this._invertKey(b))\n\n        return order\n      })\n    }\n\n    return this.child.queryKeys(tq, options)\n  }\n\n  close () {\n    return this.child.close()\n  }\n}\n\nmodule.exports = ShardingDatastore\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}