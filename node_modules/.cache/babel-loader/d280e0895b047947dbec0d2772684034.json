{"ast":null,"code":"/* eslint max-statements: 0 */\n// Support for functions returning promise\n\"use strict\";\n\nvar objectMap = require(\"es5-ext/object/map\"),\n    primitiveSet = require(\"es5-ext/object/primitive-set\"),\n    ensureString = require(\"es5-ext/object/validate-stringifiable-value\"),\n    toShortString = require(\"es5-ext/to-short-string-representation\"),\n    isPromise = require(\"is-promise\"),\n    nextTick = require(\"next-tick\");\n\nvar create = Object.create,\n    supportedModes = primitiveSet(\"then\", \"then:finally\", \"done\", \"done:finally\");\n\nrequire(\"../lib/registered-extensions\").promise = function (mode, conf) {\n  var waiting = create(null),\n      cache = create(null),\n      promises = create(null);\n\n  if (mode === true) {\n    mode = null;\n  } else {\n    mode = ensureString(mode);\n\n    if (!supportedModes[mode]) {\n      throw new TypeError(\"'\" + toShortString(mode) + \"' is not valid promise mode\");\n    }\n  } // After not from cache call\n\n\n  conf.on(\"set\", function (id, ignore, promise) {\n    var isFailed = false;\n\n    if (!isPromise(promise)) {\n      // Non promise result\n      cache[id] = promise;\n      conf.emit(\"setasync\", id, 1);\n      return;\n    }\n\n    waiting[id] = 1;\n    promises[id] = promise;\n\n    var onSuccess = function (result) {\n      var count = waiting[id];\n\n      if (isFailed) {\n        throw new Error(\"Memoizee error: Detected unordered then|done & finally resolution, which \" + \"in turn makes proper detection of success/failure impossible (when in \" + \"'done:finally' mode)\\n\" + \"Consider to rely on 'then' or 'done' mode instead.\");\n      }\n\n      if (!count) return; // Deleted from cache before resolved\n\n      delete waiting[id];\n      cache[id] = result;\n      conf.emit(\"setasync\", id, count);\n    };\n\n    var onFailure = function () {\n      isFailed = true;\n      if (!waiting[id]) return; // Deleted from cache (or succeed in case of finally)\n\n      delete waiting[id];\n      delete promises[id];\n      conf.delete(id);\n    };\n\n    var resolvedMode = mode;\n    if (!resolvedMode) resolvedMode = \"then\";\n\n    if (resolvedMode === \"then\") {\n      var nextTickFailure = function () {\n        nextTick(onFailure);\n      }; // Eventual finally needs to be attached to non rejected promise\n      // (so we not force propagation of unhandled rejection)\n\n\n      promise = promise.then(function (result) {\n        nextTick(onSuccess.bind(this, result));\n      }, nextTickFailure); // If `finally` is a function we attach to it to remove cancelled promises.\n\n      if (typeof promise.finally === \"function\") {\n        promise.finally(nextTickFailure);\n      }\n    } else if (resolvedMode === \"done\") {\n      // Not recommended, as it may mute any eventual \"Unhandled error\" events\n      if (typeof promise.done !== \"function\") {\n        throw new Error(\"Memoizee error: Retrieved promise does not implement 'done' \" + \"in 'done' mode\");\n      }\n\n      promise.done(onSuccess, onFailure);\n    } else if (resolvedMode === \"done:finally\") {\n      // The only mode with no side effects assuming library does not throw unconditionally\n      // for rejected promises.\n      if (typeof promise.done !== \"function\") {\n        throw new Error(\"Memoizee error: Retrieved promise does not implement 'done' \" + \"in 'done:finally' mode\");\n      }\n\n      if (typeof promise.finally !== \"function\") {\n        throw new Error(\"Memoizee error: Retrieved promise does not implement 'finally' \" + \"in 'done:finally' mode\");\n      }\n\n      promise.done(onSuccess);\n      promise.finally(onFailure);\n    }\n  }); // From cache (sync)\n\n  conf.on(\"get\", function (id, args, context) {\n    var promise;\n\n    if (waiting[id]) {\n      ++waiting[id]; // Still waiting\n\n      return;\n    }\n\n    promise = promises[id];\n\n    var emit = function () {\n      conf.emit(\"getasync\", id, args, context);\n    };\n\n    if (isPromise(promise)) {\n      if (typeof promise.done === \"function\") promise.done(emit);else {\n        promise.then(function () {\n          nextTick(emit);\n        });\n      }\n    } else {\n      emit();\n    }\n  }); // On delete\n\n  conf.on(\"delete\", function (id) {\n    delete promises[id];\n\n    if (waiting[id]) {\n      delete waiting[id];\n      return; // Not yet resolved\n    }\n\n    if (!hasOwnProperty.call(cache, id)) return;\n    var result = cache[id];\n    delete cache[id];\n    conf.emit(\"deleteasync\", id, [result]);\n  }); // On clear\n\n  conf.on(\"clear\", function () {\n    var oldCache = cache;\n    cache = create(null);\n    waiting = create(null);\n    promises = create(null);\n    conf.emit(\"clearasync\", objectMap(oldCache, function (data) {\n      return [data];\n    }));\n  });\n};","map":{"version":3,"names":["objectMap","require","primitiveSet","ensureString","toShortString","isPromise","nextTick","create","Object","supportedModes","promise","mode","conf","waiting","cache","promises","TypeError","on","id","ignore","isFailed","emit","onSuccess","result","count","Error","onFailure","delete","resolvedMode","nextTickFailure","then","bind","finally","done","args","context","hasOwnProperty","call","oldCache","data"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/memoizee/ext/promise.js"],"sourcesContent":["/* eslint max-statements: 0 */\n\n// Support for functions returning promise\n\n\"use strict\";\n\nvar objectMap     = require(\"es5-ext/object/map\")\n  , primitiveSet  = require(\"es5-ext/object/primitive-set\")\n  , ensureString  = require(\"es5-ext/object/validate-stringifiable-value\")\n  , toShortString = require(\"es5-ext/to-short-string-representation\")\n  , isPromise     = require(\"is-promise\")\n  , nextTick      = require(\"next-tick\");\n\nvar create = Object.create\n  , supportedModes = primitiveSet(\"then\", \"then:finally\", \"done\", \"done:finally\");\n\nrequire(\"../lib/registered-extensions\").promise = function (mode, conf) {\n\tvar waiting = create(null), cache = create(null), promises = create(null);\n\n\tif (mode === true) {\n\t\tmode = null;\n\t} else {\n\t\tmode = ensureString(mode);\n\t\tif (!supportedModes[mode]) {\n\t\t\tthrow new TypeError(\"'\" + toShortString(mode) + \"' is not valid promise mode\");\n\t\t}\n\t}\n\n\t// After not from cache call\n\tconf.on(\"set\", function (id, ignore, promise) {\n\t\tvar isFailed = false;\n\n\t\tif (!isPromise(promise)) {\n\t\t\t// Non promise result\n\t\t\tcache[id] = promise;\n\t\t\tconf.emit(\"setasync\", id, 1);\n\t\t\treturn;\n\t\t}\n\t\twaiting[id] = 1;\n\t\tpromises[id] = promise;\n\t\tvar onSuccess = function (result) {\n\t\t\tvar count = waiting[id];\n\t\t\tif (isFailed) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Detected unordered then|done & finally resolution, which \" +\n\t\t\t\t\t\t\"in turn makes proper detection of success/failure impossible (when in \" +\n\t\t\t\t\t\t\"'done:finally' mode)\\n\" +\n\t\t\t\t\t\t\"Consider to rely on 'then' or 'done' mode instead.\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!count) return; // Deleted from cache before resolved\n\t\t\tdelete waiting[id];\n\t\t\tcache[id] = result;\n\t\t\tconf.emit(\"setasync\", id, count);\n\t\t};\n\t\tvar onFailure = function () {\n\t\t\tisFailed = true;\n\t\t\tif (!waiting[id]) return; // Deleted from cache (or succeed in case of finally)\n\t\t\tdelete waiting[id];\n\t\t\tdelete promises[id];\n\t\t\tconf.delete(id);\n\t\t};\n\n\t\tvar resolvedMode = mode;\n\t\tif (!resolvedMode) resolvedMode = \"then\";\n\n\t\tif (resolvedMode === \"then\") {\n\t\t\tvar nextTickFailure = function () { nextTick(onFailure); };\n\t\t\t// Eventual finally needs to be attached to non rejected promise\n\t\t\t// (so we not force propagation of unhandled rejection)\n\t\t\tpromise = promise.then(function (result) {\n\t\t\t\tnextTick(onSuccess.bind(this, result));\n\t\t\t}, nextTickFailure);\n\t\t\t// If `finally` is a function we attach to it to remove cancelled promises.\n\t\t\tif (typeof promise.finally === \"function\") {\n\t\t\t\tpromise.finally(nextTickFailure);\n\t\t\t}\n\t\t} else if (resolvedMode === \"done\") {\n\t\t\t// Not recommended, as it may mute any eventual \"Unhandled error\" events\n\t\t\tif (typeof promise.done !== \"function\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Retrieved promise does not implement 'done' \" +\n\t\t\t\t\t\t\"in 'done' mode\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tpromise.done(onSuccess, onFailure);\n\t\t} else if (resolvedMode === \"done:finally\") {\n\t\t\t// The only mode with no side effects assuming library does not throw unconditionally\n\t\t\t// for rejected promises.\n\t\t\tif (typeof promise.done !== \"function\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Retrieved promise does not implement 'done' \" +\n\t\t\t\t\t\t\"in 'done:finally' mode\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (typeof promise.finally !== \"function\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Retrieved promise does not implement 'finally' \" +\n\t\t\t\t\t\t\"in 'done:finally' mode\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tpromise.done(onSuccess);\n\t\t\tpromise.finally(onFailure);\n\t\t}\n\t});\n\n\t// From cache (sync)\n\tconf.on(\"get\", function (id, args, context) {\n\t\tvar promise;\n\t\tif (waiting[id]) {\n\t\t\t++waiting[id]; // Still waiting\n\t\t\treturn;\n\t\t}\n\t\tpromise = promises[id];\n\t\tvar emit = function () { conf.emit(\"getasync\", id, args, context); };\n\t\tif (isPromise(promise)) {\n\t\t\tif (typeof promise.done === \"function\") promise.done(emit);\n\t\t\telse {\n\t\t\t\tpromise.then(function () { nextTick(emit); });\n\t\t\t}\n\t\t} else {\n\t\t\temit();\n\t\t}\n\t});\n\n\t// On delete\n\tconf.on(\"delete\", function (id) {\n\t\tdelete promises[id];\n\t\tif (waiting[id]) {\n\t\t\tdelete waiting[id];\n\t\t\treturn; // Not yet resolved\n\t\t}\n\t\tif (!hasOwnProperty.call(cache, id)) return;\n\t\tvar result = cache[id];\n\t\tdelete cache[id];\n\t\tconf.emit(\"deleteasync\", id, [result]);\n\t});\n\n\t// On clear\n\tconf.on(\"clear\", function () {\n\t\tvar oldCache = cache;\n\t\tcache = create(null);\n\t\twaiting = create(null);\n\t\tpromises = create(null);\n\t\tconf.emit(\"clearasync\", objectMap(oldCache, function (data) { return [data]; }));\n\t});\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}