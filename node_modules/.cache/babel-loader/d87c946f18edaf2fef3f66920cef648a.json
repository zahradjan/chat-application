{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar errCode = require('err-code');\n\nvar filter = require('it-filter');\n\nvar map = require('it-map');\n\nvar take = require('it-take');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * Store the multiaddrs from every peer in the passed peer store\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {import('../peer-store')} peerStore\n */\n\n\nfunction storeAddresses(source, peerStore) {\n  return map(source, function (peer) {\n    // ensure we have the addresses for a given peer\n    peerStore.addressBook.add(peer.id, peer.multiaddrs);\n    return peer;\n  });\n}\n/**\n * Filter peers by unique peer id\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n */\n\n\nfunction uniquePeers(source) {\n  /** @type Set<string> */\n  var seen = new Set();\n  return filter(source, function (peer) {\n    // dedupe by peer id\n    if (seen.has(peer.id.toString())) {\n      return false;\n    }\n\n    seen.add(peer.id.toString());\n    return true;\n  });\n}\n/**\n * Require at least `min` peers to be yielded from `source`\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} min\n */\n\n\nfunction requirePeers(_x) {\n  return _requirePeers.apply(this, arguments);\n}\n/**\n * If `max` is passed, only take that number of peers from the source\n * otherwise take all the peers\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} [max]\n */\n\n\nfunction _requirePeers() {\n  _requirePeers = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n    var min,\n        seen,\n        _iteratorAbruptCompletion,\n        _didIteratorError,\n        _iteratorError,\n        _iterator,\n        _step,\n        peer,\n        _args = arguments;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            min = _args.length > 1 && _args[1] !== undefined ? _args[1] : 1;\n            seen = 0;\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 4;\n            _iterator = _asyncIterator(source);\n\n          case 6:\n            _context.next = 8;\n            return _awaitAsyncGenerator(_iterator.next());\n\n          case 8:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 16;\n              break;\n            }\n\n            peer = _step.value;\n            seen++;\n            _context.next = 13;\n            return peer;\n\n          case 13:\n            _iteratorAbruptCompletion = false;\n            _context.next = 6;\n            break;\n\n          case 16:\n            _context.next = 22;\n            break;\n\n          case 18:\n            _context.prev = 18;\n            _context.t0 = _context[\"catch\"](4);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n\n          case 22:\n            _context.prev = 22;\n            _context.prev = 23;\n\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 27;\n              break;\n            }\n\n            _context.next = 27;\n            return _awaitAsyncGenerator(_iterator.return());\n\n          case 27:\n            _context.prev = 27;\n\n            if (!_didIteratorError) {\n              _context.next = 30;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 30:\n            return _context.finish(27);\n\n          case 31:\n            return _context.finish(22);\n\n          case 32:\n            if (!(seen < min)) {\n              _context.next = 34;\n              break;\n            }\n\n            throw errCode(new Error('not found'), 'NOT_FOUND');\n\n          case 34:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 18, 22, 32], [23,, 27, 31]]);\n  }));\n  return _requirePeers.apply(this, arguments);\n}\n\nfunction maybeLimitSource(source, max) {\n  if (max) {\n    return take(source, max);\n  }\n\n  return source;\n}\n\nmodule.exports = {\n  storeAddresses: storeAddresses,\n  uniquePeers: uniquePeers,\n  requirePeers: requirePeers,\n  maybeLimitSource: maybeLimitSource\n};","map":{"version":3,"names":["errCode","require","filter","map","take","storeAddresses","source","peerStore","peer","addressBook","add","id","multiaddrs","uniquePeers","seen","Set","has","toString","requirePeers","min","Error","maybeLimitSource","max","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/content-routing/utils.js"],"sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst filter = require('it-filter')\nconst map = require('it-map')\nconst take = require('it-take')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * Store the multiaddrs from every peer in the passed peer store\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {import('../peer-store')} peerStore\n */\nfunction storeAddresses (source, peerStore) {\n  return map(source, (peer) => {\n    // ensure we have the addresses for a given peer\n    peerStore.addressBook.add(peer.id, peer.multiaddrs)\n\n    return peer\n  })\n}\n\n/**\n * Filter peers by unique peer id\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n */\nfunction uniquePeers (source) {\n  /** @type Set<string> */\n  const seen = new Set()\n\n  return filter(source, (peer) => {\n    // dedupe by peer id\n    if (seen.has(peer.id.toString())) {\n      return false\n    }\n\n    seen.add(peer.id.toString())\n\n    return true\n  })\n}\n\n/**\n * Require at least `min` peers to be yielded from `source`\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} min\n */\nasync function * requirePeers (source, min = 1) {\n  let seen = 0\n\n  for await (const peer of source) {\n    seen++\n\n    yield peer\n  }\n\n  if (seen < min) {\n    throw errCode(new Error('not found'), 'NOT_FOUND')\n  }\n}\n\n/**\n * If `max` is passed, only take that number of peers from the source\n * otherwise take all the peers\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} [max]\n */\nfunction maybeLimitSource (source, max) {\n  if (max) {\n    return take(source, max)\n  }\n\n  return source\n}\n\nmodule.exports = {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n}\n"],"mappings":"AAAA;;;;;;;;;;AAEA,IAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AACA,IAAME,GAAG,GAAGF,OAAO,CAAC,QAAD,CAAnB;;AACA,IAAMG,IAAI,GAAGH,OAAO,CAAC,SAAD,CAApB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,cAAT,CAAyBC,MAAzB,EAAiCC,SAAjC,EAA4C;EAC1C,OAAOJ,GAAG,CAACG,MAAD,EAAS,UAACE,IAAD,EAAU;IAC3B;IACAD,SAAS,CAACE,WAAV,CAAsBC,GAAtB,CAA0BF,IAAI,CAACG,EAA/B,EAAmCH,IAAI,CAACI,UAAxC;IAEA,OAAOJ,IAAP;EACD,CALS,CAAV;AAMD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASK,WAAT,CAAsBP,MAAtB,EAA8B;EAC5B;EACA,IAAMQ,IAAI,GAAG,IAAIC,GAAJ,EAAb;EAEA,OAAOb,MAAM,CAACI,MAAD,EAAS,UAACE,IAAD,EAAU;IAC9B;IACA,IAAIM,IAAI,CAACE,GAAL,CAASR,IAAI,CAACG,EAAL,CAAQM,QAAR,EAAT,CAAJ,EAAkC;MAChC,OAAO,KAAP;IACD;;IAEDH,IAAI,CAACJ,GAAL,CAASF,IAAI,CAACG,EAAL,CAAQM,QAAR,EAAT;IAEA,OAAO,IAAP;EACD,CATY,CAAb;AAUD;AAED;AACA;AACA;AACA;AACA;AACA;;;SACiBC,Y;;;AAcjB;AACA;AACA;AACA;AACA;AACA;AACA;;;;+EApBA,iBAA+BZ,MAA/B;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;;IAAA;MAAA;QAAA;UAAA;YAAuCa,GAAvC,2DAA6C,CAA7C;YACML,IADN,GACa,CADb;YAAA;YAAA;YAAA;YAAA,2BAG2BR,MAH3B;;UAAA;YAAA;YAAA;;UAAA;YAAA;cAAA;cAAA;YAAA;;YAGmBE,IAHnB;YAIIM,IAAI;YAJR;YAMI,OAAMN,IAAN;;UANJ;YAAA;YAAA;YAAA;;UAAA;YAAA;YAAA;;UAAA;YAAA;YAAA;YAAA;YAAA;;UAAA;YAAA;YAAA;;YAAA;cAAA;cAAA;YAAA;;YAAA;YAAA;;UAAA;YAAA;;YAAA;cAAA;cAAA;YAAA;;YAAA;;UAAA;YAAA;;UAAA;YAAA;;UAAA;YAAA,MASMM,IAAI,GAAGK,GATb;cAAA;cAAA;YAAA;;YAAA,MAUUnB,OAAO,CAAC,IAAIoB,KAAJ,CAAU,WAAV,CAAD,EAAyB,WAAzB,CAVjB;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C;;;;AAqBA,SAASC,gBAAT,CAA2Bf,MAA3B,EAAmCgB,GAAnC,EAAwC;EACtC,IAAIA,GAAJ,EAAS;IACP,OAAOlB,IAAI,CAACE,MAAD,EAASgB,GAAT,CAAX;EACD;;EAED,OAAOhB,MAAP;AACD;;AAEDiB,MAAM,CAACC,OAAP,GAAiB;EACfnB,cAAc,EAAdA,cADe;EAEfQ,WAAW,EAAXA,WAFe;EAGfK,YAAY,EAAZA,YAHe;EAIfG,gBAAgB,EAAhBA;AAJe,CAAjB"},"metadata":{},"sourceType":"script"}