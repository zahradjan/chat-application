{"ast":null,"code":"async function* _batch(size, iterable) {\n  let dataBatch = [];\n\n  for await (const data of iterable) {\n    dataBatch.push(data);\n\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\n\nfunction* _syncBatch(size, iterable) {\n  let dataBatch = [];\n\n  for (const data of iterable) {\n    dataBatch.push(data);\n\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\n\nfunction batch(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => batch(size, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _batch(size, iterable);\n  }\n\n  return _syncBatch(size, iterable);\n}\n\nconst TIMEOUT = Symbol('TIMEOUT');\n\nconst createTimer = duration => {\n  let timeoutId;\n  return [new Promise(resolve => {\n    timeoutId = setTimeout(() => resolve(TIMEOUT), duration);\n  }), () => {\n    clearTimeout(timeoutId);\n  }];\n}; // Like `batch` but flushes early if the `timeout` is reached\n// NOTE: The strategy is to only hold onto a single item for a maximum of `timeout` ms.\n\n\nasync function* _batchWithTimeout(size, timeout, iterable) {\n  const iterator = iterable[Symbol.asyncIterator]();\n  let pendingData;\n  let batchData = [];\n  let timer;\n  let clearTimer;\n\n  const startTimer = () => {\n    deleteTimer();\n    [timer, clearTimer] = createTimer(timeout);\n  };\n\n  const deleteTimer = () => {\n    if (clearTimer) {\n      clearTimer();\n    }\n\n    timer = undefined;\n  };\n\n  pendingData = iterator.next();\n\n  while (true) {\n    const res = await (timer ? Promise.race([pendingData, timer]) : pendingData);\n\n    if (res === TIMEOUT || res.done) {\n      // Flush early (before we reach the batch size)\n      if (batchData.length) {\n        yield batchData;\n        batchData = [];\n      }\n\n      deleteTimer(); // And exit appropriately\n\n      if (res !== TIMEOUT) {\n        // done\n        break;\n      }\n\n      continue;\n    } // Fetch next item early doors (before we potentially yield)\n\n\n    pendingData = iterator.next(); // Then handle the value\n\n    batchData.push(res.value);\n\n    if (batchData.length === 1) {\n      // Start timer once we have at least 1 item ready to go\n      startTimer();\n    }\n\n    if (batchData.length === size) {\n      yield batchData;\n      batchData = [];\n      deleteTimer();\n      continue;\n    }\n  }\n}\n\nfunction batchWithTimeout(size, timeout, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => batchWithTimeout(size, timeout, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator] && timeout !== Infinity) {\n    return _batchWithTimeout(size, timeout, iterable);\n  } // For sync iterables or an infinite timeout, the timeout is irrelevant so just fallback to regular `batch`.\n\n\n  return batch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n  if (typeof iterable.next === 'function') {\n    return iterable;\n  }\n\n  if (typeof iterable[Symbol.iterator] === 'function') {\n    return iterable[Symbol.iterator]();\n  }\n\n  if (typeof iterable[Symbol.asyncIterator] === 'function') {\n    return iterable[Symbol.asyncIterator]();\n  }\n\n  throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n  let reject;\n  let resolve;\n  const promise = new Promise((resolveFunc, rejectFunc) => {\n    resolve = resolveFunc;\n    reject = rejectFunc;\n  });\n  return {\n    promise,\n    reject,\n    resolve\n  };\n}\n\nfunction _buffer(size, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let reading = false;\n  let ended = false;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const readDeferred = readQueue.shift();\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n\n      if (error) {\n        readDeferred.reject(error);\n      } else {\n        readDeferred.resolve({\n          done: false,\n          value\n        });\n      }\n    }\n\n    while (readQueue.length > 0 && ended) {\n      const {\n        resolve\n      } = readQueue.shift();\n      resolve({\n        done: true,\n        value: undefined\n      });\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (resultQueue.length >= size) {\n      return;\n    }\n\n    reading = true;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n      } else {\n        resultQueue.push({\n          value\n        });\n      }\n    } catch (error) {\n      ended = true;\n      resultQueue.push({\n        error\n      });\n    }\n\n    fulfillReadQueue();\n    reading = false;\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length > 0) {\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n\n      if (error) {\n        throw error;\n      }\n\n      fillQueue();\n      return {\n        done: false,\n        value\n      };\n    }\n\n    if (ended) {\n      return {\n        done: true,\n        value: undefined\n      }; // stupid ts\n    }\n\n    const deferred = defer();\n    readQueue.push(deferred);\n    fillQueue();\n    return deferred.promise;\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction* syncBuffer(size, iterable) {\n  const valueQueue = [];\n  let e;\n\n  try {\n    for (const value of iterable) {\n      valueQueue.push(value);\n\n      if (valueQueue.length <= size) {\n        continue;\n      }\n\n      yield valueQueue.shift();\n    }\n  } catch (error) {\n    e = error;\n  }\n\n  for (const value of valueQueue) {\n    yield value;\n  }\n\n  if (e) {\n    throw e;\n  }\n}\n\nfunction buffer(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => buffer(size, curriedIterable);\n  }\n\n  if (size === 0) {\n    return iterable;\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _buffer(size, iterable);\n  }\n\n  return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n  const values = [];\n\n  for await (const value of iterable) {\n    values.push(value);\n  }\n\n  return values;\n}\n\nfunction collect(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _collect(iterable);\n  }\n\n  return Array.from(iterable);\n}\n\nasync function* _concat(iterables) {\n  for await (const iterable of iterables) {\n    yield* iterable;\n  }\n}\n\nfunction* _syncConcat(iterables) {\n  for (const iterable of iterables) {\n    yield* iterable;\n  }\n}\n\nfunction concat() {\n  for (var _len = arguments.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {\n    iterables[_key] = arguments[_key];\n  }\n\n  const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n\n  if (hasAnyAsync) {\n    return _concat(iterables);\n  } else {\n    return _syncConcat(iterables);\n  }\n}\n\nasync function _consume(iterable) {\n  for await (const val of iterable) {// do nothing\n  }\n}\n\nfunction consume(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _consume(iterable);\n  }\n\n  for (const val of iterable) {// do nothing\n  }\n}\n\nasync function* _filter(filterFunc, iterable) {\n  for await (const data of iterable) {\n    if (await filterFunc(data)) {\n      yield data;\n    }\n  }\n}\n\nfunction filter(filterFunc, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _filter(filterFunc, curriedIterable);\n  }\n\n  return _filter(filterFunc, iterable);\n}\n\nasync function* flatten(iterable) {\n  for await (const maybeItr of iterable) {\n    if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n      yield* flatten(maybeItr);\n    } else {\n      yield maybeItr;\n    }\n  }\n}\n\nasync function* _map(func, iterable) {\n  for await (const val of iterable) {\n    yield await func(val);\n  }\n}\n\nfunction map(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _map(func, curriedIterable);\n  }\n\n  return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => flatMap(func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n\n    reading = true;\n    inflightCount++;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n\n    reading = false;\n    fillQueue();\n  }\n\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n\n      if (value && value[Symbol.asyncIterator]) {\n        for await (const asyncVal of value) {\n          resultQueue.push(asyncVal);\n        }\n      } else {\n        resultQueue.push(value);\n      }\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction flatTransform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => flatTransform(concurrency, func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n  return new Promise(resolve => {\n    stream.once('readable', () => {\n      resolve();\n    });\n  });\n}\n\nasync function* _fromStream(stream) {\n  while (true) {\n    const data = stream.read();\n\n    if (data !== null) {\n      yield data;\n      continue;\n    }\n\n    if (stream._readableState.ended) {\n      break;\n    }\n\n    await onceReadable(stream);\n  }\n}\n\nfunction fromStream(stream) {\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return stream;\n  }\n\n  return _fromStream(stream);\n}\n\nasync function* merge() {\n  for (var _len2 = arguments.length, iterables = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    iterables[_key2] = arguments[_key2];\n  }\n\n  const sources = new Set(iterables.map(getIterator));\n\n  while (sources.size > 0) {\n    for (const iterator of sources) {\n      const nextVal = await iterator.next();\n\n      if (nextVal.done) {\n        sources.delete(iterator);\n      } else {\n        yield nextVal.value;\n      }\n    }\n  }\n}\n\nfunction pipeline(firstFn) {\n  let previousFn = firstFn();\n\n  for (var _len3 = arguments.length, fns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    fns[_key3 - 1] = arguments[_key3];\n  }\n\n  for (const func of fns) {\n    previousFn = func(previousFn);\n  }\n\n  return previousFn;\n}\n\nasync function* _parallelMap(concurrency, func, iterable) {\n  let transformError = null;\n\n  const wrapFunc = value => ({\n    value: func(value)\n  });\n\n  const stopOnError = async function* (source) {\n    for await (const value of source) {\n      if (transformError) {\n        return;\n      }\n\n      yield value;\n    }\n  };\n\n  const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n  const itr = getIterator(output);\n\n  while (true) {\n    const {\n      value,\n      done\n    } = await itr.next();\n\n    if (done) {\n      break;\n    }\n\n    try {\n      const val = await value.value;\n\n      if (!transformError) {\n        yield val;\n      }\n    } catch (error) {\n      transformError = error;\n    }\n  }\n\n  if (transformError) {\n    throw transformError;\n  }\n}\n\nfunction parallelMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n  }\n\n  if (concurrency === 1) {\n    return map(func, iterable);\n  }\n\n  return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => parallelFlatMap(concurrency, func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\n\nasync function* parallelMerge() {\n  for (var _len4 = arguments.length, iterables = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    iterables[_key4] = arguments[_key4];\n  }\n\n  const inputs = iterables.map(getIterator);\n  const concurrentWork = new Set();\n  const values = new Map();\n  let lastError = null;\n  let errCb = null;\n  let valueCb = null;\n\n  const notifyError = err => {\n    lastError = err;\n\n    if (errCb) {\n      errCb(err);\n    }\n  };\n\n  const notifyDone = value => {\n    if (valueCb) {\n      valueCb(value);\n    }\n  };\n\n  const waitForQueue = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      reject(lastError);\n    }\n\n    if (values.size > 0) {\n      return resolve();\n    }\n\n    valueCb = resolve;\n    errCb = reject;\n  });\n\n  const queueNext = input => {\n    const nextVal = Promise.resolve(input.next()).then(async _ref => {\n      let {\n        done,\n        value\n      } = _ref;\n\n      if (!done) {\n        values.set(input, value);\n      }\n\n      concurrentWork.delete(nextVal);\n    });\n    concurrentWork.add(nextVal);\n    nextVal.then(notifyDone, notifyError);\n  };\n\n  for (const input of inputs) {\n    queueNext(input);\n  }\n\n  while (true) {\n    // We technically don't have to check `values.size` as the for loop should have emptied it\n    // However I haven't yet found specs verifying that behavior, only tests\n    // the guard in waitForQueue() checking for values is in place for the same reason\n    if (concurrentWork.size === 0 && values.size === 0) {\n      return;\n    }\n\n    await waitForQueue();\n\n    for (const [input, value] of values) {\n      values.delete(input);\n      yield value;\n      queueNext(input);\n    }\n  }\n}\n\nasync function _reduce(func, start, iterable) {\n  let value = start;\n\n  for await (const nextItem of iterable) {\n    value = await func(value, nextItem);\n  }\n\n  return value;\n}\n\nfunction reduce(func, start, iterable) {\n  if (start === undefined) {\n    return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => reduce(func, start, curriedIterable);\n  }\n\n  return _reduce(func, start, iterable);\n}\n\nasync function* _take(count, iterable) {\n  let taken = 0;\n\n  for await (const val of iterable) {\n    yield await val;\n    taken++;\n\n    if (taken >= count) {\n      break;\n    }\n  }\n}\n\nfunction* _syncTake(count, iterable) {\n  let taken = 0;\n\n  for (const val of iterable) {\n    yield val;\n    taken++;\n\n    if (taken >= count) {\n      break;\n    }\n  }\n}\n\nfunction take(count, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => take(count, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _take(count, iterable);\n  }\n\n  return _syncTake(count, iterable);\n}\n\nasync function* _asyncTap(func, iterable) {\n  for await (const val of iterable) {\n    await func(val);\n    yield val;\n  }\n}\n\nfunction tap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _asyncTap(func, curriedIterable);\n  }\n\n  return _asyncTap(func, iterable);\n}\n\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\nfunction _throttle(limit, interval, iterable) {\n  if (!Number.isFinite(limit)) {\n    throw new TypeError('Expected `limit` to be a finite number');\n  }\n\n  if (limit <= 0) {\n    throw new TypeError('Expected `limit` to be greater than 0');\n  }\n\n  if (!Number.isFinite(interval)) {\n    throw new TypeError('Expected `interval` to be a finite number');\n  }\n\n  return async function* __throttle() {\n    let sent = 0;\n    let time;\n\n    for await (const val of iterable) {\n      if (sent < limit) {\n        if (typeof time === 'undefined') {\n          time = Date.now();\n        }\n\n        sent++;\n        yield val;\n        continue;\n      } // Only wait if the interval hasn't already passed while we were\n      // yielding the previous values.\n\n\n      const elapsedMs = Date.now() - time;\n      const waitFor = interval - elapsedMs;\n\n      if (waitFor > 0) {\n        await sleep(waitFor);\n      }\n\n      time = Date.now();\n      sent = 1;\n      yield val;\n    }\n  }();\n}\n\nfunction throttle(limit, interval, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _throttle(limit, interval, curriedIterable);\n  }\n\n  return _throttle(limit, interval, iterable);\n}\n\nfunction addTime(a, b) {\n  let seconds = a[0] + b[0];\n  let nanoseconds = a[1] + b[1];\n\n  if (nanoseconds >= 1000000000) {\n    const remainder = nanoseconds % 1000000000;\n    seconds += (nanoseconds - remainder) / 1000000000;\n    nanoseconds = remainder;\n  }\n\n  return [seconds, nanoseconds];\n}\n\nasync function* _asyncTime(config, iterable) {\n  const itr = iterable[Symbol.asyncIterator]();\n  let total = [0, 0];\n\n  while (true) {\n    const start = process.hrtime();\n    const {\n      value,\n      done\n    } = await itr.next();\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n\n      return value;\n    }\n\n    yield value;\n  }\n}\n\nfunction* _syncTime(config, iterable) {\n  const itr = iterable[Symbol.iterator]();\n  let total = [0, 0];\n\n  while (true) {\n    const start = process.hrtime();\n    const {\n      value,\n      done\n    } = itr.next();\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n\n      return value;\n    }\n\n    yield value;\n  }\n}\n\nfunction time() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let iterable = arguments.length > 1 ? arguments[1] : undefined;\n\n  if (iterable === undefined) {\n    return curriedIterable => time(config, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator] !== undefined) {\n    return _asyncTime(config, iterable);\n  } else {\n    return _syncTime(config, iterable);\n  }\n}\n\nfunction _transform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n\n    reading = true;\n    inflightCount++;\n\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n\n    reading = false;\n    fillQueue();\n  }\n\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n      resultQueue.push(value);\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction transform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => transform(concurrency, func, curriedIterable);\n  }\n\n  return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n  let lastError = null;\n  let errCb = null;\n  let drainCb = null;\n\n  const notifyError = err => {\n    lastError = err;\n\n    if (errCb) {\n      errCb(err);\n    }\n  };\n\n  const notifyDrain = () => {\n    if (drainCb) {\n      drainCb();\n    }\n  };\n\n  const cleanup = () => {\n    stream.removeListener('error', notifyError);\n    stream.removeListener('drain', notifyDrain);\n  };\n\n  stream.once('error', notifyError);\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      return reject(lastError);\n    }\n\n    stream.once('drain', notifyDrain);\n    drainCb = resolve;\n    errCb = reject;\n  });\n\n  for await (const value of iterable) {\n    if (stream.write(value) === false) {\n      await waitForDrain();\n    }\n\n    if (lastError) {\n      break;\n    }\n  }\n\n  cleanup();\n\n  if (lastError) {\n    throw lastError;\n  }\n}\n\nfunction writeToStream(stream, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _writeToStream(stream, curriedIterable);\n  }\n\n  return _writeToStream(stream, iterable);\n}\n\nexport { batch, batchWithTimeout, buffer, collect, concat, consume, filter, flatMap, flatTransform, flatten, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, tap, throttle, time, transform, writeToStream };","map":{"version":3,"names":["_batch","size","iterable","dataBatch","data","push","length","_syncBatch","batch","undefined","curriedIterable","Symbol","asyncIterator","TIMEOUT","createTimer","duration","timeoutId","Promise","resolve","setTimeout","clearTimeout","_batchWithTimeout","timeout","iterator","pendingData","batchData","timer","clearTimer","startTimer","deleteTimer","next","res","race","done","value","batchWithTimeout","Infinity","getIterator","TypeError","defer","reject","promise","resolveFunc","rejectFunc","_buffer","resultQueue","readQueue","reading","ended","fulfillReadQueue","readDeferred","shift","error","fillQueue","deferred","asyncIterableIterator","syncBuffer","valueQueue","e","buffer","_collect","values","collect","Array","from","_concat","iterables","_syncConcat","concat","hasAnyAsync","find","itr","_consume","val","consume","_filter","filterFunc","filter","flatten","maybeItr","_map","func","map","flatMap","i","_flatTransform","concurrency","inflightCount","lastError","mapAndQueue","itrValue","asyncVal","flatTransform","curriedFunc","onceReadable","stream","once","_fromStream","read","_readableState","fromStream","merge","sources","Set","nextVal","delete","pipeline","firstFn","previousFn","fns","_parallelMap","transformError","wrapFunc","stopOnError","source","output","parallelMap","parallelFlatMap","parallelMerge","inputs","concurrentWork","Map","errCb","valueCb","notifyError","err","notifyDone","waitForQueue","queueNext","input","then","set","add","_reduce","start","nextItem","reduce","curriedStart","_take","count","taken","_syncTake","take","_asyncTap","tap","sleep","ms","_throttle","limit","interval","Number","isFinite","__throttle","sent","time","Date","now","elapsedMs","waitFor","throttle","addTime","a","b","seconds","nanoseconds","remainder","_asyncTime","config","total","process","hrtime","delta","progress","_syncTime","_transform","transform","_writeToStream","drainCb","notifyDrain","cleanup","removeListener","waitForDrain","write","writeToStream"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/streaming-iterables/dist/index.mjs"],"sourcesContent":["async function* _batch(size, iterable) {\n    let dataBatch = [];\n    for await (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction* _syncBatch(size, iterable) {\n    let dataBatch = [];\n    for (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction batch(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batch(size, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _batch(size, iterable);\n    }\n    return _syncBatch(size, iterable);\n}\n\nconst TIMEOUT = Symbol('TIMEOUT');\nconst createTimer = (duration) => {\n    let timeoutId;\n    return [\n        new Promise(resolve => {\n            timeoutId = setTimeout(() => resolve(TIMEOUT), duration);\n        }),\n        () => {\n            clearTimeout(timeoutId);\n        },\n    ];\n};\n// Like `batch` but flushes early if the `timeout` is reached\n// NOTE: The strategy is to only hold onto a single item for a maximum of `timeout` ms.\nasync function* _batchWithTimeout(size, timeout, iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    let pendingData;\n    let batchData = [];\n    let timer;\n    let clearTimer;\n    const startTimer = () => {\n        deleteTimer();\n        [timer, clearTimer] = createTimer(timeout);\n    };\n    const deleteTimer = () => {\n        if (clearTimer) {\n            clearTimer();\n        }\n        timer = undefined;\n    };\n    pendingData = iterator.next();\n    while (true) {\n        const res = await (timer ? Promise.race([pendingData, timer]) : pendingData);\n        if (res === TIMEOUT || res.done) {\n            // Flush early (before we reach the batch size)\n            if (batchData.length) {\n                yield batchData;\n                batchData = [];\n            }\n            deleteTimer();\n            // And exit appropriately\n            if (res !== TIMEOUT) {\n                // done\n                break;\n            }\n            continue;\n        }\n        // Fetch next item early doors (before we potentially yield)\n        pendingData = iterator.next();\n        // Then handle the value\n        batchData.push(res.value);\n        if (batchData.length === 1) {\n            // Start timer once we have at least 1 item ready to go\n            startTimer();\n        }\n        if (batchData.length === size) {\n            yield batchData;\n            batchData = [];\n            deleteTimer();\n            continue;\n        }\n    }\n}\nfunction batchWithTimeout(size, timeout, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batchWithTimeout(size, timeout, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] && timeout !== Infinity) {\n        return _batchWithTimeout(size, timeout, iterable);\n    }\n    // For sync iterables or an infinite timeout, the timeout is irrelevant so just fallback to regular `batch`.\n    return batch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n    if (typeof iterable.next === 'function') {\n        return iterable;\n    }\n    if (typeof iterable[Symbol.iterator] === 'function') {\n        return iterable[Symbol.iterator]();\n    }\n    if (typeof iterable[Symbol.asyncIterator] === 'function') {\n        return iterable[Symbol.asyncIterator]();\n    }\n    throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n    let reject;\n    let resolve;\n    const promise = new Promise((resolveFunc, rejectFunc) => {\n        resolve = resolveFunc;\n        reject = rejectFunc;\n    });\n    return {\n        promise,\n        reject,\n        resolve,\n    };\n}\n\nfunction _buffer(size, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let reading = false;\n    let ended = false;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const readDeferred = readQueue.shift();\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                readDeferred.reject(error);\n            }\n            else {\n                readDeferred.resolve({ done: false, value });\n            }\n        }\n        while (readQueue.length > 0 && ended) {\n            const { resolve } = readQueue.shift();\n            resolve({ done: true, value: undefined });\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (resultQueue.length >= size) {\n            return;\n        }\n        reading = true;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n            }\n            else {\n                resultQueue.push({ value });\n            }\n        }\n        catch (error) {\n            ended = true;\n            resultQueue.push({ error });\n        }\n        fulfillReadQueue();\n        reading = false;\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length > 0) {\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                throw error;\n            }\n            fillQueue();\n            return { done: false, value };\n        }\n        if (ended) {\n            return { done: true, value: undefined }; // stupid ts\n        }\n        const deferred = defer();\n        readQueue.push(deferred);\n        fillQueue();\n        return deferred.promise;\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction* syncBuffer(size, iterable) {\n    const valueQueue = [];\n    let e;\n    try {\n        for (const value of iterable) {\n            valueQueue.push(value);\n            if (valueQueue.length <= size) {\n                continue;\n            }\n            yield valueQueue.shift();\n        }\n    }\n    catch (error) {\n        e = error;\n    }\n    for (const value of valueQueue) {\n        yield value;\n    }\n    if (e) {\n        throw e;\n    }\n}\nfunction buffer(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => buffer(size, curriedIterable);\n    }\n    if (size === 0) {\n        return iterable;\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _buffer(size, iterable);\n    }\n    return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n    const values = [];\n    for await (const value of iterable) {\n        values.push(value);\n    }\n    return values;\n}\nfunction collect(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _collect(iterable);\n    }\n    return Array.from(iterable);\n}\n\nasync function* _concat(iterables) {\n    for await (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction* _syncConcat(iterables) {\n    for (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction concat(...iterables) {\n    const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n    if (hasAnyAsync) {\n        return _concat(iterables);\n    }\n    else {\n        return _syncConcat(iterables);\n    }\n}\n\nasync function _consume(iterable) {\n    for await (const val of iterable) {\n        // do nothing\n    }\n}\nfunction consume(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _consume(iterable);\n    }\n    for (const val of iterable) {\n        // do nothing\n    }\n}\n\nasync function* _filter(filterFunc, iterable) {\n    for await (const data of iterable) {\n        if (await filterFunc(data)) {\n            yield data;\n        }\n    }\n}\nfunction filter(filterFunc, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _filter(filterFunc, curriedIterable);\n    }\n    return _filter(filterFunc, iterable);\n}\n\nasync function* flatten(iterable) {\n    for await (const maybeItr of iterable) {\n        if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n            yield* flatten(maybeItr);\n        }\n        else {\n            yield maybeItr;\n        }\n    }\n}\n\nasync function* _map(func, iterable) {\n    for await (const val of iterable) {\n        yield await func(val);\n    }\n}\nfunction map(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => _map(func, curriedIterable);\n    }\n    return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => flatMap(func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            if (value && value[Symbol.asyncIterator]) {\n                for await (const asyncVal of value) {\n                    resultQueue.push(asyncVal);\n                }\n            }\n            else {\n                resultQueue.push(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction flatTransform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? flatTransform(concurrency, curriedFunc, curriedIterable)\n            : flatTransform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n    return new Promise(resolve => {\n        stream.once('readable', () => {\n            resolve();\n        });\n    });\n}\nasync function* _fromStream(stream) {\n    while (true) {\n        const data = stream.read();\n        if (data !== null) {\n            yield data;\n            continue;\n        }\n        if (stream._readableState.ended) {\n            break;\n        }\n        await onceReadable(stream);\n    }\n}\nfunction fromStream(stream) {\n    if (typeof stream[Symbol.asyncIterator] === 'function') {\n        return stream;\n    }\n    return _fromStream(stream);\n}\n\nasync function* merge(...iterables) {\n    const sources = new Set(iterables.map(getIterator));\n    while (sources.size > 0) {\n        for (const iterator of sources) {\n            const nextVal = await iterator.next();\n            if (nextVal.done) {\n                sources.delete(iterator);\n            }\n            else {\n                yield nextVal.value;\n            }\n        }\n    }\n}\n\nfunction pipeline(firstFn, ...fns) {\n    let previousFn = firstFn();\n    for (const func of fns) {\n        previousFn = func(previousFn);\n    }\n    return previousFn;\n}\n\nasync function* _parallelMap(concurrency, func, iterable) {\n    let transformError = null;\n    const wrapFunc = value => ({\n        value: func(value),\n    });\n    const stopOnError = async function* (source) {\n        for await (const value of source) {\n            if (transformError) {\n                return;\n            }\n            yield value;\n        }\n    };\n    const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n    const itr = getIterator(output);\n    while (true) {\n        const { value, done } = await itr.next();\n        if (done) {\n            break;\n        }\n        try {\n            const val = await value.value;\n            if (!transformError) {\n                yield val;\n            }\n        }\n        catch (error) {\n            transformError = error;\n        }\n    }\n    if (transformError) {\n        throw transformError;\n    }\n}\nfunction parallelMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n    }\n    if (iterable === undefined) {\n        return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n    }\n    if (concurrency === 1) {\n        return map(func, iterable);\n    }\n    return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? parallelFlatMap(concurrency, curriedFunc, curriedIterable)\n            : parallelFlatMap(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\n\nasync function* parallelMerge(...iterables) {\n    const inputs = iterables.map(getIterator);\n    const concurrentWork = new Set();\n    const values = new Map();\n    let lastError = null;\n    let errCb = null;\n    let valueCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDone = value => {\n        if (valueCb) {\n            valueCb(value);\n        }\n    };\n    const waitForQueue = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            reject(lastError);\n        }\n        if (values.size > 0) {\n            return resolve();\n        }\n        valueCb = resolve;\n        errCb = reject;\n    });\n    const queueNext = input => {\n        const nextVal = Promise.resolve(input.next()).then(async ({ done, value }) => {\n            if (!done) {\n                values.set(input, value);\n            }\n            concurrentWork.delete(nextVal);\n        });\n        concurrentWork.add(nextVal);\n        nextVal.then(notifyDone, notifyError);\n    };\n    for (const input of inputs) {\n        queueNext(input);\n    }\n    while (true) {\n        // We technically don't have to check `values.size` as the for loop should have emptied it\n        // However I haven't yet found specs verifying that behavior, only tests\n        // the guard in waitForQueue() checking for values is in place for the same reason\n        if (concurrentWork.size === 0 && values.size === 0) {\n            return;\n        }\n        await waitForQueue();\n        for (const [input, value] of values) {\n            values.delete(input);\n            yield value;\n            queueNext(input);\n        }\n    }\n}\n\nasync function _reduce(func, start, iterable) {\n    let value = start;\n    for await (const nextItem of iterable) {\n        value = await func(value, nextItem);\n    }\n    return value;\n}\nfunction reduce(func, start, iterable) {\n    if (start === undefined) {\n        return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => reduce(func, start, curriedIterable);\n    }\n    return _reduce(func, start, iterable);\n}\n\nasync function* _take(count, iterable) {\n    let taken = 0;\n    for await (const val of iterable) {\n        yield await val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction* _syncTake(count, iterable) {\n    let taken = 0;\n    for (const val of iterable) {\n        yield val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction take(count, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => take(count, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _take(count, iterable);\n    }\n    return _syncTake(count, iterable);\n}\n\nasync function* _asyncTap(func, iterable) {\n    for await (const val of iterable) {\n        await func(val);\n        yield val;\n    }\n}\nfunction tap(func, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _asyncTap(func, curriedIterable);\n    }\n    return _asyncTap(func, iterable);\n}\n\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\nfunction _throttle(limit, interval, iterable) {\n    if (!Number.isFinite(limit)) {\n        throw new TypeError('Expected `limit` to be a finite number');\n    }\n    if (limit <= 0) {\n        throw new TypeError('Expected `limit` to be greater than 0');\n    }\n    if (!Number.isFinite(interval)) {\n        throw new TypeError('Expected `interval` to be a finite number');\n    }\n    return (async function* __throttle() {\n        let sent = 0;\n        let time;\n        for await (const val of iterable) {\n            if (sent < limit) {\n                if (typeof time === 'undefined') {\n                    time = Date.now();\n                }\n                sent++;\n                yield val;\n                continue;\n            }\n            // Only wait if the interval hasn't already passed while we were\n            // yielding the previous values.\n            const elapsedMs = Date.now() - time;\n            const waitFor = interval - elapsedMs;\n            if (waitFor > 0) {\n                await sleep(waitFor);\n            }\n            time = Date.now();\n            sent = 1;\n            yield val;\n        }\n    })();\n}\nfunction throttle(limit, interval, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _throttle(limit, interval, curriedIterable);\n    }\n    return _throttle(limit, interval, iterable);\n}\n\nfunction addTime(a, b) {\n    let seconds = a[0] + b[0];\n    let nanoseconds = a[1] + b[1];\n    if (nanoseconds >= 1000000000) {\n        const remainder = nanoseconds % 1000000000;\n        seconds += (nanoseconds - remainder) / 1000000000;\n        nanoseconds = remainder;\n    }\n    return [seconds, nanoseconds];\n}\nasync function* _asyncTime(config, iterable) {\n    const itr = iterable[Symbol.asyncIterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = await itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction* _syncTime(config, iterable) {\n    const itr = iterable[Symbol.iterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction time(config = {}, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => time(config, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] !== undefined) {\n        return _asyncTime(config, iterable);\n    }\n    else {\n        return _syncTime(config, iterable);\n    }\n}\n\nfunction _transform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            resultQueue.push(value);\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction transform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? transform(concurrency, curriedFunc, curriedIterable)\n            : transform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => transform(concurrency, func, curriedIterable);\n    }\n    return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n    let lastError = null;\n    let errCb = null;\n    let drainCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDrain = () => {\n        if (drainCb) {\n            drainCb();\n        }\n    };\n    const cleanup = () => {\n        stream.removeListener('error', notifyError);\n        stream.removeListener('drain', notifyDrain);\n    };\n    stream.once('error', notifyError);\n    const waitForDrain = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            return reject(lastError);\n        }\n        stream.once('drain', notifyDrain);\n        drainCb = resolve;\n        errCb = reject;\n    });\n    for await (const value of iterable) {\n        if (stream.write(value) === false) {\n            await waitForDrain();\n        }\n        if (lastError) {\n            break;\n        }\n    }\n    cleanup();\n    if (lastError) {\n        throw lastError;\n    }\n}\nfunction writeToStream(stream, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _writeToStream(stream, curriedIterable);\n    }\n    return _writeToStream(stream, iterable);\n}\n\nexport { batch, batchWithTimeout, buffer, collect, concat, consume, filter, flatMap, flatTransform, flatten, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, tap, throttle, time, transform, writeToStream };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}