{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar ipns = require('ipns');\n\nvar PeerId = require('peer-id');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('ipfs:ipns:resolver'), {\n  error: debug('ipfs:ipns:resolver:error')\n});\n\nvar _require = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require.toString;\n\nvar _require2 = require('interface-datastore'),\n    Errors = _require2.Errors;\n\nvar ERR_NOT_FOUND = Errors.notFoundError().code;\nvar defaultMaximumRecursiveDepth = 32;\n\nvar IpnsResolver = /*#__PURE__*/function () {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   */\n  function IpnsResolver(routing) {\n    _classCallCheck(this, IpnsResolver);\n\n    this._routing = routing;\n  }\n  /**\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.recursive]\n   */\n\n\n  _createClass(IpnsResolver, [{\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(name) {\n        var options,\n            recursive,\n            nameSegments,\n            key,\n            depth,\n            res,\n            _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n                if (!(typeof name !== 'string')) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n\n              case 3:\n                recursive = options.recursive && options.recursive.toString() === 'true';\n                nameSegments = name.split('/');\n\n                if (!(nameSegments.length !== 3 || nameSegments[0] !== '')) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n\n              case 7:\n                key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n                depth = Infinity;\n\n                if (recursive) {\n                  depth = defaultMaximumRecursiveDepth;\n                }\n\n                _context.next = 12;\n                return this.resolver(key, depth);\n\n              case 12:\n                res = _context.sent;\n                log(\"\".concat(name, \" was locally resolved correctly\"));\n                return _context.abrupt(\"return\", res);\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function resolve(_x) {\n        return _resolve.apply(this, arguments);\n      }\n\n      return resolve;\n    }()\n    /**\n     * Recursive resolver according to the specified depth\n     *\n     * @param {string} name\n     * @param {number} depth\n     * @returns {Promise<string>}\n     */\n\n  }, {\n    key: \"resolver\",\n    value: function () {\n      var _resolver = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name, depth) {\n        var errMsg, res, nameSegments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(depth === 0)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                errMsg = \"could not resolve name (recursion limit of \".concat(defaultMaximumRecursiveDepth, \" exceeded)\");\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n\n              case 4:\n                _context2.next = 6;\n                return this._resolveName(name);\n\n              case 6:\n                res = _context2.sent;\n                nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n                if (!(nameSegments[1] === 'ipfs' || !depth)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", res);\n\n              case 10:\n                return _context2.abrupt(\"return\", this.resolver(nameSegments[2], depth - 1));\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function resolver(_x2, _x3) {\n        return _resolver.apply(this, arguments);\n      }\n\n      return resolver;\n    }()\n    /**\n     * Resolve ipns entries from the provided routing\n     *\n     * @param {string} name\n     */\n\n  }, {\n    key: \"_resolveName\",\n    value: function () {\n      var _resolveName2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(name) {\n        var peerId, _ipns$getIdKeys, routingKey, record, ipnsEntry;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                peerId = PeerId.parse(name);\n                _ipns$getIdKeys = ipns.getIdKeys(peerId.toBytes()), routingKey = _ipns$getIdKeys.routingKey;\n                _context3.prev = 2;\n                _context3.next = 5;\n                return this._routing.get(routingKey.uint8Array());\n\n              case 5:\n                record = _context3.sent;\n                _context3.next = 14;\n                break;\n\n              case 8:\n                _context3.prev = 8;\n                _context3.t0 = _context3[\"catch\"](2);\n                log.error('could not get record from routing', _context3.t0);\n\n                if (!(_context3.t0.code === ERR_NOT_FOUND)) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                throw errcode(new Error(\"record requested for \".concat(name, \" was not found in the network\")), 'ERR_NO_RECORD_FOUND');\n\n              case 13:\n                throw errcode(new Error(\"unexpected error getting the ipns record \".concat(peerId.toString())), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n\n              case 14:\n                _context3.prev = 14;\n                ipnsEntry = ipns.unmarshal(record);\n                _context3.next = 22;\n                break;\n\n              case 18:\n                _context3.prev = 18;\n                _context3.t1 = _context3[\"catch\"](14);\n                log.error('could not unmarshal record', _context3.t1);\n                throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');\n\n              case 22:\n                return _context3.abrupt(\"return\", this._validateRecord(peerId, ipnsEntry));\n\n              case 23:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[2, 8], [14, 18]]);\n      }));\n\n      function _resolveName(_x4) {\n        return _resolveName2.apply(this, arguments);\n      }\n\n      return _resolveName;\n    }()\n    /**\n     * Validate a resolved record\n     *\n     * @param {PeerId} peerId\n     * @param {import('ipns').IPNSEntry} ipnsEntry\n     */\n\n  }, {\n    key: \"_validateRecord\",\n    value: function () {\n      var _validateRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(peerId, ipnsEntry) {\n        var pubKey;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return ipns.extractPublicKey(peerId, ipnsEntry);\n\n              case 2:\n                pubKey = _context4.sent;\n                _context4.next = 5;\n                return ipns.validate(pubKey, ipnsEntry);\n\n              case 5:\n                return _context4.abrupt(\"return\", uint8ArrayToString(ipnsEntry.value));\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function _validateRecord(_x5, _x6) {\n        return _validateRecord2.apply(this, arguments);\n      }\n\n      return _validateRecord;\n    }()\n  }]);\n\n  return IpnsResolver;\n}();\n\nexports = module.exports = IpnsResolver;","map":{"version":3,"names":["ipns","require","PeerId","errcode","debug","log","Object","assign","error","uint8ArrayToString","toString","Errors","ERR_NOT_FOUND","notFoundError","code","defaultMaximumRecursiveDepth","IpnsResolver","routing","_routing","name","options","Error","recursive","nameSegments","split","length","key","depth","Infinity","resolver","res","errMsg","_resolveName","peerId","parse","getIdKeys","toBytes","routingKey","get","uint8Array","record","ipnsEntry","unmarshal","_validateRecord","extractPublicKey","pubKey","validate","value","exports","module"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/ipns/resolver.js"],"sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst PeerId = require('peer-id')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns:resolver'), {\n  error: debug('ipfs:ipns:resolver:error')\n})\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\n\nconst defaultMaximumRecursiveDepth = 32\n\nclass IpnsResolver {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   */\n  constructor (routing) {\n    this._routing = routing\n  }\n\n  /**\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.recursive]\n   */\n  async resolve (name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const recursive = options.recursive && options.recursive.toString() === 'true'\n\n    const nameSegments = name.split('/')\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const key = nameSegments[2]\n\n    // Define a maximum depth if recursive option enabled\n    let depth = Infinity\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth\n    }\n\n    const res = await this.resolver(key, depth)\n\n    log(`${name} was locally resolved correctly`)\n    return res\n  }\n\n  /**\n   * Recursive resolver according to the specified depth\n   *\n   * @param {string} name\n   * @param {number} depth\n   * @returns {Promise<string>}\n   */\n  async resolver (name, depth) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT')\n    }\n\n    const res = await this._resolveName(name)\n    const nameSegments = res.split('/')\n\n    // If obtained a ipfs cid or recursive option is disabled\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res\n    }\n\n    // continue recursively until depth equals 0\n    return this.resolver(nameSegments[2], depth - 1)\n  }\n\n  /**\n   * Resolve ipns entries from the provided routing\n   *\n   * @param {string} name\n   */\n  async _resolveName (name) {\n    const peerId = PeerId.parse(name)\n    const { routingKey } = ipns.getIdKeys(peerId.toBytes())\n    let record\n\n    try {\n      record = await this._routing.get(routingKey.uint8Array())\n    } catch (err) {\n      log.error('could not get record from routing', err)\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND')\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n    }\n\n    // IPNS entry\n    let ipnsEntry\n    try {\n      ipnsEntry = ipns.unmarshal(record)\n    } catch (err) {\n      log.error('could not unmarshal record', err)\n\n      throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    // We should have the public key by now (inline, or in the entry)\n    return this._validateRecord(peerId, ipnsEntry)\n  }\n\n  /**\n   * Validate a resolved record\n   *\n   * @param {PeerId} peerId\n   * @param {import('ipns').IPNSEntry} ipnsEntry\n   */\n  async _validateRecord (peerId, ipnsEntry) {\n    const pubKey = await ipns.extractPublicKey(peerId, ipnsEntry)\n\n    // IPNS entry validation\n    await ipns.validate(pubKey, ipnsEntry)\n\n    return uint8ArrayToString(ipnsEntry.value)\n  }\n}\n\nexports = module.exports = IpnsResolver\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}