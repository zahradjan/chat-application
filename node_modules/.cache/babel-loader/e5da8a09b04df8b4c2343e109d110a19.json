{"ast":null,"code":"'use strict';\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst toCIDAndPath = require('ipfs-core-utils/src/to-cid-and-path');\n\nconst {\n  CID\n} = require('multiformats/cid'); // @ts-expect-error no types\n\n\nconst TimeoutController = require('timeout-abort-controller');\n\nconst {\n  anySignal\n} = require('any-signal');\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\n\nmodule.exports = function (_ref) {\n  let {\n    repo,\n    codecs,\n    resolve,\n    preload\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/refs').API[\"refs\"]}\n   */\n  async function* refs(ipfsPath) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.maxDepth === 0) {\n      return;\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format');\n    }\n\n    options.format = options.edges ? Format.edges : options.format;\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1;\n    }\n\n    if (options.timeout) {\n      const controller = new TimeoutController(options.timeout);\n      options.signal = anySignal([options.signal, controller.signal]);\n    }\n    /** @type {(string|CID)[]} */\n\n\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n    const paths = rawPaths.map(p => getFullPath(preload, p, options));\n\n    for (const path of paths) {\n      try {\n        yield* refsStream(resolve, repo, codecs, path, options);\n      } catch (err) {\n        yield {\n          ref: '',\n          err: err.message\n        };\n      }\n    }\n  }\n\n  return refs;\n};\n\nmodule.exports.Format = Format;\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\nfunction getFullPath(preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCIDAndPath(ipfsPath);\n\n  if (options.preload !== false) {\n    preload(cid);\n  }\n\n  return `/ipfs/${cid}${path || ''}`;\n}\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\n\nasync function* refsStream(resolve, repo, codecs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path, options);\n  const {\n    cid\n  } = toCIDAndPath(resPath);\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;\n  const unique = options.unique || false; // Traverse the DAG, converting it into a stream\n\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique, options)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue;\n    } // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n\n\n    if (obj.isDuplicate) {\n      continue;\n    } // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n\n\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    };\n  }\n}\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\n\n\nfunction formatLink(srcCid, dstCid) {\n  let linkName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  let format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Format.default;\n  let out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n}\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n * @param {AbortOptions} options\n */\n\n\nasync function* objectStream(repo, codecs, rootCid, maxDepth, uniqueOnly, options) {\n  // eslint-disable-line require-await\n  const seen = new Set();\n  /**\n   * @param {Node} parent\n   * @param {number} depth\n   * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n   */\n\n  async function* traverseLevel(parent, depth) {\n    const nextLevelDepth = depth + 1; // Check the depth\n\n    if (nextLevelDepth > maxDepth) {\n      return;\n    } // Get this object's links\n\n\n    try {\n      // Look at each link, parent and the new depth\n      for await (const link of getLinks(repo, codecs, parent.cid, options)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        };\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString());\n        }\n\n        yield* traverseLevel(link, nextLevelDepth);\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`;\n      }\n\n      throw err;\n    }\n  }\n\n  yield* traverseLevel({\n    cid: rootCid\n  }, 0);\n}\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} cid\n * @param {AbortOptions} options\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\n\n\nasync function* getLinks(repo, codecs, cid, options) {\n  const block = await repo.blocks.get(cid, options);\n  const codec = await codecs.getCodec(cid.code);\n  const value = codec.decode(block);\n  const isDagPb = cid.code === dagPb.code;\n  /** @type {Array<string|number>} */\n\n  const base = [];\n\n  for (const [name, cid] of links(value, base)) {\n    // special case for dag-pb - use the name of the link\n    // instead of the path within the object\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/);\n\n      if (match) {\n        const index = Number(match[1]);\n\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          };\n          continue;\n        }\n      }\n    }\n\n    yield {\n      name,\n      cid\n    };\n  }\n}\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\n\n\nconst links = function* (source, base) {\n  if (source == null) {\n    return;\n  }\n\n  if (source instanceof Uint8Array) {\n    return;\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key];\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index];\n          const cid = CID.asCID(element); // eslint-disable-next-line max-depth\n\n          if (cid) {\n            yield [elementPath.join('/'), cid];\n          } else if (typeof element === 'object') {\n            yield* links(element, elementPath);\n          }\n        }\n      } else {\n        const cid = CID.asCID(value);\n\n        if (cid) {\n          yield [path.join('/'), cid];\n        } else {\n          yield* links(value, path);\n        }\n      }\n    }\n  } // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n\n\n  return [];\n};","map":{"version":3,"names":["dagPb","require","Errors","ERR_NOT_FOUND","notFoundError","code","toCIDAndPath","CID","TimeoutController","anySignal","Format","default","edges","module","exports","repo","codecs","resolve","preload","refs","ipfsPath","options","maxDepth","format","Error","recursive","Infinity","timeout","controller","signal","rawPaths","Array","isArray","paths","map","p","getFullPath","path","refsStream","err","ref","message","cid","resPath","unique","obj","objectStream","parent","isDuplicate","formatLink","node","name","srcCid","dstCid","linkName","out","replace","toString","rootCid","uniqueOnly","seen","Set","traverseLevel","depth","nextLevelDepth","link","getLinks","has","add","block","blocks","get","codec","getCodec","value","decode","isDagPb","base","links","match","index","Number","Links","length","Name","source","Uint8Array","key","Object","entries","element","elementPath","asCID","join"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/refs/index.js"],"sourcesContent":["'use strict'\n\nconst dagPb = require('@ipld/dag-pb')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst toCIDAndPath = require('ipfs-core-utils/src/to-cid-and-path')\nconst { CID } = require('multiformats/cid')\n// @ts-expect-error no types\nconst TimeoutController = require('timeout-abort-controller')\nconst { anySignal } = require('any-signal')\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n}\n\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\nmodule.exports = function ({ repo, codecs, resolve, preload }) {\n  /**\n   * @type {import('ipfs-core-types/src/refs').API[\"refs\"]}\n   */\n  async function * refs (ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format')\n    }\n\n    options.format = options.edges ? Format.edges : options.format\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1\n    }\n\n    if (options.timeout) {\n      const controller = new TimeoutController(options.timeout)\n\n      options.signal = anySignal([options.signal, controller.signal])\n    }\n\n    /** @type {(string|CID)[]} */\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath]\n\n    const paths = rawPaths.map(p => getFullPath(preload, p, options))\n\n    for (const path of paths) {\n      try {\n        yield * refsStream(resolve, repo, codecs, path, options)\n      } catch (err) {\n        yield {\n          ref: '',\n          err: err.message\n        }\n      }\n    }\n  }\n\n  return refs\n}\n\nmodule.exports.Format = Format\n\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nfunction getFullPath (preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCIDAndPath(ipfsPath)\n\n  if (options.preload !== false) {\n    preload(cid)\n  }\n\n  return `/ipfs/${cid}${path || ''}`\n}\n\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nasync function * refsStream (resolve, repo, codecs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path, options)\n  const {\n    cid\n  } = toCIDAndPath(resPath)\n\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity\n  const unique = options.unique || false\n\n  // Traverse the DAG, converting it into a stream\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique, options)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue\n    }\n\n    // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n    if (obj.isDuplicate) {\n      continue\n    }\n\n    // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    }\n  }\n}\n\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\nfunction formatLink (srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString())\n  out = out.replace(/<dst>/g, dstCid.toString())\n  out = out.replace(/<linkname>/g, linkName)\n  return out\n}\n\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n * @param {AbortOptions} options\n */\nasync function * objectStream (repo, codecs, rootCid, maxDepth, uniqueOnly, options) { // eslint-disable-line require-await\n  const seen = new Set()\n\n  /**\n   * @param {Node} parent\n   * @param {number} depth\n   * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n   */\n  async function * traverseLevel (parent, depth) {\n    const nextLevelDepth = depth + 1\n\n    // Check the depth\n    if (nextLevelDepth > maxDepth) {\n      return\n    }\n\n    // Get this object's links\n    try {\n      // Look at each link, parent and the new depth\n      for await (const link of getLinks(repo, codecs, parent.cid, options)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        }\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString())\n        }\n\n        yield * traverseLevel(link, nextLevelDepth)\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`\n      }\n\n      throw err\n    }\n  }\n\n  yield * traverseLevel({ cid: rootCid }, 0)\n}\n\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} cid\n * @param {AbortOptions} options\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\nasync function * getLinks (repo, codecs, cid, options) {\n  const block = await repo.blocks.get(cid, options)\n  const codec = await codecs.getCodec(cid.code)\n  const value = codec.decode(block)\n  const isDagPb = cid.code === dagPb.code\n  /** @type {Array<string|number>} */\n  const base = []\n\n  for (const [name, cid] of links(value, base)) {\n    // special case for dag-pb - use the name of the link\n    // instead of the path within the object\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/)\n\n      if (match) {\n        const index = Number(match[1])\n\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          }\n\n          continue\n        }\n      }\n    }\n\n    yield {\n      name,\n      cid\n    }\n  }\n}\n\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nconst links = function * (source, base) {\n  if (source == null) {\n    return\n  }\n\n  if (source instanceof Uint8Array) {\n    return\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key]\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index]\n          const cid = CID.asCID(element)\n\n          // eslint-disable-next-line max-depth\n          if (cid) {\n            yield [elementPath.join('/'), cid]\n          } else if (typeof element === 'object') {\n            yield * links(element, elementPath)\n          }\n        }\n      } else {\n        const cid = CID.asCID(value)\n\n        if (cid) {\n          yield [path.join('/'), cid]\n        } else {\n          yield * links(value, path)\n        }\n      }\n    }\n  }\n\n  // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n  return []\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}