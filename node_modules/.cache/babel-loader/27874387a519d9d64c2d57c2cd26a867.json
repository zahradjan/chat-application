{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst {\n  messages,\n  codes\n} = require('../errors');\n\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n} = require('./utils');\n\nconst merge = require('it-merge');\n\nconst {\n  pipe\n} = require('it-pipe');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n */\n\n/**\n * @typedef {Object} GetData\n * @property {PeerId} from\n * @property {Uint8Array} val\n */\n\n\nclass ContentRouting {\n  /**\n   * @class\n   * @param {import('..')} libp2p\n   */\n  constructor(libp2p) {\n    this.libp2p = libp2p;\n    /** @type {ContentRoutingModule[]} */\n\n    this.routers = libp2p._modules.contentRouting || [];\n    this.dht = libp2p._dht; // If we have the dht, add it to the available content routers\n\n    if (this.dht && libp2p._config.dht.enabled) {\n      this.routers.push(this.dht);\n    }\n  }\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @param {number} [options.maxNumProviders] - maximum number of providers to find\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  async *findProviders(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this.routers.length) {\n      throw errCode(new Error('No content this.routers available'), 'NO_ROUTERS_AVAILABLE');\n    }\n\n    yield* pipe(merge(...this.routers.map(router => router.findProviders(key, options))), source => storeAddresses(source, this.libp2p.peerStore), source => uniquePeers(source), source => maybeLimitSource(source, options.maxNumProviders), source => requirePeers(source));\n  }\n  /**\n   * Iterates over all content routers in parallel to notify it is\n   * a provider of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @returns {Promise<void>}\n   */\n\n\n  async provide(key) {\n    if (!this.routers.length) {\n      throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE');\n    }\n\n    await Promise.all(this.routers.map(router => router.provide(key)));\n  }\n  /**\n   * Store the given key/value pair in the DHT.\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {Object} [options] - put options\n   * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n   * @returns {Promise<void>}\n   */\n\n\n  put(key, value, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n    }\n\n    return this.dht.put(key, value, options);\n  }\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute by default.\n   *\n   * @param {Uint8Array} key\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData>}\n   */\n\n\n  get(key, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n    }\n\n    return this.dht.get(key, options);\n  }\n  /**\n   * Get the `n` values to the given key without sorting.\n   *\n   * @param {Uint8Array} key\n   * @param {number} nVals\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData[]>}\n   */\n\n\n  async getMany(key, nVals, options) {\n    // eslint-disable-line require-await\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n    }\n\n    return this.dht.getMany(key, nVals, options);\n  }\n\n}\n\nmodule.exports = ContentRouting;","map":{"version":3,"names":["errCode","require","messages","codes","storeAddresses","uniquePeers","requirePeers","maybeLimitSource","merge","pipe","ContentRouting","constructor","libp2p","routers","_modules","contentRouting","dht","_dht","_config","enabled","push","findProviders","key","options","length","Error","map","router","source","peerStore","maxNumProviders","provide","Promise","all","put","value","isStarted","NOT_STARTED_YET","DHT_NOT_STARTED","get","getMany","nVals","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/content-routing/index.js"],"sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst { messages, codes } = require('../errors')\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n} = require('./utils')\n\nconst merge = require('it-merge')\nconst { pipe } = require('it-pipe')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n */\n\n/**\n * @typedef {Object} GetData\n * @property {PeerId} from\n * @property {Uint8Array} val\n */\n\nclass ContentRouting {\n  /**\n   * @class\n   * @param {import('..')} libp2p\n   */\n  constructor (libp2p) {\n    this.libp2p = libp2p\n    /** @type {ContentRoutingModule[]} */\n    this.routers = libp2p._modules.contentRouting || []\n    this.dht = libp2p._dht\n\n    // If we have the dht, add it to the available content routers\n    if (this.dht && libp2p._config.dht.enabled) {\n      this.routers.push(this.dht)\n    }\n  }\n\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @param {number} [options.maxNumProviders] - maximum number of providers to find\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async * findProviders (key, options = {}) {\n    if (!this.routers.length) {\n      throw errCode(new Error('No content this.routers available'), 'NO_ROUTERS_AVAILABLE')\n    }\n\n    yield * pipe(\n      merge(\n        ...this.routers.map(router => router.findProviders(key, options))\n      ),\n      (source) => storeAddresses(source, this.libp2p.peerStore),\n      (source) => uniquePeers(source),\n      (source) => maybeLimitSource(source, options.maxNumProviders),\n      (source) => requirePeers(source)\n    )\n  }\n\n  /**\n   * Iterates over all content routers in parallel to notify it is\n   * a provider of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @returns {Promise<void>}\n   */\n  async provide (key) {\n    if (!this.routers.length) {\n      throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE')\n    }\n\n    await Promise.all(this.routers.map((router) => router.provide(key)))\n  }\n\n  /**\n   * Store the given key/value pair in the DHT.\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {Object} [options] - put options\n   * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n   * @returns {Promise<void>}\n   */\n  put (key, value, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n    }\n\n    return this.dht.put(key, value, options)\n  }\n\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute by default.\n   *\n   * @param {Uint8Array} key\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData>}\n   */\n  get (key, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n    }\n\n    return this.dht.get(key, options)\n  }\n\n  /**\n   * Get the `n` values to the given key without sorting.\n   *\n   * @param {Uint8Array} key\n   * @param {number} nVals\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData[]>}\n   */\n  async getMany (key, nVals, options) { // eslint-disable-line require-await\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n    }\n\n    return this.dht.getMany(key, nVals, options)\n  }\n}\n\nmodule.exports = ContentRouting\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}