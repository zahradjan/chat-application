{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar errcode = require('err-code');\n\nvar pTimeout = require('p-timeout');\n\nvar _require = require('uint8arrays/equals'),\n    uint8ArrayEquals = _require.equals;\n\nvar _require2 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require2.toString;\n\nvar libp2pRecord = require('libp2p-record');\n\nvar c = require('../constants');\n\nvar Query = require('../query');\n\nvar utils = require('../utils');\n\nvar Record = libp2pRecord.Record;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../query').DHTQueryResult} DHTQueryResult\n */\n\n/**\n * @param {import('../')} dht\n */\n\nmodule.exports = function (dht) {\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} rec\n   */\n  var putLocal = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, rec) {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", dht.datastore.put(utils.bufferToKey(key), rec));\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function putLocal(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  var getLocal = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key) {\n      var raw, rec;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              dht._log(\"getLocal \".concat(uint8ArrayToString(key, 'base32')));\n\n              _context2.next = 3;\n              return dht.datastore.get(utils.bufferToKey(key));\n\n            case 3:\n              raw = _context2.sent;\n\n              dht._log(\"found \".concat(uint8ArrayToString(key, 'base32'), \" in local datastore\"));\n\n              rec = Record.deserialize(raw);\n              _context2.next = 8;\n              return dht._verifyRecordLocally(rec);\n\n            case 8:\n              return _context2.abrupt(\"return\", rec);\n\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function getLocal(_x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Uint8Array} key\n   * @param {import('../query').DHTQueryValue[]} vals - values retrieved from the DHT\n   * @param {Uint8Array} best - the best record that was found\n   */\n\n\n  var sendCorrectionRecord = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(key, vals, best) {\n      var fixupRec;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return utils.createPutRecord(key, best);\n\n            case 2:\n              fixupRec = _context4.sent;\n              return _context4.abrupt(\"return\", Promise.all(vals.map( /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(v) {\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          if (!uint8ArrayEquals(v.val, best)) {\n                            _context3.next = 2;\n                            break;\n                          }\n\n                          return _context3.abrupt(\"return\");\n\n                        case 2:\n                          if (!dht._isSelf(v.from)) {\n                            _context3.next = 12;\n                            break;\n                          }\n\n                          _context3.prev = 3;\n                          _context3.next = 6;\n                          return dht._putLocal(key, fixupRec);\n\n                        case 6:\n                          _context3.next = 11;\n                          break;\n\n                        case 8:\n                          _context3.prev = 8;\n                          _context3.t0 = _context3[\"catch\"](3);\n\n                          dht._log.error('Failed error correcting self', _context3.t0);\n\n                        case 11:\n                          return _context3.abrupt(\"return\");\n\n                        case 12:\n                          _context3.prev = 12;\n                          _context3.next = 15;\n                          return dht._putValueToPeer(key, fixupRec, v.from);\n\n                        case 15:\n                          _context3.next = 20;\n                          break;\n\n                        case 17:\n                          _context3.prev = 17;\n                          _context3.t1 = _context3[\"catch\"](12);\n\n                          dht._log.error('Failed error correcting entry', _context3.t1);\n\n                        case 20:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3, null, [[3, 8], [12, 17]]);\n                }));\n\n                return function (_x7) {\n                  return _ref4.apply(this, arguments);\n                };\n              }())));\n\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function sendCorrectionRecord(_x4, _x5, _x6) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} rec - encoded record\n     */\n    _putLocal: function _putLocal(key, rec) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", putLocal(key, rec));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     * @param {object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     */\n    put: function put(key, value) {\n      var _arguments = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var options, record, counterAll, counterSuccess, minPeers, error;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                options = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};\n\n                dht._log('PutValue %b', key); // create record in the dht format\n\n\n                _context7.next = 4;\n                return utils.createPutRecord(key, value);\n\n              case 4:\n                record = _context7.sent;\n                _context7.next = 7;\n                return putLocal(key, record);\n\n              case 7:\n                // put record to the closest peers\n                counterAll = 0;\n                counterSuccess = 0;\n                _context7.next = 11;\n                return utils.mapParallel(dht.getClosestPeers(key, {\n                  shallow: true\n                }), /*#__PURE__*/function () {\n                  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(peer) {\n                    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            _context6.prev = 0;\n                            counterAll += 1;\n                            _context6.next = 4;\n                            return dht._putValueToPeer(key, record, peer);\n\n                          case 4:\n                            counterSuccess += 1;\n                            _context6.next = 10;\n                            break;\n\n                          case 7:\n                            _context6.prev = 7;\n                            _context6.t0 = _context6[\"catch\"](0);\n\n                            dht._log.error('Failed to put to peer (%b): %s', peer.id, _context6.t0);\n\n                          case 10:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6, null, [[0, 7]]);\n                  }));\n\n                  return function (_x8) {\n                    return _ref5.apply(this, arguments);\n                  };\n                }());\n\n              case 11:\n                // verify if we were able to put to enough peers\n                minPeers = options.minPeers || counterAll; // Ensure we have a default `minPeers`\n\n                if (!(minPeers > counterSuccess)) {\n                  _context7.next = 16;\n                  break;\n                }\n\n                error = errcode(new Error(\"Failed to put value to enough peers: \".concat(counterSuccess, \"/\").concat(minPeers)), 'ERR_NOT_ENOUGH_PUT_PEERS');\n\n                dht._log.error(error);\n\n                throw error;\n\n              case 16:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }))();\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Uint8Array} key\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    get: function get(key) {\n      var _arguments2 = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var options, vals, recs, i, best;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                options = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};\n                options.timeout = options.timeout || c.minute;\n\n                dht._log('_get %b', key);\n\n                _context8.next = 5;\n                return dht.getMany(key, c.GET_MANY_RECORD_COUNT, options);\n\n              case 5:\n                vals = _context8.sent;\n                recs = vals.map(function (v) {\n                  return v.val;\n                });\n                i = 0;\n                _context8.prev = 8;\n                i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);\n                _context8.next = 16;\n                break;\n\n              case 12:\n                _context8.prev = 12;\n                _context8.t0 = _context8[\"catch\"](8);\n\n                if (!(_context8.t0.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY')) {\n                  _context8.next = 16;\n                  break;\n                }\n\n                throw _context8.t0;\n\n              case 16:\n                best = recs[i];\n\n                dht._log('GetValue %b %s', key, best);\n\n                if (best) {\n                  _context8.next = 20;\n                  break;\n                }\n\n                throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND');\n\n              case 20:\n                _context8.next = 22;\n                return sendCorrectionRecord(key, vals, best);\n\n              case 22:\n                return _context8.abrupt(\"return\", best);\n\n              case 23:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, null, [[8, 12]]);\n      }))();\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Uint8Array} key\n     * @param {number} nvals\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    getMany: function getMany(key, nvals) {\n      var _arguments3 = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var options, vals, localRec, id, rtp, errMsg, valsLength, createQuery, query;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                createQuery = function _createQuery(pathIndex, numPaths) {\n                  // This function body runs once per disjoint path\n                  var pathSize = utils.pathSize(nvals - valsLength, numPaths);\n                  var queryResults = 0;\n                  /**\n                   * Here we return the query function to use on this particular disjoint path\n                   *\n                   * @param {PeerId} peer\n                   */\n\n                  function disjointPathQuery(_x9) {\n                    return _disjointPathQuery.apply(this, arguments);\n                  }\n\n                  function _disjointPathQuery() {\n                    _disjointPathQuery = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(peer) {\n                      var rec, peers, lookupErr, results, res;\n                      return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                        while (1) {\n                          switch (_context9.prev = _context9.next) {\n                            case 0:\n                              _context9.prev = 0;\n                              _context9.next = 3;\n                              return dht._getValueOrPeers(peer, key);\n\n                            case 3:\n                              results = _context9.sent;\n                              rec = results.record;\n                              peers = results.peers;\n                              _context9.next = 13;\n                              break;\n\n                            case 8:\n                              _context9.prev = 8;\n                              _context9.t0 = _context9[\"catch\"](0);\n\n                              if (!(_context9.t0.code !== 'ERR_INVALID_RECORD')) {\n                                _context9.next = 12;\n                                break;\n                              }\n\n                              throw _context9.t0;\n\n                            case 12:\n                              lookupErr = _context9.t0;\n\n                            case 13:\n                              /** @type {import('../query').QueryResult} */\n                              res = {\n                                closerPeers: peers\n                              };\n\n                              if (rec && rec.value) {\n                                vals.push({\n                                  val: rec.value,\n                                  from: peer\n                                });\n                                queryResults++;\n                              } else if (lookupErr) {\n                                vals.push({\n                                  err: lookupErr,\n                                  from: peer\n                                });\n                                queryResults++;\n                              } // enough is enough\n\n\n                              if (queryResults >= pathSize) {\n                                res.pathComplete = true;\n                              }\n\n                              return _context9.abrupt(\"return\", res);\n\n                            case 17:\n                            case \"end\":\n                              return _context9.stop();\n                          }\n                        }\n                      }, _callee9, null, [[0, 8]]);\n                    }));\n                    return _disjointPathQuery.apply(this, arguments);\n                  }\n\n                  return disjointPathQuery;\n                };\n\n                options = _arguments3.length > 2 && _arguments3[2] !== undefined ? _arguments3[2] : {};\n                options.timeout = options.timeout || c.minute;\n\n                dht._log('getMany %b (%s)', key, nvals);\n\n                vals = [];\n                _context10.prev = 5;\n                _context10.next = 8;\n                return getLocal(key);\n\n              case 8:\n                localRec = _context10.sent;\n                _context10.next = 15;\n                break;\n\n              case 11:\n                _context10.prev = 11;\n                _context10.t0 = _context10[\"catch\"](5);\n\n                if (!(nvals === 0)) {\n                  _context10.next = 15;\n                  break;\n                }\n\n                throw _context10.t0;\n\n              case 15:\n                if (localRec) {\n                  vals.push({\n                    val: localRec.value,\n                    from: dht.peerId\n                  });\n                }\n\n                if (!(vals.length >= nvals)) {\n                  _context10.next = 18;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", vals);\n\n              case 18:\n                _context10.next = 20;\n                return utils.convertBuffer(key);\n\n              case 20:\n                id = _context10.sent;\n                rtp = dht.routingTable.closestPeers(id, dht.kBucketSize);\n\n                dht._log('peers in rt: %d', rtp.length);\n\n                if (!(rtp.length === 0)) {\n                  _context10.next = 29;\n                  break;\n                }\n\n                errMsg = 'Failed to lookup key! No peers from routing table!';\n\n                dht._log.error(errMsg);\n\n                if (!(vals.length === 0)) {\n                  _context10.next = 28;\n                  break;\n                }\n\n                throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE');\n\n              case 28:\n                return _context10.abrupt(\"return\", vals);\n\n              case 29:\n                valsLength = vals.length;\n                /**\n                 * @param {number} pathIndex\n                 * @param {number} numPaths\n                 */\n\n                // we have peers, lets send the actual query to them\n                query = new Query(dht, key, createQuery);\n                _context10.prev = 31;\n                _context10.next = 34;\n                return pTimeout(query.run(rtp), options.timeout);\n\n              case 34:\n                _context10.next = 40;\n                break;\n\n              case 36:\n                _context10.prev = 36;\n                _context10.t1 = _context10[\"catch\"](31);\n\n                if (!(vals.length === 0)) {\n                  _context10.next = 40;\n                  break;\n                }\n\n                throw _context10.t1;\n\n              case 40:\n                _context10.prev = 40;\n                query.stop();\n                return _context10.finish(40);\n\n              case 43:\n                return _context10.abrupt(\"return\", vals);\n\n              case 44:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, null, [[5, 11], [31, 36, 40, 43]]);\n      }))();\n    }\n  };\n};","map":{"version":3,"names":["errcode","require","pTimeout","uint8ArrayEquals","equals","uint8ArrayToString","toString","libp2pRecord","c","Query","utils","Record","module","exports","dht","putLocal","key","rec","datastore","put","bufferToKey","getLocal","_log","get","raw","deserialize","_verifyRecordLocally","sendCorrectionRecord","vals","best","createPutRecord","fixupRec","Promise","all","map","v","val","_isSelf","from","_putLocal","error","_putValueToPeer","value","options","record","counterAll","counterSuccess","mapParallel","getClosestPeers","shallow","peer","id","minPeers","Error","timeout","minute","getMany","GET_MANY_RECORD_COUNT","recs","i","selection","bestRecord","selectors","code","nvals","createQuery","pathIndex","numPaths","pathSize","valsLength","queryResults","disjointPathQuery","_getValueOrPeers","results","peers","lookupErr","res","closerPeers","push","err","pathComplete","localRec","peerId","length","convertBuffer","rtp","routingTable","closestPeers","kBucketSize","errMsg","query","run","stop"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-kad-dht/src/content-fetching/index.js"],"sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst libp2pRecord = require('libp2p-record')\nconst c = require('../constants')\nconst Query = require('../query')\nconst utils = require('../utils')\nconst Record = libp2pRecord.Record\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../query').DHTQueryResult} DHTQueryResult\n */\n\n/**\n * @param {import('../')} dht\n */\nmodule.exports = (dht) => {\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} rec\n   */\n  const putLocal = async (key, rec) => { // eslint-disable-line require-await\n    return dht.datastore.put(utils.bufferToKey(key), rec)\n  }\n\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Uint8Array} key\n   */\n  const getLocal = async (key) => {\n    dht._log(`getLocal ${uint8ArrayToString(key, 'base32')}`)\n\n    const raw = await dht.datastore.get(utils.bufferToKey(key))\n    dht._log(`found ${uint8ArrayToString(key, 'base32')} in local datastore`)\n\n    const rec = Record.deserialize(raw)\n\n    await dht._verifyRecordLocally(rec)\n\n    return rec\n  }\n\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Uint8Array} key\n   * @param {import('../query').DHTQueryValue[]} vals - values retrieved from the DHT\n   * @param {Uint8Array} best - the best record that was found\n   */\n  const sendCorrectionRecord = async (key, vals, best) => {\n    const fixupRec = await utils.createPutRecord(key, best)\n\n    return Promise.all(vals.map(async (v) => {\n      // no need to do anything\n      if (uint8ArrayEquals(v.val, best)) {\n        return\n      }\n\n      // correct ourself\n      if (dht._isSelf(v.from)) {\n        try {\n          await dht._putLocal(key, fixupRec)\n        } catch (err) {\n          dht._log.error('Failed error correcting self', err)\n        }\n        return\n      }\n\n      // send correction\n      try {\n        await dht._putValueToPeer(key, fixupRec, v.from)\n      } catch (err) {\n        dht._log.error('Failed error correcting entry', err)\n      }\n    }))\n  }\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} rec - encoded record\n     */\n    async _putLocal (key, rec) { // eslint-disable-line require-await\n      return putLocal(key, rec)\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     * @param {object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     */\n    async put (key, value, options = {}) {\n      dht._log('PutValue %b', key)\n\n      // create record in the dht format\n      const record = await utils.createPutRecord(key, value)\n\n      // store the record locally\n      await putLocal(key, record)\n\n      // put record to the closest peers\n      let counterAll = 0\n      let counterSuccess = 0\n\n      await utils.mapParallel(dht.getClosestPeers(key, { shallow: true }), async (peer) => {\n        try {\n          counterAll += 1\n          await dht._putValueToPeer(key, record, peer)\n          counterSuccess += 1\n        } catch (err) {\n          dht._log.error('Failed to put to peer (%b): %s', peer.id, err)\n        }\n      })\n\n      // verify if we were able to put to enough peers\n      const minPeers = options.minPeers || counterAll // Ensure we have a default `minPeers`\n\n      if (minPeers > counterSuccess) {\n        const error = errcode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS')\n        dht._log.error(error)\n        throw error\n      }\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Uint8Array} key\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    async get (key, options = {}) {\n      options.timeout = options.timeout || c.minute\n\n      dht._log('_get %b', key)\n\n      const vals = await dht.getMany(key, c.GET_MANY_RECORD_COUNT, options)\n      const recs = vals.map((v) => v.val)\n      let i = 0\n\n      try {\n        i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs)\n      } catch (err) {\n        // Assume the first record if no selector available\n        if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n          throw err\n        }\n      }\n\n      const best = recs[i]\n      dht._log('GetValue %b %s', key, best)\n\n      if (!best) {\n        throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND')\n      }\n\n      await sendCorrectionRecord(key, vals, best)\n\n      return best\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Uint8Array} key\n     * @param {number} nvals\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    async getMany (key, nvals, options = {}) {\n      options.timeout = options.timeout || c.minute\n\n      dht._log('getMany %b (%s)', key, nvals)\n\n      const vals = []\n      let localRec\n\n      try {\n        localRec = await getLocal(key)\n      } catch (err) {\n        if (nvals === 0) {\n          throw err\n        }\n      }\n\n      if (localRec) {\n        vals.push({\n          val: localRec.value,\n          from: dht.peerId\n        })\n      }\n\n      if (vals.length >= nvals) {\n        return vals\n      }\n\n      const id = await utils.convertBuffer(key)\n      const rtp = dht.routingTable.closestPeers(id, dht.kBucketSize)\n\n      dht._log('peers in rt: %d', rtp.length)\n\n      if (rtp.length === 0) {\n        const errMsg = 'Failed to lookup key! No peers from routing table!'\n\n        dht._log.error(errMsg)\n        if (vals.length === 0) {\n          throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE')\n        }\n        return vals\n      }\n\n      const valsLength = vals.length\n\n      /**\n       * @param {number} pathIndex\n       * @param {number} numPaths\n       */\n      function createQuery (pathIndex, numPaths) {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(nvals - valsLength, numPaths)\n        let queryResults = 0\n\n        /**\n         * Here we return the query function to use on this particular disjoint path\n         *\n         * @param {PeerId} peer\n         */\n        async function disjointPathQuery (peer) {\n          let rec, peers, lookupErr\n          try {\n            const results = await dht._getValueOrPeers(peer, key)\n            rec = results.record\n            peers = results.peers\n          } catch (err) {\n            // If we have an invalid record we just want to continue and fetch a new one.\n            if (err.code !== 'ERR_INVALID_RECORD') {\n              throw err\n            }\n            lookupErr = err\n          }\n\n          /** @type {import('../query').QueryResult} */\n          const res = {\n            closerPeers: peers\n          }\n\n          if (rec && rec.value) {\n            vals.push({\n              val: rec.value,\n              from: peer\n            })\n\n            queryResults++\n          } else if (lookupErr) {\n            vals.push({\n              err: lookupErr,\n              from: peer\n            })\n\n            queryResults++\n          }\n\n          // enough is enough\n          if (queryResults >= pathSize) {\n            res.pathComplete = true\n          }\n\n          return res\n        }\n\n        return disjointPathQuery\n      }\n\n      // we have peers, lets send the actual query to them\n      const query = new Query(dht, key, createQuery)\n\n      try {\n        await pTimeout(query.run(rtp), options.timeout)\n      } catch (err) {\n        if (vals.length === 0) {\n          throw err\n        }\n      } finally {\n        query.stop()\n      }\n\n      return vals\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}