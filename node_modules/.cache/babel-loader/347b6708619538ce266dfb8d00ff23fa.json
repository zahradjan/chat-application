{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar Identity = require('./identity');\n\nvar IdentityProvider = require('./identity-provider-interface.js');\n\nvar OrbitDBIdentityProvider = require('./orbit-db-identity-provider');\n\nvar Keystore = require('orbit-db-keystore');\n\nvar LRU = require('lru');\n\nvar path = require('path');\n\nvar defaultType = 'orbitdb';\nvar identityKeysPath = path.join('./orbitdb', 'identity', 'identitykeys');\nvar supportedTypes = {\n  orbitdb: OrbitDBIdentityProvider\n};\n\nvar getHandlerFor = function getHandlerFor(type) {\n  if (!Identities.isSupported(type)) {\n    throw new Error(\"IdentityProvider type '\".concat(type, \"' is not supported\"));\n  }\n\n  return supportedTypes[type];\n};\n\nvar Identities = /*#__PURE__*/function () {\n  function Identities(options) {\n    _classCallCheck(this, Identities);\n\n    this._keystore = options.keystore;\n    this._signingKeystore = options.signingKeystore || this._keystore;\n    this._knownIdentities = options.cache || new LRU(options.cacheSize || 100);\n  }\n\n  _createClass(Identities, [{\n    key: \"keystore\",\n    get: function get() {\n      return this._keystore;\n    }\n  }, {\n    key: \"signingKeystore\",\n    get: function get() {\n      return this._signingKeystore;\n    }\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(identity, data) {\n        var signingKey, sig;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.keystore.getKey(identity.id);\n\n              case 2:\n                signingKey = _context.sent;\n\n                if (signingKey) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Private signing key not found from Keystore\");\n\n              case 5:\n                _context.next = 7;\n                return this.keystore.sign(signingKey, data);\n\n              case 7:\n                sig = _context.sent;\n                return _context.abrupt(\"return\", sig);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sign(_x, _x2) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n  }, {\n    key: \"verify\",\n    value: function () {\n      var _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(signature, publicKey, data) {\n        var verifier,\n            _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                verifier = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 'v1';\n                return _context2.abrupt(\"return\", this.keystore.verify(signature, publicKey, data, verifier));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function verify(_x3, _x4, _x5) {\n        return _verify.apply(this, arguments);\n      }\n\n      return verify;\n    }()\n  }, {\n    key: \"createIdentity\",\n    value: function () {\n      var _createIdentity = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var options,\n            keystore,\n            type,\n            identityProvider,\n            id,\n            _yield$this$signId,\n            publicKey,\n            idSignature,\n            pubKeyIdSignature,\n            _args3 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n                keystore = options.keystore || this.keystore;\n                type = options.type || defaultType;\n                identityProvider = type === defaultType ? new OrbitDBIdentityProvider(options.signingKeystore || keystore) : new (getHandlerFor(type))(options);\n                _context3.next = 6;\n                return identityProvider.getId(options);\n\n              case 6:\n                id = _context3.sent;\n\n                if (!options.migrate) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                _context3.next = 10;\n                return options.migrate({\n                  targetStore: keystore._store,\n                  targetId: id\n                });\n\n              case 10:\n                _context3.next = 12;\n                return this.signId(id);\n\n              case 12:\n                _yield$this$signId = _context3.sent;\n                publicKey = _yield$this$signId.publicKey;\n                idSignature = _yield$this$signId.idSignature;\n                _context3.next = 17;\n                return identityProvider.signIdentity(publicKey + idSignature, options);\n\n              case 17:\n                pubKeyIdSignature = _context3.sent;\n                return _context3.abrupt(\"return\", new Identity(id, publicKey, idSignature, pubKeyIdSignature, type, this));\n\n              case 19:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function createIdentity() {\n        return _createIdentity.apply(this, arguments);\n      }\n\n      return createIdentity;\n    }()\n  }, {\n    key: \"signId\",\n    value: function () {\n      var _signId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(id) {\n        var keystore, key, publicKey, idSignature;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                keystore = this.keystore;\n                _context4.next = 3;\n                return keystore.getKey(id);\n\n              case 3:\n                _context4.t0 = _context4.sent;\n\n                if (_context4.t0) {\n                  _context4.next = 8;\n                  break;\n                }\n\n                _context4.next = 7;\n                return keystore.createKey(id);\n\n              case 7:\n                _context4.t0 = _context4.sent;\n\n              case 8:\n                key = _context4.t0;\n                publicKey = keystore.getPublic(key);\n                _context4.next = 12;\n                return keystore.sign(key, id);\n\n              case 12:\n                idSignature = _context4.sent;\n                return _context4.abrupt(\"return\", {\n                  publicKey: publicKey,\n                  idSignature: idSignature\n                });\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function signId(_x6) {\n        return _signId.apply(this, arguments);\n      }\n\n      return signId;\n    }()\n  }, {\n    key: \"verifyIdentity\",\n    value: function () {\n      var _verifyIdentity = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(identity) {\n        var knownID, verifyIdSig, IdentityProvider, verified;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (Identity.isIdentity(identity)) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", false);\n\n              case 2:\n                knownID = this._knownIdentities.get(identity.signatures.id);\n\n                if (!knownID) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", identity.id === knownID.id && identity.publicKey === knownID.publicKey && identity.signatures.id === knownID.signatures.id && identity.signatures.publicKey === knownID.signatures.publicKey);\n\n              case 5:\n                _context5.next = 7;\n                return this.keystore.verify(identity.signatures.id, identity.publicKey, identity.id);\n\n              case 7:\n                verifyIdSig = _context5.sent;\n\n                if (verifyIdSig) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", false);\n\n              case 10:\n                IdentityProvider = getHandlerFor(identity.type);\n                _context5.next = 13;\n                return IdentityProvider.verifyIdentity(identity);\n\n              case 13:\n                verified = _context5.sent;\n\n                if (verified) {\n                  this._knownIdentities.set(identity.signatures.id, Identity.toJSON(identity));\n                }\n\n                return _context5.abrupt(\"return\", verified);\n\n              case 16:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function verifyIdentity(_x7) {\n        return _verifyIdentity.apply(this, arguments);\n      }\n\n      return verifyIdentity;\n    }()\n  }], [{\n    key: \"IdentityProvider\",\n    get: function get() {\n      return IdentityProvider;\n    }\n  }, {\n    key: \"verifyIdentity\",\n    value: function () {\n      var _verifyIdentity2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(identity) {\n        var verifyIdSig, IdentityProvider;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (Identity.isIdentity(identity)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", false);\n\n              case 2:\n                _context6.next = 4;\n                return Keystore.verify(identity.signatures.id, identity.publicKey, identity.id);\n\n              case 4:\n                verifyIdSig = _context6.sent;\n\n                if (verifyIdSig) {\n                  _context6.next = 7;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", false);\n\n              case 7:\n                IdentityProvider = getHandlerFor(identity.type);\n                return _context6.abrupt(\"return\", IdentityProvider.verifyIdentity(identity));\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function verifyIdentity(_x8) {\n        return _verifyIdentity2.apply(this, arguments);\n      }\n\n      return verifyIdentity;\n    }()\n  }, {\n    key: \"createIdentity\",\n    value: function () {\n      var _createIdentity2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var options,\n            identities,\n            _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                options = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};\n\n                if (!options.keystore) {\n                  options.keystore = new Keystore(options.identityKeysPath || identityKeysPath);\n                }\n\n                if (!options.signingKeystore) {\n                  if (options.signingKeysPath) {\n                    options.signingKeystore = new Keystore(options.signingKeysPath);\n                  } else {\n                    options.signingKeystore = options.keystore;\n                  }\n                }\n\n                options = Object.assign({}, {\n                  type: defaultType\n                }, options);\n                identities = new Identities(options);\n                return _context7.abrupt(\"return\", identities.createIdentity(options));\n\n              case 6:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function createIdentity() {\n        return _createIdentity2.apply(this, arguments);\n      }\n\n      return createIdentity;\n    }()\n  }, {\n    key: \"isSupported\",\n    value: function isSupported(type) {\n      return Object.keys(supportedTypes).includes(type);\n    }\n  }, {\n    key: \"addIdentityProvider\",\n    value: function addIdentityProvider(IdentityProvider) {\n      if (!IdentityProvider) {\n        throw new Error('IdentityProvider class needs to be given as an option');\n      }\n\n      if (!IdentityProvider.type || typeof IdentityProvider.type !== 'string') {\n        throw new Error('Given IdentityProvider class needs to implement: static get type() { /* return a string */}.');\n      }\n\n      supportedTypes[IdentityProvider.type] = IdentityProvider;\n    }\n  }, {\n    key: \"removeIdentityProvider\",\n    value: function removeIdentityProvider(type) {\n      delete supportedTypes[type];\n    }\n  }]);\n\n  return Identities;\n}();\n\nmodule.exports = Identities;","map":{"version":3,"names":["Identity","require","IdentityProvider","OrbitDBIdentityProvider","Keystore","LRU","path","defaultType","identityKeysPath","join","supportedTypes","orbitdb","getHandlerFor","type","Identities","isSupported","Error","options","_keystore","keystore","_signingKeystore","signingKeystore","_knownIdentities","cache","cacheSize","identity","data","getKey","id","signingKey","sign","sig","signature","publicKey","verifier","verify","identityProvider","getId","migrate","targetStore","_store","targetId","signId","idSignature","signIdentity","pubKeyIdSignature","createKey","key","getPublic","isIdentity","knownID","get","signatures","verifyIdSig","verifyIdentity","verified","set","toJSON","signingKeysPath","Object","assign","identities","createIdentity","keys","includes","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-identity-provider/src/identities.js"],"sourcesContent":["'use strict'\nconst Identity = require('./identity')\nconst IdentityProvider = require('./identity-provider-interface.js')\nconst OrbitDBIdentityProvider = require('./orbit-db-identity-provider')\nconst Keystore = require('orbit-db-keystore')\n\nconst LRU = require('lru')\nconst path = require('path')\n\nconst defaultType = 'orbitdb'\nconst identityKeysPath = path.join('./orbitdb', 'identity', 'identitykeys')\n\nconst supportedTypes = {\n  orbitdb: OrbitDBIdentityProvider\n}\n\nconst getHandlerFor = (type) => {\n  if (!Identities.isSupported(type)) {\n    throw new Error(`IdentityProvider type '${type}' is not supported`)\n  }\n  return supportedTypes[type]\n}\n\nclass Identities {\n  constructor (options) {\n    this._keystore = options.keystore\n    this._signingKeystore = options.signingKeystore || this._keystore\n    this._knownIdentities = options.cache || new LRU(options.cacheSize || 100)\n  }\n\n  static get IdentityProvider () { return IdentityProvider }\n\n  get keystore () { return this._keystore }\n\n  get signingKeystore () { return this._signingKeystore }\n\n  async sign (identity, data) {\n    const signingKey = await this.keystore.getKey(identity.id)\n    if (!signingKey) {\n      throw new Error(`Private signing key not found from Keystore`)\n    }\n    const sig = await this.keystore.sign(signingKey, data)\n    return sig\n  }\n\n  async verify (signature, publicKey, data, verifier = 'v1') {\n    return this.keystore.verify(signature, publicKey, data, verifier)\n  }\n\n  async createIdentity (options = {}) {\n    const keystore = options.keystore || this.keystore\n    const type = options.type || defaultType\n    const identityProvider = type === defaultType ? new OrbitDBIdentityProvider(options.signingKeystore || keystore) : new (getHandlerFor(type))(options)\n    const id = await identityProvider.getId(options)\n\n    if (options.migrate) {\n      await options.migrate({ targetStore: keystore._store, targetId: id })\n    }\n    const { publicKey, idSignature } = await this.signId(id)\n    const pubKeyIdSignature = await identityProvider.signIdentity(publicKey + idSignature, options)\n    return new Identity(id, publicKey, idSignature, pubKeyIdSignature, type, this)\n  }\n\n  async signId (id) {\n    const keystore = this.keystore\n    const key = await keystore.getKey(id) || await keystore.createKey(id)\n    const publicKey = keystore.getPublic(key)\n    const idSignature = await keystore.sign(key, id)\n    return { publicKey, idSignature }\n  }\n\n  async verifyIdentity (identity) {\n    if (!Identity.isIdentity(identity)) {\n      return false\n    }\n\n    const knownID = this._knownIdentities.get(identity.signatures.id)\n    if (knownID) {\n      return identity.id === knownID.id &&\n             identity.publicKey === knownID.publicKey &&\n             identity.signatures.id === knownID.signatures.id &&\n             identity.signatures.publicKey === knownID.signatures.publicKey\n    }\n\n    const verifyIdSig = await this.keystore.verify(\n      identity.signatures.id,\n      identity.publicKey,\n      identity.id\n    )\n    if (!verifyIdSig) return false\n\n    const IdentityProvider = getHandlerFor(identity.type)\n    const verified = await IdentityProvider.verifyIdentity(identity)\n    if (verified) {\n      this._knownIdentities.set(identity.signatures.id, Identity.toJSON(identity))\n    }\n\n    return verified\n  }\n\n  static async verifyIdentity (identity) {\n    if (!Identity.isIdentity(identity)) {\n      return false\n    }\n\n    const verifyIdSig = await Keystore.verify(\n      identity.signatures.id,\n      identity.publicKey,\n      identity.id\n    )\n\n    if (!verifyIdSig) return false\n\n    const IdentityProvider = getHandlerFor(identity.type)\n    return IdentityProvider.verifyIdentity(identity)\n  }\n\n  static async createIdentity (options = {}) {\n    if (!options.keystore) {\n      options.keystore = new Keystore(options.identityKeysPath || identityKeysPath)\n    }\n    if (!options.signingKeystore) {\n      if (options.signingKeysPath) {\n        options.signingKeystore = new Keystore(options.signingKeysPath)\n      } else {\n        options.signingKeystore = options.keystore\n      }\n    }\n    options = Object.assign({}, { type: defaultType }, options)\n    const identities = new Identities(options)\n    return identities.createIdentity(options)\n  }\n\n  static isSupported (type) {\n    return Object.keys(supportedTypes).includes(type)\n  }\n\n  static addIdentityProvider (IdentityProvider) {\n    if (!IdentityProvider) {\n      throw new Error('IdentityProvider class needs to be given as an option')\n    }\n\n    if (!IdentityProvider.type ||\n      typeof IdentityProvider.type !== 'string') {\n      throw new Error('Given IdentityProvider class needs to implement: static get type() { /* return a string */}.')\n    }\n\n    supportedTypes[IdentityProvider.type] = IdentityProvider\n  }\n\n  static removeIdentityProvider (type) {\n    delete supportedTypes[type]\n  }\n}\n\nmodule.exports = Identities\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}