{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PeerScore = void 0;\n\nconst peer_score_params_1 = require(\"./peer-score-params\");\n\nconst peer_stats_1 = require(\"./peer-stats\");\n\nconst compute_score_1 = require(\"./compute-score\");\n\nconst message_deliveries_1 = require(\"./message-deliveries\");\n\nconst constants_1 = require(\"../constants\");\n\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\n\nconst debug = require(\"debug\");\n\nconst pubsubErrors = require(\"libp2p-interfaces/src/pubsub/errors\");\n\nconst {\n  ERR_INVALID_SIGNATURE,\n  ERR_MISSING_SIGNATURE\n} = pubsubErrors.codes;\nconst log = debug('libp2p:gossipsub:score');\n\nclass PeerScore {\n  constructor(params, connectionManager, msgId) {\n    peer_score_params_1.validatePeerScoreParams(params);\n    this.params = params;\n    this._connectionManager = connectionManager;\n    this.peerStats = new Map();\n    this.peerIPs = new Map();\n    this.deliveryRecords = new message_deliveries_1.MessageDeliveries();\n    this.msgId = msgId;\n  }\n  /**\n   * Start PeerScore instance\n   * @returns {void}\n   */\n\n\n  start() {\n    if (this._backgroundInterval) {\n      log('Peer score already running');\n      return;\n    }\n\n    this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);\n    log('started');\n  }\n  /**\n   * Stop PeerScore instance\n   * @returns {void}\n   */\n\n\n  stop() {\n    if (!this._backgroundInterval) {\n      log('Peer score already stopped');\n      return;\n    }\n\n    clearInterval(this._backgroundInterval);\n    delete this._backgroundInterval;\n    this.peerIPs.clear();\n    this.peerStats.clear();\n    this.deliveryRecords.clear();\n    log('stopped');\n  }\n  /**\n   * Periodic maintenance\n   * @returns {void}\n   */\n\n\n  background() {\n    this._refreshScores();\n\n    this._updateIPs();\n\n    this.deliveryRecords.gc();\n  }\n  /**\n   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n   * @returns {void}\n   */\n\n\n  _refreshScores() {\n    const now = Date.now();\n    const decayToZero = this.params.decayToZero;\n    this.peerStats.forEach((pstats, id) => {\n      if (!pstats.connected) {\n        // has the retention perious expired?\n        if (now > pstats.expire) {\n          // yes, throw it away (but clean up the IP tracking first)\n          this._removeIPs(id, pstats.ips);\n\n          this.peerStats.delete(id);\n        } // we don't decay retained scores, as the peer is not active.\n        // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n        // unless the retention period has ellapsed.\n        // similarly, a well behaved peer does not lose its score by getting disconnected.\n\n\n        return;\n      }\n\n      Object.entries(pstats.topics).forEach(_ref => {\n        let [topic, tstats] = _ref;\n        const tparams = this.params.topics[topic];\n\n        if (!tparams) {\n          // we are not scoring this topic\n          // should be unreachable, we only add scored topics to pstats\n          return;\n        } // decay counters\n\n\n        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;\n\n        if (tstats.firstMessageDeliveries < decayToZero) {\n          tstats.firstMessageDeliveries = 0;\n        }\n\n        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;\n\n        if (tstats.meshMessageDeliveries < decayToZero) {\n          tstats.meshMessageDeliveries = 0;\n        }\n\n        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;\n\n        if (tstats.meshFailurePenalty < decayToZero) {\n          tstats.meshFailurePenalty = 0;\n        }\n\n        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;\n\n        if (tstats.invalidMessageDeliveries < decayToZero) {\n          tstats.invalidMessageDeliveries = 0;\n        } // update mesh time and activate mesh message delivery parameter if need be\n\n\n        if (tstats.inMesh) {\n          tstats.meshTime = now - tstats.graftTime;\n\n          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n            tstats.meshMessageDeliveriesActive = true;\n          }\n        }\n      }); // decay P7 counter\n\n      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;\n\n      if (pstats.behaviourPenalty < decayToZero) {\n        pstats.behaviourPenalty = 0;\n      }\n    });\n  }\n  /**\n   * Return the score for a peer\n   * @param {string} id\n   * @returns {Number}\n   */\n\n\n  score(id) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return 0;\n    }\n\n    return compute_score_1.computeScore(id, pstats, this.params, this.peerIPs);\n  }\n  /**\n   * Apply a behavioural penalty to a peer\n   * @param {string} id\n   * @param {Number} penalty\n   * @returns {void}\n   */\n\n\n  addPenalty(id, penalty) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    pstats.behaviourPenalty += penalty;\n  }\n  /**\n   * @param {string} id\n   * @returns {void}\n   */\n\n\n  addPeer(id) {\n    // create peer stats (not including topic stats for each topic to be scored)\n    // topic stats will be added as needed\n    const pstats = peer_stats_1.createPeerStats({\n      connected: true\n    });\n    this.peerStats.set(id, pstats); // get + update peer IPs\n\n    const ips = this._getIPs(id);\n\n    this._setIPs(id, ips, pstats.ips);\n\n    pstats.ips = ips;\n  }\n  /**\n   * @param {string} id\n   * @returns {void}\n   */\n\n\n  removePeer(id) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    } // decide whether to retain the score; this currently only retains non-positive scores\n    // to dissuade attacks on the score function.\n\n\n    if (this.score(id) > 0) {\n      this._removeIPs(id, pstats.ips);\n\n      this.peerStats.delete(id);\n      return;\n    } // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n    // reset to 0 and mesh delivery penalties applied.\n\n\n    Object.entries(pstats.topics).forEach(_ref2 => {\n      let [topic, tstats] = _ref2;\n      tstats.firstMessageDeliveries = 0;\n      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n\n      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n        const deficit = threshold - tstats.meshMessageDeliveries;\n        tstats.meshFailurePenalty += deficit * deficit;\n      }\n\n      tstats.inMesh = false;\n      tstats.meshMessageDeliveriesActive = false;\n    });\n    pstats.connected = false;\n    pstats.expire = Date.now() + this.params.retainScore;\n  }\n  /**\n   * @param {string} id\n   * @param {String} topic\n   * @returns {void}\n   */\n\n\n  graft(id, topic) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n    if (!tstats) {\n      return;\n    }\n\n    tstats.inMesh = true;\n    tstats.graftTime = Date.now();\n    tstats.meshTime = 0;\n    tstats.meshMessageDeliveriesActive = false;\n  }\n  /**\n   * @param {string} id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  prune(id, topic) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n    if (!tstats) {\n      return;\n    } // sticky mesh delivery rate failure penalty\n\n\n    const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n\n    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n      const deficit = threshold - tstats.meshMessageDeliveries;\n      tstats.meshFailurePenalty += deficit * deficit;\n    }\n\n    tstats.inMesh = false;\n    tstats.meshMessageDeliveriesActive = false;\n  }\n  /**\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n\n\n  validateMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.deliveryRecords.ensureRecord(yield this.msgId(message));\n    });\n  }\n  /**\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n\n\n  deliverMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const id = message.receivedFrom;\n\n      this._markFirstMessageDelivery(id, message);\n\n      const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));\n      const now = Date.now(); // defensive check that this is the first delivery trace -- delivery status should be unknown\n\n      if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {\n        log('unexpected delivery: message from %s was first seen %s ago and has delivery status %d', id, now - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n        return;\n      } // mark the message as valid and reward mesh peers that have already forwarded it to us\n\n\n      drec.status = message_deliveries_1.DeliveryRecordStatus.valid;\n      drec.validated = now;\n      drec.peers.forEach(p => {\n        // this check is to make sure a peer can't send us a message twice and get a double count\n        // if it is a first delivery.\n        if (p !== id) {\n          this._markDuplicateMessageDelivery(p, message);\n        }\n      });\n    });\n  }\n  /**\n   * @param {InMessage} message\n   * @param {string} reason\n   * @returns {Promise<void>}\n   */\n\n\n  rejectMessage(message, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const id = message.receivedFrom;\n\n      switch (reason) {\n        case ERR_MISSING_SIGNATURE:\n        case ERR_INVALID_SIGNATURE:\n          this._markInvalidMessageDelivery(id, message);\n\n          return;\n      }\n\n      const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message)); // defensive check that this is the first rejection -- delivery status should be unknown\n\n      if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {\n        log('unexpected rejection: message from %s was first seen %s ago and has delivery status %d', id, Date.now() - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n        return;\n      }\n\n      switch (reason) {\n        case constants_1.ERR_TOPIC_VALIDATOR_IGNORE:\n          // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n          drec.status = message_deliveries_1.DeliveryRecordStatus.ignored;\n          return;\n      } // mark the message as invalid and penalize peers that have already forwarded it.\n\n\n      drec.status = message_deliveries_1.DeliveryRecordStatus.invalid;\n\n      this._markInvalidMessageDelivery(id, message);\n\n      drec.peers.forEach(p => {\n        this._markInvalidMessageDelivery(p, message);\n      });\n    });\n  }\n  /**\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n\n\n  duplicateMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const id = message.receivedFrom;\n      const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));\n\n      if (drec.peers.has(id)) {\n        // we have already seen this duplicate\n        return;\n      }\n\n      switch (drec.status) {\n        case message_deliveries_1.DeliveryRecordStatus.unknown:\n          // the message is being validated; track the peer delivery and wait for\n          // the Deliver/Reject/Ignore notification.\n          drec.peers.add(id);\n          break;\n\n        case message_deliveries_1.DeliveryRecordStatus.valid:\n          // mark the peer delivery time to only count a duplicate delivery once.\n          drec.peers.add(id);\n\n          this._markDuplicateMessageDelivery(id, message, drec.validated);\n\n          break;\n\n        case message_deliveries_1.DeliveryRecordStatus.invalid:\n          // we no longer track delivery time\n          this._markInvalidMessageDelivery(id, message);\n\n          break;\n      }\n    });\n  }\n  /**\n   * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n   * @param {string} id\n   * @param {InMessage} message\n   * @returns {void}\n   */\n\n\n  _markInvalidMessageDelivery(id, message) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    message.topicIDs.forEach(topic => {\n      const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n      if (!tstats) {\n        return;\n      }\n\n      tstats.invalidMessageDeliveries += 1;\n    });\n  }\n  /**\n   * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n   * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n   * @param {string} id\n   * @param {InMessage} message\n   * @returns {void}\n   */\n\n\n  _markFirstMessageDelivery(id, message) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    message.topicIDs.forEach(topic => {\n      const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n      if (!tstats) {\n        return;\n      }\n\n      let cap = this.params.topics[topic].firstMessageDeliveriesCap;\n      tstats.firstMessageDeliveries += 1;\n\n      if (tstats.firstMessageDeliveries > cap) {\n        tstats.firstMessageDeliveries = cap;\n      }\n\n      if (!tstats.inMesh) {\n        return;\n      }\n\n      cap = this.params.topics[topic].meshMessageDeliveriesCap;\n      tstats.meshMessageDeliveries += 1;\n\n      if (tstats.meshMessageDeliveries > cap) {\n        tstats.meshMessageDeliveries = cap;\n      }\n    });\n  }\n  /**\n   * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n   * as long the message was received within the P3 window.\n   * @param {string} id\n   * @param {InMessage} message\n   * @param {number} validatedTime\n   * @returns {void}\n   */\n\n\n  _markDuplicateMessageDelivery(id, message) {\n    let validatedTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    const now = validatedTime ? Date.now() : 0;\n    message.topicIDs.forEach(topic => {\n      const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n      if (!tstats) {\n        return;\n      }\n\n      if (!tstats.inMesh) {\n        return;\n      }\n\n      const tparams = this.params.topics[topic]; // check against the mesh delivery window -- if the validated time is passed as 0, then\n      // the message was received before we finished validation and thus falls within the mesh\n      // delivery window.\n\n      if (validatedTime && now > validatedTime + tparams.meshMessageDeliveriesWindow) {\n        return;\n      }\n\n      const cap = tparams.meshMessageDeliveriesCap;\n      tstats.meshMessageDeliveries += 1;\n\n      if (tstats.meshMessageDeliveries > cap) {\n        tstats.meshMessageDeliveries = cap;\n      }\n    });\n  }\n  /**\n   * Gets the current IPs for a peer.\n   * @param {string} id\n   * @returns {Array<string>}\n   */\n\n\n  _getIPs(id) {\n    return this._connectionManager.getAll(peer_id_1.default.createFromB58String(id)).map(c => c.remoteAddr.toOptions().host);\n  }\n  /**\n   * Adds tracking for the new IPs in the list, and removes tracking from the obsolete IPs.\n   * @param {string} id\n   * @param {Array<string>} newIPs\n   * @param {Array<string>} oldIPs\n   * @returns {void}\n   */\n\n\n  _setIPs(id, newIPs, oldIPs) {\n    // add the new IPs to the tracking\n    // eslint-disable-next-line no-labels\n    addNewIPs: for (const ip of newIPs) {\n      // check if it is in the old ips list\n      for (const xip of oldIPs) {\n        if (ip === xip) {\n          // eslint-disable-next-line no-labels\n          continue addNewIPs;\n        }\n      } // no, it's a new one -- add it to the tracker\n\n\n      let peers = this.peerIPs.get(ip);\n\n      if (!peers) {\n        peers = new Set();\n        this.peerIPs.set(ip, peers);\n      }\n\n      peers.add(id);\n    } // remove the obsolete old IPs from the tracking\n    // eslint-disable-next-line no-labels\n\n\n    removeOldIPs: for (const ip of oldIPs) {\n      // check if it is in the new ips list\n      for (const xip of newIPs) {\n        if (ip === xip) {\n          // eslint-disable-next-line no-labels\n          continue removeOldIPs;\n        }\n      } // no, its obselete -- remove it from the tracker\n\n\n      const peers = this.peerIPs.get(ip);\n\n      if (!peers) {\n        continue;\n      }\n\n      peers.delete(id);\n\n      if (!peers.size) {\n        this.peerIPs.delete(ip);\n      }\n    }\n  }\n  /**\n   * Removes an IP list from the tracking list for a peer.\n   * @param {string} id\n   * @param {Array<string>} ips\n   * @returns {void}\n   */\n\n\n  _removeIPs(id, ips) {\n    ips.forEach(ip => {\n      const peers = this.peerIPs.get(ip);\n\n      if (!peers) {\n        return;\n      }\n\n      peers.delete(id);\n\n      if (!peers.size) {\n        this.peerIPs.delete(ip);\n      }\n    });\n  }\n  /**\n   * Update all peer IPs to currently open connections\n   * @returns {void}\n   */\n\n\n  _updateIPs() {\n    this.peerStats.forEach((pstats, id) => {\n      const newIPs = this._getIPs(id);\n\n      this._setIPs(id, newIPs, pstats.ips);\n\n      pstats.ips = newIPs;\n    });\n  }\n\n}\n\nexports.PeerScore = PeerScore;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","PeerScore","peer_score_params_1","require","peer_stats_1","compute_score_1","message_deliveries_1","constants_1","peer_id_1","debug","pubsubErrors","ERR_INVALID_SIGNATURE","ERR_MISSING_SIGNATURE","codes","log","constructor","params","connectionManager","msgId","validatePeerScoreParams","_connectionManager","peerStats","Map","peerIPs","deliveryRecords","MessageDeliveries","start","_backgroundInterval","setInterval","background","decayInterval","stop","clearInterval","clear","_refreshScores","_updateIPs","gc","now","Date","decayToZero","forEach","pstats","id","connected","expire","_removeIPs","ips","delete","entries","topics","topic","tstats","tparams","firstMessageDeliveries","firstMessageDeliveriesDecay","meshMessageDeliveries","meshMessageDeliveriesDecay","meshFailurePenalty","meshFailurePenaltyDecay","invalidMessageDeliveries","invalidMessageDeliveriesDecay","inMesh","meshTime","graftTime","meshMessageDeliveriesActivation","meshMessageDeliveriesActive","behaviourPenalty","behaviourPenaltyDecay","score","get","computeScore","addPenalty","penalty","addPeer","createPeerStats","set","_getIPs","_setIPs","removePeer","threshold","meshMessageDeliveriesThreshold","deficit","retainScore","graft","ensureTopicStats","prune","validateMessage","message","ensureRecord","deliverMessage","receivedFrom","_markFirstMessageDelivery","drec","status","DeliveryRecordStatus","unknown","firstSeen","valid","validated","peers","p","_markDuplicateMessageDelivery","rejectMessage","reason","_markInvalidMessageDelivery","ERR_TOPIC_VALIDATOR_IGNORE","ignored","invalid","duplicateMessage","has","add","topicIDs","cap","firstMessageDeliveriesCap","meshMessageDeliveriesCap","validatedTime","meshMessageDeliveriesWindow","getAll","default","createFromB58String","map","c","remoteAddr","toOptions","host","newIPs","oldIPs","addNewIPs","ip","xip","Set","removeOldIPs","size"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-gossipsub/src/score/peer-score.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PeerScore = void 0;\nconst peer_score_params_1 = require(\"./peer-score-params\");\nconst peer_stats_1 = require(\"./peer-stats\");\nconst compute_score_1 = require(\"./compute-score\");\nconst message_deliveries_1 = require(\"./message-deliveries\");\nconst constants_1 = require(\"../constants\");\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\nconst debug = require(\"debug\");\nconst pubsubErrors = require(\"libp2p-interfaces/src/pubsub/errors\");\nconst { ERR_INVALID_SIGNATURE, ERR_MISSING_SIGNATURE } = pubsubErrors.codes;\nconst log = debug('libp2p:gossipsub:score');\nclass PeerScore {\n    constructor(params, connectionManager, msgId) {\n        peer_score_params_1.validatePeerScoreParams(params);\n        this.params = params;\n        this._connectionManager = connectionManager;\n        this.peerStats = new Map();\n        this.peerIPs = new Map();\n        this.deliveryRecords = new message_deliveries_1.MessageDeliveries();\n        this.msgId = msgId;\n    }\n    /**\n     * Start PeerScore instance\n     * @returns {void}\n     */\n    start() {\n        if (this._backgroundInterval) {\n            log('Peer score already running');\n            return;\n        }\n        this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);\n        log('started');\n    }\n    /**\n     * Stop PeerScore instance\n     * @returns {void}\n     */\n    stop() {\n        if (!this._backgroundInterval) {\n            log('Peer score already stopped');\n            return;\n        }\n        clearInterval(this._backgroundInterval);\n        delete this._backgroundInterval;\n        this.peerIPs.clear();\n        this.peerStats.clear();\n        this.deliveryRecords.clear();\n        log('stopped');\n    }\n    /**\n     * Periodic maintenance\n     * @returns {void}\n     */\n    background() {\n        this._refreshScores();\n        this._updateIPs();\n        this.deliveryRecords.gc();\n    }\n    /**\n     * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n     * @returns {void}\n     */\n    _refreshScores() {\n        const now = Date.now();\n        const decayToZero = this.params.decayToZero;\n        this.peerStats.forEach((pstats, id) => {\n            if (!pstats.connected) {\n                // has the retention perious expired?\n                if (now > pstats.expire) {\n                    // yes, throw it away (but clean up the IP tracking first)\n                    this._removeIPs(id, pstats.ips);\n                    this.peerStats.delete(id);\n                }\n                // we don't decay retained scores, as the peer is not active.\n                // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n                // unless the retention period has ellapsed.\n                // similarly, a well behaved peer does not lose its score by getting disconnected.\n                return;\n            }\n            Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n                const tparams = this.params.topics[topic];\n                if (!tparams) {\n                    // we are not scoring this topic\n                    // should be unreachable, we only add scored topics to pstats\n                    return;\n                }\n                // decay counters\n                tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;\n                if (tstats.firstMessageDeliveries < decayToZero) {\n                    tstats.firstMessageDeliveries = 0;\n                }\n                tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;\n                if (tstats.meshMessageDeliveries < decayToZero) {\n                    tstats.meshMessageDeliveries = 0;\n                }\n                tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;\n                if (tstats.meshFailurePenalty < decayToZero) {\n                    tstats.meshFailurePenalty = 0;\n                }\n                tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;\n                if (tstats.invalidMessageDeliveries < decayToZero) {\n                    tstats.invalidMessageDeliveries = 0;\n                }\n                // update mesh time and activate mesh message delivery parameter if need be\n                if (tstats.inMesh) {\n                    tstats.meshTime = now - tstats.graftTime;\n                    if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n                        tstats.meshMessageDeliveriesActive = true;\n                    }\n                }\n            });\n            // decay P7 counter\n            pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;\n            if (pstats.behaviourPenalty < decayToZero) {\n                pstats.behaviourPenalty = 0;\n            }\n        });\n    }\n    /**\n     * Return the score for a peer\n     * @param {string} id\n     * @returns {Number}\n     */\n    score(id) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return 0;\n        }\n        return compute_score_1.computeScore(id, pstats, this.params, this.peerIPs);\n    }\n    /**\n     * Apply a behavioural penalty to a peer\n     * @param {string} id\n     * @param {Number} penalty\n     * @returns {void}\n     */\n    addPenalty(id, penalty) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        pstats.behaviourPenalty += penalty;\n    }\n    /**\n     * @param {string} id\n     * @returns {void}\n     */\n    addPeer(id) {\n        // create peer stats (not including topic stats for each topic to be scored)\n        // topic stats will be added as needed\n        const pstats = peer_stats_1.createPeerStats({\n            connected: true\n        });\n        this.peerStats.set(id, pstats);\n        // get + update peer IPs\n        const ips = this._getIPs(id);\n        this._setIPs(id, ips, pstats.ips);\n        pstats.ips = ips;\n    }\n    /**\n     * @param {string} id\n     * @returns {void}\n     */\n    removePeer(id) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        // decide whether to retain the score; this currently only retains non-positive scores\n        // to dissuade attacks on the score function.\n        if (this.score(id) > 0) {\n            this._removeIPs(id, pstats.ips);\n            this.peerStats.delete(id);\n            return;\n        }\n        // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n        // reset to 0 and mesh delivery penalties applied.\n        Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n            tstats.firstMessageDeliveries = 0;\n            const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n            if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n                const deficit = threshold - tstats.meshMessageDeliveries;\n                tstats.meshFailurePenalty += deficit * deficit;\n            }\n            tstats.inMesh = false;\n            tstats.meshMessageDeliveriesActive = false;\n        });\n        pstats.connected = false;\n        pstats.expire = Date.now() + this.params.retainScore;\n    }\n    /**\n     * @param {string} id\n     * @param {String} topic\n     * @returns {void}\n     */\n    graft(id, topic) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n        if (!tstats) {\n            return;\n        }\n        tstats.inMesh = true;\n        tstats.graftTime = Date.now();\n        tstats.meshTime = 0;\n        tstats.meshMessageDeliveriesActive = false;\n    }\n    /**\n     * @param {string} id\n     * @param {string} topic\n     * @returns {void}\n     */\n    prune(id, topic) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n        if (!tstats) {\n            return;\n        }\n        // sticky mesh delivery rate failure penalty\n        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n            const deficit = threshold - tstats.meshMessageDeliveries;\n            tstats.meshFailurePenalty += deficit * deficit;\n        }\n        tstats.inMesh = false;\n        tstats.meshMessageDeliveriesActive = false;\n    }\n    /**\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n    validateMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.deliveryRecords.ensureRecord(yield this.msgId(message));\n        });\n    }\n    /**\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n    deliverMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const id = message.receivedFrom;\n            this._markFirstMessageDelivery(id, message);\n            const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));\n            const now = Date.now();\n            // defensive check that this is the first delivery trace -- delivery status should be unknown\n            if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {\n                log('unexpected delivery: message from %s was first seen %s ago and has delivery status %d', id, now - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n                return;\n            }\n            // mark the message as valid and reward mesh peers that have already forwarded it to us\n            drec.status = message_deliveries_1.DeliveryRecordStatus.valid;\n            drec.validated = now;\n            drec.peers.forEach(p => {\n                // this check is to make sure a peer can't send us a message twice and get a double count\n                // if it is a first delivery.\n                if (p !== id) {\n                    this._markDuplicateMessageDelivery(p, message);\n                }\n            });\n        });\n    }\n    /**\n     * @param {InMessage} message\n     * @param {string} reason\n     * @returns {Promise<void>}\n     */\n    rejectMessage(message, reason) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const id = message.receivedFrom;\n            switch (reason) {\n                case ERR_MISSING_SIGNATURE:\n                case ERR_INVALID_SIGNATURE:\n                    this._markInvalidMessageDelivery(id, message);\n                    return;\n            }\n            const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));\n            // defensive check that this is the first rejection -- delivery status should be unknown\n            if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {\n                log('unexpected rejection: message from %s was first seen %s ago and has delivery status %d', id, Date.now() - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n                return;\n            }\n            switch (reason) {\n                case constants_1.ERR_TOPIC_VALIDATOR_IGNORE:\n                    // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n                    drec.status = message_deliveries_1.DeliveryRecordStatus.ignored;\n                    return;\n            }\n            // mark the message as invalid and penalize peers that have already forwarded it.\n            drec.status = message_deliveries_1.DeliveryRecordStatus.invalid;\n            this._markInvalidMessageDelivery(id, message);\n            drec.peers.forEach(p => {\n                this._markInvalidMessageDelivery(p, message);\n            });\n        });\n    }\n    /**\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n    duplicateMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const id = message.receivedFrom;\n            const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));\n            if (drec.peers.has(id)) {\n                // we have already seen this duplicate\n                return;\n            }\n            switch (drec.status) {\n                case message_deliveries_1.DeliveryRecordStatus.unknown:\n                    // the message is being validated; track the peer delivery and wait for\n                    // the Deliver/Reject/Ignore notification.\n                    drec.peers.add(id);\n                    break;\n                case message_deliveries_1.DeliveryRecordStatus.valid:\n                    // mark the peer delivery time to only count a duplicate delivery once.\n                    drec.peers.add(id);\n                    this._markDuplicateMessageDelivery(id, message, drec.validated);\n                    break;\n                case message_deliveries_1.DeliveryRecordStatus.invalid:\n                    // we no longer track delivery time\n                    this._markInvalidMessageDelivery(id, message);\n                    break;\n            }\n        });\n    }\n    /**\n     * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n     * @param {string} id\n     * @param {InMessage} message\n     * @returns {void}\n     */\n    _markInvalidMessageDelivery(id, message) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        message.topicIDs.forEach(topic => {\n            const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n            if (!tstats) {\n                return;\n            }\n            tstats.invalidMessageDeliveries += 1;\n        });\n    }\n    /**\n     * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n     * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n     * @param {string} id\n     * @param {InMessage} message\n     * @returns {void}\n     */\n    _markFirstMessageDelivery(id, message) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        message.topicIDs.forEach(topic => {\n            const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n            if (!tstats) {\n                return;\n            }\n            let cap = this.params.topics[topic].firstMessageDeliveriesCap;\n            tstats.firstMessageDeliveries += 1;\n            if (tstats.firstMessageDeliveries > cap) {\n                tstats.firstMessageDeliveries = cap;\n            }\n            if (!tstats.inMesh) {\n                return;\n            }\n            cap = this.params.topics[topic].meshMessageDeliveriesCap;\n            tstats.meshMessageDeliveries += 1;\n            if (tstats.meshMessageDeliveries > cap) {\n                tstats.meshMessageDeliveries = cap;\n            }\n        });\n    }\n    /**\n     * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n     * as long the message was received within the P3 window.\n     * @param {string} id\n     * @param {InMessage} message\n     * @param {number} validatedTime\n     * @returns {void}\n     */\n    _markDuplicateMessageDelivery(id, message, validatedTime = 0) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        const now = validatedTime ? Date.now() : 0;\n        message.topicIDs.forEach(topic => {\n            const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n            if (!tstats) {\n                return;\n            }\n            if (!tstats.inMesh) {\n                return;\n            }\n            const tparams = this.params.topics[topic];\n            // check against the mesh delivery window -- if the validated time is passed as 0, then\n            // the message was received before we finished validation and thus falls within the mesh\n            // delivery window.\n            if (validatedTime && now > validatedTime + tparams.meshMessageDeliveriesWindow) {\n                return;\n            }\n            const cap = tparams.meshMessageDeliveriesCap;\n            tstats.meshMessageDeliveries += 1;\n            if (tstats.meshMessageDeliveries > cap) {\n                tstats.meshMessageDeliveries = cap;\n            }\n        });\n    }\n    /**\n     * Gets the current IPs for a peer.\n     * @param {string} id\n     * @returns {Array<string>}\n     */\n    _getIPs(id) {\n        return this._connectionManager.getAll(peer_id_1.default.createFromB58String(id))\n            .map(c => c.remoteAddr.toOptions().host);\n    }\n    /**\n     * Adds tracking for the new IPs in the list, and removes tracking from the obsolete IPs.\n     * @param {string} id\n     * @param {Array<string>} newIPs\n     * @param {Array<string>} oldIPs\n     * @returns {void}\n     */\n    _setIPs(id, newIPs, oldIPs) {\n        // add the new IPs to the tracking\n        // eslint-disable-next-line no-labels\n        addNewIPs: for (const ip of newIPs) {\n            // check if it is in the old ips list\n            for (const xip of oldIPs) {\n                if (ip === xip) {\n                    // eslint-disable-next-line no-labels\n                    continue addNewIPs;\n                }\n            }\n            // no, it's a new one -- add it to the tracker\n            let peers = this.peerIPs.get(ip);\n            if (!peers) {\n                peers = new Set();\n                this.peerIPs.set(ip, peers);\n            }\n            peers.add(id);\n        }\n        // remove the obsolete old IPs from the tracking\n        // eslint-disable-next-line no-labels\n        removeOldIPs: for (const ip of oldIPs) {\n            // check if it is in the new ips list\n            for (const xip of newIPs) {\n                if (ip === xip) {\n                    // eslint-disable-next-line no-labels\n                    continue removeOldIPs;\n                }\n            }\n            // no, its obselete -- remove it from the tracker\n            const peers = this.peerIPs.get(ip);\n            if (!peers) {\n                continue;\n            }\n            peers.delete(id);\n            if (!peers.size) {\n                this.peerIPs.delete(ip);\n            }\n        }\n    }\n    /**\n     * Removes an IP list from the tracking list for a peer.\n     * @param {string} id\n     * @param {Array<string>} ips\n     * @returns {void}\n     */\n    _removeIPs(id, ips) {\n        ips.forEach(ip => {\n            const peers = this.peerIPs.get(ip);\n            if (!peers) {\n                return;\n            }\n            peers.delete(id);\n            if (!peers.size) {\n                this.peerIPs.delete(ip);\n            }\n        });\n    }\n    /**\n     * Update all peer IPs to currently open connections\n     * @returns {void}\n     */\n    _updateIPs() {\n        this.peerStats.forEach((pstats, id) => {\n            const newIPs = this._getIPs(id);\n            this._setIPs(id, newIPs, pstats.ips);\n            pstats.ips = newIPs;\n        });\n    }\n}\nexports.PeerScore = PeerScore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}