{"ast":null,"code":"'use strict';\n\nconst cache = require('hashlru'); // @ts-ignore\n\n\nconst varint = require('varint');\n\nconst PeerId = require('peer-id');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst c = require('./constants');\n\nconst utils = require('./utils');\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\n\n\nclass Providers {\n  /**\n   * @param {Datastore} datastore\n   * @param {PeerId} [self]\n   * @param {number} [cacheSize=256]\n   */\n  constructor(datastore, self, cacheSize) {\n    this.datastore = datastore;\n    this._log = utils.logger(self, 'providers');\n    /**\n     * How often invalid records are cleaned. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL;\n    /**\n     * How long is a provider valid for. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.provideValidity = c.PROVIDERS_VALIDITY;\n    /**\n     * LRU cache size\n     *\n     * @type {number}\n     */\n\n    this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE; // @ts-ignore hashlru types are wrong\n\n    this.providers = cache(this.lruCacheSize);\n    this.syncQueue = new Queue({\n      concurrency: 1\n    });\n  }\n  /**\n   * Start the provider cleanup service\n   */\n\n\n  start() {\n    if (this._started) {\n      return;\n    }\n\n    this._started = true;\n    this._cleaner = setInterval(() => this._cleanup(), this.cleanupInterval);\n  }\n  /**\n   * Release any resources.\n   */\n\n\n  stop() {\n    this._started = false;\n\n    if (this._cleaner) {\n      clearInterval(this._cleaner);\n      this._cleaner = null;\n    }\n  }\n  /**\n   * Check all providers if they are still valid, and if not delete them.\n   *\n   * @returns {Promise<void>}\n   * @private\n   */\n\n\n  _cleanup() {\n    return this.syncQueue.add(async () => {\n      this._log('start cleanup');\n\n      const start = Date.now();\n      let count = 0;\n      let deleteCount = 0;\n      const deleted = new Map();\n      const batch = this.datastore.batch(); // Get all provider entries from the datastore\n\n      const query = this.datastore.query({\n        prefix: c.PROVIDERS_KEY_PREFIX\n      });\n\n      for await (const entry of query) {\n        try {\n          // Add a delete to the batch for each expired entry\n          const {\n            cid,\n            peerId\n          } = parseProviderKey(entry.key);\n          const time = readTime(entry.value);\n          const now = Date.now();\n          const delta = now - time;\n          const expired = delta > this.provideValidity;\n\n          this._log('comparing: %d - %d = %d > %d %s', now, time, delta, this.provideValidity, expired ? '(expired)' : '');\n\n          if (expired) {\n            deleteCount++;\n            batch.delete(entry.key);\n            const peers = deleted.get(cid) || new Set();\n            peers.add(peerId);\n            deleted.set(cid, peers);\n          }\n\n          count++;\n        } catch (err) {\n          this._log.error(err.message);\n        }\n      }\n\n      this._log('deleting %d / %d entries', deleteCount, count); // Commit the deletes to the datastore\n\n\n      if (deleted.size) {\n        await batch.commit();\n      } // Clear expired entries from the cache\n\n\n      for (const [cid, peers] of deleted) {\n        const key = makeProviderKey(cid);\n        const provs = this.providers.get(key);\n\n        if (provs) {\n          for (const peerId of peers) {\n            provs.delete(peerId);\n          }\n\n          if (provs.size === 0) {\n            this.providers.remove(key);\n          } else {\n            this.providers.set(key, provs);\n          }\n        }\n      }\n\n      this._log('Cleanup successful (%dms)', Date.now() - start);\n    });\n  }\n  /**\n   * Get the currently known provider peer ids for a given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Map<string, Date>>}\n   *\n   * @private\n   */\n\n\n  async _getProvidersMap(cid) {\n    const cacheKey = makeProviderKey(cid);\n    let provs = this.providers.get(cacheKey);\n\n    if (!provs) {\n      provs = await loadProviders(this.datastore, cid);\n      this.providers.set(cacheKey, provs);\n    }\n\n    return provs;\n  }\n  /**\n   * Add a new provider for the given CID.\n   *\n   * @param {CID} cid\n   * @param {PeerId} provider\n   * @returns {Promise<void>}\n   */\n\n\n  async addProvider(cid, provider) {\n    // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      this._log('addProvider %s', cid.toString());\n\n      const provs = await this._getProvidersMap(cid);\n\n      this._log('loaded %s provs', provs.size);\n\n      const now = new Date();\n      provs.set(utils.encodeBase32(provider.id), now);\n      const dsKey = makeProviderKey(cid);\n      this.providers.set(dsKey, provs);\n      return writeProviderEntry(this.datastore, cid, provider, now);\n    });\n  }\n  /**\n   * Get a list of providers for the given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Array<PeerId>>}\n   */\n\n\n  async getProviders(cid) {\n    // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      this._log('getProviders %s', cid.toString());\n\n      const provs = await this._getProvidersMap(cid);\n      return [...provs.keys()].map(base32PeerId => {\n        return new PeerId(utils.decodeBase32(base32PeerId));\n      });\n    });\n  }\n\n}\n/**\n * Encode the given key its matching datastore key.\n *\n * @param {CID|string} cid - cid or base32 encoded string\n * @returns {string}\n *\n * @private\n */\n\n\nfunction makeProviderKey(cid) {\n  cid = typeof cid === 'string' ? cid : utils.encodeBase32(cid.bytes);\n  return c.PROVIDERS_KEY_PREFIX + cid;\n}\n/**\n * Write a provider into the given store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {PeerId} peer\n * @param {Date} time\n */\n\n\nasync function writeProviderEntry(store, cid, peer, time) {\n  // eslint-disable-line require-await\n  const dsKey = [makeProviderKey(cid), '/', utils.encodeBase32(peer.id)].join('');\n  const key = new Key(dsKey);\n  const buffer = Uint8Array.from(varint.encode(time.getTime()));\n  return store.put(key, buffer);\n}\n/**\n * Parse the CID and provider peer id from the key\n *\n * @param {import('interface-datastore').Key} key\n */\n\n\nfunction parseProviderKey(key) {\n  const parts = key.toString().split('/');\n\n  if (parts.length !== 4) {\n    throw new Error('incorrectly formatted provider entry key in datastore: ' + key);\n  }\n\n  return {\n    cid: parts[2],\n    peerId: parts[3]\n  };\n}\n/**\n * Load providers for the given CID from the store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @returns {Promise<Map<PeerId, Date>>}\n *\n * @private\n */\n\n\nasync function loadProviders(store, cid) {\n  const providers = new Map();\n  const query = store.query({\n    prefix: makeProviderKey(cid)\n  });\n\n  for await (const entry of query) {\n    const {\n      peerId\n    } = parseProviderKey(entry.key);\n    providers.set(peerId, readTime(entry.value));\n  }\n\n  return providers;\n}\n/**\n * @param {Uint8Array} buf\n */\n\n\nfunction readTime(buf) {\n  return varint.decode(buf);\n}\n\nmodule.exports = Providers;","map":{"version":3,"names":["cache","require","varint","PeerId","Key","default","Queue","c","utils","Providers","constructor","datastore","self","cacheSize","_log","logger","cleanupInterval","PROVIDERS_CLEANUP_INTERVAL","provideValidity","PROVIDERS_VALIDITY","lruCacheSize","PROVIDERS_LRU_CACHE_SIZE","providers","syncQueue","concurrency","start","_started","_cleaner","setInterval","_cleanup","stop","clearInterval","add","Date","now","count","deleteCount","deleted","Map","batch","query","prefix","PROVIDERS_KEY_PREFIX","entry","cid","peerId","parseProviderKey","key","time","readTime","value","delta","expired","delete","peers","get","Set","set","err","error","message","size","commit","makeProviderKey","provs","remove","_getProvidersMap","cacheKey","loadProviders","addProvider","provider","toString","encodeBase32","id","dsKey","writeProviderEntry","getProviders","keys","map","base32PeerId","decodeBase32","bytes","store","peer","join","buffer","Uint8Array","from","encode","getTime","put","parts","split","length","Error","buf","decode","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-kad-dht/src/providers.js"],"sourcesContent":["'use strict'\n\nconst cache = require('hashlru')\n// @ts-ignore\nconst varint = require('varint')\nconst PeerId = require('peer-id')\nconst { Key } = require('interface-datastore')\nconst { default: Queue } = require('p-queue')\nconst c = require('./constants')\nconst utils = require('./utils')\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\nclass Providers {\n  /**\n   * @param {Datastore} datastore\n   * @param {PeerId} [self]\n   * @param {number} [cacheSize=256]\n   */\n  constructor (datastore, self, cacheSize) {\n    this.datastore = datastore\n\n    this._log = utils.logger(self, 'providers')\n\n    /**\n     * How often invalid records are cleaned. (in seconds)\n     *\n     * @type {number}\n     */\n    this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL\n\n    /**\n     * How long is a provider valid for. (in seconds)\n     *\n     * @type {number}\n     */\n    this.provideValidity = c.PROVIDERS_VALIDITY\n\n    /**\n     * LRU cache size\n     *\n     * @type {number}\n     */\n    this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE\n\n    // @ts-ignore hashlru types are wrong\n    this.providers = cache(this.lruCacheSize)\n\n    this.syncQueue = new Queue({ concurrency: 1 })\n  }\n\n  /**\n   * Start the provider cleanup service\n   */\n  start () {\n    if (this._started) {\n      return\n    }\n\n    this._started = true\n\n    this._cleaner = setInterval(\n      () => this._cleanup(),\n      this.cleanupInterval\n    )\n  }\n\n  /**\n   * Release any resources.\n   */\n  stop () {\n    this._started = false\n\n    if (this._cleaner) {\n      clearInterval(this._cleaner)\n      this._cleaner = null\n    }\n  }\n\n  /**\n   * Check all providers if they are still valid, and if not delete them.\n   *\n   * @returns {Promise<void>}\n   * @private\n   */\n  _cleanup () {\n    return this.syncQueue.add(async () => {\n      this._log('start cleanup')\n      const start = Date.now()\n\n      let count = 0\n      let deleteCount = 0\n      const deleted = new Map()\n      const batch = this.datastore.batch()\n\n      // Get all provider entries from the datastore\n      const query = this.datastore.query({ prefix: c.PROVIDERS_KEY_PREFIX })\n      for await (const entry of query) {\n        try {\n          // Add a delete to the batch for each expired entry\n          const { cid, peerId } = parseProviderKey(entry.key)\n          const time = readTime(entry.value)\n          const now = Date.now()\n          const delta = now - time\n          const expired = delta > this.provideValidity\n          this._log('comparing: %d - %d = %d > %d %s',\n            now, time, delta, this.provideValidity, expired ? '(expired)' : '')\n          if (expired) {\n            deleteCount++\n            batch.delete(entry.key)\n            const peers = deleted.get(cid) || new Set()\n            peers.add(peerId)\n            deleted.set(cid, peers)\n          }\n          count++\n        } catch (err) {\n          this._log.error(err.message)\n        }\n      }\n      this._log('deleting %d / %d entries', deleteCount, count)\n\n      // Commit the deletes to the datastore\n      if (deleted.size) {\n        await batch.commit()\n      }\n\n      // Clear expired entries from the cache\n      for (const [cid, peers] of deleted) {\n        const key = makeProviderKey(cid)\n        const provs = this.providers.get(key)\n        if (provs) {\n          for (const peerId of peers) {\n            provs.delete(peerId)\n          }\n          if (provs.size === 0) {\n            this.providers.remove(key)\n          } else {\n            this.providers.set(key, provs)\n          }\n        }\n      }\n\n      this._log('Cleanup successful (%dms)', Date.now() - start)\n    })\n  }\n\n  /**\n   * Get the currently known provider peer ids for a given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Map<string, Date>>}\n   *\n   * @private\n   */\n  async _getProvidersMap (cid) {\n    const cacheKey = makeProviderKey(cid)\n    let provs = this.providers.get(cacheKey)\n    if (!provs) {\n      provs = await loadProviders(this.datastore, cid)\n      this.providers.set(cacheKey, provs)\n    }\n    return provs\n  }\n\n  /**\n   * Add a new provider for the given CID.\n   *\n   * @param {CID} cid\n   * @param {PeerId} provider\n   * @returns {Promise<void>}\n   */\n  async addProvider (cid, provider) { // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      this._log('addProvider %s', cid.toString())\n      const provs = await this._getProvidersMap(cid)\n\n      this._log('loaded %s provs', provs.size)\n      const now = new Date()\n      provs.set(utils.encodeBase32(provider.id), now)\n\n      const dsKey = makeProviderKey(cid)\n      this.providers.set(dsKey, provs)\n      return writeProviderEntry(this.datastore, cid, provider, now)\n    })\n  }\n\n  /**\n   * Get a list of providers for the given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Array<PeerId>>}\n   */\n  async getProviders (cid) { // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      this._log('getProviders %s', cid.toString())\n      const provs = await this._getProvidersMap(cid)\n      return [...provs.keys()].map((base32PeerId) => {\n        return new PeerId(utils.decodeBase32(base32PeerId))\n      })\n    })\n  }\n}\n\n/**\n * Encode the given key its matching datastore key.\n *\n * @param {CID|string} cid - cid or base32 encoded string\n * @returns {string}\n *\n * @private\n */\nfunction makeProviderKey (cid) {\n  cid = typeof cid === 'string' ? cid : utils.encodeBase32(cid.bytes)\n  return c.PROVIDERS_KEY_PREFIX + cid\n}\n\n/**\n * Write a provider into the given store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {PeerId} peer\n * @param {Date} time\n */\nasync function writeProviderEntry (store, cid, peer, time) { // eslint-disable-line require-await\n  const dsKey = [\n    makeProviderKey(cid),\n    '/',\n    utils.encodeBase32(peer.id)\n  ].join('')\n\n  const key = new Key(dsKey)\n  const buffer = Uint8Array.from(varint.encode(time.getTime()))\n  return store.put(key, buffer)\n}\n\n/**\n * Parse the CID and provider peer id from the key\n *\n * @param {import('interface-datastore').Key} key\n */\nfunction parseProviderKey (key) {\n  const parts = key.toString().split('/')\n  if (parts.length !== 4) {\n    throw new Error('incorrectly formatted provider entry key in datastore: ' + key)\n  }\n\n  return {\n    cid: parts[2],\n    peerId: parts[3]\n  }\n}\n\n/**\n * Load providers for the given CID from the store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @returns {Promise<Map<PeerId, Date>>}\n *\n * @private\n */\nasync function loadProviders (store, cid) {\n  const providers = new Map()\n  const query = store.query({ prefix: makeProviderKey(cid) })\n  for await (const entry of query) {\n    const { peerId } = parseProviderKey(entry.key)\n    providers.set(peerId, readTime(entry.value))\n  }\n  return providers\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction readTime (buf) {\n  return varint.decode(buf)\n}\n\nmodule.exports = Providers\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}