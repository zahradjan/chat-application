{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidPublicKey = exports.getHkdf = exports.verifySignedPayload = exports.getHandshakePayload = exports.decodePayload = exports.getPeerIdFromPayload = exports.signPayload = exports.createHandshakePayload = exports.getPayload = exports.generateKeypair = void 0;\n\nconst hkdf_1 = require(\"@stablelib/hkdf\");\n\nconst sha256_1 = require(\"@stablelib/sha256\");\n\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\n\nconst buffer_1 = require(\"buffer\");\n\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\n\nconst libp2p_crypto_1 = require(\"libp2p-crypto\");\n\nconst payload_1 = require(\"./proto/payload\");\n\nconst equals_1 = require(\"uint8arrays/equals\");\n\nconst NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;\n\nfunction generateKeypair() {\n  const keypair = x25519.generateKeyPair();\n  return {\n    publicKey: buffer_1.Buffer.from(keypair.publicKey.buffer, keypair.publicKey.byteOffset, keypair.publicKey.length),\n    privateKey: buffer_1.Buffer.from(keypair.secretKey.buffer, keypair.secretKey.byteOffset, keypair.secretKey.length)\n  };\n}\n\nexports.generateKeypair = generateKeypair;\n\nasync function getPayload(localPeer, staticPublicKey, earlyData) {\n  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));\n  const earlyDataPayload = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);\n  return createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);\n}\n\nexports.getPayload = getPayload;\n\nfunction createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {\n  const payloadInit = NoiseHandshakePayloadProto.create({\n    identityKey: buffer_1.Buffer.from(libp2pPublicKey),\n    identitySig: signedPayload,\n    data: earlyData !== null && earlyData !== void 0 ? earlyData : null\n  });\n  return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());\n}\n\nexports.createHandshakePayload = createHandshakePayload;\n\nasync function signPayload(peerId, payload) {\n  return buffer_1.Buffer.from(await peerId.privKey.sign(payload));\n}\n\nexports.signPayload = signPayload;\n\nasync function getPeerIdFromPayload(payload) {\n  return await peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));\n}\n\nexports.getPeerIdFromPayload = getPeerIdFromPayload;\n\nfunction decodePayload(payload) {\n  return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));\n}\n\nexports.decodePayload = decodePayload;\n\nfunction getHandshakePayload(publicKey) {\n  return buffer_1.Buffer.concat([buffer_1.Buffer.from('noise-libp2p-static-key:'), publicKey]);\n}\n\nexports.getHandshakePayload = getHandshakePayload;\n\nasync function isValidPeerId(peerId, publicKeyProtobuf) {\n  const generatedPeerId = await peer_id_1.default.createFromPubKey(publicKeyProtobuf);\n  return equals_1.equals(generatedPeerId.id, peerId);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\n\n\nasync function verifySignedPayload(noiseStaticKey, payload, remotePeer) {\n  const identityKey = buffer_1.Buffer.from(payload.identityKey);\n\n  if (!(await isValidPeerId(remotePeer.id, identityKey))) {\n    throw new Error(\"Peer ID doesn't match libp2p public key.\");\n  }\n\n  const generatedPayload = getHandshakePayload(noiseStaticKey); // Unmarshaling from PublicKey protobuf\n\n  const publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey);\n\n  if (!payload.identitySig || !(await publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig)))) {\n    throw new Error(\"Static key doesn't match to peer that signed payload!\");\n  }\n\n  return await peer_id_1.default.createFromPubKey(identityKey);\n}\n\nexports.verifySignedPayload = verifySignedPayload;\n\nfunction getHkdf(ck, ikm) {\n  const hkdf = new hkdf_1.HKDF(sha256_1.SHA256, ikm, ck);\n  const okmU8Array = hkdf.expand(96);\n  const okm = buffer_1.Buffer.from(okmU8Array.buffer, okmU8Array.byteOffset, okmU8Array.length);\n  const k1 = okm.slice(0, 32);\n  const k2 = okm.slice(32, 64);\n  const k3 = okm.slice(64, 96);\n  return [k1, k2, k3];\n}\n\nexports.getHkdf = getHkdf;\n\nfunction isValidPublicKey(pk) {\n  if (!buffer_1.Buffer.isBuffer(pk)) {\n    return false;\n  }\n\n  if (pk.length !== 32) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isValidPublicKey = isValidPublicKey;","map":{"version":3,"mappings":"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","names":["NoiseHandshakePayloadProto","payload_1","NoiseHandshakePayload","generateKeypair","keypair","x25519","generateKeyPair","publicKey","buffer_1","from","buffer","byteOffset","length","privateKey","secretKey","exports","getPayload","localPeer","staticPublicKey","earlyData","signedPayload","signPayload","getHandshakePayload","earlyDataPayload","alloc","createHandshakePayload","marshalPubKey","libp2pPublicKey","payloadInit","create","identityKey","identitySig","data","encode","finish","peerId","payload","privKey","sign","getPeerIdFromPayload","peer_id_1","createFromPubKey","decodePayload","toObject","decode","concat","isValidPeerId","publicKeyProtobuf","generatedPeerId","equals_1","id","verifySignedPayload","noiseStaticKey","remotePeer","Error","generatedPayload","libp2p_crypto_1","unmarshalPublicKey","verify","getHkdf","ck","ikm","hkdf","hkdf_1","sha256_1","okmU8Array","expand","okm","k1","slice","k2","k3","isValidPublicKey","pk","isBuffer"],"sourceRoot":"","sources":["../../src/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}