{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nconst pubsub_1 = __importStar(require(\"libp2p-interfaces/src/pubsub\"));\n\nconst message_cache_1 = require(\"./message-cache\");\n\nconst rpc_1 = require(\"./message/rpc\");\n\nconst constants = __importStar(require(\"./constants\"));\n\nconst heartbeat_1 = require(\"./heartbeat\");\n\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\n\nconst utils_1 = require(\"./utils\");\n\nconst score_1 = require(\"./score\");\n\nconst tracer_1 = require(\"./tracer\"); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\n\nconst TimeCache = require(\"time-cache\");\n\nconst PeerId = require(\"peer-id\"); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\n\nconst Envelope = require(\"libp2p/src/record/envelope\");\n\nclass Gossipsub extends pubsub_1.default {\n  // TODO: add remaining props\n\n  /**\n   * @param {Libp2p} libp2p\n   * @param {Object} [options]\n   * @param {boolean} [options.emitSelf = false] if publish should emit to self, if subscribed\n   * @param {boolean} [options.canRelayMessage = false] - if can relay messages not subscribed\n   * @param {boolean} [options.gossipIncoming = true] if incoming messages on a subscribed topic should be automatically gossiped\n   * @param {boolean} [options.fallbackToFloodsub = true] if dial should fallback to floodsub\n   * @param {boolean} [options.floodPublish = true] if self-published messages should be sent to all peers\n   * @param {boolean} [options.doPX = false] whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes.\n   * @param {Object} [options.messageCache] override the default MessageCache\n   * @param {string} [options.globalSignaturePolicy = \"StrictSign\"] signing policy to apply across all messages\n   * @param {Object} [options.scoreParams] peer score parameters\n   * @param {Object} [options.scoreThresholds] peer score thresholds\n   * @param {AddrInfo[]} [options.directPeers] peers with which we will maintain direct connections\n   * @constructor\n   */\n  constructor(libp2p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];\n    const opts = Object.assign(Object.assign({\n      gossipIncoming: true,\n      fallbackToFloodsub: true,\n      floodPublish: true,\n      doPX: false,\n      directPeers: [],\n      D: constants.GossipsubD,\n      Dlo: constants.GossipsubDlo,\n      Dhi: constants.GossipsubDhi,\n      Dscore: constants.GossipsubDscore,\n      Dout: constants.GossipsubDout,\n      Dlazy: constants.GossipsubDlazy,\n      heartbeatInterval: constants.GossipsubHeartbeatInterval,\n      fanoutTTL: constants.GossipsubFanoutTTL,\n      mcacheLength: constants.GossipsubHistoryLength,\n      mcacheGossip: constants.GossipsubHistoryGossip,\n      seenTTL: constants.GossipsubSeenTTL\n    }, options), {\n      scoreParams: score_1.createPeerScoreParams(options.scoreParams),\n      scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds)\n    }); // Also wants to get notified of peers connected using floodsub\n\n    if (opts.fallbackToFloodsub) {\n      multicodecs.push(constants.FloodsubID);\n    }\n\n    super(Object.assign({\n      debugName: 'libp2p:gossipsub',\n      multicodecs,\n      libp2p\n    }, opts));\n    this._options = opts;\n    /**\n     * Direct peers\n     * @type {Set<string>}\n     */\n\n    this.direct = new Set(opts.directPeers.map(p => p.id.toB58String())); // set direct peer addresses in the address book\n\n    opts.directPeers.forEach(p => {\n      libp2p.peerStore.addressBook.add(p.id, p.addrs);\n    });\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n\n    this.seenCache = new TimeCache({\n      validity: opts.seenTTL / 1000\n    });\n    /**\n     * Map of topic meshes\n     * topic => peer id set\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this.mesh = new Map();\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     * topic => peer id set\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this.fanout = new Map();\n    /**\n     * Map of last publish time for fanout topics\n     * topic => last publish time\n     *\n     * @type {Map<string, number>}\n     */\n\n    this.lastpub = new Map();\n    /**\n     * Map of pending messages to gossip\n     * peer id => control messages\n     *\n     * @type {Map<string, Array<RPC.IControlIHave object>> }\n     */\n\n    this.gossip = new Map();\n    /**\n     * Map of control messages\n     * peer id => control message\n     *\n     * @type {Map<string, RPC.IControlMessage object>}\n     */\n\n    this.control = new Map();\n    /**\n     * Number of IHAVEs received from peer in the last heartbeat\n     * @type {Map<string, number>}\n     */\n\n    this.peerhave = new Map();\n    /**\n     * Number of messages we have asked from peer in the last heartbeat\n     * @type {Map<string, number>}\n     */\n\n    this.iasked = new Map();\n    /**\n     * Prune backoff map\n     */\n\n    this.backoff = new Map();\n    /**\n     * Connection direction cache, marks peers with outbound connections\n     * peer id => direction\n     *\n     * @type {Map<string, boolean>}\n     */\n\n    this.outbound = new Map();\n    /**\n     * A message cache that contains the messages for last few hearbeat ticks\n     *\n     */\n\n    this.messageCache = options.messageCache || new message_cache_1.MessageCache(opts.mcacheGossip, opts.mcacheLength, this.getMsgId.bind(this));\n    /**\n     * A heartbeat timer that maintains the mesh\n     */\n\n    this.heartbeat = new heartbeat_1.Heartbeat(this);\n    /**\n     * Number of heartbeats since the beginning of time\n     * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n     */\n\n    this.heartbeatTicks = 0;\n    /**\n     * Tracks IHAVE/IWANT promises broken by peers\n     */\n\n    this.gossipTracer = new tracer_1.IWantTracer(this.getMsgId.bind(this));\n    /**\n     * libp2p\n     */\n\n    this._libp2p = libp2p;\n    /**\n     * Peer score tracking\n     */\n\n    this.score = new score_1.PeerScore(this._options.scoreParams, libp2p.connectionManager, this.getMsgId.bind(this));\n  }\n  /**\n   * Decode a Uint8Array into an RPC object\n   * Overrided to use an extended protocol-specific protobuf decoder\n   * @override\n   * @param {Uint8Array} bytes\n   * @returns {RPC}\n   */\n\n\n  _decodeRpc(bytes) {\n    return rpc_1.RPC.decode(bytes);\n  }\n  /**\n   * Encode an RPC object into a Uint8Array\n   * Overrided to use an extended protocol-specific protobuf encoder\n   * @override\n   * @param {RPC} rpc\n   * @returns {Uint8Array}\n   */\n\n\n  _encodeRpc(rpc) {\n    return rpc_1.RPC.encode(rpc).finish();\n  }\n  /**\n   * Add a peer to the router\n   * @override\n   * @param {PeerId} peerId\n   * @param {string} protocol\n   * @returns {PeerStreams}\n   */\n\n\n  _addPeer(peerId, protocol) {\n    const p = super._addPeer(peerId, protocol); // Add to peer scoring\n\n\n    this.score.addPeer(peerId.toB58String()); // track the connection direction\n\n    let outbound = false;\n\n    for (const c of this._libp2p.connectionManager.getAll(peerId)) {\n      if (c.stat.direction === 'outbound') {\n        if (Array.from(c.registry.values()).some(rvalue => protocol === rvalue.protocol)) {\n          outbound = true;\n          break;\n        }\n      }\n    }\n\n    this.outbound.set(p.id.toB58String(), outbound);\n    return p;\n  }\n  /**\n   * Removes a peer from the router\n   * @override\n   * @param {PeerId} peer\n   * @returns {PeerStreams | undefined}\n   */\n\n\n  _removePeer(peerId) {\n    const peerStreams = super._removePeer(peerId);\n\n    const id = peerId.toB58String(); // Remove this peer from the mesh\n    // eslint-disable-next-line no-unused-vars\n\n    for (const peers of this.mesh.values()) {\n      peers.delete(id);\n    } // Remove this peer from the fanout\n    // eslint-disable-next-line no-unused-vars\n\n\n    for (const peers of this.fanout.values()) {\n      peers.delete(id);\n    } // Remove from gossip mapping\n\n\n    this.gossip.delete(id); // Remove from control mapping\n\n    this.control.delete(id); // Remove from backoff mapping\n\n    this.outbound.delete(id); // Remove from peer scoring\n\n    this.score.removePeer(id);\n    return peerStreams;\n  }\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @override\n   * @param {String} idB58Str\n   * @param {PeerStreams} peerStreams\n   * @param {RPC} rpc\n   * @returns {Promise<boolean>}\n   */\n\n\n  _processRpc(id, peerStreams, rpc) {\n    const _super = Object.create(null, {\n      _processRpc: {\n        get: () => super._processRpc\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (yield _super._processRpc.call(this, id, peerStreams, rpc)) {\n        if (rpc.control) {\n          this._processRpcControlMessage(id, rpc.control);\n        }\n\n        return true;\n      }\n\n      return false;\n    });\n  }\n  /**\n   * Handles an rpc control message from a peer\n   * @param {string} id peer id\n   * @param {RPC.IControlMessage} controlMsg\n   * @returns {void}\n   */\n\n\n  _processRpcControlMessage(id, controlMsg) {\n    if (!controlMsg) {\n      return;\n    }\n\n    const iwant = controlMsg.ihave ? this._handleIHave(id, controlMsg.ihave) : [];\n    const ihave = controlMsg.iwant ? this._handleIWant(id, controlMsg.iwant) : [];\n    const prune = controlMsg.graft ? this._handleGraft(id, controlMsg.graft) : [];\n    controlMsg.prune && this._handlePrune(id, controlMsg.prune);\n\n    if (!iwant.length && !ihave.length && !prune.length) {\n      return;\n    }\n\n    const outRpc = utils_1.createGossipRpc(ihave, {\n      iwant,\n      prune\n    });\n\n    this._sendRpc(id, outRpc);\n  }\n  /**\n   * Process incoming message,\n   * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n   * @override\n   * @param {InMessage} msg\n   * @returns {Promise<void>}\n   */\n\n\n  _processRpcMessage(msg) {\n    const _super = Object.create(null, {\n      _processRpcMessage: {\n        get: () => super._processRpcMessage\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const msgID = yield this.getMsgId(msg);\n      const msgIdStr = utils_1.messageIdToString(msgID); // Ignore if we've already seen the message\n\n      if (this.seenCache.has(msgIdStr)) {\n        this.score.duplicateMessage(msg);\n        return;\n      }\n\n      this.seenCache.put(msgIdStr);\n      yield this.score.validateMessage(msg);\n      yield _super._processRpcMessage.call(this, msg);\n    });\n  }\n  /**\n   * Whether to accept a message from a peer\n   * @override\n   * @param {string} id\n   * @returns {boolean}\n   */\n\n\n  _acceptFrom(id) {\n    return this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.graylistThreshold;\n  }\n  /**\n   * Validate incoming message\n   * @override\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n\n\n  validate(message) {\n    const _super = Object.create(null, {\n      validate: {\n        get: () => super.validate\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield _super.validate.call(this, message);\n      } catch (e) {\n        this.score.rejectMessage(message, e.code);\n        this.gossipTracer.rejectMessage(message, e.code);\n        throw e;\n      }\n    });\n  }\n  /**\n   * Handles IHAVE messages\n   * @param {string} id peer id\n   * @param {Array<RPC.IControlIHave>} ihave\n   * @returns {RPC.IControlIWant}\n   */\n\n\n  _handleIHave(id, ihave) {\n    if (!ihave.length) {\n      return [];\n    } // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n\n\n    const score = this.score.score(id);\n\n    if (score < this._options.scoreThresholds.gossipThreshold) {\n      this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score);\n      return [];\n    } // IHAVE flood protection\n\n\n    const peerhave = (this.peerhave.get(id) || 0) + 1;\n    this.peerhave.set(id, peerhave);\n\n    if (peerhave > constants.GossipsubMaxIHaveMessages) {\n      this.log('IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring', id, peerhave);\n      return [];\n    }\n\n    const iasked = this.iasked.get(id) || 0;\n\n    if (iasked >= constants.GossipsubMaxIHaveLength) {\n      this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked);\n      return [];\n    } // string msgId => msgId\n\n\n    const iwant = new Map();\n    ihave.forEach(_ref => {\n      let {\n        topicID,\n        messageIDs\n      } = _ref;\n\n      if (!topicID || !messageIDs || !this.mesh.has(topicID)) {\n        return;\n      }\n\n      messageIDs.forEach(msgID => {\n        const msgIdStr = utils_1.messageIdToString(msgID);\n\n        if (this.seenCache.has(msgIdStr)) {\n          return;\n        }\n\n        iwant.set(msgIdStr, msgID);\n      });\n    });\n\n    if (!iwant.size) {\n      return [];\n    }\n\n    let iask = iwant.size;\n\n    if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n      iask = constants.GossipsubMaxIHaveLength - iasked;\n    }\n\n    this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id);\n    let iwantList = Array.from(iwant.values()); // ask in random order\n\n    utils_1.shuffle(iwantList); // truncate to the messages we are actually asking for and update the iasked counter\n\n    iwantList = iwantList.slice(0, iask);\n    this.iasked.set(id, iasked + iask);\n    this.gossipTracer.addPromise(id, iwantList);\n    return [{\n      messageIDs: iwantList\n    }];\n  }\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   * @param {string} id peer id\n   * @param {Array<RPC.IControlIWant>} iwant\n   * @returns {Array<RPC.IMessage>}\n   */\n\n\n  _handleIWant(id, iwant) {\n    if (!iwant.length) {\n      return [];\n    } // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n\n\n    const score = this.score.score(id);\n\n    if (score < this._options.scoreThresholds.gossipThreshold) {\n      this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score);\n      return [];\n    } // @type {Map<string, Message>}\n\n\n    const ihave = new Map();\n    iwant.forEach(_ref2 => {\n      let {\n        messageIDs\n      } = _ref2;\n      messageIDs && messageIDs.forEach(msgID => {\n        const [msg, count] = this.messageCache.getForPeer(msgID, id);\n\n        if (!msg) {\n          return;\n        }\n\n        if (count > constants.GossipsubGossipRetransmission) {\n          this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgID);\n          return;\n        }\n\n        ihave.set(utils_1.messageIdToString(msgID), msg);\n      });\n    });\n\n    if (!ihave.size) {\n      return [];\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, id);\n    return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);\n  }\n  /**\n   * Handles Graft messages\n   * @param {string} id peer id\n   * @param {Array<RPC.IControlGraft>} graft\n   * @return {Array<RPC.IControlPrune>}\n   */\n\n\n  _handleGraft(id, graft) {\n    const prune = [];\n    const score = this.score.score(id);\n\n    const now = this._now();\n\n    let doPX = this._options.doPX;\n    graft.forEach(_ref3 => {\n      let {\n        topicID\n      } = _ref3;\n\n      var _a;\n\n      if (!topicID) {\n        return;\n      }\n\n      const peersInMesh = this.mesh.get(topicID);\n\n      if (!peersInMesh) {\n        // don't do PX when there is an unknown topic to avoid leaking our peers\n        doPX = false; // spam hardening: ignore GRAFTs for unknown topics\n\n        return;\n      } // check if peer is already in the mesh; if so do nothing\n\n\n      if (peersInMesh.has(id)) {\n        return;\n      } // we don't GRAFT to/from direct peers; complain loudly if this happens\n\n\n      if (this.direct.has(id)) {\n        this.log('GRAFT: ignoring request from direct peer %s', id); // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n\n        prune.push(topicID); // but don't px\n\n        doPX = false;\n        return;\n      } // make sure we are not backing off that peer\n\n\n      const expire = (_a = this.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);\n\n      if (typeof expire === 'number' && now < expire) {\n        this.log('GRAFT: ignoring backed off peer %s', id); // add behavioral penalty\n\n        this.score.addPenalty(id, 1); // no PX\n\n        doPX = false; // check the flood cutoff -- is the GRAFT coming too fast?\n\n        const floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;\n\n        if (now < floodCutoff) {\n          // extra penalty\n          this.score.addPenalty(id, 1);\n        } // refresh the backoff\n\n\n        this._addBackoff(id, topicID);\n\n        prune.push(topicID);\n        return;\n      } // check the score\n\n\n      if (score < 0) {\n        // we don't GRAFT peers with negative score\n        this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID); // we do send them PRUNE however, because it's a matter of protocol correctness\n\n        prune.push(topicID); // but we won't PX to them\n\n        doPX = false; // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n\n        this._addBackoff(id, topicID);\n\n        return;\n      } // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n      // from peers with outbound connections; this is a defensive check to restrict potential\n      // mesh takeover attacks combined with love bombing\n\n\n      if (peersInMesh.size >= this._options.Dhi && !this.outbound.get(id)) {\n        prune.push(topicID);\n\n        this._addBackoff(id, topicID);\n\n        return;\n      }\n\n      this.log('GRAFT: Add mesh link from %s in %s', id, topicID);\n      this.score.graft(id, topicID);\n      peersInMesh.add(id);\n    });\n\n    if (!prune.length) {\n      return [];\n    }\n\n    return prune.map(topic => this._makePrune(id, topic, doPX));\n  }\n  /**\n   * Handles Prune messages\n   * @param {string} id peer id\n   * @param {Array<RPC.IControlPrune>} prune\n   * @returns {void}\n   */\n\n\n  _handlePrune(id, prune) {\n    const score = this.score.score(id);\n    prune.forEach(_ref4 => {\n      let {\n        topicID,\n        backoff,\n        peers\n      } = _ref4;\n\n      if (!topicID) {\n        return;\n      }\n\n      const peersInMesh = this.mesh.get(topicID);\n\n      if (!peersInMesh) {\n        return;\n      }\n\n      this.log('PRUNE: Remove mesh link to %s in %s', id, topicID);\n      this.score.prune(id, topicID);\n      peersInMesh.delete(id); // is there a backoff specified by the peer? if so obey it\n\n      if (typeof backoff === 'number' && backoff > 0) {\n        this._doAddBackoff(id, topicID, backoff * 1000);\n      } else {\n        this._addBackoff(id, topicID);\n      } // PX\n\n\n      if (peers && peers.length) {\n        // we ignore PX from peers with insufficient scores\n        if (score < this._options.scoreThresholds.acceptPXThreshold) {\n          this.log('PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]', id, score, topicID);\n          return;\n        }\n\n        this._pxConnect(peers);\n      }\n    });\n  }\n  /**\n   * Add standard backoff log for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _addBackoff(id, topic) {\n    this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);\n  }\n  /**\n   * Add backoff expiry interval for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @param {number} interval backoff duration in milliseconds\n   * @returns {void}\n   */\n\n\n  _doAddBackoff(id, topic, interval) {\n    let backoff = this.backoff.get(topic);\n\n    if (!backoff) {\n      backoff = new Map();\n      this.backoff.set(topic, backoff);\n    }\n\n    const expire = this._now() + interval;\n    const existingExpire = backoff.get(id) || 0;\n\n    if (existingExpire < expire) {\n      backoff.set(id, expire);\n    }\n  }\n  /**\n   * Apply penalties from broken IHAVE/IWANT promises\n   * @returns {void}\n   */\n\n\n  _applyIwantPenalties() {\n    this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n      this.log('peer %s didn\\'t follow up in %d IWANT requests; adding penalty', p, count);\n      this.score.addPenalty(p, count);\n    });\n  }\n  /**\n   * Clear expired backoff expiries\n   * @returns {void}\n   */\n\n\n  _clearBackoff() {\n    // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n    if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n      return;\n    }\n\n    const now = this._now();\n\n    this.backoff.forEach((backoff, topic) => {\n      backoff.forEach((expire, id) => {\n        if (expire < now) {\n          backoff.delete(id);\n        }\n      });\n\n      if (backoff.size === 0) {\n        this.backoff.delete(topic);\n      }\n    });\n  }\n  /**\n   * Maybe reconnect to direct peers\n   * @returns {void}\n   */\n\n\n  _directConnect() {\n    // we only do this every few ticks to allow pending connections to complete and account for\n    // restarts/downtime\n    if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {\n      return;\n    }\n\n    const toconnect = [];\n    this.direct.forEach(id => {\n      const peer = this.peers.get(id);\n\n      if (!peer || !peer.isWritable) {\n        toconnect.push(id);\n      }\n    });\n\n    if (toconnect.length) {\n      toconnect.forEach(id => {\n        this._connect(id);\n      });\n    }\n  }\n  /**\n   * Maybe attempt connection given signed peer records\n   * @param {RPC.IPeerInfo[]} peers\n   * @returns {Promise<void>}\n   */\n\n\n  _pxConnect(peers) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (peers.length > constants.GossipsubPrunePeers) {\n        utils_1.shuffle(peers);\n        peers = peers.slice(0, constants.GossipsubPrunePeers);\n      }\n\n      const toconnect = [];\n      yield Promise.all(peers.map(pi => __awaiter(this, void 0, void 0, function* () {\n        if (!pi.peerID) {\n          return;\n        }\n\n        const p = PeerId.createFromBytes(pi.peerID);\n        const id = p.toB58String();\n\n        if (this.peers.has(id)) {\n          return;\n        }\n\n        if (!pi.signedPeerRecord) {\n          toconnect.push(id);\n          return;\n        } // The peer sent us a signed record\n        // This is not a record from the peer who sent the record, but another peer who is connected with it\n        // Ensure that it is valid\n\n\n        try {\n          const envelope = yield Envelope.openAndCertify(pi.signedPeerRecord, 'libp2p-peer-record');\n          const eid = envelope.peerId.toB58String();\n\n          if (id !== eid) {\n            this.log('bogus peer record obtained through px: peer ID %s doesn\\'t match expected peer %s', eid, id);\n            return;\n          }\n\n          if (!this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {\n            this.log('bogus peer record obtained through px: could not add peer record to address book');\n            return;\n          }\n\n          toconnect.push(id);\n        } catch (e) {\n          this.log('bogus peer record obtained through px: invalid signature or not a peer record');\n        }\n      })));\n\n      if (!toconnect.length) {\n        return;\n      }\n\n      toconnect.forEach(id => this._connect(id));\n    });\n  }\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   * @override\n   * @returns {void}\n   */\n\n\n  start() {\n    super.start();\n    this.heartbeat.start();\n    this.score.start(); // connect to direct peers\n\n    this._directPeerInitial = setTimeout(() => {\n      this.direct.forEach(id => {\n        this._connect(id);\n      });\n    }, constants.GossipsubDirectConnectInitialDelay);\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   * @override\n   * @returns {void}\n   */\n\n\n  stop() {\n    super.stop();\n    this.heartbeat.stop();\n    this.score.stop();\n    this.mesh = new Map();\n    this.fanout = new Map();\n    this.lastpub = new Map();\n    this.gossip = new Map();\n    this.control = new Map();\n    this.peerhave = new Map();\n    this.iasked = new Map();\n    this.backoff = new Map();\n    this.outbound = new Map();\n    this.gossipTracer.clear();\n    clearTimeout(this._directPeerInitial);\n  }\n  /**\n   * Connect to a peer using the gossipsub protocol\n   * @param {string} id\n   * @returns {void}\n   */\n\n\n  _connect(id) {\n    this.log('Initiating connection with %s', id);\n\n    this._libp2p.dialProtocol(PeerId.createFromB58String(id), this.multicodecs);\n  }\n  /**\n   * Subscribes to a topic\n   * @override\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  subscribe(topic) {\n    super.subscribe(topic);\n    this.join(topic);\n  }\n  /**\n   * Unsubscribe to a topic\n   * @override\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  unsubscribe(topic) {\n    super.unsubscribe(topic);\n    this.leave(topic);\n  }\n  /**\n   * Join topic\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  join(topic) {\n    if (!this.started) {\n      throw new Error('Gossipsub has not started');\n    }\n\n    this.log('JOIN %s', topic);\n    const fanoutPeers = this.fanout.get(topic);\n\n    if (fanoutPeers) {\n      // these peers have a score above the publish threshold, which may be negative\n      // so drop the ones with a negative score\n      fanoutPeers.forEach(id => {\n        if (this.score.score(id) < 0) {\n          fanoutPeers.delete(id);\n        }\n      });\n\n      if (fanoutPeers.size < this._options.D) {\n        // we need more peers; eager, as this would get fixed in the next heartbeat\n        get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, id => {\n          // filter our current peers, direct peers, and peers with negative scores\n          return !fanoutPeers.has(id) && !this.direct.has(id) && this.score.score(id) >= 0;\n        }).forEach(id => fanoutPeers.add(id));\n      }\n\n      this.mesh.set(topic, fanoutPeers);\n      this.fanout.delete(topic);\n      this.lastpub.delete(topic);\n    } else {\n      const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n        // filter direct peers and peers with negative score\n        return !this.direct.has(id) && this.score.score(id) >= 0;\n      });\n      this.mesh.set(topic, peers);\n    }\n\n    this.mesh.get(topic).forEach(id => {\n      this.log('JOIN: Add mesh link to %s in %s', id, topic);\n\n      this._sendGraft(id, topic);\n    });\n  }\n  /**\n   * Leave topic\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  leave(topic) {\n    if (!this.started) {\n      throw new Error('Gossipsub has not started');\n    }\n\n    this.log('LEAVE %s', topic); // Send PRUNE to mesh peers\n\n    const meshPeers = this.mesh.get(topic);\n\n    if (meshPeers) {\n      meshPeers.forEach(id => {\n        this.log('LEAVE: Remove mesh link to %s in %s', id, topic);\n\n        this._sendPrune(id, topic);\n      });\n      this.mesh.delete(topic);\n    }\n  }\n  /**\n   * Publish messages\n   *\n   * @override\n   * @param {InMessage} msg\n   * @returns {void}\n   */\n\n\n  _publish(msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (msg.receivedFrom !== this.peerId.toB58String()) {\n        this.score.deliverMessage(msg);\n        this.gossipTracer.deliverMessage(msg);\n      }\n\n      const msgID = yield this.getMsgId(msg);\n      const msgIdStr = utils_1.messageIdToString(msgID); // put in seen cache\n\n      this.seenCache.put(msgIdStr);\n      this.messageCache.put(msg);\n      const tosend = new Set();\n      msg.topicIDs.forEach(topic => {\n        const peersInTopic = this.topics.get(topic);\n\n        if (!peersInTopic) {\n          return;\n        }\n\n        if (this._options.floodPublish && msg.receivedFrom === this.peerId.toB58String()) {\n          // flood-publish behavior\n          // send to direct peers and _all_ peers meeting the publishThreshold\n          peersInTopic.forEach(id => {\n            if (this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.publishThreshold) {\n              tosend.add(id);\n            }\n          });\n        } else {\n          // non-flood-publish behavior\n          // send to direct peers, subscribed floodsub peers\n          // and some mesh peers above publishThreshold\n          // direct peers\n          this.direct.forEach(id => {\n            tosend.add(id);\n          }); // floodsub peers\n\n          peersInTopic.forEach(id => {\n            const score = this.score.score(id);\n            const peerStreams = this.peers.get(id);\n\n            if (!peerStreams) {\n              return;\n            }\n\n            if (peerStreams.protocol === constants.FloodsubID && score >= this._options.scoreThresholds.publishThreshold) {\n              tosend.add(id);\n            }\n          }); // Gossipsub peers handling\n\n          let meshPeers = this.mesh.get(topic);\n\n          if (!meshPeers || !meshPeers.size) {\n            // We are not in the mesh for topic, use fanout peers\n            meshPeers = this.fanout.get(topic);\n\n            if (!meshPeers) {\n              // If we are not in the fanout, then pick peers in topic above the publishThreshold\n              const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n                return this.score.score(id) >= this._options.scoreThresholds.publishThreshold;\n              });\n\n              if (peers.size > 0) {\n                meshPeers = peers;\n                this.fanout.set(topic, peers);\n              } else {\n                meshPeers = new Set();\n              }\n            } // Store the latest publishing time\n\n\n            this.lastpub.set(topic, this._now());\n          }\n\n          meshPeers.forEach(peer => {\n            tosend.add(peer);\n          });\n        }\n      }); // Publish messages to peers\n\n      const rpc = utils_1.createGossipRpc([pubsub_1.utils.normalizeOutRpcMessage(msg)]);\n      tosend.forEach(id => {\n        if (id === msg.receivedFrom || id === msg.from) {\n          return;\n        }\n\n        this._sendRpc(id, rpc);\n      });\n    });\n  }\n  /**\n   * Sends a GRAFT message to a peer\n   * @param {string} id peer id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _sendGraft(id, topic) {\n    const graft = [{\n      topicID: topic\n    }];\n    const out = utils_1.createGossipRpc([], {\n      graft\n    });\n\n    this._sendRpc(id, out);\n  }\n  /**\n   * Sends a PRUNE message to a peer\n   * @param {string} id peer id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _sendPrune(id, topic) {\n    const prune = [this._makePrune(id, topic, this._options.doPX)];\n    const out = utils_1.createGossipRpc([], {\n      prune\n    });\n\n    this._sendRpc(id, out);\n  }\n  /**\n   * @override\n   */\n\n\n  _sendRpc(id, outRpc) {\n    const peerStreams = this.peers.get(id);\n\n    if (!peerStreams || !peerStreams.isWritable) {\n      return;\n    } // piggyback control message retries\n\n\n    const ctrl = this.control.get(id);\n\n    if (ctrl) {\n      this._piggybackControl(id, outRpc, ctrl);\n\n      this.control.delete(id);\n    } // piggyback gossip\n\n\n    const ihave = this.gossip.get(id);\n\n    if (ihave) {\n      this._piggybackGossip(id, outRpc, ihave);\n\n      this.gossip.delete(id);\n    }\n\n    peerStreams.write(rpc_1.RPC.encode(outRpc).finish());\n  }\n\n  _piggybackControl(id, outRpc, ctrl) {\n    const tograft = (ctrl.graft || []).filter(_ref5 => {\n      let {\n        topicID\n      } = _ref5;\n      return (topicID && this.mesh.get(topicID) || new Set()).has(id);\n    });\n    const toprune = (ctrl.prune || []).filter(_ref6 => {\n      let {\n        topicID\n      } = _ref6;\n      return !(topicID && this.mesh.get(topicID) || new Set()).has(id);\n    });\n\n    if (!tograft.length && !toprune.length) {\n      return;\n    }\n\n    if (outRpc.control) {\n      outRpc.control.graft = outRpc.control.graft && outRpc.control.graft.concat(tograft);\n      outRpc.control.prune = outRpc.control.prune && outRpc.control.prune.concat(toprune);\n    } else {\n      outRpc.control = {\n        ihave: [],\n        iwant: [],\n        graft: tograft,\n        prune: toprune\n      };\n    }\n  }\n\n  _piggybackGossip(id, outRpc, ihave) {\n    if (!outRpc.control) {\n      outRpc.control = {\n        ihave: [],\n        iwant: [],\n        graft: [],\n        prune: []\n      };\n    }\n\n    outRpc.control.ihave = ihave;\n  }\n  /**\n   * Send graft and prune messages\n   * @param {Map<string, Array<string>>} tograft peer id => topic[]\n   * @param {Map<string, Array<string>>} toprune peer id => topic[]\n   */\n\n\n  _sendGraftPrune(tograft, toprune, noPX) {\n    const doPX = this._options.doPX;\n\n    for (const [id, topics] of tograft) {\n      const graft = topics.map(topicID => ({\n        topicID\n      }));\n      let prune = []; // If a peer also has prunes, process them now\n\n      const pruning = toprune.get(id);\n\n      if (pruning) {\n        prune = pruning.map(topicID => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n        toprune.delete(id);\n      }\n\n      const outRpc = utils_1.createGossipRpc([], {\n        graft,\n        prune\n      });\n\n      this._sendRpc(id, outRpc);\n    }\n\n    for (const [id, topics] of toprune) {\n      const prune = topics.map(topicID => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n      const outRpc = utils_1.createGossipRpc([], {\n        prune\n      });\n\n      this._sendRpc(id, outRpc);\n    }\n  }\n  /**\n   * Emits gossip to peers in a particular topic\n   * @param {string} topic\n   * @param {Set<string>} exclude peers to exclude\n   * @returns {void}\n   */\n\n\n  _emitGossip(topic, exclude) {\n    const messageIDs = this.messageCache.getGossipIDs(topic);\n\n    if (!messageIDs.length) {\n      return;\n    } // shuffle to emit in random order\n\n\n    utils_1.shuffle(messageIDs); // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n\n    if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n      // we do the truncation (with shuffling) per peer below\n      this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n    } // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy\n    // First we collect the peers above gossipThreshold that are not in the exclude set\n    // and then randomly select from that set\n    // We also exclude direct peers, as there is no reason to emit gossip to them\n\n\n    const peersToGossip = [];\n    const topicPeers = this.topics.get(topic);\n\n    if (!topicPeers) {\n      // no topic peers, no gossip\n      return;\n    }\n\n    topicPeers.forEach(id => {\n      const peerStreams = this.peers.get(id);\n\n      if (!peerStreams) {\n        return;\n      }\n\n      if (!exclude.has(id) && !this.direct.has(id) && utils_1.hasGossipProtocol(peerStreams.protocol) && this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {\n        peersToGossip.push(id);\n      }\n    });\n    let target = this._options.Dlazy;\n    const factor = constants.GossipsubGossipFactor * peersToGossip.length;\n\n    if (factor > target) {\n      target = factor;\n    }\n\n    if (target > peersToGossip.length) {\n      target = peersToGossip.length;\n    } else {\n      utils_1.shuffle(peersToGossip);\n    } // Emit the IHAVE gossip to the selected peers up to the target\n\n\n    peersToGossip.slice(0, target).forEach(id => {\n      let peerMessageIDs = messageIDs;\n\n      if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n        // shuffle and slice message IDs per peer so that we emit a different set for each peer\n        // we have enough reduncancy in the system that this will significantly increase the message\n        // coverage when we do truncate\n        peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);\n      }\n\n      this._pushGossip(id, {\n        topicID: topic,\n        messageIDs: peerMessageIDs\n      });\n    });\n  }\n  /**\n   * Flush gossip and control messages\n   */\n\n\n  _flush() {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer);\n      const out = utils_1.createGossipRpc([], {\n        ihave\n      });\n\n      this._sendRpc(peer, out);\n    } // send the remaining control messages\n\n\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer);\n      const out = utils_1.createGossipRpc([], {\n        graft: control.graft,\n        prune: control.prune\n      });\n\n      this._sendRpc(peer, out);\n    }\n  }\n  /**\n   * Adds new IHAVE messages to pending gossip\n   * @param {PeerStreams} peerStreams\n   * @param {Array<RPC.IControlIHave>} controlIHaveMsgs\n   * @returns {void}\n   */\n\n\n  _pushGossip(id, controlIHaveMsgs) {\n    this.log('Add gossip to %s', id);\n    const gossip = this.gossip.get(id) || [];\n    this.gossip.set(id, gossip.concat(controlIHaveMsgs));\n  }\n  /**\n   * Returns the current time in milliseconds\n   * @returns {number}\n   */\n\n\n  _now() {\n    return Date.now();\n  }\n  /**\n   * Make a PRUNE control message for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @param {boolean} doPX\n   * @returns {RPC.IControlPrune}\n   */\n\n\n  _makePrune(id, topic, doPX) {\n    if (this.peers.get(id).protocol === constants.GossipsubIDv10) {\n      // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n      return {\n        topicID: topic,\n        peers: []\n      };\n    } // backoff is measured in seconds\n    // GossipsubPruneBackoff is measured in milliseconds\n\n\n    const backoff = constants.GossipsubPruneBackoff / 1000;\n    const px = [];\n\n    if (doPX) {\n      // select peers for Peer eXchange\n      const peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, xid => {\n        return xid !== id && this.score.score(xid) >= 0;\n      });\n      peers.forEach(p => {\n        // see if we have a signed record to send back; if we don't, just send\n        // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n        // unsigned address records through PX anyways\n        // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n        const peerId = PeerId.createFromB58String(p);\n        px.push({\n          peerID: peerId.toBytes(),\n          signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId)\n        });\n      });\n    }\n\n    return {\n      topicID: topic,\n      peers: px,\n      backoff: backoff\n    };\n  }\n\n}\n\nGossipsub.multicodec = constants.GossipsubIDv11;\nmodule.exports = Gossipsub;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","next","e","rejected","done","then","apply","pubsub_1","require","message_cache_1","rpc_1","constants","heartbeat_1","get_gossip_peers_1","utils_1","score_1","tracer_1","TimeCache","PeerId","Envelope","Gossipsub","default","constructor","libp2p","options","multicodecs","GossipsubIDv11","GossipsubIDv10","opts","assign","gossipIncoming","fallbackToFloodsub","floodPublish","doPX","directPeers","D","GossipsubD","Dlo","GossipsubDlo","Dhi","GossipsubDhi","Dscore","GossipsubDscore","Dout","GossipsubDout","Dlazy","GossipsubDlazy","heartbeatInterval","GossipsubHeartbeatInterval","fanoutTTL","GossipsubFanoutTTL","mcacheLength","GossipsubHistoryLength","mcacheGossip","GossipsubHistoryGossip","seenTTL","GossipsubSeenTTL","scoreParams","createPeerScoreParams","scoreThresholds","createPeerScoreThresholds","push","FloodsubID","debugName","_options","direct","Set","map","p","id","toB58String","forEach","peerStore","addressBook","add","addrs","seenCache","validity","mesh","Map","fanout","lastpub","gossip","control","peerhave","iasked","backoff","outbound","messageCache","MessageCache","getMsgId","bind","heartbeat","Heartbeat","heartbeatTicks","gossipTracer","IWantTracer","_libp2p","score","PeerScore","connectionManager","_decodeRpc","bytes","RPC","decode","_encodeRpc","rpc","encode","finish","_addPeer","peerId","protocol","addPeer","c","getAll","stat","direction","Array","from","registry","values","some","rvalue","set","_removePeer","peerStreams","peers","delete","removePeer","_processRpc","_super","_processRpcControlMessage","controlMsg","iwant","ihave","_handleIHave","_handleIWant","prune","graft","_handleGraft","_handlePrune","length","outRpc","createGossipRpc","_sendRpc","_processRpcMessage","msg","msgID","msgIdStr","messageIdToString","has","duplicateMessage","put","validateMessage","_acceptFrom","graylistThreshold","validate","message","rejectMessage","code","gossipThreshold","log","GossipsubMaxIHaveMessages","GossipsubMaxIHaveLength","topicID","messageIDs","size","iask","iwantList","shuffle","slice","addPromise","count","getForPeer","GossipsubGossipRetransmission","utils","normalizeOutRpcMessage","now","_now","_a","peersInMesh","expire","addPenalty","floodCutoff","GossipsubGraftFloodThreshold","GossipsubPruneBackoff","_addBackoff","topic","_makePrune","_doAddBackoff","acceptPXThreshold","_pxConnect","interval","existingExpire","_applyIwantPenalties","getBrokenPromises","_clearBackoff","GossipsubPruneBackoffTicks","_directConnect","GossipsubDirectConnectTicks","toconnect","peer","isWritable","_connect","GossipsubPrunePeers","all","pi","peerID","createFromBytes","signedPeerRecord","envelope","openAndCertify","eid","consumePeerRecord","start","_directPeerInitial","setTimeout","GossipsubDirectConnectInitialDelay","stop","clear","clearTimeout","dialProtocol","createFromB58String","subscribe","join","unsubscribe","leave","started","Error","fanoutPeers","getGossipPeers","_sendGraft","meshPeers","_sendPrune","_publish","receivedFrom","deliverMessage","tosend","topicIDs","peersInTopic","topics","publishThreshold","out","ctrl","_piggybackControl","_piggybackGossip","write","tograft","filter","toprune","concat","_sendGraftPrune","noPX","pruning","_emitGossip","exclude","getGossipIDs","peersToGossip","topicPeers","hasGossipProtocol","target","factor","GossipsubGossipFactor","peerMessageIDs","_pushGossip","_flush","entries","controlIHaveMsgs","Date","px","xid","toBytes","getRawEnvelope","multicodec","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-gossipsub/src/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst pubsub_1 = __importStar(require(\"libp2p-interfaces/src/pubsub\"));\nconst message_cache_1 = require(\"./message-cache\");\nconst rpc_1 = require(\"./message/rpc\");\nconst constants = __importStar(require(\"./constants\"));\nconst heartbeat_1 = require(\"./heartbeat\");\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\nconst utils_1 = require(\"./utils\");\nconst score_1 = require(\"./score\");\nconst tracer_1 = require(\"./tracer\");\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst TimeCache = require(\"time-cache\");\nconst PeerId = require(\"peer-id\");\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst Envelope = require(\"libp2p/src/record/envelope\");\nclass Gossipsub extends pubsub_1.default {\n    // TODO: add remaining props\n    /**\n     * @param {Libp2p} libp2p\n     * @param {Object} [options]\n     * @param {boolean} [options.emitSelf = false] if publish should emit to self, if subscribed\n     * @param {boolean} [options.canRelayMessage = false] - if can relay messages not subscribed\n     * @param {boolean} [options.gossipIncoming = true] if incoming messages on a subscribed topic should be automatically gossiped\n     * @param {boolean} [options.fallbackToFloodsub = true] if dial should fallback to floodsub\n     * @param {boolean} [options.floodPublish = true] if self-published messages should be sent to all peers\n     * @param {boolean} [options.doPX = false] whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes.\n     * @param {Object} [options.messageCache] override the default MessageCache\n     * @param {string} [options.globalSignaturePolicy = \"StrictSign\"] signing policy to apply across all messages\n     * @param {Object} [options.scoreParams] peer score parameters\n     * @param {Object} [options.scoreThresholds] peer score thresholds\n     * @param {AddrInfo[]} [options.directPeers] peers with which we will maintain direct connections\n     * @constructor\n     */\n    constructor(libp2p, options = {}) {\n        const multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];\n        const opts = Object.assign(Object.assign({ gossipIncoming: true, fallbackToFloodsub: true, floodPublish: true, doPX: false, directPeers: [], D: constants.GossipsubD, Dlo: constants.GossipsubDlo, Dhi: constants.GossipsubDhi, Dscore: constants.GossipsubDscore, Dout: constants.GossipsubDout, Dlazy: constants.GossipsubDlazy, heartbeatInterval: constants.GossipsubHeartbeatInterval, fanoutTTL: constants.GossipsubFanoutTTL, mcacheLength: constants.GossipsubHistoryLength, mcacheGossip: constants.GossipsubHistoryGossip, seenTTL: constants.GossipsubSeenTTL }, options), { scoreParams: score_1.createPeerScoreParams(options.scoreParams), scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds) });\n        // Also wants to get notified of peers connected using floodsub\n        if (opts.fallbackToFloodsub) {\n            multicodecs.push(constants.FloodsubID);\n        }\n        super(Object.assign({ debugName: 'libp2p:gossipsub', multicodecs,\n            libp2p }, opts));\n        this._options = opts;\n        /**\n         * Direct peers\n         * @type {Set<string>}\n         */\n        this.direct = new Set(opts.directPeers.map(p => p.id.toB58String()));\n        // set direct peer addresses in the address book\n        opts.directPeers.forEach(p => {\n            libp2p.peerStore.addressBook.add(p.id, p.addrs);\n        });\n        /**\n         * Cache of seen messages\n         *\n         * @type {TimeCache}\n         */\n        this.seenCache = new TimeCache({ validity: opts.seenTTL / 1000 });\n        /**\n         * Map of topic meshes\n         * topic => peer id set\n         *\n         * @type {Map<string, Set<string>>}\n         */\n        this.mesh = new Map();\n        /**\n         * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n         * topic => peer id set\n         *\n         * @type {Map<string, Set<string>>}\n         */\n        this.fanout = new Map();\n        /**\n         * Map of last publish time for fanout topics\n         * topic => last publish time\n         *\n         * @type {Map<string, number>}\n         */\n        this.lastpub = new Map();\n        /**\n         * Map of pending messages to gossip\n         * peer id => control messages\n         *\n         * @type {Map<string, Array<RPC.IControlIHave object>> }\n         */\n        this.gossip = new Map();\n        /**\n         * Map of control messages\n         * peer id => control message\n         *\n         * @type {Map<string, RPC.IControlMessage object>}\n         */\n        this.control = new Map();\n        /**\n         * Number of IHAVEs received from peer in the last heartbeat\n         * @type {Map<string, number>}\n         */\n        this.peerhave = new Map();\n        /**\n         * Number of messages we have asked from peer in the last heartbeat\n         * @type {Map<string, number>}\n         */\n        this.iasked = new Map();\n        /**\n         * Prune backoff map\n         */\n        this.backoff = new Map();\n        /**\n         * Connection direction cache, marks peers with outbound connections\n         * peer id => direction\n         *\n         * @type {Map<string, boolean>}\n         */\n        this.outbound = new Map();\n        /**\n         * A message cache that contains the messages for last few hearbeat ticks\n         *\n         */\n        this.messageCache = options.messageCache || new message_cache_1.MessageCache(opts.mcacheGossip, opts.mcacheLength, this.getMsgId.bind(this));\n        /**\n         * A heartbeat timer that maintains the mesh\n         */\n        this.heartbeat = new heartbeat_1.Heartbeat(this);\n        /**\n         * Number of heartbeats since the beginning of time\n         * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n         */\n        this.heartbeatTicks = 0;\n        /**\n         * Tracks IHAVE/IWANT promises broken by peers\n         */\n        this.gossipTracer = new tracer_1.IWantTracer(this.getMsgId.bind(this));\n        /**\n         * libp2p\n         */\n        this._libp2p = libp2p;\n        /**\n         * Peer score tracking\n         */\n        this.score = new score_1.PeerScore(this._options.scoreParams, libp2p.connectionManager, this.getMsgId.bind(this));\n    }\n    /**\n     * Decode a Uint8Array into an RPC object\n     * Overrided to use an extended protocol-specific protobuf decoder\n     * @override\n     * @param {Uint8Array} bytes\n     * @returns {RPC}\n     */\n    _decodeRpc(bytes) {\n        return rpc_1.RPC.decode(bytes);\n    }\n    /**\n     * Encode an RPC object into a Uint8Array\n     * Overrided to use an extended protocol-specific protobuf encoder\n     * @override\n     * @param {RPC} rpc\n     * @returns {Uint8Array}\n     */\n    _encodeRpc(rpc) {\n        return rpc_1.RPC.encode(rpc).finish();\n    }\n    /**\n     * Add a peer to the router\n     * @override\n     * @param {PeerId} peerId\n     * @param {string} protocol\n     * @returns {PeerStreams}\n     */\n    _addPeer(peerId, protocol) {\n        const p = super._addPeer(peerId, protocol);\n        // Add to peer scoring\n        this.score.addPeer(peerId.toB58String());\n        // track the connection direction\n        let outbound = false;\n        for (const c of this._libp2p.connectionManager.getAll(peerId)) {\n            if (c.stat.direction === 'outbound') {\n                if (Array.from(c.registry.values()).some(rvalue => protocol === rvalue.protocol)) {\n                    outbound = true;\n                    break;\n                }\n            }\n        }\n        this.outbound.set(p.id.toB58String(), outbound);\n        return p;\n    }\n    /**\n     * Removes a peer from the router\n     * @override\n     * @param {PeerId} peer\n     * @returns {PeerStreams | undefined}\n     */\n    _removePeer(peerId) {\n        const peerStreams = super._removePeer(peerId);\n        const id = peerId.toB58String();\n        // Remove this peer from the mesh\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.mesh.values()) {\n            peers.delete(id);\n        }\n        // Remove this peer from the fanout\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.fanout.values()) {\n            peers.delete(id);\n        }\n        // Remove from gossip mapping\n        this.gossip.delete(id);\n        // Remove from control mapping\n        this.control.delete(id);\n        // Remove from backoff mapping\n        this.outbound.delete(id);\n        // Remove from peer scoring\n        this.score.removePeer(id);\n        return peerStreams;\n    }\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @override\n     * @param {String} idB58Str\n     * @param {PeerStreams} peerStreams\n     * @param {RPC} rpc\n     * @returns {Promise<boolean>}\n     */\n    _processRpc(id, peerStreams, rpc) {\n        const _super = Object.create(null, {\n            _processRpc: { get: () => super._processRpc }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (yield _super._processRpc.call(this, id, peerStreams, rpc)) {\n                if (rpc.control) {\n                    this._processRpcControlMessage(id, rpc.control);\n                }\n                return true;\n            }\n            return false;\n        });\n    }\n    /**\n     * Handles an rpc control message from a peer\n     * @param {string} id peer id\n     * @param {RPC.IControlMessage} controlMsg\n     * @returns {void}\n     */\n    _processRpcControlMessage(id, controlMsg) {\n        if (!controlMsg) {\n            return;\n        }\n        const iwant = controlMsg.ihave ? this._handleIHave(id, controlMsg.ihave) : [];\n        const ihave = controlMsg.iwant ? this._handleIWant(id, controlMsg.iwant) : [];\n        const prune = controlMsg.graft ? this._handleGraft(id, controlMsg.graft) : [];\n        controlMsg.prune && this._handlePrune(id, controlMsg.prune);\n        if (!iwant.length && !ihave.length && !prune.length) {\n            return;\n        }\n        const outRpc = utils_1.createGossipRpc(ihave, { iwant, prune });\n        this._sendRpc(id, outRpc);\n    }\n    /**\n     * Process incoming message,\n     * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n     * @override\n     * @param {InMessage} msg\n     * @returns {Promise<void>}\n     */\n    _processRpcMessage(msg) {\n        const _super = Object.create(null, {\n            _processRpcMessage: { get: () => super._processRpcMessage }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const msgID = yield this.getMsgId(msg);\n            const msgIdStr = utils_1.messageIdToString(msgID);\n            // Ignore if we've already seen the message\n            if (this.seenCache.has(msgIdStr)) {\n                this.score.duplicateMessage(msg);\n                return;\n            }\n            this.seenCache.put(msgIdStr);\n            yield this.score.validateMessage(msg);\n            yield _super._processRpcMessage.call(this, msg);\n        });\n    }\n    /**\n     * Whether to accept a message from a peer\n     * @override\n     * @param {string} id\n     * @returns {boolean}\n     */\n    _acceptFrom(id) {\n        return this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.graylistThreshold;\n    }\n    /**\n     * Validate incoming message\n     * @override\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n    validate(message) {\n        const _super = Object.create(null, {\n            validate: { get: () => super.validate }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield _super.validate.call(this, message);\n            }\n            catch (e) {\n                this.score.rejectMessage(message, e.code);\n                this.gossipTracer.rejectMessage(message, e.code);\n                throw e;\n            }\n        });\n    }\n    /**\n     * Handles IHAVE messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlIHave>} ihave\n     * @returns {RPC.IControlIWant}\n     */\n    _handleIHave(id, ihave) {\n        if (!ihave.length) {\n            return [];\n        }\n        // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n        const score = this.score.score(id);\n        if (score < this._options.scoreThresholds.gossipThreshold) {\n            this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score);\n            return [];\n        }\n        // IHAVE flood protection\n        const peerhave = (this.peerhave.get(id) || 0) + 1;\n        this.peerhave.set(id, peerhave);\n        if (peerhave > constants.GossipsubMaxIHaveMessages) {\n            this.log('IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring', id, peerhave);\n            return [];\n        }\n        const iasked = this.iasked.get(id) || 0;\n        if (iasked >= constants.GossipsubMaxIHaveLength) {\n            this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked);\n            return [];\n        }\n        // string msgId => msgId\n        const iwant = new Map();\n        ihave.forEach(({ topicID, messageIDs }) => {\n            if (!topicID || !messageIDs || !this.mesh.has(topicID)) {\n                return;\n            }\n            messageIDs.forEach((msgID) => {\n                const msgIdStr = utils_1.messageIdToString(msgID);\n                if (this.seenCache.has(msgIdStr)) {\n                    return;\n                }\n                iwant.set(msgIdStr, msgID);\n            });\n        });\n        if (!iwant.size) {\n            return [];\n        }\n        let iask = iwant.size;\n        if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n            iask = constants.GossipsubMaxIHaveLength - iasked;\n        }\n        this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id);\n        let iwantList = Array.from(iwant.values());\n        // ask in random order\n        utils_1.shuffle(iwantList);\n        // truncate to the messages we are actually asking for and update the iasked counter\n        iwantList = iwantList.slice(0, iask);\n        this.iasked.set(id, iasked + iask);\n        this.gossipTracer.addPromise(id, iwantList);\n        return [{\n                messageIDs: iwantList\n            }];\n    }\n    /**\n     * Handles IWANT messages\n     * Returns messages to send back to peer\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlIWant>} iwant\n     * @returns {Array<RPC.IMessage>}\n     */\n    _handleIWant(id, iwant) {\n        if (!iwant.length) {\n            return [];\n        }\n        // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n        const score = this.score.score(id);\n        if (score < this._options.scoreThresholds.gossipThreshold) {\n            this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score);\n            return [];\n        }\n        // @type {Map<string, Message>}\n        const ihave = new Map();\n        iwant.forEach(({ messageIDs }) => {\n            messageIDs && messageIDs.forEach((msgID) => {\n                const [msg, count] = this.messageCache.getForPeer(msgID, id);\n                if (!msg) {\n                    return;\n                }\n                if (count > constants.GossipsubGossipRetransmission) {\n                    this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgID);\n                    return;\n                }\n                ihave.set(utils_1.messageIdToString(msgID), msg);\n            });\n        });\n        if (!ihave.size) {\n            return [];\n        }\n        this.log('IWANT: Sending %d messages to %s', ihave.size, id);\n        return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);\n    }\n    /**\n     * Handles Graft messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlGraft>} graft\n     * @return {Array<RPC.IControlPrune>}\n     */\n    _handleGraft(id, graft) {\n        const prune = [];\n        const score = this.score.score(id);\n        const now = this._now();\n        let doPX = this._options.doPX;\n        graft.forEach(({ topicID }) => {\n            var _a;\n            if (!topicID) {\n                return;\n            }\n            const peersInMesh = this.mesh.get(topicID);\n            if (!peersInMesh) {\n                // don't do PX when there is an unknown topic to avoid leaking our peers\n                doPX = false;\n                // spam hardening: ignore GRAFTs for unknown topics\n                return;\n            }\n            // check if peer is already in the mesh; if so do nothing\n            if (peersInMesh.has(id)) {\n                return;\n            }\n            // we don't GRAFT to/from direct peers; complain loudly if this happens\n            if (this.direct.has(id)) {\n                this.log('GRAFT: ignoring request from direct peer %s', id);\n                // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n                prune.push(topicID);\n                // but don't px\n                doPX = false;\n                return;\n            }\n            // make sure we are not backing off that peer\n            const expire = (_a = this.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);\n            if (typeof expire === 'number' && now < expire) {\n                this.log('GRAFT: ignoring backed off peer %s', id);\n                // add behavioral penalty\n                this.score.addPenalty(id, 1);\n                // no PX\n                doPX = false;\n                // check the flood cutoff -- is the GRAFT coming too fast?\n                const floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;\n                if (now < floodCutoff) {\n                    // extra penalty\n                    this.score.addPenalty(id, 1);\n                }\n                // refresh the backoff\n                this._addBackoff(id, topicID);\n                prune.push(topicID);\n                return;\n            }\n            // check the score\n            if (score < 0) {\n                // we don't GRAFT peers with negative score\n                this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID);\n                // we do send them PRUNE however, because it's a matter of protocol correctness\n                prune.push(topicID);\n                // but we won't PX to them\n                doPX = false;\n                // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n                this._addBackoff(id, topicID);\n                return;\n            }\n            // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n            // from peers with outbound connections; this is a defensive check to restrict potential\n            // mesh takeover attacks combined with love bombing\n            if (peersInMesh.size >= this._options.Dhi && !this.outbound.get(id)) {\n                prune.push(topicID);\n                this._addBackoff(id, topicID);\n                return;\n            }\n            this.log('GRAFT: Add mesh link from %s in %s', id, topicID);\n            this.score.graft(id, topicID);\n            peersInMesh.add(id);\n        });\n        if (!prune.length) {\n            return [];\n        }\n        return prune.map(topic => this._makePrune(id, topic, doPX));\n    }\n    /**\n     * Handles Prune messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlPrune>} prune\n     * @returns {void}\n     */\n    _handlePrune(id, prune) {\n        const score = this.score.score(id);\n        prune.forEach(({ topicID, backoff, peers }) => {\n            if (!topicID) {\n                return;\n            }\n            const peersInMesh = this.mesh.get(topicID);\n            if (!peersInMesh) {\n                return;\n            }\n            this.log('PRUNE: Remove mesh link to %s in %s', id, topicID);\n            this.score.prune(id, topicID);\n            peersInMesh.delete(id);\n            // is there a backoff specified by the peer? if so obey it\n            if (typeof backoff === 'number' && backoff > 0) {\n                this._doAddBackoff(id, topicID, backoff * 1000);\n            }\n            else {\n                this._addBackoff(id, topicID);\n            }\n            // PX\n            if (peers && peers.length) {\n                // we ignore PX from peers with insufficient scores\n                if (score < this._options.scoreThresholds.acceptPXThreshold) {\n                    this.log('PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]', id, score, topicID);\n                    return;\n                }\n                this._pxConnect(peers);\n            }\n        });\n    }\n    /**\n     * Add standard backoff log for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _addBackoff(id, topic) {\n        this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);\n    }\n    /**\n     * Add backoff expiry interval for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @param {number} interval backoff duration in milliseconds\n     * @returns {void}\n     */\n    _doAddBackoff(id, topic, interval) {\n        let backoff = this.backoff.get(topic);\n        if (!backoff) {\n            backoff = new Map();\n            this.backoff.set(topic, backoff);\n        }\n        const expire = this._now() + interval;\n        const existingExpire = backoff.get(id) || 0;\n        if (existingExpire < expire) {\n            backoff.set(id, expire);\n        }\n    }\n    /**\n     * Apply penalties from broken IHAVE/IWANT promises\n     * @returns {void}\n     */\n    _applyIwantPenalties() {\n        this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n            this.log('peer %s didn\\'t follow up in %d IWANT requests; adding penalty', p, count);\n            this.score.addPenalty(p, count);\n        });\n    }\n    /**\n     * Clear expired backoff expiries\n     * @returns {void}\n     */\n    _clearBackoff() {\n        // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n        if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n            return;\n        }\n        const now = this._now();\n        this.backoff.forEach((backoff, topic) => {\n            backoff.forEach((expire, id) => {\n                if (expire < now) {\n                    backoff.delete(id);\n                }\n            });\n            if (backoff.size === 0) {\n                this.backoff.delete(topic);\n            }\n        });\n    }\n    /**\n     * Maybe reconnect to direct peers\n     * @returns {void}\n     */\n    _directConnect() {\n        // we only do this every few ticks to allow pending connections to complete and account for\n        // restarts/downtime\n        if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {\n            return;\n        }\n        const toconnect = [];\n        this.direct.forEach(id => {\n            const peer = this.peers.get(id);\n            if (!peer || !peer.isWritable) {\n                toconnect.push(id);\n            }\n        });\n        if (toconnect.length) {\n            toconnect.forEach(id => {\n                this._connect(id);\n            });\n        }\n    }\n    /**\n     * Maybe attempt connection given signed peer records\n     * @param {RPC.IPeerInfo[]} peers\n     * @returns {Promise<void>}\n     */\n    _pxConnect(peers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (peers.length > constants.GossipsubPrunePeers) {\n                utils_1.shuffle(peers);\n                peers = peers.slice(0, constants.GossipsubPrunePeers);\n            }\n            const toconnect = [];\n            yield Promise.all(peers.map((pi) => __awaiter(this, void 0, void 0, function* () {\n                if (!pi.peerID) {\n                    return;\n                }\n                const p = PeerId.createFromBytes(pi.peerID);\n                const id = p.toB58String();\n                if (this.peers.has(id)) {\n                    return;\n                }\n                if (!pi.signedPeerRecord) {\n                    toconnect.push(id);\n                    return;\n                }\n                // The peer sent us a signed record\n                // This is not a record from the peer who sent the record, but another peer who is connected with it\n                // Ensure that it is valid\n                try {\n                    const envelope = yield Envelope.openAndCertify(pi.signedPeerRecord, 'libp2p-peer-record');\n                    const eid = envelope.peerId.toB58String();\n                    if (id !== eid) {\n                        this.log('bogus peer record obtained through px: peer ID %s doesn\\'t match expected peer %s', eid, id);\n                        return;\n                    }\n                    if (!this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {\n                        this.log('bogus peer record obtained through px: could not add peer record to address book');\n                        return;\n                    }\n                    toconnect.push(id);\n                }\n                catch (e) {\n                    this.log('bogus peer record obtained through px: invalid signature or not a peer record');\n                }\n            })));\n            if (!toconnect.length) {\n                return;\n            }\n            toconnect.forEach(id => this._connect(id));\n        });\n    }\n    /**\n     * Mounts the gossipsub protocol onto the libp2p node and sends our\n     * our subscriptions to every peer connected\n     * @override\n     * @returns {void}\n     */\n    start() {\n        super.start();\n        this.heartbeat.start();\n        this.score.start();\n        // connect to direct peers\n        this._directPeerInitial = setTimeout(() => {\n            this.direct.forEach(id => {\n                this._connect(id);\n            });\n        }, constants.GossipsubDirectConnectInitialDelay);\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n    stop() {\n        super.stop();\n        this.heartbeat.stop();\n        this.score.stop();\n        this.mesh = new Map();\n        this.fanout = new Map();\n        this.lastpub = new Map();\n        this.gossip = new Map();\n        this.control = new Map();\n        this.peerhave = new Map();\n        this.iasked = new Map();\n        this.backoff = new Map();\n        this.outbound = new Map();\n        this.gossipTracer.clear();\n        clearTimeout(this._directPeerInitial);\n    }\n    /**\n     * Connect to a peer using the gossipsub protocol\n     * @param {string} id\n     * @returns {void}\n     */\n    _connect(id) {\n        this.log('Initiating connection with %s', id);\n        this._libp2p.dialProtocol(PeerId.createFromB58String(id), this.multicodecs);\n    }\n    /**\n     * Subscribes to a topic\n     * @override\n     * @param {string} topic\n     * @returns {void}\n     */\n    subscribe(topic) {\n        super.subscribe(topic);\n        this.join(topic);\n    }\n    /**\n     * Unsubscribe to a topic\n     * @override\n     * @param {string} topic\n     * @returns {void}\n     */\n    unsubscribe(topic) {\n        super.unsubscribe(topic);\n        this.leave(topic);\n    }\n    /**\n     * Join topic\n     * @param {string} topic\n     * @returns {void}\n     */\n    join(topic) {\n        if (!this.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        this.log('JOIN %s', topic);\n        const fanoutPeers = this.fanout.get(topic);\n        if (fanoutPeers) {\n            // these peers have a score above the publish threshold, which may be negative\n            // so drop the ones with a negative score\n            fanoutPeers.forEach(id => {\n                if (this.score.score(id) < 0) {\n                    fanoutPeers.delete(id);\n                }\n            });\n            if (fanoutPeers.size < this._options.D) {\n                // we need more peers; eager, as this would get fixed in the next heartbeat\n                get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, (id) => {\n                    // filter our current peers, direct peers, and peers with negative scores\n                    return !fanoutPeers.has(id) && !this.direct.has(id) && this.score.score(id) >= 0;\n                }).forEach(id => fanoutPeers.add(id));\n            }\n            this.mesh.set(topic, fanoutPeers);\n            this.fanout.delete(topic);\n            this.lastpub.delete(topic);\n        }\n        else {\n            const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, (id) => {\n                // filter direct peers and peers with negative score\n                return !this.direct.has(id) && this.score.score(id) >= 0;\n            });\n            this.mesh.set(topic, peers);\n        }\n        this.mesh.get(topic).forEach((id) => {\n            this.log('JOIN: Add mesh link to %s in %s', id, topic);\n            this._sendGraft(id, topic);\n        });\n    }\n    /**\n     * Leave topic\n     * @param {string} topic\n     * @returns {void}\n     */\n    leave(topic) {\n        if (!this.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        this.log('LEAVE %s', topic);\n        // Send PRUNE to mesh peers\n        const meshPeers = this.mesh.get(topic);\n        if (meshPeers) {\n            meshPeers.forEach((id) => {\n                this.log('LEAVE: Remove mesh link to %s in %s', id, topic);\n                this._sendPrune(id, topic);\n            });\n            this.mesh.delete(topic);\n        }\n    }\n    /**\n     * Publish messages\n     *\n     * @override\n     * @param {InMessage} msg\n     * @returns {void}\n     */\n    _publish(msg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (msg.receivedFrom !== this.peerId.toB58String()) {\n                this.score.deliverMessage(msg);\n                this.gossipTracer.deliverMessage(msg);\n            }\n            const msgID = yield this.getMsgId(msg);\n            const msgIdStr = utils_1.messageIdToString(msgID);\n            // put in seen cache\n            this.seenCache.put(msgIdStr);\n            this.messageCache.put(msg);\n            const tosend = new Set();\n            msg.topicIDs.forEach((topic) => {\n                const peersInTopic = this.topics.get(topic);\n                if (!peersInTopic) {\n                    return;\n                }\n                if (this._options.floodPublish && msg.receivedFrom === this.peerId.toB58String()) {\n                    // flood-publish behavior\n                    // send to direct peers and _all_ peers meeting the publishThreshold\n                    peersInTopic.forEach(id => {\n                        if (this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.publishThreshold) {\n                            tosend.add(id);\n                        }\n                    });\n                }\n                else {\n                    // non-flood-publish behavior\n                    // send to direct peers, subscribed floodsub peers\n                    // and some mesh peers above publishThreshold\n                    // direct peers\n                    this.direct.forEach(id => {\n                        tosend.add(id);\n                    });\n                    // floodsub peers\n                    peersInTopic.forEach((id) => {\n                        const score = this.score.score(id);\n                        const peerStreams = this.peers.get(id);\n                        if (!peerStreams) {\n                            return;\n                        }\n                        if (peerStreams.protocol === constants.FloodsubID && score >= this._options.scoreThresholds.publishThreshold) {\n                            tosend.add(id);\n                        }\n                    });\n                    // Gossipsub peers handling\n                    let meshPeers = this.mesh.get(topic);\n                    if (!meshPeers || !meshPeers.size) {\n                        // We are not in the mesh for topic, use fanout peers\n                        meshPeers = this.fanout.get(topic);\n                        if (!meshPeers) {\n                            // If we are not in the fanout, then pick peers in topic above the publishThreshold\n                            const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n                                return this.score.score(id) >= this._options.scoreThresholds.publishThreshold;\n                            });\n                            if (peers.size > 0) {\n                                meshPeers = peers;\n                                this.fanout.set(topic, peers);\n                            }\n                            else {\n                                meshPeers = new Set();\n                            }\n                        }\n                        // Store the latest publishing time\n                        this.lastpub.set(topic, this._now());\n                    }\n                    meshPeers.forEach((peer) => {\n                        tosend.add(peer);\n                    });\n                }\n            });\n            // Publish messages to peers\n            const rpc = utils_1.createGossipRpc([\n                pubsub_1.utils.normalizeOutRpcMessage(msg)\n            ]);\n            tosend.forEach((id) => {\n                if (id === msg.receivedFrom || id === msg.from) {\n                    return;\n                }\n                this._sendRpc(id, rpc);\n            });\n        });\n    }\n    /**\n     * Sends a GRAFT message to a peer\n     * @param {string} id peer id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _sendGraft(id, topic) {\n        const graft = [{\n                topicID: topic\n            }];\n        const out = utils_1.createGossipRpc([], { graft });\n        this._sendRpc(id, out);\n    }\n    /**\n     * Sends a PRUNE message to a peer\n     * @param {string} id peer id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _sendPrune(id, topic) {\n        const prune = [\n            this._makePrune(id, topic, this._options.doPX)\n        ];\n        const out = utils_1.createGossipRpc([], { prune });\n        this._sendRpc(id, out);\n    }\n    /**\n     * @override\n     */\n    _sendRpc(id, outRpc) {\n        const peerStreams = this.peers.get(id);\n        if (!peerStreams || !peerStreams.isWritable) {\n            return;\n        }\n        // piggyback control message retries\n        const ctrl = this.control.get(id);\n        if (ctrl) {\n            this._piggybackControl(id, outRpc, ctrl);\n            this.control.delete(id);\n        }\n        // piggyback gossip\n        const ihave = this.gossip.get(id);\n        if (ihave) {\n            this._piggybackGossip(id, outRpc, ihave);\n            this.gossip.delete(id);\n        }\n        peerStreams.write(rpc_1.RPC.encode(outRpc).finish());\n    }\n    _piggybackControl(id, outRpc, ctrl) {\n        const tograft = (ctrl.graft || [])\n            .filter(({ topicID }) => (topicID && this.mesh.get(topicID) || new Set()).has(id));\n        const toprune = (ctrl.prune || [])\n            .filter(({ topicID }) => !(topicID && this.mesh.get(topicID) || new Set()).has(id));\n        if (!tograft.length && !toprune.length) {\n            return;\n        }\n        if (outRpc.control) {\n            outRpc.control.graft = outRpc.control.graft && outRpc.control.graft.concat(tograft);\n            outRpc.control.prune = outRpc.control.prune && outRpc.control.prune.concat(toprune);\n        }\n        else {\n            outRpc.control = { ihave: [], iwant: [], graft: tograft, prune: toprune };\n        }\n    }\n    _piggybackGossip(id, outRpc, ihave) {\n        if (!outRpc.control) {\n            outRpc.control = { ihave: [], iwant: [], graft: [], prune: [] };\n        }\n        outRpc.control.ihave = ihave;\n    }\n    /**\n     * Send graft and prune messages\n     * @param {Map<string, Array<string>>} tograft peer id => topic[]\n     * @param {Map<string, Array<string>>} toprune peer id => topic[]\n     */\n    _sendGraftPrune(tograft, toprune, noPX) {\n        const doPX = this._options.doPX;\n        for (const [id, topics] of tograft) {\n            const graft = topics.map((topicID) => ({ topicID }));\n            let prune = [];\n            // If a peer also has prunes, process them now\n            const pruning = toprune.get(id);\n            if (pruning) {\n                prune = pruning.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n                toprune.delete(id);\n            }\n            const outRpc = utils_1.createGossipRpc([], { graft, prune });\n            this._sendRpc(id, outRpc);\n        }\n        for (const [id, topics] of toprune) {\n            const prune = topics.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n            const outRpc = utils_1.createGossipRpc([], { prune });\n            this._sendRpc(id, outRpc);\n        }\n    }\n    /**\n     * Emits gossip to peers in a particular topic\n     * @param {string} topic\n     * @param {Set<string>} exclude peers to exclude\n     * @returns {void}\n     */\n    _emitGossip(topic, exclude) {\n        const messageIDs = this.messageCache.getGossipIDs(topic);\n        if (!messageIDs.length) {\n            return;\n        }\n        // shuffle to emit in random order\n        utils_1.shuffle(messageIDs);\n        // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n        if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n            // we do the truncation (with shuffling) per peer below\n            this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n        }\n        // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy\n        // First we collect the peers above gossipThreshold that are not in the exclude set\n        // and then randomly select from that set\n        // We also exclude direct peers, as there is no reason to emit gossip to them\n        const peersToGossip = [];\n        const topicPeers = this.topics.get(topic);\n        if (!topicPeers) {\n            // no topic peers, no gossip\n            return;\n        }\n        topicPeers.forEach(id => {\n            const peerStreams = this.peers.get(id);\n            if (!peerStreams) {\n                return;\n            }\n            if (!exclude.has(id) &&\n                !this.direct.has(id) &&\n                utils_1.hasGossipProtocol(peerStreams.protocol) &&\n                this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {\n                peersToGossip.push(id);\n            }\n        });\n        let target = this._options.Dlazy;\n        const factor = constants.GossipsubGossipFactor * peersToGossip.length;\n        if (factor > target) {\n            target = factor;\n        }\n        if (target > peersToGossip.length) {\n            target = peersToGossip.length;\n        }\n        else {\n            utils_1.shuffle(peersToGossip);\n        }\n        // Emit the IHAVE gossip to the selected peers up to the target\n        peersToGossip.slice(0, target).forEach(id => {\n            let peerMessageIDs = messageIDs;\n            if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n                // shuffle and slice message IDs per peer so that we emit a different set for each peer\n                // we have enough reduncancy in the system that this will significantly increase the message\n                // coverage when we do truncate\n                peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);\n            }\n            this._pushGossip(id, {\n                topicID: topic,\n                messageIDs: peerMessageIDs\n            });\n        });\n    }\n    /**\n     * Flush gossip and control messages\n     */\n    _flush() {\n        // send gossip first, which will also piggyback control\n        for (const [peer, ihave] of this.gossip.entries()) {\n            this.gossip.delete(peer);\n            const out = utils_1.createGossipRpc([], { ihave });\n            this._sendRpc(peer, out);\n        }\n        // send the remaining control messages\n        for (const [peer, control] of this.control.entries()) {\n            this.control.delete(peer);\n            const out = utils_1.createGossipRpc([], { graft: control.graft, prune: control.prune });\n            this._sendRpc(peer, out);\n        }\n    }\n    /**\n     * Adds new IHAVE messages to pending gossip\n     * @param {PeerStreams} peerStreams\n     * @param {Array<RPC.IControlIHave>} controlIHaveMsgs\n     * @returns {void}\n     */\n    _pushGossip(id, controlIHaveMsgs) {\n        this.log('Add gossip to %s', id);\n        const gossip = this.gossip.get(id) || [];\n        this.gossip.set(id, gossip.concat(controlIHaveMsgs));\n    }\n    /**\n     * Returns the current time in milliseconds\n     * @returns {number}\n     */\n    _now() {\n        return Date.now();\n    }\n    /**\n     * Make a PRUNE control message for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @param {boolean} doPX\n     * @returns {RPC.IControlPrune}\n     */\n    _makePrune(id, topic, doPX) {\n        if (this.peers.get(id).protocol === constants.GossipsubIDv10) {\n            // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n            return {\n                topicID: topic,\n                peers: []\n            };\n        }\n        // backoff is measured in seconds\n        // GossipsubPruneBackoff is measured in milliseconds\n        const backoff = constants.GossipsubPruneBackoff / 1000;\n        const px = [];\n        if (doPX) {\n            // select peers for Peer eXchange\n            const peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, (xid) => {\n                return xid !== id && this.score.score(xid) >= 0;\n            });\n            peers.forEach(p => {\n                // see if we have a signed record to send back; if we don't, just send\n                // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n                // unsigned address records through PX anyways\n                // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n                const peerId = PeerId.createFromB58String(p);\n                px.push({\n                    peerID: peerId.toBytes(),\n                    signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId)\n                });\n            });\n        }\n        return {\n            topicID: topic,\n            peers: px,\n            backoff: backoff\n        };\n    }\n}\nGossipsub.multicodec = constants.GossipsubIDv11;\nmodule.exports = Gossipsub;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}