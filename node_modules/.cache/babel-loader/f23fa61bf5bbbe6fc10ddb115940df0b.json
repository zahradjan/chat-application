{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar _require = require('multiformats/cid'),\n    CID = _require.CID;\n\nvar Key = require('interface-datastore').Key;\n\nvar log = require('debug')('ipfs:repo:migrator:migration-8');\n\nvar length = require('it-length');\n\nvar _require2 = require('multiformats/bases/base32'),\n    base32 = _require2.base32;\n\nvar raw = require('multiformats/codecs/raw');\n\nvar mhd = require('multiformats/hashes/digest');\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {*} blockstore\n * @returns {Datastore}\n */\n\n\nfunction unwrap(blockstore) {\n  if (blockstore.child) {\n    return unwrap(blockstore.child);\n  }\n\n  return blockstore;\n}\n/**\n * @param {Key} key\n */\n\n\nfunction keyToMultihash(key) {\n  try {\n    var buf = base32.decode(\"b\".concat(key.toString().toLowerCase().slice(1))); // Extract multihash from CID\n\n    var multihash = CID.decode(buf).multihash.bytes; // Encode and slice off multibase codec\n    // Should be uppercase for interop with go\n\n    var multihashStr = base32.encode(multihash).slice(1).toUpperCase();\n    return new Key(\"/\".concat(multihashStr), false);\n  } catch (err) {\n    return key;\n  }\n}\n/**\n * @param {Key} key\n */\n\n\nfunction keyToCid(key) {\n  try {\n    var buf = base32.decode(\"b\".concat(key.toString().toLowerCase().slice(1)));\n    var digest = mhd.decode(buf); // CID to Key\n\n    var multihash = base32.encode(CID.createV1(raw.code, digest).bytes).slice(1);\n    return new Key(\"/\".concat(multihash.toUpperCase()), false);\n  } catch (_unused) {\n    return key;\n  }\n}\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {(percent: number, message: string) => void} onProgress\n * @param {(key: Key) => Key} keyFunction\n */\n\n\nfunction process(_x, _x2, _x3) {\n  return _process.apply(this, arguments);\n}\n/** @type {Migration} */\n\n\nfunction _process() {\n  _process = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backends, onProgress, keyFunction) {\n    var blockstore, unwrapped, blockCount, counter, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, block, newKey;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            blockstore = backends.blocks;\n            _context.next = 3;\n            return blockstore.open();\n\n          case 3:\n            unwrapped = unwrap(blockstore);\n            _context.next = 6;\n            return length(unwrapped.queryKeys({\n              filters: [function (key) {\n                var newKey = keyFunction(key);\n                return newKey.toString() !== key.toString();\n              }]\n            }));\n\n          case 6:\n            blockCount = _context.sent;\n            _context.prev = 7;\n            counter = 0;\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 11;\n            _iterator = _asyncIterator(unwrapped.query({}));\n\n          case 13:\n            _context.next = 15;\n            return _iterator.next();\n\n          case 15:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 34;\n              break;\n            }\n\n            block = _step.value;\n            newKey = keyFunction(block.key); // If the Key is base32 CIDv0 then there's nothing to do\n\n            if (!(newKey.toString() !== block.key.toString())) {\n              _context.next = 31;\n              break;\n            }\n\n            counter += 1;\n            _context.t0 = log;\n            _context.t1 = \"Migrating Block from \".concat(block.key, \" to \").concat(newKey);\n            _context.next = 24;\n            return unwrapped.has(block.key);\n\n          case 24:\n            _context.t2 = _context.sent;\n            (0, _context.t0)(_context.t1, _context.t2);\n            _context.next = 28;\n            return unwrapped.delete(block.key);\n\n          case 28:\n            _context.next = 30;\n            return unwrapped.put(newKey, block.value);\n\n          case 30:\n            onProgress(counter / blockCount * 100, \"Migrated Block from \".concat(block.key, \" to \").concat(newKey));\n\n          case 31:\n            _iteratorAbruptCompletion = false;\n            _context.next = 13;\n            break;\n\n          case 34:\n            _context.next = 40;\n            break;\n\n          case 36:\n            _context.prev = 36;\n            _context.t3 = _context[\"catch\"](11);\n            _didIteratorError = true;\n            _iteratorError = _context.t3;\n\n          case 40:\n            _context.prev = 40;\n            _context.prev = 41;\n\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 45;\n              break;\n            }\n\n            _context.next = 45;\n            return _iterator.return();\n\n          case 45:\n            _context.prev = 45;\n\n            if (!_didIteratorError) {\n              _context.next = 48;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 48:\n            return _context.finish(45);\n\n          case 49:\n            return _context.finish(40);\n\n          case 50:\n            _context.prev = 50;\n            _context.next = 53;\n            return blockstore.close();\n\n          case 53:\n            return _context.finish(50);\n\n          case 54:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[7,, 50, 54], [11, 36, 40, 50], [41,, 45, 49]]);\n  }));\n  return _process.apply(this, arguments);\n}\n\nmodule.exports = {\n  version: 8,\n  description: 'Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32',\n  migrate: function migrate(backends) {\n    var onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n    return process(backends, onProgress, keyToMultihash);\n  },\n  revert: function revert(backends) {\n    var onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n    return process(backends, onProgress, keyToCid);\n  }\n};","map":{"version":3,"names":["require","CID","Key","log","length","base32","raw","mhd","unwrap","blockstore","child","keyToMultihash","key","buf","decode","toString","toLowerCase","slice","multihash","bytes","multihashStr","encode","toUpperCase","err","keyToCid","digest","createV1","code","process","backends","onProgress","keyFunction","blocks","open","unwrapped","queryKeys","filters","newKey","blockCount","counter","query","block","has","delete","put","value","close","module","exports","version","description","migrate","revert"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-repo-migrations/migrations/migration-8/index.js"],"sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst Key = require('interface-datastore').Key\nconst log = require('debug')('ipfs:repo:migrator:migration-8')\n\nconst length = require('it-length')\nconst { base32 } = require('multiformats/bases/base32')\nconst raw = require('multiformats/codecs/raw')\nconst mhd = require('multiformats/hashes/digest')\n\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {*} blockstore\n * @returns {Datastore}\n */\nfunction unwrap (blockstore) {\n  if (blockstore.child) {\n    return unwrap(blockstore.child)\n  }\n\n  return blockstore\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToMultihash (key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`)\n\n    // Extract multihash from CID\n    const multihash = CID.decode(buf).multihash.bytes\n\n    // Encode and slice off multibase codec\n    // Should be uppercase for interop with go\n    const multihashStr = base32.encode(multihash).slice(1).toUpperCase()\n\n    return new Key(`/${multihashStr}`, false)\n  } catch (err) {\n    return key\n  }\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToCid (key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`)\n    const digest = mhd.decode(buf)\n\n    // CID to Key\n    const multihash = base32.encode(CID.createV1(raw.code, digest).bytes).slice(1)\n\n    return new Key(`/${multihash.toUpperCase()}`, false)\n  } catch {\n    return key\n  }\n}\n\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {(percent: number, message: string) => void} onProgress\n * @param {(key: Key) => Key} keyFunction\n */\nasync function process (backends, onProgress, keyFunction) {\n  const blockstore = backends.blocks\n  await blockstore.open()\n\n  const unwrapped = unwrap(blockstore)\n\n  const blockCount = await length(unwrapped.queryKeys({\n    filters: [(key) => {\n      const newKey = keyFunction(key)\n\n      return newKey.toString() !== key.toString()\n    }]\n  }))\n\n  try {\n    let counter = 0\n\n    for await (const block of unwrapped.query({})) {\n      const newKey = keyFunction(block.key)\n\n      // If the Key is base32 CIDv0 then there's nothing to do\n      if (newKey.toString() !== block.key.toString()) {\n        counter += 1\n        log(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key))\n\n        await unwrapped.delete(block.key)\n        await unwrapped.put(newKey, block.value)\n\n        onProgress((counter / blockCount) * 100, `Migrated Block from ${block.key} to ${newKey}`)\n      }\n    }\n  } finally {\n    await blockstore.close()\n  }\n}\n\n/** @type {Migration} */\nmodule.exports = {\n  version: 8,\n  description: 'Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToMultihash)\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToCid)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}