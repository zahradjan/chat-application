{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst mapSeries = require('p-each-series');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst Log = require('ipfs-log');\n\nconst Entry = Log.Entry;\n\nconst Index = require('./Index');\n\nconst Replicator = require('./Replicator');\n\nconst ReplicationInfo = require('./replication-info');\n\nconst Logger = require('logplease');\n\nconst logger = Logger.create('orbit-db.store', {\n  color: Logger.Colors.Blue\n});\nLogger.setLogLevel('ERROR');\n\nconst io = require('orbit-db-io');\n\nconst DefaultOptions = {\n  Index: Index,\n  maxHistory: -1,\n  fetchEntryTimeout: null,\n  referenceCount: 32,\n  replicationConcurrency: 32,\n  syncLocal: false,\n  sortFn: undefined\n};\n\nclass Store {\n  constructor(ipfs, identity, address, options) {\n    if (!identity) {\n      throw new Error('Identity required');\n    } // Set the options\n\n\n    const opts = Object.assign({}, DefaultOptions);\n    Object.assign(opts, options);\n    this.options = opts; // Default type\n\n    this._type = 'store'; // Create IDs, names and paths\n\n    this.id = address.toString();\n    this.identity = identity;\n    this.address = address;\n    this.dbname = address.path || '';\n    this.events = new EventEmitter();\n    this.remoteHeadsPath = path.join(this.id, '_remoteHeads');\n    this.localHeadsPath = path.join(this.id, '_localHeads');\n    this.snapshotPath = path.join(this.id, 'snapshot');\n    this.queuePath = path.join(this.id, 'queue');\n    this.manifestPath = path.join(this.id, '_manifest'); // External dependencies\n\n    this._ipfs = ipfs;\n    this._cache = options.cache; // Access mapping\n\n    const defaultAccess = {\n      canAppend: entry => entry.identity.publicKey === identity.publicKey\n    };\n    this.access = options.accessController || defaultAccess; // Create the operations log\n\n    this._oplog = new Log(this._ipfs, this.identity, {\n      logId: this.id,\n      access: this.access,\n      sortFn: this.options.sortFn\n    }); // _addOperation and log-joins queue. Adding ops and joins to the queue\n    // makes sure they get processed sequentially to avoid race conditions\n    // between writes and joins (coming from Replicator)\n\n    this._queue = new PQueue({\n      concurrency: 1\n    }); // Create the index\n\n    this._index = new this.options.Index(this.address.root); // Replication progress info\n\n    this._replicationStatus = new ReplicationInfo(); // Statistics\n\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    };\n\n    try {\n      const onReplicationQueued = async entry => {\n        // Update the latest entry state (latest is the entry with largest clock time)\n        this._recalculateReplicationMax(entry.clock ? entry.clock.time : 0);\n\n        this.events.emit('replicate', this.address.toString(), entry);\n      };\n\n      const onReplicationProgress = async entry => {\n        const previousProgress = this.replicationStatus.progress;\n        const previousMax = this.replicationStatus.max;\n\n        this._recalculateReplicationStatus(entry.clock.time);\n\n        if (this._oplog.length + 1 > this.replicationStatus.progress || this.replicationStatus.progress > previousProgress || this.replicationStatus.max > previousMax) {\n          this.events.emit('replicate.progress', this.address.toString(), entry.hash, entry, this.replicationStatus.progress, this.replicationStatus.max);\n        }\n      };\n\n      const onReplicationComplete = async logs => {\n        const updateState = async () => {\n          try {\n            if (this._oplog && logs.length > 0) {\n              for (const log of logs) {\n                await this._oplog.join(log);\n              } // only store heads that has been verified and merges\n\n\n              const heads = this._oplog.heads;\n              await this._cache.set(this.remoteHeadsPath, heads);\n              logger.debug(`Saved heads ${heads.length} [${heads.map(e => e.hash).join(', ')}]`); // update the store's index after joining the logs\n              // and persisting the latest heads\n\n              await this._updateIndex();\n\n              if (this._oplog.length > this.replicationStatus.progress) {\n                this._recalculateReplicationStatus(this._oplog.length);\n              }\n\n              this.events.emit('replicated', this.address.toString(), logs.length, this);\n            }\n          } catch (e) {\n            console.error(e);\n          }\n        };\n\n        await this._queue.add(updateState.bind(this));\n      }; // Create the replicator\n\n\n      this._replicator = new Replicator(this, this.options.replicationConcurrency); // For internal backwards compatibility,\n      // to be removed in future releases\n\n      this._loader = this._replicator; // Hook up the callbacks to the Replicator\n\n      this._replicator.onReplicationQueued = onReplicationQueued;\n      this._replicator.onReplicationProgress = onReplicationProgress;\n      this._replicator.onReplicationComplete = onReplicationComplete;\n    } catch (e) {\n      console.error('Store Error:', e);\n    } // TODO: verify if this is working since we don't seem to emit \"replicated.progress\" anywhere\n\n\n    this.events.on('replicated.progress', (address, hash, entry, progress, have) => {\n      this._procEntry(entry);\n    });\n    this.events.on('write', (address, entry, heads) => {\n      this._procEntry(entry);\n    });\n  }\n\n  get all() {\n    return Array.isArray(this._index._index) ? this._index._index : Object.keys(this._index._index).map(e => this._index._index[e]);\n  }\n\n  get index() {\n    return this._index._index;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  get key() {\n    return this._key;\n  }\n  /**\n   * Returns the database's current replication status information\n   * @return {[Object]} [description]\n   */\n\n\n  get replicationStatus() {\n    return this._replicationStatus;\n  }\n\n  setIdentity(identity) {\n    this.identity = identity;\n\n    this._oplog.setIdentity(identity);\n  }\n\n  async close() {\n    // Stop the Replicator\n    await this._replicator.stop(); // Wait for the operations queue to finish processing\n    // to make sure everything that all operations that have\n    // been queued will be written to disk\n\n    await this._queue.onIdle(); // Reset replication statistics\n\n    this._replicationStatus.reset(); // Reset database statistics\n\n\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    };\n\n    if (this.options.onClose) {\n      await this.options.onClose(this);\n    } // Close store access controller\n\n\n    if (this.access.close) {\n      await this.access.close();\n    } // Remove all event listeners\n\n\n    for (const event in this.events._events) {\n      this.events.removeAllListeners(event);\n    }\n\n    this._oplog = null; // Database is now closed\n    // TODO: afaik we don't use 'closed' event anymore,\n    // to be removed in future releases\n\n    this.events.emit('closed', this.address.toString());\n    return Promise.resolve();\n  }\n  /**\n   * Drops a database and removes local data\n   * @return {[None]}\n   */\n\n\n  async drop() {\n    if (this.options.onDrop) {\n      await this.options.onDrop(this);\n    }\n\n    await this._cache.del(this.localHeadsPath);\n    await this._cache.del(this.remoteHeadsPath);\n    await this._cache.del(this.snapshotPath);\n    await this._cache.del(this.queuePath);\n    await this._cache.del(this.manifestPath);\n    await this.close(); // Reset\n\n    this._index = new this.options.Index(this.address.root);\n    this._oplog = new Log(this._ipfs, this.identity, {\n      logId: this.id,\n      access: this.access,\n      sortFn: this.options.sortFn\n    });\n    this._cache = this.options.cache;\n  }\n\n  async load(amount) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof amount === 'object') {\n      opts = amount;\n      amount = undefined;\n    }\n\n    amount = amount || this.options.maxHistory;\n    const fetchEntryTimeout = opts.fetchEntryTimeout || this.options.fetchEntryTimeout;\n\n    if (this.options.onLoad) {\n      await this.options.onLoad(this);\n    }\n\n    const localHeads = (await this._cache.get(this.localHeadsPath)) || [];\n    const remoteHeads = (await this._cache.get(this.remoteHeadsPath)) || [];\n    const heads = localHeads.concat(remoteHeads);\n\n    if (heads.length > 0) {\n      this.events.emit('load', this.address.toString(), heads);\n    } // Update the replication status from the heads\n\n\n    heads.forEach(h => this._recalculateReplicationMax(h.clock.time)); // Load the log\n\n    const log = await Log.fromEntryHash(this._ipfs, this.identity, heads.map(e => e.hash), {\n      logId: this.id,\n      access: this.access,\n      sortFn: this.options.sortFn,\n      length: amount,\n      onProgressCallback: this._onLoadProgress.bind(this),\n      timeout: fetchEntryTimeout,\n      concurrency: this.options.replicationConcurrency\n    });\n    this._oplog = log; // Update the index\n\n    if (heads.length > 0) {\n      await this._updateIndex();\n    }\n\n    this.events.emit('ready', this.address.toString(), this._oplog.heads);\n  }\n\n  async sync(heads) {\n    this._stats.syncRequestsReceieved += 1;\n    logger.debug(`Sync request #${this._stats.syncRequestsReceieved} ${heads.length}`);\n\n    if (heads.length === 0) {\n      return;\n    } // To simulate network latency, uncomment this line\n    // and comment out the rest of the function\n    // That way the object (received as head message from pubsub)\n    // doesn't get written to IPFS and so when the Replicator is fetching\n    // the log, it'll fetch it from the network instead from the disk.\n    // return this._replicator.load(heads)\n\n\n    const saveToIpfs = async head => {\n      if (!head) {\n        console.warn(\"Warning: Given input entry was 'null'.\");\n        return Promise.resolve(null);\n      }\n\n      const identityProvider = this.identity.provider;\n      if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry');\n      const canAppend = await this.access.canAppend(head, identityProvider);\n\n      if (!canAppend) {\n        console.warn('Warning: Given input entry is not allowed in this log and was discarded (no write access).');\n        return Promise.resolve(null);\n      }\n\n      const logEntry = Entry.toEntry(head);\n      const hash = await io.write(this._ipfs, Entry.getWriteFormat(logEntry), logEntry, {\n        links: Entry.IPLD_LINKS,\n        onlyHash: true\n      });\n\n      if (hash !== head.hash) {\n        console.warn('\"WARNING! Head hash didn\\'t match the contents');\n      }\n\n      return head;\n    };\n\n    return mapSeries(heads, saveToIpfs).then(async saved => {\n      return this._replicator.load(saved.filter(e => e !== null));\n    });\n  }\n\n  loadMoreFrom(amount, entries) {\n    this._replicator.load(entries);\n  }\n\n  async saveSnapshot() {\n    const unfinished = this._replicator.unfinished;\n\n    const snapshotData = this._oplog.toSnapshot();\n\n    const buf = Buffer.from(JSON.stringify({\n      id: snapshotData.id,\n      heads: snapshotData.heads,\n      size: snapshotData.values.length,\n      values: snapshotData.values,\n      type: this.type\n    }));\n    const snapshot = await this._ipfs.add(buf);\n    snapshot.hash = snapshot.cid.toString(); // js-ipfs >= 0.41, ipfs.add results contain a cid property (a CID instance) instead of a string hash property\n\n    await this._cache.set(this.snapshotPath, snapshot);\n    await this._cache.set(this.queuePath, unfinished);\n    logger.debug(`Saved snapshot: ${snapshot.hash}, queue length: ${unfinished.length}`);\n    return [snapshot];\n  }\n\n  async loadFromSnapshot(onProgressCallback) {\n    if (this.options.onLoad) {\n      await this.options.onLoad(this);\n    }\n\n    this.events.emit('load', this.address.toString()); // TODO emits inconsistent params, missing heads param\n\n    const maxClock = (res, val) => Math.max(res, val.clock.time);\n\n    const queue = await this._cache.get(this.queuePath);\n    this.sync(queue || []);\n    const snapshot = await this._cache.get(this.snapshotPath);\n\n    if (snapshot) {\n      const chunks = [];\n\n      for await (const chunk of this._ipfs.cat(snapshot.hash)) {\n        chunks.push(chunk);\n      }\n\n      const buffer = Buffer.concat(chunks);\n      const snapshotData = JSON.parse(buffer.toString()); // Fetch the entries\n      // Timeout 1 sec to only load entries that are already fetched (in order to not get stuck at loading)\n\n      this._recalculateReplicationMax(snapshotData.values.reduce(maxClock, 0));\n\n      if (snapshotData) {\n        this._oplog = await Log.fromJSON(this._ipfs, this.identity, snapshotData, {\n          access: this.access,\n          sortFn: this.options.sortFn,\n          length: -1,\n          timeout: 1000,\n          onProgressCallback: this._onLoadProgress.bind(this)\n        });\n        await this._updateIndex();\n        this.events.emit('replicated', this.address.toString()); // TODO: inconsistent params, count param not emited\n      }\n\n      this.events.emit('ready', this.address.toString(), this._oplog.heads);\n    } else {\n      throw new Error(`Snapshot for ${this.address} not found!`);\n    }\n\n    return this;\n  }\n\n  async _updateIndex() {\n    await this._index.updateIndex(this._oplog);\n  }\n\n  async syncLocal() {\n    const localHeads = (await this._cache.get(this.localHeadsPath)) || [];\n    const remoteHeads = (await this._cache.get(this.remoteHeadsPath)) || [];\n    const heads = localHeads.concat(remoteHeads);\n\n    for (let i = 0; i < heads.length; i++) {\n      const head = heads[i];\n\n      if (!this._oplog.heads.includes(head)) {\n        await this.load();\n        break;\n      }\n    }\n  }\n\n  async _addOperation(data) {\n    let {\n      onProgressCallback,\n      pin = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    async function addOperation() {\n      if (this._oplog) {\n        // check local cache for latest heads\n        if (this.options.syncLocal) {\n          await this.syncLocal();\n        }\n\n        const entry = await this._oplog.append(data, this.options.referenceCount, pin);\n\n        this._recalculateReplicationStatus(entry.clock.time);\n\n        await this._cache.set(this.localHeadsPath, [entry]);\n        await this._updateIndex();\n        this.events.emit('write', this.address.toString(), entry, this._oplog.heads);\n        if (onProgressCallback) onProgressCallback(entry);\n        return entry.hash;\n      }\n    }\n\n    return this._queue.add(addOperation.bind(this));\n  }\n\n  _addOperationBatch(data, batchOperation, lastOperation, onProgressCallback) {\n    throw new Error('Not implemented!');\n  }\n\n  _procEntry(entry) {\n    const {\n      payload,\n      hash\n    } = entry;\n    const {\n      op\n    } = payload;\n\n    if (op) {\n      this.events.emit(`log.op.${op}`, this.address.toString(), hash, payload);\n    } else {\n      this.events.emit('log.op.none', this.address.toString(), hash, payload);\n    }\n\n    this.events.emit('log.op', op, this.address.toString(), hash, payload);\n  }\n  /* Replication Status state updates */\n\n\n  _recalculateReplicationProgress() {\n    this._replicationStatus.progress = Math.max(Math.min(this._replicationStatus.progress + 1, this._replicationStatus.max), this._oplog ? this._oplog.length : 0);\n  }\n\n  _recalculateReplicationMax(max) {\n    this._replicationStatus.max = Math.max.apply(null, [this.replicationStatus.max, this._oplog ? this._oplog.length : 0, max || 0]);\n  }\n\n  _recalculateReplicationStatus(maxTotal) {\n    this._recalculateReplicationMax(maxTotal);\n\n    this._recalculateReplicationProgress();\n  }\n  /* Loading progress callback */\n\n\n  _onLoadProgress(entry) {\n    this._recalculateReplicationStatus(entry.clock.time);\n\n    this.events.emit('load.progress', this.address.toString(), entry.hash, entry, this.replicationStatus.progress, this.replicationStatus.max);\n  }\n\n}\n\nmodule.exports = Store;\nmodule.exports.DefaultOptions = DefaultOptions;","map":{"version":3,"names":["path","require","EventEmitter","mapSeries","default","PQueue","Log","Entry","Index","Replicator","ReplicationInfo","Logger","logger","create","color","Colors","Blue","setLogLevel","io","DefaultOptions","maxHistory","fetchEntryTimeout","referenceCount","replicationConcurrency","syncLocal","sortFn","undefined","Store","constructor","ipfs","identity","address","options","Error","opts","Object","assign","_type","id","toString","dbname","events","remoteHeadsPath","join","localHeadsPath","snapshotPath","queuePath","manifestPath","_ipfs","_cache","cache","defaultAccess","canAppend","entry","publicKey","access","accessController","_oplog","logId","_queue","concurrency","_index","root","_replicationStatus","_stats","snapshot","bytesLoaded","syncRequestsReceieved","onReplicationQueued","_recalculateReplicationMax","clock","time","emit","onReplicationProgress","previousProgress","replicationStatus","progress","previousMax","max","_recalculateReplicationStatus","length","hash","onReplicationComplete","logs","updateState","log","heads","set","debug","map","e","_updateIndex","console","error","add","bind","_replicator","_loader","on","have","_procEntry","all","Array","isArray","keys","index","type","key","_key","setIdentity","close","stop","onIdle","reset","onClose","event","_events","removeAllListeners","Promise","resolve","drop","onDrop","del","load","amount","onLoad","localHeads","get","remoteHeads","concat","forEach","h","fromEntryHash","onProgressCallback","_onLoadProgress","timeout","sync","saveToIpfs","head","warn","identityProvider","provider","logEntry","toEntry","write","getWriteFormat","links","IPLD_LINKS","onlyHash","then","saved","filter","loadMoreFrom","entries","saveSnapshot","unfinished","snapshotData","toSnapshot","buf","Buffer","from","JSON","stringify","size","values","cid","loadFromSnapshot","maxClock","res","val","Math","queue","chunks","chunk","cat","push","buffer","parse","reduce","fromJSON","updateIndex","i","includes","_addOperation","data","pin","addOperation","append","_addOperationBatch","batchOperation","lastOperation","payload","op","_recalculateReplicationProgress","min","apply","maxTotal","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-store/src/Store.js"],"sourcesContent":["'use strict'\n\nconst path = require('path')\nconst EventEmitter = require('events').EventEmitter\nconst mapSeries = require('p-each-series')\nconst { default: PQueue } = require('p-queue')\nconst Log = require('ipfs-log')\nconst Entry = Log.Entry\nconst Index = require('./Index')\nconst Replicator = require('./Replicator')\nconst ReplicationInfo = require('./replication-info')\n\nconst Logger = require('logplease')\nconst logger = Logger.create('orbit-db.store', { color: Logger.Colors.Blue })\nLogger.setLogLevel('ERROR')\nconst io = require('orbit-db-io')\n\nconst DefaultOptions = {\n  Index: Index,\n  maxHistory: -1,\n  fetchEntryTimeout: null,\n  referenceCount: 32,\n  replicationConcurrency: 32,\n  syncLocal: false,\n  sortFn: undefined\n}\n\nclass Store {\n  constructor (ipfs, identity, address, options) {\n    if (!identity) {\n      throw new Error('Identity required')\n    }\n\n    // Set the options\n    const opts = Object.assign({}, DefaultOptions)\n    Object.assign(opts, options)\n    this.options = opts\n\n    // Default type\n    this._type = 'store'\n\n    // Create IDs, names and paths\n    this.id = address.toString()\n    this.identity = identity\n    this.address = address\n    this.dbname = address.path || ''\n    this.events = new EventEmitter()\n\n    this.remoteHeadsPath = path.join(this.id, '_remoteHeads')\n    this.localHeadsPath = path.join(this.id, '_localHeads')\n    this.snapshotPath = path.join(this.id, 'snapshot')\n    this.queuePath = path.join(this.id, 'queue')\n    this.manifestPath = path.join(this.id, '_manifest')\n\n    // External dependencies\n    this._ipfs = ipfs\n    this._cache = options.cache\n\n    // Access mapping\n    const defaultAccess = {\n      canAppend: (entry) => (entry.identity.publicKey === identity.publicKey)\n    }\n    this.access = options.accessController || defaultAccess\n\n    // Create the operations log\n    this._oplog = new Log(this._ipfs, this.identity, { logId: this.id, access: this.access, sortFn: this.options.sortFn })\n\n    // _addOperation and log-joins queue. Adding ops and joins to the queue\n    // makes sure they get processed sequentially to avoid race conditions\n    // between writes and joins (coming from Replicator)\n    this._queue = new PQueue({ concurrency: 1 })\n\n    // Create the index\n    this._index = new this.options.Index(this.address.root)\n\n    // Replication progress info\n    this._replicationStatus = new ReplicationInfo()\n\n    // Statistics\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    }\n\n    try {\n      const onReplicationQueued = async (entry) => {\n        // Update the latest entry state (latest is the entry with largest clock time)\n        this._recalculateReplicationMax(entry.clock ? entry.clock.time : 0)\n        this.events.emit('replicate', this.address.toString(), entry)\n      }\n\n      const onReplicationProgress = async (entry) => {\n        const previousProgress = this.replicationStatus.progress\n        const previousMax = this.replicationStatus.max\n        this._recalculateReplicationStatus(entry.clock.time)\n        if (this._oplog.length + 1 > this.replicationStatus.progress ||\n          this.replicationStatus.progress > previousProgress ||\n          this.replicationStatus.max > previousMax) {\n          this.events.emit('replicate.progress', this.address.toString(), entry.hash, entry, this.replicationStatus.progress, this.replicationStatus.max)\n        }\n      }\n\n      const onReplicationComplete = async (logs) => {\n        const updateState = async () => {\n          try {\n            if (this._oplog && logs.length > 0) {\n              for (const log of logs) {\n                await this._oplog.join(log)\n              }\n\n              // only store heads that has been verified and merges\n              const heads = this._oplog.heads\n              await this._cache.set(this.remoteHeadsPath, heads)\n              logger.debug(`Saved heads ${heads.length} [${heads.map(e => e.hash).join(', ')}]`)\n\n              // update the store's index after joining the logs\n              // and persisting the latest heads\n              await this._updateIndex()\n\n              if (this._oplog.length > this.replicationStatus.progress) {\n                this._recalculateReplicationStatus(this._oplog.length)\n              }\n\n              this.events.emit('replicated', this.address.toString(), logs.length, this)\n            }\n          } catch (e) {\n            console.error(e)\n          }\n        }\n        await this._queue.add(updateState.bind(this))\n      }\n      // Create the replicator\n      this._replicator = new Replicator(this, this.options.replicationConcurrency)\n      // For internal backwards compatibility,\n      // to be removed in future releases\n      this._loader = this._replicator\n      // Hook up the callbacks to the Replicator\n      this._replicator.onReplicationQueued = onReplicationQueued\n      this._replicator.onReplicationProgress = onReplicationProgress\n      this._replicator.onReplicationComplete = onReplicationComplete\n    } catch (e) {\n      console.error('Store Error:', e)\n    }\n    // TODO: verify if this is working since we don't seem to emit \"replicated.progress\" anywhere\n    this.events.on('replicated.progress', (address, hash, entry, progress, have) => {\n      this._procEntry(entry)\n    })\n    this.events.on('write', (address, entry, heads) => {\n      this._procEntry(entry)\n    })\n  }\n\n  get all () {\n    return Array.isArray(this._index._index)\n      ? this._index._index\n      : Object.keys(this._index._index).map(e => this._index._index[e])\n  }\n\n  get index () {\n    return this._index._index\n  }\n\n  get type () {\n    return this._type\n  }\n\n  get key () {\n    return this._key\n  }\n\n  /**\n   * Returns the database's current replication status information\n   * @return {[Object]} [description]\n   */\n  get replicationStatus () {\n    return this._replicationStatus\n  }\n\n  setIdentity (identity) {\n    this.identity = identity\n    this._oplog.setIdentity(identity)\n  }\n\n  async close () {\n    // Stop the Replicator\n    await this._replicator.stop()\n\n    // Wait for the operations queue to finish processing\n    // to make sure everything that all operations that have\n    // been queued will be written to disk\n    await this._queue.onIdle()\n\n    // Reset replication statistics\n    this._replicationStatus.reset()\n\n    // Reset database statistics\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    }\n\n    if (this.options.onClose) {\n      await this.options.onClose(this)\n    }\n\n    // Close store access controller\n    if (this.access.close) {\n      await this.access.close()\n    }\n\n    // Remove all event listeners\n    for (const event in this.events._events) {\n      this.events.removeAllListeners(event)\n    }\n\n    this._oplog = null\n\n    // Database is now closed\n    // TODO: afaik we don't use 'closed' event anymore,\n    // to be removed in future releases\n    this.events.emit('closed', this.address.toString())\n    return Promise.resolve()\n  }\n\n  /**\n   * Drops a database and removes local data\n   * @return {[None]}\n   */\n  async drop () {\n    if (this.options.onDrop) {\n      await this.options.onDrop(this)\n    }\n\n    await this._cache.del(this.localHeadsPath)\n    await this._cache.del(this.remoteHeadsPath)\n    await this._cache.del(this.snapshotPath)\n    await this._cache.del(this.queuePath)\n    await this._cache.del(this.manifestPath)\n\n    await this.close()\n\n    // Reset\n    this._index = new this.options.Index(this.address.root)\n    this._oplog = new Log(this._ipfs, this.identity, { logId: this.id, access: this.access, sortFn: this.options.sortFn })\n    this._cache = this.options.cache\n  }\n\n  async load (amount, opts = {}) {\n    if (typeof amount === 'object') {\n      opts = amount\n      amount = undefined\n    }\n    amount = amount || this.options.maxHistory\n    const fetchEntryTimeout = opts.fetchEntryTimeout || this.options.fetchEntryTimeout\n\n    if (this.options.onLoad) {\n      await this.options.onLoad(this)\n    }\n    const localHeads = await this._cache.get(this.localHeadsPath) || []\n    const remoteHeads = await this._cache.get(this.remoteHeadsPath) || []\n    const heads = localHeads.concat(remoteHeads)\n\n    if (heads.length > 0) {\n      this.events.emit('load', this.address.toString(), heads)\n    }\n\n    // Update the replication status from the heads\n    heads.forEach(h => this._recalculateReplicationMax(h.clock.time))\n\n    // Load the log\n    const log = await Log.fromEntryHash(this._ipfs, this.identity, heads.map(e => e.hash), {\n      logId: this.id,\n      access: this.access,\n      sortFn: this.options.sortFn,\n      length: amount,\n      onProgressCallback: this._onLoadProgress.bind(this),\n      timeout: fetchEntryTimeout,\n      concurrency: this.options.replicationConcurrency\n    })\n\n    this._oplog = log\n\n    // Update the index\n    if (heads.length > 0) {\n      await this._updateIndex()\n    }\n\n    this.events.emit('ready', this.address.toString(), this._oplog.heads)\n  }\n\n  async sync (heads) {\n    this._stats.syncRequestsReceieved += 1\n    logger.debug(`Sync request #${this._stats.syncRequestsReceieved} ${heads.length}`)\n    if (heads.length === 0) {\n      return\n    }\n\n    // To simulate network latency, uncomment this line\n    // and comment out the rest of the function\n    // That way the object (received as head message from pubsub)\n    // doesn't get written to IPFS and so when the Replicator is fetching\n    // the log, it'll fetch it from the network instead from the disk.\n    // return this._replicator.load(heads)\n\n    const saveToIpfs = async (head) => {\n      if (!head) {\n        console.warn(\"Warning: Given input entry was 'null'.\")\n        return Promise.resolve(null)\n      }\n\n      const identityProvider = this.identity.provider\n      if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry')\n\n      const canAppend = await this.access.canAppend(head, identityProvider)\n      if (!canAppend) {\n        console.warn('Warning: Given input entry is not allowed in this log and was discarded (no write access).')\n        return Promise.resolve(null)\n      }\n\n      const logEntry = Entry.toEntry(head)\n      const hash = await io.write(this._ipfs, Entry.getWriteFormat(logEntry), logEntry, { links: Entry.IPLD_LINKS, onlyHash: true })\n\n      if (hash !== head.hash) {\n        console.warn('\"WARNING! Head hash didn\\'t match the contents')\n      }\n\n      return head\n    }\n\n    return mapSeries(heads, saveToIpfs)\n      .then(async (saved) => {\n        return this._replicator.load(saved.filter(e => e !== null))\n      })\n  }\n\n  loadMoreFrom (amount, entries) {\n    this._replicator.load(entries)\n  }\n\n  async saveSnapshot () {\n    const unfinished = this._replicator.unfinished\n\n    const snapshotData = this._oplog.toSnapshot()\n    const buf = Buffer.from(JSON.stringify({\n      id: snapshotData.id,\n      heads: snapshotData.heads,\n      size: snapshotData.values.length,\n      values: snapshotData.values,\n      type: this.type\n    }))\n\n    const snapshot = await this._ipfs.add(buf)\n\n    snapshot.hash = snapshot.cid.toString() // js-ipfs >= 0.41, ipfs.add results contain a cid property (a CID instance) instead of a string hash property\n    await this._cache.set(this.snapshotPath, snapshot)\n    await this._cache.set(this.queuePath, unfinished)\n\n    logger.debug(`Saved snapshot: ${snapshot.hash}, queue length: ${unfinished.length}`)\n\n    return [snapshot]\n  }\n\n  async loadFromSnapshot (onProgressCallback) {\n    if (this.options.onLoad) {\n      await this.options.onLoad(this)\n    }\n\n    this.events.emit('load', this.address.toString()) // TODO emits inconsistent params, missing heads param\n\n    const maxClock = (res, val) => Math.max(res, val.clock.time)\n\n    const queue = await this._cache.get(this.queuePath)\n    this.sync(queue || [])\n\n    const snapshot = await this._cache.get(this.snapshotPath)\n\n    if (snapshot) {\n      const chunks = []\n      for await (const chunk of this._ipfs.cat(snapshot.hash)) {\n        chunks.push(chunk)\n      }\n      const buffer = Buffer.concat(chunks)\n      const snapshotData = JSON.parse(buffer.toString())\n\n      // Fetch the entries\n      // Timeout 1 sec to only load entries that are already fetched (in order to not get stuck at loading)\n      this._recalculateReplicationMax(snapshotData.values.reduce(maxClock, 0))\n      if (snapshotData) {\n        this._oplog = await Log.fromJSON(this._ipfs, this.identity, snapshotData, {\n          access: this.access,\n          sortFn: this.options.sortFn,\n          length: -1,\n          timeout: 1000,\n          onProgressCallback: this._onLoadProgress.bind(this)\n        })\n        await this._updateIndex()\n        this.events.emit('replicated', this.address.toString()) // TODO: inconsistent params, count param not emited\n      }\n      this.events.emit('ready', this.address.toString(), this._oplog.heads)\n    } else {\n      throw new Error(`Snapshot for ${this.address} not found!`)\n    }\n\n    return this\n  }\n\n  async _updateIndex () {\n    await this._index.updateIndex(this._oplog)\n  }\n\n  async syncLocal () {\n    const localHeads = await this._cache.get(this.localHeadsPath) || []\n    const remoteHeads = await this._cache.get(this.remoteHeadsPath) || []\n    const heads = localHeads.concat(remoteHeads)\n    for (let i = 0; i < heads.length; i++) {\n      const head = heads[i]\n      if (!this._oplog.heads.includes(head)) {\n        await this.load()\n        break\n      }\n    }\n  }\n\n  async _addOperation (data, { onProgressCallback, pin = false } = {}) {\n    async function addOperation () {\n      if (this._oplog) {\n        // check local cache for latest heads\n        if (this.options.syncLocal) {\n          await this.syncLocal()\n        }\n        const entry = await this._oplog.append(data, this.options.referenceCount, pin)\n        this._recalculateReplicationStatus(entry.clock.time)\n        await this._cache.set(this.localHeadsPath, [entry])\n        await this._updateIndex()\n        this.events.emit('write', this.address.toString(), entry, this._oplog.heads)\n        if (onProgressCallback) onProgressCallback(entry)\n        return entry.hash\n      }\n    }\n    return this._queue.add(addOperation.bind(this))\n  }\n\n  _addOperationBatch (data, batchOperation, lastOperation, onProgressCallback) {\n    throw new Error('Not implemented!')\n  }\n\n  _procEntry (entry) {\n    const { payload, hash } = entry\n    const { op } = payload\n    if (op) {\n      this.events.emit(`log.op.${op}`, this.address.toString(), hash, payload)\n    } else {\n      this.events.emit('log.op.none', this.address.toString(), hash, payload)\n    }\n    this.events.emit('log.op', op, this.address.toString(), hash, payload)\n  }\n\n  /* Replication Status state updates */\n  _recalculateReplicationProgress () {\n    this._replicationStatus.progress = Math.max(\n      Math.min(this._replicationStatus.progress + 1, this._replicationStatus.max),\n      this._oplog ? this._oplog.length : 0\n    )\n  }\n\n  _recalculateReplicationMax (max) {\n    this._replicationStatus.max = Math.max.apply(null, [\n      this.replicationStatus.max,\n      this._oplog ? this._oplog.length : 0,\n      (max || 0)\n    ])\n  }\n\n  _recalculateReplicationStatus (maxTotal) {\n    this._recalculateReplicationMax(maxTotal)\n    this._recalculateReplicationProgress()\n  }\n\n  /* Loading progress callback */\n  _onLoadProgress (entry) {\n    this._recalculateReplicationStatus(entry.clock.time)\n    this.events.emit('load.progress', this.address.toString(), entry.hash, entry, this.replicationStatus.progress, this.replicationStatus.max)\n  }\n}\n\nmodule.exports = Store\nmodule.exports.DefaultOptions = DefaultOptions\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}