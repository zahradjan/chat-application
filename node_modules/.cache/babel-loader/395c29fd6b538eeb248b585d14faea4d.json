{"ast":null,"code":"'use strict';\n\nconst {\n  concat\n} = require('uint8arrays/concat');\n\nconst {\n  fromString\n} = require('uint8arrays/from-string');\n\nconst webcrypto = require('../webcrypto'); // Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\n\n/**\n *\n * @param {object} [options]\n * @param {string} [options.algorithm=AES-GCM]\n * @param {number} [options.nonceLength=12]\n * @param {number} [options.keyLength=16]\n * @param {string} [options.digest=sha256]\n * @param {number} [options.saltLength=16]\n * @param {number} [options.iterations=32767]\n * @returns {*}\n */\n\n\nfunction create() {\n  let {\n    algorithm = 'AES-GCM',\n    nonceLength = 12,\n    keyLength = 16,\n    digest = 'SHA-256',\n    saltLength = 16,\n    iterations = 32767\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const crypto = webcrypto.get();\n  keyLength *= 8; // Browser crypto uses bits instead of bytes\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to encrypt the data.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n\n  async function encrypt(data, password) {\n    // eslint-disable-line require-await\n    const salt = crypto.getRandomValues(new Uint8Array(saltLength));\n    const nonce = crypto.getRandomValues(new Uint8Array(nonceLength));\n    const aesGcm = {\n      name: algorithm,\n      iv: nonce\n    }; // Derive a key using PBKDF2.\n\n    const deriveParams = {\n      name: 'PBKDF2',\n      salt,\n      iterations,\n      hash: {\n        name: digest\n      }\n    };\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), {\n      name: 'PBKDF2'\n    }, false, ['deriveKey', 'deriveBits']);\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, {\n      name: algorithm,\n      length: keyLength\n    }, true, ['encrypt']); // Encrypt the string.\n\n    const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data);\n    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);\n  }\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to decrypt the data. The options used to create\n   * this decryption cipher must be the same as those used to create\n   * the encryption cipher.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  async function decrypt(data, password) {\n    const salt = data.slice(0, saltLength);\n    const nonce = data.slice(saltLength, saltLength + nonceLength);\n    const ciphertext = data.slice(saltLength + nonceLength);\n    const aesGcm = {\n      name: algorithm,\n      iv: nonce\n    }; // Derive the key using PBKDF2.\n\n    const deriveParams = {\n      name: 'PBKDF2',\n      salt,\n      iterations,\n      hash: {\n        name: digest\n      }\n    };\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), {\n      name: 'PBKDF2'\n    }, false, ['deriveKey', 'deriveBits']);\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, {\n      name: algorithm,\n      length: keyLength\n    }, true, ['decrypt']); // Decrypt the string.\n\n    const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext);\n    return new Uint8Array(plaintext);\n  }\n\n  return {\n    encrypt,\n    decrypt\n  };\n}\n\nmodule.exports = {\n  create\n};","map":{"version":3,"names":["concat","require","fromString","webcrypto","create","algorithm","nonceLength","keyLength","digest","saltLength","iterations","crypto","get","encrypt","data","password","salt","getRandomValues","Uint8Array","nonce","aesGcm","name","iv","deriveParams","hash","rawKey","subtle","importKey","cryptoKey","deriveKey","length","ciphertext","decrypt","slice","plaintext","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/peer-id/node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js"],"sourcesContent":["'use strict'\n\nconst { concat } = require('uint8arrays/concat')\nconst { fromString } = require('uint8arrays/from-string')\n\nconst webcrypto = require('../webcrypto')\n\n// Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\n\n/**\n *\n * @param {object} [options]\n * @param {string} [options.algorithm=AES-GCM]\n * @param {number} [options.nonceLength=12]\n * @param {number} [options.keyLength=16]\n * @param {string} [options.digest=sha256]\n * @param {number} [options.saltLength=16]\n * @param {number} [options.iterations=32767]\n * @returns {*}\n */\nfunction create ({\n  algorithm = 'AES-GCM',\n  nonceLength = 12,\n  keyLength = 16,\n  digest = 'SHA-256',\n  saltLength = 16,\n  iterations = 32767\n} = {}) {\n  const crypto = webcrypto.get()\n  keyLength *= 8 // Browser crypto uses bits instead of bytes\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to encrypt the data.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n  async function encrypt (data, password) { // eslint-disable-line require-await\n    const salt = crypto.getRandomValues(new Uint8Array(saltLength))\n    const nonce = crypto.getRandomValues(new Uint8Array(nonceLength))\n    const aesGcm = { name: algorithm, iv: nonce }\n\n    // Derive a key using PBKDF2.\n    const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), { name: 'PBKDF2' }, false, ['deriveKey', 'deriveBits'])\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['encrypt'])\n\n    // Encrypt the string.\n    const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data)\n    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)])\n  }\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to decrypt the data. The options used to create\n   * this decryption cipher must be the same as those used to create\n   * the encryption cipher.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n  async function decrypt (data, password) {\n    const salt = data.slice(0, saltLength)\n    const nonce = data.slice(saltLength, saltLength + nonceLength)\n    const ciphertext = data.slice(saltLength + nonceLength)\n    const aesGcm = { name: algorithm, iv: nonce }\n\n    // Derive the key using PBKDF2.\n    const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), { name: 'PBKDF2' }, false, ['deriveKey', 'deriveBits'])\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['decrypt'])\n\n    // Decrypt the string.\n    const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext)\n    return new Uint8Array(plaintext)\n  }\n\n  return {\n    encrypt,\n    decrypt\n  }\n}\n\nmodule.exports = {\n  create\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}