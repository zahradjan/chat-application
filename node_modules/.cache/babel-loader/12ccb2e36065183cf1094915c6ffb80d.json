{"ast":null,"code":"'use strict';\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst log = require('debug')('ipfs:mfs:touch');\n\nconst errCode = require('err-code');\n\nconst {\n  UnixFS\n} = require('ipfs-unixfs');\n\nconst toTrail = require('./utils/to-trail');\n\nconst addLink = require('./utils/add-link');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  importer\n} = require('ipfs-unixfs-importer');\n\nconst {\n  recursive\n} = require('ipfs-unixfs-exporter');\n\nconst last = require('it-last');\n\nconst cp = require('./cp');\n\nconst rm = require('./rm');\n\nconst persist = require('./utils/persist');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n};\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\n\nfunction calculateModification(mode, originalMode, isDirectory) {\n  let modification = 0;\n\n  if (mode.includes('x') || mode.includes('X') && (isDirectory || originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)) {\n    modification += 1;\n  }\n\n  if (mode.includes('w')) {\n    modification += 2;\n  }\n\n  if (mode.includes('r')) {\n    modification += 4;\n  }\n\n  return modification;\n}\n/**\n * @param {string} references\n * @param {number} modification\n */\n\n\nfunction calculateUGO(references, modification) {\n  let ugo = 0;\n\n  if (references.includes('u')) {\n    ugo += modification << 6;\n  }\n\n  if (references.includes('g')) {\n    ugo += modification << 3;\n  }\n\n  if (references.includes('o')) {\n    ugo += modification;\n  }\n\n  return ugo;\n}\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\n\n\nfunction calculateSpecial(references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8);\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8);\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8);\n    }\n  }\n\n  return modification;\n}\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\n\n\nfunction parseSymbolicMode(input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0;\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/);\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`);\n  }\n\n  let [, references, operator, mode] = match;\n\n  if (references === 'a' || !references) {\n    references = 'ugo';\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory);\n  modification = calculateUGO(references, modification);\n  modification = calculateSpecial(references, mode, modification);\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    return originalMode;\n  }\n\n  if (operator === '+') {\n    return modification | originalMode;\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode;\n  }\n\n  return originalMode;\n}\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\n\n\nfunction calculateMode(mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${mode}`;\n\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8);\n    } else {\n      // @ts-ignore freaks out over the curr: number, acc: string thing\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory());\n      }, metadata.mode || 0);\n    }\n  }\n\n  return mode;\n}\n/**\n * @param {MfsContext} context\n */\n\n\nmodule.exports = context => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"chmod\"]}\n   */\n  async function mfsChmod(path, mode) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options);\n    log(`Fetching stats for ${path}`);\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, opts);\n\n    if (cid.code !== dagPb.code) {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n    }\n\n    if (opts.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(async function* () {\n        for await (const entry of recursive(cid, context.repo.blocks)) {\n          if (entry.type !== 'file' && entry.type !== 'directory') {\n            throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n          }\n\n          entry.unixfs.mode = calculateMode(mode, entry.unixfs);\n          const node = dagPb.prepare({\n            Data: entry.unixfs.marshal(),\n            Links: entry.node.Links\n          });\n          yield {\n            path: entry.path,\n            content: node\n          };\n        }\n      }, // @ts-ignore we account for the incompatible source type with our custom dag builder below\n      source => importer(source, context.repo.blocks, { ...opts,\n        pin: false,\n        dagBuilder: async function* (source, block, opts) {\n          for await (const entry of source) {\n            yield async function () {\n              /** @type {PBNode} */\n              // @ts-ignore - cannot derive type\n              const node = entry.content;\n              const buf = dagPb.encode(node);\n              const cid = await persist(buf, block, opts);\n\n              if (!node.Data) {\n                throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE');\n              }\n\n              const unixfs = UnixFS.unmarshal(node.Data);\n              return {\n                cid,\n                size: buf.length,\n                path: entry.path,\n                unixfs\n              };\n            };\n          }\n        }\n      }), nodes => last(nodes));\n\n      if (!root) {\n        throw errCode(new Error(`Could not chmod ${path}`), 'ERR_COULD_NOT_CHMOD');\n      } // remove old path from mfs\n\n\n      await rm(context)(path, opts); // add newly created tree to mfs at path\n\n      await cp(context)(`/ipfs/${root.cid}`, path, opts);\n      return;\n    }\n\n    const block = await context.repo.blocks.get(cid);\n    const node = dagPb.decode(block);\n\n    if (!node.Data) {\n      throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE');\n    }\n\n    const metadata = UnixFS.unmarshal(node.Data);\n    metadata.mode = calculateMode(mode, metadata);\n    const updatedBlock = dagPb.encode({\n      Data: metadata.marshal(),\n      Links: node.Links\n    });\n    const hashAlg = opts.hashAlg || defaultOptions.hashAlg;\n    const hasher = await context.hashers.getHasher(hashAlg);\n    const hash = await hasher.digest(updatedBlock);\n    const updatedCid = CID.create(opts.cidVersion, dagPb.code, hash);\n\n    if (opts.flush) {\n      await context.repo.blocks.put(updatedCid, updatedBlock);\n    }\n\n    const trail = await toTrail(context, mfsDirectory);\n    const parent = trail[trail.length - 1];\n    const parentCid = CID.decode(parent.cid.bytes);\n    const parentBlock = await context.repo.blocks.get(parentCid);\n    const parentNode = dagPb.decode(parentBlock);\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: opts.flush,\n      // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n      hashAlg,\n      cidVersion: cid.version,\n      shardSplitThreshold: Infinity\n    });\n    parent.cid = result.cid; // update the tree with the new child\n\n    const newRootCid = await updateTree(context, trail, opts); // Update the MFS record with the new CID for the root of the tree\n\n    await updateMfsRoot(context, newRootCid, opts);\n  }\n\n  return withTimeoutOption(mfsChmod);\n};","map":{"version":3,"names":["mergeOptions","require","bind","ignoreUndefined","toMfsPath","log","errCode","UnixFS","toTrail","addLink","updateTree","updateMfsRoot","dagPb","CID","pipe","importer","recursive","last","cp","rm","persist","withTimeoutOption","defaultOptions","flush","shardSplitThreshold","hashAlg","cidVersion","calculateModification","mode","originalMode","isDirectory","modification","includes","calculateUGO","references","ugo","calculateSpecial","parseInt","parseSymbolicMode","input","match","Error","operator","calculateMode","metadata","String","strMode","split","reduce","curr","acc","module","exports","context","mfsChmod","path","options","opts","cid","mfsDirectory","name","code","root","entry","repo","blocks","type","unixfs","node","prepare","Data","marshal","Links","content","source","pin","dagBuilder","block","buf","encode","unmarshal","size","length","nodes","get","decode","updatedBlock","hasher","hashers","getHasher","hash","digest","updatedCid","create","put","trail","parent","parentCid","bytes","parentBlock","parentNode","result","version","Infinity","newRootCid"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/chmod.js"],"sourcesContent":["'use strict'\n\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst toMfsPath = require('./utils/to-mfs-path')\nconst log = require('debug')('ipfs:mfs:touch')\nconst errCode = require('err-code')\nconst { UnixFS } = require('ipfs-unixfs')\nconst toTrail = require('./utils/to-trail')\nconst addLink = require('./utils/add-link')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst dagPb = require('@ipld/dag-pb')\nconst { CID } = require('multiformats/cid')\nconst { pipe } = require('it-pipe')\nconst { importer } = require('ipfs-unixfs-importer')\nconst { recursive } = require('ipfs-unixfs-exporter')\nconst last = require('it-last')\nconst cp = require('./cp')\nconst rm = require('./rm')\nconst persist = require('./utils/persist')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n}\n\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction calculateModification (mode, originalMode, isDirectory) {\n  let modification = 0\n\n  if (mode.includes('x') || (mode.includes('X') && (isDirectory || (originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)))) {\n    modification += 1\n  }\n\n  if (mode.includes('w')) {\n    modification += 2\n  }\n\n  if (mode.includes('r')) {\n    modification += 4\n  }\n\n  return modification\n}\n\n/**\n * @param {string} references\n * @param {number} modification\n */\nfunction calculateUGO (references, modification) {\n  let ugo = 0\n\n  if (references.includes('u')) {\n    ugo += (modification << 6)\n  }\n\n  if (references.includes('g')) {\n    ugo += (modification << 3)\n  }\n\n  if (references.includes('o')) {\n    ugo += (modification)\n  }\n\n  return ugo\n}\n\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\nfunction calculateSpecial (references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8)\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8)\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8)\n    }\n  }\n\n  return modification\n}\n\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction parseSymbolicMode (input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/)\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`)\n  }\n\n  let [\n    ,\n    references,\n    operator,\n    mode\n  ] = match\n\n  if (references === 'a' || !references) {\n    references = 'ugo'\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory)\n  modification = calculateUGO(references, modification)\n  modification = calculateSpecial(references, mode, modification)\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    return originalMode\n  }\n\n  if (operator === '+') {\n    return modification | originalMode\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode\n  }\n\n  return originalMode\n}\n\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\nfunction calculateMode (mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${mode}`\n\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8)\n    } else {\n      // @ts-ignore freaks out over the curr: number, acc: string thing\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory())\n      }, metadata.mode || 0)\n    }\n  }\n\n  return mode\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"chmod\"]}\n   */\n  async function mfsChmod (path, mode, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options)\n\n    log(`Fetching stats for ${path}`)\n\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, opts)\n\n    if (cid.code !== dagPb.code) {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n    }\n\n    if (opts.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(\n        async function * () {\n          for await (const entry of recursive(cid, context.repo.blocks)) {\n            if (entry.type !== 'file' && entry.type !== 'directory') {\n              throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n            }\n\n            entry.unixfs.mode = calculateMode(mode, entry.unixfs)\n\n            const node = dagPb.prepare({\n              Data: entry.unixfs.marshal(),\n              Links: entry.node.Links\n            })\n\n            yield {\n              path: entry.path,\n              content: node\n            }\n          }\n        },\n        // @ts-ignore we account for the incompatible source type with our custom dag builder below\n        (source) => importer(source, context.repo.blocks, {\n          ...opts,\n          pin: false,\n          dagBuilder: async function * (source, block, opts) {\n            for await (const entry of source) {\n              yield async function () {\n                /** @type {PBNode} */\n                // @ts-ignore - cannot derive type\n                const node = entry.content\n\n                const buf = dagPb.encode(node)\n                const cid = await persist(buf, block, opts)\n\n                if (!node.Data) {\n                  throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n                }\n\n                const unixfs = UnixFS.unmarshal(node.Data)\n\n                return {\n                  cid,\n                  size: buf.length,\n                  path: entry.path,\n                  unixfs\n                }\n              }\n            }\n          }\n        }),\n        (nodes) => last(nodes)\n      )\n\n      if (!root) {\n        throw errCode(new Error(`Could not chmod ${path}`), 'ERR_COULD_NOT_CHMOD')\n      }\n\n      // remove old path from mfs\n      await rm(context)(path, opts)\n\n      // add newly created tree to mfs at path\n      await cp(context)(`/ipfs/${root.cid}`, path, opts)\n\n      return\n    }\n\n    const block = await context.repo.blocks.get(cid)\n    const node = dagPb.decode(block)\n\n    if (!node.Data) {\n      throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n    }\n\n    const metadata = UnixFS.unmarshal(node.Data)\n    metadata.mode = calculateMode(mode, metadata)\n    const updatedBlock = dagPb.encode({\n      Data: metadata.marshal(),\n      Links: node.Links\n    })\n\n    const hashAlg = opts.hashAlg || defaultOptions.hashAlg\n    const hasher = await context.hashers.getHasher(hashAlg)\n    const hash = await hasher.digest(updatedBlock)\n    const updatedCid = CID.create(opts.cidVersion, dagPb.code, hash)\n\n    if (opts.flush) {\n      await context.repo.blocks.put(updatedCid, updatedBlock)\n    }\n\n    const trail = await toTrail(context, mfsDirectory)\n    const parent = trail[trail.length - 1]\n    const parentCid = CID.decode(parent.cid.bytes)\n    const parentBlock = await context.repo.blocks.get(parentCid)\n    const parentNode = dagPb.decode(parentBlock)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: opts.flush,\n      // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n      hashAlg,\n      cidVersion: cid.version,\n      shardSplitThreshold: Infinity\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, opts)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts)\n  }\n\n  return withTimeoutOption(mfsChmod)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}