{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar ed = require('@noble/ed25519');\n\nvar PUBLIC_KEY_BYTE_LENGTH = 32;\nvar PRIVATE_KEY_BYTE_LENGTH = 64; // private key is actually 32 bytes but for historical reasons we concat private and public keys\n\nvar KEYS_BYTE_LENGTH = 32;\nexports.publicKeyLength = PUBLIC_KEY_BYTE_LENGTH;\nexports.privateKeyLength = PRIVATE_KEY_BYTE_LENGTH;\nexports.generateKey = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n  var privateKeyRaw, publicKey, privateKey;\n  return _regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          // the actual private key (32 bytes)\n          privateKeyRaw = ed.utils.randomPrivateKey();\n          _context.next = 3;\n          return ed.getPublicKey(privateKeyRaw);\n\n        case 3:\n          publicKey = _context.sent;\n          // concatenated the public key to the private key\n          privateKey = concatKeys(privateKeyRaw, publicKey);\n          return _context.abrupt(\"return\", {\n            privateKey: privateKey,\n            publicKey: publicKey\n          });\n\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee);\n}));\n/**\n * Generate keypair from a seed\n *\n * @param {Uint8Array} seed - seed should be a 32 byte uint8array\n * @returns\n */\n\nexports.generateKeyFromSeed = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(seed) {\n    var privateKeyRaw, publicKey, privateKey;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(seed.length !== KEYS_BYTE_LENGTH)) {\n              _context2.next = 4;\n              break;\n            }\n\n            throw new TypeError('\"seed\" must be 32 bytes in length.');\n\n          case 4:\n            if (seed instanceof Uint8Array) {\n              _context2.next = 6;\n              break;\n            }\n\n            throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.');\n\n          case 6:\n            // based on node forges algorithm, the seed is used directly as private key\n            privateKeyRaw = seed;\n            _context2.next = 9;\n            return ed.getPublicKey(privateKeyRaw);\n\n          case 9:\n            publicKey = _context2.sent;\n            privateKey = concatKeys(privateKeyRaw, publicKey);\n            return _context2.abrupt(\"return\", {\n              privateKey: privateKey,\n              publicKey: publicKey\n            });\n\n          case 12:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.hashAndSign = function (privateKey, msg) {\n  var privateKeyRaw = privateKey.slice(0, KEYS_BYTE_LENGTH);\n  return ed.sign(msg, privateKeyRaw);\n};\n\nexports.hashAndVerify = function (publicKey, sig, msg) {\n  return ed.verify(sig, msg, publicKey);\n};\n\nfunction concatKeys(privateKeyRaw, publicKey) {\n  var privateKey = new Uint8Array(exports.privateKeyLength);\n\n  for (var i = 0; i < KEYS_BYTE_LENGTH; i++) {\n    privateKey[i] = privateKeyRaw[i];\n    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];\n  }\n\n  return privateKey;\n}","map":{"version":3,"names":["ed","require","PUBLIC_KEY_BYTE_LENGTH","PRIVATE_KEY_BYTE_LENGTH","KEYS_BYTE_LENGTH","exports","publicKeyLength","privateKeyLength","generateKey","privateKeyRaw","utils","randomPrivateKey","getPublicKey","publicKey","privateKey","concatKeys","generateKeyFromSeed","seed","length","TypeError","Uint8Array","hashAndSign","msg","slice","sign","hashAndVerify","sig","verify","i"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-delegated-content-routing/node_modules/libp2p-crypto/src/keys/ed25519.js"],"sourcesContent":["'use strict'\n\nconst ed = require('@noble/ed25519')\n\nconst PUBLIC_KEY_BYTE_LENGTH = 32\nconst PRIVATE_KEY_BYTE_LENGTH = 64 // private key is actually 32 bytes but for historical reasons we concat private and public keys\nconst KEYS_BYTE_LENGTH = 32\n\nexports.publicKeyLength = PUBLIC_KEY_BYTE_LENGTH\nexports.privateKeyLength = PRIVATE_KEY_BYTE_LENGTH\n\nexports.generateKey = async function () {\n  // the actual private key (32 bytes)\n  const privateKeyRaw = ed.utils.randomPrivateKey()\n  const publicKey = await ed.getPublicKey(privateKeyRaw)\n\n  // concatenated the public key to the private key\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\n/**\n * Generate keypair from a seed\n *\n * @param {Uint8Array} seed - seed should be a 32 byte uint8array\n * @returns\n */\nexports.generateKeyFromSeed = async function (seed) {\n  if (seed.length !== KEYS_BYTE_LENGTH) {\n    throw new TypeError('\"seed\" must be 32 bytes in length.')\n  } else if (!(seed instanceof Uint8Array)) {\n    throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.')\n  }\n\n  // based on node forges algorithm, the seed is used directly as private key\n  const privateKeyRaw = seed\n  const publicKey = await ed.getPublicKey(privateKeyRaw)\n\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\nexports.hashAndSign = function (privateKey, msg) {\n  const privateKeyRaw = privateKey.slice(0, KEYS_BYTE_LENGTH)\n\n  return ed.sign(msg, privateKeyRaw)\n}\n\nexports.hashAndVerify = function (publicKey, sig, msg) {\n  return ed.verify(sig, msg, publicKey)\n}\n\nfunction concatKeys (privateKeyRaw, publicKey) {\n  const privateKey = new Uint8Array(exports.privateKeyLength)\n  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n    privateKey[i] = privateKeyRaw[i]\n    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i]\n  }\n  return privateKey\n}\n"],"mappings":"AAAA;;;;;;AAEA,IAAMA,EAAE,GAAGC,OAAO,CAAC,gBAAD,CAAlB;;AAEA,IAAMC,sBAAsB,GAAG,EAA/B;AACA,IAAMC,uBAAuB,GAAG,EAAhC,C,CAAmC;;AACnC,IAAMC,gBAAgB,GAAG,EAAzB;AAEAC,OAAO,CAACC,eAAR,GAA0BJ,sBAA1B;AACAG,OAAO,CAACE,gBAAR,GAA2BJ,uBAA3B;AAEAE,OAAO,CAACG,WAAR,2EAAsB;EAAA;EAAA;IAAA;MAAA;QAAA;UACpB;UACMC,aAFc,GAEET,EAAE,CAACU,KAAH,CAASC,gBAAT,EAFF;UAAA;UAAA,OAGIX,EAAE,CAACY,YAAH,CAAgBH,aAAhB,CAHJ;;QAAA;UAGdI,SAHc;UAKpB;UACMC,UANc,GAMDC,UAAU,CAACN,aAAD,EAAgBI,SAAhB,CANT;UAAA,iCAQb;YACLC,UAAU,EAAVA,UADK;YAELD,SAAS,EAATA;UAFK,CARa;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA,CAAtB;AAcA;AACA;AACA;AACA;AACA;AACA;;AACAR,OAAO,CAACW,mBAAR;EAAA,uEAA8B,kBAAgBC,IAAhB;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,MACxBA,IAAI,CAACC,MAAL,KAAgBd,gBADQ;cAAA;cAAA;YAAA;;YAAA,MAEpB,IAAIe,SAAJ,CAAc,oCAAd,CAFoB;;UAAA;YAAA,IAGfF,IAAI,YAAYG,UAHD;cAAA;cAAA;YAAA;;YAAA,MAIpB,IAAID,SAAJ,CAAc,iDAAd,CAJoB;;UAAA;YAO5B;YACMV,aARsB,GAQNQ,IARM;YAAA;YAAA,OASJjB,EAAE,CAACY,YAAH,CAAgBH,aAAhB,CATI;;UAAA;YAStBI,SATsB;YAWtBC,UAXsB,GAWTC,UAAU,CAACN,aAAD,EAAgBI,SAAhB,CAXD;YAAA,kCAarB;cACLC,UAAU,EAAVA,UADK;cAELD,SAAS,EAATA;YAFK,CAbqB;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAA9B;;EAAA;IAAA;EAAA;AAAA;;AAmBAR,OAAO,CAACgB,WAAR,GAAsB,UAAUP,UAAV,EAAsBQ,GAAtB,EAA2B;EAC/C,IAAMb,aAAa,GAAGK,UAAU,CAACS,KAAX,CAAiB,CAAjB,EAAoBnB,gBAApB,CAAtB;EAEA,OAAOJ,EAAE,CAACwB,IAAH,CAAQF,GAAR,EAAab,aAAb,CAAP;AACD,CAJD;;AAMAJ,OAAO,CAACoB,aAAR,GAAwB,UAAUZ,SAAV,EAAqBa,GAArB,EAA0BJ,GAA1B,EAA+B;EACrD,OAAOtB,EAAE,CAAC2B,MAAH,CAAUD,GAAV,EAAeJ,GAAf,EAAoBT,SAApB,CAAP;AACD,CAFD;;AAIA,SAASE,UAAT,CAAqBN,aAArB,EAAoCI,SAApC,EAA+C;EAC7C,IAAMC,UAAU,GAAG,IAAIM,UAAJ,CAAef,OAAO,CAACE,gBAAvB,CAAnB;;EACA,KAAK,IAAIqB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxB,gBAApB,EAAsCwB,CAAC,EAAvC,EAA2C;IACzCd,UAAU,CAACc,CAAD,CAAV,GAAgBnB,aAAa,CAACmB,CAAD,CAA7B;IACAd,UAAU,CAACV,gBAAgB,GAAGwB,CAApB,CAAV,GAAmCf,SAAS,CAACe,CAAD,CAA5C;EACD;;EACD,OAAOd,UAAP;AACD"},"metadata":{},"sourceType":"script"}