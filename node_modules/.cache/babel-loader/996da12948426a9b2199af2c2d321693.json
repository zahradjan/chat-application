{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _assertThisInitialized = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key,\n    Adapter = _require.Adapter;\n\nvar _require2 = require('./utils'),\n    encodeBase32 = _require2.encodeBase32,\n    keyToTopic = _require2.keyToTopic,\n    topicToKey = _require2.topicToKey;\n\nvar _require3 = require('uint8arrays/equals'),\n    uint8ArrayEquals = _require3.equals;\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('datastore-pubsub:publisher'), {\n  error: debug('datastore-pubsub:publisher:error')\n});\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types').Validator} Validator\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('libp2p-interfaces/src/pubsub').InMessage} PubSubMessage\n */\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\n\nvar DatastorePubsub = /*#__PURE__*/function (_Adapter) {\n  _inherits(DatastorePubsub, _Adapter);\n\n  var _super = _createSuper(DatastorePubsub);\n\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('libp2p-interfaces/src/pubsub')} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {Validator} validator - validator functions\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  function DatastorePubsub(pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    var _this;\n\n    _classCallCheck(this, DatastorePubsub);\n\n    _this = _super.call(this);\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    _this._pubsub = pubsub;\n    _this._datastore = datastore;\n    _this._peerId = peerId;\n    _this._validator = validator;\n    _this._handleSubscriptionKeyFn = subscriptionKeyFn; // Bind _onMessage function, which is called by pubsub.\n\n    _this._onMessage = _this._onMessage.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n\n\n  _createClass(DatastorePubsub, [{\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, val) {\n        var errMsg, _errMsg, stringifiedTopic;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (key instanceof Uint8Array) {\n                  _context.next = 4;\n                  break;\n                }\n\n                errMsg = 'datastore key does not have a valid format';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n\n              case 4:\n                if (val instanceof Uint8Array) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _errMsg = 'received value is not a Uint8Array';\n                log.error(_errMsg);\n                throw errcode(new Error(_errMsg), 'ERR_INVALID_VALUE_RECEIVED');\n\n              case 8:\n                stringifiedTopic = keyToTopic(key);\n                log(\"publish value for topic \".concat(stringifiedTopic)); // Publish record to pubsub\n\n                _context.next = 12;\n                return this._pubsub.publish(stringifiedTopic, val);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function put(_x, _x2) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n    /**\n     * Try to subscribe a topic with Pubsub and returns the local value if available.\n     *\n     * @param {Uint8Array} key - identifier of the value to be subscribed.\n     */\n    // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key) {\n        var errMsg, stringifiedTopic, subscriptions, _errMsg2;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (key instanceof Uint8Array) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                errMsg = 'datastore key does not have a valid format';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n\n              case 4:\n                stringifiedTopic = keyToTopic(key);\n                _context2.next = 7;\n                return this._pubsub.getTopics();\n\n              case 7:\n                subscriptions = _context2.sent;\n\n                if (!(subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this._getLocal(key));\n\n              case 10:\n                _context2.prev = 10;\n\n                this._pubsub.on(stringifiedTopic, this._onMessage);\n\n                _context2.next = 14;\n                return this._pubsub.subscribe(stringifiedTopic);\n\n              case 14:\n                _context2.next = 21;\n                break;\n\n              case 16:\n                _context2.prev = 16;\n                _context2.t0 = _context2[\"catch\"](10);\n                _errMsg2 = \"cannot subscribe topic \".concat(stringifiedTopic);\n                log.error(_errMsg2);\n                throw errcode(new Error(_errMsg2), 'ERR_SUBSCRIBING_TOPIC');\n\n              case 21:\n                log(\"subscribed values for key \".concat(stringifiedTopic));\n                return _context2.abrupt(\"return\", this._getLocal(key));\n\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[10, 16]]);\n      }));\n\n      function get(_x3) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * Unsubscribe topic.\n     *\n     * @param {Uint8Array} key - identifier of the value to unsubscribe.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(key) {\n      var stringifiedTopic = keyToTopic(key);\n\n      this._pubsub.removeListener(stringifiedTopic, this._onMessage);\n\n      return this._pubsub.unsubscribe(stringifiedTopic);\n    }\n    /**\n     * Get record from local datastore\n     *\n     * @private\n     * @param {Uint8Array} key\n     */\n\n  }, {\n    key: \"_getLocal\",\n    value: function () {\n      var _getLocal2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key) {\n        var routingKey, dsVal, _errMsg3, errMsg, _errMsg4;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // encode key - base32(/ipns/{cid})\n                routingKey = new Key('/' + encodeBase32(key), false);\n                _context3.prev = 1;\n                _context3.next = 4;\n                return this._datastore.get(routingKey);\n\n              case 4:\n                dsVal = _context3.sent;\n                _context3.next = 16;\n                break;\n\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](1);\n\n                if (!(_context3.t0.code !== 'ERR_NOT_FOUND')) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                _errMsg3 = \"unexpected error getting the ipns record for \".concat(routingKey.toString());\n                log.error(_errMsg3);\n                throw errcode(new Error(_errMsg3), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n\n              case 13:\n                errMsg = \"local record requested was not found for \".concat(routingKey.toString());\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_NOT_FOUND');\n\n              case 16:\n                if (dsVal instanceof Uint8Array) {\n                  _context3.next = 20;\n                  break;\n                }\n\n                _errMsg4 = 'found record that we couldn\\'t convert to a value';\n                log.error(_errMsg4);\n                throw errcode(new Error(_errMsg4), 'ERR_INVALID_RECORD_RECEIVED');\n\n              case 20:\n                return _context3.abrupt(\"return\", dsVal);\n\n              case 21:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 7]]);\n      }));\n\n      function _getLocal(_x4) {\n        return _getLocal2.apply(this, arguments);\n      }\n\n      return _getLocal;\n    }()\n    /**\n     * handles pubsub subscription messages\n     *\n     * @param {PubSubMessage} msg\n     */\n\n  }, {\n    key: \"_onMessage\",\n    value: function () {\n      var _onMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(msg) {\n        var data, from, topicIDs, key, res;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                data = msg.data, from = msg.from, topicIDs = msg.topicIDs;\n                _context4.prev = 1;\n                key = topicToKey(topicIDs[0]);\n                _context4.next = 9;\n                break;\n\n              case 5:\n                _context4.prev = 5;\n                _context4.t0 = _context4[\"catch\"](1);\n                log.error(_context4.t0);\n                return _context4.abrupt(\"return\");\n\n              case 9:\n                log(\"message received for topic \".concat(topicIDs[0])); // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n\n                if (!(from === this._peerId.toB58String())) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                log('message discarded as it is from the same peer');\n                return _context4.abrupt(\"return\");\n\n              case 13:\n                if (!this._handleSubscriptionKeyFn) {\n                  _context4.next = 25;\n                  break;\n                }\n\n                _context4.prev = 14;\n                _context4.next = 17;\n                return this._handleSubscriptionKeyFn(key);\n\n              case 17:\n                res = _context4.sent;\n                _context4.next = 24;\n                break;\n\n              case 20:\n                _context4.prev = 20;\n                _context4.t1 = _context4[\"catch\"](14);\n                log.error('message discarded by the subscriptionKeyFn');\n                return _context4.abrupt(\"return\");\n\n              case 24:\n                key = res;\n\n              case 25:\n                _context4.prev = 25;\n                _context4.next = 28;\n                return this._storeIfSubscriptionIsBetter(key, data);\n\n              case 28:\n                _context4.next = 33;\n                break;\n\n              case 30:\n                _context4.prev = 30;\n                _context4.t2 = _context4[\"catch\"](25);\n                log.error(_context4.t2);\n\n              case 33:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[1, 5], [14, 20], [25, 30]]);\n      }));\n\n      function _onMessage(_x5) {\n        return _onMessage2.apply(this, arguments);\n      }\n\n      return _onMessage;\n    }()\n    /**\n     * Store the received record if it is better than the current stored\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} data\n     */\n\n  }, {\n    key: \"_storeIfSubscriptionIsBetter\",\n    value: function () {\n      var _storeIfSubscriptionIsBetter2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key, data) {\n        var isBetter;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                isBetter = false;\n                _context5.prev = 1;\n                _context5.next = 4;\n                return this._isBetter(key, data);\n\n              case 4:\n                isBetter = _context5.sent;\n                _context5.next = 11;\n                break;\n\n              case 7:\n                _context5.prev = 7;\n                _context5.t0 = _context5[\"catch\"](1);\n\n                if (!(_context5.t0.code !== 'ERR_NOT_VALID_RECORD')) {\n                  _context5.next = 11;\n                  break;\n                }\n\n                throw _context5.t0;\n\n              case 11:\n                if (!isBetter) {\n                  _context5.next = 14;\n                  break;\n                }\n\n                _context5.next = 14;\n                return this._storeRecord(key, data);\n\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[1, 7]]);\n      }));\n\n      function _storeIfSubscriptionIsBetter(_x6, _x7) {\n        return _storeIfSubscriptionIsBetter2.apply(this, arguments);\n      }\n\n      return _storeIfSubscriptionIsBetter;\n    }()\n    /**\n     * Validate record according to the received validation function\n     *\n     * @param {Uint8Array} value\n     * @param {Uint8Array} peerId\n     */\n\n  }, {\n    key: \"_validateRecord\",\n    value: function () {\n      var _validateRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(value, peerId) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this._validator.validate(value, peerId));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _validateRecord(_x8, _x9) {\n        return _validateRecord2.apply(this, arguments);\n      }\n\n      return _validateRecord;\n    }()\n    /**\n     * Select the best record according to the received select function\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array[]} records\n     */\n\n  }, {\n    key: \"_selectRecord\",\n    value: function () {\n      var _selectRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(key, records) {\n        var res;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this._validator.select(key, records);\n\n              case 2:\n                res = _context7.sent;\n                return _context7.abrupt(\"return\", res === 0);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function _selectRecord(_x10, _x11) {\n        return _selectRecord2.apply(this, arguments);\n      }\n\n      return _selectRecord;\n    }()\n    /**\n     * Verify if the record received through pubsub is valid and better than the one currently stored\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} val\n     */\n\n  }, {\n    key: \"_isBetter\",\n    value: function () {\n      var _isBetter2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(key, val) {\n        var errMsg, dsKey, currentRecord;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                _context8.next = 3;\n                return this._validateRecord(val, key);\n\n              case 3:\n                _context8.next = 10;\n                break;\n\n              case 5:\n                _context8.prev = 5;\n                _context8.t0 = _context8[\"catch\"](0);\n                // If not valid, it is not better than the one currently available\n                errMsg = 'record received through pubsub is not valid';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD');\n\n              case 10:\n                // Get Local record\n                dsKey = new Key(key);\n                _context8.prev = 11;\n                _context8.next = 14;\n                return this._getLocal(dsKey.uint8Array());\n\n              case 14:\n                currentRecord = _context8.sent;\n                _context8.next = 20;\n                break;\n\n              case 17:\n                _context8.prev = 17;\n                _context8.t1 = _context8[\"catch\"](11);\n                return _context8.abrupt(\"return\", true);\n\n              case 20:\n                if (!uint8ArrayEquals(currentRecord, val)) {\n                  _context8.next = 22;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", false);\n\n              case 22:\n                return _context8.abrupt(\"return\", this._selectRecord(key, [currentRecord, val]));\n\n              case 23:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 5], [11, 17]]);\n      }));\n\n      function _isBetter(_x12, _x13) {\n        return _isBetter2.apply(this, arguments);\n      }\n\n      return _isBetter;\n    }()\n    /**\n     * add record to datastore\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} data\n     */\n\n  }, {\n    key: \"_storeRecord\",\n    value: function () {\n      var _storeRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(key, data) {\n        var routingKey;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                // encode key - base32(/ipns/{cid})\n                routingKey = new Key('/' + encodeBase32(key), false);\n                _context9.next = 3;\n                return this._datastore.put(routingKey, data);\n\n              case 3:\n                log(\"record for \".concat(keyToTopic(key), \" was stored in the datastore\"));\n\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function _storeRecord(_x14, _x15) {\n        return _storeRecord2.apply(this, arguments);\n      }\n\n      return _storeRecord;\n    }()\n  }]);\n\n  return DatastorePubsub;\n}(Adapter);\n\nexports = module.exports = DatastorePubsub;","map":{"version":3,"names":["require","Key","Adapter","encodeBase32","keyToTopic","topicToKey","uint8ArrayEquals","equals","errcode","debug","log","Object","assign","error","DatastorePubsub","pubsub","datastore","peerId","validator","subscriptionKeyFn","TypeError","validate","select","_pubsub","_datastore","_peerId","_validator","_handleSubscriptionKeyFn","_onMessage","bind","key","val","Uint8Array","errMsg","Error","stringifiedTopic","publish","getTopics","subscriptions","Array","isArray","indexOf","_getLocal","on","subscribe","removeListener","unsubscribe","routingKey","get","dsVal","code","toString","msg","data","from","topicIDs","toB58String","res","_storeIfSubscriptionIsBetter","isBetter","_isBetter","_storeRecord","value","records","_validateRecord","dsKey","uint8Array","currentRecord","_selectRecord","put","exports","module"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/datastore-pubsub/src/index.js"],"sourcesContent":["'use strict'\n\nconst { Key, Adapter } = require('interface-datastore')\nconst { encodeBase32, keyToTopic, topicToKey } = require('./utils')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('datastore-pubsub:publisher'), {\n  error: debug('datastore-pubsub:publisher:error')\n})\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types').Validator} Validator\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('libp2p-interfaces/src/pubsub').InMessage} PubSubMessage\n */\n\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\nclass DatastorePubsub extends Adapter {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('libp2p-interfaces/src/pubsub')} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {Validator} validator - validator functions\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  constructor (pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    super()\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    this._pubsub = pubsub\n    this._datastore = datastore\n    this._peerId = peerId\n    this._validator = validator\n    this._handleSubscriptionKeyFn = subscriptionKeyFn\n\n    // Bind _onMessage function, which is called by pubsub.\n    this._onMessage = this._onMessage.bind(this)\n  }\n\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async put (key, val) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!(val instanceof Uint8Array)) {\n      const errMsg = 'received value is not a Uint8Array'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n\n    log(`publish value for topic ${stringifiedTopic}`)\n\n    // Publish record to pubsub\n    await this._pubsub.publish(stringifiedTopic, val)\n  }\n\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async get (key) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n    const subscriptions = await this._pubsub.getTopics()\n\n    // If already subscribed, just try to get it\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key)\n    }\n\n    // subscribe\n    try {\n      this._pubsub.on(stringifiedTopic, this._onMessage)\n      await this._pubsub.subscribe(stringifiedTopic)\n    } catch (err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC')\n    }\n    log(`subscribed values for key ${stringifiedTopic}`)\n\n    return this._getLocal(key)\n  }\n\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n  unsubscribe (key) {\n    const stringifiedTopic = keyToTopic(key)\n\n    this._pubsub.removeListener(stringifiedTopic, this._onMessage)\n    return this._pubsub.unsubscribe(stringifiedTopic)\n  }\n\n  /**\n   * Get record from local datastore\n   *\n   * @private\n   * @param {Uint8Array} key\n   */\n  async _getLocal (key) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n    let dsVal\n\n    try {\n      dsVal = await this._datastore.get(routingKey)\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`\n\n        log.error(errMsg)\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n      }\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND')\n    }\n\n    if (!(dsVal instanceof Uint8Array)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    return dsVal\n  }\n\n  /**\n   * handles pubsub subscription messages\n   *\n   * @param {PubSubMessage} msg\n   */\n  async _onMessage (msg) {\n    const { data, from, topicIDs } = msg\n    let key\n    try {\n      key = topicToKey(topicIDs[0])\n    } catch (err) {\n      log.error(err)\n      return\n    }\n\n    log(`message received for topic ${topicIDs[0]}`)\n\n    // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n    if (from === this._peerId.toB58String()) {\n      log('message discarded as it is from the same peer')\n      return\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key)\n      } catch (err) {\n        log.error('message discarded by the subscriptionKeyFn')\n        return\n      }\n\n      key = res\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Store the received record if it is better than the current stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n  async _storeIfSubscriptionIsBetter (key, data) {\n    let isBetter = false\n\n    try {\n      isBetter = await this._isBetter(key, data)\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(key, data)\n    }\n  }\n\n  /**\n   * Validate record according to the received validation function\n   *\n   * @param {Uint8Array} value\n   * @param {Uint8Array} peerId\n   */\n  async _validateRecord (value, peerId) { // eslint-disable-line require-await\n    return this._validator.validate(value, peerId)\n  }\n\n  /**\n   * Select the best record according to the received select function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array[]} records\n   */\n  async _selectRecord (key, records) {\n    const res = await this._validator.select(key, records)\n\n    // If the selected was the first (0), it should be stored (true)\n    return res === 0\n  }\n\n  /**\n   * Verify if the record received through pubsub is valid and better than the one currently stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} val\n   */\n  async _isBetter (key, val) {\n    try {\n      await this._validateRecord(val, key)\n    } catch (err) {\n      // If not valid, it is not better than the one currently available\n      const errMsg = 'record received through pubsub is not valid'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD')\n    }\n\n    // Get Local record\n    const dsKey = new Key(key)\n    let currentRecord\n\n    try {\n      currentRecord = await this._getLocal(dsKey.uint8Array())\n    } catch (err) {\n      // if the old one is invalid, the new one is *always* better\n      return true\n    }\n\n    // if the same record, do not need to store\n    if (uint8ArrayEquals(currentRecord, val)) {\n      return false\n    }\n\n    // verify if the received record should replace the current one\n    return this._selectRecord(key, [currentRecord, val])\n  }\n\n  /**\n   * add record to datastore\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n  async _storeRecord (key, data) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n\n    await this._datastore.put(routingKey, data)\n    log(`record for ${keyToTopic(key)} was stored in the datastore`)\n  }\n}\n\nexports = module.exports = DatastorePubsub\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAEA,eAAyBA,OAAO,CAAC,qBAAD,CAAhC;AAAA,IAAQC,GAAR,YAAQA,GAAR;AAAA,IAAaC,OAAb,YAAaA,OAAb;;AACA,gBAAiDF,OAAO,CAAC,SAAD,CAAxD;AAAA,IAAQG,YAAR,aAAQA,YAAR;AAAA,IAAsBC,UAAtB,aAAsBA,UAAtB;AAAA,IAAkCC,UAAlC,aAAkCA,UAAlC;;AACA,gBAAqCL,OAAO,CAAC,oBAAD,CAA5C;AAAA,IAAgBM,gBAAhB,aAAQC,MAAR;;AAEA,IAAMC,OAAO,GAAGR,OAAO,CAAC,UAAD,CAAvB;;AACA,IAAMS,KAAK,GAAGT,OAAO,CAAC,OAAD,CAArB;;AACA,IAAMU,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcH,KAAK,CAAC,4BAAD,CAAnB,EAAmD;EAC7DI,KAAK,EAAEJ,KAAK,CAAC,kCAAD;AADiD,CAAnD,CAAZ;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;IACMK,e;;;;;EACJ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,yBAAaC,MAAb,EAAqBC,SAArB,EAAgCC,MAAhC,EAAwCC,SAAxC,EAAmDC,iBAAnD,EAAsE;IAAA;;IAAA;;IACpE;;IAEA,IAAI,CAACD,SAAL,EAAgB;MACd,MAAMV,OAAO,CAAC,IAAIY,SAAJ,CAAc,mBAAd,CAAD,EAAqC,wBAArC,CAAb;IACD;;IAED,IAAI,OAAOF,SAAS,CAACG,QAAjB,KAA8B,UAAlC,EAA8C;MAC5C,MAAMb,OAAO,CAAC,IAAIY,SAAJ,CAAc,2BAAd,CAAD,EAA6C,wBAA7C,CAAb;IACD;;IAED,IAAI,OAAOF,SAAS,CAACI,MAAjB,KAA4B,UAAhC,EAA4C;MAC1C,MAAMd,OAAO,CAAC,IAAIY,SAAJ,CAAc,yBAAd,CAAD,EAA2C,wBAA3C,CAAb;IACD;;IAED,IAAID,iBAAiB,IAAI,OAAOA,iBAAP,KAA6B,UAAtD,EAAkE;MAChE,MAAMX,OAAO,CAAC,IAAIY,SAAJ,CAAc,oCAAd,CAAD,EAAsD,wBAAtD,CAAb;IACD;;IAED,MAAKG,OAAL,GAAeR,MAAf;IACA,MAAKS,UAAL,GAAkBR,SAAlB;IACA,MAAKS,OAAL,GAAeR,MAAf;IACA,MAAKS,UAAL,GAAkBR,SAAlB;IACA,MAAKS,wBAAL,GAAgCR,iBAAhC,CAvBoE,CAyBpE;;IACA,MAAKS,UAAL,GAAkB,MAAKA,UAAL,CAAgBC,IAAhB,+BAAlB;IA1BoE;EA2BrE;EAED;AACF;AACA;AACA;AACA;AACA;EACE;;;;;;4EACA,iBAAWC,GAAX,EAAgBC,GAAhB;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAA,IACQD,GAAG,YAAYE,UADvB;kBAAA;kBAAA;gBAAA;;gBAEUC,MAFV,GAEmB,4CAFnB;gBAIIvB,GAAG,CAACG,KAAJ,CAAUoB,MAAV;gBAJJ,MAKUzB,OAAO,CAAC,IAAI0B,KAAJ,CAAUD,MAAV,CAAD,EAAoB,2BAApB,CALjB;;cAAA;gBAAA,IAQQF,GAAG,YAAYC,UARvB;kBAAA;kBAAA;gBAAA;;gBASUC,OATV,GASmB,oCATnB;gBAWIvB,GAAG,CAACG,KAAJ,CAAUoB,OAAV;gBAXJ,MAYUzB,OAAO,CAAC,IAAI0B,KAAJ,CAAUD,OAAV,CAAD,EAAoB,4BAApB,CAZjB;;cAAA;gBAeQE,gBAfR,GAe2B/B,UAAU,CAAC0B,GAAD,CAfrC;gBAiBEpB,GAAG,mCAA4ByB,gBAA5B,EAAH,CAjBF,CAmBE;;gBAnBF;gBAAA,OAoBQ,KAAKZ,OAAL,CAAaa,OAAb,CAAqBD,gBAArB,EAAuCJ,GAAvC,CApBR;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAuBA;AACF;AACA;AACA;AACA;IACE;;;;;4EACA,kBAAWD,GAAX;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAA,IACQA,GAAG,YAAYE,UADvB;kBAAA;kBAAA;gBAAA;;gBAEUC,MAFV,GAEmB,4CAFnB;gBAIIvB,GAAG,CAACG,KAAJ,CAAUoB,MAAV;gBAJJ,MAKUzB,OAAO,CAAC,IAAI0B,KAAJ,CAAUD,MAAV,CAAD,EAAoB,2BAApB,CALjB;;cAAA;gBAQQE,gBARR,GAQ2B/B,UAAU,CAAC0B,GAAD,CARrC;gBAAA;gBAAA,OAS8B,KAAKP,OAAL,CAAac,SAAb,EAT9B;;cAAA;gBASQC,aATR;;gBAAA,MAYMA,aAAa,IAAIC,KAAK,CAACC,OAAN,CAAcF,aAAd,CAAjB,IAAiDA,aAAa,CAACG,OAAd,CAAsBN,gBAAtB,IAA0C,CAAC,CAZlG;kBAAA;kBAAA;gBAAA;;gBAAA,kCAaW,KAAKO,SAAL,CAAeZ,GAAf,CAbX;;cAAA;gBAAA;;gBAkBI,KAAKP,OAAL,CAAaoB,EAAb,CAAgBR,gBAAhB,EAAkC,KAAKP,UAAvC;;gBAlBJ;gBAAA,OAmBU,KAAKL,OAAL,CAAaqB,SAAb,CAAuBT,gBAAvB,CAnBV;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBAqBUF,QArBV,oCAqB6CE,gBArB7C;gBAuBIzB,GAAG,CAACG,KAAJ,CAAUoB,QAAV;gBAvBJ,MAwBUzB,OAAO,CAAC,IAAI0B,KAAJ,CAAUD,QAAV,CAAD,EAAoB,uBAApB,CAxBjB;;cAAA;gBA0BEvB,GAAG,qCAA8ByB,gBAA9B,EAAH;gBA1BF,kCA4BS,KAAKO,SAAL,CAAeZ,GAAf,CA5BT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IA+BA;AACF;AACA;AACA;AACA;AACA;;;;WACE,qBAAaA,GAAb,EAAkB;MAChB,IAAMK,gBAAgB,GAAG/B,UAAU,CAAC0B,GAAD,CAAnC;;MAEA,KAAKP,OAAL,CAAasB,cAAb,CAA4BV,gBAA5B,EAA8C,KAAKP,UAAnD;;MACA,OAAO,KAAKL,OAAL,CAAauB,WAAb,CAAyBX,gBAAzB,CAAP;IACD;IAED;AACF;AACA;AACA;AACA;AACA;;;;;kFACE,kBAAiBL,GAAjB;QAAA;;QAAA;UAAA;YAAA;cAAA;gBACE;gBACMiB,UAFR,GAEqB,IAAI9C,GAAJ,CAAQ,MAAME,YAAY,CAAC2B,GAAD,CAA1B,EAAiC,KAAjC,CAFrB;gBAAA;gBAAA;gBAAA,OAMkB,KAAKN,UAAL,CAAgBwB,GAAhB,CAAoBD,UAApB,CANlB;;cAAA;gBAMIE,KANJ;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;gBAAA,MAQQ,aAAIC,IAAJ,KAAa,eARrB;kBAAA;kBAAA;gBAAA;;gBASYjB,QATZ,0DASqEc,UAAU,CAACI,QAAX,EATrE;gBAWMzC,GAAG,CAACG,KAAJ,CAAUoB,QAAV;gBAXN,MAYYzB,OAAO,CAAC,IAAI0B,KAAJ,CAAUD,QAAV,CAAD,EAAoB,qCAApB,CAZnB;;cAAA;gBAcUA,MAdV,sDAc+Dc,UAAU,CAACI,QAAX,EAd/D;gBAgBIzC,GAAG,CAACG,KAAJ,CAAUoB,MAAV;gBAhBJ,MAiBUzB,OAAO,CAAC,IAAI0B,KAAJ,CAAUD,MAAV,CAAD,EAAoB,eAApB,CAjBjB;;cAAA;gBAAA,IAoBQgB,KAAK,YAAYjB,UApBzB;kBAAA;kBAAA;gBAAA;;gBAqBUC,QArBV,GAqBmB,mDArBnB;gBAuBIvB,GAAG,CAACG,KAAJ,CAAUoB,QAAV;gBAvBJ,MAwBUzB,OAAO,CAAC,IAAI0B,KAAJ,CAAUD,QAAV,CAAD,EAAoB,6BAApB,CAxBjB;;cAAA;gBAAA,kCA2BSgB,KA3BT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IA8BA;AACF;AACA;AACA;AACA;;;;;mFACE,kBAAkBG,GAAlB;QAAA;QAAA;UAAA;YAAA;cAAA;gBACUC,IADV,GACmCD,GADnC,CACUC,IADV,EACgBC,IADhB,GACmCF,GADnC,CACgBE,IADhB,EACsBC,QADtB,GACmCH,GADnC,CACsBG,QADtB;gBAAA;gBAIIzB,GAAG,GAAGzB,UAAU,CAACkD,QAAQ,CAAC,CAAD,CAAT,CAAhB;gBAJJ;gBAAA;;cAAA;gBAAA;gBAAA;gBAMI7C,GAAG,CAACG,KAAJ;gBANJ;;cAAA;gBAUEH,GAAG,sCAA+B6C,QAAQ,CAAC,CAAD,CAAvC,EAAH,CAVF,CAYE;;gBAZF,MAaMD,IAAI,KAAK,KAAK7B,OAAL,CAAa+B,WAAb,EAbf;kBAAA;kBAAA;gBAAA;;gBAcI9C,GAAG,CAAC,+CAAD,CAAH;gBAdJ;;cAAA;gBAAA,KAkBM,KAAKiB,wBAlBX;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA;gBAAA,OAsBkB,KAAKA,wBAAL,CAA8BG,GAA9B,CAtBlB;;cAAA;gBAsBM2B,GAtBN;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBAwBM/C,GAAG,CAACG,KAAJ,CAAU,4CAAV;gBAxBN;;cAAA;gBA4BIiB,GAAG,GAAG2B,GAAN;;cA5BJ;gBAAA;gBAAA;gBAAA,OAgCU,KAAKC,4BAAL,CAAkC5B,GAAlC,EAAuCuB,IAAvC,CAhCV;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBAkCI3C,GAAG,CAACG,KAAJ;;cAlCJ;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAsCA;AACF;AACA;AACA;AACA;AACA;;;;;qGACE,kBAAoCiB,GAApC,EAAyCuB,IAAzC;QAAA;QAAA;UAAA;YAAA;cAAA;gBACMM,QADN,GACiB,KADjB;gBAAA;gBAAA;gBAAA,OAIqB,KAAKC,SAAL,CAAe9B,GAAf,EAAoBuB,IAApB,CAJrB;;cAAA;gBAIIM,QAJJ;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;gBAAA,MAMQ,aAAIT,IAAJ,KAAa,sBANrB;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAAA,KAWMS,QAXN;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAYU,KAAKE,YAAL,CAAkB/B,GAAlB,EAAuBuB,IAAvB,CAZV;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAgBA;AACF;AACA;AACA;AACA;AACA;;;;;wFACE,kBAAuBS,KAAvB,EAA8B7C,MAA9B;QAAA;UAAA;YAAA;cAAA;gBAAA,kCACS,KAAKS,UAAL,CAAgBL,QAAhB,CAAyByC,KAAzB,EAAgC7C,MAAhC,CADT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAIA;AACF;AACA;AACA;AACA;AACA;;;;;sFACE,kBAAqBa,GAArB,EAA0BiC,OAA1B;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACoB,KAAKrC,UAAL,CAAgBJ,MAAhB,CAAuBQ,GAAvB,EAA4BiC,OAA5B,CADpB;;cAAA;gBACQN,GADR;gBAAA,kCAISA,GAAG,KAAK,CAJjB;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAOA;AACF;AACA;AACA;AACA;AACA;;;;;kFACE,kBAAiB3B,GAAjB,EAAsBC,GAAtB;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA;gBAAA,OAEU,KAAKiC,eAAL,CAAqBjC,GAArB,EAA0BD,GAA1B,CAFV;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBAII;gBACMG,MALV,GAKmB,6CALnB;gBAOIvB,GAAG,CAACG,KAAJ,CAAUoB,MAAV;gBAPJ,MAQUzB,OAAO,CAAC,IAAI0B,KAAJ,CAAUD,MAAV,CAAD,EAAoB,sBAApB,CARjB;;cAAA;gBAWE;gBACMgC,KAZR,GAYgB,IAAIhE,GAAJ,CAAQ6B,GAAR,CAZhB;gBAAA;gBAAA;gBAAA,OAgB0B,KAAKY,SAAL,CAAeuB,KAAK,CAACC,UAAN,EAAf,CAhB1B;;cAAA;gBAgBIC,aAhBJ;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBAAA,kCAmBW,IAnBX;;cAAA;gBAAA,KAuBM7D,gBAAgB,CAAC6D,aAAD,EAAgBpC,GAAhB,CAvBtB;kBAAA;kBAAA;gBAAA;;gBAAA,kCAwBW,KAxBX;;cAAA;gBAAA,kCA4BS,KAAKqC,aAAL,CAAmBtC,GAAnB,EAAwB,CAACqC,aAAD,EAAgBpC,GAAhB,CAAxB,CA5BT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IA+BA;AACF;AACA;AACA;AACA;AACA;;;;;qFACE,kBAAoBD,GAApB,EAAyBuB,IAAzB;QAAA;QAAA;UAAA;YAAA;cAAA;gBACE;gBACMN,UAFR,GAEqB,IAAI9C,GAAJ,CAAQ,MAAME,YAAY,CAAC2B,GAAD,CAA1B,EAAiC,KAAjC,CAFrB;gBAAA;gBAAA,OAIQ,KAAKN,UAAL,CAAgB6C,GAAhB,CAAoBtB,UAApB,EAAgCM,IAAhC,CAJR;;cAAA;gBAKE3C,GAAG,sBAAeN,UAAU,CAAC0B,GAAD,CAAzB,kCAAH;;cALF;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;EA/R4B5B,O;;AAwS9BoE,OAAO,GAAGC,MAAM,CAACD,OAAP,GAAiBxD,eAA3B"},"metadata":{},"sourceType":"script"}