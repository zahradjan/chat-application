{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst errcode = require('err-code');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst MulticodecTopology = require('../topology/multicodec-topology');\n\nconst {\n  codes\n} = require('./errors');\n\nconst {\n  RPC\n} = require('./message/rpc');\n\nconst PeerStreams = require('./peer-streams');\n\nconst {\n  SignaturePolicy\n} = require('./signature-policy');\n\nconst utils = require('./utils');\n\nconst {\n  signMessage,\n  verifySignature\n} = require('./message/sign');\n/**\n * @typedef {any} Libp2p\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('bl')} BufferList\n * @typedef {import('../stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('../connection/connection')} Connection\n * @typedef {import('./signature-policy').SignaturePolicyType} SignaturePolicyType\n * @typedef {import('./message/rpc').IRPC} IRPC\n * @typedef {import('./message/rpc').RPC.SubOpts} RPCSubOpts\n * @typedef {import('./message/rpc').RPC.Message} RPCMessage\n */\n\n/**\n * @typedef {Object} InMessage\n * @property {string} [from]\n * @property {string} receivedFrom\n * @property {string[]} topicIDs\n * @property {Uint8Array} [seqno]\n * @property {Uint8Array} data\n * @property {Uint8Array} [signature]\n * @property {Uint8Array} [key]\n *\n * @typedef {Object} PubsubProperties\n * @property {string} debugName - log namespace\n * @property {Array<string>|string} multicodecs - protocol identificers to connect\n * @property {Libp2p} libp2p\n *\n * @typedef {Object} PubsubOptions\n * @property {SignaturePolicyType} [globalSignaturePolicy = SignaturePolicy.StrictSign] - defines how signatures should be handled\n * @property {boolean} [canRelayMessage = false] - if can relay messages not subscribed\n * @property {boolean} [emitSelf = false] - if publish should emit to self, if subscribed\n * @property {number} [messageProcessingConcurrency = 10] - handle this many incoming pubsub messages concurrently\n */\n\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n * and specifies the API that pubsub routers should have.\n */\n\n\nclass PubsubBaseProtocol extends EventEmitter {\n  /**\n   * @param {PubsubProperties & PubsubOptions} props\n   * @abstract\n   */\n  constructor(_ref) {\n    let {\n      debugName,\n      multicodecs,\n      libp2p,\n      globalSignaturePolicy = SignaturePolicy.StrictSign,\n      canRelayMessage = false,\n      emitSelf = false,\n      messageProcessingConcurrency = 10\n    } = _ref;\n\n    if (typeof debugName !== 'string') {\n      throw new Error('a debugname `string` is required');\n    }\n\n    if (!multicodecs) {\n      throw new Error('multicodecs are required');\n    }\n\n    if (!libp2p) {\n      throw new Error('libp2p is required');\n    }\n\n    super();\n    this.log = Object.assign(debug(debugName), {\n      err: debug(`${debugName}:error`)\n    });\n    /**\n     * @type {Array<string>}\n     */\n\n    this.multicodecs = utils.ensureArray(multicodecs);\n    this._libp2p = libp2p;\n    this.registrar = libp2p.registrar;\n    /**\n     * @type {PeerId}\n     */\n\n    this.peerId = libp2p.peerId;\n    this.started = false;\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this.topics = new Map();\n    /**\n     * List of our subscriptions\n     *\n     * @type {Set<string>}\n     */\n\n    this.subscriptions = new Set();\n    /**\n     * Map of peer streams\n     *\n     * @type {Map<string, import('./peer-streams')>}\n     */\n\n    this.peers = new Map(); // validate signature policy\n\n    if (!SignaturePolicy[globalSignaturePolicy]) {\n      throw errcode(new Error('Invalid global signature policy'), codes.ERR_INVALID_SIGNATURE_POLICY);\n    }\n    /**\n     * The signature policy to follow by default\n     *\n     * @type {string}\n     */\n\n\n    this.globalSignaturePolicy = globalSignaturePolicy;\n    /**\n     * If router can relay received messages, even if not subscribed\n     *\n     * @type {boolean}\n     */\n\n    this.canRelayMessage = canRelayMessage;\n    /**\n     * if publish should emit to self, if subscribed\n     *\n     * @type {boolean}\n     */\n\n    this.emitSelf = emitSelf;\n    /**\n     * Topic validator function\n     *\n     * @typedef {function(string, InMessage): Promise<void>} validator\n     */\n\n    /**\n     * Topic validator map\n     *\n     * Keyed by topic\n     * Topic validators are functions with the following input:\n     *\n     * @type {Map<string, validator>}\n     */\n\n    this.topicValidators = new Map();\n    /**\n     * @type {Queue}\n     */\n\n    this.queue = new Queue({\n      concurrency: messageProcessingConcurrency\n    });\n    this._registrarId = undefined;\n    this._onIncomingStream = this._onIncomingStream.bind(this);\n    this._onPeerConnected = this._onPeerConnected.bind(this);\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);\n  } // LIFECYCLE METHODS\n\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   *\n   * @returns {void}\n   */\n\n\n  start() {\n    if (this.started) {\n      return;\n    }\n\n    this.log('starting'); // Incoming streams\n    // Called after a peer dials us\n\n    this.registrar.handle(this.multicodecs, this._onIncomingStream); // register protocol with topology\n    // Topology callbacks called on connection manager changes\n\n    const topology = new MulticodecTopology({\n      multicodecs: this.multicodecs,\n      handlers: {\n        onConnect: this._onPeerConnected,\n        onDisconnect: this._onPeerDisconnected\n      }\n    });\n    this._registrarId = this.registrar.register(topology);\n    this.log('started');\n    this.started = true;\n  }\n  /**\n   * Unregister the pubsub protocol and the streams with other peers will be closed.\n   *\n   * @returns {void}\n   */\n\n\n  stop() {\n    if (!this.started) {\n      return;\n    } // unregister protocol and handlers\n\n\n    this.registrar.unregister(this._registrarId);\n    this.log('stopping');\n    this.peers.forEach(peerStreams => peerStreams.close());\n    this.peers = new Map();\n    this.subscriptions = new Set();\n    this.started = false;\n    this.log('stopped');\n  }\n  /**\n   * On an inbound stream opened.\n   *\n   * @protected\n   * @param {Object} props\n   * @param {string} props.protocol\n   * @param {MuxedStream} props.stream\n   * @param {Connection} props.connection - connection\n   */\n\n\n  _onIncomingStream(_ref2) {\n    let {\n      protocol,\n      stream,\n      connection\n    } = _ref2;\n    const peerId = connection.remotePeer;\n    const idB58Str = peerId.toB58String();\n\n    const peer = this._addPeer(peerId, protocol);\n\n    const inboundStream = peer.attachInboundStream(stream);\n\n    this._processMessages(idB58Str, inboundStream, peer);\n  }\n  /**\n   * Registrar notifies an established connection with pubsub protocol.\n   *\n   * @protected\n   * @param {PeerId} peerId - remote peer-id\n   * @param {Connection} conn - connection to the peer\n   */\n\n\n  async _onPeerConnected(peerId, conn) {\n    const idB58Str = peerId.toB58String();\n    this.log('connected', idB58Str);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await conn.newStream(this.multicodecs);\n\n      const peer = this._addPeer(peerId, protocol);\n\n      await peer.attachOutboundStream(stream);\n    } catch (err) {\n      this.log.err(err);\n    } // Immediately send my own subscriptions to the newly established conn\n\n\n    this._sendSubscriptions(idB58Str, Array.from(this.subscriptions), true);\n  }\n  /**\n   * Registrar notifies a closing connection with pubsub protocol.\n   *\n   * @protected\n   * @param {PeerId} peerId - peerId\n   * @param {Error} [err] - error for connection end\n   */\n\n\n  _onPeerDisconnected(peerId, err) {\n    const idB58Str = peerId.toB58String();\n    this.log('connection ended', idB58Str, err ? err.message : '');\n\n    this._removePeer(peerId);\n  }\n  /**\n   * Notifies the router that a peer has been connected\n   *\n   * @protected\n   * @param {PeerId} peerId\n   * @param {string} protocol\n   * @returns {PeerStreams}\n   */\n\n\n  _addPeer(peerId, protocol) {\n    const id = peerId.toB58String();\n    const existing = this.peers.get(id); // If peer streams already exists, do nothing\n\n    if (existing) {\n      return existing;\n    } // else create a new peer streams\n\n\n    this.log('new peer', id);\n    const peerStreams = new PeerStreams({\n      id: peerId,\n      protocol\n    });\n    this.peers.set(id, peerStreams);\n    peerStreams.once('close', () => this._removePeer(peerId));\n    return peerStreams;\n  }\n  /**\n   * Notifies the router that a peer has been disconnected.\n   *\n   * @protected\n   * @param {PeerId} peerId\n   * @returns {PeerStreams | undefined}\n   */\n\n\n  _removePeer(peerId) {\n    if (!peerId) return;\n    const id = peerId.toB58String();\n    const peerStreams = this.peers.get(id);\n    if (!peerStreams) return; // close peer streams\n\n    peerStreams.removeAllListeners();\n    peerStreams.close(); // delete peer streams\n\n    this.log('delete peer', id);\n    this.peers.delete(id); // remove peer from topics map\n\n    for (const peers of this.topics.values()) {\n      peers.delete(id);\n    }\n\n    return peerStreams;\n  } // MESSAGE METHODS\n\n  /**\n   * Responsible for processing each RPC message received by other peers.\n   *\n   * @param {string} idB58Str - peer id string in base58\n   * @param {AsyncIterable<Uint8Array|BufferList>} stream - inbound stream\n   * @param {PeerStreams} peerStreams - PubSub peer\n   * @returns {Promise<void>}\n   */\n\n\n  async _processMessages(idB58Str, stream, peerStreams) {\n    try {\n      await pipe(stream, async source => {\n        for await (const data of source) {\n          const rpcBytes = data instanceof Uint8Array ? data : data.slice();\n\n          const rpcMsg = this._decodeRpc(rpcBytes) // Since _processRpc may be overridden entirely in unsafe ways,\n          // the simplest/safest option here is to wrap in a function and capture all errors\n          // to prevent a top-level unhandled exception\n          // This processing of rpc messages should happen without awaiting full validation/execution of prior messages\n          ;\n\n          (async () => {\n            try {\n              await this._processRpc(idB58Str, peerStreams, rpcMsg);\n            } catch (err) {\n              this.log.err(err);\n            }\n          })();\n        }\n      });\n    } catch (err) {\n      this._onPeerDisconnected(peerStreams.id, err);\n    }\n  }\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @param {string} idB58Str\n   * @param {PeerStreams} peerStreams\n   * @param {RPC} rpc\n   * @returns {Promise<boolean>}\n   */\n\n\n  async _processRpc(idB58Str, peerStreams, rpc) {\n    this.log('rpc from', idB58Str);\n    const subs = rpc.subscriptions;\n    const msgs = rpc.msgs;\n\n    if (subs.length) {\n      // update peer subscriptions\n      subs.forEach(subOpt => {\n        this._processRpcSubOpt(idB58Str, subOpt);\n      });\n      this.emit('pubsub:subscription-change', peerStreams.id, subs);\n    }\n\n    if (!this._acceptFrom(idB58Str)) {\n      this.log('received message from unacceptable peer %s', idB58Str);\n      return false;\n    }\n\n    if (msgs.length) {\n      this.queue.addAll(msgs.map(message => async () => {\n        if (!(this.canRelayMessage || message.topicIDs && message.topicIDs.some(topic => this.subscriptions.has(topic)))) {\n          this.log('received message we didn\\'t subscribe to. Dropping.');\n          return;\n        }\n\n        try {\n          const msg = utils.normalizeInRpcMessage(message, idB58Str);\n          await this._processRpcMessage(msg);\n        } catch (err) {\n          this.log.err(err);\n        }\n      }));\n    }\n\n    return true;\n  }\n  /**\n   * Handles a subscription change from a peer\n   *\n   * @param {string} id\n   * @param {RPC.ISubOpts} subOpt\n   */\n\n\n  _processRpcSubOpt(id, subOpt) {\n    const t = subOpt.topicID;\n\n    if (!t) {\n      return;\n    }\n\n    let topicSet = this.topics.get(t);\n\n    if (!topicSet) {\n      topicSet = new Set();\n      this.topics.set(t, topicSet);\n    }\n\n    if (subOpt.subscribe) {\n      // subscribe peer to new topic\n      topicSet.add(id);\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(id);\n    }\n  }\n  /**\n   * Handles an message from a peer\n   *\n   * @param {InMessage} msg\n   * @returns {Promise<void>}\n   */\n\n\n  async _processRpcMessage(msg) {\n    if (this.peerId.toB58String() === msg.from && !this.emitSelf) {\n      return;\n    } // Ensure the message is valid before processing it\n\n\n    try {\n      await this.validate(msg);\n    } catch (err) {\n      this.log('Message is invalid, dropping it. %O', err);\n      return;\n    } // Emit to self\n\n\n    this._emitMessage(msg);\n\n    return this._publish(utils.normalizeOutRpcMessage(msg));\n  }\n  /**\n   * Emit a message from a peer\n   *\n   * @param {InMessage} message\n   */\n\n\n  _emitMessage(message) {\n    message.topicIDs.forEach(topic => {\n      if (this.subscriptions.has(topic)) {\n        this.emit(topic, message);\n      }\n    });\n  }\n  /**\n   * The default msgID implementation\n   * Child class can override this.\n   *\n   * @param {InMessage} msg - the message object\n   * @returns {Promise<Uint8Array> | Uint8Array} message id as bytes\n   */\n\n\n  getMsgId(msg) {\n    const signaturePolicy = this.globalSignaturePolicy;\n\n    switch (signaturePolicy) {\n      case SignaturePolicy.StrictSign:\n        // @ts-ignore seqno is optional in protobuf definition but it will exist\n        return utils.msgId(msg.from, msg.seqno);\n\n      case SignaturePolicy.StrictNoSign:\n        return utils.noSignMsgId(msg.data);\n\n      default:\n        throw errcode(new Error('Cannot get message id: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);\n    }\n  }\n  /**\n   * Whether to accept a message from a peer\n   * Override to create a graylist\n   *\n   * @param {string} id\n   * @returns {boolean}\n   */\n\n\n  _acceptFrom(id) {\n    return true;\n  }\n  /**\n   * Decode Uint8Array into an RPC object.\n   * This can be override to use a custom router protobuf.\n   *\n   * @param {Uint8Array} bytes\n   * @returns {RPC}\n   */\n\n\n  _decodeRpc(bytes) {\n    return RPC.decode(bytes);\n  }\n  /**\n   * Encode RPC object into a Uint8Array.\n   * This can be override to use a custom router protobuf.\n   *\n   * @param {IRPC} rpc\n   * @returns {Uint8Array}\n   */\n\n\n  _encodeRpc(rpc) {\n    return RPC.encode(rpc).finish();\n  }\n  /**\n   * Send an rpc object to a peer\n   *\n   * @param {string} id - peer id\n   * @param {IRPC} rpc\n   * @returns {void}\n   */\n\n\n  _sendRpc(id, rpc) {\n    const peerStreams = this.peers.get(id);\n\n    if (!peerStreams || !peerStreams.isWritable) {\n      const msg = `Cannot send RPC to ${id} as there is no open stream to it available`;\n      this.log.err(msg);\n      return;\n    }\n\n    peerStreams.write(this._encodeRpc(rpc));\n  }\n  /**\n   * Send subscroptions to a peer\n   *\n   * @param {string} id - peer id\n   * @param {string[]} topics\n   * @param {boolean} subscribe - set to false for unsubscriptions\n   * @returns {void}\n   */\n\n\n  _sendSubscriptions(id, topics, subscribe) {\n    return this._sendRpc(id, {\n      subscriptions: topics.map(t => ({\n        topicID: t,\n        subscribe: subscribe\n      }))\n    });\n  }\n  /**\n   * Validates the given message. The signature will be checked for authenticity.\n   * Throws an error on invalid messages\n   *\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n\n\n  async validate(message) {\n    // eslint-disable-line require-await\n    const signaturePolicy = this.globalSignaturePolicy;\n\n    switch (signaturePolicy) {\n      case SignaturePolicy.StrictNoSign:\n        if (message.from) {\n          throw errcode(new Error('StrictNoSigning: from should not be present'), codes.ERR_UNEXPECTED_FROM);\n        }\n\n        if (message.signature) {\n          throw errcode(new Error('StrictNoSigning: signature should not be present'), codes.ERR_UNEXPECTED_SIGNATURE);\n        }\n\n        if (message.key) {\n          throw errcode(new Error('StrictNoSigning: key should not be present'), codes.ERR_UNEXPECTED_KEY);\n        }\n\n        if (message.seqno) {\n          throw errcode(new Error('StrictNoSigning: seqno should not be present'), codes.ERR_UNEXPECTED_SEQNO);\n        }\n\n        break;\n\n      case SignaturePolicy.StrictSign:\n        if (!message.signature) {\n          throw errcode(new Error('StrictSigning: Signing required and no signature was present'), codes.ERR_MISSING_SIGNATURE);\n        }\n\n        if (!message.seqno) {\n          throw errcode(new Error('StrictSigning: Signing required and no seqno was present'), codes.ERR_MISSING_SEQNO);\n        }\n\n        if (!(await verifySignature(message))) {\n          throw errcode(new Error('StrictSigning: Invalid message signature'), codes.ERR_INVALID_SIGNATURE);\n        }\n\n        break;\n\n      default:\n        throw errcode(new Error('Cannot validate message: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);\n    }\n\n    for (const topic of message.topicIDs) {\n      const validatorFn = this.topicValidators.get(topic);\n\n      if (validatorFn) {\n        await validatorFn(topic, message);\n      }\n    }\n  }\n  /**\n   * Normalizes the message and signs it, if signing is enabled.\n   * Should be used by the routers to create the message to send.\n   *\n   * @protected\n   * @param {InMessage} message\n   * @returns {Promise<InMessage>}\n   */\n\n\n  _buildMessage(message) {\n    const signaturePolicy = this.globalSignaturePolicy;\n\n    switch (signaturePolicy) {\n      case SignaturePolicy.StrictSign:\n        message.from = this.peerId.toB58String();\n        message.seqno = utils.randomSeqno();\n        return signMessage(this.peerId, message);\n\n      case SignaturePolicy.StrictNoSign:\n        return Promise.resolve(message);\n\n      default:\n        throw errcode(new Error('Cannot build message: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);\n    }\n  } // API METHODS\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   *\n   * @param {string} topic\n   * @returns {Array<string>}\n   */\n\n\n  getSubscribers(topic) {\n    if (!this.started) {\n      throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET');\n    }\n\n    if (!topic || typeof topic !== 'string') {\n      throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC');\n    }\n\n    const peersInTopic = this.topics.get(topic);\n\n    if (!peersInTopic) {\n      return [];\n    }\n\n    return Array.from(peersInTopic);\n  }\n  /**\n   * Publishes messages to all subscribed peers\n   *\n   * @param {string} topic\n   * @param {Uint8Array} message\n   * @returns {Promise<void>}\n   */\n\n\n  async publish(topic, message) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started');\n    }\n\n    this.log('publish', topic, message);\n    const from = this.peerId.toB58String();\n    const msgObject = {\n      receivedFrom: from,\n      data: message,\n      topicIDs: [topic]\n    }; // ensure that the message follows the signature policy\n\n    const outMsg = await this._buildMessage(msgObject); // @ts-ignore different type as from is converted\n\n    const msg = utils.normalizeInRpcMessage(outMsg); // Emit to self if I'm interested and emitSelf enabled\n\n    this.emitSelf && this._emitMessage(msg); // send to all the other peers\n\n    await this._publish(msg);\n  }\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n   *\n   * @abstract\n   * @param {InMessage|RPCMessage} message\n   * @returns {Promise<void>}\n   *\n   */\n\n\n  _publish(message) {\n    throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Subscribes to a given topic.\n   *\n   * @abstract\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  subscribe(topic) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started');\n    }\n\n    if (!this.subscriptions.has(topic)) {\n      this.subscriptions.add(topic);\n      this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], true));\n    }\n  }\n  /**\n   * Unsubscribe from the given topic.\n   *\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  unsubscribe(topic) {\n    if (!this.started) {\n      throw new Error('Pubsub is not started');\n    }\n\n    if (this.subscriptions.has(topic) && this.listenerCount(topic) === 0) {\n      this.subscriptions.delete(topic);\n      this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], false));\n    }\n  }\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   *\n   * @returns {Array<string>}\n   */\n\n\n  getTopics() {\n    if (!this.started) {\n      throw new Error('Pubsub is not started');\n    }\n\n    return Array.from(this.subscriptions);\n  }\n\n}\n\nPubsubBaseProtocol.utils = utils;\nPubsubBaseProtocol.SignaturePolicy = SignaturePolicy;\nmodule.exports = PubsubBaseProtocol;","map":{"version":3,"names":["debug","require","EventEmitter","errcode","pipe","default","Queue","MulticodecTopology","codes","RPC","PeerStreams","SignaturePolicy","utils","signMessage","verifySignature","PubsubBaseProtocol","constructor","debugName","multicodecs","libp2p","globalSignaturePolicy","StrictSign","canRelayMessage","emitSelf","messageProcessingConcurrency","Error","log","Object","assign","err","ensureArray","_libp2p","registrar","peerId","started","topics","Map","subscriptions","Set","peers","ERR_INVALID_SIGNATURE_POLICY","topicValidators","queue","concurrency","_registrarId","undefined","_onIncomingStream","bind","_onPeerConnected","_onPeerDisconnected","start","handle","topology","handlers","onConnect","onDisconnect","register","stop","unregister","forEach","peerStreams","close","protocol","stream","connection","remotePeer","idB58Str","toB58String","peer","_addPeer","inboundStream","attachInboundStream","_processMessages","conn","newStream","attachOutboundStream","_sendSubscriptions","Array","from","message","_removePeer","id","existing","get","set","once","removeAllListeners","delete","values","source","data","rpcBytes","Uint8Array","slice","rpcMsg","_decodeRpc","_processRpc","rpc","subs","msgs","length","subOpt","_processRpcSubOpt","emit","_acceptFrom","addAll","map","topicIDs","some","topic","has","msg","normalizeInRpcMessage","_processRpcMessage","t","topicID","topicSet","subscribe","add","validate","_emitMessage","_publish","normalizeOutRpcMessage","getMsgId","signaturePolicy","msgId","seqno","StrictNoSign","noSignMsgId","ERR_UNHANDLED_SIGNATURE_POLICY","bytes","decode","_encodeRpc","encode","finish","_sendRpc","isWritable","write","ERR_UNEXPECTED_FROM","signature","ERR_UNEXPECTED_SIGNATURE","key","ERR_UNEXPECTED_KEY","ERR_UNEXPECTED_SEQNO","ERR_MISSING_SIGNATURE","ERR_MISSING_SEQNO","ERR_INVALID_SIGNATURE","validatorFn","_buildMessage","randomSeqno","Promise","resolve","getSubscribers","peersInTopic","publish","msgObject","receivedFrom","outMsg","_","unsubscribe","listenerCount","getTopics","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-interfaces/src/pubsub/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst { EventEmitter } = require('events')\nconst errcode = require('err-code')\n\nconst { pipe } = require('it-pipe')\nconst { default: Queue } = require('p-queue')\n\nconst MulticodecTopology = require('../topology/multicodec-topology')\nconst { codes } = require('./errors')\n\nconst { RPC } = require('./message/rpc')\nconst PeerStreams = require('./peer-streams')\nconst { SignaturePolicy } = require('./signature-policy')\nconst utils = require('./utils')\n\nconst {\n  signMessage,\n  verifySignature\n} = require('./message/sign')\n\n/**\n * @typedef {any} Libp2p\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('bl')} BufferList\n * @typedef {import('../stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('../connection/connection')} Connection\n * @typedef {import('./signature-policy').SignaturePolicyType} SignaturePolicyType\n * @typedef {import('./message/rpc').IRPC} IRPC\n * @typedef {import('./message/rpc').RPC.SubOpts} RPCSubOpts\n * @typedef {import('./message/rpc').RPC.Message} RPCMessage\n */\n\n/**\n * @typedef {Object} InMessage\n * @property {string} [from]\n * @property {string} receivedFrom\n * @property {string[]} topicIDs\n * @property {Uint8Array} [seqno]\n * @property {Uint8Array} data\n * @property {Uint8Array} [signature]\n * @property {Uint8Array} [key]\n *\n * @typedef {Object} PubsubProperties\n * @property {string} debugName - log namespace\n * @property {Array<string>|string} multicodecs - protocol identificers to connect\n * @property {Libp2p} libp2p\n *\n * @typedef {Object} PubsubOptions\n * @property {SignaturePolicyType} [globalSignaturePolicy = SignaturePolicy.StrictSign] - defines how signatures should be handled\n * @property {boolean} [canRelayMessage = false] - if can relay messages not subscribed\n * @property {boolean} [emitSelf = false] - if publish should emit to self, if subscribed\n * @property {number} [messageProcessingConcurrency = 10] - handle this many incoming pubsub messages concurrently\n */\n\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n * and specifies the API that pubsub routers should have.\n */\nclass PubsubBaseProtocol extends EventEmitter {\n  /**\n   * @param {PubsubProperties & PubsubOptions} props\n   * @abstract\n   */\n  constructor ({\n    debugName,\n    multicodecs,\n    libp2p,\n    globalSignaturePolicy = SignaturePolicy.StrictSign,\n    canRelayMessage = false,\n    emitSelf = false,\n    messageProcessingConcurrency = 10\n  }) {\n    if (typeof debugName !== 'string') {\n      throw new Error('a debugname `string` is required')\n    }\n\n    if (!multicodecs) {\n      throw new Error('multicodecs are required')\n    }\n\n    if (!libp2p) {\n      throw new Error('libp2p is required')\n    }\n\n    super()\n\n    this.log = Object.assign(debug(debugName), {\n      err: debug(`${debugName}:error`)\n    })\n\n    /**\n     * @type {Array<string>}\n     */\n    this.multicodecs = utils.ensureArray(multicodecs)\n    this._libp2p = libp2p\n    this.registrar = libp2p.registrar\n    /**\n     * @type {PeerId}\n     */\n    this.peerId = libp2p.peerId\n\n    this.started = false\n\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Set<string>>}\n     */\n    this.topics = new Map()\n\n    /**\n     * List of our subscriptions\n     *\n     * @type {Set<string>}\n     */\n    this.subscriptions = new Set()\n\n    /**\n     * Map of peer streams\n     *\n     * @type {Map<string, import('./peer-streams')>}\n     */\n    this.peers = new Map()\n\n    // validate signature policy\n    if (!SignaturePolicy[globalSignaturePolicy]) {\n      throw errcode(new Error('Invalid global signature policy'), codes.ERR_INVALID_SIGNATURE_POLICY)\n    }\n\n    /**\n     * The signature policy to follow by default\n     *\n     * @type {string}\n     */\n    this.globalSignaturePolicy = globalSignaturePolicy\n\n    /**\n     * If router can relay received messages, even if not subscribed\n     *\n     * @type {boolean}\n     */\n    this.canRelayMessage = canRelayMessage\n\n    /**\n     * if publish should emit to self, if subscribed\n     *\n     * @type {boolean}\n     */\n    this.emitSelf = emitSelf\n\n    /**\n     * Topic validator function\n     *\n     * @typedef {function(string, InMessage): Promise<void>} validator\n     */\n    /**\n     * Topic validator map\n     *\n     * Keyed by topic\n     * Topic validators are functions with the following input:\n     *\n     * @type {Map<string, validator>}\n     */\n    this.topicValidators = new Map()\n\n    /**\n     * @type {Queue}\n     */\n    this.queue = new Queue({ concurrency: messageProcessingConcurrency })\n\n    this._registrarId = undefined\n    this._onIncomingStream = this._onIncomingStream.bind(this)\n    this._onPeerConnected = this._onPeerConnected.bind(this)\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this)\n  }\n\n  // LIFECYCLE METHODS\n\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   *\n   * @returns {void}\n   */\n  start () {\n    if (this.started) {\n      return\n    }\n    this.log('starting')\n\n    // Incoming streams\n    // Called after a peer dials us\n    this.registrar.handle(this.multicodecs, this._onIncomingStream)\n\n    // register protocol with topology\n    // Topology callbacks called on connection manager changes\n    const topology = new MulticodecTopology({\n      multicodecs: this.multicodecs,\n      handlers: {\n        onConnect: this._onPeerConnected,\n        onDisconnect: this._onPeerDisconnected\n      }\n    })\n    this._registrarId = this.registrar.register(topology)\n\n    this.log('started')\n    this.started = true\n  }\n\n  /**\n   * Unregister the pubsub protocol and the streams with other peers will be closed.\n   *\n   * @returns {void}\n   */\n  stop () {\n    if (!this.started) {\n      return\n    }\n\n    // unregister protocol and handlers\n    this.registrar.unregister(this._registrarId)\n\n    this.log('stopping')\n    this.peers.forEach((peerStreams) => peerStreams.close())\n\n    this.peers = new Map()\n    this.subscriptions = new Set()\n    this.started = false\n    this.log('stopped')\n  }\n\n  /**\n   * On an inbound stream opened.\n   *\n   * @protected\n   * @param {Object} props\n   * @param {string} props.protocol\n   * @param {MuxedStream} props.stream\n   * @param {Connection} props.connection - connection\n   */\n  _onIncomingStream ({ protocol, stream, connection }) {\n    const peerId = connection.remotePeer\n    const idB58Str = peerId.toB58String()\n    const peer = this._addPeer(peerId, protocol)\n    const inboundStream = peer.attachInboundStream(stream)\n\n    this._processMessages(idB58Str, inboundStream, peer)\n  }\n\n  /**\n   * Registrar notifies an established connection with pubsub protocol.\n   *\n   * @protected\n   * @param {PeerId} peerId - remote peer-id\n   * @param {Connection} conn - connection to the peer\n   */\n  async _onPeerConnected (peerId, conn) {\n    const idB58Str = peerId.toB58String()\n    this.log('connected', idB58Str)\n\n    try {\n      const { stream, protocol } = await conn.newStream(this.multicodecs)\n      const peer = this._addPeer(peerId, protocol)\n      await peer.attachOutboundStream(stream)\n    } catch (err) {\n      this.log.err(err)\n    }\n\n    // Immediately send my own subscriptions to the newly established conn\n    this._sendSubscriptions(idB58Str, Array.from(this.subscriptions), true)\n  }\n\n  /**\n   * Registrar notifies a closing connection with pubsub protocol.\n   *\n   * @protected\n   * @param {PeerId} peerId - peerId\n   * @param {Error} [err] - error for connection end\n   */\n  _onPeerDisconnected (peerId, err) {\n    const idB58Str = peerId.toB58String()\n\n    this.log('connection ended', idB58Str, err ? err.message : '')\n    this._removePeer(peerId)\n  }\n\n  /**\n   * Notifies the router that a peer has been connected\n   *\n   * @protected\n   * @param {PeerId} peerId\n   * @param {string} protocol\n   * @returns {PeerStreams}\n   */\n  _addPeer (peerId, protocol) {\n    const id = peerId.toB58String()\n    const existing = this.peers.get(id)\n\n    // If peer streams already exists, do nothing\n    if (existing) {\n      return existing\n    }\n\n    // else create a new peer streams\n    this.log('new peer', id)\n\n    const peerStreams = new PeerStreams({\n      id: peerId,\n      protocol\n    })\n\n    this.peers.set(id, peerStreams)\n    peerStreams.once('close', () => this._removePeer(peerId))\n\n    return peerStreams\n  }\n\n  /**\n   * Notifies the router that a peer has been disconnected.\n   *\n   * @protected\n   * @param {PeerId} peerId\n   * @returns {PeerStreams | undefined}\n   */\n  _removePeer (peerId) {\n    if (!peerId) return\n    const id = peerId.toB58String()\n    const peerStreams = this.peers.get(id)\n    if (!peerStreams) return\n\n    // close peer streams\n    peerStreams.removeAllListeners()\n    peerStreams.close()\n\n    // delete peer streams\n    this.log('delete peer', id)\n    this.peers.delete(id)\n\n    // remove peer from topics map\n    for (const peers of this.topics.values()) {\n      peers.delete(id)\n    }\n\n    return peerStreams\n  }\n\n  // MESSAGE METHODS\n\n  /**\n   * Responsible for processing each RPC message received by other peers.\n   *\n   * @param {string} idB58Str - peer id string in base58\n   * @param {AsyncIterable<Uint8Array|BufferList>} stream - inbound stream\n   * @param {PeerStreams} peerStreams - PubSub peer\n   * @returns {Promise<void>}\n   */\n  async _processMessages (idB58Str, stream, peerStreams) {\n    try {\n      await pipe(\n        stream,\n        async (source) => {\n          for await (const data of source) {\n            const rpcBytes = data instanceof Uint8Array ? data : data.slice()\n            const rpcMsg = this._decodeRpc(rpcBytes)\n\n            // Since _processRpc may be overridden entirely in unsafe ways,\n            // the simplest/safest option here is to wrap in a function and capture all errors\n            // to prevent a top-level unhandled exception\n            // This processing of rpc messages should happen without awaiting full validation/execution of prior messages\n            ;(async () => {\n              try {\n                await this._processRpc(idB58Str, peerStreams, rpcMsg)\n              } catch (err) {\n                this.log.err(err)\n              }\n            })()\n          }\n        }\n      )\n    } catch (err) {\n      this._onPeerDisconnected(peerStreams.id, err)\n    }\n  }\n\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @param {string} idB58Str\n   * @param {PeerStreams} peerStreams\n   * @param {RPC} rpc\n   * @returns {Promise<boolean>}\n   */\n  async _processRpc (idB58Str, peerStreams, rpc) {\n    this.log('rpc from', idB58Str)\n    const subs = rpc.subscriptions\n    const msgs = rpc.msgs\n\n    if (subs.length) {\n      // update peer subscriptions\n      subs.forEach((subOpt) => {\n        this._processRpcSubOpt(idB58Str, subOpt)\n      })\n      this.emit('pubsub:subscription-change', peerStreams.id, subs)\n    }\n\n    if (!this._acceptFrom(idB58Str)) {\n      this.log('received message from unacceptable peer %s', idB58Str)\n      return false\n    }\n\n    if (msgs.length) {\n      this.queue.addAll(msgs.map(message => async () => {\n        if (!(this.canRelayMessage || (message.topicIDs && message.topicIDs.some((topic) => this.subscriptions.has(topic))))) {\n          this.log('received message we didn\\'t subscribe to. Dropping.')\n          return\n        }\n\n        try {\n          const msg = utils.normalizeInRpcMessage(message, idB58Str)\n\n          await this._processRpcMessage(msg)\n        } catch (err) {\n          this.log.err(err)\n        }\n      }))\n    }\n    return true\n  }\n\n  /**\n   * Handles a subscription change from a peer\n   *\n   * @param {string} id\n   * @param {RPC.ISubOpts} subOpt\n   */\n  _processRpcSubOpt (id, subOpt) {\n    const t = subOpt.topicID\n\n    if (!t) {\n      return\n    }\n\n    let topicSet = this.topics.get(t)\n    if (!topicSet) {\n      topicSet = new Set()\n      this.topics.set(t, topicSet)\n    }\n\n    if (subOpt.subscribe) {\n      // subscribe peer to new topic\n      topicSet.add(id)\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(id)\n    }\n  }\n\n  /**\n   * Handles an message from a peer\n   *\n   * @param {InMessage} msg\n   * @returns {Promise<void>}\n   */\n  async _processRpcMessage (msg) {\n    if (this.peerId.toB58String() === msg.from && !this.emitSelf) {\n      return\n    }\n\n    // Ensure the message is valid before processing it\n    try {\n      await this.validate(msg)\n    } catch (err) {\n      this.log('Message is invalid, dropping it. %O', err)\n      return\n    }\n\n    // Emit to self\n    this._emitMessage(msg)\n\n    return this._publish(utils.normalizeOutRpcMessage(msg))\n  }\n\n  /**\n   * Emit a message from a peer\n   *\n   * @param {InMessage} message\n   */\n  _emitMessage (message) {\n    message.topicIDs.forEach((topic) => {\n      if (this.subscriptions.has(topic)) {\n        this.emit(topic, message)\n      }\n    })\n  }\n\n  /**\n   * The default msgID implementation\n   * Child class can override this.\n   *\n   * @param {InMessage} msg - the message object\n   * @returns {Promise<Uint8Array> | Uint8Array} message id as bytes\n   */\n  getMsgId (msg) {\n    const signaturePolicy = this.globalSignaturePolicy\n    switch (signaturePolicy) {\n      case SignaturePolicy.StrictSign:\n        // @ts-ignore seqno is optional in protobuf definition but it will exist\n        return utils.msgId(msg.from, msg.seqno)\n      case SignaturePolicy.StrictNoSign:\n        return utils.noSignMsgId(msg.data)\n      default:\n        throw errcode(new Error('Cannot get message id: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY)\n    }\n  }\n\n  /**\n   * Whether to accept a message from a peer\n   * Override to create a graylist\n   *\n   * @param {string} id\n   * @returns {boolean}\n   */\n  _acceptFrom (id) {\n    return true\n  }\n\n  /**\n   * Decode Uint8Array into an RPC object.\n   * This can be override to use a custom router protobuf.\n   *\n   * @param {Uint8Array} bytes\n   * @returns {RPC}\n   */\n  _decodeRpc (bytes) {\n    return RPC.decode(bytes)\n  }\n\n  /**\n   * Encode RPC object into a Uint8Array.\n   * This can be override to use a custom router protobuf.\n   *\n   * @param {IRPC} rpc\n   * @returns {Uint8Array}\n   */\n  _encodeRpc (rpc) {\n    return RPC.encode(rpc).finish()\n  }\n\n  /**\n   * Send an rpc object to a peer\n   *\n   * @param {string} id - peer id\n   * @param {IRPC} rpc\n   * @returns {void}\n   */\n  _sendRpc (id, rpc) {\n    const peerStreams = this.peers.get(id)\n    if (!peerStreams || !peerStreams.isWritable) {\n      const msg = `Cannot send RPC to ${id} as there is no open stream to it available`\n\n      this.log.err(msg)\n      return\n    }\n    peerStreams.write(this._encodeRpc(rpc))\n  }\n\n  /**\n   * Send subscroptions to a peer\n   *\n   * @param {string} id - peer id\n   * @param {string[]} topics\n   * @param {boolean} subscribe - set to false for unsubscriptions\n   * @returns {void}\n   */\n  _sendSubscriptions (id, topics, subscribe) {\n    return this._sendRpc(id, {\n      subscriptions: topics.map(t => ({ topicID: t, subscribe: subscribe }))\n    })\n  }\n\n  /**\n   * Validates the given message. The signature will be checked for authenticity.\n   * Throws an error on invalid messages\n   *\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n  async validate (message) { // eslint-disable-line require-await\n    const signaturePolicy = this.globalSignaturePolicy\n    switch (signaturePolicy) {\n      case SignaturePolicy.StrictNoSign:\n        if (message.from) {\n          throw errcode(new Error('StrictNoSigning: from should not be present'), codes.ERR_UNEXPECTED_FROM)\n        }\n        if (message.signature) {\n          throw errcode(new Error('StrictNoSigning: signature should not be present'), codes.ERR_UNEXPECTED_SIGNATURE)\n        }\n        if (message.key) {\n          throw errcode(new Error('StrictNoSigning: key should not be present'), codes.ERR_UNEXPECTED_KEY)\n        }\n        if (message.seqno) {\n          throw errcode(new Error('StrictNoSigning: seqno should not be present'), codes.ERR_UNEXPECTED_SEQNO)\n        }\n        break\n      case SignaturePolicy.StrictSign:\n        if (!message.signature) {\n          throw errcode(new Error('StrictSigning: Signing required and no signature was present'), codes.ERR_MISSING_SIGNATURE)\n        }\n        if (!message.seqno) {\n          throw errcode(new Error('StrictSigning: Signing required and no seqno was present'), codes.ERR_MISSING_SEQNO)\n        }\n        if (!(await verifySignature(message))) {\n          throw errcode(new Error('StrictSigning: Invalid message signature'), codes.ERR_INVALID_SIGNATURE)\n        }\n        break\n      default:\n        throw errcode(new Error('Cannot validate message: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY)\n    }\n\n    for (const topic of message.topicIDs) {\n      const validatorFn = this.topicValidators.get(topic)\n      if (validatorFn) {\n        await validatorFn(topic, message)\n      }\n    }\n  }\n\n  /**\n   * Normalizes the message and signs it, if signing is enabled.\n   * Should be used by the routers to create the message to send.\n   *\n   * @protected\n   * @param {InMessage} message\n   * @returns {Promise<InMessage>}\n   */\n  _buildMessage (message) {\n    const signaturePolicy = this.globalSignaturePolicy\n    switch (signaturePolicy) {\n      case SignaturePolicy.StrictSign:\n        message.from = this.peerId.toB58String()\n        message.seqno = utils.randomSeqno()\n        return signMessage(this.peerId, message)\n      case SignaturePolicy.StrictNoSign:\n        return Promise.resolve(message)\n      default:\n        throw errcode(new Error('Cannot build message: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY)\n    }\n  }\n\n  // API METHODS\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   *\n   * @param {string} topic\n   * @returns {Array<string>}\n   */\n  getSubscribers (topic) {\n    if (!this.started) {\n      throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET')\n    }\n\n    if (!topic || typeof topic !== 'string') {\n      throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC')\n    }\n\n    const peersInTopic = this.topics.get(topic)\n    if (!peersInTopic) {\n      return []\n    }\n    return Array.from(peersInTopic)\n  }\n\n  /**\n   * Publishes messages to all subscribed peers\n   *\n   * @param {string} topic\n   * @param {Uint8Array} message\n   * @returns {Promise<void>}\n   */\n  async publish (topic, message) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started')\n    }\n\n    this.log('publish', topic, message)\n\n    const from = this.peerId.toB58String()\n    const msgObject = {\n      receivedFrom: from,\n      data: message,\n      topicIDs: [topic]\n    }\n\n    // ensure that the message follows the signature policy\n    const outMsg = await this._buildMessage(msgObject)\n    // @ts-ignore different type as from is converted\n    const msg = utils.normalizeInRpcMessage(outMsg)\n\n    // Emit to self if I'm interested and emitSelf enabled\n    this.emitSelf && this._emitMessage(msg)\n\n    // send to all the other peers\n    await this._publish(msg)\n  }\n\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n   *\n   * @abstract\n   * @param {InMessage|RPCMessage} message\n   * @returns {Promise<void>}\n   *\n   */\n  _publish (message) {\n    throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Subscribes to a given topic.\n   *\n   * @abstract\n   * @param {string} topic\n   * @returns {void}\n   */\n  subscribe (topic) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started')\n    }\n\n    if (!this.subscriptions.has(topic)) {\n      this.subscriptions.add(topic)\n      this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], true))\n    }\n  }\n\n  /**\n   * Unsubscribe from the given topic.\n   *\n   * @param {string} topic\n   * @returns {void}\n   */\n  unsubscribe (topic) {\n    if (!this.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    if (this.subscriptions.has(topic) && this.listenerCount(topic) === 0) {\n      this.subscriptions.delete(topic)\n      this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], false))\n    }\n  }\n\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   *\n   * @returns {Array<string>}\n   */\n  getTopics () {\n    if (!this.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    return Array.from(this.subscriptions)\n  }\n}\n\nPubsubBaseProtocol.utils = utils\nPubsubBaseProtocol.SignaturePolicy = SignaturePolicy\n\nmodule.exports = PubsubBaseProtocol\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}