{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar _require2 = require('multiaddr'),\n    Multiaddr = _require2.Multiaddr;\n/**\n * @typedef {import('libp2p-interfaces/src/transport/types').Listener} Listener\n */\n\n/**\n * @param {import('../')} libp2p\n * @returns {Listener} a transport listener\n */\n\n\nmodule.exports = function (libp2p) {\n  var listeningAddrs = new Map();\n  /**\n   * Add swarm handler and listen for incoming connections\n   *\n   * @param {Multiaddr} addr\n   * @returns {Promise<void>}\n   */\n\n  function listen(_x) {\n    return _listen.apply(this, arguments);\n  }\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   * `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   * address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   * `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   * addr, such when dialing over a relay with this address, it will create the circuit using\n   * the encapsulated transport address. This is useful when for example, a peer should only\n   * be dialed over TCP rather than any other transport\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  function _listen() {\n    _listen = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(addr) {\n      var addrString, relayConn, relayedAddr;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              addrString = String(addr).split('/p2p-circuit').find(function (a) {\n                return a !== '';\n              });\n              _context.next = 3;\n              return libp2p.dial(new Multiaddr(addrString));\n\n            case 3:\n              relayConn = _context.sent;\n              relayedAddr = relayConn.remoteAddr.encapsulate('/p2p-circuit');\n              listeningAddrs.set(relayConn.remotePeer.toB58String(), relayedAddr);\n              listener.emit('listening');\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return _listen.apply(this, arguments);\n  }\n\n  function getAddrs() {\n    var addrs = [];\n\n    var _iterator = _createForOfIteratorHelper(listeningAddrs.values()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var addr = _step.value;\n        addrs.push(addr);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return addrs;\n  }\n  /** @type Listener */\n\n\n  var listener = Object.assign(new EventEmitter(), {\n    close: function close() {\n      return Promise.resolve();\n    },\n    listen: listen,\n    getAddrs: getAddrs\n  }); // Remove listeningAddrs when a peer disconnects\n\n  libp2p.connectionManager.on('peer:disconnect', function (connection) {\n    var deleted = listeningAddrs.delete(connection.remotePeer.toB58String());\n\n    if (deleted) {\n      // Announce listen addresses change\n      listener.emit('close');\n    }\n  });\n  return listener;\n};","map":{"version":3,"names":["require","EventEmitter","Multiaddr","module","exports","libp2p","listeningAddrs","Map","listen","addr","addrString","String","split","find","a","dial","relayConn","relayedAddr","remoteAddr","encapsulate","set","remotePeer","toB58String","listener","emit","getAddrs","addrs","values","push","Object","assign","close","Promise","resolve","connectionManager","on","connection","deleted","delete"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/circuit/listener.js"],"sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst { Multiaddr } = require('multiaddr')\n\n/**\n * @typedef {import('libp2p-interfaces/src/transport/types').Listener} Listener\n */\n\n/**\n * @param {import('../')} libp2p\n * @returns {Listener} a transport listener\n */\nmodule.exports = (libp2p) => {\n  const listeningAddrs = new Map()\n\n  /**\n   * Add swarm handler and listen for incoming connections\n   *\n   * @param {Multiaddr} addr\n   * @returns {Promise<void>}\n   */\n  async function listen (addr) {\n    const addrString = String(addr).split('/p2p-circuit').find(a => a !== '')\n\n    const relayConn = await libp2p.dial(new Multiaddr(addrString))\n    const relayedAddr = relayConn.remoteAddr.encapsulate('/p2p-circuit')\n\n    listeningAddrs.set(relayConn.remotePeer.toB58String(), relayedAddr)\n    listener.emit('listening')\n  }\n\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   * `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   * address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   * `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   * addr, such when dialing over a relay with this address, it will create the circuit using\n   * the encapsulated transport address. This is useful when for example, a peer should only\n   * be dialed over TCP rather than any other transport\n   *\n   * @returns {Multiaddr[]}\n   */\n  function getAddrs () {\n    const addrs = []\n    for (const addr of listeningAddrs.values()) {\n      addrs.push(addr)\n    }\n    return addrs\n  }\n\n  /** @type Listener */\n  const listener = Object.assign(new EventEmitter(), {\n    close: () => Promise.resolve(),\n    listen,\n    getAddrs\n  })\n\n  // Remove listeningAddrs when a peer disconnects\n  libp2p.connectionManager.on('peer:disconnect', (connection) => {\n    const deleted = listeningAddrs.delete(connection.remotePeer.toB58String())\n\n    if (deleted) {\n      // Announce listen addresses change\n      listener.emit('close')\n    }\n  })\n\n  return listener\n}\n"],"mappings":"AAAA;;;;;;;;AAEA,eAAyBA,OAAO,CAAC,QAAD,CAAhC;AAAA,IAAQC,YAAR,YAAQA,YAAR;;AACA,gBAAsBD,OAAO,CAAC,WAAD,CAA7B;AAAA,IAAQE,SAAR,aAAQA,SAAR;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,UAACC,MAAD,EAAY;EAC3B,IAAMC,cAAc,GAAG,IAAIC,GAAJ,EAAvB;EAEA;AACF;AACA;AACA;AACA;AACA;;EAR6B,SASZC,MATY;IAAA;EAAA;EAmB3B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAlC6B;IAAA,qEAS3B,iBAAuBC,IAAvB;MAAA;MAAA;QAAA;UAAA;YAAA;cACQC,UADR,GACqBC,MAAM,CAACF,IAAD,CAAN,CAAaG,KAAb,CAAmB,cAAnB,EAAmCC,IAAnC,CAAwC,UAAAC,CAAC;gBAAA,OAAIA,CAAC,KAAK,EAAV;cAAA,CAAzC,CADrB;cAAA;cAAA,OAG0BT,MAAM,CAACU,IAAP,CAAY,IAAIb,SAAJ,CAAcQ,UAAd,CAAZ,CAH1B;;YAAA;cAGQM,SAHR;cAIQC,WAJR,GAIsBD,SAAS,CAACE,UAAV,CAAqBC,WAArB,CAAiC,cAAjC,CAJtB;cAMEb,cAAc,CAACc,GAAf,CAAmBJ,SAAS,CAACK,UAAV,CAAqBC,WAArB,EAAnB,EAAuDL,WAAvD;cACAM,QAAQ,CAACC,IAAT,CAAc,WAAd;;YAPF;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAT2B;IAAA;EAAA;;EAmC3B,SAASC,QAAT,GAAqB;IACnB,IAAMC,KAAK,GAAG,EAAd;;IADmB,2CAEApB,cAAc,CAACqB,MAAf,EAFA;IAAA;;IAAA;MAEnB,oDAA4C;QAAA,IAAjClB,IAAiC;QAC1CiB,KAAK,CAACE,IAAN,CAAWnB,IAAX;MACD;IAJkB;MAAA;IAAA;MAAA;IAAA;;IAKnB,OAAOiB,KAAP;EACD;EAED;;;EACA,IAAMH,QAAQ,GAAGM,MAAM,CAACC,MAAP,CAAc,IAAI7B,YAAJ,EAAd,EAAkC;IACjD8B,KAAK,EAAE;MAAA,OAAMC,OAAO,CAACC,OAAR,EAAN;IAAA,CAD0C;IAEjDzB,MAAM,EAANA,MAFiD;IAGjDiB,QAAQ,EAARA;EAHiD,CAAlC,CAAjB,CA5C2B,CAkD3B;;EACApB,MAAM,CAAC6B,iBAAP,CAAyBC,EAAzB,CAA4B,iBAA5B,EAA+C,UAACC,UAAD,EAAgB;IAC7D,IAAMC,OAAO,GAAG/B,cAAc,CAACgC,MAAf,CAAsBF,UAAU,CAACf,UAAX,CAAsBC,WAAtB,EAAtB,CAAhB;;IAEA,IAAIe,OAAJ,EAAa;MACX;MACAd,QAAQ,CAACC,IAAT,CAAc,OAAd;IACD;EACF,CAPD;EASA,OAAOD,QAAP;AACD,CA7DD"},"metadata":{},"sourceType":"script"}