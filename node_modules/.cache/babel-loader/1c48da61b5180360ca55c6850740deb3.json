{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require('peer-id'),\n    createFromPrivKey = _require.createFromPrivKey;\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('ipfs:ipns'), {\n  error: debug('ipfs:ipns:error')\n});\n\nvar IpnsPublisher = require('./publisher');\n\nvar IpnsRepublisher = require('./republisher');\n\nvar IpnsResolver = require('./resolver');\n\nvar TLRU = require('../utils/tlru');\n\nvar defaultRecordTtl = 60 * 1000;\n\nvar _require2 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require2.toString;\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('peer-id')} PeerId\n */\n\n\nvar IPNS = /*#__PURE__*/function () {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('libp2p/src/keychain')} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  function IPNS(routing, datastore, peerId, keychain, options) {\n    _classCallCheck(this, IPNS);\n\n    this.publisher = new IpnsPublisher(routing, datastore);\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);\n    this.resolver = new IpnsResolver(routing);\n    this.cache = new TLRU(1000);\n    this.routing = routing;\n  }\n  /**\n   * Publish\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n\n\n  _createClass(IPNS, [{\n    key: \"publish\",\n    value: function () {\n      var _publish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(privKey, value) {\n        var lifetime,\n            peerId,\n            id,\n            ttEol,\n            ttl,\n            _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                lifetime = _args.length > 2 && _args[2] !== undefined ? _args[2] : IpnsPublisher.defaultRecordLifetime;\n                _context.prev = 1;\n                _context.next = 4;\n                return createFromPrivKey(privKey.bytes);\n\n              case 4:\n                peerId = _context.sent;\n                _context.next = 7;\n                return this.publisher.publishWithEOL(privKey, value, lifetime);\n\n              case 7:\n                log(\"IPNS value \".concat(uint8ArrayToString(value, 'base32'), \" was published correctly\")); // // Add to cache\n\n                id = peerId.toB58String(); // @ts-ignore - parseFloat expects string\n\n                ttEol = parseFloat(lifetime);\n                ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n                this.cache.set(id, value, ttl);\n                log(\"IPNS value \".concat(uint8ArrayToString(value, 'base32'), \" was cached correctly\"));\n                return _context.abrupt(\"return\", {\n                  name: id,\n                  value: value\n                });\n\n              case 16:\n                _context.prev = 16;\n                _context.t0 = _context[\"catch\"](1);\n                log.error(_context.t0);\n                throw _context.t0;\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 16]]);\n      }));\n\n      function publish(_x, _x2) {\n        return _publish.apply(this, arguments);\n      }\n\n      return publish;\n    }()\n    /**\n     * Resolve\n     *\n     * @param {string} name\n     * @param {object} options\n     * @param {boolean} [options.nocache]\n     * @param {boolean} [options.recursive]\n     */\n\n  }, {\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name) {\n        var options,\n            id,\n            result,\n            _result,\n            _args2 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n\n                if (!(typeof name !== 'string')) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME');\n\n              case 3:\n                if (!(!options.nocache && !options.recursive)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                // Try to get the record from cache\n                id = name.split('/')[2];\n                result = this.cache.get(id);\n\n                if (!result) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", result);\n\n              case 8:\n                _context2.prev = 8;\n                _context2.next = 11;\n                return this.resolver.resolve(name, options);\n\n              case 11:\n                _result = _context2.sent;\n                log(\"IPNS record from \".concat(name, \" was resolved correctly\"));\n                return _context2.abrupt(\"return\", _result);\n\n              case 16:\n                _context2.prev = 16;\n                _context2.t0 = _context2[\"catch\"](8);\n                log.error(_context2.t0);\n                throw _context2.t0;\n\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[8, 16]]);\n      }));\n\n      function resolve(_x3) {\n        return _resolve.apply(this, arguments);\n      }\n\n      return resolve;\n    }()\n    /**\n     * Initialize keyspace\n     *\n     * Sets the ipns record for the given key to point to an empty directory\n     *\n     * @param {PrivateKey} privKey\n     * @param {Uint8Array} value\n     */\n\n  }, {\n    key: \"initializeKeyspace\",\n    value: function () {\n      var _initializeKeyspace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(privKey, value) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.publish(privKey, value, IpnsPublisher.defaultRecordLifetime));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function initializeKeyspace(_x4, _x5) {\n        return _initializeKeyspace.apply(this, arguments);\n      }\n\n      return initializeKeyspace;\n    }()\n  }]);\n\n  return IPNS;\n}();\n\nmodule.exports = IPNS;","map":{"version":3,"names":["require","createFromPrivKey","errcode","debug","log","Object","assign","error","IpnsPublisher","IpnsRepublisher","IpnsResolver","TLRU","defaultRecordTtl","uint8ArrayToString","toString","IPNS","routing","datastore","peerId","keychain","options","publisher","republisher","resolver","cache","privKey","value","lifetime","defaultRecordLifetime","bytes","publishWithEOL","id","toB58String","ttEol","parseFloat","ttl","set","name","Error","nocache","recursive","split","result","get","resolve","publish","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/ipns/index.js"],"sourcesContent":["'use strict'\n\nconst { createFromPrivKey } = require('peer-id')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns'), {\n  error: debug('ipfs:ipns:error')\n})\n\nconst IpnsPublisher = require('./publisher')\nconst IpnsRepublisher = require('./republisher')\nconst IpnsResolver = require('./resolver')\nconst TLRU = require('../utils/tlru')\nconst defaultRecordTtl = 60 * 1000\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('peer-id')} PeerId\n */\n\nclass IPNS {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   * @param {PeerId} peerId\n   * @param {import('libp2p/src/keychain')} keychain\n   * @param {object} options\n   * @param {string} options.pass\n   * @param {number} [options.initialBroadcastInterval]\n   * @param {number} [options.broadcastInterval]\n   */\n  constructor (routing, datastore, peerId, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore)\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options)\n    this.resolver = new IpnsResolver(routing)\n    this.cache = new TLRU(1000)\n    this.routing = routing\n  }\n\n  /**\n   * Publish\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n  async publish (privKey, value, lifetime = IpnsPublisher.defaultRecordLifetime) {\n    try {\n      const peerId = await createFromPrivKey(privKey.bytes)\n      await this.publisher.publishWithEOL(privKey, value, lifetime)\n\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was published correctly`)\n\n      // // Add to cache\n      const id = peerId.toB58String()\n      // @ts-ignore - parseFloat expects string\n      const ttEol = parseFloat(lifetime)\n      const ttl = (ttEol < defaultRecordTtl) ? ttEol : defaultRecordTtl\n\n      this.cache.set(id, value, ttl)\n\n      log(`IPNS value ${uint8ArrayToString(value, 'base32')} was cached correctly`)\n\n      return {\n        name: id,\n        value: value\n      }\n    } catch (err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  /**\n   * Resolve\n   *\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.nocache]\n   * @param {boolean} [options.recursive]\n   */\n  async resolve (name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME')\n    }\n\n    // If recursive, we should not try to get the cached value\n    if (!options.nocache && !options.recursive) {\n      // Try to get the record from cache\n      const id = name.split('/')[2]\n      const result = this.cache.get(id)\n\n      if (result) {\n        return result\n      }\n    }\n\n    try {\n      const result = await this.resolver.resolve(name, options)\n\n      log(`IPNS record from ${name} was resolved correctly`)\n\n      return result\n    } catch (err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  /**\n   * Initialize keyspace\n   *\n   * Sets the ipns record for the given key to point to an empty directory\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n  async initializeKeyspace (privKey, value) { // eslint-disable-line require-await\n    return this.publish(privKey, value, IpnsPublisher.defaultRecordLifetime)\n  }\n}\n\nmodule.exports = IPNS\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}