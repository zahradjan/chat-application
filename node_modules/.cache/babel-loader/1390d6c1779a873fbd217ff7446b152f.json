{"ast":null,"code":"'use strict';\n\nconst fs = typeof window === 'object' || typeof self === 'object' ? null : eval('require(\"fs\")'); // eslint-disable-line\n\nconst level = require('level');\n\nconst crypto = require('libp2p-crypto');\n\nconst secp256k1 = require('secp256k1');\n\nconst LRU = require('lru');\n\nconst Buffer = require('safe-buffer/').Buffer;\n\nconst {\n  verifier\n} = require('./verifiers');\n\nfunction createStore() {\n  let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : './keystore';\n\n  if (fs && fs.mkdirSync) {\n    fs.mkdirSync(path, {\n      recursive: true\n    });\n  }\n\n  return level(path);\n}\n\nconst verifiedCache = new LRU(1000);\n\nclass Keystore {\n  constructor() {\n    let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (typeof input === 'string') {\n      this._store = createStore(input);\n    } else if (typeof input.open === 'function') {\n      this._store = input;\n    } else if (typeof input.store === 'string') {\n      this._store = createStore(input.store);\n    } else {\n      this._store = input.store || createStore();\n    }\n\n    this._cache = input.cache || new LRU(100);\n  }\n\n  async open() {\n    if (this._store) {\n      await this._store.open();\n      return Promise.resolve();\n    }\n\n    return Promise.reject(new Error('Keystore: No store found to open'));\n  }\n\n  async close() {\n    if (!this._store) return;\n    await this._store.close();\n  }\n\n  async hasKey(id) {\n    if (!id) {\n      throw new Error('id needed to check a key');\n    }\n\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null);\n    }\n\n    let hasKey = false;\n\n    try {\n      let storedKey = this._cache.get(id) || (await this._store.get(id));\n      hasKey = storedKey !== undefined && storedKey !== null;\n    } catch (e) {\n      // Catches 'Error: ENOENT: no such file or directory, open <path>'\n      console.error('Error: ENOENT: no such file or directory');\n    }\n\n    return hasKey;\n  }\n\n  async createKey(id) {\n    if (!id) {\n      throw new Error('id needed to create a key');\n    }\n\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null);\n    }\n\n    const genKeyPair = () => new Promise((resolve, reject) => {\n      crypto.keys.generateKeyPair('secp256k1', 256, (err, key) => {\n        if (!err) {\n          resolve(key);\n        }\n\n        reject(err);\n      });\n    });\n\n    const keys = await genKeyPair();\n    const decompressedKey = Buffer.from(secp256k1.publicKeyConvert(keys.public.marshal(), false));\n    const key = {\n      publicKey: decompressedKey.toString('hex'),\n      privateKey: keys.marshal().toString('hex')\n    };\n\n    try {\n      await this._store.put(id, JSON.stringify(key));\n    } catch (e) {\n      console.log(e);\n    }\n\n    this._cache.set(id, key);\n\n    return keys;\n  }\n\n  async getKey(id) {\n    if (!id) {\n      throw new Error('id needed to get a key');\n    }\n\n    if (!this._store) {\n      await this.open();\n    }\n\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null);\n    }\n\n    const cachedKey = this._cache.get(id);\n\n    let storedKey;\n\n    try {\n      storedKey = cachedKey || (await this._store.get(id));\n    } catch (e) {// ignore ENOENT error\n    }\n\n    if (!storedKey) {\n      return;\n    }\n\n    const deserializedKey = cachedKey || JSON.parse(storedKey);\n\n    if (!deserializedKey) {\n      return;\n    }\n\n    if (!cachedKey) {\n      this._cache.set(id, deserializedKey);\n    }\n\n    const genPrivKey = pk => new Promise((resolve, reject) => {\n      crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(pk, (err, key) => {\n        if (!err) {\n          resolve(key);\n        }\n\n        reject(err);\n      });\n    });\n\n    return genPrivKey(Buffer.from(deserializedKey.privateKey, 'hex'));\n  }\n\n  async sign(key, data) {\n    if (!key) {\n      throw new Error('No signing key given');\n    }\n\n    if (!data) {\n      throw new Error('Given input data was undefined');\n    }\n\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data);\n    }\n\n    return new Promise((resolve, reject) => {\n      key.sign(data, (err, signature) => {\n        if (!err) {\n          resolve(signature.toString('hex'));\n        }\n\n        reject(err);\n      });\n    });\n  }\n\n  getPublic(keys) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const formats = ['hex', 'buffer'];\n    const decompress = typeof options.decompress === 'undefined' ? true : options.decompress;\n    const format = options.format || 'hex';\n\n    if (formats.indexOf(format) === -1) {\n      throw new Error('Supported formats are `hex` and `buffer`');\n    }\n\n    let pubKey = keys.public.marshal();\n\n    if (decompress) {\n      pubKey = Buffer.from(secp256k1.publicKeyConvert(pubKey, false));\n    }\n\n    return format === 'buffer' ? pubKey : pubKey.toString('hex');\n  }\n\n  async verify(signature, publicKey, data) {\n    let v = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'v1';\n    return Keystore.verify(signature, publicKey, data, v);\n  }\n\n  static async verify(signature, publicKey, data) {\n    let v = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'v1';\n    const cached = verifiedCache.get(signature);\n    let res = false;\n\n    if (!cached) {\n      const verified = await verifier(v).verify(signature, publicKey, data);\n      res = verified;\n\n      if (verified) {\n        verifiedCache.set(signature, {\n          publicKey,\n          data\n        });\n      }\n    } else {\n      const compare = (cached, data, v) => {\n        let match;\n\n        if (v === 'v0') {\n          match = Buffer.compare(Buffer.alloc(30, cached), Buffer.alloc(30, data)) === 0;\n        } else {\n          match = Buffer.isBuffer(data) ? Buffer.compare(cached, data) === 0 : cached === data;\n        }\n\n        return match;\n      };\n\n      res = cached.publicKey === publicKey && compare(cached.data, data, v);\n    }\n\n    return res;\n  }\n\n}\n\nmodule.exports = Keystore;","map":{"version":3,"names":["fs","window","self","eval","level","require","crypto","secp256k1","LRU","Buffer","verifier","createStore","path","mkdirSync","recursive","verifiedCache","Keystore","constructor","input","_store","open","store","_cache","cache","Promise","resolve","reject","Error","close","hasKey","id","status","storedKey","get","undefined","e","console","error","createKey","genKeyPair","keys","generateKeyPair","err","key","decompressedKey","from","publicKeyConvert","public","marshal","publicKey","toString","privateKey","put","JSON","stringify","log","set","getKey","cachedKey","deserializedKey","parse","genPrivKey","pk","supportedKeys","unmarshalSecp256k1PrivateKey","sign","data","isBuffer","signature","getPublic","options","formats","decompress","format","indexOf","pubKey","verify","v","cached","res","verified","compare","match","alloc","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-keystore/src/keystore.js"],"sourcesContent":["'use strict'\n\nconst fs = (typeof window === 'object' || typeof self === 'object') ? null : eval('require(\"fs\")') // eslint-disable-line\nconst level = require('level')\nconst crypto = require('libp2p-crypto')\nconst secp256k1 = require('secp256k1')\nconst LRU = require('lru')\nconst Buffer = require('safe-buffer/').Buffer\nconst { verifier } = require('./verifiers')\n\nfunction createStore (path = './keystore') {\n  if (fs && fs.mkdirSync) {\n    fs.mkdirSync(path, { recursive: true })\n  }\n  return level(path)\n}\nconst verifiedCache = new LRU(1000)\n\nclass Keystore {\n  constructor (input = {}) {\n    if (typeof input === 'string') {\n      this._store = createStore(input)\n    } else if (typeof input.open === 'function') {\n      this._store = input\n    } else if (typeof input.store === 'string') {\n      this._store = createStore(input.store)\n    } else {\n      this._store = input.store || createStore()\n    }\n    this._cache = input.cache || new LRU(100)\n  }\n\n  async open () {\n    if (this._store) {\n      await this._store.open()\n      return Promise.resolve()\n    }\n    return Promise.reject(new Error('Keystore: No store found to open'))\n  }\n\n  async close () {\n    if (!this._store) return\n    await this._store.close()\n  }\n\n  async hasKey (id) {\n    if (!id) {\n      throw new Error('id needed to check a key')\n    }\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null)\n    }\n\n    let hasKey = false\n    try {\n      let storedKey = this._cache.get(id) || await this._store.get(id)\n      hasKey = storedKey !== undefined && storedKey !== null\n    } catch (e) {\n      // Catches 'Error: ENOENT: no such file or directory, open <path>'\n      console.error('Error: ENOENT: no such file or directory')\n    }\n\n    return hasKey\n  }\n\n  async createKey (id) {\n    if (!id) {\n      throw new Error('id needed to create a key')\n    }\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null)\n    }\n\n    const genKeyPair = () => new Promise((resolve, reject) => {\n      crypto.keys.generateKeyPair('secp256k1', 256, (err, key) => {\n        if (!err) {\n          resolve(key)\n        }\n        reject(err)\n      })\n    })\n\n    const keys = await genKeyPair()\n    const decompressedKey = Buffer.from(secp256k1.publicKeyConvert(keys.public.marshal(), false))\n    const key = {\n      publicKey: decompressedKey.toString('hex'),\n      privateKey: keys.marshal().toString('hex')\n    }\n\n    try {\n      await this._store.put(id, JSON.stringify(key))\n    } catch (e) {\n      console.log(e)\n    }\n    this._cache.set(id, key)\n\n    return keys\n  }\n\n  async getKey (id) {\n    if (!id) {\n      throw new Error('id needed to get a key')\n    }\n    if (!this._store) {\n      await this.open()\n    }\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null)\n    }\n\n    const cachedKey = this._cache.get(id)\n    let storedKey\n    try {\n      storedKey = cachedKey || await this._store.get(id)\n    } catch (e) {\n      // ignore ENOENT error\n    }\n\n    if (!storedKey) {\n      return\n    }\n\n    const deserializedKey = cachedKey || JSON.parse(storedKey)\n    if (!deserializedKey) {\n      return\n    }\n\n    if (!cachedKey) {\n      this._cache.set(id, deserializedKey)\n    }\n\n    const genPrivKey = (pk) => new Promise((resolve, reject) => {\n      crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(pk, (err, key) => {\n        if (!err) {\n          resolve(key)\n        }\n        reject(err)\n      })\n    })\n\n    return genPrivKey(Buffer.from(deserializedKey.privateKey, 'hex'))\n  }\n\n  async sign (key, data) {\n    if (!key) {\n      throw new Error('No signing key given')\n    }\n\n    if (!data) {\n      throw new Error('Given input data was undefined')\n    }\n\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data)\n    }\n\n    return new Promise((resolve, reject) => {\n      key.sign(data, (err, signature) => {\n        if (!err) {\n          resolve(signature.toString('hex'))\n        }\n        reject(err)\n      })\n    })\n  }\n\n  getPublic (keys, options = {}) {\n    const formats = ['hex', 'buffer']\n    const decompress = typeof options.decompress === 'undefined' ? true : options.decompress\n    const format = options.format || 'hex'\n    if (formats.indexOf(format) === -1) {\n      throw new Error('Supported formats are `hex` and `buffer`')\n    }\n    let pubKey = keys.public.marshal()\n    if (decompress) {\n      pubKey = Buffer.from(secp256k1.publicKeyConvert(pubKey, false))\n    }\n    return format === 'buffer' ? pubKey : pubKey.toString('hex')\n  }\n\n  async verify (signature, publicKey, data, v = 'v1') {\n    return Keystore.verify(signature, publicKey, data, v)\n  }\n\n  static async verify (signature, publicKey, data, v = 'v1') {\n    const cached = verifiedCache.get(signature)\n    let res = false\n    if (!cached) {\n      const verified = await verifier(v).verify(signature, publicKey, data)\n      res = verified\n      if (verified) {\n        verifiedCache.set(signature, { publicKey, data })\n      }\n    } else {\n      const compare = (cached, data, v) => {\n        let match\n        if (v === 'v0') {\n          match = Buffer.compare(Buffer.alloc(30, cached), Buffer.alloc(30, data)) === 0\n        } else {\n          match = Buffer.isBuffer(data) ? Buffer.compare(cached, data) === 0 : cached === data\n        }\n        return match\n      }\n      res = cached.publicKey === publicKey && compare(cached.data, data, v)\n    }\n    return res\n  }\n}\n\nmodule.exports = Keystore\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}