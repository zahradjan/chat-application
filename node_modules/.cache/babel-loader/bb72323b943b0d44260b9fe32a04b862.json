{"ast":null,"code":"'use strict';\n\nconst pipe = require('it-pipe');\n\nconst pushable = require('it-pushable');\n\nconst log = require('debug')('libp2p:mplex');\n\nconst abortable = require('abortable-iterator');\n\nconst Coder = require('./coder');\n\nconst restrictSize = require('./restrict-size');\n\nconst {\n  MessageTypes,\n  MessageTypeNames\n} = require('./message-types');\n\nconst createStream = require('./stream');\n\nclass Mplex {\n  /**\n   * @class\n   * @param {object} options\n   * @param {function(*)} options.onStream - Called whenever an inbound stream is created\n   * @param {function(*)} options.onStreamEnd - Called whenever a stream ends\n   * @param {AbortSignal} options.signal - An AbortController signal\n   */\n  constructor(options) {\n    options = options || {};\n    options = typeof options === 'function' ? {\n      onStream: options\n    } : options;\n    this._streamId = 0;\n    this._streams = {\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      initiators: new Map(),\n\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      receivers: new Map()\n    };\n    this._options = options;\n    /**\n     * An iterable sink\n     */\n\n    this.sink = this._createSink();\n    /**\n     * An iterable source\n     */\n\n    this.source = this._createSource();\n    /**\n     * @property {Function} onStream\n     */\n\n    this.onStream = options.onStream;\n    /**\n     * @property {Function} onStreamEnd\n     */\n\n    this.onStreamEnd = options.onStreamEnd;\n  }\n  /**\n   * Returns a Map of streams and their ids\n   *\n   * @returns {Map<number,*>}\n   */\n\n\n  get streams() {\n    // Inbound and Outbound streams may have the same ids, so we need to make those unique\n    const streams = [];\n\n    this._streams.initiators.forEach(stream => {\n      streams.push(stream);\n    });\n\n    this._streams.receivers.forEach(stream => {\n      streams.push(stream);\n    });\n\n    return streams;\n  }\n  /**\n   * Initiate a new stream with the given name. If no name is\n   * provided, the id of th stream will be used.\n   *\n   * @param {string} [name] - If name is not a string it will be cast to one\n   * @returns {Stream}\n   */\n\n\n  newStream(name) {\n    const id = this._streamId++;\n    name = name == null ? id.toString() : String(name);\n    const registry = this._streams.initiators;\n    return this._newStream({\n      id,\n      name,\n      type: 'initiator',\n      registry\n    });\n  }\n  /**\n   * Called whenever an inbound stream is created\n   *\n   * @private\n   * @param {*} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @returns {*} A muxed stream\n   */\n\n\n  _newReceiverStream(_ref) {\n    let {\n      id,\n      name\n    } = _ref;\n    const registry = this._streams.receivers;\n    return this._newStream({\n      id,\n      name,\n      type: 'receiver',\n      registry\n    });\n  }\n  /**\n   * Creates a new stream\n   *\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @param {string} options.type\n   * @param {Map<number, *>} options.registry - A map of streams to their ids\n   * @returns {*} A muxed stream\n   */\n\n\n  _newStream(_ref2) {\n    let {\n      id,\n      name,\n      type,\n      registry\n    } = _ref2;\n\n    if (registry.has(id)) {\n      throw new Error(`${type} stream ${id} already exists!`);\n    }\n\n    log('new %s stream %s %s', type, id, name);\n\n    const send = msg => {\n      if (log.enabled) {\n        log('%s stream %s %s send', type, id, name, { ...msg,\n          type: MessageTypeNames[msg.type],\n          data: msg.data && msg.data.slice()\n        });\n      }\n\n      return this.source.push(msg);\n    };\n\n    const onEnd = () => {\n      log('%s stream %s %s ended', type, id, name);\n      registry.delete(id);\n      this.onStreamEnd && this.onStreamEnd(stream);\n    };\n\n    const stream = createStream({\n      id,\n      name,\n      send,\n      type,\n      onEnd,\n      maxMsgSize: this._options.maxMsgSize\n    });\n    registry.set(id, stream);\n    return stream;\n  }\n  /**\n   * Creates a sink with an abortable source. Incoming messages will\n   * also have their size restricted. All messages will be varint decoded.\n   *\n   * @private\n   * @returns {*} Returns an iterable sink\n   */\n\n\n  _createSink() {\n    return async source => {\n      if (this._options.signal) {\n        source = abortable(source, this._options.signal);\n      }\n\n      try {\n        await pipe(source, Coder.decode, restrictSize(this._options.maxMsgSize), async source => {\n          for await (const msgs of source) {\n            for (const msg of msgs) {\n              this._handleIncoming(msg);\n            }\n          }\n        });\n      } catch (err) {\n        log('error in sink', err);\n        return this.source.end(err); // End the source with an error\n      }\n\n      this.source.end();\n    };\n  }\n  /**\n   * Creates a source that restricts outgoing message sizes\n   * and varint encodes them.\n   *\n   * @private\n   * @returns {*} An iterable source\n   */\n\n\n  _createSource() {\n    const onEnd = err => {\n      const {\n        initiators,\n        receivers\n      } = this._streams; // Abort all the things!\n\n      for (const s of initiators.values()) s.abort(err);\n\n      for (const s of receivers.values()) s.abort(err);\n    };\n\n    const source = pushable({\n      onEnd,\n      writev: true\n    });\n    return Object.assign(Coder.encode(source), {\n      push: source.push,\n      end: source.end,\n      return: source.return\n    });\n  }\n  /**\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.type\n   * @param {Uint8Array|BufferList} options.data\n   * @returns {void}\n   */\n\n\n  _handleIncoming(_ref3) {\n    let {\n      id,\n      type,\n      data\n    } = _ref3;\n\n    if (log.enabled) {\n      log('incoming message', {\n        id,\n        type: MessageTypeNames[type],\n        data: data.slice()\n      });\n    } // Create a new stream?\n\n\n    if (type === MessageTypes.NEW_STREAM && this.onStream) {\n      const stream = this._newReceiverStream({\n        id,\n        name: data.toString()\n      });\n\n      return this.onStream(stream);\n    }\n\n    const list = type & 1 ? this._streams.initiators : this._streams.receivers;\n    const stream = list.get(id);\n    if (!stream) return log('missing stream %s', id);\n\n    switch (type) {\n      case MessageTypes.MESSAGE_INITIATOR:\n      case MessageTypes.MESSAGE_RECEIVER:\n        stream.source.push(data);\n        break;\n\n      case MessageTypes.CLOSE_INITIATOR:\n      case MessageTypes.CLOSE_RECEIVER:\n        stream.close();\n        break;\n\n      case MessageTypes.RESET_INITIATOR:\n      case MessageTypes.RESET_RECEIVER:\n        stream.reset();\n        break;\n\n      default:\n        log('unknown message type %s', type);\n    }\n  }\n\n}\n\nMplex.multicodec = '/mplex/6.7.0';\nmodule.exports = Mplex;","map":{"version":3,"names":["pipe","require","pushable","log","abortable","Coder","restrictSize","MessageTypes","MessageTypeNames","createStream","Mplex","constructor","options","onStream","_streamId","_streams","initiators","Map","receivers","_options","sink","_createSink","source","_createSource","onStreamEnd","streams","forEach","stream","push","newStream","name","id","toString","String","registry","_newStream","type","_newReceiverStream","has","Error","send","msg","enabled","data","slice","onEnd","delete","maxMsgSize","set","signal","decode","msgs","_handleIncoming","err","end","s","values","abort","writev","Object","assign","encode","return","NEW_STREAM","list","get","MESSAGE_INITIATOR","MESSAGE_RECEIVER","CLOSE_INITIATOR","CLOSE_RECEIVER","close","RESET_INITIATOR","RESET_RECEIVER","reset","multicodec","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-mplex/src/mplex.js"],"sourcesContent":["'use strict'\n\nconst pipe = require('it-pipe')\nconst pushable = require('it-pushable')\nconst log = require('debug')('libp2p:mplex')\nconst abortable = require('abortable-iterator')\nconst Coder = require('./coder')\nconst restrictSize = require('./restrict-size')\nconst { MessageTypes, MessageTypeNames } = require('./message-types')\nconst createStream = require('./stream')\n\nclass Mplex {\n  /**\n   * @class\n   * @param {object} options\n   * @param {function(*)} options.onStream - Called whenever an inbound stream is created\n   * @param {function(*)} options.onStreamEnd - Called whenever a stream ends\n   * @param {AbortSignal} options.signal - An AbortController signal\n   */\n  constructor (options) {\n    options = options || {}\n    options = typeof options === 'function' ? { onStream: options } : options\n\n    this._streamId = 0\n    this._streams = {\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      initiators: new Map(),\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      receivers: new Map()\n    }\n    this._options = options\n\n    /**\n     * An iterable sink\n     */\n    this.sink = this._createSink()\n\n    /**\n     * An iterable source\n     */\n    this.source = this._createSource()\n\n    /**\n     * @property {Function} onStream\n     */\n    this.onStream = options.onStream\n\n    /**\n     * @property {Function} onStreamEnd\n     */\n    this.onStreamEnd = options.onStreamEnd\n  }\n\n  /**\n   * Returns a Map of streams and their ids\n   *\n   * @returns {Map<number,*>}\n   */\n  get streams () {\n    // Inbound and Outbound streams may have the same ids, so we need to make those unique\n    const streams = []\n    this._streams.initiators.forEach(stream => {\n      streams.push(stream)\n    })\n    this._streams.receivers.forEach(stream => {\n      streams.push(stream)\n    })\n    return streams\n  }\n\n  /**\n   * Initiate a new stream with the given name. If no name is\n   * provided, the id of th stream will be used.\n   *\n   * @param {string} [name] - If name is not a string it will be cast to one\n   * @returns {Stream}\n   */\n  newStream (name) {\n    const id = this._streamId++\n    name = name == null ? id.toString() : String(name)\n    const registry = this._streams.initiators\n    return this._newStream({ id, name, type: 'initiator', registry })\n  }\n\n  /**\n   * Called whenever an inbound stream is created\n   *\n   * @private\n   * @param {*} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @returns {*} A muxed stream\n   */\n  _newReceiverStream ({ id, name }) {\n    const registry = this._streams.receivers\n    return this._newStream({ id, name, type: 'receiver', registry })\n  }\n\n  /**\n   * Creates a new stream\n   *\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @param {string} options.type\n   * @param {Map<number, *>} options.registry - A map of streams to their ids\n   * @returns {*} A muxed stream\n   */\n  _newStream ({ id, name, type, registry }) {\n    if (registry.has(id)) {\n      throw new Error(`${type} stream ${id} already exists!`)\n    }\n    log('new %s stream %s %s', type, id, name)\n    const send = msg => {\n      if (log.enabled) {\n        log('%s stream %s %s send', type, id, name, { ...msg, type: MessageTypeNames[msg.type], data: msg.data && msg.data.slice() })\n      }\n      return this.source.push(msg)\n    }\n    const onEnd = () => {\n      log('%s stream %s %s ended', type, id, name)\n      registry.delete(id)\n      this.onStreamEnd && this.onStreamEnd(stream)\n    }\n    const stream = createStream({ id, name, send, type, onEnd, maxMsgSize: this._options.maxMsgSize })\n    registry.set(id, stream)\n    return stream\n  }\n\n  /**\n   * Creates a sink with an abortable source. Incoming messages will\n   * also have their size restricted. All messages will be varint decoded.\n   *\n   * @private\n   * @returns {*} Returns an iterable sink\n   */\n  _createSink () {\n    return async source => {\n      if (this._options.signal) {\n        source = abortable(source, this._options.signal)\n      }\n\n      try {\n        await pipe(\n          source,\n          Coder.decode,\n          restrictSize(this._options.maxMsgSize),\n          async source => {\n            for await (const msgs of source) {\n              for (const msg of msgs) {\n                this._handleIncoming(msg)\n              }\n            }\n          }\n        )\n      } catch (err) {\n        log('error in sink', err)\n        return this.source.end(err) // End the source with an error\n      }\n\n      this.source.end()\n    }\n  }\n\n  /**\n   * Creates a source that restricts outgoing message sizes\n   * and varint encodes them.\n   *\n   * @private\n   * @returns {*} An iterable source\n   */\n  _createSource () {\n    const onEnd = err => {\n      const { initiators, receivers } = this._streams\n      // Abort all the things!\n      for (const s of initiators.values()) s.abort(err)\n      for (const s of receivers.values()) s.abort(err)\n    }\n    const source = pushable({ onEnd, writev: true })\n    return Object.assign(Coder.encode(source), {\n      push: source.push,\n      end: source.end,\n      return: source.return\n    })\n  }\n\n  /**\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.type\n   * @param {Uint8Array|BufferList} options.data\n   * @returns {void}\n   */\n  _handleIncoming ({ id, type, data }) {\n    if (log.enabled) {\n      log('incoming message', { id, type: MessageTypeNames[type], data: data.slice() })\n    }\n\n    // Create a new stream?\n    if (type === MessageTypes.NEW_STREAM && this.onStream) {\n      const stream = this._newReceiverStream({ id, name: data.toString() })\n      return this.onStream(stream)\n    }\n\n    const list = type & 1 ? this._streams.initiators : this._streams.receivers\n    const stream = list.get(id)\n\n    if (!stream) return log('missing stream %s', id)\n\n    switch (type) {\n      case MessageTypes.MESSAGE_INITIATOR:\n      case MessageTypes.MESSAGE_RECEIVER:\n        stream.source.push(data)\n        break\n      case MessageTypes.CLOSE_INITIATOR:\n      case MessageTypes.CLOSE_RECEIVER:\n        stream.close()\n        break\n      case MessageTypes.RESET_INITIATOR:\n      case MessageTypes.RESET_RECEIVER:\n        stream.reset()\n        break\n      default:\n        log('unknown message type %s', type)\n    }\n  }\n}\n\nMplex.multicodec = '/mplex/6.7.0'\n\nmodule.exports = Mplex\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}