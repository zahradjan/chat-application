{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('libp2p:peer-store:address-book'), {\n  error: debug('libp2p:peer-store:address-book:err')\n});\n\nvar errcode = require('err-code');\n\nvar _require = require('multiaddr'),\n    Multiaddr = _require.Multiaddr;\n\nvar PeerId = require('peer-id');\n\nvar Book = require('./book');\n\nvar PeerRecord = require('../record/peer-record');\n\nvar _require2 = require('../errors'),\n    ERR_INVALID_PARAMETERS = _require2.codes.ERR_INVALID_PARAMETERS;\n\nvar Envelope = require('../record/envelope');\n/**\n * @typedef {import('./')} PeerStore\n */\n\n/**\n * @typedef {Object} Address\n * @property {Multiaddr} multiaddr peer multiaddr.\n * @property {boolean} isCertified obtained from a signed peer record.\n *\n * @typedef {Object} CertifiedRecord\n * @property {Uint8Array} raw raw envelope.\n * @property {number} seqNumber seq counter.\n *\n * @typedef {Object} Entry\n * @property {Address[]} addresses peer Addresses.\n * @property {CertifiedRecord} record certified peer record.\n */\n\n/**\n * @extends {Book}\n */\n\n\nvar AddressBook = /*#__PURE__*/function (_Book) {\n  _inherits(AddressBook, _Book);\n\n  var _super = _createSuper(AddressBook);\n\n  /**\n   * The AddressBook is responsible for keeping the known multiaddrs of a peer.\n   *\n   * @class\n   * @param {PeerStore} peerStore\n   */\n  function AddressBook(peerStore) {\n    var _this;\n\n    _classCallCheck(this, AddressBook);\n\n    /**\n     * PeerStore Event emitter, used by the AddressBook to emit:\n     * \"peer\" - emitted when a peer is discovered by the node.\n     * \"change:multiaddrs\" - emitted when the known multiaddrs of a peer change.\n     */\n    _this = _super.call(this, {\n      peerStore: peerStore,\n      eventName: 'change:multiaddrs',\n      eventProperty: 'multiaddrs',\n      eventTransformer: function eventTransformer(data) {\n        if (!data.addresses) {\n          return [];\n        }\n\n        return data.addresses.map(function (\n        /** @type {Address} */\n        address) {\n          return address.multiaddr;\n        });\n      }\n    });\n    /**\n     * Map known peers to their known Address Entries.\n     *\n     * @type {Map<string, Entry>}\n     */\n\n    _this.data = new Map();\n    return _this;\n  }\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   *\n   * @param {Envelope} envelope\n   * @returns {boolean}\n   */\n\n\n  _createClass(AddressBook, [{\n    key: \"consumePeerRecord\",\n    value: function consumePeerRecord(envelope) {\n      var peerRecord;\n\n      try {\n        peerRecord = PeerRecord.createFromProtobuf(envelope.payload);\n      } catch (err) {\n        log.error('invalid peer record received');\n        return false;\n      } // Verify peerId\n\n\n      if (!peerRecord.peerId.equals(envelope.peerId)) {\n        log('signing key does not match PeerId in the PeerRecord');\n        return false;\n      } // ensure the record has multiaddrs\n\n\n      if (!peerRecord.multiaddrs || !peerRecord.multiaddrs.length) {\n        return false;\n      }\n\n      var peerId = peerRecord.peerId;\n      var id = peerId.toB58String();\n      var entry = this.data.get(id) || {\n        record: undefined\n      };\n      var storedRecord = entry.record; // ensure seq is greater than, or equal to, the last received\n\n      if (storedRecord && storedRecord.seqNumber >= peerRecord.seqNumber) {\n        return false;\n      }\n\n      var addresses = this._toAddresses(peerRecord.multiaddrs, true); // Replace unsigned addresses by the new ones from the record\n      // TODO: Once we have ttls for the addresses, we should merge these in.\n\n\n      this._setData(peerId, {\n        addresses: addresses,\n        record: {\n          raw: envelope.marshal(),\n          seqNumber: peerRecord.seqNumber\n        }\n      });\n\n      log(\"stored provided peer record for \".concat(id));\n      return true;\n    }\n    /**\n     * Get the raw Envelope for a peer. Returns\n     * undefined if no Envelope is found.\n     *\n     * @param {PeerId} peerId\n     * @returns {Uint8Array|undefined}\n     */\n\n  }, {\n    key: \"getRawEnvelope\",\n    value: function getRawEnvelope(peerId) {\n      var entry = this.data.get(peerId.toB58String());\n\n      if (!entry || !entry.record || !entry.record.raw) {\n        return undefined;\n      }\n\n      return entry.record.raw;\n    }\n    /**\n     * Get an Envelope containing a PeerRecord for the given peer.\n     * Returns undefined if no record exists.\n     *\n     * @param {PeerId} peerId\n     * @returns {Promise<Envelope|void>|undefined}\n     */\n\n  }, {\n    key: \"getPeerRecord\",\n    value: function getPeerRecord(peerId) {\n      var raw = this.getRawEnvelope(peerId);\n\n      if (!raw) {\n        return undefined;\n      }\n\n      return Envelope.createFromProtobuf(raw);\n    }\n    /**\n     * Set known multiaddrs of a provided peer.\n     * This will replace previously stored multiaddrs, if available.\n     * Replacing stored multiaddrs might result in losing obtained certified addresses.\n     * If you are not sure, it's recommended to use `add` instead.\n     *\n     * @override\n     * @param {PeerId} peerId\n     * @param {Multiaddr[]} multiaddrs\n     * @returns {AddressBook}\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(peerId, multiaddrs) {\n      if (!PeerId.isPeerId(peerId)) {\n        log.error('peerId must be an instance of peer-id to store data');\n        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n      }\n\n      var addresses = this._toAddresses(multiaddrs); // Not replace multiaddrs\n\n\n      if (!addresses.length) {\n        return this;\n      }\n\n      var id = peerId.toB58String();\n      var entry = this.data.get(id); // Already knows the peer\n\n      if (entry && entry.addresses && entry.addresses.length === addresses.length) {\n        var intersection = entry.addresses.filter(function (addr) {\n          return addresses.some(function (newAddr) {\n            return addr.multiaddr.equals(newAddr.multiaddr);\n          });\n        }); // Are new addresses equal to the old ones?\n        // If yes, no changes needed!\n\n        if (intersection.length === entry.addresses.length) {\n          log(\"the addresses provided to store are equal to the already stored for \".concat(id));\n          return this;\n        }\n      }\n\n      this._setData(peerId, {\n        addresses: addresses,\n        record: entry && entry.record\n      });\n\n      log(\"stored provided multiaddrs for \".concat(id)); // Notify the existance of a new peer\n\n      if (!entry) {\n        this._ps.emit('peer', peerId);\n      }\n\n      return this;\n    }\n    /**\n     * Add known addresses of a provided peer.\n     * If the peer is not known, it is set with the given addresses.\n     *\n     * @param {PeerId} peerId\n     * @param {Multiaddr[]} multiaddrs\n     * @returns {AddressBook}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(peerId, multiaddrs) {\n      if (!PeerId.isPeerId(peerId)) {\n        log.error('peerId must be an instance of peer-id to store data');\n        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n      }\n\n      var addresses = this._toAddresses(multiaddrs);\n\n      var id = peerId.toB58String(); // No addresses to be added\n\n      if (!addresses.length) {\n        return this;\n      }\n\n      var entry = this.data.get(id);\n\n      if (entry && entry.addresses) {\n        // Add recorded uniquely to the new array (Union)\n        entry.addresses.forEach(function (addr) {\n          if (!addresses.find(function (r) {\n            return r.multiaddr.equals(addr.multiaddr);\n          })) {\n            addresses.push(addr);\n          }\n        }); // If the recorded length is equal to the new after the unique union\n        // The content is the same, no need to update.\n\n        if (entry.addresses.length === addresses.length) {\n          log(\"the addresses provided to store are already stored for \".concat(id));\n          return this;\n        }\n      }\n\n      this._setData(peerId, {\n        addresses: addresses,\n        record: entry && entry.record\n      });\n\n      log(\"added provided multiaddrs for \".concat(id)); // Notify the existance of a new peer\n\n      if (!(entry && entry.addresses)) {\n        this._ps.emit('peer', peerId);\n      }\n\n      return this;\n    }\n    /**\n     * Get the known data of a provided peer.\n     *\n     * @override\n     * @param {PeerId} peerId\n     * @returns {Address[]|undefined}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(peerId) {\n      if (!PeerId.isPeerId(peerId)) {\n        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n      }\n\n      var entry = this.data.get(peerId.toB58String());\n      return entry && entry.addresses ? _toConsumableArray(entry.addresses) : undefined;\n    }\n    /**\n     * Transforms received multiaddrs into Address.\n     *\n     * @private\n     * @param {Multiaddr[]} multiaddrs\n     * @param {boolean} [isCertified]\n     * @returns {Address[]}\n     */\n\n  }, {\n    key: \"_toAddresses\",\n    value: function _toAddresses(multiaddrs) {\n      var isCertified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!multiaddrs) {\n        log.error('multiaddrs must be provided to store data');\n        throw errcode(new Error('multiaddrs must be provided'), ERR_INVALID_PARAMETERS);\n      } // create Address for each address\n\n      /** @type {Address[]} */\n\n\n      var addresses = [];\n      multiaddrs.forEach(function (addr) {\n        if (!Multiaddr.isMultiaddr(addr)) {\n          log.error(\"multiaddr \".concat(addr, \" must be an instance of multiaddr\"));\n          throw errcode(new Error(\"multiaddr \".concat(addr, \" must be an instance of multiaddr\")), ERR_INVALID_PARAMETERS);\n        } // Guarantee no replicates\n\n\n        if (!addresses.find(function (a) {\n          return a.multiaddr.equals(addr);\n        })) {\n          addresses.push({\n            multiaddr: addr,\n            isCertified: isCertified\n          });\n        }\n      });\n      return addresses;\n    }\n    /**\n     * Get the known multiaddrs for a given peer. All returned multiaddrs\n     * will include the encapsulated `PeerId` of the peer.\n     * Returns `undefined` if there are no known multiaddrs for the given peer.\n     *\n     * @param {PeerId} peerId\n     * @param {(addresses: Address[]) => Address[]} [addressSorter]\n     * @returns {Multiaddr[]|undefined}\n     */\n\n  }, {\n    key: \"getMultiaddrsForPeer\",\n    value: function getMultiaddrsForPeer(peerId) {\n      var addressSorter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (ms) {\n        return ms;\n      };\n\n      if (!PeerId.isPeerId(peerId)) {\n        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n      }\n\n      var entry = this.data.get(peerId.toB58String());\n\n      if (!entry || !entry.addresses) {\n        return undefined;\n      }\n\n      return addressSorter(entry.addresses || []).map(function (address) {\n        var multiaddr = address.multiaddr;\n        var idString = multiaddr.getPeerId();\n        if (idString && idString === peerId.toB58String()) return multiaddr;\n        return multiaddr.encapsulate(\"/p2p/\".concat(peerId.toB58String()));\n      });\n    }\n  }]);\n\n  return AddressBook;\n}(Book);\n\nmodule.exports = AddressBook;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errcode","Multiaddr","PeerId","Book","PeerRecord","ERR_INVALID_PARAMETERS","codes","Envelope","AddressBook","peerStore","eventName","eventProperty","eventTransformer","data","addresses","map","address","multiaddr","Map","envelope","peerRecord","createFromProtobuf","payload","err","peerId","equals","multiaddrs","length","id","toB58String","entry","get","record","undefined","storedRecord","seqNumber","_toAddresses","_setData","raw","marshal","getRawEnvelope","isPeerId","Error","intersection","filter","addr","some","newAddr","_ps","emit","forEach","find","r","push","isCertified","isMultiaddr","a","addressSorter","ms","idString","getPeerId","encapsulate","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/peer-store/address-book.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:peer-store:address-book'), {\n  error: debug('libp2p:peer-store:address-book:err')\n})\nconst errcode = require('err-code')\n\nconst { Multiaddr } = require('multiaddr')\nconst PeerId = require('peer-id')\n\nconst Book = require('./book')\nconst PeerRecord = require('../record/peer-record')\n\nconst {\n  codes: { ERR_INVALID_PARAMETERS }\n} = require('../errors')\nconst Envelope = require('../record/envelope')\n\n/**\n * @typedef {import('./')} PeerStore\n */\n\n/**\n * @typedef {Object} Address\n * @property {Multiaddr} multiaddr peer multiaddr.\n * @property {boolean} isCertified obtained from a signed peer record.\n *\n * @typedef {Object} CertifiedRecord\n * @property {Uint8Array} raw raw envelope.\n * @property {number} seqNumber seq counter.\n *\n * @typedef {Object} Entry\n * @property {Address[]} addresses peer Addresses.\n * @property {CertifiedRecord} record certified peer record.\n */\n\n/**\n * @extends {Book}\n */\nclass AddressBook extends Book {\n  /**\n   * The AddressBook is responsible for keeping the known multiaddrs of a peer.\n   *\n   * @class\n   * @param {PeerStore} peerStore\n   */\n  constructor (peerStore) {\n    /**\n     * PeerStore Event emitter, used by the AddressBook to emit:\n     * \"peer\" - emitted when a peer is discovered by the node.\n     * \"change:multiaddrs\" - emitted when the known multiaddrs of a peer change.\n     */\n    super({\n      peerStore,\n      eventName: 'change:multiaddrs',\n      eventProperty: 'multiaddrs',\n      eventTransformer: (data) => {\n        if (!data.addresses) {\n          return []\n        }\n        return data.addresses.map((/** @type {Address} */ address) => address.multiaddr)\n      }\n    })\n\n    /**\n     * Map known peers to their known Address Entries.\n     *\n     * @type {Map<string, Entry>}\n     */\n    this.data = new Map()\n  }\n\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   *\n   * @param {Envelope} envelope\n   * @returns {boolean}\n   */\n  consumePeerRecord (envelope) {\n    let peerRecord\n    try {\n      peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n    } catch (err) {\n      log.error('invalid peer record received')\n      return false\n    }\n\n    // Verify peerId\n    if (!peerRecord.peerId.equals(envelope.peerId)) {\n      log('signing key does not match PeerId in the PeerRecord')\n      return false\n    }\n\n    // ensure the record has multiaddrs\n    if (!peerRecord.multiaddrs || !peerRecord.multiaddrs.length) {\n      return false\n    }\n\n    const peerId = peerRecord.peerId\n    const id = peerId.toB58String()\n    const entry = this.data.get(id) || { record: undefined }\n    const storedRecord = entry.record\n\n    // ensure seq is greater than, or equal to, the last received\n    if (storedRecord && storedRecord.seqNumber >= peerRecord.seqNumber) {\n      return false\n    }\n\n    const addresses = this._toAddresses(peerRecord.multiaddrs, true)\n\n    // Replace unsigned addresses by the new ones from the record\n    // TODO: Once we have ttls for the addresses, we should merge these in.\n    this._setData(peerId, {\n      addresses,\n      record: {\n        raw: envelope.marshal(),\n        seqNumber: peerRecord.seqNumber\n      }\n    })\n    log(`stored provided peer record for ${id}`)\n\n    return true\n  }\n\n  /**\n   * Get the raw Envelope for a peer. Returns\n   * undefined if no Envelope is found.\n   *\n   * @param {PeerId} peerId\n   * @returns {Uint8Array|undefined}\n   */\n  getRawEnvelope (peerId) {\n    const entry = this.data.get(peerId.toB58String())\n\n    if (!entry || !entry.record || !entry.record.raw) {\n      return undefined\n    }\n\n    return entry.record.raw\n  }\n\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   *\n   * @param {PeerId} peerId\n   * @returns {Promise<Envelope|void>|undefined}\n   */\n  getPeerRecord (peerId) {\n    const raw = this.getRawEnvelope(peerId)\n\n    if (!raw) {\n      return undefined\n    }\n\n    return Envelope.createFromProtobuf(raw)\n  }\n\n  /**\n   * Set known multiaddrs of a provided peer.\n   * This will replace previously stored multiaddrs, if available.\n   * Replacing stored multiaddrs might result in losing obtained certified addresses.\n   * If you are not sure, it's recommended to use `add` instead.\n   *\n   * @override\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {AddressBook}\n   */\n  set (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const addresses = this._toAddresses(multiaddrs)\n\n    // Not replace multiaddrs\n    if (!addresses.length) {\n      return this\n    }\n\n    const id = peerId.toB58String()\n    const entry = this.data.get(id)\n\n    // Already knows the peer\n    if (entry && entry.addresses && entry.addresses.length === addresses.length) {\n      const intersection = entry.addresses.filter((addr) => addresses.some((newAddr) => addr.multiaddr.equals(newAddr.multiaddr)))\n\n      // Are new addresses equal to the old ones?\n      // If yes, no changes needed!\n      if (intersection.length === entry.addresses.length) {\n        log(`the addresses provided to store are equal to the already stored for ${id}`)\n        return this\n      }\n    }\n\n    this._setData(peerId, {\n      addresses,\n      record: entry && entry.record\n    })\n    log(`stored provided multiaddrs for ${id}`)\n\n    // Notify the existance of a new peer\n    if (!entry) {\n      this._ps.emit('peer', peerId)\n    }\n\n    return this\n  }\n\n  /**\n   * Add known addresses of a provided peer.\n   * If the peer is not known, it is set with the given addresses.\n   *\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {AddressBook}\n   */\n  add (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const addresses = this._toAddresses(multiaddrs)\n    const id = peerId.toB58String()\n\n    // No addresses to be added\n    if (!addresses.length) {\n      return this\n    }\n\n    const entry = this.data.get(id)\n\n    if (entry && entry.addresses) {\n      // Add recorded uniquely to the new array (Union)\n      entry.addresses.forEach((addr) => {\n        if (!addresses.find(r => r.multiaddr.equals(addr.multiaddr))) {\n          addresses.push(addr)\n        }\n      })\n\n      // If the recorded length is equal to the new after the unique union\n      // The content is the same, no need to update.\n      if (entry.addresses.length === addresses.length) {\n        log(`the addresses provided to store are already stored for ${id}`)\n        return this\n      }\n    }\n\n    this._setData(peerId, {\n      addresses,\n      record: entry && entry.record\n    })\n\n    log(`added provided multiaddrs for ${id}`)\n\n    // Notify the existance of a new peer\n    if (!(entry && entry.addresses)) {\n      this._ps.emit('peer', peerId)\n    }\n\n    return this\n  }\n\n  /**\n   * Get the known data of a provided peer.\n   *\n   * @override\n   * @param {PeerId} peerId\n   * @returns {Address[]|undefined}\n   */\n  get (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const entry = this.data.get(peerId.toB58String())\n\n    return entry && entry.addresses ? [...entry.addresses] : undefined\n  }\n\n  /**\n   * Transforms received multiaddrs into Address.\n   *\n   * @private\n   * @param {Multiaddr[]} multiaddrs\n   * @param {boolean} [isCertified]\n   * @returns {Address[]}\n   */\n  _toAddresses (multiaddrs, isCertified = false) {\n    if (!multiaddrs) {\n      log.error('multiaddrs must be provided to store data')\n      throw errcode(new Error('multiaddrs must be provided'), ERR_INVALID_PARAMETERS)\n    }\n\n    // create Address for each address\n    /** @type {Address[]} */\n    const addresses = []\n    multiaddrs.forEach((addr) => {\n      if (!Multiaddr.isMultiaddr(addr)) {\n        log.error(`multiaddr ${addr} must be an instance of multiaddr`)\n        throw errcode(new Error(`multiaddr ${addr} must be an instance of multiaddr`), ERR_INVALID_PARAMETERS)\n      }\n\n      // Guarantee no replicates\n      if (!addresses.find((a) => a.multiaddr.equals(addr))) {\n        addresses.push({\n          multiaddr: addr,\n          isCertified\n        })\n      }\n    })\n\n    return addresses\n  }\n\n  /**\n   * Get the known multiaddrs for a given peer. All returned multiaddrs\n   * will include the encapsulated `PeerId` of the peer.\n   * Returns `undefined` if there are no known multiaddrs for the given peer.\n   *\n   * @param {PeerId} peerId\n   * @param {(addresses: Address[]) => Address[]} [addressSorter]\n   * @returns {Multiaddr[]|undefined}\n   */\n  getMultiaddrsForPeer (peerId, addressSorter = (ms) => ms) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const entry = this.data.get(peerId.toB58String())\n    if (!entry || !entry.addresses) {\n      return undefined\n    }\n\n    return addressSorter(\n      entry.addresses || []\n    ).map((address) => {\n      const multiaddr = address.multiaddr\n\n      const idString = multiaddr.getPeerId()\n      if (idString && idString === peerId.toB58String()) return multiaddr\n\n      return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`)\n    })\n  }\n}\n\nmodule.exports = AddressBook\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}