{"ast":null,"code":"import _regeneratorRuntime from\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";import _asyncToGenerator from\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import _classCallCheck from\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/esm/createClass.js\";import OrbitDB from\"orbit-db\";import IPFS from\"ipfs\";import{makeAutoObservable}from\"mobx\";var DataStore=/*#__PURE__*/function(){function DataStore(rootStore){_classCallCheck(this,DataStore);this.rootStore=rootStore;this.peers=[];makeAutoObservable(this);}_createClass(DataStore,[{key:\"init\",value:function(){var _init=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(){var dbConfig,ipfsConfig;return _regeneratorRuntime().wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(this.rootStore.sessionStore.isAuthenticated()){_context.next=2;break;}throw Error(\"User is not defined\");case 2:if(!(this.ipfsNode!==undefined)){_context.next=4;break;}return _context.abrupt(\"return\");case 4:if(!(this.orbitDb!==undefined)){_context.next=6;break;}return _context.abrupt(\"return\");case 6:dbConfig={// If database doesn't exist, create it\ncreate:true,// Don't wait to load from the network\nsync:true,// directory: `/orbitdb/decentio-orbitdb-chat-${Math.random()}}`,\n// Load only the local version of the database\nlocalOnly:false,// Allow anyone to write to the database,\n// otherwise only the creator of the database can write\naccessController:{write:[\"*\"]}};ipfsConfig={// preload: { enabled: false },\nrelay:{enabled:true,hop:{enabled:true,active:true}},// libp2p: {\n//   config: {\n//     dht: {\n//       enabled: true,\n//     },\n//     modules: {\n//       transport: [\"WebRTCStar\", \"WebSockets\"],\n//     },\n//     // transport: {\n//     //   WebRTCStar: {\n//     //     wrtc,\n//     //   },\n//     // },\n//   },\n// },\n// peerDiscovery: {\n//   autoDial: true, // Auto connect to discovered peers (limited by ConnectionManager minPeers)\n//   mdns: {\n//     // mdns options\n//     interval: 1000, // ms\n//     enabled: true,\n//   },\n//   webRTCStar: {\n//     // webrtc-star options\n//     interval: 1000, // ms\n//     enabled: false,\n//   },\n//   // .. other discovery module options.\n// },\n// Prevents large data transfers\n//TODO: nejak oddelit at to neni random ale treba username nebo neco\nrepo:\"/orbitdb/decentio-orbitdb-chat-ipfs-\".concat(this.rootStore.sessionStore._user,\"}\"),EXPERIMENTAL:{pubsub:true},config:{Addresses:{Swarm:[//       // Use IPFS dev signal server\n//       // Websocket:\n// \"/dns4/ws-star-signal-1.servep2p.com/tcp/443/wss/p2p-websocket-star\",\n// \"/dns4/ws-star-signal-2.servep2p.com/tcp/443/wss/p2p-websocket-star\",\n// \"/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star\",\n// WebRTC:\n// \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n\"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\"/dns4/webrtc-star.discovery.libp2p.io/tcp/443/wss/p2p-webrtc-star/\",\"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star\",\"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star\"// // \"/ip4/0.0.0.0/tcp/4002\",\n// \"/ip4/127.0.0.1/tcp/4003/ws\",\n// \"/libp2p-webrtc-star/dns4/star-signal.cloud.ipfs.team/wss\",\n// \"/dns4/star-signal.cloud.ipfs.team/wss/p2p-webrtc-star\",\n//       // Use local signal server\n// \"/ip4/0.0.0.0/tcp/4011/ws\",\n// \"/ip6/::/tcp/4011/ws\",\n]},Bootstrap:[// \"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n// \"/dns4/webrtc-star.discovery.libp2p.io/tcp/443/wss/p2p-webrtc-star/\",\n// \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star\",\n// \"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star\",\n]}};_context.next=10;return this.start(ipfsConfig,dbConfig);case 10:case\"end\":return _context.stop();}}},_callee,this);}));function init(){return _init.apply(this,arguments);}return init;}()},{key:\"start\",value:function(){var _start=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(ipfsConf,orbitDbconf){return _regeneratorRuntime().wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:console.log(this.ipfsNode);console.log(this.orbitDb);_context2.next=4;return this.startIpfsNode(ipfsConf);case 4:_context2.next=6;return this.startOrbitDb(orbitDbconf);case 6:console.log(this.ipfsNode);console.log(this.orbitDb);_context2.next=10;return this.getPeerId();case 10:this.peerId=_context2.sent;case 11:case\"end\":return _context2.stop();}}},_callee2,this);}));function start(_x,_x2){return _start.apply(this,arguments);}return start;}()},{key:\"onPeerConnect\",value:function(){var _onPeerConnect=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(connection){return _regeneratorRuntime().wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:console.log(\"Peer connected:\"+connection.remotePeer._idB58String);case 1:case\"end\":return _context3.stop();}}},_callee3);}));function onPeerConnect(_x3){return _onPeerConnect.apply(this,arguments);}return onPeerConnect;}()},{key:\"getPeerId\",value:function(){var _getPeerId=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(){var peerInfo;return _regeneratorRuntime().wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(!(this.ipfsNode===undefined)){_context4.next=2;break;}throw Error(\"IPFS Node not defined\");case 2:_context4.next=4;return this.ipfsNode.id();case 4:peerInfo=_context4.sent;return _context4.abrupt(\"return\",peerInfo.id);case 6:case\"end\":return _context4.stop();}}},_callee4,this);}));function getPeerId(){return _getPeerId.apply(this,arguments);}return getPeerId;}()},{key:\"connectToPeer\",value:function(){var _connectToPeer=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(multiaddr){var protocol,_args5=arguments;return _regeneratorRuntime().wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:protocol=_args5.length>1&&_args5[1]!==undefined?_args5[1]:\"/dnsaddr/bootstrap.libp2p.io/p2p/\";_context5.prev=1;_context5.next=4;return this.ipfsNode.swarm.connect(protocol+multiaddr);case 4:_context5.next=11;break;case 6:_context5.prev=6;_context5.t0=_context5[\"catch\"](1);console.log(_context5.t0);_context5.next=11;return this.ipfsNode.swarm.connect(protocol+multiaddr);case 11:case\"end\":return _context5.stop();}}},_callee5,this,[[1,6]]);}));function connectToPeer(_x4){return _connectToPeer.apply(this,arguments);}return connectToPeer;}()},{key:\"startIpfsNode\",value:function(){var _startIpfsNode=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(ipfsConf){return _regeneratorRuntime().wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:_context6.next=2;return IPFS.create(ipfsConf);case 2:this.ipfsNode=_context6.sent;case 3:case\"end\":return _context6.stop();}}},_callee6,this);}));function startIpfsNode(_x5){return _startIpfsNode.apply(this,arguments);}return startIpfsNode;}()},{key:\"startOrbitDb\",value:function(){var _startOrbitDb=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(orbitDbconf){return _regeneratorRuntime().wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:_context7.next=2;return OrbitDB.createInstance(this.ipfsNode,orbitDbconf);case 2:this.orbitDb=_context7.sent;case 3:case\"end\":return _context7.stop();}}},_callee7,this);}));function startOrbitDb(_x6){return _startOrbitDb.apply(this,arguments);}return startOrbitDb;}()},{key:\"getIpfsPeers\",value:function(){var _getIpfsPeers=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(){var peers;return _regeneratorRuntime().wrap(function _callee8$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:_context8.next=2;return this.ipfsNode.swarm.peers();case 2:peers=_context8.sent;return _context8.abrupt(\"return\",peers);case 4:case\"end\":return _context8.stop();}}},_callee8,this);}));function getIpfsPeers(){return _getIpfsPeers.apply(this,arguments);}return getIpfsPeers;}()},{key:\"handleStop\",value:function(){var _handleStop=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(){return _regeneratorRuntime().wrap(function _callee9$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:_context9.next=2;return this.orbitDb.disconnect();case 2:_context9.next=4;return this.ipfsNode.stop();case 4:delete this.orbitDb;delete this.ipfsNode;case 6:case\"end\":return _context9.stop();}}},_callee9,this);}));function handleStop(){return _handleStop.apply(this,arguments);}return handleStop;}()}]);return DataStore;}();export{DataStore as default};","map":{"version":3,"names":["OrbitDB","IPFS","makeAutoObservable","DataStore","rootStore","peers","sessionStore","isAuthenticated","Error","ipfsNode","undefined","orbitDb","dbConfig","create","sync","localOnly","accessController","write","ipfsConfig","relay","enabled","hop","active","repo","_user","EXPERIMENTAL","pubsub","config","Addresses","Swarm","Bootstrap","start","ipfsConf","orbitDbconf","console","log","startIpfsNode","startOrbitDb","getPeerId","peerId","connection","remotePeer","_idB58String","id","peerInfo","multiaddr","protocol","swarm","connect","createInstance","disconnect","stop"],"sources":["C:/Users/zajan/GitHub/chatApplication/src/data/store/DataStore.js"],"sourcesContent":["import OrbitDB from \"orbit-db\";\r\nimport IPFS from \"ipfs\";\r\nimport { makeAutoObservable } from \"mobx\";\r\nexport default class DataStore {\r\n  ipfsNode;\r\n  orbitDb;\r\n  peerId;\r\n  constructor(rootStore) {\r\n    this.rootStore = rootStore;\r\n    this.peers = [];\r\n    makeAutoObservable(this);\r\n  }\r\n\r\n  async init() {\r\n    if (!this.rootStore.sessionStore.isAuthenticated()) throw Error(\"User is not defined\");\r\n    if (this.ipfsNode !== undefined) return;\r\n    if (this.orbitDb !== undefined) return;\r\n\r\n    const dbConfig = {\r\n      // If database doesn't exist, create it\r\n      create: true,\r\n      // Don't wait to load from the network\r\n      sync: true,\r\n      // directory: `/orbitdb/decentio-orbitdb-chat-${Math.random()}}`,\r\n      // Load only the local version of the database\r\n      localOnly: false,\r\n      // Allow anyone to write to the database,\r\n      // otherwise only the creator of the database can write\r\n      accessController: {\r\n        write: [\"*\"],\r\n      },\r\n    };\r\n    const ipfsConfig = {\r\n      // preload: { enabled: false },\r\n      relay: { enabled: true, hop: { enabled: true, active: true } },\r\n      // libp2p: {\r\n      //   config: {\r\n      //     dht: {\r\n      //       enabled: true,\r\n      //     },\r\n      //     modules: {\r\n      //       transport: [\"WebRTCStar\", \"WebSockets\"],\r\n      //     },\r\n      //     // transport: {\r\n      //     //   WebRTCStar: {\r\n      //     //     wrtc,\r\n      //     //   },\r\n      //     // },\r\n      //   },\r\n      // },\r\n      // peerDiscovery: {\r\n      //   autoDial: true, // Auto connect to discovered peers (limited by ConnectionManager minPeers)\r\n      //   mdns: {\r\n      //     // mdns options\r\n      //     interval: 1000, // ms\r\n      //     enabled: true,\r\n      //   },\r\n      //   webRTCStar: {\r\n      //     // webrtc-star options\r\n      //     interval: 1000, // ms\r\n      //     enabled: false,\r\n      //   },\r\n      //   // .. other discovery module options.\r\n      // },\r\n      // Prevents large data transfers\r\n      //TODO: nejak oddelit at to neni random ale treba username nebo neco\r\n      repo: `/orbitdb/decentio-orbitdb-chat-ipfs-${this.rootStore.sessionStore._user}}`,\r\n      EXPERIMENTAL: {\r\n        pubsub: true,\r\n      },\r\n\r\n      config: {\r\n        Addresses: {\r\n          Swarm: [\r\n            //       // Use IPFS dev signal server\r\n            //       // Websocket:\r\n            // \"/dns4/ws-star-signal-1.servep2p.com/tcp/443/wss/p2p-websocket-star\",\r\n            // \"/dns4/ws-star-signal-2.servep2p.com/tcp/443/wss/p2p-websocket-star\",\r\n            // \"/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star\",\r\n            // WebRTC:\r\n            // \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\r\n            \"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\r\n            \"/dns4/webrtc-star.discovery.libp2p.io/tcp/443/wss/p2p-webrtc-star/\",\r\n            \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star\",\r\n            \"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star\",\r\n            // // \"/ip4/0.0.0.0/tcp/4002\",\r\n            // \"/ip4/127.0.0.1/tcp/4003/ws\",\r\n            // \"/libp2p-webrtc-star/dns4/star-signal.cloud.ipfs.team/wss\",\r\n            // \"/dns4/star-signal.cloud.ipfs.team/wss/p2p-webrtc-star\",\r\n            //       // Use local signal server\r\n            // \"/ip4/0.0.0.0/tcp/4011/ws\",\r\n            // \"/ip6/::/tcp/4011/ws\",\r\n          ],\r\n        },\r\n        Bootstrap: [\r\n          // \"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\r\n          // \"/dns4/webrtc-star.discovery.libp2p.io/tcp/443/wss/p2p-webrtc-star/\",\r\n          // \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star\",\r\n          // \"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star\",\r\n        ],\r\n      },\r\n    };\r\n\r\n    await this.start(ipfsConfig, dbConfig);\r\n  }\r\n\r\n  async start(ipfsConf, orbitDbconf) {\r\n    console.log(this.ipfsNode);\r\n    console.log(this.orbitDb);\r\n    await this.startIpfsNode(ipfsConf);\r\n    await this.startOrbitDb(orbitDbconf);\r\n    console.log(this.ipfsNode);\r\n    console.log(this.orbitDb);\r\n    this.peerId = await this.getPeerId();\r\n    // setInterval(async () => {\r\n    //   const peers = await this.getIpfsPeers();\r\n    //   console.log(peers);\r\n    //   // await peers.map(async (peerId) => {\r\n    //   //   try {\r\n    //   //     await this.connectToPeer(peerId.peer);\r\n    //   //   } catch {}\r\n    //   // });\r\n    //   // const topics = await this.ipfsNode.pubsub.ls();\r\n    //   // console.log(topics);\r\n    // }, 10000);\r\n    // this.ipfsNode.libp2p.connectionManager.on(\"peer:connect\", this.onPeerConnect.bind(this));\r\n  }\r\n  async onPeerConnect(connection) {\r\n    console.log(\"Peer connected:\" + connection.remotePeer._idB58String);\r\n  }\r\n\r\n  async getPeerId() {\r\n    if (this.ipfsNode === undefined) throw Error(\"IPFS Node not defined\");\r\n    const peerInfo = await this.ipfsNode.id();\r\n    return peerInfo.id;\r\n  }\r\n\r\n  async connectToPeer(multiaddr, protocol = \"/dnsaddr/bootstrap.libp2p.io/p2p/\") {\r\n    try {\r\n      await this.ipfsNode.swarm.connect(protocol + multiaddr);\r\n    } catch (err) {\r\n      console.log(err);\r\n      await this.ipfsNode.swarm.connect(protocol + multiaddr);\r\n    }\r\n  }\r\n\r\n  async startIpfsNode(ipfsConf) {\r\n    this.ipfsNode = await IPFS.create(ipfsConf);\r\n  }\r\n  async startOrbitDb(orbitDbconf) {\r\n    this.orbitDb = await OrbitDB.createInstance(this.ipfsNode, orbitDbconf);\r\n  }\r\n  async getIpfsPeers() {\r\n    const peers = await this.ipfsNode.swarm.peers();\r\n    // console.log(peers);\r\n    return peers;\r\n  }\r\n\r\n  async handleStop() {\r\n    await this.orbitDb.disconnect();\r\n    await this.ipfsNode.stop();\r\n    delete this.orbitDb;\r\n    delete this.ipfsNode;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}