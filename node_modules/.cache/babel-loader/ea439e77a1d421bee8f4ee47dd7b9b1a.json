{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar PeerId = require('peer-id');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key,\n    Errors = _require.Errors;\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('ipfs:ipns:publisher'), {\n  error: debug('ipfs:ipns:publisher:error')\n});\n\nvar _require2 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require2.toString;\n\nvar _require3 = require('uint8arrays/equals'),\n    uint8ArrayEquals = _require3.equals;\n\nvar ipns = require('ipns');\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n */\n\n\nvar ERR_NOT_FOUND = Errors.notFoundError().code;\nvar defaultRecordLifetime = 60 * 60 * 1000; // IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\n\nvar IpnsPublisher = /*#__PURE__*/function () {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  function IpnsPublisher(routing, datastore) {\n    _classCallCheck(this, IpnsPublisher);\n\n    this._routing = routing;\n    this._datastore = datastore;\n  }\n  /**\n   * Publish record with a eol\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n\n\n  _createClass(IpnsPublisher, [{\n    key: \"publishWithEOL\",\n    value: function () {\n      var _publishWithEOL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(privKey, value, lifetime) {\n        var peerId, record;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!privKey || !privKey.bytes)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n\n              case 2:\n                _context.next = 4;\n                return PeerId.createFromPrivKey(privKey.bytes);\n\n              case 4:\n                peerId = _context.sent;\n                _context.next = 7;\n                return this._updateOrCreateRecord(privKey, value, lifetime, peerId);\n\n              case 7:\n                record = _context.sent;\n                return _context.abrupt(\"return\", this._putRecordToRouting(record, peerId));\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function publishWithEOL(_x, _x2, _x3) {\n        return _publishWithEOL.apply(this, arguments);\n      }\n\n      return publishWithEOL;\n    }()\n    /**\n     * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n     *\n     * @param {PrivateKey} privKey\n     * @param {Uint8Array} value\n     */\n\n  }, {\n    key: \"publish\",\n    value: function publish(privKey, value) {\n      return this.publishWithEOL(privKey, value, defaultRecordLifetime);\n    }\n    /**\n     * @param {IPNSEntry} record\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"_putRecordToRouting\",\n    value: function () {\n      var _putRecordToRouting2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(record, peerId) {\n        var errMsg, publicKey, embedPublicKeyRecord, keys;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (PeerId.isPeerId(peerId)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                errMsg = 'peerId received is not valid';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n\n              case 4:\n                // @ts-ignore - accessing private property isn't allowed\n                publicKey = peerId._pubKey;\n                _context2.next = 7;\n                return ipns.embedPublicKey(publicKey, record);\n\n              case 7:\n                embedPublicKeyRecord = _context2.sent;\n                keys = ipns.getIdKeys(peerId.toBytes());\n                _context2.next = 11;\n                return this._publishEntry(keys.routingKey, embedPublicKeyRecord || record);\n\n              case 11:\n                _context2.next = 13;\n                return this._publishPublicKey(keys.routingPubKey, publicKey);\n\n              case 13:\n                return _context2.abrupt(\"return\", embedPublicKeyRecord || record);\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _putRecordToRouting(_x4, _x5) {\n        return _putRecordToRouting2.apply(this, arguments);\n      }\n\n      return _putRecordToRouting;\n    }()\n    /**\n     * @param {Key} key\n     * @param {IPNSEntry} entry\n     */\n\n  }, {\n    key: \"_publishEntry\",\n    value: function () {\n      var _publishEntry2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key, entry) {\n        var k, errMsg, entryData, res, _errMsg;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                k = Key.asKey(key);\n\n                if (k) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                errMsg = 'datastore key does not have a valid format';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n\n              case 5:\n                _context3.prev = 5;\n                // Marshal record\n                entryData = ipns.marshal(entry);\n                _context3.next = 13;\n                break;\n\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](5);\n                log.error(_context3.t0);\n                throw _context3.t0;\n\n              case 13:\n                _context3.prev = 13;\n                _context3.next = 16;\n                return this._routing.put(k.uint8Array(), entryData);\n\n              case 16:\n                res = _context3.sent;\n                log(\"ipns record for \".concat(uint8ArrayToString(k.uint8Array(), 'base64'), \" was stored in the routing\"));\n                return _context3.abrupt(\"return\", res);\n\n              case 21:\n                _context3.prev = 21;\n                _context3.t1 = _context3[\"catch\"](13);\n                _errMsg = \"ipns record for \".concat(uint8ArrayToString(k.uint8Array(), 'base64'), \" could not be stored in the routing\");\n                log.error(_errMsg);\n                log.error(_context3.t1);\n                throw errcode(new Error(_errMsg), 'ERR_PUTTING_TO_ROUTING');\n\n              case 27:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[5, 9], [13, 21]]);\n      }));\n\n      function _publishEntry(_x6, _x7) {\n        return _publishEntry2.apply(this, arguments);\n      }\n\n      return _publishEntry;\n    }()\n    /**\n     * @param {Key} key\n     * @param {PublicKey} publicKey\n     */\n\n  }, {\n    key: \"_publishPublicKey\",\n    value: function () {\n      var _publishPublicKey2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(key, publicKey) {\n        var k, errMsg, _errMsg2, res, _errMsg3;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                k = Key.asKey(key);\n\n                if (k) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                errMsg = 'datastore key does not have a valid format';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n\n              case 5:\n                if (!(!publicKey || !publicKey.bytes)) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                _errMsg2 = 'one or more of the provided parameters are not defined';\n                log.error(_errMsg2);\n                throw errcode(new Error(_errMsg2), 'ERR_UNDEFINED_PARAMETER');\n\n              case 9:\n                _context4.prev = 9;\n                _context4.next = 12;\n                return this._routing.put(k.uint8Array(), publicKey.bytes);\n\n              case 12:\n                res = _context4.sent;\n                log(\"public key for \".concat(uint8ArrayToString(k.uint8Array(), 'base64'), \" was stored in the routing\"));\n                return _context4.abrupt(\"return\", res);\n\n              case 17:\n                _context4.prev = 17;\n                _context4.t0 = _context4[\"catch\"](9);\n                _errMsg3 = \"public key for \".concat(uint8ArrayToString(k.uint8Array(), 'base64'), \" could not be stored in the routing\");\n                log.error(_errMsg3);\n                log.error(_context4.t0);\n                throw errcode(new Error(_errMsg3), 'ERR_PUTTING_TO_ROUTING');\n\n              case 23:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[9, 17]]);\n      }));\n\n      function _publishPublicKey(_x8, _x9) {\n        return _publishPublicKey2.apply(this, arguments);\n      }\n\n      return _publishPublicKey;\n    }()\n    /**\n     * Returns the record this node has published corresponding to the given peer ID.\n     *\n     * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n     *\n     * @param {PeerId} peerId\n     * @param {object} options\n     * @param {boolean} [options.checkRouting]\n     */\n\n  }, {\n    key: \"_getPublished\",\n    value: function () {\n      var _getPublished2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(peerId) {\n        var options,\n            errMsg,\n            checkRouting,\n            dsVal,\n            _errMsg4,\n            keys,\n            res,\n            _args5 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                options = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};\n\n                if (PeerId.isPeerId(peerId)) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                errMsg = 'peerId received is not valid';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n\n              case 5:\n                checkRouting = options.checkRouting !== false;\n                _context5.prev = 6;\n                _context5.next = 9;\n                return this._datastore.get(ipns.getLocalKey(peerId.id));\n\n              case 9:\n                dsVal = _context5.sent;\n                return _context5.abrupt(\"return\", this._unmarshalData(dsVal));\n\n              case 13:\n                _context5.prev = 13;\n                _context5.t0 = _context5[\"catch\"](6);\n\n                if (!(_context5.t0.code !== ERR_NOT_FOUND)) {\n                  _context5.next = 19;\n                  break;\n                }\n\n                _errMsg4 = \"unexpected error getting the ipns record \".concat(peerId.id, \" from datastore\");\n                log.error(_errMsg4);\n                throw errcode(new Error(_errMsg4), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');\n\n              case 19:\n                if (checkRouting) {\n                  _context5.next = 21;\n                  break;\n                }\n\n                throw errcode(_context5.t0, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED');\n\n              case 21:\n                _context5.prev = 21;\n                keys = ipns.getIdKeys(peerId.toBytes());\n                _context5.next = 25;\n                return this._routing.get(keys.routingKey.uint8Array());\n\n              case 25:\n                res = _context5.sent;\n                return _context5.abrupt(\"return\", this._unmarshalData(res));\n\n              case 29:\n                _context5.prev = 29;\n                _context5.t1 = _context5[\"catch\"](21);\n                log.error(_context5.t1);\n                throw _context5.t1;\n\n              case 33:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[6, 13], [21, 29]]);\n      }));\n\n      function _getPublished(_x10) {\n        return _getPublished2.apply(this, arguments);\n      }\n\n      return _getPublished;\n    }()\n    /**\n     * @param {Uint8Array} data\n     */\n\n  }, {\n    key: \"_unmarshalData\",\n    value: function _unmarshalData(data) {\n      try {\n        return ipns.unmarshal(data);\n      } catch (err) {\n        throw errcode(err, 'ERR_INVALID_RECORD_DATA');\n      }\n    }\n    /**\n     * @param {PrivateKey} privKey\n     * @param {Uint8Array} value\n     * @param {number} lifetime\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"_updateOrCreateRecord\",\n    value: function () {\n      var _updateOrCreateRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(privKey, value, lifetime, peerId) {\n        var errMsg, getPublishedOptions, record, _errMsg5, seqNumber, entryData, _errMsg6, data, _errMsg7;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (PeerId.isPeerId(peerId)) {\n                  _context6.next = 4;\n                  break;\n                }\n\n                errMsg = 'peerId received is not valid';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n\n              case 4:\n                getPublishedOptions = {\n                  checkRouting: true\n                };\n                _context6.prev = 5;\n                _context6.next = 8;\n                return this._getPublished(peerId, getPublishedOptions);\n\n              case 8:\n                record = _context6.sent;\n                _context6.next = 17;\n                break;\n\n              case 11:\n                _context6.prev = 11;\n                _context6.t0 = _context6[\"catch\"](5);\n\n                if (!(_context6.t0.code !== ERR_NOT_FOUND)) {\n                  _context6.next = 17;\n                  break;\n                }\n\n                _errMsg5 = \"unexpected error when determining the last published IPNS record for \".concat(peerId.id, \" \").concat(_context6.t0.stack);\n                log.error(_errMsg5);\n                throw errcode(new Error(_errMsg5), 'ERR_DETERMINING_PUBLISHED_RECORD');\n\n              case 17:\n                // Determinate the record sequence number\n                seqNumber = 0n;\n\n                if (record && record.sequence !== undefined) {\n                  seqNumber = !uint8ArrayEquals(record.value, value) ? BigInt(record.sequence) + 1n : BigInt(record.sequence);\n                }\n\n                _context6.prev = 19;\n                _context6.next = 22;\n                return ipns.create(privKey, value, seqNumber, lifetime);\n\n              case 22:\n                entryData = _context6.sent;\n                _context6.next = 30;\n                break;\n\n              case 25:\n                _context6.prev = 25;\n                _context6.t1 = _context6[\"catch\"](19);\n                _errMsg6 = \"ipns record for \".concat(value, \" could not be created\");\n                log.error(_context6.t1);\n                throw errcode(new Error(_errMsg6), 'ERR_CREATING_IPNS_RECORD');\n\n              case 30:\n                _context6.prev = 30;\n                // Marshal record\n                data = ipns.marshal(entryData); // Store the new record\n\n                _context6.next = 34;\n                return this._datastore.put(ipns.getLocalKey(peerId.id), data);\n\n              case 34:\n                log(\"ipns record for \".concat(uint8ArrayToString(value, 'base32'), \" was stored in the datastore\"));\n                return _context6.abrupt(\"return\", entryData);\n\n              case 38:\n                _context6.prev = 38;\n                _context6.t2 = _context6[\"catch\"](30);\n                _errMsg7 = \"ipns record for \".concat(value, \" could not be stored in the datastore\");\n                log.error(_errMsg7);\n                throw errcode(new Error(_errMsg7), 'ERR_STORING_IN_DATASTORE');\n\n              case 43:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[5, 11], [19, 25], [30, 38]]);\n      }));\n\n      function _updateOrCreateRecord(_x11, _x12, _x13, _x14) {\n        return _updateOrCreateRecord2.apply(this, arguments);\n      }\n\n      return _updateOrCreateRecord;\n    }()\n  }]);\n\n  return IpnsPublisher;\n}();\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;\nexports = module.exports = IpnsPublisher;","map":{"version":3,"names":["PeerId","require","Key","Errors","errcode","debug","log","Object","assign","error","uint8ArrayToString","toString","uint8ArrayEquals","equals","ipns","ERR_NOT_FOUND","notFoundError","code","defaultRecordLifetime","IpnsPublisher","routing","datastore","_routing","_datastore","privKey","value","lifetime","bytes","Error","createFromPrivKey","peerId","_updateOrCreateRecord","record","_putRecordToRouting","publishWithEOL","isPeerId","errMsg","publicKey","_pubKey","embedPublicKey","embedPublicKeyRecord","keys","getIdKeys","toBytes","_publishEntry","routingKey","_publishPublicKey","routingPubKey","key","entry","k","asKey","entryData","marshal","put","uint8Array","res","options","checkRouting","get","getLocalKey","id","dsVal","_unmarshalData","data","unmarshal","err","getPublishedOptions","_getPublished","stack","seqNumber","sequence","undefined","BigInt","create","exports","module"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/ipns/publisher.js"],"sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { Key, Errors } = require('interface-datastore')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns:publisher'), {\n  error: debug('ipfs:ipns:publisher:error')\n})\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\n\nconst ipns = require('ipns')\n\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n */\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst defaultRecordLifetime = 60 * 60 * 1000\n\n// IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\nclass IpnsPublisher {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor (routing, datastore) {\n    this._routing = routing\n    this._datastore = datastore\n  }\n\n  /**\n   * Publish record with a eol\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n  async publishWithEOL (privKey, value, lifetime) {\n    if (!privKey || !privKey.bytes) {\n      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY')\n    }\n\n    const peerId = await PeerId.createFromPrivKey(privKey.bytes)\n    const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId)\n\n    return this._putRecordToRouting(record, peerId)\n  }\n\n  /**\n   * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n  publish (privKey, value) {\n    return this.publishWithEOL(privKey, value, defaultRecordLifetime)\n  }\n\n  /**\n   * @param {IPNSEntry} record\n   * @param {PeerId} peerId\n   */\n  async _putRecordToRouting (record, peerId) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    // @ts-ignore - accessing private property isn't allowed\n    const publicKey = peerId._pubKey\n    const embedPublicKeyRecord = await ipns.embedPublicKey(publicKey, record)\n    const keys = ipns.getIdKeys(peerId.toBytes())\n\n    await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record)\n\n    // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n    // We will be able to deprecate this part in the future, since the public keys will be only\n    // in IPNS record and the peerId.\n    await this._publishPublicKey(keys.routingPubKey, publicKey)\n\n    return embedPublicKeyRecord || record\n  }\n\n  /**\n   * @param {Key} key\n   * @param {IPNSEntry} entry\n   */\n  async _publishEntry (key, entry) {\n    const k = Key.asKey(key)\n\n    if (!k) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    let entryData\n    try {\n      // Marshal record\n      entryData = ipns.marshal(entry)\n    } catch (err) {\n      log.error(err)\n\n      throw err\n    }\n\n    // Add record to routing (buffer key)\n    try {\n      const res = await this._routing.put(k.uint8Array(), entryData)\n      log(`ipns record for ${uint8ArrayToString(k.uint8Array(), 'base64')} was stored in the routing`)\n\n      return res\n    } catch (err) {\n      const errMsg = `ipns record for ${uint8ArrayToString(k.uint8Array(), 'base64')} could not be stored in the routing`\n      log.error(errMsg)\n      log.error(err)\n\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING')\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {PublicKey} publicKey\n   */\n  async _publishPublicKey (key, publicKey) {\n    const k = Key.asKey(key)\n\n    if (!k) {\n      const errMsg = 'datastore key does not have a valid format'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!publicKey || !publicKey.bytes) {\n      const errMsg = 'one or more of the provided parameters are not defined'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER')\n    }\n\n    // Add public key to routing (buffer key)\n    try {\n      const res = await this._routing.put(k.uint8Array(), publicKey.bytes)\n      log(`public key for ${uint8ArrayToString(k.uint8Array(), 'base64')} was stored in the routing`)\n\n      return res\n    } catch (err) {\n      const errMsg = `public key for ${uint8ArrayToString(k.uint8Array(), 'base64')} could not be stored in the routing`\n      log.error(errMsg)\n      log.error(err)\n\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING')\n    }\n  }\n\n  /**\n   * Returns the record this node has published corresponding to the given peer ID.\n   *\n   * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n   *\n   * @param {PeerId} peerId\n   * @param {object} options\n   * @param {boolean} [options.checkRouting]\n   */\n  async _getPublished (peerId, options = {}) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const checkRouting = options.checkRouting !== false\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id))\n\n      // unmarshal data\n      return this._unmarshalData(dsVal)\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE')\n      }\n\n      if (!checkRouting) {\n        throw errcode(err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED')\n      }\n\n      // Try to get from routing\n      try {\n        const keys = ipns.getIdKeys(peerId.toBytes())\n        const res = await this._routing.get(keys.routingKey.uint8Array())\n\n        // unmarshal data\n        return this._unmarshalData(res)\n      } catch (err) {\n        log.error(err)\n\n        throw err\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  _unmarshalData (data) {\n    try {\n      return ipns.unmarshal(data)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA')\n    }\n  }\n\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {PeerId} peerId\n   */\n  async _updateOrCreateRecord (privKey, value, lifetime, peerId) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    }\n\n    let record\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions)\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id} ${err.stack}`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD')\n      }\n    }\n\n    // Determinate the record sequence number\n    let seqNumber = 0n\n\n    if (record && record.sequence !== undefined) {\n      seqNumber = !uint8ArrayEquals(record.value, value) ? BigInt(record.sequence) + 1n : BigInt(record.sequence)\n    }\n\n    let entryData\n\n    try {\n      // Create record\n      entryData = await ipns.create(privKey, value, seqNumber, lifetime)\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be created`\n\n      log.error(err)\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD')\n    }\n\n    // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData)\n\n      // Store the new record\n      await this._datastore.put(ipns.getLocalKey(peerId.id), data)\n\n      log(`ipns record for ${uint8ArrayToString(value, 'base32')} was stored in the datastore`)\n\n      return entryData\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE')\n    }\n  }\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime\nexports = module.exports = IpnsPublisher\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}