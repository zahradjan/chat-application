{"ast":null,"code":"'use strict'; // @ts-ignore\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar SparseArray = require('sparse-array');\n\nvar _require = require('uint8arrays/from-string'),\n    uint8ArrayFromString = _require.fromString;\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\n\n\nvar Bucket = /*#__PURE__*/function () {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  function Bucket(options, parent) {\n    var posAtParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Bucket);\n\n    this._options = options;\n    this._popCount = 0;\n    this._parent = parent;\n    this._posAtParent = posAtParent;\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n\n    this._children = new SparseArray();\n    /** @type {string | null} */\n\n    this.key = null;\n  }\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n\n\n  _createClass(Bucket, [{\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, value) {\n        var place;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._findNewBucketAndPos(key);\n\n              case 2:\n                place = _context.sent;\n                _context.next = 5;\n                return place.bucket._putAt(place, key, value);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function put(_x, _x2) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n    /**\n     * @param {string} key\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key) {\n        var child;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._findChild(key);\n\n              case 2:\n                child = _context2.sent;\n\n                if (!child) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", child.value);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function get(_x3) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * @param {string} key\n     */\n\n  }, {\n    key: \"del\",\n    value: function () {\n      var _del = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key) {\n        var place, child;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._findPlace(key);\n\n              case 2:\n                place = _context3.sent;\n                child = place.bucket._at(place.pos);\n\n                if (child && child.key === key) {\n                  place.bucket._delAt(place.pos);\n                }\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function del(_x4) {\n        return _del.apply(this, arguments);\n      }\n\n      return del;\n    }()\n    /**\n     * @returns {number}\n     */\n\n  }, {\n    key: \"leafCount\",\n    value: function leafCount() {\n      var children = this._children.compactArray();\n\n      return children.reduce(function (acc, child) {\n        if (child instanceof Bucket) {\n          return acc + child.leafCount();\n        }\n\n        return acc + 1;\n      }, 0);\n    }\n  }, {\n    key: \"childrenCount\",\n    value: function childrenCount() {\n      return this._children.length;\n    }\n  }, {\n    key: \"onlyChild\",\n    value: function onlyChild() {\n      return this._children.get(0);\n    }\n    /**\n     * @returns {Iterable<BucketChild<T>>}\n     */\n\n  }, {\n    key: \"eachLeafSeries\",\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime().mark(function eachLeafSeries() {\n      var children, _iterator, _step, child;\n\n      return _regeneratorRuntime().wrap(function eachLeafSeries$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              children = this._children.compactArray();\n              _iterator = _createForOfIteratorHelper(children);\n              _context4.prev = 2;\n\n              _iterator.s();\n\n            case 4:\n              if ((_step = _iterator.n()).done) {\n                _context4.next = 14;\n                break;\n              }\n\n              child = _step.value;\n\n              if (!(child instanceof Bucket)) {\n                _context4.next = 10;\n                break;\n              }\n\n              return _context4.delegateYield(child.eachLeafSeries(), \"t0\", 8);\n\n            case 8:\n              _context4.next = 12;\n              break;\n\n            case 10:\n              _context4.next = 12;\n              return child;\n\n            case 12:\n              _context4.next = 4;\n              break;\n\n            case 14:\n              _context4.next = 19;\n              break;\n\n            case 16:\n              _context4.prev = 16;\n              _context4.t1 = _context4[\"catch\"](2);\n\n              _iterator.e(_context4.t1);\n\n            case 19:\n              _context4.prev = 19;\n\n              _iterator.f();\n\n              return _context4.finish(19);\n\n            case 22:\n              return _context4.abrupt(\"return\", []);\n\n            case 23:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, eachLeafSeries, this, [[2, 16, 19, 22]]);\n    })\n    /**\n     * @param {(value: BucketChild<T>, index: number) => T} map\n     * @param {(reduced: any) => any} reduce\n     */\n\n  }, {\n    key: \"serialize\",\n    value: function serialize(map, reduce) {\n      /** @type {T[]} */\n      var acc = []; // serialize to a custom non-sparse representation\n\n      return reduce(this._children.reduce(function (acc, child, index) {\n        if (child) {\n          if (child instanceof Bucket) {\n            acc.push(child.serialize(map, reduce));\n          } else {\n            acc.push(map(child, index));\n          }\n        }\n\n        return acc;\n      }, acc));\n    }\n    /**\n     * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n     * @param {(reduced: any) => Promise<any>} asyncReduce\n     */\n\n  }, {\n    key: \"asyncTransform\",\n    value: function asyncTransform(asyncMap, asyncReduce) {\n      return asyncTransformBucket(this, asyncMap, asyncReduce);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.serialize(mapNode, reduceNodes);\n    }\n  }, {\n    key: \"prettyPrint\",\n    value: function prettyPrint() {\n      return JSON.stringify(this.toJSON(), null, '  ');\n    }\n  }, {\n    key: \"tableSize\",\n    value: function tableSize() {\n      return Math.pow(2, this._options.bits);\n    }\n    /**\n     * @param {string} key\n     * @returns {Promise<BucketChild<T> | undefined>}\n     */\n\n  }, {\n    key: \"_findChild\",\n    value: function () {\n      var _findChild2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(key) {\n        var result, child;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._findPlace(key);\n\n              case 2:\n                result = _context5.sent;\n                child = result.bucket._at(result.pos);\n\n                if (!(child instanceof Bucket)) {\n                  _context5.next = 6;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", undefined);\n\n              case 6:\n                if (!(child && child.key === key)) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", child);\n\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _findChild(_x5) {\n        return _findChild2.apply(this, arguments);\n      }\n\n      return _findChild;\n    }()\n    /**\n     * @param {string | InfiniteHash} key\n     * @returns {Promise<BucketPosition<T>>}\n     */\n\n  }, {\n    key: \"_findPlace\",\n    value: function () {\n      var _findPlace2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key) {\n        var hashValue, index, child;\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key);\n                _context6.next = 3;\n                return hashValue.take(this._options.bits);\n\n              case 3:\n                index = _context6.sent;\n                child = this._children.get(index);\n\n                if (!(child instanceof Bucket)) {\n                  _context6.next = 7;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", child._findPlace(hashValue));\n\n              case 7:\n                return _context6.abrupt(\"return\", {\n                  bucket: this,\n                  pos: index,\n                  hash: hashValue,\n                  existingChild: child\n                });\n\n              case 8:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _findPlace(_x6) {\n        return _findPlace2.apply(this, arguments);\n      }\n\n      return _findPlace;\n    }()\n    /**\n     * @param {string | InfiniteHash} key\n     * @returns {Promise<BucketPosition<T>>}\n     */\n\n  }, {\n    key: \"_findNewBucketAndPos\",\n    value: function () {\n      var _findNewBucketAndPos2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(key) {\n        var place, bucket, newPlace;\n        return _regeneratorRuntime().wrap(function _callee6$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this._findPlace(key);\n\n              case 2:\n                place = _context7.sent;\n\n                if (!(place.existingChild && place.existingChild.key !== key)) {\n                  _context7.next = 11;\n                  break;\n                }\n\n                // conflict\n                bucket = new Bucket(this._options, place.bucket, place.pos);\n\n                place.bucket._putObjectAt(place.pos, bucket); // put the previous value\n\n\n                _context7.next = 8;\n                return bucket._findPlace(place.existingChild.hash);\n\n              case 8:\n                newPlace = _context7.sent;\n\n                newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);\n\n                return _context7.abrupt(\"return\", bucket._findNewBucketAndPos(place.hash));\n\n              case 11:\n                return _context7.abrupt(\"return\", place);\n\n              case 12:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _findNewBucketAndPos(_x7) {\n        return _findNewBucketAndPos2.apply(this, arguments);\n      }\n\n      return _findNewBucketAndPos;\n    }()\n    /**\n     * @param {BucketPosition<T>} place\n     * @param {string} key\n     * @param {T} value\n     */\n\n  }, {\n    key: \"_putAt\",\n    value: function _putAt(place, key, value) {\n      this._putObjectAt(place.pos, {\n        key: key,\n        value: value,\n        hash: place.hash\n      });\n    }\n    /**\n     * @param {number} pos\n     * @param {Bucket<T> | BucketChild<T>} object\n     */\n\n  }, {\n    key: \"_putObjectAt\",\n    value: function _putObjectAt(pos, object) {\n      if (!this._children.get(pos)) {\n        this._popCount++;\n      }\n\n      this._children.set(pos, object);\n    }\n    /**\n     * @param {number} pos\n     */\n\n  }, {\n    key: \"_delAt\",\n    value: function _delAt(pos) {\n      if (pos === -1) {\n        throw new Error('Invalid position');\n      }\n\n      if (this._children.get(pos)) {\n        this._popCount--;\n      }\n\n      this._children.unset(pos);\n\n      this._level();\n    }\n  }, {\n    key: \"_level\",\n    value: function _level() {\n      if (this._parent && this._popCount <= 1) {\n        if (this._popCount === 1) {\n          // remove myself from parent, replacing me with my only child\n          var onlyChild = this._children.find(exists);\n\n          if (onlyChild && !(onlyChild instanceof Bucket)) {\n            var hash = onlyChild.hash;\n            hash.untake(this._options.bits);\n            var place = {\n              pos: this._posAtParent,\n              hash: hash,\n              bucket: this._parent\n            };\n\n            this._parent._putAt(place, onlyChild.key, onlyChild.value);\n          }\n        } else {\n          this._parent._delAt(this._posAtParent);\n        }\n      }\n    }\n    /**\n     * @param {number} index\n     * @returns {BucketChild<T> | Bucket<T> | undefined}\n     */\n\n  }, {\n    key: \"_at\",\n    value: function _at(index) {\n      return this._children.get(index);\n    }\n  }]);\n\n  return Bucket;\n}();\n/**\n * @param {any} o\n */\n\n\nfunction exists(o) {\n  return Boolean(o);\n}\n/**\n *\n * @param {*} node\n * @param {number} index\n */\n\n\nfunction mapNode(node, index) {\n  return node.key;\n}\n/**\n * @param {*} nodes\n */\n\n\nfunction reduceNodes(nodes) {\n  return nodes;\n}\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\n\n\nfunction asyncTransformBucket(_x8, _x9, _x10) {\n  return _asyncTransformBucket.apply(this, arguments);\n}\n\nfunction _asyncTransformBucket() {\n  _asyncTransformBucket = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(bucket, asyncMap, asyncReduce) {\n    var output, _iterator2, _step2, child, mappedChildren;\n\n    return _regeneratorRuntime().wrap(function _callee7$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            output = [];\n            _iterator2 = _createForOfIteratorHelper(bucket._children.compactArray());\n            _context8.prev = 2;\n\n            _iterator2.s();\n\n          case 4:\n            if ((_step2 = _iterator2.n()).done) {\n              _context8.next = 17;\n              break;\n            }\n\n            child = _step2.value;\n\n            if (!(child instanceof Bucket)) {\n              _context8.next = 11;\n              break;\n            }\n\n            _context8.next = 9;\n            return asyncTransformBucket(child, asyncMap, asyncReduce);\n\n          case 9:\n            _context8.next = 15;\n            break;\n\n          case 11:\n            _context8.next = 13;\n            return asyncMap(child);\n\n          case 13:\n            mappedChildren = _context8.sent;\n            output.push({\n              bitField: bucket._children.bitField(),\n              children: mappedChildren\n            });\n\n          case 15:\n            _context8.next = 4;\n            break;\n\n          case 17:\n            _context8.next = 22;\n            break;\n\n          case 19:\n            _context8.prev = 19;\n            _context8.t0 = _context8[\"catch\"](2);\n\n            _iterator2.e(_context8.t0);\n\n          case 22:\n            _context8.prev = 22;\n\n            _iterator2.f();\n\n            return _context8.finish(22);\n\n          case 25:\n            return _context8.abrupt(\"return\", asyncReduce(output));\n\n          case 26:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee7, null, [[2, 19, 22, 25]]);\n  }));\n  return _asyncTransformBucket.apply(this, arguments);\n}\n\nmodule.exports = Bucket;","map":{"version":3,"names":["SparseArray","require","uint8ArrayFromString","fromString","Bucket","options","parent","posAtParent","_options","_popCount","_parent","_posAtParent","_children","key","value","_findNewBucketAndPos","place","bucket","_putAt","_findChild","child","_findPlace","_at","pos","_delAt","children","compactArray","reduce","acc","leafCount","length","get","eachLeafSeries","map","index","push","serialize","asyncMap","asyncReduce","asyncTransformBucket","mapNode","reduceNodes","JSON","stringify","toJSON","Math","pow","bits","result","undefined","hashValue","hash","take","existingChild","_putObjectAt","newPlace","object","set","Error","unset","_level","onlyChild","find","exists","untake","o","Boolean","node","nodes","output","mappedChildren","bitField","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/hamt-sharding/src/bucket.js"],"sourcesContent":["'use strict'\n\n// @ts-ignore\nconst SparseArray = require('sparse-array')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\n\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\nclass Bucket {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  constructor (options, parent, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n    this._children = new SparseArray()\n\n    /** @type {string | null} */\n    this.key = null\n  }\n\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n  async put (key, value) {\n    const place = await this._findNewBucketAndPos(key)\n\n    await place.bucket._putAt(place, key, value)\n  }\n\n  /**\n   * @param {string} key\n   */\n  async get (key) {\n    const child = await this._findChild(key)\n\n    if (child) {\n      return child.value\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  async del (key) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  /**\n   * @returns {number}\n   */\n  leafCount () {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount () {\n    return this._children.length\n  }\n\n  onlyChild () {\n    return this._children.get(0)\n  }\n\n  /**\n   * @returns {Iterable<BucketChild<T>>}\n   */\n  * eachLeafSeries () {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n\n    // this is necessary because tsc requires a @return annotation as it\n    // can't derive a return type due to the recursion, and eslint requires\n    // a return statement when there is a @return annotation\n    return []\n  }\n\n  /**\n   * @param {(value: BucketChild<T>, index: number) => T} map\n   * @param {(reduced: any) => any} reduce\n   */\n  serialize (map, reduce) {\n    /** @type {T[]} */\n    const acc = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  /**\n   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n   * @param {(reduced: any) => Promise<any>} asyncReduce\n   */\n  asyncTransform (asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON () {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint () {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize () {\n    return Math.pow(2, this._options.bits)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Promise<BucketChild<T> | undefined>}\n   */\n  async _findChild (key) {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child && child.key === key) {\n      return child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findPlace (key) {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findNewBucketAndPos (key) {\n    const place = await this._findPlace(key)\n\n    if (place.existingChild && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  /**\n   * @param {BucketPosition<T>} place\n   * @param {string} key\n   * @param {T} value\n   */\n  _putAt (place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    })\n  }\n\n  /**\n   * @param {number} pos\n   * @param {Bucket<T> | BucketChild<T>} object\n   */\n  _putObjectAt (pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  /**\n   * @param {number} pos\n   */\n  _delAt (pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos)) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level () {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if (onlyChild && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @returns {BucketChild<T> | Bucket<T> | undefined}\n   */\n  _at (index) {\n    return this._children.get(index)\n  }\n}\n\n/**\n * @param {any} o\n */\nfunction exists (o) {\n  return Boolean(o)\n}\n\n/**\n *\n * @param {*} node\n * @param {number} index\n */\nfunction mapNode (node, index) {\n  return node.key\n}\n\n/**\n * @param {*} nodes\n */\nfunction reduceNodes (nodes) {\n  return nodes\n}\n\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\nasync function asyncTransformBucket (bucket, asyncMap, asyncReduce) {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return asyncReduce(output)\n}\n\nmodule.exports = Bucket\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}