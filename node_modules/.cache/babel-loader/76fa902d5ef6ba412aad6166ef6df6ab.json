{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar Store = require('orbit-db-store');\n\nvar EventIndex = require('./EventIndex'); // TODO: generalize the Iterator functions and spin to its own module\n\n\nvar EventStore = /*#__PURE__*/function (_Store) {\n  _inherits(EventStore, _Store);\n\n  var _super = _createSuper(EventStore);\n\n  function EventStore(ipfs, id, dbname) {\n    var _this;\n\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, EventStore);\n\n    if (options.Index === undefined) Object.assign(options, {\n      Index: EventIndex\n    });\n    _this = _super.call(this, ipfs, id, dbname, options);\n    _this._type = 'eventlog';\n\n    _this.events.on(\"log.op.ADD\", function (address, hash, payload) {\n      _this.events.emit(\"db.append\", payload.value);\n    });\n\n    return _this;\n  }\n\n  _createClass(EventStore, [{\n    key: \"add\",\n    value: function add(data) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this._addOperation({\n        op: 'ADD',\n        key: null,\n        value: data\n      }, options);\n    }\n  }, {\n    key: \"get\",\n    value: function get(hash) {\n      return this.iterator({\n        gte: hash,\n        limit: 1\n      }).collect()[0];\n    }\n  }, {\n    key: \"iterator\",\n    value: function iterator(options) {\n      var _iterator;\n\n      var messages = this._query(options);\n\n      var currentIndex = 0;\n      var iterator = (_iterator = {}, _defineProperty(_iterator, Symbol.iterator, function () {\n        return this;\n      }), _defineProperty(_iterator, \"next\", function next() {\n        var item = {\n          value: null,\n          done: true\n        };\n\n        if (currentIndex < messages.length) {\n          item = {\n            value: messages[currentIndex],\n            done: false\n          };\n          currentIndex++;\n        }\n\n        return item;\n      }), _defineProperty(_iterator, \"collect\", function collect() {\n        return messages;\n      }), _iterator);\n      return iterator;\n    }\n  }, {\n    key: \"_query\",\n    value: function _query(opts) {\n      if (!opts) opts = {};\n      var amount = opts.limit ? opts.limit > -1 ? opts.limit : this._index.get().length : 1; // Return 1 if no limit is provided\n\n      var events = this._index.get().slice();\n\n      var result = [];\n\n      if (opts.gt || opts.gte) {\n        // Greater than case\n        result = this._read(events, opts.gt ? opts.gt : opts.gte, amount, !!opts.gte);\n      } else {\n        // Lower than and lastN case, search latest first by reversing the sequence\n        result = this._read(events.reverse(), opts.lt ? opts.lt : opts.lte, amount, opts.lte || !opts.lt).reverse();\n      }\n\n      if (opts.reverse) {\n        result.reverse();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(ops, hash, amount, inclusive) {\n      // Find the index of the gt/lt hash, or start from the beginning of the array if not found\n      var index = ops.map(function (e) {\n        return e.hash;\n      }).indexOf(hash);\n      var startIndex = Math.max(index, 0); // If gte/lte is set, we include the given hash, if not, start from the next element\n\n      startIndex += inclusive ? 0 : 1; // Slice the array to its requested size\n\n      var res = ops.slice(startIndex).slice(0, amount);\n      return res;\n    }\n  }]);\n\n  return EventStore;\n}(Store);\n\nmodule.exports = EventStore;","map":{"version":3,"names":["Store","require","EventIndex","EventStore","ipfs","id","dbname","options","Index","undefined","Object","assign","_type","events","on","address","hash","payload","emit","value","data","_addOperation","op","key","iterator","gte","limit","collect","messages","_query","currentIndex","Symbol","item","done","length","opts","amount","_index","get","slice","result","gt","_read","reverse","lt","lte","ops","inclusive","index","map","e","indexOf","startIndex","Math","max","res","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-eventstore/src/EventStore.js"],"sourcesContent":["'use strict'\n\nconst Store = require('orbit-db-store')\nconst EventIndex = require('./EventIndex')\n\n// TODO: generalize the Iterator functions and spin to its own module\n\nclass EventStore extends Store {\n  constructor (ipfs, id, dbname, options = {}) {\n    if (options.Index === undefined) Object.assign(options, { Index: EventIndex })\n    super(ipfs, id, dbname, options)\n    this._type = 'eventlog';\n    this.events.on(\"log.op.ADD\", (address, hash, payload) => {\n      this.events.emit(\"db.append\", payload.value)\n    })\n  }\n\n  add (data, options = {}) {\n    return this._addOperation({\n      op: 'ADD',\n      key: null,\n      value: data\n    }, options)\n  }\n\n  get (hash) {\n    return this.iterator({ gte: hash, limit: 1 }).collect()[0]\n  }\n  iterator (options) {\n    const messages = this._query(options)\n    let currentIndex = 0\n    let iterator = {\n      [Symbol.iterator] () {\n        return this\n      },\n      next () {\n        let item = { value: null, done: true }\n        if (currentIndex < messages.length) {\n          item = { value: messages[currentIndex], done: false }\n          currentIndex++\n        }\n        return item\n      },\n      collect: () => messages\n    }\n\n    return iterator\n  }\n\n  _query (opts) {\n    if (!opts) opts = {}\n\n    const amount = opts.limit ? (opts.limit > -1 ? opts.limit : this._index.get().length) : 1 // Return 1 if no limit is provided\n    const events = this._index.get().slice()\n    let result = []\n\n    if (opts.gt || opts.gte) {\n      // Greater than case\n      result = this._read(events, opts.gt ? opts.gt : opts.gte, amount, !!opts.gte)\n    } else {\n      // Lower than and lastN case, search latest first by reversing the sequence\n      result = this._read(events.reverse(), opts.lt ? opts.lt : opts.lte, amount, opts.lte || !opts.lt).reverse()\n    }\n    \n    if (opts.reverse) {\n      result.reverse()\n    }\n\n    return result\n  }\n\n  _read (ops, hash, amount, inclusive) {\n    // Find the index of the gt/lt hash, or start from the beginning of the array if not found\n    const index = ops.map((e) => e.hash).indexOf(hash)\n    let startIndex = Math.max(index, 0)\n    // If gte/lte is set, we include the given hash, if not, start from the next element\n    startIndex += inclusive ? 0 : 1\n    // Slice the array to its requested size\n    const res = ops.slice(startIndex).slice(0, amount)\n    return res\n  }\n}\n\nmodule.exports = EventStore\n"],"mappings":"AAAA;;;;;;;;;;;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAMC,UAAU,GAAGD,OAAO,CAAC,cAAD,CAA1B,C,CAEA;;;IAEME,U;;;;;EACJ,oBAAaC,IAAb,EAAmBC,EAAnB,EAAuBC,MAAvB,EAA6C;IAAA;;IAAA,IAAdC,OAAc,uEAAJ,EAAI;;IAAA;;IAC3C,IAAIA,OAAO,CAACC,KAAR,KAAkBC,SAAtB,EAAiCC,MAAM,CAACC,MAAP,CAAcJ,OAAd,EAAuB;MAAEC,KAAK,EAAEN;IAAT,CAAvB;IACjC,0BAAME,IAAN,EAAYC,EAAZ,EAAgBC,MAAhB,EAAwBC,OAAxB;IACA,MAAKK,KAAL,GAAa,UAAb;;IACA,MAAKC,MAAL,CAAYC,EAAZ,CAAe,YAAf,EAA6B,UAACC,OAAD,EAAUC,IAAV,EAAgBC,OAAhB,EAA4B;MACvD,MAAKJ,MAAL,CAAYK,IAAZ,CAAiB,WAAjB,EAA8BD,OAAO,CAACE,KAAtC;IACD,CAFD;;IAJ2C;EAO5C;;;;WAED,aAAKC,IAAL,EAAyB;MAAA,IAAdb,OAAc,uEAAJ,EAAI;MACvB,OAAO,KAAKc,aAAL,CAAmB;QACxBC,EAAE,EAAE,KADoB;QAExBC,GAAG,EAAE,IAFmB;QAGxBJ,KAAK,EAAEC;MAHiB,CAAnB,EAIJb,OAJI,CAAP;IAKD;;;WAED,aAAKS,IAAL,EAAW;MACT,OAAO,KAAKQ,QAAL,CAAc;QAAEC,GAAG,EAAET,IAAP;QAAaU,KAAK,EAAE;MAApB,CAAd,EAAuCC,OAAvC,GAAiD,CAAjD,CAAP;IACD;;;WACD,kBAAUpB,OAAV,EAAmB;MAAA;;MACjB,IAAMqB,QAAQ,GAAG,KAAKC,MAAL,CAAYtB,OAAZ,CAAjB;;MACA,IAAIuB,YAAY,GAAG,CAAnB;MACA,IAAIN,QAAQ,+CACTO,MAAM,CAACP,QADE,cACW;QACnB,OAAO,IAAP;MACD,CAHS,sDAIF;QACN,IAAIQ,IAAI,GAAG;UAAEb,KAAK,EAAE,IAAT;UAAec,IAAI,EAAE;QAArB,CAAX;;QACA,IAAIH,YAAY,GAAGF,QAAQ,CAACM,MAA5B,EAAoC;UAClCF,IAAI,GAAG;YAAEb,KAAK,EAAES,QAAQ,CAACE,YAAD,CAAjB;YAAiCG,IAAI,EAAE;UAAvC,CAAP;UACAH,YAAY;QACb;;QACD,OAAOE,IAAP;MACD,CAXS,yCAYD;QAAA,OAAMJ,QAAN;MAAA,CAZC,aAAZ;MAeA,OAAOJ,QAAP;IACD;;;WAED,gBAAQW,IAAR,EAAc;MACZ,IAAI,CAACA,IAAL,EAAWA,IAAI,GAAG,EAAP;MAEX,IAAMC,MAAM,GAAGD,IAAI,CAACT,KAAL,GAAcS,IAAI,CAACT,KAAL,GAAa,CAAC,CAAd,GAAkBS,IAAI,CAACT,KAAvB,GAA+B,KAAKW,MAAL,CAAYC,GAAZ,GAAkBJ,MAA/D,GAAyE,CAAxF,CAHY,CAG8E;;MAC1F,IAAMrB,MAAM,GAAG,KAAKwB,MAAL,CAAYC,GAAZ,GAAkBC,KAAlB,EAAf;;MACA,IAAIC,MAAM,GAAG,EAAb;;MAEA,IAAIL,IAAI,CAACM,EAAL,IAAWN,IAAI,CAACV,GAApB,EAAyB;QACvB;QACAe,MAAM,GAAG,KAAKE,KAAL,CAAW7B,MAAX,EAAmBsB,IAAI,CAACM,EAAL,GAAUN,IAAI,CAACM,EAAf,GAAoBN,IAAI,CAACV,GAA5C,EAAiDW,MAAjD,EAAyD,CAAC,CAACD,IAAI,CAACV,GAAhE,CAAT;MACD,CAHD,MAGO;QACL;QACAe,MAAM,GAAG,KAAKE,KAAL,CAAW7B,MAAM,CAAC8B,OAAP,EAAX,EAA6BR,IAAI,CAACS,EAAL,GAAUT,IAAI,CAACS,EAAf,GAAoBT,IAAI,CAACU,GAAtD,EAA2DT,MAA3D,EAAmED,IAAI,CAACU,GAAL,IAAY,CAACV,IAAI,CAACS,EAArF,EAAyFD,OAAzF,EAAT;MACD;;MAED,IAAIR,IAAI,CAACQ,OAAT,EAAkB;QAChBH,MAAM,CAACG,OAAP;MACD;;MAED,OAAOH,MAAP;IACD;;;WAED,eAAOM,GAAP,EAAY9B,IAAZ,EAAkBoB,MAAlB,EAA0BW,SAA1B,EAAqC;MACnC;MACA,IAAMC,KAAK,GAAGF,GAAG,CAACG,GAAJ,CAAQ,UAACC,CAAD;QAAA,OAAOA,CAAC,CAAClC,IAAT;MAAA,CAAR,EAAuBmC,OAAvB,CAA+BnC,IAA/B,CAAd;MACA,IAAIoC,UAAU,GAAGC,IAAI,CAACC,GAAL,CAASN,KAAT,EAAgB,CAAhB,CAAjB,CAHmC,CAInC;;MACAI,UAAU,IAAIL,SAAS,GAAG,CAAH,GAAO,CAA9B,CALmC,CAMnC;;MACA,IAAMQ,GAAG,GAAGT,GAAG,CAACP,KAAJ,CAAUa,UAAV,EAAsBb,KAAtB,CAA4B,CAA5B,EAA+BH,MAA/B,CAAZ;MACA,OAAOmB,GAAP;IACD;;;;EAzEsBvD,K;;AA4EzBwD,MAAM,CAACC,OAAP,GAAiBtD,UAAjB"},"metadata":{},"sourceType":"script"}