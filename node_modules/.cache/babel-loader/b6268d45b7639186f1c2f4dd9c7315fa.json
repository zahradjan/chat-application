{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar path = require('path');\n\nvar EventEmitter = require('events');\n\nvar PROTOCOL = require('./protocol');\n\nvar encode = require('./encoding');\n\nvar waitForPeers = require('./wait-for-peers');\n\nvar getPeerID = require('./get-peer-id');\n/**\n * Communication channel over Pubsub between two IPFS nodes\n */\n\n\nvar DirectChannel = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(DirectChannel, _EventEmitter);\n\n  var _super = _createSuper(DirectChannel);\n\n  function DirectChannel(ipfs, receiverID) {\n    var _this;\n\n    _classCallCheck(this, DirectChannel);\n\n    _this = _super.call(this); // IPFS instance to use internally\n\n    _this._ipfs = ipfs;\n\n    if (!ipfs.pubsub) {\n      throw new Error('This IPFS node does not support pubsub.');\n    }\n\n    _this._closed = false;\n\n    _this._isClosed = function () {\n      return _this._closed;\n    };\n\n    _this._receiverID = receiverID;\n\n    if (!_this._receiverID) {\n      throw new Error('Receiver ID was undefined');\n    } // See _setup() for more state initialization\n\n\n    return _this;\n  }\n  /**\n   * Channel ID\n   * @return {[String]} Channel's ID\n   */\n\n\n  _createClass(DirectChannel, [{\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * Peers participating in this channel\n     * @return {[Array]} Array of peer IDs participating in this channel\n     */\n\n  }, {\n    key: \"peers\",\n    get: function get() {\n      return this._peers;\n    }\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return waitForPeers(this._ipfs, [this._receiverID], this._id, this._isClosed);\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n    /**\n     * Send a message to the other peer\n     * @param  {[Any]} message Payload\n     */\n\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(message) {\n        var m;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._closed) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                m = encode(message);\n                _context2.next = 5;\n                return this._ipfs.pubsub.publish(this._id, m);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function send(_x) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n    /**\n     * Close the channel\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      this._closed = true;\n      this.removeAllListeners('message');\n\n      this._ipfs.pubsub.unsubscribe(this._id, this._messageHandler);\n    }\n  }, {\n    key: \"_setup\",\n    value: function () {\n      var _setup2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _this2 = this;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return getPeerID(this._ipfs);\n\n              case 2:\n                this._senderID = _context3.sent;\n                // Channel's participants\n                this._peers = Array.from([this._senderID, this._receiverID]).sort(); // ID of the channel is \"<peer1 id>/<peer 2 id>\"\"\n\n                this._id = '/' + PROTOCOL + '/' + this._peers.join('/'); // Function to use to handle incoming messages\n\n                this._messageHandler = function (message) {\n                  // Make sure the message is coming from the correct peer\n                  var isValid = message && message.from === _this2._receiverID; // Filter out all messages that didn't come from the second peer\n\n                  if (isValid) {\n                    _this2.emit('message', message);\n                  }\n                };\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _setup() {\n        return _setup2.apply(this, arguments);\n      }\n\n      return _setup;\n    }()\n  }, {\n    key: \"_openChannel\",\n    value: function () {\n      var _openChannel2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this._closed = false;\n                _context4.next = 3;\n                return this._setup();\n\n              case 3:\n                _context4.next = 5;\n                return this._ipfs.pubsub.subscribe(this._id, this._messageHandler);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _openChannel() {\n        return _openChannel2.apply(this, arguments);\n      }\n\n      return _openChannel;\n    }()\n  }], [{\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(ipfs, receiverID) {\n        var channel;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                channel = new DirectChannel(ipfs, receiverID);\n                _context5.next = 3;\n                return channel._openChannel();\n\n              case 3:\n                return _context5.abrupt(\"return\", channel);\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function open(_x2, _x3) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }]);\n\n  return DirectChannel;\n}(EventEmitter);\n\nmodule.exports = DirectChannel;","map":{"version":3,"names":["path","require","EventEmitter","PROTOCOL","encode","waitForPeers","getPeerID","DirectChannel","ipfs","receiverID","_ipfs","pubsub","Error","_closed","_isClosed","_receiverID","_id","_peers","message","m","publish","removeAllListeners","unsubscribe","_messageHandler","_senderID","Array","from","sort","join","isValid","emit","_setup","subscribe","channel","_openChannel","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-pubsub-1on1/src/direct-channel.js"],"sourcesContent":["'use strict'\n\nconst path = require('path')\nconst EventEmitter = require('events')\nconst PROTOCOL = require('./protocol')\nconst encode = require('./encoding')\nconst waitForPeers = require('./wait-for-peers')\nconst getPeerID = require('./get-peer-id')\n\n/**\n * Communication channel over Pubsub between two IPFS nodes\n */\nclass DirectChannel extends EventEmitter {\n  constructor (ipfs, receiverID) {\n    super()\n\n    // IPFS instance to use internally\n    this._ipfs = ipfs\n\n    if (!ipfs.pubsub) {\n      throw new Error('This IPFS node does not support pubsub.')\n    }\n\n    this._closed = false\n    this._isClosed = () => this._closed\n    this._receiverID = receiverID\n\n    if (!this._receiverID) {\n      throw new Error('Receiver ID was undefined')\n    }\n    // See _setup() for more state initialization\n  }\n\n  /**\n   * Channel ID\n   * @return {[String]} Channel's ID\n   */\n  get id () {\n    return this._id\n  }\n\n  /**\n   * Peers participating in this channel\n   * @return {[Array]} Array of peer IDs participating in this channel\n   */\n  get peers () {\n    return this._peers\n  }\n\n  async connect () {\n    await waitForPeers(this._ipfs, [this._receiverID], this._id, this._isClosed)\n  }\n\n  /**\n   * Send a message to the other peer\n   * @param  {[Any]} message Payload\n   */\n  async send (message) {\n    if (this._closed) return\n    let m = encode(message)\n    await this._ipfs.pubsub.publish(this._id, m)\n  }\n\n  /**\n   * Close the channel\n   */\n  close () {\n    this._closed = true\n    this.removeAllListeners('message')\n    this._ipfs.pubsub.unsubscribe(this._id, this._messageHandler)\n  }\n\n  async _setup () {\n    this._senderID = await getPeerID(this._ipfs)\n\n    // Channel's participants\n    this._peers = Array.from([this._senderID, this._receiverID]).sort()\n\n    // ID of the channel is \"<peer1 id>/<peer 2 id>\"\"\n    this._id = '/' + PROTOCOL + '/' + this._peers.join('/')\n\n    // Function to use to handle incoming messages\n    this._messageHandler = message => {\n      // Make sure the message is coming from the correct peer\n      const isValid = message && message.from === this._receiverID\n      // Filter out all messages that didn't come from the second peer\n      if (isValid) {\n        this.emit('message', message)\n      }\n    }\n  }\n\n  async _openChannel () {\n    this._closed = false\n    await this._setup()\n    await this._ipfs.pubsub.subscribe(this._id, this._messageHandler)\n  }\n\n  static async open (ipfs, receiverID) {\n    const channel = new DirectChannel(ipfs, receiverID)\n    await channel._openChannel()\n    return channel\n  }\n}\n\nmodule.exports = DirectChannel\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}