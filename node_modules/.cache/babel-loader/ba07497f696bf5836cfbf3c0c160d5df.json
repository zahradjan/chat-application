{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar _get = require('just-safe-get');\n\nvar debug = require('debug');\n\nvar errCode = require('err-code');\n\nvar migrator = require('ipfs-repo-migrations');\n\nvar bytes = require('bytes');\n\nvar merge = require('merge-options');\n\nvar constants = require('./constants');\n\nvar version = require('./version');\n\nvar config = require('./config');\n\nvar spec = require('./spec');\n\nvar apiAddr = require('./api-addr');\n\nvar createIdstore = require('./idstore');\n\nvar defaultOptions = require('./default-options');\n\nvar defaultDatastore = require('./default-datastore');\n\nvar ERRORS = require('./errors');\n\nvar _require = require('./pins'),\n    PinManager = _require.PinManager,\n    PinTypes = _require.PinTypes;\n\nvar createPinnedBlockstore = require('./pinned-blockstore'); // @ts-ignore - no types\n\n\nvar mortice = require('mortice');\n\nvar gc = require('./gc');\n\nvar MemoryLock = require('./locks/memory');\n\nvar FSLock = require('./locks/fs');\n\nvar log = debug('ipfs:repo');\nvar noLimit = Number.MAX_SAFE_INTEGER;\nvar AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate';\n/**\n * @typedef {import('./types').Options} Options\n * @typedef {import('./types').RepoLock} RepoLock\n * @typedef {import('./types').LockCloser} LockCloser\n * @typedef {import('./types').GCLock} GCLock\n * @typedef {import('./types').Stat} Stat\n * @typedef {import('./types').Config} Config\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').Backends} Backends\n * @typedef {import('./types').IPFSRepo} IPFSRepo\n */\n\n/**\n * IPFSRepo implements all required functionality to read and write to an ipfs repo.\n */\n\nvar Repo = /*#__PURE__*/function () {\n  /**\n   * @param {string} path - Where this repo is stored\n   * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n   * @param {Backends} backends - backends used by this repo\n   * @param {Partial<Options>} [options] - Configuration\n   */\n  function Repo(path, loadCodec, backends, options) {\n    _classCallCheck(this, Repo);\n\n    if (typeof path !== 'string') {\n      throw new Error('missing repo path');\n    }\n\n    if (typeof loadCodec !== 'function') {\n      throw new Error('missing codec loader');\n    }\n    /** @type {Options} */\n\n\n    this.options = merge(defaultOptions, options);\n    this.closed = true;\n    this.path = path;\n    this.root = backends.root;\n    this.datastore = backends.datastore;\n    this.keys = backends.keys;\n    var blockstore = backends.blocks;\n    var pinstore = backends.pins;\n    this.pins = new PinManager({\n      pinstore: pinstore,\n      blockstore: blockstore,\n      loadCodec: loadCodec\n    }); // this blockstore will not delete blocks that have been pinned\n\n    var pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore); // this blockstore will extract blocks from multihashes with the identity codec\n\n    this.blocks = createIdstore(pinnedBlockstore);\n    this.version = version(this.root);\n    this.config = config(this.root);\n    this.spec = spec(this.root);\n    this.apiAddr = apiAddr(this.root);\n    /** @type {GCLock} */\n\n    this.gcLock = mortice(path, {\n      singleProcess: this.options.repoOwner !== false\n    });\n    this.gc = gc({\n      gcLock: this.gcLock,\n      pins: this.pins,\n      blockstore: this.blocks,\n      root: this.root,\n      loadCodec: loadCodec\n    });\n  }\n  /**\n   * Initialize a new repo.\n   *\n   * @param {import('./types').Config} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n\n\n  _createClass(Repo, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(config) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                log('initializing at: %s', this.path);\n                _context.next = 3;\n                return this._openRoot();\n\n              case 3:\n                _context.next = 5;\n                return this.config.replace(buildConfig(config));\n\n              case 5:\n                _context.next = 7;\n                return this.spec.set(buildDatastoreSpec(config));\n\n              case 7:\n                _context.next = 9;\n                return this.version.set(constants.repoVersion);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n    /**\n     * Check if the repo is already initialized.\n     *\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: \"isInitialized\",\n    value: function () {\n      var _isInitialized = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.closed) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", true);\n\n              case 2:\n                _context2.prev = 2;\n                _context2.next = 5;\n                return this._openRoot();\n\n              case 5:\n                _context2.next = 7;\n                return this._checkInitialized();\n\n              case 7:\n                _context2.next = 9;\n                return this.root.close();\n\n              case 9:\n                return _context2.abrupt(\"return\", true);\n\n              case 12:\n                _context2.prev = 12;\n                _context2.t0 = _context2[\"catch\"](2);\n                return _context2.abrupt(\"return\", false);\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2, 12]]);\n      }));\n\n      function isInitialized() {\n        return _isInitialized.apply(this, arguments);\n      }\n\n      return isInitialized;\n    }()\n    /**\n     * Open the repo. If the repo is already open an error will be thrown.\n     * If the repo is not initialized it will throw an error.\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var isCompatible;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.closed) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN);\n\n              case 2:\n                log('opening at: %s', this.path); // check if the repo is already initialized\n\n                _context3.prev = 3;\n                _context3.next = 6;\n                return this._openRoot();\n\n              case 6:\n                _context3.next = 8;\n                return this._checkInitialized();\n\n              case 8:\n                _context3.next = 10;\n                return this._openLock();\n\n              case 10:\n                this._lockfile = _context3.sent;\n                log('acquired repo.lock');\n                _context3.next = 14;\n                return this.version.check(constants.repoVersion);\n\n              case 14:\n                isCompatible = _context3.sent;\n\n                if (isCompatible) {\n                  _context3.next = 24;\n                  break;\n                }\n\n                _context3.next = 18;\n                return this._isAutoMigrationEnabled();\n\n              case 18:\n                if (!_context3.sent) {\n                  _context3.next = 23;\n                  break;\n                }\n\n                _context3.next = 21;\n                return this._migrate(constants.repoVersion, {\n                  root: this.root,\n                  datastore: this.datastore,\n                  pins: this.pins.pinstore,\n                  blocks: this.pins.blockstore,\n                  keys: this.keys\n                });\n\n              case 21:\n                _context3.next = 24;\n                break;\n\n              case 23:\n                throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.');\n\n              case 24:\n                log('creating datastore');\n                _context3.next = 27;\n                return this.datastore.open();\n\n              case 27:\n                log('creating blocks');\n                this.blocks.open();\n                log('creating keystore');\n                _context3.next = 32;\n                return this.keys.open();\n\n              case 32:\n                log('creating pins');\n                _context3.next = 35;\n                return this.pins.pinstore.open();\n\n              case 35:\n                this.closed = false;\n                log('all opened');\n                _context3.next = 52;\n                break;\n\n              case 39:\n                _context3.prev = 39;\n                _context3.t0 = _context3[\"catch\"](3);\n\n                if (!this._lockfile) {\n                  _context3.next = 51;\n                  break;\n                }\n\n                _context3.prev = 42;\n                _context3.next = 45;\n                return this._closeLock();\n\n              case 45:\n                this._lockfile = null;\n                _context3.next = 51;\n                break;\n\n              case 48:\n                _context3.prev = 48;\n                _context3.t1 = _context3[\"catch\"](42);\n                log('error removing lock', _context3.t1);\n\n              case 51:\n                throw _context3.t0;\n\n              case 52:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 39], [42, 48]]);\n      }));\n\n      function open() {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n    /**\n     * Opens the root backend, catching and ignoring an 'Already open' error\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_openRoot\",\n    value: function () {\n      var _openRoot2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                _context4.next = 3;\n                return this.root.open();\n\n              case 3:\n                _context4.next = 9;\n                break;\n\n              case 5:\n                _context4.prev = 5;\n                _context4.t0 = _context4[\"catch\"](0);\n\n                if (!(_context4.t0.message !== 'Already open')) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                throw _context4.t0;\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 5]]);\n      }));\n\n      function _openRoot() {\n        return _openRoot2.apply(this, arguments);\n      }\n\n      return _openRoot;\n    }()\n    /**\n     * Creates a lock on the repo if a locker is specified. The lockfile object will\n     * be returned in the callback if one has been created.\n     *\n     * @private\n     * @returns {Promise<LockCloser>}\n     */\n\n  }, {\n    key: \"_openLock\",\n    value: function () {\n      var _openLock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var lockfile;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.options.repoLock.lock(this.path);\n\n              case 2:\n                lockfile = _context5.sent;\n\n                if (!(typeof lockfile.close !== 'function')) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                throw errCode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION');\n\n              case 5:\n                return _context5.abrupt(\"return\", lockfile);\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _openLock() {\n        return _openLock2.apply(this, arguments);\n      }\n\n      return _openLock;\n    }()\n    /**\n     * Closes the lock on the repo\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_closeLock\",\n    value: function _closeLock() {\n      return this._lockfile && this._lockfile.close();\n    }\n    /**\n     * Check if the repo is already initialized.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_checkInitialized\",\n    value: function () {\n      var _checkInitialized2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var config, _yield$Promise$all, _yield$Promise$all2;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                log('init check');\n                _context6.prev = 1;\n                _context6.next = 4;\n                return Promise.all([this.config.exists(), this.spec.exists(), this.version.exists()]);\n\n              case 4:\n                _yield$Promise$all = _context6.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 1);\n                config = _yield$Promise$all2[0];\n                _context6.next = 14;\n                break;\n\n              case 9:\n                _context6.prev = 9;\n                _context6.t0 = _context6[\"catch\"](1);\n\n                if (!(_context6.t0.code === 'ERR_NOT_FOUND')) {\n                  _context6.next = 13;\n                  break;\n                }\n\n                throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n                  path: this.path\n                });\n\n              case 13:\n                throw _context6.t0;\n\n              case 14:\n                if (config) {\n                  _context6.next = 16;\n                  break;\n                }\n\n                throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n                  path: this.path\n                });\n\n              case 16:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[1, 9]]);\n      }));\n\n      function _checkInitialized() {\n        return _checkInitialized2.apply(this, arguments);\n      }\n\n      return _checkInitialized;\n    }()\n    /**\n     * Close the repo and cleanup.\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!this.closed) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED);\n\n              case 2:\n                log('closing at: %s', this.path);\n                _context7.prev = 3;\n                _context7.next = 6;\n                return this.apiAddr.delete();\n\n              case 6:\n                _context7.next = 12;\n                break;\n\n              case 8:\n                _context7.prev = 8;\n                _context7.t0 = _context7[\"catch\"](3);\n\n                if (!(_context7.t0.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !_context7.t0.message.startsWith('ENOENT'))) {\n                  _context7.next = 12;\n                  break;\n                }\n\n                throw _context7.t0;\n\n              case 12:\n                _context7.next = 14;\n                return Promise.all([this.root, this.blocks, this.keys, this.datastore, this.pins.pinstore].map(function (store) {\n                  return store && store.close();\n                }));\n\n              case 14:\n                log('unlocking');\n                this.closed = true;\n                _context7.next = 18;\n                return this._closeLock();\n\n              case 18:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[3, 8]]);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Check if a repo exists.\n     *\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: \"exists\",\n    value: function exists() {\n      return this.version.exists();\n    }\n    /**\n     * Get repo status.\n     *\n     * @returns {Promise<Stat>}\n     */\n\n  }, {\n    key: \"stat\",\n    value: function () {\n      var _stat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _yield$Promise$all3, _yield$Promise$all4, storageMax, blocks, _version, datastore, keys, size;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!(this.datastore && this.keys)) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                _context8.next = 3;\n                return Promise.all([this._storageMaxStat(), this._blockStat(), this.version.get(), getSize(this.datastore), getSize(this.keys)]);\n\n              case 3:\n                _yield$Promise$all3 = _context8.sent;\n                _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 5);\n                storageMax = _yield$Promise$all4[0];\n                blocks = _yield$Promise$all4[1];\n                _version = _yield$Promise$all4[2];\n                datastore = _yield$Promise$all4[3];\n                keys = _yield$Promise$all4[4];\n                size = blocks.size + datastore + keys;\n                return _context8.abrupt(\"return\", {\n                  repoPath: this.path,\n                  storageMax: storageMax,\n                  version: _version,\n                  numObjects: blocks.count,\n                  repoSize: size\n                });\n\n              case 12:\n                throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n                  path: this.path\n                });\n\n              case 13:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function stat() {\n        return _stat.apply(this, arguments);\n      }\n\n      return stat;\n    }()\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_isAutoMigrationEnabled\",\n    value: function () {\n      var _isAutoMigrationEnabled2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var autoMigrateConfig;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!(this.options.autoMigrate !== undefined)) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", this.options.autoMigrate);\n\n              case 2:\n                _context9.prev = 2;\n                _context9.next = 5;\n                return this.config.get(AUTO_MIGRATE_CONFIG_KEY);\n\n              case 5:\n                autoMigrateConfig = _context9.sent;\n                _context9.next = 15;\n                break;\n\n              case 8:\n                _context9.prev = 8;\n                _context9.t0 = _context9[\"catch\"](2);\n\n                if (!(_context9.t0.code === ERRORS.NotFoundError.code)) {\n                  _context9.next = 14;\n                  break;\n                }\n\n                autoMigrateConfig = true; // Config's default value is True\n\n                _context9.next = 15;\n                break;\n\n              case 14:\n                throw _context9.t0;\n\n              case 15:\n                return _context9.abrupt(\"return\", autoMigrateConfig);\n\n              case 16:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[2, 8]]);\n      }));\n\n      function _isAutoMigrationEnabled() {\n        return _isAutoMigrationEnabled2.apply(this, arguments);\n      }\n\n      return _isAutoMigrationEnabled;\n    }()\n    /**\n     * Internal migration\n     *\n     * @private\n     * @param {number} toVersion\n     * @param {Backends} backends\n     */\n\n  }, {\n    key: \"_migrate\",\n    value: function () {\n      var _migrate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(toVersion, backends) {\n        var currentRepoVersion;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.version.get();\n\n              case 2:\n                currentRepoVersion = _context10.sent;\n\n                if (!(currentRepoVersion > toVersion)) {\n                  _context10.next = 8;\n                  break;\n                }\n\n                log(\"reverting to version \".concat(toVersion));\n                return _context10.abrupt(\"return\", migrator.revert(this.path, backends, this.options, toVersion, {\n                  ignoreLock: true,\n                  onProgress: this.options.onMigrationProgress\n                }));\n\n              case 8:\n                log(\"migrating to version \".concat(toVersion));\n                return _context10.abrupt(\"return\", migrator.migrate(this.path, backends, this.options, toVersion, {\n                  ignoreLock: true,\n                  onProgress: this.options.onMigrationProgress\n                }));\n\n              case 10:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function _migrate(_x2, _x3) {\n        return _migrate2.apply(this, arguments);\n      }\n\n      return _migrate;\n    }()\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_storageMaxStat\",\n    value: function () {\n      var _storageMaxStat2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var max;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.prev = 0;\n                _context11.next = 3;\n                return this.config.get('Datastore.StorageMax');\n\n              case 3:\n                max = _context11.sent;\n                return _context11.abrupt(\"return\", BigInt(bytes(max)));\n\n              case 7:\n                _context11.prev = 7;\n                _context11.t0 = _context11[\"catch\"](0);\n                return _context11.abrupt(\"return\", BigInt(noLimit));\n\n              case 10:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[0, 7]]);\n      }));\n\n      function _storageMaxStat() {\n        return _storageMaxStat2.apply(this, arguments);\n      }\n\n      return _storageMaxStat;\n    }()\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_blockStat\",\n    value: function () {\n      var _blockStat2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var count, size, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, key, value;\n\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                count = BigInt(0);\n                size = BigInt(0);\n\n                if (!this.blocks) {\n                  _context12.next = 33;\n                  break;\n                }\n\n                _iteratorAbruptCompletion = false;\n                _didIteratorError = false;\n                _context12.prev = 5;\n                _iterator = _asyncIterator(this.blocks.query({}));\n\n              case 7:\n                _context12.next = 9;\n                return _iterator.next();\n\n              case 9:\n                if (!(_iteratorAbruptCompletion = !(_step = _context12.sent).done)) {\n                  _context12.next = 17;\n                  break;\n                }\n\n                _step$value = _step.value, key = _step$value.key, value = _step$value.value;\n                count += BigInt(1);\n                size += BigInt(value.byteLength);\n                size += BigInt(key.bytes.byteLength);\n\n              case 14:\n                _iteratorAbruptCompletion = false;\n                _context12.next = 7;\n                break;\n\n              case 17:\n                _context12.next = 23;\n                break;\n\n              case 19:\n                _context12.prev = 19;\n                _context12.t0 = _context12[\"catch\"](5);\n                _didIteratorError = true;\n                _iteratorError = _context12.t0;\n\n              case 23:\n                _context12.prev = 23;\n                _context12.prev = 24;\n\n                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                  _context12.next = 28;\n                  break;\n                }\n\n                _context12.next = 28;\n                return _iterator.return();\n\n              case 28:\n                _context12.prev = 28;\n\n                if (!_didIteratorError) {\n                  _context12.next = 31;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 31:\n                return _context12.finish(28);\n\n              case 32:\n                return _context12.finish(23);\n\n              case 33:\n                return _context12.abrupt(\"return\", {\n                  count: count,\n                  size: size\n                });\n\n              case 34:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[5, 19, 23, 33], [24,, 28, 32]]);\n      }));\n\n      function _blockStat() {\n        return _blockStat2.apply(this, arguments);\n      }\n\n      return _blockStat;\n    }()\n  }]);\n\n  return Repo;\n}();\n/**\n * @param {Datastore} datastore\n */\n\n\nfunction getSize(_x4) {\n  return _getSize.apply(this, arguments);\n}\n/**\n * @param {string} path - Where this repo is stored\n * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n * @param {import('./types').Backends} backends - backends used by this repo\n * @param {Partial<Options>} [options] - Configuration\n * @returns {import('./types').IPFSRepo}\n */\n\n\nfunction _getSize() {\n  _getSize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(datastore) {\n    var sum, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, block;\n\n    return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            sum = BigInt(0);\n            _iteratorAbruptCompletion2 = false;\n            _didIteratorError2 = false;\n            _context13.prev = 3;\n            _iterator2 = _asyncIterator(datastore.query({}));\n\n          case 5:\n            _context13.next = 7;\n            return _iterator2.next();\n\n          case 7:\n            if (!(_iteratorAbruptCompletion2 = !(_step2 = _context13.sent).done)) {\n              _context13.next = 14;\n              break;\n            }\n\n            block = _step2.value;\n            sum += BigInt(block.value.byteLength);\n            sum += BigInt(block.key.uint8Array().byteLength);\n\n          case 11:\n            _iteratorAbruptCompletion2 = false;\n            _context13.next = 5;\n            break;\n\n          case 14:\n            _context13.next = 20;\n            break;\n\n          case 16:\n            _context13.prev = 16;\n            _context13.t0 = _context13[\"catch\"](3);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context13.t0;\n\n          case 20:\n            _context13.prev = 20;\n            _context13.prev = 21;\n\n            if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n              _context13.next = 25;\n              break;\n            }\n\n            _context13.next = 25;\n            return _iterator2.return();\n\n          case 25:\n            _context13.prev = 25;\n\n            if (!_didIteratorError2) {\n              _context13.next = 28;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 28:\n            return _context13.finish(25);\n\n          case 29:\n            return _context13.finish(20);\n\n          case 30:\n            return _context13.abrupt(\"return\", sum);\n\n          case 31:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13, null, [[3, 16, 20, 30], [21,, 25, 29]]);\n  }));\n  return _getSize.apply(this, arguments);\n}\n\nfunction createRepo(path, loadCodec, backends, options) {\n  return new Repo(path, loadCodec, backends, options);\n}\n\nmodule.exports = {\n  createRepo: createRepo,\n  repoVersion: constants.repoVersion,\n  errors: ERRORS,\n  utils: {\n    blockstore: require('./utils/blockstore')\n  },\n  locks: {\n    memory: MemoryLock,\n    fs: FSLock\n  },\n  PinTypes: PinTypes\n};\n/**\n * @param {import('./types').Config} _config\n */\n\nfunction buildConfig(_config) {\n  _config.Datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore'));\n  return _config;\n}\n/**\n * @param {import('./types').Config} _config\n */\n\n\nfunction buildDatastoreSpec(_config) {\n  /** @type { {type: string, mounts: Array<{mountpoint: string, type: string, prefix: string, child: {type: string, path: 'string', sync: boolean, shardFunc: string}}>}} */\n  var spec = _objectSpread(_objectSpread({}, defaultDatastore.Spec), _get(_config, 'Datastore.Spec'));\n\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map(function (mounting) {\n      return {\n        mountpoint: mounting.mountpoint,\n        type: mounting.child.type,\n        path: mounting.child.path,\n        shardFunc: mounting.child.shardFunc\n      };\n    })\n  };\n}","map":{"version":3,"names":["_get","require","debug","errCode","migrator","bytes","merge","constants","version","config","spec","apiAddr","createIdstore","defaultOptions","defaultDatastore","ERRORS","PinManager","PinTypes","createPinnedBlockstore","mortice","gc","MemoryLock","FSLock","log","noLimit","Number","MAX_SAFE_INTEGER","AUTO_MIGRATE_CONFIG_KEY","Repo","path","loadCodec","backends","options","Error","closed","root","datastore","keys","blockstore","blocks","pinstore","pins","pinnedBlockstore","gcLock","singleProcess","repoOwner","_openRoot","replace","buildConfig","set","buildDatastoreSpec","repoVersion","_checkInitialized","close","ERR_REPO_ALREADY_OPEN","_openLock","_lockfile","check","isCompatible","_isAutoMigrationEnabled","_migrate","InvalidRepoVersionError","open","_closeLock","message","repoLock","lock","lockfile","Promise","all","exists","code","ERR_REPO_NOT_INITIALIZED","ERR_REPO_ALREADY_CLOSED","delete","startsWith","map","store","_storageMaxStat","_blockStat","get","getSize","storageMax","size","repoPath","numObjects","count","repoSize","autoMigrate","undefined","autoMigrateConfig","NotFoundError","toVersion","currentRepoVersion","revert","ignoreLock","onProgress","onMigrationProgress","migrate","max","BigInt","query","key","value","byteLength","sum","block","uint8Array","createRepo","module","exports","errors","utils","locks","memory","fs","_config","Datastore","Object","assign","Spec","type","mounts","mounting","mountpoint","child","shardFunc"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-repo/src/index.js"],"sourcesContent":["'use strict'\n\nconst _get = require('just-safe-get')\nconst debug = require('debug')\nconst errCode = require('err-code')\nconst migrator = require('ipfs-repo-migrations')\nconst bytes = require('bytes')\nconst merge = require('merge-options')\nconst constants = require('./constants')\nconst version = require('./version')\nconst config = require('./config')\nconst spec = require('./spec')\nconst apiAddr = require('./api-addr')\nconst createIdstore = require('./idstore')\nconst defaultOptions = require('./default-options')\nconst defaultDatastore = require('./default-datastore')\nconst ERRORS = require('./errors')\nconst { PinManager, PinTypes } = require('./pins')\nconst createPinnedBlockstore = require('./pinned-blockstore')\n// @ts-ignore - no types\nconst mortice = require('mortice')\nconst gc = require('./gc')\nconst MemoryLock = require('./locks/memory')\nconst FSLock = require('./locks/fs')\n\nconst log = debug('ipfs:repo')\n\nconst noLimit = Number.MAX_SAFE_INTEGER\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate'\n\n/**\n * @typedef {import('./types').Options} Options\n * @typedef {import('./types').RepoLock} RepoLock\n * @typedef {import('./types').LockCloser} LockCloser\n * @typedef {import('./types').GCLock} GCLock\n * @typedef {import('./types').Stat} Stat\n * @typedef {import('./types').Config} Config\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').Backends} Backends\n * @typedef {import('./types').IPFSRepo} IPFSRepo\n */\n\n/**\n * IPFSRepo implements all required functionality to read and write to an ipfs repo.\n */\nclass Repo {\n  /**\n   * @param {string} path - Where this repo is stored\n   * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n   * @param {Backends} backends - backends used by this repo\n   * @param {Partial<Options>} [options] - Configuration\n   */\n  constructor (path, loadCodec, backends, options) {\n    if (typeof path !== 'string') {\n      throw new Error('missing repo path')\n    }\n\n    if (typeof loadCodec !== 'function') {\n      throw new Error('missing codec loader')\n    }\n\n    /** @type {Options} */\n    this.options = merge(defaultOptions, options)\n    this.closed = true\n    this.path = path\n    this.root = backends.root\n    this.datastore = backends.datastore\n    this.keys = backends.keys\n\n    const blockstore = backends.blocks\n    const pinstore = backends.pins\n\n    this.pins = new PinManager({ pinstore, blockstore, loadCodec })\n\n    // this blockstore will not delete blocks that have been pinned\n    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore)\n\n    // this blockstore will extract blocks from multihashes with the identity codec\n    this.blocks = createIdstore(pinnedBlockstore)\n\n    this.version = version(this.root)\n    this.config = config(this.root)\n    this.spec = spec(this.root)\n    this.apiAddr = apiAddr(this.root)\n\n    /** @type {GCLock} */\n    this.gcLock = mortice(path, {\n      singleProcess: this.options.repoOwner !== false\n    })\n\n    this.gc = gc({ gcLock: this.gcLock, pins: this.pins, blockstore: this.blocks, root: this.root, loadCodec })\n  }\n\n  /**\n   * Initialize a new repo.\n   *\n   * @param {import('./types').Config} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n  async init (config) {\n    log('initializing at: %s', this.path)\n    await this._openRoot()\n    await this.config.replace(buildConfig(config))\n    await this.spec.set(buildDatastoreSpec(config))\n    await this.version.set(constants.repoVersion)\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @returns {Promise<boolean>}\n   */\n  async isInitialized () {\n    if (!this.closed) {\n      // repo is open, must be initialized\n      return true\n    }\n\n    try {\n      // have to open the root datastore in the browser before\n      // we can check whether it's been initialized\n      await this._openRoot()\n      await this._checkInitialized()\n      await this.root.close()\n\n      return true\n    } catch (err) {\n      // FIXME: do not use exceptions for flow control\n      return false\n    }\n  }\n\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n  async open () {\n    if (!this.closed) {\n      throw errCode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN)\n    }\n    log('opening at: %s', this.path)\n\n    // check if the repo is already initialized\n    try {\n      await this._openRoot()\n      await this._checkInitialized()\n\n      this._lockfile = await this._openLock()\n      log('acquired repo.lock')\n\n      const isCompatible = await this.version.check(constants.repoVersion)\n\n      if (!isCompatible) {\n        if (await this._isAutoMigrationEnabled()) {\n          await this._migrate(constants.repoVersion, {\n            root: this.root,\n            datastore: this.datastore,\n            pins: this.pins.pinstore,\n            blocks: this.pins.blockstore,\n            keys: this.keys\n          })\n        } else {\n          throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.')\n        }\n      }\n\n      log('creating datastore')\n      await this.datastore.open()\n\n      log('creating blocks')\n      this.blocks.open()\n\n      log('creating keystore')\n      await this.keys.open()\n\n      log('creating pins')\n      await this.pins.pinstore.open()\n\n      this.closed = false\n      log('all opened')\n    } catch (err) {\n      if (this._lockfile) {\n        try {\n          await this._closeLock()\n          this._lockfile = null\n        } catch (err2) {\n          log('error removing lock', err2)\n        }\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   *\n   * @private\n   */\n  async _openRoot () {\n    try {\n      await this.root.open()\n    } catch (err) {\n      if (err.message !== 'Already open') {\n        throw err\n      }\n    }\n  }\n\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @private\n   * @returns {Promise<LockCloser>}\n   */\n  async _openLock () {\n    const lockfile = await this.options.repoLock.lock(this.path)\n\n    if (typeof lockfile.close !== 'function') {\n      throw errCode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION')\n    }\n\n    return lockfile\n  }\n\n  /**\n   * Closes the lock on the repo\n   *\n   * @private\n   */\n  _closeLock () {\n    return this._lockfile && this._lockfile.close()\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   *\n   * @private\n   */\n  async _checkInitialized () {\n    log('init check')\n    let config\n    try {\n      [config] = await Promise.all([\n        this.config.exists(),\n        this.spec.exists(),\n        this.version.exists()\n      ])\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: this.path\n        })\n      }\n\n      throw err\n    }\n\n    if (!config) {\n      throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: this.path\n      })\n    }\n  }\n\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this.closed) {\n      throw errCode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED)\n    }\n    log('closing at: %s', this.path)\n\n    try {\n      // Delete api, ignoring irrelevant errors\n      await this.apiAddr.delete()\n    } catch (err) {\n      if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n        throw err\n      }\n    }\n\n    await Promise.all([\n      this.root,\n      this.blocks,\n      this.keys,\n      this.datastore,\n      this.pins.pinstore\n    ].map((store) => store && store.close()))\n\n    log('unlocking')\n    this.closed = true\n    await this._closeLock()\n  }\n\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<boolean>}\n   */\n  exists () {\n    return this.version.exists()\n  }\n\n  /**\n   * Get repo status.\n   *\n   * @returns {Promise<Stat>}\n   */\n  async stat () {\n    if (this.datastore && this.keys) {\n      const [storageMax, blocks, version, datastore, keys] = await Promise.all([\n        this._storageMaxStat(),\n        this._blockStat(),\n        this.version.get(),\n        getSize(this.datastore),\n        getSize(this.keys)\n      ])\n      const size = blocks.size + datastore + keys\n\n      return {\n        repoPath: this.path,\n        storageMax,\n        version: version,\n        numObjects: blocks.count,\n        repoSize: size\n      }\n    }\n    throw errCode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n      path: this.path\n    })\n  }\n\n  /**\n   * @private\n   */\n  async _isAutoMigrationEnabled () {\n    if (this.options.autoMigrate !== undefined) {\n      return this.options.autoMigrate\n    }\n\n    // TODO we need to figure out the priority here, between repo options and config.\n    let autoMigrateConfig\n    try {\n      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY)\n    } catch (e) {\n      if (e.code === ERRORS.NotFoundError.code) {\n        autoMigrateConfig = true // Config's default value is True\n      } else {\n        throw e\n      }\n    }\n\n    return autoMigrateConfig\n  }\n\n  /**\n   * Internal migration\n   *\n   * @private\n   * @param {number} toVersion\n   * @param {Backends} backends\n   */\n  async _migrate (toVersion, backends) {\n    const currentRepoVersion = await this.version.get()\n\n    if (currentRepoVersion > toVersion) {\n      log(`reverting to version ${toVersion}`)\n      return migrator.revert(this.path, backends, this.options, toVersion, {\n        ignoreLock: true,\n        onProgress: this.options.onMigrationProgress\n      })\n    } else {\n      log(`migrating to version ${toVersion}`)\n      return migrator.migrate(this.path, backends, this.options, toVersion, {\n        ignoreLock: true,\n        onProgress: this.options.onMigrationProgress\n      })\n    }\n  }\n\n  /**\n   * @private\n   */\n  async _storageMaxStat () {\n    try {\n      const max = /** @type {number} */(await this.config.get('Datastore.StorageMax'))\n      return BigInt(bytes(max))\n    } catch (err) {\n      return BigInt(noLimit)\n    }\n  }\n\n  /**\n   * @private\n   */\n  async _blockStat () {\n    let count = BigInt(0)\n    let size = BigInt(0)\n\n    if (this.blocks) {\n      for await (const { key, value } of this.blocks.query({})) {\n        count += BigInt(1)\n        size += BigInt(value.byteLength)\n        size += BigInt(key.bytes.byteLength)\n      }\n    }\n\n    return { count, size }\n  }\n}\n\n/**\n * @param {Datastore} datastore\n */\nasync function getSize (datastore) {\n  let sum = BigInt(0)\n  for await (const block of datastore.query({})) {\n    sum += BigInt(block.value.byteLength)\n    sum += BigInt(block.key.uint8Array().byteLength)\n  }\n  return sum\n}\n\n/**\n * @param {string} path - Where this repo is stored\n * @param {import('./types').loadCodec} loadCodec - a function that will load multiformat block codecs\n * @param {import('./types').Backends} backends - backends used by this repo\n * @param {Partial<Options>} [options] - Configuration\n * @returns {import('./types').IPFSRepo}\n */\nfunction createRepo (path, loadCodec, backends, options) {\n  return new Repo(path, loadCodec, backends, options)\n}\n\nmodule.exports = {\n  createRepo,\n  repoVersion: constants.repoVersion,\n  errors: ERRORS,\n  utils: { blockstore: require('./utils/blockstore') },\n  locks: {\n    memory: MemoryLock,\n    fs: FSLock\n  },\n  PinTypes\n}\n\n/**\n * @param {import('./types').Config} _config\n */\nfunction buildConfig (_config) {\n  _config.Datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore'))\n\n  return _config\n}\n\n/**\n * @param {import('./types').Config} _config\n */\nfunction buildDatastoreSpec (_config) {\n  /** @type { {type: string, mounts: Array<{mountpoint: string, type: string, prefix: string, child: {type: string, path: 'string', sync: boolean, shardFunc: string}}>}} */\n  const spec = {\n    ...defaultDatastore.Spec,\n    ..._get(_config, 'Datastore.Spec')\n  }\n\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map((mounting) => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}