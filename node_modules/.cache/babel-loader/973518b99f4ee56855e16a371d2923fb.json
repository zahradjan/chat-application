{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst errCode = require('err-code');\n\nconst {\n  NotEnabledError\n} = require('../errors');\n\nconst get = require('dlv');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @param {Object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\n\nmodule.exports = _ref => {\n  let {\n    network,\n    repo\n  } = _ref;\n  const {\n    get,\n    put,\n    findProvs,\n    findPeer,\n    provide,\n    query\n  } = {\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"get\"]}\n     */\n    async get(key) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        libp2p\n      } = await use(network, options);\n      return libp2p._dht.get(key, options);\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"put\"]}\n     */\n    async *put(key, value, options) {\n      const {\n        libp2p\n      } = await use(network, options);\n      yield* libp2p._dht.put(key, value);\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"findProvs\"]}\n     */\n    async *findProvs(cid) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        numProviders: 20\n      };\n      const {\n        libp2p\n      } = await use(network, options);\n\n      for await (const peer of libp2p._dht.findProviders(cid, {\n        maxNumProviders: options.numProviders,\n        signal: options.signal\n      })) {\n        yield {\n          id: peer.id.toB58String(),\n          addrs: peer.addrs\n        };\n      }\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"findPeer\"]}\n     */\n    async findPeer(peerId, options) {\n      const {\n        libp2p\n      } = await use(network, options);\n      const peer = await libp2p._dht.findPeer(PeerId.parse(peerId));\n      return {\n        id: peer.id.toB58String(),\n        addrs: peer.multiaddrs\n      };\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"provide\"]}\n     */\n    async *provide(cids) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        recursive: false\n      };\n      const {\n        libp2p\n      } = await use(network, options);\n      const cidArr = Array.isArray(cids) ? cids : [cids]; // ensure blocks are actually local\n\n      const hasCids = await Promise.all(cidArr.map(cid => repo.blocks.has(cid)));\n      const hasAll = hasCids.every(has => has);\n\n      if (!hasAll) {\n        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND');\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET');\n      }\n\n      for (const cid of cidArr) {\n        yield libp2p._dht.provide(cid);\n      }\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"query\"]}\n     */\n    async *query(peerId, options) {\n      const {\n        libp2p\n      } = await use(network, options);\n\n      for await (const closerPeerId of libp2p._dht.getClosestPeers(PeerId.parse(peerId).toBytes())) {\n        yield {\n          id: closerPeerId.toB58String(),\n          addrs: [] // TODO: get addrs?\n\n        };\n      }\n    }\n\n  };\n  return {\n    get: withTimeoutOption(get),\n    put: withTimeoutOption(put),\n    findProvs: withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption(findPeer),\n    provide: withTimeoutOption(provide),\n    query: withTimeoutOption(query)\n  };\n};\n/**\n * @param {import('../types').NetworkService} network\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\n\n\nconst use = async (network, options) => {\n  const net = await network.use(options);\n\n  if (get(net.libp2p, '_config.dht.enabled', false)) {\n    return net;\n  } else {\n    throw new NotEnabledError('dht not enabled');\n  }\n};","map":{"version":3,"names":["PeerId","require","errCode","NotEnabledError","get","withTimeoutOption","module","exports","network","repo","put","findProvs","findPeer","provide","query","key","options","libp2p","use","_dht","value","cid","numProviders","peer","findProviders","maxNumProviders","signal","id","toB58String","addrs","peerId","parse","multiaddrs","cids","recursive","cidArr","Array","isArray","hasCids","Promise","all","map","blocks","has","hasAll","every","Error","closerPeerId","getClosestPeers","toBytes","net"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/dht.js"],"sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst errCode = require('err-code')\nconst { NotEnabledError } = require('../errors')\nconst get = require('dlv')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n * @param {Object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nmodule.exports = ({ network, repo }) => {\n  const { get, put, findProvs, findPeer, provide, query } = {\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"get\"]}\n     */\n    async get (key, options = {}) {\n      const { libp2p } = await use(network, options)\n      return libp2p._dht.get(key, options)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"put\"]}\n     */\n    async * put (key, value, options) {\n      const { libp2p } = await use(network, options)\n      yield * libp2p._dht.put(key, value)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"findProvs\"]}\n     */\n    async * findProvs (cid, options = { numProviders: 20 }) {\n      const { libp2p } = await use(network, options)\n\n      for await (const peer of libp2p._dht.findProviders(cid, {\n        maxNumProviders: options.numProviders,\n        signal: options.signal\n      })) {\n        yield {\n          id: peer.id.toB58String(),\n          addrs: peer.addrs\n        }\n      }\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"findPeer\"]}\n     */\n    async findPeer (peerId, options) {\n      const { libp2p } = await use(network, options)\n      const peer = await libp2p._dht.findPeer(PeerId.parse(peerId))\n\n      return {\n        id: peer.id.toB58String(),\n        addrs: peer.multiaddrs\n      }\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"provide\"]}\n     */\n    async * provide (cids, options = { recursive: false }) {\n      const { libp2p } = await use(network, options)\n      const cidArr = Array.isArray(cids) ? cids : [cids]\n\n      // ensure blocks are actually local\n      const hasCids = await Promise.all(cidArr.map(cid => repo.blocks.has(cid)))\n      const hasAll = hasCids.every(has => has)\n\n      if (!hasAll) {\n        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND')\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET')\n      }\n\n      for (const cid of cidArr) {\n        yield libp2p._dht.provide(cid)\n      }\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"query\"]}\n     */\n    async * query (peerId, options) {\n      const { libp2p } = await use(network, options)\n\n      for await (const closerPeerId of libp2p._dht.getClosestPeers(PeerId.parse(peerId).toBytes())) {\n        yield {\n          id: closerPeerId.toB58String(),\n          addrs: [] // TODO: get addrs?\n        }\n      }\n    }\n  }\n\n  return {\n    get: withTimeoutOption(get),\n    put: withTimeoutOption(put),\n    findProvs: withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption(findPeer),\n    provide: withTimeoutOption(provide),\n    query: withTimeoutOption(query)\n  }\n}\n\n/**\n * @param {import('../types').NetworkService} network\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\nconst use = async (network, options) => {\n  const net = await network.use(options)\n  if (get(net.libp2p, '_config.dht.enabled', false)) {\n    return net\n  } else {\n    throw new NotEnabledError('dht not enabled')\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}