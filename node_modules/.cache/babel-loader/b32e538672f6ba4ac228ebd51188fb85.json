{"ast":null,"code":"/* @flow */\n'use strict';\n\nconst {\n  Adapter,\n  Key,\n  Errors,\n  utils: {\n    sortAll,\n    replaceStartWith\n  }\n} = require('interface-datastore');\n\nconst filter = require('it-filter');\n\nconst take = require('it-take');\n\nconst merge = require('it-merge');\n\nconst Keytransform = require('./keytransform');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('./types').KeyTransform} KeyTransform\n */\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixes\n *\n * @implements {Datastore}\n */\n\n\nclass MountDatastore extends Adapter {\n  /**\n   * @param {Array<{prefix: Key, datastore: Datastore}>} mounts\n   */\n  constructor(mounts) {\n    super();\n    this.mounts = mounts.slice();\n  }\n\n  async open() {\n    await Promise.all(this.mounts.map(m => m.datastore.open()));\n  }\n  /**\n   * Lookup the matching datastore for the given key\n   *\n   * @private\n   * @param {Key} key\n   * @returns {{datastore: Datastore, mountpoint: Key, rest: Key} | undefined}\n   */\n\n\n  _lookup(key) {\n    for (const mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        const s = replaceStartWith(key.toString(), mount.prefix.toString());\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix,\n          rest: new Key(s)\n        };\n      }\n    }\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n\n\n  put(key, value, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.put(match.rest, value, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  get(key, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw Errors.notFoundError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.get(match.rest, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  has(key, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      return Promise.resolve(false);\n    }\n\n    return match.datastore.has(match.rest, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  delete(key, options) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.delete(match.rest, options);\n  }\n\n  async close() {\n    await Promise.all(this.mounts.map(m => {\n      return m.datastore.close();\n    }));\n  }\n  /**\n   * @returns {Batch}\n   */\n\n\n  batch() {\n    /** @type {Record<string, Batch>} */\n    const batchMounts = {};\n    /**\n     * @param {Key} key\n     */\n\n    const lookup = key => {\n      const match = this._lookup(key);\n\n      if (match == null) {\n        throw new Error('No datastore mounted for this key');\n      }\n\n      const m = match.mountpoint.toString();\n\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch();\n      }\n\n      return {\n        batch: batchMounts[m],\n        rest: match.rest\n      };\n    };\n\n    return {\n      put: (key, value) => {\n        const match = lookup(key);\n        match.batch.put(match.rest, value);\n      },\n      delete: key => {\n        const match = lookup(key);\n        match.batch.delete(match.rest);\n      },\n      commit: async options => {\n        await Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)));\n      }\n    };\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    const qs = this.mounts.map(m => {\n      const ks = new Keytransform(m.datastore, {\n        convert: key => {\n          throw new Error('should never be called');\n        },\n        invert: key => {\n          return m.prefix.child(key);\n        }\n      });\n      let prefix;\n\n      if (q.prefix != null) {\n        prefix = replaceStartWith(q.prefix, m.prefix.toString());\n      }\n\n      return ks.query({\n        prefix: prefix,\n        filters: q.filters\n      }, options);\n    });\n    let it = merge(...qs);\n    if (q.filters) q.filters.forEach(f => {\n      it = filter(it, f);\n    });\n    if (q.orders) q.orders.forEach(o => {\n      it = sortAll(it, o);\n    });\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >=\n      /** @type {number} */\n      q.offset);\n    }\n\n    if (q.limit != null) it = take(it, q.limit);\n    return it;\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n\n\n  queryKeys(q, options) {\n    const qs = this.mounts.map(m => {\n      const ks = new Keytransform(m.datastore, {\n        convert: key => {\n          throw new Error('should never be called');\n        },\n        invert: key => {\n          return m.prefix.child(key);\n        }\n      });\n      let prefix;\n\n      if (q.prefix != null) {\n        prefix = replaceStartWith(q.prefix, m.prefix.toString());\n      }\n\n      return ks.queryKeys({\n        prefix: prefix,\n        filters: q.filters\n      }, options);\n    });\n    let it = merge(...qs);\n    if (q.filters) q.filters.forEach(f => {\n      it = filter(it, f);\n    });\n    if (q.orders) q.orders.forEach(o => {\n      it = sortAll(it, o);\n    });\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >=\n      /** @type {number} */\n      q.offset);\n    }\n\n    if (q.limit != null) it = take(it, q.limit);\n    return it;\n  }\n\n}\n\nmodule.exports = MountDatastore;","map":{"version":3,"names":["Adapter","Key","Errors","utils","sortAll","replaceStartWith","require","filter","take","merge","Keytransform","MountDatastore","constructor","mounts","slice","open","Promise","all","map","m","datastore","_lookup","key","mount","prefix","toString","isAncestorOf","s","mountpoint","rest","put","value","options","match","dbWriteFailedError","Error","get","notFoundError","has","resolve","delete","dbDeleteFailedError","close","batch","batchMounts","lookup","commit","Object","keys","p","query","q","qs","ks","convert","invert","child","filters","it","forEach","f","orders","o","offset","i","limit","queryKeys","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/datastore-core/src/mount.js"],"sourcesContent":["/* @flow */\n'use strict'\n\nconst {\n  Adapter, Key, Errors, utils: {\n    sortAll,\n    replaceStartWith\n  }\n} = require('interface-datastore')\nconst filter = require('it-filter')\nconst take = require('it-take')\nconst merge = require('it-merge')\n\nconst Keytransform = require('./keytransform')\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('./types').KeyTransform} KeyTransform\n */\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixes\n *\n * @implements {Datastore}\n */\nclass MountDatastore extends Adapter {\n  /**\n   * @param {Array<{prefix: Key, datastore: Datastore}>} mounts\n   */\n  constructor (mounts) {\n    super()\n\n    this.mounts = mounts.slice()\n  }\n\n  async open () {\n    await Promise.all(this.mounts.map((m) => m.datastore.open()))\n  }\n\n  /**\n   * Lookup the matching datastore for the given key\n   *\n   * @private\n   * @param {Key} key\n   * @returns {{datastore: Datastore, mountpoint: Key, rest: Key} | undefined}\n   */\n  _lookup (key) {\n    for (const mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        const s = replaceStartWith(key.toString(), mount.prefix.toString())\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix,\n          rest: new Key(s)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n  put (key, value, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'))\n    }\n\n    return match.datastore.put(match.rest, value, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  get (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.notFoundError(new Error('No datastore mounted for this key'))\n    }\n    return match.datastore.get(match.rest, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  has (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      return Promise.resolve(false)\n    }\n    return match.datastore.has(match.rest, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  delete (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'))\n    }\n\n    return match.datastore.delete(match.rest, options)\n  }\n\n  async close () {\n    await Promise.all(this.mounts.map((m) => {\n      return m.datastore.close()\n    }))\n  }\n\n  /**\n   * @returns {Batch}\n   */\n  batch () {\n    /** @type {Record<string, Batch>} */\n    const batchMounts = {}\n    /**\n     * @param {Key} key\n     */\n    const lookup = (key) => {\n      const match = this._lookup(key)\n      if (match == null) {\n        throw new Error('No datastore mounted for this key')\n      }\n\n      const m = match.mountpoint.toString()\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch()\n      }\n\n      return {\n        batch: batchMounts[m],\n        rest: match.rest\n      }\n    }\n\n    return {\n      put: (key, value) => {\n        const match = lookup(key)\n        match.batch.put(match.rest, value)\n      },\n      delete: (key) => {\n        const match = lookup(key)\n        match.batch.delete(match.rest)\n      },\n      commit: async (options) => {\n        await Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)))\n      }\n    }\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query (q, options) {\n    const qs = this.mounts.map(m => {\n      const ks = new Keytransform(m.datastore, {\n        convert: (key) => {\n          throw new Error('should never be called')\n        },\n        invert: (key) => {\n          return m.prefix.child(key)\n        }\n      })\n\n      let prefix\n      if (q.prefix != null) {\n        prefix = replaceStartWith(q.prefix, m.prefix.toString())\n      }\n\n      return ks.query({\n        prefix: prefix,\n        filters: q.filters\n      }, options)\n    })\n\n    let it = merge(...qs)\n    if (q.filters) q.filters.forEach(f => { it = filter(it, f) })\n    if (q.orders) q.orders.forEach(o => { it = sortAll(it, o) })\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= /** @type {number} */ (q.offset))\n    }\n    if (q.limit != null) it = take(it, q.limit)\n\n    return it\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys (q, options) {\n    const qs = this.mounts.map(m => {\n      const ks = new Keytransform(m.datastore, {\n        convert: (key) => {\n          throw new Error('should never be called')\n        },\n        invert: (key) => {\n          return m.prefix.child(key)\n        }\n      })\n\n      let prefix\n      if (q.prefix != null) {\n        prefix = replaceStartWith(q.prefix, m.prefix.toString())\n      }\n\n      return ks.queryKeys({\n        prefix: prefix,\n        filters: q.filters\n      }, options)\n    })\n\n    let it = merge(...qs)\n    if (q.filters) q.filters.forEach(f => { it = filter(it, f) })\n    if (q.orders) q.orders.forEach(o => { it = sortAll(it, o) })\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= /** @type {number} */ (q.offset))\n    }\n    if (q.limit != null) it = take(it, q.limit)\n\n    return it\n  }\n}\n\nmodule.exports = MountDatastore\n"],"mappings":"AAAA;AACA;;AAEA,MAAM;EACJA,OADI;EACKC,GADL;EACUC,MADV;EACkBC,KAAK,EAAE;IAC3BC,OAD2B;IAE3BC;EAF2B;AADzB,IAKFC,OAAO,CAAC,qBAAD,CALX;;AAMA,MAAMC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,SAAD,CAApB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,UAAD,CAArB;;AAEA,MAAMI,YAAY,GAAGJ,OAAO,CAAC,gBAAD,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMK,cAAN,SAA6BX,OAA7B,CAAqC;EACnC;AACF;AACA;EACEY,WAAW,CAAEC,MAAF,EAAU;IACnB;IAEA,KAAKA,MAAL,GAAcA,MAAM,CAACC,KAAP,EAAd;EACD;;EAES,MAAJC,IAAI,GAAI;IACZ,MAAMC,OAAO,CAACC,GAAR,CAAY,KAAKJ,MAAL,CAAYK,GAAZ,CAAiBC,CAAD,IAAOA,CAAC,CAACC,SAAF,CAAYL,IAAZ,EAAvB,CAAZ,CAAN;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEM,OAAO,CAAEC,GAAF,EAAO;IACZ,KAAK,MAAMC,KAAX,IAAoB,KAAKV,MAAzB,EAAiC;MAC/B,IAAIU,KAAK,CAACC,MAAN,CAAaC,QAAb,OAA4BH,GAAG,CAACG,QAAJ,EAA5B,IAA8CF,KAAK,CAACC,MAAN,CAAaE,YAAb,CAA0BJ,GAA1B,CAAlD,EAAkF;QAChF,MAAMK,CAAC,GAAGtB,gBAAgB,CAACiB,GAAG,CAACG,QAAJ,EAAD,EAAiBF,KAAK,CAACC,MAAN,CAAaC,QAAb,EAAjB,CAA1B;QACA,OAAO;UACLL,SAAS,EAAEG,KAAK,CAACH,SADZ;UAELQ,UAAU,EAAEL,KAAK,CAACC,MAFb;UAGLK,IAAI,EAAE,IAAI5B,GAAJ,CAAQ0B,CAAR;QAHD,CAAP;MAKD;IACF;EACF;EAED;AACF;AACA;AACA;AACA;;;EACEG,GAAG,CAAER,GAAF,EAAOS,KAAP,EAAcC,OAAd,EAAuB;IACxB,MAAMC,KAAK,GAAG,KAAKZ,OAAL,CAAaC,GAAb,CAAd;;IACA,IAAIW,KAAK,IAAI,IAAb,EAAmB;MACjB,MAAM/B,MAAM,CAACgC,kBAAP,CAA0B,IAAIC,KAAJ,CAAU,mCAAV,CAA1B,CAAN;IACD;;IAED,OAAOF,KAAK,CAACb,SAAN,CAAgBU,GAAhB,CAAoBG,KAAK,CAACJ,IAA1B,EAAgCE,KAAhC,EAAuCC,OAAvC,CAAP;EACD;EAED;AACF;AACA;AACA;;;EACEI,GAAG,CAAEd,GAAF,EAAOU,OAAP,EAAgB;IACjB,MAAMC,KAAK,GAAG,KAAKZ,OAAL,CAAaC,GAAb,CAAd;;IACA,IAAIW,KAAK,IAAI,IAAb,EAAmB;MACjB,MAAM/B,MAAM,CAACmC,aAAP,CAAqB,IAAIF,KAAJ,CAAU,mCAAV,CAArB,CAAN;IACD;;IACD,OAAOF,KAAK,CAACb,SAAN,CAAgBgB,GAAhB,CAAoBH,KAAK,CAACJ,IAA1B,EAAgCG,OAAhC,CAAP;EACD;EAED;AACF;AACA;AACA;;;EACEM,GAAG,CAAEhB,GAAF,EAAOU,OAAP,EAAgB;IACjB,MAAMC,KAAK,GAAG,KAAKZ,OAAL,CAAaC,GAAb,CAAd;;IACA,IAAIW,KAAK,IAAI,IAAb,EAAmB;MACjB,OAAOjB,OAAO,CAACuB,OAAR,CAAgB,KAAhB,CAAP;IACD;;IACD,OAAON,KAAK,CAACb,SAAN,CAAgBkB,GAAhB,CAAoBL,KAAK,CAACJ,IAA1B,EAAgCG,OAAhC,CAAP;EACD;EAED;AACF;AACA;AACA;;;EACEQ,MAAM,CAAElB,GAAF,EAAOU,OAAP,EAAgB;IACpB,MAAMC,KAAK,GAAG,KAAKZ,OAAL,CAAaC,GAAb,CAAd;;IACA,IAAIW,KAAK,IAAI,IAAb,EAAmB;MACjB,MAAM/B,MAAM,CAACuC,mBAAP,CAA2B,IAAIN,KAAJ,CAAU,mCAAV,CAA3B,CAAN;IACD;;IAED,OAAOF,KAAK,CAACb,SAAN,CAAgBoB,MAAhB,CAAuBP,KAAK,CAACJ,IAA7B,EAAmCG,OAAnC,CAAP;EACD;;EAEU,MAALU,KAAK,GAAI;IACb,MAAM1B,OAAO,CAACC,GAAR,CAAY,KAAKJ,MAAL,CAAYK,GAAZ,CAAiBC,CAAD,IAAO;MACvC,OAAOA,CAAC,CAACC,SAAF,CAAYsB,KAAZ,EAAP;IACD,CAFiB,CAAZ,CAAN;EAGD;EAED;AACF;AACA;;;EACEC,KAAK,GAAI;IACP;IACA,MAAMC,WAAW,GAAG,EAApB;IACA;AACJ;AACA;;IACI,MAAMC,MAAM,GAAIvB,GAAD,IAAS;MACtB,MAAMW,KAAK,GAAG,KAAKZ,OAAL,CAAaC,GAAb,CAAd;;MACA,IAAIW,KAAK,IAAI,IAAb,EAAmB;QACjB,MAAM,IAAIE,KAAJ,CAAU,mCAAV,CAAN;MACD;;MAED,MAAMhB,CAAC,GAAGc,KAAK,CAACL,UAAN,CAAiBH,QAAjB,EAAV;;MACA,IAAImB,WAAW,CAACzB,CAAD,CAAX,IAAkB,IAAtB,EAA4B;QAC1ByB,WAAW,CAACzB,CAAD,CAAX,GAAiBc,KAAK,CAACb,SAAN,CAAgBuB,KAAhB,EAAjB;MACD;;MAED,OAAO;QACLA,KAAK,EAAEC,WAAW,CAACzB,CAAD,CADb;QAELU,IAAI,EAAEI,KAAK,CAACJ;MAFP,CAAP;IAID,CAfD;;IAiBA,OAAO;MACLC,GAAG,EAAE,CAACR,GAAD,EAAMS,KAAN,KAAgB;QACnB,MAAME,KAAK,GAAGY,MAAM,CAACvB,GAAD,CAApB;QACAW,KAAK,CAACU,KAAN,CAAYb,GAAZ,CAAgBG,KAAK,CAACJ,IAAtB,EAA4BE,KAA5B;MACD,CAJI;MAKLS,MAAM,EAAGlB,GAAD,IAAS;QACf,MAAMW,KAAK,GAAGY,MAAM,CAACvB,GAAD,CAApB;QACAW,KAAK,CAACU,KAAN,CAAYH,MAAZ,CAAmBP,KAAK,CAACJ,IAAzB;MACD,CARI;MASLiB,MAAM,EAAE,MAAOd,OAAP,IAAmB;QACzB,MAAMhB,OAAO,CAACC,GAAR,CAAY8B,MAAM,CAACC,IAAP,CAAYJ,WAAZ,EAAyB1B,GAAzB,CAA6B+B,CAAC,IAAIL,WAAW,CAACK,CAAD,CAAX,CAAeH,MAAf,CAAsBd,OAAtB,CAAlC,CAAZ,CAAN;MACD;IAXI,CAAP;EAaD;EAED;AACF;AACA;AACA;;;EACEkB,KAAK,CAAEC,CAAF,EAAKnB,OAAL,EAAc;IACjB,MAAMoB,EAAE,GAAG,KAAKvC,MAAL,CAAYK,GAAZ,CAAgBC,CAAC,IAAI;MAC9B,MAAMkC,EAAE,GAAG,IAAI3C,YAAJ,CAAiBS,CAAC,CAACC,SAAnB,EAA8B;QACvCkC,OAAO,EAAGhC,GAAD,IAAS;UAChB,MAAM,IAAIa,KAAJ,CAAU,wBAAV,CAAN;QACD,CAHsC;QAIvCoB,MAAM,EAAGjC,GAAD,IAAS;UACf,OAAOH,CAAC,CAACK,MAAF,CAASgC,KAAT,CAAelC,GAAf,CAAP;QACD;MANsC,CAA9B,CAAX;MASA,IAAIE,MAAJ;;MACA,IAAI2B,CAAC,CAAC3B,MAAF,IAAY,IAAhB,EAAsB;QACpBA,MAAM,GAAGnB,gBAAgB,CAAC8C,CAAC,CAAC3B,MAAH,EAAWL,CAAC,CAACK,MAAF,CAASC,QAAT,EAAX,CAAzB;MACD;;MAED,OAAO4B,EAAE,CAACH,KAAH,CAAS;QACd1B,MAAM,EAAEA,MADM;QAEdiC,OAAO,EAAEN,CAAC,CAACM;MAFG,CAAT,EAGJzB,OAHI,CAAP;IAID,CAnBU,CAAX;IAqBA,IAAI0B,EAAE,GAAGjD,KAAK,CAAC,GAAG2C,EAAJ,CAAd;IACA,IAAID,CAAC,CAACM,OAAN,EAAeN,CAAC,CAACM,OAAF,CAAUE,OAAV,CAAkBC,CAAC,IAAI;MAAEF,EAAE,GAAGnD,MAAM,CAACmD,EAAD,EAAKE,CAAL,CAAX;IAAoB,CAA7C;IACf,IAAIT,CAAC,CAACU,MAAN,EAAcV,CAAC,CAACU,MAAF,CAASF,OAAT,CAAiBG,CAAC,IAAI;MAAEJ,EAAE,GAAGtD,OAAO,CAACsD,EAAD,EAAKI,CAAL,CAAZ;IAAqB,CAA7C;;IACd,IAAIX,CAAC,CAACY,MAAF,IAAY,IAAhB,EAAsB;MACpB,IAAIC,CAAC,GAAG,CAAR;MACAN,EAAE,GAAGnD,MAAM,CAACmD,EAAD,EAAK,MAAMM,CAAC;MAAM;MAAuBb,CAAC,CAACY,MAA3C,CAAX;IACD;;IACD,IAAIZ,CAAC,CAACc,KAAF,IAAW,IAAf,EAAqBP,EAAE,GAAGlD,IAAI,CAACkD,EAAD,EAAKP,CAAC,CAACc,KAAP,CAAT;IAErB,OAAOP,EAAP;EACD;EAED;AACF;AACA;AACA;;;EACEQ,SAAS,CAAEf,CAAF,EAAKnB,OAAL,EAAc;IACrB,MAAMoB,EAAE,GAAG,KAAKvC,MAAL,CAAYK,GAAZ,CAAgBC,CAAC,IAAI;MAC9B,MAAMkC,EAAE,GAAG,IAAI3C,YAAJ,CAAiBS,CAAC,CAACC,SAAnB,EAA8B;QACvCkC,OAAO,EAAGhC,GAAD,IAAS;UAChB,MAAM,IAAIa,KAAJ,CAAU,wBAAV,CAAN;QACD,CAHsC;QAIvCoB,MAAM,EAAGjC,GAAD,IAAS;UACf,OAAOH,CAAC,CAACK,MAAF,CAASgC,KAAT,CAAelC,GAAf,CAAP;QACD;MANsC,CAA9B,CAAX;MASA,IAAIE,MAAJ;;MACA,IAAI2B,CAAC,CAAC3B,MAAF,IAAY,IAAhB,EAAsB;QACpBA,MAAM,GAAGnB,gBAAgB,CAAC8C,CAAC,CAAC3B,MAAH,EAAWL,CAAC,CAACK,MAAF,CAASC,QAAT,EAAX,CAAzB;MACD;;MAED,OAAO4B,EAAE,CAACa,SAAH,CAAa;QAClB1C,MAAM,EAAEA,MADU;QAElBiC,OAAO,EAAEN,CAAC,CAACM;MAFO,CAAb,EAGJzB,OAHI,CAAP;IAID,CAnBU,CAAX;IAqBA,IAAI0B,EAAE,GAAGjD,KAAK,CAAC,GAAG2C,EAAJ,CAAd;IACA,IAAID,CAAC,CAACM,OAAN,EAAeN,CAAC,CAACM,OAAF,CAAUE,OAAV,CAAkBC,CAAC,IAAI;MAAEF,EAAE,GAAGnD,MAAM,CAACmD,EAAD,EAAKE,CAAL,CAAX;IAAoB,CAA7C;IACf,IAAIT,CAAC,CAACU,MAAN,EAAcV,CAAC,CAACU,MAAF,CAASF,OAAT,CAAiBG,CAAC,IAAI;MAAEJ,EAAE,GAAGtD,OAAO,CAACsD,EAAD,EAAKI,CAAL,CAAZ;IAAqB,CAA7C;;IACd,IAAIX,CAAC,CAACY,MAAF,IAAY,IAAhB,EAAsB;MACpB,IAAIC,CAAC,GAAG,CAAR;MACAN,EAAE,GAAGnD,MAAM,CAACmD,EAAD,EAAK,MAAMM,CAAC;MAAM;MAAuBb,CAAC,CAACY,MAA3C,CAAX;IACD;;IACD,IAAIZ,CAAC,CAACc,KAAF,IAAW,IAAf,EAAqBP,EAAE,GAAGlD,IAAI,CAACkD,EAAD,EAAKP,CAAC,CAACc,KAAP,CAAT;IAErB,OAAOP,EAAP;EACD;;AA9MkC;;AAiNrCS,MAAM,CAACC,OAAP,GAAiBzD,cAAjB"},"metadata":{},"sourceType":"script"}