{"ast":null,"code":"import * as React from 'react';\nimport { memo, useState, useEffect, useCallback, useMemo, useContext } from 'react';\nimport * as ReactDOM from 'react-dom';\n/**\r\n * Throw error when ModalContext is used outside of context provider\r\n */\n\nvar invariantViolation = function () {\n  throw new Error(\"Attempted to call useModal outside of modal context. Make sure your app is rendered inside ModalProvider.\");\n};\n/**\r\n * Modal Context Object\r\n */\n\n\nvar ModalContext = React.createContext({\n  showModal: invariantViolation,\n  hideModal: invariantViolation\n});\nModalContext.displayName = 'ModalContext';\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n/**\r\n * Component responsible for rendering the modal.\r\n *\r\n * The identity of `Component` may change dependeing on the inputs passed to\r\n * `useModal`. If we simply rendered `<Component />` then the modal would be\r\n * susceptible to rerenders whenever one of the inputs change.\r\n */\n\n\nvar ModalRenderer = memo(function (_a) {\n  var component = _a.component,\n      rest = __rest(_a, [\"component\"]);\n\n  return component(rest);\n});\n/**\r\n * Modal Root\r\n *\r\n * Renders modals using react portal.\r\n */\n\nvar ModalRoot = memo(function (_a) {\n  var modals = _a.modals,\n      container = _a.container,\n      _b = _a.component,\n      RootComponent = _b === void 0 ? React.Fragment : _b;\n\n  var _c = useState(undefined),\n      mountNode = _c[0],\n      setMountNode = _c[1]; // This effect will not be ran in the server environment\n\n\n  useEffect(function () {\n    return setMountNode(container || document.body);\n  });\n  return mountNode ? ReactDOM.createPortal(React.createElement(RootComponent, null, Object.keys(modals).map(function (key) {\n    return React.createElement(ModalRenderer, {\n      key: key,\n      component: modals[key]\n    });\n  })), mountNode) : null;\n});\n/**\r\n * Modal Provider\r\n *\r\n * Provides modal context and renders ModalRoot.\r\n */\n\nvar ModalProvider = function (_a) {\n  var container = _a.container,\n      rootComponent = _a.rootComponent,\n      children = _a.children;\n\n  if (container && !(container instanceof HTMLElement)) {\n    throw new Error(\"Container must specify DOM element to mount modal root into.\\n\\n    This behavior has changed in 3.0.0. Please use `rootComponent` prop instead.\\n    See: https://github.com/mpontus/react-modal-hook/issues/18\");\n  }\n\n  var _b = useState({}),\n      modals = _b[0],\n      setModals = _b[1];\n\n  var showModal = useCallback(function (key, modal) {\n    return setModals(function (modals) {\n      var _a;\n\n      return __assign(__assign({}, modals), (_a = {}, _a[key] = modal, _a));\n    });\n  }, []);\n  var hideModal = useCallback(function (key) {\n    return setModals(function (modals) {\n      if (!modals[key]) {\n        return modals;\n      }\n\n      var newModals = __assign({}, modals);\n\n      delete newModals[key];\n      return newModals;\n    });\n  }, []);\n  var contextValue = useMemo(function () {\n    return {\n      showModal: showModal,\n      hideModal: hideModal\n    };\n  }, []);\n  return React.createElement(ModalContext.Provider, {\n    value: contextValue\n  }, React.createElement(React.Fragment, null, children, React.createElement(ModalRoot, {\n    modals: modals,\n    component: rootComponent,\n    container: container\n  })));\n};\n/**\r\n * Utility function to generate unique number per component instance\r\n */\n\n\nvar generateModalKey = function () {\n  var count = 0;\n  return function () {\n    return \"\".concat(++count);\n  };\n}();\n/**\r\n * Check whether the argument is a stateless component.\r\n *\r\n * We take advantage of the stateless nature of functional components to be\r\n * inline the rendering of the modal component as part of another immutable\r\n * component.\r\n *\r\n * This is necessary for allowing the modal to update based on the inputs passed\r\n * as the second argument to useModal without unmounting the previous version of\r\n * the modal component.\r\n */\n\n\nvar isFunctionalComponent = function (Component) {\n  var prototype = Component.prototype;\n  return !prototype || !prototype.isReactComponent;\n};\n/**\r\n * React hook for showing modal windows\r\n */\n\n\nvar useModal = function (component, inputs) {\n  if (inputs === void 0) {\n    inputs = [];\n  }\n\n  if (!isFunctionalComponent(component)) {\n    throw new Error(\"Only stateless components can be used as an argument to useModal. You have probably passed a class component where a function was expected.\");\n  }\n\n  var key = useMemo(generateModalKey, []);\n  var modal = useMemo(function () {\n    return component;\n  }, inputs);\n  var context = useContext(ModalContext);\n\n  var _a = useState(false),\n      isShown = _a[0],\n      setShown = _a[1];\n\n  var showModal = useCallback(function () {\n    return setShown(true);\n  }, []);\n  var hideModal = useCallback(function () {\n    return setShown(false);\n  }, []);\n  useEffect(function () {\n    if (isShown) {\n      context.showModal(key, modal);\n    } else {\n      context.hideModal(key);\n    } // Hide modal when parent component unmounts\n\n\n    return function () {\n      return context.hideModal(key);\n    };\n  }, [modal, isShown]);\n  return [showModal, hideModal];\n};\n\nexport { ModalContext, ModalProvider, useModal };","map":{"version":3,"mappings":"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","names":["invariantViolation","Error","React","createContext","showModal","hideModal","ModalContext","displayName","ModalRenderer","memo","_a","rest","ModalRoot","container","_b","RootComponent","Fragment","useState","undefined","mountNode","setMountNode","useEffect","document","body","ReactDOM","createPortal","Object","keys","modals","map","key","component","ModalProvider","rootComponent","children","HTMLElement","setModals","useCallback","modal","newModals","contextValue","useMemo","Provider","value","generateModalKey","count","concat","isFunctionalComponent","Component","prototype","isReactComponent","inputs","context","useContext","isShown","setShown"],"sources":["../src/ModalContext.ts","../src/ModalRoot.tsx","../src/ModalProvider.tsx","../src/useModal.ts"],"sourcesContent":["import * as React from \"react\";\n\n/**\n * Modals are represented as react components\n *\n * This is what gets passed to useModal as the first argument.\n */\nexport type ModalType = React.FunctionComponent<any>;\n\n/**\n * The shape of the modal context\n */\nexport interface ModalContextType {\n  showModal(key: string, component: ModalType): void;\n  hideModal(key: string): void;\n}\n\n/**\n * Throw error when ModalContext is used outside of context provider\n */\nconst invariantViolation = () => {\n  throw new Error(\n    \"Attempted to call useModal outside of modal context. Make sure your app is rendered inside ModalProvider.\"\n  );\n};\n\n/**\n * Modal Context Object\n */\nexport const ModalContext = React.createContext<ModalContextType>({\n  showModal: invariantViolation,\n  hideModal: invariantViolation\n});\nModalContext.displayName = 'ModalContext';\n","import { memo, useState, useEffect } from \"react\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { ModalType } from \"./ModalContext\";\n\n/**\n * Modal Root Props\n */\ninterface ModalRootProps {\n  /**\n   * Map of modal instances associated by unique ids\n   */\n  modals: Record<string, ModalType>;\n\n  /**\n   * Container component for modals\n   *\n   * Modals will be rendered as children of this component. React.Fragment is\n   * used by defualt, specifying a different component can change the way modals\n   * are rendered across the whole application.\n   */\n  component?: React.ComponentType<any>;\n\n  /**\n   * Specifies the root element to render modals into\n   */\n  container?: Element;\n}\n\n/**\n * Modal renderer props\n */\ninterface ModalRendererProps {\n  /**\n   * Functional component representing the modal\n   */\n  component: ModalType;\n}\n\n/**\n * Component responsible for rendering the modal.\n *\n * The identity of `Component` may change dependeing on the inputs passed to\n * `useModal`. If we simply rendered `<Component />` then the modal would be\n * susceptible to rerenders whenever one of the inputs change.\n */\nconst ModalRenderer = memo(({ component, ...rest }: ModalRendererProps) =>\n  component(rest)\n);\n\n/**\n * Modal Root\n *\n * Renders modals using react portal.\n */\nexport const ModalRoot = memo(\n  ({\n    modals,\n    container,\n    component: RootComponent = React.Fragment\n  }: ModalRootProps) => {\n    const [mountNode, setMountNode] = useState<Element | undefined>(undefined);\n\n    // This effect will not be ran in the server environment\n    useEffect(() => setMountNode(container || document.body));\n\n    return mountNode\n      ? ReactDOM.createPortal(\n          <RootComponent>\n            {Object.keys(modals).map(key => (\n              <ModalRenderer key={key} component={modals[key]} />\n            ))}\n          </RootComponent>,\n          mountNode\n        )\n      : null;\n  }\n);\n","import { useCallback, useState, useMemo } from \"react\";\nimport * as React from \"react\";\nimport { ModalType, ModalContext } from \"./ModalContext\";\nimport { ModalRoot } from \"./ModalRoot\";\n\n/**\n * Modal Provider Props\n */\nexport interface ModalProviderProps {\n  /**\n   * Specifies the root element to render modals into\n   */\n  container?: Element;\n\n  /**\n   * Container component for modal nodes\n   */\n  rootComponent?: React.ComponentType<any>;\n\n  /**\n   * Subtree that will receive modal context\n   */\n  children: React.ReactNode;\n}\n\n/**\n * Modal Provider\n *\n * Provides modal context and renders ModalRoot.\n */\nexport const ModalProvider = ({\n  container,\n  rootComponent,\n  children\n}: ModalProviderProps) => {\n  if (container && !(container instanceof HTMLElement)) {\n    throw new Error(`Container must specify DOM element to mount modal root into.\n\n    This behavior has changed in 3.0.0. Please use \\`rootComponent\\` prop instead.\n    See: https://github.com/mpontus/react-modal-hook/issues/18`);\n  }\n  const [modals, setModals] = useState<Record<string, ModalType>>({});\n  const showModal = useCallback(\n    (key: string, modal: ModalType) =>\n      setModals(modals => ({\n        ...modals,\n        [key]: modal\n      })),\n    []\n  );\n  const hideModal = useCallback(\n    (key: string) =>\n      setModals(modals => {\n        if (!modals[key]) {\n          return modals;\n        }\n        const newModals = { ...modals };\n        delete newModals[key];\n        return newModals;\n      }),\n    []\n  );\n  const contextValue = useMemo(() => ({ showModal, hideModal }), []);\n\n  return (\n    <ModalContext.Provider value={contextValue}>\n      <React.Fragment>\n        {children}\n        <ModalRoot\n          modals={modals}\n          component={rootComponent}\n          container={container}\n        />\n      </React.Fragment>\n    </ModalContext.Provider>\n  );\n};\n","import { useContext, useEffect, useState, useCallback, useMemo, DependencyList } from \"react\";\nimport { ModalContext, ModalType } from \"./ModalContext\";\n\n/**\n * Callback types provided for descriptive type-hints\n */\ntype ShowModal = () => void;\ntype HideModal = () => void;\n\n/**\n * Utility function to generate unique number per component instance\n */\nconst generateModalKey = (() => {\n  let count = 0;\n\n  return () => `${++count}`;\n})();\n\n/**\n * Check whether the argument is a stateless component.\n *\n * We take advantage of the stateless nature of functional components to be\n * inline the rendering of the modal component as part of another immutable\n * component.\n *\n * This is necessary for allowing the modal to update based on the inputs passed\n * as the second argument to useModal without unmounting the previous version of\n * the modal component.\n */\nconst isFunctionalComponent = (Component: Function) => {\n  const prototype = Component.prototype;\n\n  return !prototype || !prototype.isReactComponent;\n};\n\n/**\n * React hook for showing modal windows\n */\nexport const useModal = (\n  component: ModalType,\n  inputs: DependencyList = []\n): [ShowModal, HideModal] => {\n  if (!isFunctionalComponent(component)) {\n    throw new Error(\n      \"Only stateless components can be used as an argument to useModal. You have probably passed a class component where a function was expected.\"\n    );\n  }\n\n  const key = useMemo(generateModalKey, []);\n  const modal = useMemo(() => component, inputs);\n  const context = useContext(ModalContext);\n  const [isShown, setShown] = useState<boolean>(false);\n  const showModal = useCallback(() => setShown(true), []);\n  const hideModal = useCallback(() => setShown(false), []);\n\n  useEffect(() => {\n    if (isShown) {\n      context.showModal(key, modal);\n    } else {\n      context.hideModal(key);\n    }\n\n    // Hide modal when parent component unmounts\n    return () => context.hideModal(key);\n  }, [modal, isShown]);\n\n  return [showModal, hideModal];\n};\n"]},"metadata":{},"sourceType":"module"}