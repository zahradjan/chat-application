{"ast":null,"code":"/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nvar debug = require('debug')('simple-peer');\n\nvar getBrowserRTC = require('get-browser-rtc');\n\nvar randombytes = require('randombytes');\n\nvar stream = require('readable-stream');\n\nvar queueMicrotask = require('queue-microtask'); // TODO: remove when Node 10 is not supported\n\n\nvar errCode = require('err-code');\n\nvar MAX_BUFFERED_AMOUNT = 64 * 1024;\nvar ICECOMPLETE_TIMEOUT = 5 * 1000;\nvar CHANNEL_CLOSING_TIMEOUT = 5 * 1000; // HACK: Filter trickle lines when trickle is disabled #354\n\nfunction filterTrickle(sdp) {\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '');\n}\n\nfunction warn(message) {\n  console.warn(message);\n}\n/**\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\n * Duplex stream.\n * @param {Object} opts\n */\n\n\nclass Peer extends stream.Duplex {\n  constructor(opts) {\n    opts = Object.assign({\n      allowHalfOpen: false\n    }, opts);\n    super(opts);\n    this._id = randombytes(4).toString('hex').slice(0, 7);\n\n    this._debug('new peer %o', opts);\n\n    this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString('hex') : null;\n    this.initiator = opts.initiator || false;\n    this.channelConfig = opts.channelConfig || Peer.channelConfig;\n    this.negotiated = this.channelConfig.negotiated;\n    this.config = Object.assign({}, Peer.config, opts.config);\n    this.offerOptions = opts.offerOptions || {};\n    this.answerOptions = opts.answerOptions || {};\n\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp);\n\n    this.streams = opts.streams || (opts.stream ? [opts.stream] : []); // support old \"stream\" option\n\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true;\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false;\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;\n    this._connected = false;\n    this.remoteAddress = undefined;\n    this.remoteFamily = undefined;\n    this.remotePort = undefined;\n    this.localAddress = undefined;\n    this.localFamily = undefined;\n    this.localPort = undefined;\n    this._wrtc = opts.wrtc && typeof opts.wrtc === 'object' ? opts.wrtc : getBrowserRTC();\n\n    if (!this._wrtc) {\n      if (typeof window === 'undefined') {\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT');\n      } else {\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT');\n      }\n    }\n\n    this._pcReady = false;\n    this._channelReady = false;\n    this._iceComplete = false; // ice candidate trickle done (got null candidate)\n\n    this._iceCompleteTimer = null; // send an offer/answer anyway after some timeout\n\n    this._channel = null;\n    this._pendingCandidates = [];\n    this._isNegotiating = this.negotiated ? false : !this.initiator; // is this peer waiting for negotiation to complete?\n\n    this._batchedNegotiation = false; // batch synchronous negotiations\n\n    this._queuedNegotiation = false; // is there a queued negotiation request?\n\n    this._sendersAwaitingStable = [];\n    this._senderMap = new Map();\n    this._firstStable = true;\n    this._closingInterval = null;\n    this._remoteTracks = [];\n    this._remoteStreams = [];\n    this._chunk = null;\n    this._cb = null;\n    this._interval = null;\n\n    try {\n      this._pc = new this._wrtc.RTCPeerConnection(this.config);\n    } catch (err) {\n      queueMicrotask(() => this.destroy(errCode(err, 'ERR_PC_CONSTRUCTOR')));\n      return;\n    } // We prefer feature detection whenever possible, but sometimes that's not\n    // possible for certain implementations.\n\n\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number';\n\n    this._pc.oniceconnectionstatechange = () => {\n      this._onIceStateChange();\n    };\n\n    this._pc.onicegatheringstatechange = () => {\n      this._onIceStateChange();\n    };\n\n    this._pc.onconnectionstatechange = () => {\n      this._onConnectionStateChange();\n    };\n\n    this._pc.onsignalingstatechange = () => {\n      this._onSignalingStateChange();\n    };\n\n    this._pc.onicecandidate = event => {\n      this._onIceCandidate(event);\n    }; // Other spec events, unused by this implementation:\n    // - onconnectionstatechange\n    // - onicecandidateerror\n    // - onfingerprintfailure\n    // - onnegotiationneeded\n\n\n    if (this.initiator || this.negotiated) {\n      this._setupData({\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\n      });\n    } else {\n      this._pc.ondatachannel = event => {\n        this._setupData(event);\n      };\n    }\n\n    if (this.streams) {\n      this.streams.forEach(stream => {\n        this.addStream(stream);\n      });\n    }\n\n    this._pc.ontrack = event => {\n      this._onTrack(event);\n    };\n\n    if (this.initiator) {\n      this._needsNegotiation();\n    }\n\n    this._onFinishBound = () => {\n      this._onFinish();\n    };\n\n    this.once('finish', this._onFinishBound);\n  }\n\n  get bufferSize() {\n    return this._channel && this._channel.bufferedAmount || 0;\n  } // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n\n\n  get connected() {\n    return this._connected && this._channel.readyState === 'open';\n  }\n\n  address() {\n    return {\n      port: this.localPort,\n      family: this.localFamily,\n      address: this.localAddress\n    };\n  }\n\n  signal(data) {\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_SIGNALING');\n\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (err) {\n        data = {};\n      }\n    }\n\n    this._debug('signal()');\n\n    if (data.renegotiate && this.initiator) {\n      this._debug('got request to renegotiate');\n\n      this._needsNegotiation();\n    }\n\n    if (data.transceiverRequest && this.initiator) {\n      this._debug('got request for transceiver');\n\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);\n    }\n\n    if (data.candidate) {\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\n        this._addIceCandidate(data.candidate);\n      } else {\n        this._pendingCandidates.push(data.candidate);\n      }\n    }\n\n    if (data.sdp) {\n      this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(() => {\n        if (this.destroyed) return;\n\n        this._pendingCandidates.forEach(candidate => {\n          this._addIceCandidate(candidate);\n        });\n\n        this._pendingCandidates = [];\n        if (this._pc.remoteDescription.type === 'offer') this._createAnswer();\n      }).catch(err => {\n        this.destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'));\n      });\n    }\n\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\n      this.destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'));\n    }\n  }\n\n  _addIceCandidate(candidate) {\n    var iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);\n\n    this._pc.addIceCandidate(iceCandidateObj).catch(err => {\n      if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\n        warn('Ignoring unsupported ICE candidate.');\n      } else {\n        this.destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'));\n      }\n    });\n  }\n  /**\n   * Send text/binary data to the remote peer.\n   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk\n   */\n\n\n  send(chunk) {\n    this._channel.send(chunk);\n  }\n  /**\n   * Add a Transceiver to the connection.\n   * @param {String} kind\n   * @param {Object} init\n   */\n\n\n  addTransceiver(kind, init) {\n    this._debug('addTransceiver()');\n\n    if (this.initiator) {\n      try {\n        this._pc.addTransceiver(kind, init);\n\n        this._needsNegotiation();\n      } catch (err) {\n        this.destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'));\n      }\n    } else {\n      this.emit('signal', {\n        // request initiator to renegotiate\n        transceiverRequest: {\n          kind,\n          init\n        }\n      });\n    }\n  }\n  /**\n   * Add a MediaStream to the connection.\n   * @param {MediaStream} stream\n   */\n\n\n  addStream(stream) {\n    this._debug('addStream()');\n\n    stream.getTracks().forEach(track => {\n      this.addTrack(track, stream);\n    });\n  }\n  /**\n   * Add a MediaStreamTrack to the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */\n\n\n  addTrack(track, stream) {\n    this._debug('addTrack()');\n\n    var submap = this._senderMap.get(track) || new Map(); // nested Maps map [track, stream] to sender\n\n    var sender = submap.get(stream);\n\n    if (!sender) {\n      sender = this._pc.addTrack(track, stream);\n      submap.set(stream, sender);\n\n      this._senderMap.set(track, submap);\n\n      this._needsNegotiation();\n    } else if (sender.removed) {\n      throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED');\n    } else {\n      throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED');\n    }\n  }\n  /**\n   * Replace a MediaStreamTrack by another in the connection.\n   * @param {MediaStreamTrack} oldTrack\n   * @param {MediaStreamTrack} newTrack\n   * @param {MediaStream} stream\n   */\n\n\n  replaceTrack(oldTrack, newTrack, stream) {\n    this._debug('replaceTrack()');\n\n    var submap = this._senderMap.get(oldTrack);\n\n    var sender = submap ? submap.get(stream) : null;\n\n    if (!sender) {\n      throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED');\n    }\n\n    if (newTrack) this._senderMap.set(newTrack, submap);\n\n    if (sender.replaceTrack != null) {\n      sender.replaceTrack(newTrack);\n    } else {\n      this.destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'));\n    }\n  }\n  /**\n   * Remove a MediaStreamTrack from the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */\n\n\n  removeTrack(track, stream) {\n    this._debug('removeSender()');\n\n    var submap = this._senderMap.get(track);\n\n    var sender = submap ? submap.get(stream) : null;\n\n    if (!sender) {\n      throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED');\n    }\n\n    try {\n      sender.removed = true;\n\n      this._pc.removeTrack(sender);\n    } catch (err) {\n      if (err.name === 'NS_ERROR_UNEXPECTED') {\n        this._sendersAwaitingStable.push(sender); // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n\n      } else {\n        this.destroy(errCode(err, 'ERR_REMOVE_TRACK'));\n      }\n    }\n\n    this._needsNegotiation();\n  }\n  /**\n   * Remove a MediaStream from the connection.\n   * @param {MediaStream} stream\n   */\n\n\n  removeStream(stream) {\n    this._debug('removeSenders()');\n\n    stream.getTracks().forEach(track => {\n      this.removeTrack(track, stream);\n    });\n  }\n\n  _needsNegotiation() {\n    this._debug('_needsNegotiation');\n\n    if (this._batchedNegotiation) return; // batch synchronous renegotiations\n\n    this._batchedNegotiation = true;\n    queueMicrotask(() => {\n      this._batchedNegotiation = false;\n\n      this._debug('starting batched negotiation');\n\n      this.negotiate();\n    });\n  }\n\n  negotiate() {\n    if (this.initiator) {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true;\n\n        this._debug('already negotiating, queueing');\n      } else {\n        this._debug('start negotiation');\n\n        setTimeout(() => {\n          // HACK: Chrome crashes if we immediately call createOffer\n          this._createOffer();\n        }, 0);\n      }\n    } else {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true;\n\n        this._debug('already negotiating, queueing');\n      } else {\n        this._debug('requesting negotiation from initiator');\n\n        this.emit('signal', {\n          // request initiator to renegotiate\n          renegotiate: true\n        });\n      }\n    }\n\n    this._isNegotiating = true;\n  }\n\n  _destroy(err, cb) {\n    this._debug('destroy (error: %s)', err && (err.message || err));\n\n    this.readable = this.writable = false;\n    if (!this._readableState.ended) this.push(null);\n    if (!this._writableState.finished) this.end();\n    this._connected = false;\n    this._pcReady = false;\n    this._channelReady = false;\n    this._remoteTracks = null;\n    this._remoteStreams = null;\n    this._senderMap = null;\n    clearInterval(this._closingInterval);\n    this._closingInterval = null;\n    clearInterval(this._interval);\n    this._interval = null;\n    this._chunk = null;\n    this._cb = null;\n    if (this._onFinishBound) this.removeListener('finish', this._onFinishBound);\n    this._onFinishBound = null;\n\n    if (this._channel) {\n      try {\n        this._channel.close();\n      } catch (err) {}\n\n      this._channel.onmessage = null;\n      this._channel.onopen = null;\n      this._channel.onclose = null;\n      this._channel.onerror = null;\n    }\n\n    if (this._pc) {\n      try {\n        this._pc.close();\n      } catch (err) {}\n\n      this._pc.oniceconnectionstatechange = null;\n      this._pc.onicegatheringstatechange = null;\n      this._pc.onsignalingstatechange = null;\n      this._pc.onicecandidate = null;\n      this._pc.ontrack = null;\n      this._pc.ondatachannel = null;\n    }\n\n    this._pc = null;\n    this._channel = null;\n    cb(err);\n  }\n\n  _setupData(event) {\n    if (!event.channel) {\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n      // which is invalid behavior. Handle it gracefully.\n      // See: https://github.com/feross/simple-peer/issues/163\n      return this.destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'));\n    }\n\n    this._channel = event.channel;\n    this._channel.binaryType = 'arraybuffer';\n\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;\n    }\n\n    this.channelName = this._channel.label;\n\n    this._channel.onmessage = event => {\n      this._onChannelMessage(event);\n    };\n\n    this._channel.onbufferedamountlow = () => {\n      this._onChannelBufferedAmountLow();\n    };\n\n    this._channel.onopen = () => {\n      this._onChannelOpen();\n    };\n\n    this._channel.onclose = () => {\n      this._onChannelClose();\n    };\n\n    this._channel.onerror = err => {\n      this.destroy(errCode(err, 'ERR_DATA_CHANNEL'));\n    }; // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n\n\n    var isClosing = false;\n    this._closingInterval = setInterval(() => {\n      // No \"onclosing\" event\n      if (this._channel && this._channel.readyState === 'closing') {\n        if (isClosing) this._onChannelClose(); // closing timed out: equivalent to onclose firing\n\n        isClosing = true;\n      } else {\n        isClosing = false;\n      }\n    }, CHANNEL_CLOSING_TIMEOUT);\n  }\n\n  _read() {}\n\n  _write(chunk, encoding, cb) {\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'));\n\n    if (this._connected) {\n      try {\n        this.send(chunk);\n      } catch (err) {\n        return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'));\n      }\n\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount);\n\n        this._cb = cb;\n      } else {\n        cb(null);\n      }\n    } else {\n      this._debug('write before connect');\n\n      this._chunk = chunk;\n      this._cb = cb;\n    }\n  } // When stream finishes writing, close socket. Half open connections are not\n  // supported.\n\n\n  _onFinish() {\n    if (this.destroyed) return; // Wait a bit before destroying so the socket flushes.\n    // TODO: is there a more reliable way to accomplish this?\n\n    const destroySoon = () => {\n      setTimeout(() => this.destroy(), 1000);\n    };\n\n    if (this._connected) {\n      destroySoon();\n    } else {\n      this.once('connect', destroySoon);\n    }\n  }\n\n  _startIceCompleteTimeout() {\n    if (this.destroyed) return;\n    if (this._iceCompleteTimer) return;\n\n    this._debug('started iceComplete timeout');\n\n    this._iceCompleteTimer = setTimeout(() => {\n      if (!this._iceComplete) {\n        this._iceComplete = true;\n\n        this._debug('iceComplete timeout completed');\n\n        this.emit('iceTimeout');\n        this.emit('_iceComplete');\n      }\n    }, this.iceCompleteTimeout);\n  }\n\n  _createOffer() {\n    if (this.destroyed) return;\n\n    this._pc.createOffer(this.offerOptions).then(offer => {\n      if (this.destroyed) return;\n      if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp);\n      offer.sdp = this.sdpTransform(offer.sdp);\n\n      const sendOffer = () => {\n        if (this.destroyed) return;\n        var signal = this._pc.localDescription || offer;\n\n        this._debug('signal');\n\n        this.emit('signal', {\n          type: signal.type,\n          sdp: signal.sdp\n        });\n      };\n\n      const onSuccess = () => {\n        this._debug('createOffer success');\n\n        if (this.destroyed) return;\n        if (this.trickle || this._iceComplete) sendOffer();else this.once('_iceComplete', sendOffer); // wait for candidates\n      };\n\n      const onError = err => {\n        this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'));\n      };\n\n      this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);\n    }).catch(err => {\n      this.destroy(errCode(err, 'ERR_CREATE_OFFER'));\n    });\n  }\n\n  _requestMissingTransceivers() {\n    if (this._pc.getTransceivers) {\n      this._pc.getTransceivers().forEach(transceiver => {\n        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\n          transceiver.requested = true; // HACK: Safari returns negotiated transceivers with a null mid\n\n          this.addTransceiver(transceiver.sender.track.kind);\n        }\n      });\n    }\n  }\n\n  _createAnswer() {\n    if (this.destroyed) return;\n\n    this._pc.createAnswer(this.answerOptions).then(answer => {\n      if (this.destroyed) return;\n      if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp);\n      answer.sdp = this.sdpTransform(answer.sdp);\n\n      const sendAnswer = () => {\n        if (this.destroyed) return;\n        var signal = this._pc.localDescription || answer;\n\n        this._debug('signal');\n\n        this.emit('signal', {\n          type: signal.type,\n          sdp: signal.sdp\n        });\n        if (!this.initiator) this._requestMissingTransceivers();\n      };\n\n      const onSuccess = () => {\n        if (this.destroyed) return;\n        if (this.trickle || this._iceComplete) sendAnswer();else this.once('_iceComplete', sendAnswer);\n      };\n\n      const onError = err => {\n        this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'));\n      };\n\n      this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);\n    }).catch(err => {\n      this.destroy(errCode(err, 'ERR_CREATE_ANSWER'));\n    });\n  }\n\n  _onConnectionStateChange() {\n    if (this.destroyed) return;\n\n    if (this._pc.connectionState === 'failed') {\n      this.destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'));\n    }\n  }\n\n  _onIceStateChange() {\n    if (this.destroyed) return;\n    var iceConnectionState = this._pc.iceConnectionState;\n    var iceGatheringState = this._pc.iceGatheringState;\n\n    this._debug('iceStateChange (connection: %s) (gathering: %s)', iceConnectionState, iceGatheringState);\n\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState);\n\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\n      this._pcReady = true;\n\n      this._maybeReady();\n    }\n\n    if (iceConnectionState === 'failed') {\n      this.destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'));\n    }\n\n    if (iceConnectionState === 'closed') {\n      this.destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'));\n    }\n  }\n\n  getStats(cb) {\n    // statreports can come with a value array instead of properties\n    const flattenValues = report => {\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\n        report.values.forEach(value => {\n          Object.assign(report, value);\n        });\n      }\n\n      return report;\n    }; // Promise-based getStats() (standard)\n\n\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\n      this._pc.getStats().then(res => {\n        var reports = [];\n        res.forEach(report => {\n          reports.push(flattenValues(report));\n        });\n        cb(null, reports);\n      }, err => cb(err)); // Single-parameter callback-based getStats() (non-standard)\n\n    } else if (this._pc.getStats.length > 0) {\n      this._pc.getStats(res => {\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\n        if (this.destroyed) return;\n        var reports = [];\n        res.result().forEach(result => {\n          var report = {};\n          result.names().forEach(name => {\n            report[name] = result.stat(name);\n          });\n          report.id = result.id;\n          report.type = result.type;\n          report.timestamp = result.timestamp;\n          reports.push(flattenValues(report));\n        });\n        cb(null, reports);\n      }, err => cb(err)); // Unknown browser, skip getStats() since it's anyone's guess which style of\n      // getStats() they implement.\n\n    } else {\n      cb(null, []);\n    }\n  }\n\n  _maybeReady() {\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady);\n\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return;\n    this._connecting = true; // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\n\n    const findCandidatePair = () => {\n      if (this.destroyed) return;\n      this.getStats((err, items) => {\n        if (this.destroyed) return; // Treat getStats error as non-fatal. It's not essential.\n\n        if (err) items = [];\n        var remoteCandidates = {};\n        var localCandidates = {};\n        var candidatePairs = {};\n        var foundSelectedCandidatePair = false;\n        items.forEach(item => {\n          // TODO: Once all browsers support the hyphenated stats report types, remove\n          // the non-hypenated ones\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\n            remoteCandidates[item.id] = item;\n          }\n\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\n            localCandidates[item.id] = item;\n          }\n\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\n            candidatePairs[item.id] = item;\n          }\n        });\n\n        const setSelectedCandidatePair = selectedCandidatePair => {\n          foundSelectedCandidatePair = true;\n          var local = localCandidates[selectedCandidatePair.localCandidateId];\n\n          if (local && (local.ip || local.address)) {\n            // Spec\n            this.localAddress = local.ip || local.address;\n            this.localPort = Number(local.port);\n          } else if (local && local.ipAddress) {\n            // Firefox\n            this.localAddress = local.ipAddress;\n            this.localPort = Number(local.portNumber);\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\n            // TODO: remove this once Chrome 58 is released\n            local = selectedCandidatePair.googLocalAddress.split(':');\n            this.localAddress = local[0];\n            this.localPort = Number(local[1]);\n          }\n\n          if (this.localAddress) {\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4';\n          }\n\n          var remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];\n\n          if (remote && (remote.ip || remote.address)) {\n            // Spec\n            this.remoteAddress = remote.ip || remote.address;\n            this.remotePort = Number(remote.port);\n          } else if (remote && remote.ipAddress) {\n            // Firefox\n            this.remoteAddress = remote.ipAddress;\n            this.remotePort = Number(remote.portNumber);\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\n            // TODO: remove this once Chrome 58 is released\n            remote = selectedCandidatePair.googRemoteAddress.split(':');\n            this.remoteAddress = remote[0];\n            this.remotePort = Number(remote[1]);\n          }\n\n          if (this.remoteAddress) {\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4';\n          }\n\n          this._debug('connect local: %s:%s remote: %s:%s', this.localAddress, this.localPort, this.remoteAddress, this.remotePort);\n        };\n\n        items.forEach(item => {\n          // Spec-compliant\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);\n          } // Old implementations\n\n\n          if (item.type === 'googCandidatePair' && item.googActiveConnection === 'true' || (item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected) {\n            setSelectedCandidatePair(item);\n          }\n        }); // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\n        // But wait until at least 1 candidate pair is available\n\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\n          setTimeout(findCandidatePair, 100);\n          return;\n        } else {\n          this._connecting = false;\n          this._connected = true;\n        }\n\n        if (this._chunk) {\n          try {\n            this.send(this._chunk);\n          } catch (err) {\n            return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'));\n          }\n\n          this._chunk = null;\n\n          this._debug('sent chunk from \"write before connect\"');\n\n          var cb = this._cb;\n          this._cb = null;\n          cb(null);\n        } // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\n        // fallback to using setInterval to implement backpressure.\n\n\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\n          this._interval = setInterval(() => this._onInterval(), 150);\n          if (this._interval.unref) this._interval.unref();\n        }\n\n        this._debug('connect');\n\n        this.emit('connect');\n      });\n    };\n\n    findCandidatePair();\n  }\n\n  _onInterval() {\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n      return;\n    }\n\n    this._onChannelBufferedAmountLow();\n  }\n\n  _onSignalingStateChange() {\n    if (this.destroyed) return;\n\n    if (this._pc.signalingState === 'stable' && !this._firstStable) {\n      this._isNegotiating = false; // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\n\n      this._debug('flushing sender queue', this._sendersAwaitingStable);\n\n      this._sendersAwaitingStable.forEach(sender => {\n        this._pc.removeTrack(sender);\n\n        this._queuedNegotiation = true;\n      });\n\n      this._sendersAwaitingStable = [];\n\n      if (this._queuedNegotiation) {\n        this._debug('flushing negotiation queue');\n\n        this._queuedNegotiation = false;\n\n        this._needsNegotiation(); // negotiate again\n\n      }\n\n      this._debug('negotiate');\n\n      this.emit('negotiate');\n    }\n\n    this._firstStable = false;\n\n    this._debug('signalingStateChange %s', this._pc.signalingState);\n\n    this.emit('signalingStateChange', this._pc.signalingState);\n  }\n\n  _onIceCandidate(event) {\n    if (this.destroyed) return;\n\n    if (event.candidate && this.trickle) {\n      this.emit('signal', {\n        candidate: {\n          candidate: event.candidate.candidate,\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          sdpMid: event.candidate.sdpMid\n        }\n      });\n    } else if (!event.candidate && !this._iceComplete) {\n      this._iceComplete = true;\n      this.emit('_iceComplete');\n    } // as soon as we've received one valid candidate start timeout\n\n\n    if (event.candidate) {\n      this._startIceCompleteTimeout();\n    }\n  }\n\n  _onChannelMessage(event) {\n    if (this.destroyed) return;\n    var data = event.data;\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n    this.push(data);\n  }\n\n  _onChannelBufferedAmountLow() {\n    if (this.destroyed || !this._cb) return;\n\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount);\n\n    var cb = this._cb;\n    this._cb = null;\n    cb(null);\n  }\n\n  _onChannelOpen() {\n    if (this._connected || this.destroyed) return;\n\n    this._debug('on channel open');\n\n    this._channelReady = true;\n\n    this._maybeReady();\n  }\n\n  _onChannelClose() {\n    if (this.destroyed) return;\n\n    this._debug('on channel close');\n\n    this.destroy();\n  }\n\n  _onTrack(event) {\n    if (this.destroyed) return;\n    event.streams.forEach(eventStream => {\n      this._debug('on track');\n\n      this.emit('track', event.track, eventStream);\n\n      this._remoteTracks.push({\n        track: event.track,\n        stream: eventStream\n      });\n\n      if (this._remoteStreams.some(remoteStream => {\n        return remoteStream.id === eventStream.id;\n      })) return; // Only fire one 'stream' event, even though there may be multiple tracks per stream\n\n      this._remoteStreams.push(eventStream);\n\n      queueMicrotask(() => {\n        this.emit('stream', eventStream); // ensure all tracks have been added\n      });\n    });\n  }\n\n  _debug() {\n    var args = [].slice.call(arguments);\n    args[0] = '[' + this._id + '] ' + args[0];\n    debug.apply(null, args);\n  }\n\n}\n\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC();\n/**\n * Expose peer and data channel config for overriding all Peer\n * instances. Otherwise, just set opts.config or opts.channelConfig\n * when constructing a Peer.\n */\n\nPeer.config = {\n  iceServers: [{\n    urls: ['stun:stun.l.google.com:19302', 'stun:global.stun.twilio.com:3478']\n  }],\n  sdpSemantics: 'unified-plan'\n};\nPeer.channelConfig = {};\nmodule.exports = Peer;","map":{"version":3,"names":["debug","require","getBrowserRTC","randombytes","stream","queueMicrotask","errCode","MAX_BUFFERED_AMOUNT","ICECOMPLETE_TIMEOUT","CHANNEL_CLOSING_TIMEOUT","filterTrickle","sdp","replace","warn","message","console","Peer","Duplex","constructor","opts","Object","assign","allowHalfOpen","_id","toString","slice","_debug","channelName","initiator","channelConfig","negotiated","config","offerOptions","answerOptions","sdpTransform","streams","trickle","undefined","allowHalfTrickle","iceCompleteTimeout","_connected","remoteAddress","remoteFamily","remotePort","localAddress","localFamily","localPort","_wrtc","wrtc","window","Error","_pcReady","_channelReady","_iceComplete","_iceCompleteTimer","_channel","_pendingCandidates","_isNegotiating","_batchedNegotiation","_queuedNegotiation","_sendersAwaitingStable","_senderMap","Map","_firstStable","_closingInterval","_remoteTracks","_remoteStreams","_chunk","_cb","_interval","_pc","RTCPeerConnection","err","destroy","_isReactNativeWebrtc","_peerConnectionId","oniceconnectionstatechange","_onIceStateChange","onicegatheringstatechange","onconnectionstatechange","_onConnectionStateChange","onsignalingstatechange","_onSignalingStateChange","onicecandidate","event","_onIceCandidate","_setupData","channel","createDataChannel","ondatachannel","forEach","addStream","ontrack","_onTrack","_needsNegotiation","_onFinishBound","_onFinish","once","bufferSize","bufferedAmount","connected","readyState","address","port","family","signal","data","destroyed","JSON","parse","renegotiate","transceiverRequest","addTransceiver","kind","init","candidate","remoteDescription","type","_addIceCandidate","push","setRemoteDescription","RTCSessionDescription","then","_createAnswer","catch","iceCandidateObj","RTCIceCandidate","addIceCandidate","endsWith","send","chunk","emit","getTracks","track","addTrack","submap","get","sender","set","removed","replaceTrack","oldTrack","newTrack","removeTrack","name","removeStream","negotiate","setTimeout","_createOffer","_destroy","cb","readable","writable","_readableState","ended","_writableState","finished","end","clearInterval","removeListener","close","onmessage","onopen","onclose","onerror","binaryType","bufferedAmountLowThreshold","label","_onChannelMessage","onbufferedamountlow","_onChannelBufferedAmountLow","_onChannelOpen","_onChannelClose","isClosing","setInterval","_read","_write","encoding","destroySoon","_startIceCompleteTimeout","createOffer","offer","sendOffer","localDescription","onSuccess","onError","setLocalDescription","_requestMissingTransceivers","getTransceivers","transceiver","mid","requested","createAnswer","answer","sendAnswer","connectionState","iceConnectionState","iceGatheringState","_maybeReady","getStats","flattenValues","report","prototype","call","values","value","length","res","reports","result","names","stat","id","timestamp","_connecting","findCandidatePair","items","remoteCandidates","localCandidates","candidatePairs","foundSelectedCandidatePair","item","setSelectedCandidatePair","selectedCandidatePair","local","localCandidateId","ip","Number","ipAddress","portNumber","googLocalAddress","split","includes","remote","remoteCandidateId","googRemoteAddress","selectedCandidatePairId","googActiveConnection","selected","keys","_onInterval","unref","signalingState","sdpMLineIndex","sdpMid","ArrayBuffer","Uint8Array","eventStream","some","remoteStream","args","arguments","apply","WEBRTC_SUPPORT","iceServers","urls","sdpSemantics","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-webrtc-peer/index.js"],"sourcesContent":["/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nvar debug = require('debug')('simple-peer')\nvar getBrowserRTC = require('get-browser-rtc')\nvar randombytes = require('randombytes')\nvar stream = require('readable-stream')\nvar queueMicrotask = require('queue-microtask') // TODO: remove when Node 10 is not supported\nvar errCode = require('err-code')\n\nvar MAX_BUFFERED_AMOUNT = 64 * 1024\nvar ICECOMPLETE_TIMEOUT = 5 * 1000\nvar CHANNEL_CLOSING_TIMEOUT = 5 * 1000\n\n// HACK: Filter trickle lines when trickle is disabled #354\nfunction filterTrickle (sdp) {\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\n}\n\nfunction warn (message) {\n  console.warn(message)\n}\n\n/**\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\n * Duplex stream.\n * @param {Object} opts\n */\nclass Peer extends stream.Duplex {\n  constructor (opts) {\n    opts = Object.assign({\n      allowHalfOpen: false\n    }, opts)\n\n    super(opts)\n\n    this._id = randombytes(4).toString('hex').slice(0, 7)\n    this._debug('new peer %o', opts)\n\n    this.channelName = opts.initiator\n      ? opts.channelName || randombytes(20).toString('hex')\n      : null\n\n    this.initiator = opts.initiator || false\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\n    this.negotiated = this.channelConfig.negotiated\n    this.config = Object.assign({}, Peer.config, opts.config)\n    this.offerOptions = opts.offerOptions || {}\n    this.answerOptions = opts.answerOptions || {}\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\n    this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old \"stream\" option\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\n\n    this._connected = false\n\n    this.remoteAddress = undefined\n    this.remoteFamily = undefined\n    this.remotePort = undefined\n    this.localAddress = undefined\n    this.localFamily = undefined\n    this.localPort = undefined\n\n    this._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')\n      ? opts.wrtc\n      : getBrowserRTC()\n\n    if (!this._wrtc) {\n      if (typeof window === 'undefined') {\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')\n      } else {\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')\n      }\n    }\n\n    this._pcReady = false\n    this._channelReady = false\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\n    this._channel = null\n    this._pendingCandidates = []\n\n    this._isNegotiating = this.negotiated ? false : !this.initiator // is this peer waiting for negotiation to complete?\n    this._batchedNegotiation = false // batch synchronous negotiations\n    this._queuedNegotiation = false // is there a queued negotiation request?\n    this._sendersAwaitingStable = []\n    this._senderMap = new Map()\n    this._firstStable = true\n    this._closingInterval = null\n\n    this._remoteTracks = []\n    this._remoteStreams = []\n\n    this._chunk = null\n    this._cb = null\n    this._interval = null\n\n    try {\n      this._pc = new (this._wrtc.RTCPeerConnection)(this.config)\n    } catch (err) {\n      queueMicrotask(() => this.destroy(errCode(err, 'ERR_PC_CONSTRUCTOR')))\n      return\n    }\n\n    // We prefer feature detection whenever possible, but sometimes that's not\n    // possible for certain implementations.\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\n\n    this._pc.oniceconnectionstatechange = () => {\n      this._onIceStateChange()\n    }\n    this._pc.onicegatheringstatechange = () => {\n      this._onIceStateChange()\n    }\n    this._pc.onconnectionstatechange = () => {\n      this._onConnectionStateChange()\n    }\n    this._pc.onsignalingstatechange = () => {\n      this._onSignalingStateChange()\n    }\n    this._pc.onicecandidate = event => {\n      this._onIceCandidate(event)\n    }\n\n    // Other spec events, unused by this implementation:\n    // - onconnectionstatechange\n    // - onicecandidateerror\n    // - onfingerprintfailure\n    // - onnegotiationneeded\n\n    if (this.initiator || this.negotiated) {\n      this._setupData({\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\n      })\n    } else {\n      this._pc.ondatachannel = event => {\n        this._setupData(event)\n      }\n    }\n\n    if (this.streams) {\n      this.streams.forEach(stream => {\n        this.addStream(stream)\n      })\n    }\n    this._pc.ontrack = event => {\n      this._onTrack(event)\n    }\n\n    if (this.initiator) {\n      this._needsNegotiation()\n    }\n\n    this._onFinishBound = () => {\n      this._onFinish()\n    }\n    this.once('finish', this._onFinishBound)\n  }\n\n  get bufferSize () {\n    return (this._channel && this._channel.bufferedAmount) || 0\n  }\n\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n  get connected () {\n    return (this._connected && this._channel.readyState === 'open')\n  }\n\n  address () {\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\n  }\n\n  signal (data) {\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_SIGNALING')\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data)\n      } catch (err) {\n        data = {}\n      }\n    }\n    this._debug('signal()')\n\n    if (data.renegotiate && this.initiator) {\n      this._debug('got request to renegotiate')\n      this._needsNegotiation()\n    }\n    if (data.transceiverRequest && this.initiator) {\n      this._debug('got request for transceiver')\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\n    }\n    if (data.candidate) {\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\n        this._addIceCandidate(data.candidate)\n      } else {\n        this._pendingCandidates.push(data.candidate)\n      }\n    }\n    if (data.sdp) {\n      this._pc.setRemoteDescription(new (this._wrtc.RTCSessionDescription)(data))\n        .then(() => {\n          if (this.destroyed) return\n\n          this._pendingCandidates.forEach(candidate => {\n            this._addIceCandidate(candidate)\n          })\n          this._pendingCandidates = []\n\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\n        })\n        .catch(err => {\n          this.destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))\n        })\n    }\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\n      this.destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))\n    }\n  }\n\n  _addIceCandidate (candidate) {\n    var iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate)\n    this._pc.addIceCandidate(iceCandidateObj)\n      .catch(err => {\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\n          warn('Ignoring unsupported ICE candidate.')\n        } else {\n          this.destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))\n        }\n      })\n  }\n\n  /**\n   * Send text/binary data to the remote peer.\n   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk\n   */\n  send (chunk) {\n    this._channel.send(chunk)\n  }\n\n  /**\n   * Add a Transceiver to the connection.\n   * @param {String} kind\n   * @param {Object} init\n   */\n  addTransceiver (kind, init) {\n    this._debug('addTransceiver()')\n\n    if (this.initiator) {\n      try {\n        this._pc.addTransceiver(kind, init)\n        this._needsNegotiation()\n      } catch (err) {\n        this.destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'))\n      }\n    } else {\n      this.emit('signal', { // request initiator to renegotiate\n        transceiverRequest: { kind, init }\n      })\n    }\n  }\n\n  /**\n   * Add a MediaStream to the connection.\n   * @param {MediaStream} stream\n   */\n  addStream (stream) {\n    this._debug('addStream()')\n\n    stream.getTracks().forEach(track => {\n      this.addTrack(track, stream)\n    })\n  }\n\n  /**\n   * Add a MediaStreamTrack to the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */\n  addTrack (track, stream) {\n    this._debug('addTrack()')\n\n    var submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender\n    var sender = submap.get(stream)\n    if (!sender) {\n      sender = this._pc.addTrack(track, stream)\n      submap.set(stream, sender)\n      this._senderMap.set(track, submap)\n      this._needsNegotiation()\n    } else if (sender.removed) {\n      throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED')\n    } else {\n      throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED')\n    }\n  }\n\n  /**\n   * Replace a MediaStreamTrack by another in the connection.\n   * @param {MediaStreamTrack} oldTrack\n   * @param {MediaStreamTrack} newTrack\n   * @param {MediaStream} stream\n   */\n  replaceTrack (oldTrack, newTrack, stream) {\n    this._debug('replaceTrack()')\n\n    var submap = this._senderMap.get(oldTrack)\n    var sender = submap ? submap.get(stream) : null\n    if (!sender) {\n      throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED')\n    }\n    if (newTrack) this._senderMap.set(newTrack, submap)\n\n    if (sender.replaceTrack != null) {\n      sender.replaceTrack(newTrack)\n    } else {\n      this.destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'))\n    }\n  }\n\n  /**\n   * Remove a MediaStreamTrack from the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */\n  removeTrack (track, stream) {\n    this._debug('removeSender()')\n\n    var submap = this._senderMap.get(track)\n    var sender = submap ? submap.get(stream) : null\n    if (!sender) {\n      throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED')\n    }\n    try {\n      sender.removed = true\n      this._pc.removeTrack(sender)\n    } catch (err) {\n      if (err.name === 'NS_ERROR_UNEXPECTED') {\n        this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n      } else {\n        this.destroy(errCode(err, 'ERR_REMOVE_TRACK'))\n      }\n    }\n    this._needsNegotiation()\n  }\n\n  /**\n   * Remove a MediaStream from the connection.\n   * @param {MediaStream} stream\n   */\n  removeStream (stream) {\n    this._debug('removeSenders()')\n\n    stream.getTracks().forEach(track => {\n      this.removeTrack(track, stream)\n    })\n  }\n\n  _needsNegotiation () {\n    this._debug('_needsNegotiation')\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\n    this._batchedNegotiation = true\n    queueMicrotask(() => {\n      this._batchedNegotiation = false\n      this._debug('starting batched negotiation')\n      this.negotiate()\n    })\n  }\n\n  negotiate () {\n    if (this.initiator) {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true\n        this._debug('already negotiating, queueing')\n      } else {\n        this._debug('start negotiation')\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\n          this._createOffer()\n        }, 0)\n      }\n    } else {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true\n        this._debug('already negotiating, queueing')\n      } else {\n        this._debug('requesting negotiation from initiator')\n        this.emit('signal', { // request initiator to renegotiate\n          renegotiate: true\n        })\n      }\n    }\n    this._isNegotiating = true\n  }\n\n  _destroy (err, cb) {\n    this._debug('destroy (error: %s)', err && (err.message || err))\n\n    this.readable = this.writable = false\n\n    if (!this._readableState.ended) this.push(null)\n    if (!this._writableState.finished) this.end()\n\n    this._connected = false\n    this._pcReady = false\n    this._channelReady = false\n    this._remoteTracks = null\n    this._remoteStreams = null\n    this._senderMap = null\n\n    clearInterval(this._closingInterval)\n    this._closingInterval = null\n\n    clearInterval(this._interval)\n    this._interval = null\n    this._chunk = null\n    this._cb = null\n\n    if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\n    this._onFinishBound = null\n\n    if (this._channel) {\n      try {\n        this._channel.close()\n      } catch (err) {}\n\n      this._channel.onmessage = null\n      this._channel.onopen = null\n      this._channel.onclose = null\n      this._channel.onerror = null\n    }\n    if (this._pc) {\n      try {\n        this._pc.close()\n      } catch (err) {}\n\n      this._pc.oniceconnectionstatechange = null\n      this._pc.onicegatheringstatechange = null\n      this._pc.onsignalingstatechange = null\n      this._pc.onicecandidate = null\n      this._pc.ontrack = null\n      this._pc.ondatachannel = null\n    }\n    this._pc = null\n    this._channel = null\n\n    cb(err)\n  }\n\n  _setupData (event) {\n    if (!event.channel) {\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n      // which is invalid behavior. Handle it gracefully.\n      // See: https://github.com/feross/simple-peer/issues/163\n      return this.destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))\n    }\n\n    this._channel = event.channel\n    this._channel.binaryType = 'arraybuffer'\n\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\n    }\n\n    this.channelName = this._channel.label\n\n    this._channel.onmessage = event => {\n      this._onChannelMessage(event)\n    }\n    this._channel.onbufferedamountlow = () => {\n      this._onChannelBufferedAmountLow()\n    }\n    this._channel.onopen = () => {\n      this._onChannelOpen()\n    }\n    this._channel.onclose = () => {\n      this._onChannelClose()\n    }\n    this._channel.onerror = err => {\n      this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\n    }\n\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n    var isClosing = false\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\n      if (this._channel && this._channel.readyState === 'closing') {\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\n        isClosing = true\n      } else {\n        isClosing = false\n      }\n    }, CHANNEL_CLOSING_TIMEOUT)\n  }\n\n  _read () {}\n\n  _write (chunk, encoding, cb) {\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))\n\n    if (this._connected) {\n      try {\n        this.send(chunk)\n      } catch (err) {\n        return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\n      }\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\n        this._cb = cb\n      } else {\n        cb(null)\n      }\n    } else {\n      this._debug('write before connect')\n      this._chunk = chunk\n      this._cb = cb\n    }\n  }\n\n  // When stream finishes writing, close socket. Half open connections are not\n  // supported.\n  _onFinish () {\n    if (this.destroyed) return\n\n    // Wait a bit before destroying so the socket flushes.\n    // TODO: is there a more reliable way to accomplish this?\n    const destroySoon = () => {\n      setTimeout(() => this.destroy(), 1000)\n    }\n\n    if (this._connected) {\n      destroySoon()\n    } else {\n      this.once('connect', destroySoon)\n    }\n  }\n\n  _startIceCompleteTimeout () {\n    if (this.destroyed) return\n    if (this._iceCompleteTimer) return\n    this._debug('started iceComplete timeout')\n    this._iceCompleteTimer = setTimeout(() => {\n      if (!this._iceComplete) {\n        this._iceComplete = true\n        this._debug('iceComplete timeout completed')\n        this.emit('iceTimeout')\n        this.emit('_iceComplete')\n      }\n    }, this.iceCompleteTimeout)\n  }\n\n  _createOffer () {\n    if (this.destroyed) return\n\n    this._pc.createOffer(this.offerOptions)\n      .then(offer => {\n        if (this.destroyed) return\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\n        offer.sdp = this.sdpTransform(offer.sdp)\n\n        const sendOffer = () => {\n          if (this.destroyed) return\n          var signal = this._pc.localDescription || offer\n          this._debug('signal')\n          this.emit('signal', {\n            type: signal.type,\n            sdp: signal.sdp\n          })\n        }\n\n        const onSuccess = () => {\n          this._debug('createOffer success')\n          if (this.destroyed) return\n          if (this.trickle || this._iceComplete) sendOffer()\n          else this.once('_iceComplete', sendOffer) // wait for candidates\n        }\n\n        const onError = err => {\n          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\n        }\n\n        this._pc.setLocalDescription(offer)\n          .then(onSuccess)\n          .catch(onError)\n      })\n      .catch(err => {\n        this.destroy(errCode(err, 'ERR_CREATE_OFFER'))\n      })\n  }\n\n  _requestMissingTransceivers () {\n    if (this._pc.getTransceivers) {\n      this._pc.getTransceivers().forEach(transceiver => {\n        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\n          transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid\n          this.addTransceiver(transceiver.sender.track.kind)\n        }\n      })\n    }\n  }\n\n  _createAnswer () {\n    if (this.destroyed) return\n\n    this._pc.createAnswer(this.answerOptions)\n      .then(answer => {\n        if (this.destroyed) return\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\n        answer.sdp = this.sdpTransform(answer.sdp)\n\n        const sendAnswer = () => {\n          if (this.destroyed) return\n          var signal = this._pc.localDescription || answer\n          this._debug('signal')\n          this.emit('signal', {\n            type: signal.type,\n            sdp: signal.sdp\n          })\n          if (!this.initiator) this._requestMissingTransceivers()\n        }\n\n        const onSuccess = () => {\n          if (this.destroyed) return\n          if (this.trickle || this._iceComplete) sendAnswer()\n          else this.once('_iceComplete', sendAnswer)\n        }\n\n        const onError = err => {\n          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\n        }\n\n        this._pc.setLocalDescription(answer)\n          .then(onSuccess)\n          .catch(onError)\n      })\n      .catch(err => {\n        this.destroy(errCode(err, 'ERR_CREATE_ANSWER'))\n      })\n  }\n\n  _onConnectionStateChange () {\n    if (this.destroyed) return\n    if (this._pc.connectionState === 'failed') {\n      this.destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))\n    }\n  }\n\n  _onIceStateChange () {\n    if (this.destroyed) return\n    var iceConnectionState = this._pc.iceConnectionState\n    var iceGatheringState = this._pc.iceGatheringState\n\n    this._debug(\n      'iceStateChange (connection: %s) (gathering: %s)',\n      iceConnectionState,\n      iceGatheringState\n    )\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\n\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\n      this._pcReady = true\n      this._maybeReady()\n    }\n    if (iceConnectionState === 'failed') {\n      this.destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))\n    }\n    if (iceConnectionState === 'closed') {\n      this.destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))\n    }\n  }\n\n  getStats (cb) {\n    // statreports can come with a value array instead of properties\n    const flattenValues = report => {\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\n        report.values.forEach(value => {\n          Object.assign(report, value)\n        })\n      }\n      return report\n    }\n\n    // Promise-based getStats() (standard)\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\n      this._pc.getStats()\n        .then(res => {\n          var reports = []\n          res.forEach(report => {\n            reports.push(flattenValues(report))\n          })\n          cb(null, reports)\n        }, err => cb(err))\n\n    // Single-parameter callback-based getStats() (non-standard)\n    } else if (this._pc.getStats.length > 0) {\n      this._pc.getStats(res => {\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\n        if (this.destroyed) return\n\n        var reports = []\n        res.result().forEach(result => {\n          var report = {}\n          result.names().forEach(name => {\n            report[name] = result.stat(name)\n          })\n          report.id = result.id\n          report.type = result.type\n          report.timestamp = result.timestamp\n          reports.push(flattenValues(report))\n        })\n        cb(null, reports)\n      }, err => cb(err))\n\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\n    // getStats() they implement.\n    } else {\n      cb(null, [])\n    }\n  }\n\n  _maybeReady () {\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\n\n    this._connecting = true\n\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\n    const findCandidatePair = () => {\n      if (this.destroyed) return\n\n      this.getStats((err, items) => {\n        if (this.destroyed) return\n\n        // Treat getStats error as non-fatal. It's not essential.\n        if (err) items = []\n\n        var remoteCandidates = {}\n        var localCandidates = {}\n        var candidatePairs = {}\n        var foundSelectedCandidatePair = false\n\n        items.forEach(item => {\n          // TODO: Once all browsers support the hyphenated stats report types, remove\n          // the non-hypenated ones\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\n            remoteCandidates[item.id] = item\n          }\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\n            localCandidates[item.id] = item\n          }\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\n            candidatePairs[item.id] = item\n          }\n        })\n\n        const setSelectedCandidatePair = selectedCandidatePair => {\n          foundSelectedCandidatePair = true\n\n          var local = localCandidates[selectedCandidatePair.localCandidateId]\n\n          if (local && (local.ip || local.address)) {\n            // Spec\n            this.localAddress = local.ip || local.address\n            this.localPort = Number(local.port)\n          } else if (local && local.ipAddress) {\n            // Firefox\n            this.localAddress = local.ipAddress\n            this.localPort = Number(local.portNumber)\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\n            // TODO: remove this once Chrome 58 is released\n            local = selectedCandidatePair.googLocalAddress.split(':')\n            this.localAddress = local[0]\n            this.localPort = Number(local[1])\n          }\n          if (this.localAddress) {\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\n          }\n\n          var remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\n\n          if (remote && (remote.ip || remote.address)) {\n            // Spec\n            this.remoteAddress = remote.ip || remote.address\n            this.remotePort = Number(remote.port)\n          } else if (remote && remote.ipAddress) {\n            // Firefox\n            this.remoteAddress = remote.ipAddress\n            this.remotePort = Number(remote.portNumber)\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\n            // TODO: remove this once Chrome 58 is released\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\n            this.remoteAddress = remote[0]\n            this.remotePort = Number(remote[1])\n          }\n          if (this.remoteAddress) {\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\n          }\n\n          this._debug(\n            'connect local: %s:%s remote: %s:%s',\n            this.localAddress, this.localPort, this.remoteAddress, this.remotePort\n          )\n        }\n\n        items.forEach(item => {\n          // Spec-compliant\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\n          }\n\n          // Old implementations\n          if (\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\n          ) {\n            setSelectedCandidatePair(item)\n          }\n        })\n\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\n        // But wait until at least 1 candidate pair is available\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\n          setTimeout(findCandidatePair, 100)\n          return\n        } else {\n          this._connecting = false\n          this._connected = true\n        }\n\n        if (this._chunk) {\n          try {\n            this.send(this._chunk)\n          } catch (err) {\n            return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\n          }\n          this._chunk = null\n          this._debug('sent chunk from \"write before connect\"')\n\n          var cb = this._cb\n          this._cb = null\n          cb(null)\n        }\n\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\n        // fallback to using setInterval to implement backpressure.\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\n          this._interval = setInterval(() => this._onInterval(), 150)\n          if (this._interval.unref) this._interval.unref()\n        }\n\n        this._debug('connect')\n        this.emit('connect')\n      })\n    }\n    findCandidatePair()\n  }\n\n  _onInterval () {\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n      return\n    }\n    this._onChannelBufferedAmountLow()\n  }\n\n  _onSignalingStateChange () {\n    if (this.destroyed) return\n\n    if (this._pc.signalingState === 'stable' && !this._firstStable) {\n      this._isNegotiating = false\n\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\n      this._sendersAwaitingStable.forEach(sender => {\n        this._pc.removeTrack(sender)\n        this._queuedNegotiation = true\n      })\n      this._sendersAwaitingStable = []\n\n      if (this._queuedNegotiation) {\n        this._debug('flushing negotiation queue')\n        this._queuedNegotiation = false\n        this._needsNegotiation() // negotiate again\n      }\n\n      this._debug('negotiate')\n      this.emit('negotiate')\n    }\n    this._firstStable = false\n\n    this._debug('signalingStateChange %s', this._pc.signalingState)\n    this.emit('signalingStateChange', this._pc.signalingState)\n  }\n\n  _onIceCandidate (event) {\n    if (this.destroyed) return\n    if (event.candidate && this.trickle) {\n      this.emit('signal', {\n        candidate: {\n          candidate: event.candidate.candidate,\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          sdpMid: event.candidate.sdpMid\n        }\n      })\n    } else if (!event.candidate && !this._iceComplete) {\n      this._iceComplete = true\n      this.emit('_iceComplete')\n    }\n    // as soon as we've received one valid candidate start timeout\n    if (event.candidate) {\n      this._startIceCompleteTimeout()\n    }\n  }\n\n  _onChannelMessage (event) {\n    if (this.destroyed) return\n    var data = event.data\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data)\n    this.push(data)\n  }\n\n  _onChannelBufferedAmountLow () {\n    if (this.destroyed || !this._cb) return\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\n    var cb = this._cb\n    this._cb = null\n    cb(null)\n  }\n\n  _onChannelOpen () {\n    if (this._connected || this.destroyed) return\n    this._debug('on channel open')\n    this._channelReady = true\n    this._maybeReady()\n  }\n\n  _onChannelClose () {\n    if (this.destroyed) return\n    this._debug('on channel close')\n    this.destroy()\n  }\n\n  _onTrack (event) {\n    if (this.destroyed) return\n\n    event.streams.forEach(eventStream => {\n      this._debug('on track')\n      this.emit('track', event.track, eventStream)\n\n      this._remoteTracks.push({\n        track: event.track,\n        stream: eventStream\n      })\n\n      if (this._remoteStreams.some(remoteStream => {\n        return remoteStream.id === eventStream.id\n      })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream\n\n      this._remoteStreams.push(eventStream)\n      queueMicrotask(() => {\n        this.emit('stream', eventStream) // ensure all tracks have been added\n      })\n    })\n  }\n\n  _debug () {\n    var args = [].slice.call(arguments)\n    args[0] = '[' + this._id + '] ' + args[0]\n    debug.apply(null, args)\n  }\n}\n\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC()\n\n/**\n * Expose peer and data channel config for overriding all Peer\n * instances. Otherwise, just set opts.config or opts.channelConfig\n * when constructing a Peer.\n */\nPeer.config = {\n  iceServers: [\n    {\n      urls: [\n        'stun:stun.l.google.com:19302',\n        'stun:global.stun.twilio.com:3478'\n      ]\n    }\n  ],\n  sdpSemantics: 'unified-plan'\n}\n\nPeer.channelConfig = {}\n\nmodule.exports = Peer\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}