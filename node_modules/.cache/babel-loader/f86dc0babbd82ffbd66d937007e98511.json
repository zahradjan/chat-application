{"ast":null,"code":"'use strict'; // @ts-ignore\n\nconst KBuck = require('k-bucket');\n\nconst {\n  xor: uint8ArrayXor\n} = require('uint8arrays/xor');\n\nconst GENERATED_PREFIXES = require('./generated-prefix-list.json');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst crypto = require('libp2p-crypto');\n\nconst PeerId = require('peer-id');\n\nconst utils = require('../utils');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:dht:routing-table'), {\n  error: debug('libp2p:dht:routing-table:error')\n}); // @ts-ignore\n\nconst length = require('it-length');\n/**\n * @typedef {object} KBucketPeer\n * @property {Uint8Array} id\n * @property {PeerId} peer\n *\n * @typedef {object} KBucket\n * @property {Uint8Array} id\n * @property {KBucketPeer[]} contacts\n * @property {boolean} dontSplit\n * @property {KBucket} left\n * @property {KBucket} right\n *\n * @typedef {object} KBucketTree\n * @property {KBucket} root\n * @property {Uint8Array} localNodeId\n * @property {(event: string, callback: Function) => void} on\n * @property {(key: Uint8Array, count: number) => KBucketPeer[]} closest\n * @property {(key: Uint8Array) => KBucketPeer} closestPeer\n * @property {(key: Uint8Array) => void} remove\n * @property {(peer: KBucketPeer) => void} add\n * @property {() => number} count\n * @property {() => Iterable<KBucket>} toIterable\n */\n\n/**\n * Cannot generate random KadIds longer than this + 1\n */\n\n\nconst MAX_COMMON_PREFIX_LENGTH = 15;\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\n\nclass RoutingTable {\n  /**\n   * @param {import('../')} dht\n   * @param {object} [options]\n   * @param {number} [options.kBucketSize=20]\n   * @param {number} [options.refreshInterval=30000]\n   */\n  constructor(dht) {\n    let {\n      kBucketSize,\n      refreshInterval\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.peerId = dht.peerId;\n    this.dht = dht;\n    this._kBucketSize = kBucketSize || 20;\n    this._refreshInterval = refreshInterval || 30000;\n    /** @type {KBucketTree} */\n\n    this.kb = new KBuck({\n      numberOfNodesPerKBucket: this._kBucketSize,\n      numberOfNodesToPing: 1\n    });\n    /** @type {Date[]} */\n\n    this.commonPrefixLengthRefreshedAt = [];\n    this._refreshTable = this._refreshTable.bind(this);\n    this._onPing = this._onPing.bind(this);\n  }\n\n  async start() {\n    this.kb.localNodeId = await utils.convertPeerId(this.peerId);\n    this.kb.on('ping', this._onPing);\n    await this._refreshTable(true);\n  }\n\n  async stop() {\n    if (this._refreshTimeoutId) {\n      clearTimeout(this._refreshTimeoutId);\n    }\n  }\n  /**\n   * To speed lookups, we seed the table with random PeerIds. This means\n   * when we are asked to locate a peer on the network, we can find a KadId\n   * that is close to the requested peer ID and query that, then network\n   * peers will tell us who they know who is close to the fake ID\n   *\n   * @param {boolean} [force=false]\n   */\n\n\n  async _refreshTable(force) {\n    log('refreshing routing table');\n\n    const prefixLength = this._maxCommonPrefix();\n\n    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);\n\n    log(`max common prefix length ${prefixLength}`);\n    log(`tracked CPLs [ ${refreshCpls.map(date => `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`).join(', ')} ]`);\n    /**\n     * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n     * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n     * is smaller.\n     *\n     * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n     * before a very high max Cpl for which we do have peers in the network.\n     *\n     * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n     * the programmer had paid more attention in the Math classes at university.\n     *\n     * So, please be patient and a doc explaining it will be published soon.\n     *\n     * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n     */\n\n    await Promise.all(refreshCpls.map(async (lastRefresh, index) => {\n      try {\n        await this._refreshCommonPrefixLength(index, lastRefresh, force === true);\n\n        if (this._numPeersForCpl(prefixLength) === 0) {\n          const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);\n\n          for (let n = index + 1; n < lastCpl + 1; n++) {\n            try {\n              await this._refreshCommonPrefixLength(n, lastRefresh, force === true);\n            } catch (err) {\n              log.error(err);\n            }\n          }\n        }\n      } catch (err) {\n        log.error(err);\n      }\n    }));\n    this._refreshTimeoutId = setTimeout(this._refreshTable, this._refreshInterval); // @ts-ignore\n\n    this._refreshTimeoutId.unref();\n  }\n  /**\n   * @param {number} cpl\n   * @param {Date} lastRefresh\n   * @param {boolean} force\n   */\n\n\n  async _refreshCommonPrefixLength(cpl, lastRefresh, force) {\n    if (!force && lastRefresh.getTime() > Date.now() - this._refreshInterval) {\n      log(`not running refresh for cpl ${cpl} as time since last refresh not above interval`);\n      return;\n    } // gen a key for the query to refresh the cpl\n\n\n    const peerId = await this._generateRandomPeerId(cpl);\n    log(`starting refreshing cpl ${cpl} with key ${peerId.toB58String()} (routing table size was ${this.kb.count()})`);\n    const peers = await length(this.dht.getClosestPeers(peerId.toBytes(), {}));\n    log(`found ${peers} peers that were close to imaginary peer ${peerId.toB58String()}`);\n    log(`finished refreshing cpl ${cpl} with key ${peerId.toB58String()} (routing table size was ${this.kb.count()})`);\n  }\n  /**\n   * @param {number} maxCommonPrefix\n   */\n\n\n  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {\n    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;\n    }\n\n    const dates = [];\n\n    for (let i = 0; i <= maxCommonPrefix; i++) {\n      // defaults to the zero value if we haven't refreshed it yet.\n      dates[i] = this.commonPrefixLengthRefreshedAt[i] || new Date();\n    }\n\n    return dates;\n  }\n  /**\n   *\n   * @param {number} targetCommonPrefixLength\n   */\n\n\n  async _generateRandomPeerId(targetCommonPrefixLength) {\n    const randomBytes = crypto.randomBytes(2);\n    const randomUint16 = (randomBytes[1] << 8) + randomBytes[0];\n    const key = await this._makePeerId(this.kb.localNodeId, randomUint16, targetCommonPrefixLength);\n    return PeerId.createFromBytes(key);\n  }\n  /**\n   * @param {Uint8Array} localKadId\n   * @param {number} randomPrefix\n   * @param {number} targetCommonPrefixLength\n   */\n\n\n  async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {\n    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {\n      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);\n    }\n\n    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);\n    const localPrefix = view.getUint16(0, false); // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n    // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n    // to our randomly generated prefix.\n\n    const toggledLocalPrefix = localPrefix ^ 0x8000 >> targetCommonPrefixLength; // Combine the toggled local prefix and the random bits at the correct offset\n    // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n\n    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);\n    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask; // Convert to a known peer ID.\n\n    const keyPrefix = GENERATED_PREFIXES[targetPrefix];\n    const keyBuffer = new ArrayBuffer(34);\n    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);\n    keyView.setUint8(0, sha256.code);\n    keyView.setUint8(1, 32);\n    keyView.setUint32(2, keyPrefix, false);\n    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);\n  }\n  /**\n   * returns the maximum common prefix length between any peer in the table\n   * and the current peer\n   */\n\n\n  _maxCommonPrefix() {\n    if (!this.kb.localNodeId) {\n      return 0;\n    } // xor our KadId with every KadId in the k-bucket tree,\n    // return the longest id prefix that is the same\n\n\n    let prefixLength = 0;\n\n    for (const length of this._prefixLengths()) {\n      if (length > prefixLength) {\n        prefixLength = length;\n      }\n    }\n\n    return prefixLength;\n  }\n  /**\n   * Returns the number of peers in the table with a given prefix length\n   *\n   * @param {number} prefixLength\n   */\n\n\n  _numPeersForCpl(prefixLength) {\n    let count = 0;\n\n    for (const length of this._prefixLengths()) {\n      if (length === prefixLength) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n  /**\n   * Yields the common prefix length of every peer in the table\n   */\n\n\n  *_prefixLengths() {\n    for (const {\n      id\n    } of this.kb.toIterable()) {\n      const distance = uint8ArrayXor(this.kb.localNodeId, id);\n      let leadingZeros = 0;\n\n      for (const byte of distance) {\n        if (byte === 0) {\n          leadingZeros++;\n        } else {\n          break;\n        }\n      }\n\n      yield leadingZeros;\n    }\n  }\n  /**\n   * Called on the `ping` event from `k-bucket`.\n   * Currently this just removes the oldest contact from\n   * the list, without actually pinging the individual peers.\n   * This is the same as go does, but should probably\n   * be upgraded to actually ping the individual peers.\n   *\n   * @param {KBucketPeer[]} oldContacts\n   * @param {KBucketPeer} newContact\n   */\n\n\n  _onPing(oldContacts, newContact) {\n    // just use the first one (k-bucket sorts from oldest to newest)\n    const oldest = oldContacts[0];\n\n    if (oldest) {\n      // remove the oldest one\n      this.kb.remove(oldest.id);\n    } // add the new one\n\n\n    this.kb.add(newContact);\n  } // -- Public Interface\n\n  /**\n   * Amount of currently stored peers.\n   */\n\n\n  get size() {\n    return this.kb.count();\n  }\n  /**\n   * Find a specific peer by id.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async find(peer) {\n    const key = await utils.convertPeerId(peer);\n    const closest = this.closestPeer(key);\n\n    if (closest && peer.equals(closest)) {\n      return closest;\n    }\n  }\n  /**\n   * Retrieve the closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  closestPeer(key) {\n    const res = this.closestPeers(key, 1);\n\n    if (res.length > 0) {\n      return res[0];\n    }\n  }\n  /**\n   * Retrieve the `count`-closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   * @param {number} count\n   */\n\n\n  closestPeers(key, count) {\n    const closest = this.kb.closest(key, count);\n    return closest.map(p => p.peer);\n  }\n  /**\n   * Add or update the routing table with the given peer.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async add(peer) {\n    const id = await utils.convertPeerId(peer);\n    this.kb.add({\n      id: id,\n      peer: peer\n    });\n  }\n  /**\n   * Remove a given peer from the table.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async remove(peer) {\n    const id = await utils.convertPeerId(peer);\n    this.kb.remove(id);\n  }\n\n}\n\nmodule.exports = RoutingTable;","map":{"version":3,"names":["KBuck","require","xor","uint8ArrayXor","GENERATED_PREFIXES","sha256","crypto","PeerId","utils","debug","log","Object","assign","error","length","MAX_COMMON_PREFIX_LENGTH","RoutingTable","constructor","dht","kBucketSize","refreshInterval","peerId","_kBucketSize","_refreshInterval","kb","numberOfNodesPerKBucket","numberOfNodesToPing","commonPrefixLengthRefreshedAt","_refreshTable","bind","_onPing","start","localNodeId","convertPeerId","on","stop","_refreshTimeoutId","clearTimeout","force","prefixLength","_maxCommonPrefix","refreshCpls","_getTrackedCommonPrefixLengthsForRefresh","map","date","getFullYear","getMonth","toString","padStart","getDate","getHours","getMinutes","getSeconds","join","Promise","all","lastRefresh","index","_refreshCommonPrefixLength","_numPeersForCpl","lastCpl","Math","min","n","err","setTimeout","unref","cpl","getTime","Date","now","_generateRandomPeerId","toB58String","count","peers","getClosestPeers","toBytes","maxCommonPrefix","dates","i","targetCommonPrefixLength","randomBytes","randomUint16","key","_makePeerId","createFromBytes","localKadId","randomPrefix","Error","view","DataView","buffer","byteOffset","byteLength","localPrefix","getUint16","toggledLocalPrefix","mask","targetPrefix","keyPrefix","keyBuffer","ArrayBuffer","keyView","setUint8","code","setUint32","Uint8Array","_prefixLengths","id","toIterable","distance","leadingZeros","byte","oldContacts","newContact","oldest","remove","add","size","find","peer","closest","closestPeer","equals","res","closestPeers","p","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-kad-dht/src/routing-table/index.js"],"sourcesContent":["'use strict'\n\n// @ts-ignore\nconst KBuck = require('k-bucket')\nconst { xor: uint8ArrayXor } = require('uint8arrays/xor')\nconst GENERATED_PREFIXES = require('./generated-prefix-list.json')\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst utils = require('../utils')\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:dht:routing-table'), {\n  error: debug('libp2p:dht:routing-table:error')\n})\n// @ts-ignore\nconst length = require('it-length')\n\n/**\n * @typedef {object} KBucketPeer\n * @property {Uint8Array} id\n * @property {PeerId} peer\n *\n * @typedef {object} KBucket\n * @property {Uint8Array} id\n * @property {KBucketPeer[]} contacts\n * @property {boolean} dontSplit\n * @property {KBucket} left\n * @property {KBucket} right\n *\n * @typedef {object} KBucketTree\n * @property {KBucket} root\n * @property {Uint8Array} localNodeId\n * @property {(event: string, callback: Function) => void} on\n * @property {(key: Uint8Array, count: number) => KBucketPeer[]} closest\n * @property {(key: Uint8Array) => KBucketPeer} closestPeer\n * @property {(key: Uint8Array) => void} remove\n * @property {(peer: KBucketPeer) => void} add\n * @property {() => number} count\n * @property {() => Iterable<KBucket>} toIterable\n */\n\n/**\n * Cannot generate random KadIds longer than this + 1\n */\nconst MAX_COMMON_PREFIX_LENGTH = 15\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nclass RoutingTable {\n  /**\n   * @param {import('../')} dht\n   * @param {object} [options]\n   * @param {number} [options.kBucketSize=20]\n   * @param {number} [options.refreshInterval=30000]\n   */\n  constructor (dht, { kBucketSize, refreshInterval } = {}) {\n    this.peerId = dht.peerId\n    this.dht = dht\n    this._kBucketSize = kBucketSize || 20\n    this._refreshInterval = refreshInterval || 30000\n\n    /** @type {KBucketTree} */\n    this.kb = new KBuck({\n      numberOfNodesPerKBucket: this._kBucketSize,\n      numberOfNodesToPing: 1\n    })\n\n    /** @type {Date[]} */\n    this.commonPrefixLengthRefreshedAt = []\n\n    this._refreshTable = this._refreshTable.bind(this)\n    this._onPing = this._onPing.bind(this)\n  }\n\n  async start () {\n    this.kb.localNodeId = await utils.convertPeerId(this.peerId)\n    this.kb.on('ping', this._onPing)\n\n    await this._refreshTable(true)\n  }\n\n  async stop () {\n    if (this._refreshTimeoutId) {\n      clearTimeout(this._refreshTimeoutId)\n    }\n  }\n\n  /**\n   * To speed lookups, we seed the table with random PeerIds. This means\n   * when we are asked to locate a peer on the network, we can find a KadId\n   * that is close to the requested peer ID and query that, then network\n   * peers will tell us who they know who is close to the fake ID\n   *\n   * @param {boolean} [force=false]\n   */\n  async _refreshTable (force) {\n    log('refreshing routing table')\n\n    const prefixLength = this._maxCommonPrefix()\n    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength)\n\n    log(`max common prefix length ${prefixLength}`)\n    log(`tracked CPLs [ ${refreshCpls.map(date => `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`).join(', ')} ]`)\n\n    /**\n     * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n     * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n     * is smaller.\n     *\n     * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n     * before a very high max Cpl for which we do have peers in the network.\n     *\n     * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n     * the programmer had paid more attention in the Math classes at university.\n     *\n     * So, please be patient and a doc explaining it will be published soon.\n     *\n     * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n     */\n    await Promise.all(\n      refreshCpls.map(async (lastRefresh, index) => {\n        try {\n          await this._refreshCommonPrefixLength(index, lastRefresh, force === true)\n\n          if (this._numPeersForCpl(prefixLength) === 0) {\n            const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1)\n\n            for (let n = index + 1; n < lastCpl + 1; n++) {\n              try {\n                await this._refreshCommonPrefixLength(n, lastRefresh, force === true)\n              } catch (err) {\n                log.error(err)\n              }\n            }\n          }\n        } catch (err) {\n          log.error(err)\n        }\n      })\n    )\n\n    this._refreshTimeoutId = setTimeout(this._refreshTable, this._refreshInterval)\n    // @ts-ignore\n    this._refreshTimeoutId.unref()\n  }\n\n  /**\n   * @param {number} cpl\n   * @param {Date} lastRefresh\n   * @param {boolean} force\n   */\n  async _refreshCommonPrefixLength (cpl, lastRefresh, force) {\n    if (!force && lastRefresh.getTime() > (Date.now() - this._refreshInterval)) {\n      log(`not running refresh for cpl ${cpl} as time since last refresh not above interval`)\n      return\n    }\n\n    // gen a key for the query to refresh the cpl\n    const peerId = await this._generateRandomPeerId(cpl)\n\n    log(`starting refreshing cpl ${cpl} with key ${peerId.toB58String()} (routing table size was ${this.kb.count()})`)\n\n    const peers = await length(this.dht.getClosestPeers(peerId.toBytes(), {}))\n\n    log(`found ${peers} peers that were close to imaginary peer ${peerId.toB58String()}`)\n\n    log(`finished refreshing cpl ${cpl} with key ${peerId.toB58String()} (routing table size was ${this.kb.count()})`)\n  }\n\n  /**\n   * @param {number} maxCommonPrefix\n   */\n  _getTrackedCommonPrefixLengthsForRefresh (maxCommonPrefix) {\n    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH\n    }\n\n    const dates = []\n\n    for (let i = 0; i <= maxCommonPrefix; i++) {\n      // defaults to the zero value if we haven't refreshed it yet.\n      dates[i] = this.commonPrefixLengthRefreshedAt[i] || new Date()\n    }\n\n    return dates\n  }\n\n  /**\n   *\n   * @param {number} targetCommonPrefixLength\n   */\n  async _generateRandomPeerId (targetCommonPrefixLength) {\n    const randomBytes = crypto.randomBytes(2)\n    const randomUint16 = (randomBytes[1] << 8) + randomBytes[0]\n\n    const key = await this._makePeerId(this.kb.localNodeId, randomUint16, targetCommonPrefixLength)\n\n    return PeerId.createFromBytes(key)\n  }\n\n  /**\n   * @param {Uint8Array} localKadId\n   * @param {number} randomPrefix\n   * @param {number} targetCommonPrefixLength\n   */\n  async _makePeerId (localKadId, randomPrefix, targetCommonPrefixLength) {\n    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {\n      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`)\n    }\n\n    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength)\n    const localPrefix = view.getUint16(0, false)\n\n    // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n    // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n    // to our randomly generated prefix.\n    const toggledLocalPrefix = localPrefix ^ (0x8000 >> targetCommonPrefixLength)\n\n    // Combine the toggled local prefix and the random bits at the correct offset\n    // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n    const mask = 65535 << (16 - (targetCommonPrefixLength + 1))\n    const targetPrefix = (toggledLocalPrefix & mask) | (randomPrefix & ~mask)\n\n    // Convert to a known peer ID.\n    const keyPrefix = GENERATED_PREFIXES[targetPrefix]\n\n    const keyBuffer = new ArrayBuffer(34)\n    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength)\n    keyView.setUint8(0, sha256.code)\n    keyView.setUint8(1, 32)\n    keyView.setUint32(2, keyPrefix, false)\n\n    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength)\n  }\n\n  /**\n   * returns the maximum common prefix length between any peer in the table\n   * and the current peer\n   */\n  _maxCommonPrefix () {\n    if (!this.kb.localNodeId) {\n      return 0\n    }\n\n    // xor our KadId with every KadId in the k-bucket tree,\n    // return the longest id prefix that is the same\n    let prefixLength = 0\n\n    for (const length of this._prefixLengths()) {\n      if (length > prefixLength) {\n        prefixLength = length\n      }\n    }\n\n    return prefixLength\n  }\n\n  /**\n   * Returns the number of peers in the table with a given prefix length\n   *\n   * @param {number} prefixLength\n   */\n  _numPeersForCpl (prefixLength) {\n    let count = 0\n\n    for (const length of this._prefixLengths()) {\n      if (length === prefixLength) {\n        count++\n      }\n    }\n\n    return count\n  }\n\n  /**\n   * Yields the common prefix length of every peer in the table\n   */\n  * _prefixLengths () {\n    for (const { id } of this.kb.toIterable()) {\n      const distance = uint8ArrayXor(this.kb.localNodeId, id)\n      let leadingZeros = 0\n\n      for (const byte of distance) {\n        if (byte === 0) {\n          leadingZeros++\n        } else {\n          break\n        }\n      }\n\n      yield leadingZeros\n    }\n  }\n\n  /**\n   * Called on the `ping` event from `k-bucket`.\n   * Currently this just removes the oldest contact from\n   * the list, without actually pinging the individual peers.\n   * This is the same as go does, but should probably\n   * be upgraded to actually ping the individual peers.\n   *\n   * @param {KBucketPeer[]} oldContacts\n   * @param {KBucketPeer} newContact\n   */\n  _onPing (oldContacts, newContact) {\n    // just use the first one (k-bucket sorts from oldest to newest)\n    const oldest = oldContacts[0]\n\n    if (oldest) {\n      // remove the oldest one\n      this.kb.remove(oldest.id)\n    }\n\n    // add the new one\n    this.kb.add(newContact)\n  }\n\n  // -- Public Interface\n\n  /**\n   * Amount of currently stored peers.\n   */\n  get size () {\n    return this.kb.count()\n  }\n\n  /**\n   * Find a specific peer by id.\n   *\n   * @param {PeerId} peer\n   */\n  async find (peer) {\n    const key = await utils.convertPeerId(peer)\n    const closest = this.closestPeer(key)\n\n    if (closest && peer.equals(closest)) {\n      return closest\n    }\n  }\n\n  /**\n   * Retrieve the closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   */\n  closestPeer (key) {\n    const res = this.closestPeers(key, 1)\n\n    if (res.length > 0) {\n      return res[0]\n    }\n  }\n\n  /**\n   * Retrieve the `count`-closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   * @param {number} count\n   */\n  closestPeers (key, count) {\n    const closest = this.kb.closest(key, count)\n\n    return closest.map(p => p.peer)\n  }\n\n  /**\n   * Add or update the routing table with the given peer.\n   *\n   * @param {PeerId} peer\n   */\n  async add (peer) {\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.add({ id: id, peer: peer })\n  }\n\n  /**\n   * Remove a given peer from the table.\n   *\n   * @param {PeerId} peer\n   */\n  async remove (peer) {\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.remove(id)\n  }\n}\n\nmodule.exports = RoutingTable\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}