{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst Store = require('orbit-db-store');\n\nconst EventStore = require('orbit-db-eventstore');\n\nconst FeedStore = require('orbit-db-feedstore');\n\nconst KeyValueStore = require('orbit-db-kvstore');\n\nconst CounterStore = require('orbit-db-counterstore');\n\nconst DocumentStore = require('orbit-db-docstore');\n\nconst Pubsub = require('orbit-db-pubsub');\n\nconst Cache = require('orbit-db-cache');\n\nconst Keystore = require('orbit-db-keystore');\n\nconst Identities = require('orbit-db-identity-provider');\n\nlet AccessControllers = require('orbit-db-access-controllers');\n\nconst OrbitDBAddress = require('./orbit-db-address');\n\nconst createDBManifest = require('./db-manifest');\n\nconst exchangeHeads = require('./exchange-heads');\n\nconst {\n  isDefined,\n  io\n} = require('./utils');\n\nconst Storage = require('orbit-db-storage-adapter');\n\nconst migrations = require('./migrations');\n\nconst Logger = require('logplease');\n\nconst logger = Logger.create('orbit-db');\nLogger.setLogLevel('ERROR'); // Mapping for 'database type' -> Class\n\nconst databaseTypes = {\n  counter: CounterStore,\n  eventlog: EventStore,\n  feed: FeedStore,\n  docstore: DocumentStore,\n  keyvalue: KeyValueStore\n};\nconst defaultTimeout = 30000; // 30 seconds\n\nclass OrbitDB {\n  constructor(ipfs, identity) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!isDefined(ipfs)) {\n      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n    }\n\n    if (!isDefined(identity)) {\n      throw new Error('identity is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n    }\n\n    this._ipfs = ipfs;\n    this.identity = identity;\n    this.id = options.peerId;\n    this._pubsub = !options.offline ? new (options.broker ? options.broker : Pubsub)(this._ipfs, this.id) : null;\n    this.directory = options.directory || './orbitdb';\n    this.storage = options.storage;\n    this._directConnections = {};\n    this.caches = {};\n    this.caches[this.directory] = {\n      cache: options.cache,\n      handlers: new Set()\n    };\n    this.keystore = options.keystore;\n    this.stores = {}; // AccessControllers module can be passed in to enable\n    // testing with orbit-db-access-controller\n\n    AccessControllers = options.AccessControllers || AccessControllers;\n  }\n\n  static get Pubsub() {\n    return Pubsub;\n  }\n\n  static get Cache() {\n    return Cache;\n  }\n\n  static get Keystore() {\n    return Keystore;\n  }\n\n  static get Identities() {\n    return Identities;\n  }\n\n  static get AccessControllers() {\n    return AccessControllers;\n  }\n\n  static get Storage() {\n    return Storage;\n  }\n\n  static get OrbitDBAddress() {\n    return OrbitDBAddress;\n  }\n\n  static get Store() {\n    return Store;\n  }\n\n  static get EventStore() {\n    return EventStore;\n  }\n\n  static get FeedStore() {\n    return FeedStore;\n  }\n\n  static get KeyValueStore() {\n    return KeyValueStore;\n  }\n\n  static get CounterStore() {\n    return CounterStore;\n  }\n\n  static get DocumentStore() {\n    return DocumentStore;\n  }\n\n  get cache() {\n    return this.caches[this.directory].cache;\n  }\n\n  static async createInstance(ipfs) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!isDefined(ipfs)) {\n      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n    }\n\n    if (options.offline === undefined) {\n      options.offline = false;\n    }\n\n    if (options.offline && !options.id) {\n      throw new Error('Offline mode requires passing an `id` in the options');\n    }\n\n    const {\n      id\n    } = options.id || options.offline ? {\n      id: options.id\n    } : await ipfs.id();\n\n    if (!options.directory) {\n      options.directory = './orbitdb';\n    }\n\n    if (!options.storage) {\n      const storageOptions = {}; // Create default `level` store\n\n      options.storage = Storage(null, storageOptions);\n    }\n\n    if (options.identity && options.identity.provider.keystore) {\n      options.keystore = options.identity.provider.keystore;\n    }\n\n    if (!options.keystore) {\n      const keystorePath = path.join(options.directory, id, '/keystore');\n      const keyStorage = await options.storage.createStore(keystorePath);\n      options.keystore = new Keystore(keyStorage);\n    }\n\n    if (!options.identity) {\n      options.identity = await Identities.createIdentity({\n        id: id,\n        keystore: options.keystore\n      });\n    }\n\n    if (!options.cache) {\n      const cachePath = path.join(options.directory, id, '/cache');\n      const cacheStorage = await options.storage.createStore(cachePath);\n      options.cache = new Cache(cacheStorage);\n    }\n\n    const finalOptions = Object.assign({}, options, {\n      peerId: id\n    });\n    return new OrbitDB(ipfs, options.identity, finalOptions);\n  }\n  /* Databases */\n\n\n  async feed(address) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options = Object.assign({\n      create: true,\n      type: 'feed'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async log(address) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options = Object.assign({\n      create: true,\n      type: 'eventlog'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async eventlog(address) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.log(address, options);\n  }\n\n  async keyvalue(address) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options = Object.assign({\n      create: true,\n      type: 'keyvalue'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async kvstore(address) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.keyvalue(address, options);\n  }\n\n  async counter(address) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options = Object.assign({\n      create: true,\n      type: 'counter'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async docs(address) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options = Object.assign({\n      create: true,\n      type: 'docstore'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async docstore(address) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.docs(address, options);\n  }\n\n  async disconnect() {\n    // Close a direct connection and remove it from internal state\n    const removeDirectConnect = e => {\n      this._directConnections[e].close();\n\n      delete this._directConnections[e];\n    }; // Close all direct connections to peers\n\n\n    Object.keys(this._directConnections).forEach(removeDirectConnect); // Disconnect from pubsub\n\n    if (this._pubsub) {\n      await this._pubsub.disconnect();\n    } // close keystore\n\n\n    await this.keystore.close(); // Close all open databases\n\n    const databases = Object.values(this.stores);\n\n    for (const db of databases) {\n      await db.close();\n      delete this.stores[db.address.toString()];\n    }\n\n    const caches = Object.keys(this.caches);\n\n    for (const directory of caches) {\n      await this.caches[directory].cache.close();\n      delete this.caches[directory];\n    } // Remove all databases from the state\n\n\n    this.stores = {};\n  } // Alias for disconnect()\n\n\n  async stop() {\n    await this.disconnect();\n  }\n\n  async _createCache(path) {\n    const cacheStorage = await this.storage.createStore(path);\n    return new Cache(cacheStorage);\n  }\n  /* Private methods */\n\n\n  async _createStore(type, address, options) {\n    // Get the type -> class mapping\n    const Store = databaseTypes[type];\n\n    if (!Store) {\n      throw new Error(`Invalid database type '${type}'`);\n    }\n\n    let accessController;\n\n    if (options.accessControllerAddress) {\n      accessController = await AccessControllers.resolve(this, options.accessControllerAddress, options.accessController);\n    }\n\n    const opts = Object.assign({\n      replicate: true\n    }, options, {\n      accessController: accessController,\n      cache: options.cache,\n      onClose: this._onClose.bind(this),\n      onDrop: this._onDrop.bind(this),\n      onLoad: this._onLoad.bind(this)\n    });\n    const identity = options.identity || this.identity;\n    const store = new Store(this._ipfs, identity, address, opts);\n    store.events.on('write', this._onWrite.bind(this)); // ID of the store is the address as a string\n\n    const addr = address.toString();\n    this.stores[addr] = store; // Subscribe to pubsub to get updates from peers,\n    // this is what hooks us into the message propagation layer\n    // and the p2p network\n\n    if (opts.replicate && this._pubsub) {\n      await this._pubsub.subscribe(addr, this._onMessage.bind(this), this._onPeerConnected.bind(this));\n    }\n\n    return store;\n  } // Callback for local writes to the database. We the update to pubsub.\n\n\n  _onWrite(address, entry, heads) {\n    if (!heads) throw new Error(\"'heads' not defined\");\n    if (this._pubsub) this._pubsub.publish(address, heads);\n  } // Callback for receiving a message from the network\n\n\n  async _onMessage(address, heads, peer) {\n    const store = this.stores[address];\n\n    try {\n      logger.debug(`Received ${heads.length} heads for '${address}':\\n`, JSON.stringify(heads.map(e => e.hash), null, 2));\n\n      if (store && heads) {\n        if (heads.length > 0) {\n          await store.sync(heads);\n        }\n\n        store.events.emit('peer.exchanged', peer, address, heads);\n      }\n    } catch (e) {\n      logger.error(e);\n    }\n  } // Callback for when a peer connected to a database\n\n\n  async _onPeerConnected(address, peer) {\n    logger.debug(`New peer '${peer}' connected to '${address}'`);\n\n    const getStore = address => this.stores[address];\n\n    const getDirectConnection = peer => this._directConnections[peer];\n\n    const onChannelCreated = channel => {\n      this._directConnections[channel._receiverID] = channel;\n    };\n\n    const onMessage = (address, heads) => this._onMessage(address, heads, peer);\n\n    await exchangeHeads(this._ipfs, address, peer, getStore, getDirectConnection, onMessage, onChannelCreated);\n\n    if (getStore(address)) {\n      getStore(address).events.emit('peer', peer);\n    }\n  } // Callback when database was closed\n\n\n  async _onClose(db) {\n    const address = db.address.toString();\n    logger.debug(`Close ${address}`); // Unsubscribe from pubsub\n\n    if (this._pubsub) {\n      await this._pubsub.unsubscribe(address);\n    }\n\n    const dir = db && db.options.directory ? db.options.directory : this.directory;\n    const cache = this.caches[dir];\n\n    if (cache && cache.handlers.has(address)) {\n      cache.handlers.delete(address);\n      if (!cache.handlers.size) await cache.cache.close();\n    }\n\n    delete this.stores[address];\n  }\n\n  async _onDrop(db) {\n    const address = db.address.toString();\n    const dir = db && db.options.directory ? db.options.directory : this.directory;\n    await this._requestCache(address, dir, db._cache);\n  }\n\n  async _onLoad(db) {\n    const address = db.address.toString();\n    const dir = db && db.options.directory ? db.options.directory : this.directory;\n    await this._requestCache(address, dir, db._cache);\n    this.stores[address] = db;\n  }\n\n  async _determineAddress(name, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!OrbitDB.isValidType(type)) {\n      throw new Error(`Invalid database type '${type}'`);\n    }\n\n    if (OrbitDBAddress.isValid(name)) {\n      throw new Error('Given database name is an address. Please give only the name of the database!');\n    } // Create an AccessController, use IPFS AC as the default\n\n\n    options.accessController = Object.assign({}, {\n      name: name,\n      type: 'ipfs'\n    }, options.accessController);\n    const accessControllerAddress = await AccessControllers.create(this, options.accessController.type, options.accessController || {}); // Save the manifest to IPFS\n\n    const manifestHash = await createDBManifest(this._ipfs, name, type, accessControllerAddress, options); // Create the database address\n\n    return OrbitDBAddress.parse(OrbitDBAddress.join(manifestHash, name));\n  }\n  /* Create and Open databases */\n\n  /*\n    options = {\n      accessController: { write: [] } // array of keys that can write to this database\n      overwrite: false, // whether we should overwrite the existing database if it exists\n    }\n  */\n\n\n  async create(name, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    logger.debug('create()');\n    logger.debug(`Creating database '${name}' as ${type}`); // Create the database address\n\n    const dbAddress = await this._determineAddress(name, type, options);\n    options.cache = await this._requestCache(dbAddress.toString(), options.directory); // Check if we have the database locally\n\n    const haveDB = await this._haveLocalData(options.cache, dbAddress);\n\n    if (haveDB && !options.overwrite) {\n      throw new Error(`Database '${dbAddress}' already exists!`);\n    }\n\n    await this._migrate(options, dbAddress); // Save the database locally\n\n    await this._addManifestToCache(options.cache, dbAddress);\n    logger.debug(`Created database '${dbAddress}'`); // Open the database\n\n    return this.open(dbAddress, options);\n  }\n\n  async determineAddress(name, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const opts = Object.assign({}, {\n      onlyHash: true\n    }, options);\n    return this._determineAddress(name, type, opts);\n  }\n\n  async _requestCache(address, directory, existingCache) {\n    const dir = directory || this.directory;\n\n    if (!this.caches[dir]) {\n      const newCache = existingCache || (await this._createCache(dir));\n      this.caches[dir] = {\n        cache: newCache,\n        handlers: new Set()\n      };\n    }\n\n    this.caches[dir].handlers.add(address);\n    const cache = this.caches[dir].cache; // \"Wake up\" the caches if they need it\n\n    if (cache) await cache.open();\n    return cache;\n  }\n  /*\n      options = {\n        localOnly: false // if set to true, throws an error if database can't be found locally\n        create: false // whether to create the database\n        type: TODO\n        overwrite: TODO\n       }\n   */\n\n\n  async open(address) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    logger.debug('open()');\n    options = Object.assign({\n      localOnly: false,\n      create: false\n    }, options);\n    logger.debug(`Open database '${address}'`); // If address is just the name of database, check the options to crate the database\n\n    if (!OrbitDBAddress.isValid(address)) {\n      if (!options.create) {\n        throw new Error('\\'options.create\\' set to \\'false\\'. If you want to create a database, set \\'options.create\\' to \\'true\\'.');\n      } else if (options.create && !options.type) {\n        throw new Error(`Database type not provided! Provide a type with 'options.type' (${OrbitDB.databaseTypes.join('|')})`);\n      } else {\n        logger.warn(`Not a valid OrbitDB address '${address}', creating the database`);\n        options.overwrite = options.overwrite ? options.overwrite : true;\n        return this.create(address, options.type, options);\n      }\n    } // Parse the database address\n\n\n    const dbAddress = OrbitDBAddress.parse(address); // If database is already open, return early by returning the instance\n    // if (this.stores[dbAddress]) {\n    //   return this.stores[dbAddress]\n    // }\n\n    options.cache = await this._requestCache(dbAddress.toString(), options.directory); // Check if we have the database\n\n    const haveDB = await this._haveLocalData(options.cache, dbAddress);\n    logger.debug((haveDB ? 'Found' : 'Didn\\'t find') + ` database '${dbAddress}'`); // If we want to try and open the database local-only, throw an error\n    // if we don't have the database locally\n\n    if (options.localOnly && !haveDB) {\n      logger.warn(`Database '${dbAddress}' doesn't exist!`);\n      throw new Error(`Database '${dbAddress}' doesn't exist!`);\n    }\n\n    logger.debug(`Loading Manifest for '${dbAddress}'`);\n    let manifest;\n\n    try {\n      // Get the database manifest from IPFS\n      manifest = await io.read(this._ipfs, dbAddress.root, {\n        timeout: options.timeout || defaultTimeout\n      });\n      logger.debug(`Manifest for '${dbAddress}':\\n${JSON.stringify(manifest, null, 2)}`);\n    } catch (e) {\n      if (e.name === 'TimeoutError' && e.code === 'ERR_TIMEOUT') {\n        console.error(e);\n        throw new Error('ipfs unable to find and fetch manifest for this address.');\n      } else {\n        throw e;\n      }\n    }\n\n    if (manifest.name !== dbAddress.path) {\n      logger.warn(`Manifest name '${manifest.name}' and path name '${dbAddress.path}' do not match`);\n    } // Make sure the type from the manifest matches the type that was given as an option\n\n\n    if (options.type && manifest.type !== options.type) {\n      throw new Error(`Database '${dbAddress}' is type '${manifest.type}' but was opened as '${options.type}'`);\n    } // Save the database locally\n\n\n    await this._addManifestToCache(options.cache, dbAddress); // Open the the database\n\n    options = Object.assign({}, options, {\n      accessControllerAddress: manifest.accessController,\n      meta: manifest.meta\n    });\n    return this._createStore(options.type || manifest.type, dbAddress, options);\n  } // Save the database locally\n\n\n  async _addManifestToCache(cache, dbAddress) {\n    await cache.set(path.join(dbAddress.toString(), '_manifest'), dbAddress.root);\n    logger.debug(`Saved manifest to IPFS as '${dbAddress.root}'`);\n  }\n  /**\n   * Check if we have the database, or part of it, saved locally\n   * @param  {[Cache]} cache [The OrbitDBCache instance containing the local data]\n   * @param  {[OrbitDBAddress]} dbAddress [Address of the database to check]\n   * @return {[Boolean]} [Returns true if we have cached the db locally, false if not]\n   */\n\n\n  async _haveLocalData(cache, dbAddress) {\n    if (!cache) {\n      return false;\n    }\n\n    const addr = dbAddress.toString();\n    const data = await cache.get(path.join(addr, '_manifest'));\n    return data !== undefined && data !== null;\n  }\n  /**\n   * Runs all migrations inside the src/migration folder\n   * @param Object options  Options to pass into the migration\n   * @param OrbitDBAddress dbAddress Address of database in OrbitDBAddress format\n   */\n\n\n  async _migrate(options, dbAddress) {\n    await migrations.run(this, options, dbAddress);\n  }\n  /**\n   * Returns supported database types as an Array of strings\n   * Eg. [ 'counter', 'eventlog', 'feed', 'docstore', 'keyvalue']\n   * @return {[Array]} [Supported database types]\n   */\n\n\n  static get databaseTypes() {\n    return Object.keys(databaseTypes);\n  }\n\n  static isValidType(type) {\n    return Object.keys(databaseTypes).includes(type);\n  }\n\n  static addDatabaseType(type, store) {\n    if (databaseTypes[type]) throw new Error(`Type already exists: ${type}`);\n    databaseTypes[type] = store;\n  }\n\n  static getDatabaseTypes() {\n    return databaseTypes;\n  }\n\n  static isValidAddress(address) {\n    return OrbitDBAddress.isValid(address);\n  }\n\n  static parseAddress(address) {\n    return OrbitDBAddress.parse(address);\n  }\n\n}\n\nOrbitDB.prototype.AccessControllers = AccessControllers;\nOrbitDB.prototype.Identities = Identities;\nOrbitDB.prototype.Keystore = Keystore;\nmodule.exports = OrbitDB;","map":{"version":3,"names":["path","require","Store","EventStore","FeedStore","KeyValueStore","CounterStore","DocumentStore","Pubsub","Cache","Keystore","Identities","AccessControllers","OrbitDBAddress","createDBManifest","exchangeHeads","isDefined","io","Storage","migrations","Logger","logger","create","setLogLevel","databaseTypes","counter","eventlog","feed","docstore","keyvalue","defaultTimeout","OrbitDB","constructor","ipfs","identity","options","Error","_ipfs","id","peerId","_pubsub","offline","broker","directory","storage","_directConnections","caches","cache","handlers","Set","keystore","stores","createInstance","undefined","storageOptions","provider","keystorePath","join","keyStorage","createStore","createIdentity","cachePath","cacheStorage","finalOptions","Object","assign","address","type","open","log","kvstore","docs","disconnect","removeDirectConnect","e","close","keys","forEach","databases","values","db","toString","stop","_createCache","_createStore","accessController","accessControllerAddress","resolve","opts","replicate","onClose","_onClose","bind","onDrop","_onDrop","onLoad","_onLoad","store","events","on","_onWrite","addr","subscribe","_onMessage","_onPeerConnected","entry","heads","publish","peer","debug","length","JSON","stringify","map","hash","sync","emit","error","getStore","getDirectConnection","onChannelCreated","channel","_receiverID","onMessage","unsubscribe","dir","has","delete","size","_requestCache","_cache","_determineAddress","name","isValidType","isValid","manifestHash","parse","dbAddress","haveDB","_haveLocalData","overwrite","_migrate","_addManifestToCache","determineAddress","onlyHash","existingCache","newCache","add","localOnly","warn","manifest","read","root","timeout","code","console","meta","set","data","get","run","includes","addDatabaseType","getDatabaseTypes","isValidAddress","parseAddress","prototype","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db/src/OrbitDB.js"],"sourcesContent":["'use strict'\n\nconst path = require('path')\nconst Store = require('orbit-db-store')\nconst EventStore = require('orbit-db-eventstore')\nconst FeedStore = require('orbit-db-feedstore')\nconst KeyValueStore = require('orbit-db-kvstore')\nconst CounterStore = require('orbit-db-counterstore')\nconst DocumentStore = require('orbit-db-docstore')\nconst Pubsub = require('orbit-db-pubsub')\nconst Cache = require('orbit-db-cache')\nconst Keystore = require('orbit-db-keystore')\nconst Identities = require('orbit-db-identity-provider')\nlet AccessControllers = require('orbit-db-access-controllers')\nconst OrbitDBAddress = require('./orbit-db-address')\nconst createDBManifest = require('./db-manifest')\nconst exchangeHeads = require('./exchange-heads')\nconst { isDefined, io } = require('./utils')\nconst Storage = require('orbit-db-storage-adapter')\nconst migrations = require('./migrations')\n\nconst Logger = require('logplease')\nconst logger = Logger.create('orbit-db')\nLogger.setLogLevel('ERROR')\n\n// Mapping for 'database type' -> Class\nconst databaseTypes = {\n  counter: CounterStore,\n  eventlog: EventStore,\n  feed: FeedStore,\n  docstore: DocumentStore,\n  keyvalue: KeyValueStore\n}\n\nconst defaultTimeout = 30000 // 30 seconds\n\nclass OrbitDB {\n  constructor (ipfs, identity, options = {}) {\n    if (!isDefined(ipfs)) { throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance') }\n\n    if (!isDefined(identity)) { throw new Error('identity is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance') }\n\n    this._ipfs = ipfs\n    this.identity = identity\n    this.id = options.peerId\n    this._pubsub = !options.offline\n      ? new (\n          options.broker ? options.broker : Pubsub\n        )(this._ipfs, this.id)\n      : null\n    this.directory = options.directory || './orbitdb'\n    this.storage = options.storage\n    this._directConnections = {}\n\n    this.caches = {}\n    this.caches[this.directory] = { cache: options.cache, handlers: new Set() }\n    this.keystore = options.keystore\n    this.stores = {}\n\n    // AccessControllers module can be passed in to enable\n    // testing with orbit-db-access-controller\n    AccessControllers = options.AccessControllers || AccessControllers\n  }\n\n  static get Pubsub () { return Pubsub }\n  static get Cache () { return Cache }\n  static get Keystore () { return Keystore }\n  static get Identities () { return Identities }\n  static get AccessControllers () { return AccessControllers }\n  static get Storage () { return Storage }\n  static get OrbitDBAddress () { return OrbitDBAddress }\n\n  static get Store () { return Store }\n  static get EventStore () { return EventStore }\n  static get FeedStore () { return FeedStore }\n  static get KeyValueStore () { return KeyValueStore }\n  static get CounterStore () { return CounterStore }\n  static get DocumentStore () { return DocumentStore }\n\n  get cache () { return this.caches[this.directory].cache }\n\n  static async createInstance (ipfs, options = {}) {\n    if (!isDefined(ipfs)) { throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance') }\n\n    if (options.offline === undefined) {\n      options.offline = false\n    }\n\n    if (options.offline && !options.id) {\n      throw new Error('Offline mode requires passing an `id` in the options')\n    }\n\n    const { id } = options.id || options.offline ? ({ id: options.id }) : await ipfs.id()\n\n    if (!options.directory) { options.directory = './orbitdb' }\n\n    if (!options.storage) {\n      const storageOptions = {}\n\n      // Create default `level` store\n      options.storage = Storage(null, storageOptions)\n    }\n\n    if (options.identity && options.identity.provider.keystore) {\n      options.keystore = options.identity.provider.keystore\n    }\n\n    if (!options.keystore) {\n      const keystorePath = path.join(options.directory, id, '/keystore')\n      const keyStorage = await options.storage.createStore(keystorePath)\n      options.keystore = new Keystore(keyStorage)\n    }\n\n    if (!options.identity) {\n      options.identity = await Identities.createIdentity({\n        id: id,\n        keystore: options.keystore\n      })\n    }\n\n    if (!options.cache) {\n      const cachePath = path.join(options.directory, id, '/cache')\n      const cacheStorage = await options.storage.createStore(cachePath)\n      options.cache = new Cache(cacheStorage)\n    }\n\n    const finalOptions = Object.assign({}, options, { peerId: id })\n    return new OrbitDB(ipfs, options.identity, finalOptions)\n  }\n\n  /* Databases */\n  async feed (address, options = {}) {\n    options = Object.assign({ create: true, type: 'feed' }, options)\n    return this.open(address, options)\n  }\n\n  async log (address, options = {}) {\n    options = Object.assign({ create: true, type: 'eventlog' }, options)\n    return this.open(address, options)\n  }\n\n  async eventlog (address, options = {}) {\n    return this.log(address, options)\n  }\n\n  async keyvalue (address, options = {}) {\n    options = Object.assign({ create: true, type: 'keyvalue' }, options)\n    return this.open(address, options)\n  }\n\n  async kvstore (address, options = {}) {\n    return this.keyvalue(address, options)\n  }\n\n  async counter (address, options = {}) {\n    options = Object.assign({ create: true, type: 'counter' }, options)\n    return this.open(address, options)\n  }\n\n  async docs (address, options = {}) {\n    options = Object.assign({ create: true, type: 'docstore' }, options)\n    return this.open(address, options)\n  }\n\n  async docstore (address, options = {}) {\n    return this.docs(address, options)\n  }\n\n  async disconnect () {\n    // Close a direct connection and remove it from internal state\n    const removeDirectConnect = e => {\n      this._directConnections[e].close()\n      delete this._directConnections[e]\n    }\n\n    // Close all direct connections to peers\n    Object.keys(this._directConnections).forEach(removeDirectConnect)\n\n    // Disconnect from pubsub\n    if (this._pubsub) {\n      await this._pubsub.disconnect()\n    }\n\n    // close keystore\n    await this.keystore.close()\n\n    // Close all open databases\n    const databases = Object.values(this.stores)\n    for (const db of databases) {\n      await db.close()\n      delete this.stores[db.address.toString()]\n    }\n\n    const caches = Object.keys(this.caches)\n    for (const directory of caches) {\n      await this.caches[directory].cache.close()\n      delete this.caches[directory]\n    }\n\n    // Remove all databases from the state\n    this.stores = {}\n  }\n\n  // Alias for disconnect()\n  async stop () {\n    await this.disconnect()\n  }\n\n  async _createCache (path) {\n    const cacheStorage = await this.storage.createStore(path)\n    return new Cache(cacheStorage)\n  }\n\n  /* Private methods */\n  async _createStore (type, address, options) {\n    // Get the type -> class mapping\n    const Store = databaseTypes[type]\n\n    if (!Store) { throw new Error(`Invalid database type '${type}'`) }\n\n    let accessController\n    if (options.accessControllerAddress) {\n      accessController = await AccessControllers.resolve(this, options.accessControllerAddress, options.accessController)\n    }\n\n    const opts = Object.assign({ replicate: true }, options, {\n      accessController: accessController,\n      cache: options.cache,\n      onClose: this._onClose.bind(this),\n      onDrop: this._onDrop.bind(this),\n      onLoad: this._onLoad.bind(this)\n    })\n    const identity = options.identity || this.identity\n\n    const store = new Store(this._ipfs, identity, address, opts)\n    store.events.on('write', this._onWrite.bind(this))\n\n    // ID of the store is the address as a string\n    const addr = address.toString()\n    this.stores[addr] = store\n\n    // Subscribe to pubsub to get updates from peers,\n    // this is what hooks us into the message propagation layer\n    // and the p2p network\n    if (opts.replicate && this._pubsub) { await this._pubsub.subscribe(addr, this._onMessage.bind(this), this._onPeerConnected.bind(this)) }\n\n    return store\n  }\n\n  // Callback for local writes to the database. We the update to pubsub.\n  _onWrite (address, entry, heads) {\n    if (!heads) throw new Error(\"'heads' not defined\")\n    if (this._pubsub) this._pubsub.publish(address, heads)\n  }\n\n  // Callback for receiving a message from the network\n  async _onMessage (address, heads, peer) {\n    const store = this.stores[address]\n    try {\n      logger.debug(`Received ${heads.length} heads for '${address}':\\n`, JSON.stringify(heads.map(e => e.hash), null, 2))\n      if (store && heads) {\n        if (heads.length > 0) {\n          await store.sync(heads)\n        }\n        store.events.emit('peer.exchanged', peer, address, heads)\n      }\n    } catch (e) {\n      logger.error(e)\n    }\n  }\n\n  // Callback for when a peer connected to a database\n  async _onPeerConnected (address, peer) {\n    logger.debug(`New peer '${peer}' connected to '${address}'`)\n\n    const getStore = address => this.stores[address]\n    const getDirectConnection = peer => this._directConnections[peer]\n    const onChannelCreated = channel => { this._directConnections[channel._receiverID] = channel }\n\n    const onMessage = (address, heads) => this._onMessage(address, heads, peer)\n\n    await exchangeHeads(\n      this._ipfs,\n      address,\n      peer,\n      getStore,\n      getDirectConnection,\n      onMessage,\n      onChannelCreated\n    )\n\n    if (getStore(address)) { getStore(address).events.emit('peer', peer) }\n  }\n\n  // Callback when database was closed\n  async _onClose (db) {\n    const address = db.address.toString()\n    logger.debug(`Close ${address}`)\n\n    // Unsubscribe from pubsub\n    if (this._pubsub) {\n      await this._pubsub.unsubscribe(address)\n    }\n\n    const dir = db && db.options.directory ? db.options.directory : this.directory\n    const cache = this.caches[dir]\n\n    if (cache && cache.handlers.has(address)) {\n      cache.handlers.delete(address)\n      if (!cache.handlers.size) await cache.cache.close()\n    }\n\n    delete this.stores[address]\n  }\n\n  async _onDrop (db) {\n    const address = db.address.toString()\n    const dir = db && db.options.directory ? db.options.directory : this.directory\n    await this._requestCache(address, dir, db._cache)\n  }\n\n  async _onLoad (db) {\n    const address = db.address.toString()\n    const dir = db && db.options.directory ? db.options.directory : this.directory\n    await this._requestCache(address, dir, db._cache)\n    this.stores[address] = db\n  }\n\n  async _determineAddress (name, type, options = {}) {\n    if (!OrbitDB.isValidType(type)) { throw new Error(`Invalid database type '${type}'`) }\n\n    if (OrbitDBAddress.isValid(name)) { throw new Error('Given database name is an address. Please give only the name of the database!') }\n\n    // Create an AccessController, use IPFS AC as the default\n    options.accessController = Object.assign({}, { name: name, type: 'ipfs' }, options.accessController)\n    const accessControllerAddress = await AccessControllers.create(this, options.accessController.type, options.accessController || {})\n\n    // Save the manifest to IPFS\n    const manifestHash = await createDBManifest(this._ipfs, name, type, accessControllerAddress, options)\n\n    // Create the database address\n    return OrbitDBAddress.parse(OrbitDBAddress.join(manifestHash, name))\n  }\n\n  /* Create and Open databases */\n\n  /*\n    options = {\n      accessController: { write: [] } // array of keys that can write to this database\n      overwrite: false, // whether we should overwrite the existing database if it exists\n    }\n  */\n  async create (name, type, options = {}) {\n    logger.debug('create()')\n\n    logger.debug(`Creating database '${name}' as ${type}`)\n\n    // Create the database address\n    const dbAddress = await this._determineAddress(name, type, options)\n\n    options.cache = await this._requestCache(dbAddress.toString(), options.directory)\n\n    // Check if we have the database locally\n    const haveDB = await this._haveLocalData(options.cache, dbAddress)\n\n    if (haveDB && !options.overwrite) { throw new Error(`Database '${dbAddress}' already exists!`) }\n\n    await this._migrate(options, dbAddress)\n\n    // Save the database locally\n    await this._addManifestToCache(options.cache, dbAddress)\n\n    logger.debug(`Created database '${dbAddress}'`)\n\n    // Open the database\n    return this.open(dbAddress, options)\n  }\n\n  async determineAddress (name, type, options = {}) {\n    const opts = Object.assign({}, { onlyHash: true }, options)\n    return this._determineAddress(name, type, opts)\n  }\n\n  async _requestCache (address, directory, existingCache) {\n    const dir = directory || this.directory\n    if (!this.caches[dir]) {\n      const newCache = existingCache || await this._createCache(dir)\n      this.caches[dir] = { cache: newCache, handlers: new Set() }\n    }\n    this.caches[dir].handlers.add(address)\n    const cache = this.caches[dir].cache\n\n    // \"Wake up\" the caches if they need it\n    if (cache) await cache.open()\n\n    return cache\n  }\n\n  /*\n      options = {\n        localOnly: false // if set to true, throws an error if database can't be found locally\n        create: false // whether to create the database\n        type: TODO\n        overwrite: TODO\n\n      }\n   */\n  async open (address, options = {}) {\n    logger.debug('open()')\n\n    options = Object.assign({ localOnly: false, create: false }, options)\n    logger.debug(`Open database '${address}'`)\n\n    // If address is just the name of database, check the options to crate the database\n    if (!OrbitDBAddress.isValid(address)) {\n      if (!options.create) {\n        throw new Error('\\'options.create\\' set to \\'false\\'. If you want to create a database, set \\'options.create\\' to \\'true\\'.')\n      } else if (options.create && !options.type) {\n        throw new Error(`Database type not provided! Provide a type with 'options.type' (${OrbitDB.databaseTypes.join('|')})`)\n      } else {\n        logger.warn(`Not a valid OrbitDB address '${address}', creating the database`)\n        options.overwrite = options.overwrite ? options.overwrite : true\n        return this.create(address, options.type, options)\n      }\n    }\n\n    // Parse the database address\n    const dbAddress = OrbitDBAddress.parse(address)\n\n    // If database is already open, return early by returning the instance\n    // if (this.stores[dbAddress]) {\n    //   return this.stores[dbAddress]\n    // }\n\n    options.cache = await this._requestCache(dbAddress.toString(), options.directory)\n\n    // Check if we have the database\n    const haveDB = await this._haveLocalData(options.cache, dbAddress)\n\n    logger.debug((haveDB ? 'Found' : 'Didn\\'t find') + ` database '${dbAddress}'`)\n\n    // If we want to try and open the database local-only, throw an error\n    // if we don't have the database locally\n    if (options.localOnly && !haveDB) {\n      logger.warn(`Database '${dbAddress}' doesn't exist!`)\n      throw new Error(`Database '${dbAddress}' doesn't exist!`)\n    }\n\n    logger.debug(`Loading Manifest for '${dbAddress}'`)\n\n    let manifest\n    try {\n      // Get the database manifest from IPFS\n      manifest = await io.read(this._ipfs, dbAddress.root, { timeout: options.timeout || defaultTimeout })\n      logger.debug(`Manifest for '${dbAddress}':\\n${JSON.stringify(manifest, null, 2)}`)\n    } catch (e) {\n      if (e.name === 'TimeoutError' && e.code === 'ERR_TIMEOUT') {\n        console.error(e)\n        throw new Error('ipfs unable to find and fetch manifest for this address.')\n      } else {\n        throw e\n      }\n    }\n\n    if (manifest.name !== dbAddress.path) {\n      logger.warn(`Manifest name '${manifest.name}' and path name '${dbAddress.path}' do not match`)\n    }\n\n    // Make sure the type from the manifest matches the type that was given as an option\n    if (options.type && manifest.type !== options.type) {\n      throw new Error(`Database '${dbAddress}' is type '${manifest.type}' but was opened as '${options.type}'`)\n    }\n\n    // Save the database locally\n    await this._addManifestToCache(options.cache, dbAddress)\n\n    // Open the the database\n    options = Object.assign({}, options, { accessControllerAddress: manifest.accessController, meta: manifest.meta })\n    return this._createStore(options.type || manifest.type, dbAddress, options)\n  }\n\n  // Save the database locally\n  async _addManifestToCache (cache, dbAddress) {\n    await cache.set(path.join(dbAddress.toString(), '_manifest'), dbAddress.root)\n    logger.debug(`Saved manifest to IPFS as '${dbAddress.root}'`)\n  }\n\n  /**\n   * Check if we have the database, or part of it, saved locally\n   * @param  {[Cache]} cache [The OrbitDBCache instance containing the local data]\n   * @param  {[OrbitDBAddress]} dbAddress [Address of the database to check]\n   * @return {[Boolean]} [Returns true if we have cached the db locally, false if not]\n   */\n  async _haveLocalData (cache, dbAddress) {\n    if (!cache) {\n      return false\n    }\n\n    const addr = dbAddress.toString()\n    const data = await cache.get(path.join(addr, '_manifest'))\n    return data !== undefined && data !== null\n  }\n\n  /**\n   * Runs all migrations inside the src/migration folder\n   * @param Object options  Options to pass into the migration\n   * @param OrbitDBAddress dbAddress Address of database in OrbitDBAddress format\n   */\n  async _migrate (options, dbAddress) {\n    await migrations.run(this, options, dbAddress)\n  }\n\n  /**\n   * Returns supported database types as an Array of strings\n   * Eg. [ 'counter', 'eventlog', 'feed', 'docstore', 'keyvalue']\n   * @return {[Array]} [Supported database types]\n   */\n  static get databaseTypes () {\n    return Object.keys(databaseTypes)\n  }\n\n  static isValidType (type) {\n    return Object.keys(databaseTypes).includes(type)\n  }\n\n  static addDatabaseType (type, store) {\n    if (databaseTypes[type]) throw new Error(`Type already exists: ${type}`)\n    databaseTypes[type] = store\n  }\n\n  static getDatabaseTypes () {\n    return databaseTypes\n  }\n\n  static isValidAddress (address) {\n    return OrbitDBAddress.isValid(address)\n  }\n\n  static parseAddress (address) {\n    return OrbitDBAddress.parse(address)\n  }\n}\n\nOrbitDB.prototype.AccessControllers = AccessControllers\nOrbitDB.prototype.Identities = Identities\nOrbitDB.prototype.Keystore = Keystore\n\nmodule.exports = OrbitDB\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}