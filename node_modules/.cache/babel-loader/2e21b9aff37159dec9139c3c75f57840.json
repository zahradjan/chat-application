{"ast":null,"code":"import OrbitDB from \"orbit-db\";\nimport IPFS from \"ipfs\";\nimport { makeAutoObservable } from \"mobx\";\nimport { multiaddr } from \"multiaddr\";\nexport default class DataStore {\n  constructor(rootStore) {\n    this.rootStore = rootStore;\n    makeAutoObservable(this);\n  }\n\n  async init() {\n    if (this.ipfsNode !== undefined) return;\n    if (this.orbitDb !== undefined) return;\n    const dbConfig = {\n      // If database doesn't exist, create it\n      create: true,\n      // Don't wait to load from the network\n      sync: true,\n      // directory: `/orbitdb/decentio-orbitdb-chat-${Math.random()}}`,\n      // Load only the local version of the database\n      localOnly: false,\n      // Allow anyone to write to the database,\n      // otherwise only the creator of the database can write\n      accessController: {\n        write: [\"*\"]\n      }\n    };\n    const ipfsConfig = {\n      // preload: { enabled: false },\n      relay: {\n        enabled: true,\n        hop: {\n          enabled: true,\n          active: true\n        }\n      },\n      // libp2p: {\n      //   config: {\n      //     dht: {\n      //       enabled: true,\n      //     },\n      //     modules: {\n      //       transport: [\"WebRTCStar\", \"WebSockets\"],\n      //     },\n      //     // transport: {\n      //     //   WebRTCStar: {\n      //     //     wrtc,\n      //     //   },\n      //     // },\n      //   },\n      // },\n      // peerDiscovery: {\n      //   autoDial: true, // Auto connect to discovered peers (limited by ConnectionManager minPeers)\n      //   mdns: {\n      //     // mdns options\n      //     interval: 1000, // ms\n      //     enabled: true,\n      //   },\n      //   webRTCStar: {\n      //     // webrtc-star options\n      //     interval: 1000, // ms\n      //     enabled: false,\n      //   },\n      //   // .. other discovery module options.\n      // },\n      // Prevents large data transfers\n      //TODO: nejak oddelit at to neni random ale treba username nebo neco\n      repo: `/orbitdb/decentio-orbitdb-chat-ipfs-${this.rootStore.sessionStore._user}}`,\n      EXPERIMENTAL: {\n        pubsub: true\n      },\n      config: {\n        Addresses: {\n          Swarm: [//       // Use IPFS dev signal server\n          //       // Websocket:\n          // \"/dns4/ws-star-signal-1.servep2p.com/tcp/443/wss/p2p-websocket-star\",\n          // \"/dns4/ws-star-signal-2.servep2p.com/tcp/443/wss/p2p-websocket-star\",\n          // \"/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star\",\n          // WebRTC:\n          \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\", \"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\", \"/dns4/webrtc-star.discovery.libp2p.io/tcp/443/wss/p2p-webrtc-star/\", \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star\", \"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star\", // \"/ip4/0.0.0.0/tcp/4002\",\n          // \"/ip4/127.0.0.1/tcp/4003/ws\",\n          // \"/libp2p-webrtc-star/dns4/star-signal.cloud.ipfs.team/wss\",\n          // \"/dns4/star-signal.cloud.ipfs.team/wss/p2p-webrtc-star\",\n          //       // Use local signal server\n          \"/ip4/0.0.0.0/tcp/4011/ws\", \"/ip6/::/tcp/4011/ws\"]\n        },\n        Bootstrap: []\n      }\n    };\n    await this.start(ipfsConfig, dbConfig);\n  }\n\n  async start(ipfsConf, orbitDbconf) {\n    await this.startIpfsNode(ipfsConf);\n    await this.startOrbitDb(orbitDbconf); // this.ipfsNode.config.set(\"Addresses.Swarm\", [\"/ip4/0.0.0.0/tcp/4002\", \"/ip4/127.0.0.1/tcp/4003/ws\"], console.log);\n\n    const peerInfo = await this.ipfsNode.id();\n    console.log(\"Peer ID: \" + peerInfo.id); // this.ipfsNode.libp2p.on(\"peer:connect\", this.handlePeerConnected.bind(this));\n\n    this.ipfsNode.libp2p.on(\"peer:connect\", peer => console.log(\"Connected peer: \" + peer)); // this.ipfsNode.libp2p.on(\"peer:discovery\", (peer) => console.log(\"Peer: \" + peer));\n    // this.ipfsNode.libp2p.pubsub.subscribe(peerInfo.id, (msg) => console.log(msg));\n    // this.ipfsNode.libp2p.pubsub.publish(peerInfo.id, \"Hello\");\n\n    this.ipfsNode.libp2p.pubsub.subscribe(\"test\", msg => console.log(msg));\n    this.ipfsNode.libp2p.pubsub.publish(\"test\", \"Hello\"); // this.sendMessage(\"12D3KooWH1XyPHHfv2ipZEEkevBGrqNs7PXUCVALyh2vjLn9BtaJ\", \"Test\");\n\n    console.log(await this.ipfsNode.bootstrap.swarm.peers()); // if (peerInfo.id !== \"12D3KooWH1XyPHHfv2ipZEEkevBGrqNs7PXUCVALyh2vjLn9BtaJ\") {\n    //   const addr = \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/12D3KooWH1XyPHHfv2ipZEEkevBGrqNs7PXUCVALyh2vjLn9BtaJ\";\n    //   try {\n    //     await this.ipfsNode.swarm.connect(addr);\n    //   } catch (err) {\n    //     console.log(err);\n    //     await this.ipfsNode.swarm.connect(addr);\n    //   }\n    // }\n    // this.handlePeerConnected(peerInfo);\n\n    console.log(\"Peer Addresses: \" + peerInfo.addresses);\n    console.log(await this.getIpfsPeers());\n    const topics = await this.ipfsNode.pubsub.ls();\n    console.log(topics);\n    const defaultOptions = {\n      accessController: {\n        write: [this.orbitDb.identity.id]\n      }\n    };\n    const docStoreOptions = { ...defaultOptions,\n      indexBy: \"hash\"\n    };\n    this.messages = await this.orbitDb.docstore(\"messages\", docStoreOptions);\n    await this.messages.load();\n    console.log(this.messages.db);\n    this.peersDb = await this.orbitDb.keyvalue(\"peers\", defaultOptions);\n    await this.peersDb.load();\n  }\n\n  async handleMessageReceived(msg) {\n    const parsedMsg = JSON.parse(msg.data.toString());\n    const msgKeys = Object.keys(parsedMsg);\n    console.log(\"ParsedDb: \" + parsedMsg);\n    console.log(msgKeys[0]);\n\n    switch (msgKeys[0]) {\n      case \"userDb\":\n        var peerDb = await this.orbitDb.open(parsedMsg.userDb, {\n          create: true,\n          type: \"keyvalue\"\n        });\n        peerDb.events.on(\"replicated\", async () => {\n          if (peerDb.get(\"pieces\")) {\n            await this.peersDb.set(peerDb.id, peerDb.all);\n            console.log(peerDb.all);\n          }\n        });\n        break;\n\n      default:\n        break;\n    }\n\n    console.log(msg.data.toString()); // if (this.onmessage) this.onmessage(msg);\n  }\n\n  async connectToPeer(multiaddr) {\n    let protocol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"/p2p-circuit/ipfs/\";\n\n    try {\n      await this.ipfsNode.swarm.connect(multiaddr);\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  getPeers() {\n    return this.peersDb.all;\n  }\n\n  async connectToPeers() {\n    const peerIds = Object.values(this.peersDb.all).map(peer => peer.nodeId);\n    console.log(peerIds);\n    const connectedPeerIds = await this.getIpfsPeers();\n    await Promise.all(peerIds.map(async peerId => {\n      if (connectedPeerIds.indexOf(peerId) !== -1) return;\n\n      try {\n        console.log(peerId);\n        await this.connectToPeer(peerId);\n      } catch (e) {}\n    }));\n  }\n\n  handlePeerConnected(ipfsPeer) {\n    console.log(\"IPFS Peer: \" + ipfsPeer);\n    const ipfsId = ipfsPeer.id.toB58String();\n    setTimeout(async () => {\n      await this.sendMessage(ipfsId, {\n        userDb: \"test\"\n      });\n    }, 2000);\n  } // async queryCatalog(queryFn) {\n  //   const dbAddrs = Object.values(this.companions.all).map((peer) => peer.pieces);\n  //   const allPieces = await Promise.all(\n  //     dbAddrs.map(async (addr) => {\n  //       const db = await this.orbitDb.open(addr);\n  //       await db.load();\n  //       return db.query(queryFn);\n  //     })\n  //   );\n  //   return allPieces.reduce((flatPieces, pieces) => flatPieces.concat(pieces), this.messages.query(queryFn));\n  // }\n\n\n  async sendMessage(topic, message) {\n    try {\n      const msgString = JSON.stringify(message);\n      const messageBuffer = Buffer.from(msgString);\n      await this.ipfsNode.pubsub.publish(topic, messageBuffer);\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  async startIpfsNode(ipfsConf) {\n    this.ipfsNode = await IPFS.create(ipfsConf);\n  }\n\n  async startOrbitDb(orbitDbconf) {\n    this.orbitDb = await OrbitDB.createInstance(this.ipfsNode, orbitDbconf);\n  }\n\n  async getIpfsPeers() {\n    const peers = await this.ipfsNode.swarm.peers(); // console.log(peers);\n\n    return peers;\n  }\n\n  async createDBStore(address) {\n    const store = await this.orbitDb.docstore(address);\n    await store.load();\n    return store;\n  }\n\n  async handleStop() {\n    await this.orbitDb.disconnect();\n    await this.ipfsNode.stop();\n    delete this.orbitDb;\n    delete this.ipfsNode;\n  }\n\n}","map":{"version":3,"names":["OrbitDB","IPFS","makeAutoObservable","multiaddr","DataStore","constructor","rootStore","init","ipfsNode","undefined","orbitDb","dbConfig","create","sync","localOnly","accessController","write","ipfsConfig","relay","enabled","hop","active","repo","sessionStore","_user","EXPERIMENTAL","pubsub","config","Addresses","Swarm","Bootstrap","start","ipfsConf","orbitDbconf","startIpfsNode","startOrbitDb","peerInfo","id","console","log","libp2p","on","peer","subscribe","msg","publish","bootstrap","swarm","peers","addresses","getIpfsPeers","topics","ls","defaultOptions","identity","docStoreOptions","indexBy","messages","docstore","load","db","peersDb","keyvalue","handleMessageReceived","parsedMsg","JSON","parse","data","toString","msgKeys","Object","keys","peerDb","open","userDb","type","events","get","set","all","connectToPeer","protocol","connect","e","getPeers","connectToPeers","peerIds","values","map","nodeId","connectedPeerIds","Promise","peerId","indexOf","handlePeerConnected","ipfsPeer","ipfsId","toB58String","setTimeout","sendMessage","topic","message","msgString","stringify","messageBuffer","Buffer","from","createInstance","createDBStore","address","store","handleStop","disconnect","stop"],"sources":["C:/Users/zajan/GitHub/chatApplication/src/data/store/DataStore.js"],"sourcesContent":["import OrbitDB from \"orbit-db\";\r\nimport IPFS from \"ipfs\";\r\nimport { makeAutoObservable } from \"mobx\";\r\nimport { multiaddr } from \"multiaddr\";\r\n\r\nexport default class DataStore {\r\n  ipfsNode;\r\n  orbitDb;\r\n  constructor(rootStore) {\r\n    this.rootStore = rootStore;\r\n    makeAutoObservable(this);\r\n  }\r\n\r\n  async init() {\r\n    if (this.ipfsNode !== undefined) return;\r\n    if (this.orbitDb !== undefined) return;\r\n\r\n    const dbConfig = {\r\n      // If database doesn't exist, create it\r\n      create: true,\r\n      // Don't wait to load from the network\r\n      sync: true,\r\n      // directory: `/orbitdb/decentio-orbitdb-chat-${Math.random()}}`,\r\n      // Load only the local version of the database\r\n      localOnly: false,\r\n      // Allow anyone to write to the database,\r\n      // otherwise only the creator of the database can write\r\n      accessController: {\r\n        write: [\"*\"],\r\n      },\r\n    };\r\n    const ipfsConfig = {\r\n      // preload: { enabled: false },\r\n      relay: { enabled: true, hop: { enabled: true, active: true } },\r\n      // libp2p: {\r\n      //   config: {\r\n      //     dht: {\r\n      //       enabled: true,\r\n      //     },\r\n      //     modules: {\r\n      //       transport: [\"WebRTCStar\", \"WebSockets\"],\r\n      //     },\r\n      //     // transport: {\r\n      //     //   WebRTCStar: {\r\n      //     //     wrtc,\r\n      //     //   },\r\n      //     // },\r\n      //   },\r\n      // },\r\n      // peerDiscovery: {\r\n      //   autoDial: true, // Auto connect to discovered peers (limited by ConnectionManager minPeers)\r\n      //   mdns: {\r\n      //     // mdns options\r\n      //     interval: 1000, // ms\r\n      //     enabled: true,\r\n      //   },\r\n      //   webRTCStar: {\r\n      //     // webrtc-star options\r\n      //     interval: 1000, // ms\r\n      //     enabled: false,\r\n      //   },\r\n      //   // .. other discovery module options.\r\n      // },\r\n      // Prevents large data transfers\r\n      //TODO: nejak oddelit at to neni random ale treba username nebo neco\r\n      repo: `/orbitdb/decentio-orbitdb-chat-ipfs-${this.rootStore.sessionStore._user}}`,\r\n      EXPERIMENTAL: {\r\n        pubsub: true,\r\n      },\r\n\r\n      config: {\r\n        Addresses: {\r\n          Swarm: [\r\n            //       // Use IPFS dev signal server\r\n            //       // Websocket:\r\n            // \"/dns4/ws-star-signal-1.servep2p.com/tcp/443/wss/p2p-websocket-star\",\r\n            // \"/dns4/ws-star-signal-2.servep2p.com/tcp/443/wss/p2p-websocket-star\",\r\n            // \"/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star\",\r\n            // WebRTC:\r\n            \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\r\n            \"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\r\n            \"/dns4/webrtc-star.discovery.libp2p.io/tcp/443/wss/p2p-webrtc-star/\",\r\n            \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star\",\r\n            \"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star\",\r\n            // \"/ip4/0.0.0.0/tcp/4002\",\r\n            // \"/ip4/127.0.0.1/tcp/4003/ws\",\r\n            // \"/libp2p-webrtc-star/dns4/star-signal.cloud.ipfs.team/wss\",\r\n            // \"/dns4/star-signal.cloud.ipfs.team/wss/p2p-webrtc-star\",\r\n            //       // Use local signal server\r\n            \"/ip4/0.0.0.0/tcp/4011/ws\",\r\n            \"/ip6/::/tcp/4011/ws\",\r\n          ],\r\n        },\r\n        Bootstrap: [],\r\n      },\r\n    };\r\n\r\n    await this.start(ipfsConfig, dbConfig);\r\n  }\r\n\r\n  async start(ipfsConf, orbitDbconf) {\r\n    await this.startIpfsNode(ipfsConf);\r\n    await this.startOrbitDb(orbitDbconf);\r\n    // this.ipfsNode.config.set(\"Addresses.Swarm\", [\"/ip4/0.0.0.0/tcp/4002\", \"/ip4/127.0.0.1/tcp/4003/ws\"], console.log);\r\n\r\n    const peerInfo = await this.ipfsNode.id();\r\n    console.log(\"Peer ID: \" + peerInfo.id);\r\n    // this.ipfsNode.libp2p.on(\"peer:connect\", this.handlePeerConnected.bind(this));\r\n    this.ipfsNode.libp2p.on(\"peer:connect\", (peer) => console.log(\"Connected peer: \" + peer));\r\n    // this.ipfsNode.libp2p.on(\"peer:discovery\", (peer) => console.log(\"Peer: \" + peer));\r\n\r\n    // this.ipfsNode.libp2p.pubsub.subscribe(peerInfo.id, (msg) => console.log(msg));\r\n    // this.ipfsNode.libp2p.pubsub.publish(peerInfo.id, \"Hello\");\r\n\r\n    this.ipfsNode.libp2p.pubsub.subscribe(\"test\", (msg) => console.log(msg));\r\n    this.ipfsNode.libp2p.pubsub.publish(\"test\", \"Hello\");\r\n\r\n    // this.sendMessage(\"12D3KooWH1XyPHHfv2ipZEEkevBGrqNs7PXUCVALyh2vjLn9BtaJ\", \"Test\");\r\n    console.log(await this.ipfsNode.bootstrap.swarm.peers());\r\n    // if (peerInfo.id !== \"12D3KooWH1XyPHHfv2ipZEEkevBGrqNs7PXUCVALyh2vjLn9BtaJ\") {\r\n    //   const addr = \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/12D3KooWH1XyPHHfv2ipZEEkevBGrqNs7PXUCVALyh2vjLn9BtaJ\";\r\n    //   try {\r\n    //     await this.ipfsNode.swarm.connect(addr);\r\n    //   } catch (err) {\r\n    //     console.log(err);\r\n    //     await this.ipfsNode.swarm.connect(addr);\r\n    //   }\r\n    // }\r\n    // this.handlePeerConnected(peerInfo);\r\n    console.log(\"Peer Addresses: \" + peerInfo.addresses);\r\n    console.log(await this.getIpfsPeers());\r\n\r\n    const topics = await this.ipfsNode.pubsub.ls();\r\n    console.log(topics);\r\n\r\n    const defaultOptions = { accessController: { write: [this.orbitDb.identity.id] } };\r\n\r\n    const docStoreOptions = {\r\n      ...defaultOptions,\r\n      indexBy: \"hash\",\r\n    };\r\n\r\n    this.messages = await this.orbitDb.docstore(\"messages\", docStoreOptions);\r\n    await this.messages.load();\r\n    console.log(this.messages.db);\r\n\r\n    this.peersDb = await this.orbitDb.keyvalue(\"peers\", defaultOptions);\r\n    await this.peersDb.load();\r\n  }\r\n\r\n  async handleMessageReceived(msg) {\r\n    const parsedMsg = JSON.parse(msg.data.toString());\r\n    const msgKeys = Object.keys(parsedMsg);\r\n    console.log(\"ParsedDb: \" + parsedMsg);\r\n    console.log(msgKeys[0]);\r\n    switch (msgKeys[0]) {\r\n      case \"userDb\":\r\n        var peerDb = await this.orbitDb.open(parsedMsg.userDb, { create: true, type: \"keyvalue\" });\r\n        peerDb.events.on(\"replicated\", async () => {\r\n          if (peerDb.get(\"pieces\")) {\r\n            await this.peersDb.set(peerDb.id, peerDb.all);\r\n            console.log(peerDb.all);\r\n          }\r\n        });\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    console.log(msg.data.toString());\r\n    // if (this.onmessage) this.onmessage(msg);\r\n  }\r\n\r\n  async connectToPeer(multiaddr, protocol = \"/p2p-circuit/ipfs/\") {\r\n    try {\r\n      await this.ipfsNode.swarm.connect(multiaddr);\r\n    } catch (e) {\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  getPeers() {\r\n    return this.peersDb.all;\r\n  }\r\n  async connectToPeers() {\r\n    const peerIds = Object.values(this.peersDb.all).map((peer) => peer.nodeId);\r\n    console.log(peerIds);\r\n    const connectedPeerIds = await this.getIpfsPeers();\r\n    await Promise.all(\r\n      peerIds.map(async (peerId) => {\r\n        if (connectedPeerIds.indexOf(peerId) !== -1) return;\r\n        try {\r\n          console.log(peerId);\r\n          await this.connectToPeer(peerId);\r\n        } catch (e) {}\r\n      })\r\n    );\r\n  }\r\n\r\n  handlePeerConnected(ipfsPeer) {\r\n    console.log(\"IPFS Peer: \" + ipfsPeer);\r\n    const ipfsId = ipfsPeer.id.toB58String();\r\n    setTimeout(async () => {\r\n      await this.sendMessage(ipfsId, { userDb: \"test\" });\r\n    }, 2000);\r\n  }\r\n\r\n  // async queryCatalog(queryFn) {\r\n  //   const dbAddrs = Object.values(this.companions.all).map((peer) => peer.pieces);\r\n\r\n  //   const allPieces = await Promise.all(\r\n  //     dbAddrs.map(async (addr) => {\r\n  //       const db = await this.orbitDb.open(addr);\r\n  //       await db.load();\r\n\r\n  //       return db.query(queryFn);\r\n  //     })\r\n  //   );\r\n\r\n  //   return allPieces.reduce((flatPieces, pieces) => flatPieces.concat(pieces), this.messages.query(queryFn));\r\n  // }\r\n\r\n  async sendMessage(topic, message) {\r\n    try {\r\n      const msgString = JSON.stringify(message);\r\n      const messageBuffer = Buffer.from(msgString);\r\n      await this.ipfsNode.pubsub.publish(topic, messageBuffer);\r\n    } catch (e) {\r\n      throw e;\r\n    }\r\n  }\r\n  async startIpfsNode(ipfsConf) {\r\n    this.ipfsNode = await IPFS.create(ipfsConf);\r\n  }\r\n  async startOrbitDb(orbitDbconf) {\r\n    this.orbitDb = await OrbitDB.createInstance(this.ipfsNode, orbitDbconf);\r\n  }\r\n  async getIpfsPeers() {\r\n    const peers = await this.ipfsNode.swarm.peers();\r\n    // console.log(peers);\r\n    return peers;\r\n  }\r\n\r\n  async createDBStore(address) {\r\n    const store = await this.orbitDb.docstore(address);\r\n    await store.load();\r\n    return store;\r\n  }\r\n\r\n  async handleStop() {\r\n    await this.orbitDb.disconnect();\r\n    await this.ipfsNode.stop();\r\n    delete this.orbitDb;\r\n    delete this.ipfsNode;\r\n  }\r\n}\r\n"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,UAApB;AACA,OAAOC,IAAP,MAAiB,MAAjB;AACA,SAASC,kBAAT,QAAmC,MAAnC;AACA,SAASC,SAAT,QAA0B,WAA1B;AAEA,eAAe,MAAMC,SAAN,CAAgB;EAG7BC,WAAW,CAACC,SAAD,EAAY;IACrB,KAAKA,SAAL,GAAiBA,SAAjB;IACAJ,kBAAkB,CAAC,IAAD,CAAlB;EACD;;EAES,MAAJK,IAAI,GAAG;IACX,IAAI,KAAKC,QAAL,KAAkBC,SAAtB,EAAiC;IACjC,IAAI,KAAKC,OAAL,KAAiBD,SAArB,EAAgC;IAEhC,MAAME,QAAQ,GAAG;MACf;MACAC,MAAM,EAAE,IAFO;MAGf;MACAC,IAAI,EAAE,IAJS;MAKf;MACA;MACAC,SAAS,EAAE,KAPI;MAQf;MACA;MACAC,gBAAgB,EAAE;QAChBC,KAAK,EAAE,CAAC,GAAD;MADS;IAVH,CAAjB;IAcA,MAAMC,UAAU,GAAG;MACjB;MACAC,KAAK,EAAE;QAAEC,OAAO,EAAE,IAAX;QAAiBC,GAAG,EAAE;UAAED,OAAO,EAAE,IAAX;UAAiBE,MAAM,EAAE;QAAzB;MAAtB,CAFU;MAGjB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACAC,IAAI,EAAG,uCAAsC,KAAKhB,SAAL,CAAeiB,YAAf,CAA4BC,KAAM,GAlC9D;MAmCjBC,YAAY,EAAE;QACZC,MAAM,EAAE;MADI,CAnCG;MAuCjBC,MAAM,EAAE;QACNC,SAAS,EAAE;UACTC,KAAK,EAAE,CACL;UACA;UACA;UACA;UACA;UACA;UACA,+DAPK,EAQL,+DARK,EASL,oEATK,EAUL,8DAVK,EAWL,8DAXK,EAYL;UACA;UACA;UACA;UACA;UACA,0BAjBK,EAkBL,qBAlBK;QADE,CADL;QAuBNC,SAAS,EAAE;MAvBL;IAvCS,CAAnB;IAkEA,MAAM,KAAKC,KAAL,CAAWd,UAAX,EAAuBN,QAAvB,CAAN;EACD;;EAEU,MAALoB,KAAK,CAACC,QAAD,EAAWC,WAAX,EAAwB;IACjC,MAAM,KAAKC,aAAL,CAAmBF,QAAnB,CAAN;IACA,MAAM,KAAKG,YAAL,CAAkBF,WAAlB,CAAN,CAFiC,CAGjC;;IAEA,MAAMG,QAAQ,GAAG,MAAM,KAAK5B,QAAL,CAAc6B,EAAd,EAAvB;IACAC,OAAO,CAACC,GAAR,CAAY,cAAcH,QAAQ,CAACC,EAAnC,EANiC,CAOjC;;IACA,KAAK7B,QAAL,CAAcgC,MAAd,CAAqBC,EAArB,CAAwB,cAAxB,EAAyCC,IAAD,IAAUJ,OAAO,CAACC,GAAR,CAAY,qBAAqBG,IAAjC,CAAlD,EARiC,CASjC;IAEA;IACA;;IAEA,KAAKlC,QAAL,CAAcgC,MAAd,CAAqBd,MAArB,CAA4BiB,SAA5B,CAAsC,MAAtC,EAA+CC,GAAD,IAASN,OAAO,CAACC,GAAR,CAAYK,GAAZ,CAAvD;IACA,KAAKpC,QAAL,CAAcgC,MAAd,CAAqBd,MAArB,CAA4BmB,OAA5B,CAAoC,MAApC,EAA4C,OAA5C,EAfiC,CAiBjC;;IACAP,OAAO,CAACC,GAAR,CAAY,MAAM,KAAK/B,QAAL,CAAcsC,SAAd,CAAwBC,KAAxB,CAA8BC,KAA9B,EAAlB,EAlBiC,CAmBjC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IACAV,OAAO,CAACC,GAAR,CAAY,qBAAqBH,QAAQ,CAACa,SAA1C;IACAX,OAAO,CAACC,GAAR,CAAY,MAAM,KAAKW,YAAL,EAAlB;IAEA,MAAMC,MAAM,GAAG,MAAM,KAAK3C,QAAL,CAAckB,MAAd,CAAqB0B,EAArB,EAArB;IACAd,OAAO,CAACC,GAAR,CAAYY,MAAZ;IAEA,MAAME,cAAc,GAAG;MAAEtC,gBAAgB,EAAE;QAAEC,KAAK,EAAE,CAAC,KAAKN,OAAL,CAAa4C,QAAb,CAAsBjB,EAAvB;MAAT;IAApB,CAAvB;IAEA,MAAMkB,eAAe,GAAG,EACtB,GAAGF,cADmB;MAEtBG,OAAO,EAAE;IAFa,CAAxB;IAKA,KAAKC,QAAL,GAAgB,MAAM,KAAK/C,OAAL,CAAagD,QAAb,CAAsB,UAAtB,EAAkCH,eAAlC,CAAtB;IACA,MAAM,KAAKE,QAAL,CAAcE,IAAd,EAAN;IACArB,OAAO,CAACC,GAAR,CAAY,KAAKkB,QAAL,CAAcG,EAA1B;IAEA,KAAKC,OAAL,GAAe,MAAM,KAAKnD,OAAL,CAAaoD,QAAb,CAAsB,OAAtB,EAA+BT,cAA/B,CAArB;IACA,MAAM,KAAKQ,OAAL,CAAaF,IAAb,EAAN;EACD;;EAE0B,MAArBI,qBAAqB,CAACnB,GAAD,EAAM;IAC/B,MAAMoB,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAWtB,GAAG,CAACuB,IAAJ,CAASC,QAAT,EAAX,CAAlB;IACA,MAAMC,OAAO,GAAGC,MAAM,CAACC,IAAP,CAAYP,SAAZ,CAAhB;IACA1B,OAAO,CAACC,GAAR,CAAY,eAAeyB,SAA3B;IACA1B,OAAO,CAACC,GAAR,CAAY8B,OAAO,CAAC,CAAD,CAAnB;;IACA,QAAQA,OAAO,CAAC,CAAD,CAAf;MACE,KAAK,QAAL;QACE,IAAIG,MAAM,GAAG,MAAM,KAAK9D,OAAL,CAAa+D,IAAb,CAAkBT,SAAS,CAACU,MAA5B,EAAoC;UAAE9D,MAAM,EAAE,IAAV;UAAgB+D,IAAI,EAAE;QAAtB,CAApC,CAAnB;QACAH,MAAM,CAACI,MAAP,CAAcnC,EAAd,CAAiB,YAAjB,EAA+B,YAAY;UACzC,IAAI+B,MAAM,CAACK,GAAP,CAAW,QAAX,CAAJ,EAA0B;YACxB,MAAM,KAAKhB,OAAL,CAAaiB,GAAb,CAAiBN,MAAM,CAACnC,EAAxB,EAA4BmC,MAAM,CAACO,GAAnC,CAAN;YACAzC,OAAO,CAACC,GAAR,CAAYiC,MAAM,CAACO,GAAnB;UACD;QACF,CALD;QAMA;;MACF;QACE;IAXJ;;IAaAzC,OAAO,CAACC,GAAR,CAAYK,GAAG,CAACuB,IAAJ,CAASC,QAAT,EAAZ,EAlB+B,CAmB/B;EACD;;EAEkB,MAAbY,aAAa,CAAC7E,SAAD,EAA6C;IAAA,IAAjC8E,QAAiC,uEAAtB,oBAAsB;;IAC9D,IAAI;MACF,MAAM,KAAKzE,QAAL,CAAcuC,KAAd,CAAoBmC,OAApB,CAA4B/E,SAA5B,CAAN;IACD,CAFD,CAEE,OAAOgF,CAAP,EAAU;MACV,MAAMA,CAAN;IACD;EACF;;EAEDC,QAAQ,GAAG;IACT,OAAO,KAAKvB,OAAL,CAAakB,GAApB;EACD;;EACmB,MAAdM,cAAc,GAAG;IACrB,MAAMC,OAAO,GAAGhB,MAAM,CAACiB,MAAP,CAAc,KAAK1B,OAAL,CAAakB,GAA3B,EAAgCS,GAAhC,CAAqC9C,IAAD,IAAUA,IAAI,CAAC+C,MAAnD,CAAhB;IACAnD,OAAO,CAACC,GAAR,CAAY+C,OAAZ;IACA,MAAMI,gBAAgB,GAAG,MAAM,KAAKxC,YAAL,EAA/B;IACA,MAAMyC,OAAO,CAACZ,GAAR,CACJO,OAAO,CAACE,GAAR,CAAY,MAAOI,MAAP,IAAkB;MAC5B,IAAIF,gBAAgB,CAACG,OAAjB,CAAyBD,MAAzB,MAAqC,CAAC,CAA1C,EAA6C;;MAC7C,IAAI;QACFtD,OAAO,CAACC,GAAR,CAAYqD,MAAZ;QACA,MAAM,KAAKZ,aAAL,CAAmBY,MAAnB,CAAN;MACD,CAHD,CAGE,OAAOT,CAAP,EAAU,CAAE;IACf,CAND,CADI,CAAN;EASD;;EAEDW,mBAAmB,CAACC,QAAD,EAAW;IAC5BzD,OAAO,CAACC,GAAR,CAAY,gBAAgBwD,QAA5B;IACA,MAAMC,MAAM,GAAGD,QAAQ,CAAC1D,EAAT,CAAY4D,WAAZ,EAAf;IACAC,UAAU,CAAC,YAAY;MACrB,MAAM,KAAKC,WAAL,CAAiBH,MAAjB,EAAyB;QAAEtB,MAAM,EAAE;MAAV,CAAzB,CAAN;IACD,CAFS,EAEP,IAFO,CAAV;EAGD,CAvM4B,CAyM7B;EACA;EAEA;EACA;EACA;EACA;EAEA;EACA;EACA;EAEA;EACA;;;EAEiB,MAAXyB,WAAW,CAACC,KAAD,EAAQC,OAAR,EAAiB;IAChC,IAAI;MACF,MAAMC,SAAS,GAAGrC,IAAI,CAACsC,SAAL,CAAeF,OAAf,CAAlB;MACA,MAAMG,aAAa,GAAGC,MAAM,CAACC,IAAP,CAAYJ,SAAZ,CAAtB;MACA,MAAM,KAAK9F,QAAL,CAAckB,MAAd,CAAqBmB,OAArB,CAA6BuD,KAA7B,EAAoCI,aAApC,CAAN;IACD,CAJD,CAIE,OAAOrB,CAAP,EAAU;MACV,MAAMA,CAAN;IACD;EACF;;EACkB,MAAbjD,aAAa,CAACF,QAAD,EAAW;IAC5B,KAAKxB,QAAL,GAAgB,MAAMP,IAAI,CAACW,MAAL,CAAYoB,QAAZ,CAAtB;EACD;;EACiB,MAAZG,YAAY,CAACF,WAAD,EAAc;IAC9B,KAAKvB,OAAL,GAAe,MAAMV,OAAO,CAAC2G,cAAR,CAAuB,KAAKnG,QAA5B,EAAsCyB,WAAtC,CAArB;EACD;;EACiB,MAAZiB,YAAY,GAAG;IACnB,MAAMF,KAAK,GAAG,MAAM,KAAKxC,QAAL,CAAcuC,KAAd,CAAoBC,KAApB,EAApB,CADmB,CAEnB;;IACA,OAAOA,KAAP;EACD;;EAEkB,MAAb4D,aAAa,CAACC,OAAD,EAAU;IAC3B,MAAMC,KAAK,GAAG,MAAM,KAAKpG,OAAL,CAAagD,QAAb,CAAsBmD,OAAtB,CAApB;IACA,MAAMC,KAAK,CAACnD,IAAN,EAAN;IACA,OAAOmD,KAAP;EACD;;EAEe,MAAVC,UAAU,GAAG;IACjB,MAAM,KAAKrG,OAAL,CAAasG,UAAb,EAAN;IACA,MAAM,KAAKxG,QAAL,CAAcyG,IAAd,EAAN;IACA,OAAO,KAAKvG,OAAZ;IACA,OAAO,KAAKF,QAAZ;EACD;;AAxP4B"},"metadata":{},"sourceType":"module"}