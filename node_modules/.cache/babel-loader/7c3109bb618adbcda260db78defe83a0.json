{"ast":null,"code":"/* eslint-env browser */\n'use strict';\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst HTTP = require('ipfs-utils/src/http');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:preload'), {\n  error: debug('ipfs:preload:error')\n}); // browsers limit concurrent connections per host,\n// we don't want preload calls to exhaust the limit (~6)\n\nconst httpQueue = new PQueue({\n  concurrency: 4\n});\n/**\n * @param {string} url\n * @param {import('ipfs-core-types/src/utils').AbortOptions} options\n */\n\nmodule.exports = function preload(url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  log(url);\n  return httpQueue.add(async () => {\n    const res = await HTTP.post(url, {\n      signal: options.signal\n    }); // @ts-ignore\n\n    const reader = res.body.getReader();\n\n    try {\n      while (true) {\n        const {\n          done\n        } = await reader.read();\n        if (done) return; // Read to completion but do not cache\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  });\n};","map":{"version":3,"names":["default","PQueue","require","HTTP","debug","log","Object","assign","error","httpQueue","concurrency","module","exports","preload","url","options","add","res","post","signal","reader","body","getReader","done","read","releaseLock"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/runtime/preload-browser.js"],"sourcesContent":["/* eslint-env browser */\n'use strict'\n\nconst { default: PQueue } = require('p-queue')\nconst HTTP = require('ipfs-utils/src/http')\nconst debug = require('debug')\n\nconst log = Object.assign(debug('ipfs:preload'), {\n  error: debug('ipfs:preload:error')\n})\n\n// browsers limit concurrent connections per host,\n// we don't want preload calls to exhaust the limit (~6)\nconst httpQueue = new PQueue({ concurrency: 4 })\n\n/**\n * @param {string} url\n * @param {import('ipfs-core-types/src/utils').AbortOptions} options\n */\nmodule.exports = function preload (url, options = {}) {\n  log(url)\n\n  return httpQueue.add(async () => {\n    const res = await HTTP.post(url, { signal: options.signal })\n\n    // @ts-ignore\n    const reader = res.body.getReader()\n\n    try {\n      while (true) {\n        const { done } = await reader.read()\n        if (done) return\n        // Read to completion but do not cache\n      }\n    } finally {\n      reader.releaseLock()\n    }\n  })\n}\n"],"mappings":"AAAA;AACA;;AAEA,MAAM;EAAEA,OAAO,EAAEC;AAAX,IAAsBC,OAAO,CAAC,SAAD,CAAnC;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,qBAAD,CAApB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,OAAD,CAArB;;AAEA,MAAMG,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcH,KAAK,CAAC,cAAD,CAAnB,EAAqC;EAC/CI,KAAK,EAAEJ,KAAK,CAAC,oBAAD;AADmC,CAArC,CAAZ,C,CAIA;AACA;;AACA,MAAMK,SAAS,GAAG,IAAIR,MAAJ,CAAW;EAAES,WAAW,EAAE;AAAf,CAAX,CAAlB;AAEA;AACA;AACA;AACA;;AACAC,MAAM,CAACC,OAAP,GAAiB,SAASC,OAAT,CAAkBC,GAAlB,EAAqC;EAAA,IAAdC,OAAc,uEAAJ,EAAI;EACpDV,GAAG,CAACS,GAAD,CAAH;EAEA,OAAOL,SAAS,CAACO,GAAV,CAAc,YAAY;IAC/B,MAAMC,GAAG,GAAG,MAAMd,IAAI,CAACe,IAAL,CAAUJ,GAAV,EAAe;MAAEK,MAAM,EAAEJ,OAAO,CAACI;IAAlB,CAAf,CAAlB,CAD+B,CAG/B;;IACA,MAAMC,MAAM,GAAGH,GAAG,CAACI,IAAJ,CAASC,SAAT,EAAf;;IAEA,IAAI;MACF,OAAO,IAAP,EAAa;QACX,MAAM;UAAEC;QAAF,IAAW,MAAMH,MAAM,CAACI,IAAP,EAAvB;QACA,IAAID,IAAJ,EAAU,OAFC,CAGX;MACD;IACF,CAND,SAMU;MACRH,MAAM,CAACK,WAAP;IACD;EACF,CAfM,CAAP;AAgBD,CAnBD"},"metadata":{},"sourceType":"script"}