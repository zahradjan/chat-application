{"ast":null,"code":"'use strict'; // @ts-ignore\n\nconst SparseArray = require('sparse-array');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\n\n\nclass Bucket {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  constructor(options, parent) {\n    let posAtParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._options = options;\n    this._popCount = 0;\n    this._parent = parent;\n    this._posAtParent = posAtParent;\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n\n    this._children = new SparseArray();\n    /** @type {string | null} */\n\n    this.key = null;\n  }\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n\n\n  async put(key, value) {\n    const place = await this._findNewBucketAndPos(key);\n    await place.bucket._putAt(place, key, value);\n  }\n  /**\n   * @param {string} key\n   */\n\n\n  async get(key) {\n    const child = await this._findChild(key);\n\n    if (child) {\n      return child.value;\n    }\n  }\n  /**\n   * @param {string} key\n   */\n\n\n  async del(key) {\n    const place = await this._findPlace(key);\n\n    const child = place.bucket._at(place.pos);\n\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos);\n    }\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  leafCount() {\n    const children = this._children.compactArray();\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount();\n      }\n\n      return acc + 1;\n    }, 0);\n  }\n\n  childrenCount() {\n    return this._children.length;\n  }\n\n  onlyChild() {\n    return this._children.get(0);\n  }\n  /**\n   * @returns {Iterable<BucketChild<T>>}\n   */\n\n\n  *eachLeafSeries() {\n    const children = this._children.compactArray();\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield* child.eachLeafSeries();\n      } else {\n        yield child;\n      }\n    } // this is necessary because tsc requires a @return annotation as it\n    // can't derive a return type due to the recursion, and eslint requires\n    // a return statement when there is a @return annotation\n\n\n    return [];\n  }\n  /**\n   * @param {(value: BucketChild<T>, index: number) => T} map\n   * @param {(reduced: any) => any} reduce\n   */\n\n\n  serialize(map, reduce) {\n    /** @type {T[]} */\n    const acc = []; // serialize to a custom non-sparse representation\n\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce));\n        } else {\n          acc.push(map(child, index));\n        }\n      }\n\n      return acc;\n    }, acc));\n  }\n  /**\n   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n   * @param {(reduced: any) => Promise<any>} asyncReduce\n   */\n\n\n  asyncTransform(asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce);\n  }\n\n  toJSON() {\n    return this.serialize(mapNode, reduceNodes);\n  }\n\n  prettyPrint() {\n    return JSON.stringify(this.toJSON(), null, '  ');\n  }\n\n  tableSize() {\n    return Math.pow(2, this._options.bits);\n  }\n  /**\n   * @param {string} key\n   * @returns {Promise<BucketChild<T> | undefined>}\n   */\n\n\n  async _findChild(key) {\n    const result = await this._findPlace(key);\n\n    const child = result.bucket._at(result.pos);\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined;\n    }\n\n    if (child && child.key === key) {\n      return child;\n    }\n  }\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n\n\n  async _findPlace(key) {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key);\n\n    const index = await hashValue.take(this._options.bits);\n\n    const child = this._children.get(index);\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue);\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    };\n  }\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n\n\n  async _findNewBucketAndPos(key) {\n    const place = await this._findPlace(key);\n\n    if (place.existingChild && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos);\n\n      place.bucket._putObjectAt(place.pos, bucket); // put the previous value\n\n\n      const newPlace = await bucket._findPlace(place.existingChild.hash);\n\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);\n\n      return bucket._findNewBucketAndPos(place.hash);\n    } // no conflict, we found the place\n\n\n    return place;\n  }\n  /**\n   * @param {BucketPosition<T>} place\n   * @param {string} key\n   * @param {T} value\n   */\n\n\n  _putAt(place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    });\n  }\n  /**\n   * @param {number} pos\n   * @param {Bucket<T> | BucketChild<T>} object\n   */\n\n\n  _putObjectAt(pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++;\n    }\n\n    this._children.set(pos, object);\n  }\n  /**\n   * @param {number} pos\n   */\n\n\n  _delAt(pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position');\n    }\n\n    if (this._children.get(pos)) {\n      this._popCount--;\n    }\n\n    this._children.unset(pos);\n\n    this._level();\n  }\n\n  _level() {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists);\n\n        if (onlyChild && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash;\n          hash.untake(this._options.bits);\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          };\n\n          this._parent._putAt(place, onlyChild.key, onlyChild.value);\n        }\n      } else {\n        this._parent._delAt(this._posAtParent);\n      }\n    }\n  }\n  /**\n   * @param {number} index\n   * @returns {BucketChild<T> | Bucket<T> | undefined}\n   */\n\n\n  _at(index) {\n    return this._children.get(index);\n  }\n\n}\n/**\n * @param {any} o\n */\n\n\nfunction exists(o) {\n  return Boolean(o);\n}\n/**\n *\n * @param {*} node\n * @param {number} index\n */\n\n\nfunction mapNode(node, index) {\n  return node.key;\n}\n/**\n * @param {*} nodes\n */\n\n\nfunction reduceNodes(nodes) {\n  return nodes;\n}\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\n\n\nasync function asyncTransformBucket(bucket, asyncMap, asyncReduce) {\n  const output = [];\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce);\n    } else {\n      const mappedChildren = await asyncMap(child);\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      });\n    }\n  }\n\n  return asyncReduce(output);\n}\n\nmodule.exports = Bucket;","map":{"version":3,"names":["SparseArray","require","fromString","uint8ArrayFromString","Bucket","constructor","options","parent","posAtParent","_options","_popCount","_parent","_posAtParent","_children","key","put","value","place","_findNewBucketAndPos","bucket","_putAt","get","child","_findChild","del","_findPlace","_at","pos","_delAt","leafCount","children","compactArray","reduce","acc","childrenCount","length","onlyChild","eachLeafSeries","serialize","map","index","push","asyncTransform","asyncMap","asyncReduce","asyncTransformBucket","toJSON","mapNode","reduceNodes","prettyPrint","JSON","stringify","tableSize","Math","pow","bits","result","undefined","hashValue","hash","take","existingChild","_putObjectAt","newPlace","object","set","Error","unset","_level","find","exists","untake","o","Boolean","node","nodes","output","mappedChildren","bitField","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/hamt-sharding/src/bucket.js"],"sourcesContent":["'use strict'\n\n// @ts-ignore\nconst SparseArray = require('sparse-array')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\n\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\nclass Bucket {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  constructor (options, parent, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n    this._children = new SparseArray()\n\n    /** @type {string | null} */\n    this.key = null\n  }\n\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n  async put (key, value) {\n    const place = await this._findNewBucketAndPos(key)\n\n    await place.bucket._putAt(place, key, value)\n  }\n\n  /**\n   * @param {string} key\n   */\n  async get (key) {\n    const child = await this._findChild(key)\n\n    if (child) {\n      return child.value\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  async del (key) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  /**\n   * @returns {number}\n   */\n  leafCount () {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount () {\n    return this._children.length\n  }\n\n  onlyChild () {\n    return this._children.get(0)\n  }\n\n  /**\n   * @returns {Iterable<BucketChild<T>>}\n   */\n  * eachLeafSeries () {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n\n    // this is necessary because tsc requires a @return annotation as it\n    // can't derive a return type due to the recursion, and eslint requires\n    // a return statement when there is a @return annotation\n    return []\n  }\n\n  /**\n   * @param {(value: BucketChild<T>, index: number) => T} map\n   * @param {(reduced: any) => any} reduce\n   */\n  serialize (map, reduce) {\n    /** @type {T[]} */\n    const acc = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  /**\n   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n   * @param {(reduced: any) => Promise<any>} asyncReduce\n   */\n  asyncTransform (asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON () {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint () {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize () {\n    return Math.pow(2, this._options.bits)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Promise<BucketChild<T> | undefined>}\n   */\n  async _findChild (key) {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child && child.key === key) {\n      return child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findPlace (key) {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findNewBucketAndPos (key) {\n    const place = await this._findPlace(key)\n\n    if (place.existingChild && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  /**\n   * @param {BucketPosition<T>} place\n   * @param {string} key\n   * @param {T} value\n   */\n  _putAt (place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    })\n  }\n\n  /**\n   * @param {number} pos\n   * @param {Bucket<T> | BucketChild<T>} object\n   */\n  _putObjectAt (pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  /**\n   * @param {number} pos\n   */\n  _delAt (pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos)) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level () {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if (onlyChild && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @returns {BucketChild<T> | Bucket<T> | undefined}\n   */\n  _at (index) {\n    return this._children.get(index)\n  }\n}\n\n/**\n * @param {any} o\n */\nfunction exists (o) {\n  return Boolean(o)\n}\n\n/**\n *\n * @param {*} node\n * @param {number} index\n */\nfunction mapNode (node, index) {\n  return node.key\n}\n\n/**\n * @param {*} nodes\n */\nfunction reduceNodes (nodes) {\n  return nodes\n}\n\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\nasync function asyncTransformBucket (bucket, asyncMap, asyncReduce) {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return asyncReduce(output)\n}\n\nmodule.exports = Bucket\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}