{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar mkdir = require('./mkdir');\n\nvar stat = require('./stat');\n\nvar log = require('debug')('ipfs:mfs:cp');\n\nvar errCode = require('err-code');\n\nvar updateTree = require('./utils/update-tree');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar addLink = require('./utils/add-link');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nvar toTrail = require('./utils/to-trail');\n\nvar withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} DAGNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').Mtime} Mtime\n * @typedef {import('./utils/to-mfs-path').MfsPath} MfsPath\n * @typedef {import('./utils/to-trail').MfsTrail} MfsTrail\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nvar defaultOptions = {\n  parents: false,\n  flush: true,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000\n};\n/**\n * @param {MfsContext} context\n */\n\nmodule.exports = function (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"cp\"]}\n   */\n  function mfsCp(_x, _x2) {\n    return _mfsCp.apply(this, arguments);\n  }\n\n  function _mfsCp() {\n    _mfsCp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(from, to) {\n      var opts,\n          options,\n          sources,\n          destination,\n          missing,\n          destinationIsDirectory,\n          parentFolder,\n          destinationPath,\n          trail,\n          source,\n          destinationName,\n          _args = arguments;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n\n              /** @type {DefaultOptions} */\n              options = mergeOptions(defaultOptions, opts);\n\n              if (!Array.isArray(from)) {\n                from = [from];\n              }\n\n              _context.next = 5;\n              return Promise.all(from.map(function (\n              /** @type {CID | string} */\n              path) {\n                return toMfsPath(context, path, options);\n              }));\n\n            case 5:\n              sources = _context.sent;\n              _context.next = 8;\n              return toMfsPath(context, to, options);\n\n            case 8:\n              destination = _context.sent;\n\n              if (!(!sources.length || !destination)) {\n                _context.next = 11;\n                break;\n              }\n\n              throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS');\n\n            case 11:\n              // make sure all sources exist\n              missing = sources.find(function (source) {\n                return !source.exists;\n              });\n\n              if (!missing) {\n                _context.next = 14;\n                break;\n              }\n\n              throw errCode(new Error(\"\".concat(missing.path, \" does not exist\")), 'ERR_INVALID_PARAMS');\n\n            case 14:\n              destinationIsDirectory = isDirectory(destination);\n\n              if (!destination.exists) {\n                _context.next = 21;\n                break;\n              }\n\n              log('Destination exists'); // @ts-ignore ts seems to think `sources` will always have a length of 10\n\n              if (!(sources.length === 1 && !destinationIsDirectory)) {\n                _context.next = 19;\n                break;\n              }\n\n              throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS');\n\n            case 19:\n              _context.next = 50;\n              break;\n\n            case 21:\n              log('Destination does not exist');\n\n              if (!(sources.length > 1)) {\n                _context.next = 32;\n                break;\n              }\n\n              if (options.parents) {\n                _context.next = 25;\n                break;\n              }\n\n              throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n\n            case 25:\n              _context.next = 27;\n              return mkdir(context)(destination.path, options);\n\n            case 27:\n              _context.next = 29;\n              return toMfsPath(context, destination.path, options);\n\n            case 29:\n              destination = _context.sent;\n              _context.next = 50;\n              break;\n\n            case 32:\n              if (!(destination.parts.length > 1)) {\n                _context.next = 50;\n                break;\n              }\n\n              // copying to a folder, create it if necessary\n              parentFolder = \"/\".concat(destination.parts.slice(0, -1).join('/'));\n              _context.prev = 34;\n              _context.next = 37;\n              return stat(context)(parentFolder, options);\n\n            case 37:\n              _context.next = 50;\n              break;\n\n            case 39:\n              _context.prev = 39;\n              _context.t0 = _context[\"catch\"](34);\n\n              if (!(_context.t0.code !== 'ERR_NOT_FOUND')) {\n                _context.next = 43;\n                break;\n              }\n\n              throw _context.t0;\n\n            case 43:\n              if (options.parents) {\n                _context.next = 45;\n                break;\n              }\n\n              throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n\n            case 45:\n              _context.next = 47;\n              return mkdir(context)(parentFolder, options);\n\n            case 47:\n              _context.next = 49;\n              return toMfsPath(context, destination.path, options);\n\n            case 49:\n              destination = _context.sent;\n\n            case 50:\n              destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;\n              _context.next = 53;\n              return toTrail(context, destinationPath);\n\n            case 53:\n              trail = _context.sent;\n\n              if (!(sources.length === 1)) {\n                _context.next = 61;\n                break;\n              }\n\n              source = sources.pop();\n\n              if (source) {\n                _context.next = 58;\n                break;\n              }\n\n              throw errCode(new Error('could not find source'), 'ERR_INVALID_PARAMS');\n\n            case 58:\n              destinationName = destinationIsDirectory ? source.name : destination.name;\n              log(\"Only one source, copying to destination \".concat(destinationIsDirectory ? 'directory' : 'file', \" \").concat(destinationName));\n              return _context.abrupt(\"return\", copyToFile(context, source, destinationName, trail, options));\n\n            case 61:\n              log('Multiple sources, wrapping in a directory');\n              return _context.abrupt(\"return\", copyToDirectory(context, sources, destination, trail, options));\n\n            case 63:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[34, 39]]);\n    }));\n    return _mfsCp.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsCp);\n};\n/**\n * @param {*} destination\n */\n\n\nvar isDirectory = function isDirectory(destination) {\n  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes('directory');\n};\n/**\n * @param {MfsContext} context\n * @param {MfsPath} source\n * @param {string} destination\n * @param {MfsTrail[]} destinationTrail\n * @param {DefaultOptions} options\n */\n\n\nvar copyToFile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(context, source, destination, destinationTrail, options) {\n    var parent, newRootCid;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            parent = destinationTrail.pop();\n\n            if (parent) {\n              _context2.next = 3;\n              break;\n            }\n\n            throw errCode(new Error('destination had no parent'), 'ERR_INVALID_PARAMS');\n\n          case 3:\n            _context2.next = 5;\n            return addSourceToParent(context, source, destination, parent, options);\n\n          case 5:\n            parent = _context2.sent;\n            // update the tree with the new containing directory\n            destinationTrail.push(parent);\n            _context2.next = 9;\n            return updateTree(context, destinationTrail, options);\n\n          case 9:\n            newRootCid = _context2.sent;\n            _context2.next = 12;\n            return updateMfsRoot(context, newRootCid, options);\n\n          case 12:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function copyToFile(_x3, _x4, _x5, _x6, _x7) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {MfsPath[]} sources\n * @param {*} destination\n * @param {MfsTrail[]} destinationTrail\n * @param {DefaultOptions} options\n */\n\n\nvar copyToDirectory = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(context, sources, destination, destinationTrail, options) {\n    var i, source, newRootCid;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < sources.length)) {\n              _context3.next = 9;\n              break;\n            }\n\n            source = sources[i];\n            _context3.next = 5;\n            return addSourceToParent(context, source, source.name, destination, options);\n\n          case 5:\n            destination = _context3.sent;\n\n          case 6:\n            i++;\n            _context3.next = 1;\n            break;\n\n          case 9:\n            // update the tree with the new containing directory\n            destinationTrail[destinationTrail.length - 1] = destination;\n            _context3.next = 12;\n            return updateTree(context, destinationTrail, options);\n\n          case 12:\n            newRootCid = _context3.sent;\n            _context3.next = 15;\n            return updateMfsRoot(context, newRootCid, options);\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function copyToDirectory(_x8, _x9, _x10, _x11, _x12) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {MfsPath} source\n * @param {string} childName\n * @param {*} parent\n * @param {DefaultOptions} options\n * @returns {Promise<MfsTrail>}\n */\n\n\nvar addSourceToParent = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(context, source, childName, parent, options) {\n    var sourceBlock, _yield$addLink, node, cid, size;\n\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return context.repo.blocks.get(source.cid);\n\n          case 2:\n            sourceBlock = _context4.sent;\n            _context4.next = 5;\n            return addLink(context, {\n              parentCid: parent.cid,\n              size: sourceBlock.length,\n              cid: source.cid,\n              name: childName,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion,\n              flush: options.flush,\n              shardSplitThreshold: options.shardSplitThreshold\n            });\n\n          case 5:\n            _yield$addLink = _context4.sent;\n            node = _yield$addLink.node;\n            cid = _yield$addLink.cid;\n            size = _yield$addLink.size;\n            parent.node = node;\n            parent.cid = cid;\n            parent.size = size;\n            return _context4.abrupt(\"return\", parent);\n\n          case 13:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function addSourceToParent(_x13, _x14, _x15, _x16, _x17) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["mkdir","require","stat","log","errCode","updateTree","updateMfsRoot","addLink","toMfsPath","mergeOptions","bind","ignoreUndefined","toTrail","withTimeoutOption","defaultOptions","parents","flush","hashAlg","cidVersion","shardSplitThreshold","module","exports","context","mfsCp","from","to","opts","options","Array","isArray","Promise","all","map","path","sources","destination","length","Error","missing","find","source","exists","destinationIsDirectory","isDirectory","parts","parentFolder","slice","join","code","destinationPath","mfsPath","mfsDirectory","trail","pop","destinationName","name","copyToFile","copyToDirectory","unixfs","type","includes","destinationTrail","parent","addSourceToParent","push","newRootCid","i","childName","repo","blocks","get","cid","sourceBlock","parentCid","size","node"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/cp.js"],"sourcesContent":["'use strict'\n\nconst mkdir = require('./mkdir')\nconst stat = require('./stat')\nconst log = require('debug')('ipfs:mfs:cp')\nconst errCode = require('err-code')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst addLink = require('./utils/add-link')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst toTrail = require('./utils/to-trail')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} DAGNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').Mtime} Mtime\n * @typedef {import('./utils/to-mfs-path').MfsPath} MfsPath\n * @typedef {import('./utils/to-trail').MfsTrail} MfsTrail\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  parents: false,\n  flush: true,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"cp\"]}\n   */\n  async function mfsCp (from, to, opts = {}) {\n    /** @type {DefaultOptions} */\n    const options = mergeOptions(defaultOptions, opts)\n\n    if (!Array.isArray(from)) {\n      from = [from]\n    }\n\n    const sources = await Promise.all(\n      from.map((/** @type {CID | string} */ path) => toMfsPath(context, path, options))\n    )\n    let destination = await toMfsPath(context, to, options)\n\n    if (!sources.length || !destination) {\n      throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS')\n    }\n\n    // make sure all sources exist\n    const missing = sources.find(source => !source.exists)\n\n    if (missing) {\n      throw errCode(new Error(`${missing.path} does not exist`), 'ERR_INVALID_PARAMS')\n    }\n\n    const destinationIsDirectory = isDirectory(destination)\n\n    if (destination.exists) {\n      log('Destination exists')\n\n      // @ts-ignore ts seems to think `sources` will always have a length of 10\n      if (sources.length === 1 && !destinationIsDirectory) {\n        throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS')\n      }\n    } else {\n      log('Destination does not exist')\n\n      if (sources.length > 1) {\n        // copying multiple files to one location, destination will be a directory\n        if (!options.parents) {\n          throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS')\n        }\n\n        await mkdir(context)(destination.path, options)\n        destination = await toMfsPath(context, destination.path, options)\n      } else if (destination.parts.length > 1) {\n        // copying to a folder, create it if necessary\n        const parentFolder = `/${destination.parts.slice(0, -1).join('/')}`\n\n        try {\n          await stat(context)(parentFolder, options)\n        } catch (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err\n          }\n\n          if (!options.parents) {\n            throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS')\n          }\n\n          await mkdir(context)(parentFolder, options)\n          destination = await toMfsPath(context, destination.path, options)\n        }\n      }\n    }\n\n    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory\n    const trail = await toTrail(context, destinationPath)\n\n    // @ts-ignore ts seems to think `sources` will always have a length of 10\n    if (sources.length === 1) {\n      const source = sources.pop()\n\n      if (!source) {\n        throw errCode(new Error('could not find source'), 'ERR_INVALID_PARAMS')\n      }\n\n      const destinationName = destinationIsDirectory ? source.name : destination.name\n\n      log(`Only one source, copying to destination ${destinationIsDirectory ? 'directory' : 'file'} ${destinationName}`)\n\n      return copyToFile(context, source, destinationName, trail, options)\n    }\n\n    log('Multiple sources, wrapping in a directory')\n    return copyToDirectory(context, sources, destination, trail, options)\n  }\n\n  return withTimeoutOption(mfsCp)\n}\n\n/**\n * @param {*} destination\n */\nconst isDirectory = (destination) => {\n  return destination.unixfs &&\n    destination.unixfs.type &&\n    destination.unixfs.type.includes('directory')\n}\n\n/**\n * @param {MfsContext} context\n * @param {MfsPath} source\n * @param {string} destination\n * @param {MfsTrail[]} destinationTrail\n * @param {DefaultOptions} options\n */\nconst copyToFile = async (context, source, destination, destinationTrail, options) => {\n  let parent = destinationTrail.pop()\n\n  if (!parent) {\n    throw errCode(new Error('destination had no parent'), 'ERR_INVALID_PARAMS')\n  }\n\n  parent = await addSourceToParent(context, source, destination, parent, options)\n\n  // update the tree with the new containing directory\n  destinationTrail.push(parent)\n\n  const newRootCid = await updateTree(context, destinationTrail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {MfsPath[]} sources\n * @param {*} destination\n * @param {MfsTrail[]} destinationTrail\n * @param {DefaultOptions} options\n */\nconst copyToDirectory = async (context, sources, destination, destinationTrail, options) => {\n  // copy all the sources to the destination\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i]\n\n    destination = await addSourceToParent(context, source, source.name, destination, options)\n  }\n\n  // update the tree with the new containing directory\n  destinationTrail[destinationTrail.length - 1] = destination\n\n  const newRootCid = await updateTree(context, destinationTrail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {MfsPath} source\n * @param {string} childName\n * @param {*} parent\n * @param {DefaultOptions} options\n * @returns {Promise<MfsTrail>}\n */\nconst addSourceToParent = async (context, source, childName, parent, options) => {\n  const sourceBlock = await context.repo.blocks.get(source.cid)\n  const {\n    node,\n    cid,\n    size\n  } = await addLink(context, {\n    parentCid: parent.cid,\n    size: sourceBlock.length,\n    cid: source.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  })\n\n  parent.node = node\n  parent.cid = cid\n  parent.size = size\n\n  return parent\n}\n"],"mappings":"AAAA;;;;;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAArB;;AACA,IAAMC,IAAI,GAAGD,OAAO,CAAC,QAAD,CAApB;;AACA,IAAME,GAAG,GAAGF,OAAO,CAAC,OAAD,CAAP,CAAiB,aAAjB,CAAZ;;AACA,IAAMG,OAAO,GAAGH,OAAO,CAAC,UAAD,CAAvB;;AACA,IAAMI,UAAU,GAAGJ,OAAO,CAAC,qBAAD,CAA1B;;AACA,IAAMK,aAAa,GAAGL,OAAO,CAAC,yBAAD,CAA7B;;AACA,IAAMM,OAAO,GAAGN,OAAO,CAAC,kBAAD,CAAvB;;AACA,IAAMO,SAAS,GAAGP,OAAO,CAAC,qBAAD,CAAzB;;AACA,IAAMQ,YAAY,GAAGR,OAAO,CAAC,eAAD,CAAP,CAAyBS,IAAzB,CAA8B;EAAEC,eAAe,EAAE;AAAnB,CAA9B,CAArB;;AACA,IAAMC,OAAO,GAAGX,OAAO,CAAC,kBAAD,CAAvB;;AACA,IAAMY,iBAAiB,GAAGZ,OAAO,CAAC,yCAAD,CAAjC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,IAAMa,cAAc,GAAG;EACrBC,OAAO,EAAE,KADY;EAErBC,KAAK,EAAE,IAFc;EAGrBC,OAAO,EAAE,UAHY;EAIrBC,UAAU,EAAE,CAJS;EAKrBC,mBAAmB,EAAE;AALA,CAAvB;AAQA;AACA;AACA;;AACAC,MAAM,CAACC,OAAP,GAAiB,UAACC,OAAD,EAAa;EAC5B;AACF;AACA;EAH8B,SAIbC,KAJa;IAAA;EAAA;;EAAA;IAAA,oEAI5B,iBAAsBC,IAAtB,EAA4BC,EAA5B;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;QAAA;UAAA;YAAA;cAAgCC,IAAhC,2DAAuC,EAAvC;;cACE;cACMC,OAFR,GAEkBlB,YAAY,CAACK,cAAD,EAAiBY,IAAjB,CAF9B;;cAIE,IAAI,CAACE,KAAK,CAACC,OAAN,CAAcL,IAAd,CAAL,EAA0B;gBACxBA,IAAI,GAAG,CAACA,IAAD,CAAP;cACD;;cANH;cAAA,OAQwBM,OAAO,CAACC,GAAR,CACpBP,IAAI,CAACQ,GAAL,CAAS;cAAC;cAA4BC,IAA7B;gBAAA,OAAsCzB,SAAS,CAACc,OAAD,EAAUW,IAAV,EAAgBN,OAAhB,CAA/C;cAAA,CAAT,CADoB,CARxB;;YAAA;cAQQO,OARR;cAAA;cAAA,OAW0B1B,SAAS,CAACc,OAAD,EAAUG,EAAV,EAAcE,OAAd,CAXnC;;YAAA;cAWMQ,WAXN;;cAAA,MAaM,CAACD,OAAO,CAACE,MAAT,IAAmB,CAACD,WAb1B;gBAAA;gBAAA;cAAA;;cAAA,MAcU/B,OAAO,CAAC,IAAIiC,KAAJ,CAAU,mCAAV,CAAD,EAAiD,oBAAjD,CAdjB;;YAAA;cAiBE;cACMC,OAlBR,GAkBkBJ,OAAO,CAACK,IAAR,CAAa,UAAAC,MAAM;gBAAA,OAAI,CAACA,MAAM,CAACC,MAAZ;cAAA,CAAnB,CAlBlB;;cAAA,KAoBMH,OApBN;gBAAA;gBAAA;cAAA;;cAAA,MAqBUlC,OAAO,CAAC,IAAIiC,KAAJ,WAAaC,OAAO,CAACL,IAArB,qBAAD,EAA8C,oBAA9C,CArBjB;;YAAA;cAwBQS,sBAxBR,GAwBiCC,WAAW,CAACR,WAAD,CAxB5C;;cAAA,KA0BMA,WAAW,CAACM,MA1BlB;gBAAA;gBAAA;cAAA;;cA2BItC,GAAG,CAAC,oBAAD,CAAH,CA3BJ,CA6BI;;cA7BJ,MA8BQ+B,OAAO,CAACE,MAAR,KAAmB,CAAnB,IAAwB,CAACM,sBA9BjC;gBAAA;gBAAA;cAAA;;cAAA,MA+BYtC,OAAO,CAAC,IAAIiC,KAAJ,CAAU,0CAAV,CAAD,EAAwD,oBAAxD,CA/BnB;;YAAA;cAAA;cAAA;;YAAA;cAkCIlC,GAAG,CAAC,4BAAD,CAAH;;cAlCJ,MAoCQ+B,OAAO,CAACE,MAAR,GAAiB,CApCzB;gBAAA;gBAAA;cAAA;;cAAA,IAsCWT,OAAO,CAACZ,OAtCnB;gBAAA;gBAAA;cAAA;;cAAA,MAuCcX,OAAO,CAAC,IAAIiC,KAAJ,CAAU,uEAAV,CAAD,EAAqF,oBAArF,CAvCrB;;YAAA;cAAA;cAAA,OA0CYrC,KAAK,CAACsB,OAAD,CAAL,CAAea,WAAW,CAACF,IAA3B,EAAiCN,OAAjC,CA1CZ;;YAAA;cAAA;cAAA,OA2C0BnB,SAAS,CAACc,OAAD,EAAUa,WAAW,CAACF,IAAtB,EAA4BN,OAA5B,CA3CnC;;YAAA;cA2CMQ,WA3CN;cAAA;cAAA;;YAAA;cAAA,MA4CeA,WAAW,CAACS,KAAZ,CAAkBR,MAAlB,GAA2B,CA5C1C;gBAAA;gBAAA;cAAA;;cA6CM;cACMS,YA9CZ,cA8C+BV,WAAW,CAACS,KAAZ,CAAkBE,KAAlB,CAAwB,CAAxB,EAA2B,CAAC,CAA5B,EAA+BC,IAA/B,CAAoC,GAApC,CA9C/B;cAAA;cAAA;cAAA,OAiDc7C,IAAI,CAACoB,OAAD,CAAJ,CAAcuB,YAAd,EAA4BlB,OAA5B,CAjDd;;YAAA;cAAA;cAAA;;YAAA;cAAA;cAAA;;cAAA,MAmDY,YAAIqB,IAAJ,KAAa,eAnDzB;gBAAA;gBAAA;cAAA;;cAAA;;YAAA;cAAA,IAuDarB,OAAO,CAACZ,OAvDrB;gBAAA;gBAAA;cAAA;;cAAA,MAwDgBX,OAAO,CAAC,IAAIiC,KAAJ,CAAU,uEAAV,CAAD,EAAqF,oBAArF,CAxDvB;;YAAA;cAAA;cAAA,OA2DcrC,KAAK,CAACsB,OAAD,CAAL,CAAeuB,YAAf,EAA6BlB,OAA7B,CA3Dd;;YAAA;cAAA;cAAA,OA4D4BnB,SAAS,CAACc,OAAD,EAAUa,WAAW,CAACF,IAAtB,EAA4BN,OAA5B,CA5DrC;;YAAA;cA4DQQ,WA5DR;;YAAA;cAiEQc,eAjER,GAiE0BN,WAAW,CAACR,WAAD,CAAX,GAA2BA,WAAW,CAACe,OAAvC,GAAiDf,WAAW,CAACgB,YAjEvF;cAAA;cAAA,OAkEsBvC,OAAO,CAACU,OAAD,EAAU2B,eAAV,CAlE7B;;YAAA;cAkEQG,KAlER;;cAAA,MAqEMlB,OAAO,CAACE,MAAR,KAAmB,CArEzB;gBAAA;gBAAA;cAAA;;cAsEUI,MAtEV,GAsEmBN,OAAO,CAACmB,GAAR,EAtEnB;;cAAA,IAwESb,MAxET;gBAAA;gBAAA;cAAA;;cAAA,MAyEYpC,OAAO,CAAC,IAAIiC,KAAJ,CAAU,uBAAV,CAAD,EAAqC,oBAArC,CAzEnB;;YAAA;cA4EUiB,eA5EV,GA4E4BZ,sBAAsB,GAAGF,MAAM,CAACe,IAAV,GAAiBpB,WAAW,CAACoB,IA5E/E;cA8EIpD,GAAG,mDAA4CuC,sBAAsB,GAAG,WAAH,GAAiB,MAAnF,cAA6FY,eAA7F,EAAH;cA9EJ,iCAgFWE,UAAU,CAAClC,OAAD,EAAUkB,MAAV,EAAkBc,eAAlB,EAAmCF,KAAnC,EAA0CzB,OAA1C,CAhFrB;;YAAA;cAmFExB,GAAG,CAAC,2CAAD,CAAH;cAnFF,iCAoFSsD,eAAe,CAACnC,OAAD,EAAUY,OAAV,EAAmBC,WAAnB,EAAgCiB,KAAhC,EAAuCzB,OAAvC,CApFxB;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAJ4B;IAAA;EAAA;;EA2F5B,OAAOd,iBAAiB,CAACU,KAAD,CAAxB;AACD,CA5FD;AA8FA;AACA;AACA;;;AACA,IAAMoB,WAAW,GAAG,SAAdA,WAAc,CAACR,WAAD,EAAiB;EACnC,OAAOA,WAAW,CAACuB,MAAZ,IACLvB,WAAW,CAACuB,MAAZ,CAAmBC,IADd,IAELxB,WAAW,CAACuB,MAAZ,CAAmBC,IAAnB,CAAwBC,QAAxB,CAAiC,WAAjC,CAFF;AAGD,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMJ,UAAU;EAAA,sEAAG,kBAAOlC,OAAP,EAAgBkB,MAAhB,EAAwBL,WAAxB,EAAqC0B,gBAArC,EAAuDlC,OAAvD;IAAA;IAAA;MAAA;QAAA;UAAA;YACbmC,MADa,GACJD,gBAAgB,CAACR,GAAjB,EADI;;YAAA,IAGZS,MAHY;cAAA;cAAA;YAAA;;YAAA,MAIT1D,OAAO,CAAC,IAAIiC,KAAJ,CAAU,2BAAV,CAAD,EAAyC,oBAAzC,CAJE;;UAAA;YAAA;YAAA,OAOF0B,iBAAiB,CAACzC,OAAD,EAAUkB,MAAV,EAAkBL,WAAlB,EAA+B2B,MAA/B,EAAuCnC,OAAvC,CAPf;;UAAA;YAOjBmC,MAPiB;YASjB;YACAD,gBAAgB,CAACG,IAAjB,CAAsBF,MAAtB;YAViB;YAAA,OAYQzD,UAAU,CAACiB,OAAD,EAAUuC,gBAAV,EAA4BlC,OAA5B,CAZlB;;UAAA;YAYXsC,UAZW;YAAA;YAAA,OAeX3D,aAAa,CAACgB,OAAD,EAAU2C,UAAV,EAAsBtC,OAAtB,CAfF;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAAH;;EAAA,gBAAV6B,UAAU;IAAA;EAAA;AAAA,GAAhB;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,eAAe;EAAA,uEAAG,kBAAOnC,OAAP,EAAgBY,OAAhB,EAAyBC,WAAzB,EAAsC0B,gBAAtC,EAAwDlC,OAAxD;IAAA;IAAA;MAAA;QAAA;UAAA;YAEbuC,CAFa,GAET,CAFS;;UAAA;YAAA,MAENA,CAAC,GAAGhC,OAAO,CAACE,MAFN;cAAA;cAAA;YAAA;;YAGdI,MAHc,GAGLN,OAAO,CAACgC,CAAD,CAHF;YAAA;YAAA,OAKAH,iBAAiB,CAACzC,OAAD,EAAUkB,MAAV,EAAkBA,MAAM,CAACe,IAAzB,EAA+BpB,WAA/B,EAA4CR,OAA5C,CALjB;;UAAA;YAKpBQ,WALoB;;UAAA;YAEc+B,CAAC,EAFf;YAAA;YAAA;;UAAA;YAQtB;YACAL,gBAAgB,CAACA,gBAAgB,CAACzB,MAAjB,GAA0B,CAA3B,CAAhB,GAAgDD,WAAhD;YATsB;YAAA,OAWG9B,UAAU,CAACiB,OAAD,EAAUuC,gBAAV,EAA4BlC,OAA5B,CAXb;;UAAA;YAWhBsC,UAXgB;YAAA;YAAA,OAchB3D,aAAa,CAACgB,OAAD,EAAU2C,UAAV,EAAsBtC,OAAtB,CAdG;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAAH;;EAAA,gBAAf8B,eAAe;IAAA;EAAA;AAAA,GAArB;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMM,iBAAiB;EAAA,uEAAG,kBAAOzC,OAAP,EAAgBkB,MAAhB,EAAwB2B,SAAxB,EAAmCL,MAAnC,EAA2CnC,OAA3C;IAAA;;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA,OACEL,OAAO,CAAC8C,IAAR,CAAaC,MAAb,CAAoBC,GAApB,CAAwB9B,MAAM,CAAC+B,GAA/B,CADF;;UAAA;YAClBC,WADkB;YAAA;YAAA,OAMdjE,OAAO,CAACe,OAAD,EAAU;cACzBmD,SAAS,EAAEX,MAAM,CAACS,GADO;cAEzBG,IAAI,EAAEF,WAAW,CAACpC,MAFO;cAGzBmC,GAAG,EAAE/B,MAAM,CAAC+B,GAHa;cAIzBhB,IAAI,EAAEY,SAJmB;cAKzBlD,OAAO,EAAEU,OAAO,CAACV,OALQ;cAMzBC,UAAU,EAAES,OAAO,CAACT,UANK;cAOzBF,KAAK,EAAEW,OAAO,CAACX,KAPU;cAQzBG,mBAAmB,EAAEQ,OAAO,CAACR;YARJ,CAAV,CANO;;UAAA;YAAA;YAGtBwD,IAHsB,kBAGtBA,IAHsB;YAItBJ,GAJsB,kBAItBA,GAJsB;YAKtBG,IALsB,kBAKtBA,IALsB;YAiBxBZ,MAAM,CAACa,IAAP,GAAcA,IAAd;YACAb,MAAM,CAACS,GAAP,GAAaA,GAAb;YACAT,MAAM,CAACY,IAAP,GAAcA,IAAd;YAnBwB,kCAqBjBZ,MArBiB;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAAH;;EAAA,gBAAjBC,iBAAiB;IAAA;EAAA;AAAA,GAAvB"},"metadata":{},"sourceType":"script"}