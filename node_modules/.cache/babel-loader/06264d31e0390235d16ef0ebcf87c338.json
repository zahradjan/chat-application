{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('libp2p:auto-relay'), {\n  error: debug('libp2p:auto-relay:err')\n});\n\nvar _require = require('uint8arrays/from-string'),\n    uint8ArrayFromString = _require.fromString;\n\nvar _require2 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require2.toString;\n\nvar _require3 = require('multiaddr'),\n    Multiaddr = _require3.Multiaddr;\n\nvar PeerId = require('peer-id');\n\nvar _require4 = require('./multicodec'),\n    multicodec = _require4.relay;\n\nvar _require5 = require('./circuit/hop'),\n    canHop = _require5.canHop;\n\nvar _require6 = require('./utils'),\n    namespaceToCid = _require6.namespaceToCid;\n\nvar _require7 = require('./constants'),\n    CIRCUIT_PROTO_CODE = _require7.CIRCUIT_PROTO_CODE,\n    HOP_METADATA_KEY = _require7.HOP_METADATA_KEY,\n    HOP_METADATA_VALUE = _require7.HOP_METADATA_VALUE,\n    RELAY_RENDEZVOUS_NS = _require7.RELAY_RENDEZVOUS_NS;\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('../peer-store/address-book').Address} Address\n */\n\n/**\n * @typedef {Object} AutoRelayProperties\n * @property {import('../')} libp2p\n *\n * @typedef {Object} AutoRelayOptions\n * @property {number} [maxListeners = 1] - maximum number of relays to listen.\n * @property {(error: Error, msg?: string) => {}} [onError]\n */\n\n\nvar AutoRelay = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of AutoRelay.\n   *\n   * @class\n   * @param {AutoRelayProperties & AutoRelayOptions} props\n   */\n  function AutoRelay(_ref) {\n    var libp2p = _ref.libp2p,\n        _ref$maxListeners = _ref.maxListeners,\n        maxListeners = _ref$maxListeners === void 0 ? 1 : _ref$maxListeners,\n        onError = _ref.onError;\n\n    _classCallCheck(this, AutoRelay);\n\n    this._libp2p = libp2p;\n    this._peerId = libp2p.peerId;\n    this._peerStore = libp2p.peerStore;\n    this._connectionManager = libp2p.connectionManager;\n    this._transportManager = libp2p.transportManager;\n    this._addressSorter = libp2p.dialer.addressSorter;\n    this.maxListeners = maxListeners;\n    /**\n     * @type {Set<string>}\n     */\n\n    this._listenRelays = new Set();\n    this._onProtocolChange = this._onProtocolChange.bind(this);\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);\n\n    this._peerStore.on('change:protocols', this._onProtocolChange);\n\n    this._connectionManager.on('peer:disconnect', this._onPeerDisconnected);\n    /**\n     * @param {Error} error\n     * @param {string} [msg]\n     */\n\n\n    this._onError = function (error, msg) {\n      log.error(msg || error);\n      onError && onError(error, msg);\n    };\n  }\n  /**\n   * Check if a peer supports the relay protocol.\n   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.\n   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if\n   * inside the threshold.\n   *\n   * @param {Object} props\n   * @param {PeerId} props.peerId\n   * @param {string[]} props.protocols\n   * @returns {Promise<void>}\n   */\n\n\n  _createClass(AutoRelay, [{\n    key: \"_onProtocolChange\",\n    value: function () {\n      var _onProtocolChange2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2) {\n        var peerId, protocols, id, hasProtocol, connection, supportsHop;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                peerId = _ref2.peerId, protocols = _ref2.protocols;\n                id = peerId.toB58String(); // Check if it has the protocol\n\n                hasProtocol = protocols.find(function (protocol) {\n                  return protocol === multicodec;\n                }); // If no protocol, check if we were keeping the peer before as a listenRelay\n\n                if (!(!hasProtocol && this._listenRelays.has(id))) {\n                  _context.next = 8;\n                  break;\n                }\n\n                this._removeListenRelay(id);\n\n                return _context.abrupt(\"return\");\n\n              case 8:\n                if (!(!hasProtocol || this._listenRelays.has(id))) {\n                  _context.next = 10;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 10:\n                _context.prev = 10;\n                connection = this._connectionManager.get(peerId);\n\n                if (connection) {\n                  _context.next = 14;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 14:\n                if (!connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {\n                  _context.next = 17;\n                  break;\n                }\n\n                log(\"relayed connection to \".concat(id, \" will not be used to hop on\"));\n                return _context.abrupt(\"return\");\n\n              case 17:\n                _context.next = 19;\n                return canHop({\n                  connection: connection\n                });\n\n              case 19:\n                supportsHop = _context.sent;\n\n                if (!supportsHop) {\n                  _context.next = 24;\n                  break;\n                }\n\n                this._peerStore.metadataBook.set(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE));\n\n                _context.next = 24;\n                return this._addListenRelay(connection, id);\n\n              case 24:\n                _context.next = 29;\n                break;\n\n              case 26:\n                _context.prev = 26;\n                _context.t0 = _context[\"catch\"](10);\n\n                this._onError(_context.t0);\n\n              case 29:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[10, 26]]);\n      }));\n\n      function _onProtocolChange(_x) {\n        return _onProtocolChange2.apply(this, arguments);\n      }\n\n      return _onProtocolChange;\n    }()\n    /**\n     * Peer disconnects.\n     *\n     * @param {Connection} connection - connection to the peer\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onPeerDisconnected\",\n    value: function _onPeerDisconnected(connection) {\n      var peerId = connection.remotePeer;\n      var id = peerId.toB58String(); // Not listening on this relay\n\n      if (!this._listenRelays.has(id)) {\n        return;\n      }\n\n      this._removeListenRelay(id);\n    }\n    /**\n     * Attempt to listen on the given relay connection.\n     *\n     * @private\n     * @param {Connection} connection - connection to the peer\n     * @param {string} id - peer identifier string\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_addListenRelay\",\n    value: function () {\n      var _addListenRelay2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(connection, id) {\n        var remoteAddrs, listenAddr;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this._listenRelays.size >= this.maxListeners)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                // Get peer known addresses and sort them per public addresses first\n                remoteAddrs = this._peerStore.addressBook.getMultiaddrsForPeer(connection.remotePeer, this._addressSorter);\n\n                if (!(!remoteAddrs || !remoteAddrs.length)) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 5:\n                listenAddr = \"\".concat(remoteAddrs[0].toString(), \"/p2p-circuit\");\n\n                this._listenRelays.add(id); // Attempt to listen on relay\n\n\n                _context2.prev = 7;\n                _context2.next = 10;\n                return this._transportManager.listen([new Multiaddr(listenAddr)]);\n\n              case 10:\n                _context2.next = 16;\n                break;\n\n              case 12:\n                _context2.prev = 12;\n                _context2.t0 = _context2[\"catch\"](7);\n\n                this._onError(_context2.t0);\n\n                this._listenRelays.delete(id);\n\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[7, 12]]);\n      }));\n\n      function _addListenRelay(_x2, _x3) {\n        return _addListenRelay2.apply(this, arguments);\n      }\n\n      return _addListenRelay;\n    }()\n    /**\n     * Remove listen relay.\n     *\n     * @private\n     * @param {string} id - peer identifier string.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_removeListenRelay\",\n    value: function _removeListenRelay(id) {\n      if (this._listenRelays.delete(id)) {\n        // TODO: this should be responsibility of the connMgr\n        this._listenOnAvailableHopRelays([id]);\n      }\n    }\n    /**\n     * Try to listen on available hop relay connections.\n     * The following order will happen while we do not have enough relays.\n     * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.\n     * 2. Dial and try to listen on the peers we know that support hop but are not connected.\n     * 3. Search the network.\n     *\n     * @param {string[]} [peersToIgnore]\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_listenOnAvailableHopRelays\",\n    value: function () {\n      var _listenOnAvailableHopRelays2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var peersToIgnore,\n            knownHopsToDial,\n            _iterator2,\n            _step2,\n            _step2$value,\n            id,\n            metadataMap,\n            supportsHop,\n            _peerId2,\n            connection,\n            _i,\n            _knownHopsToDial,\n            peerId,\n            cid,\n            _iteratorAbruptCompletion,\n            _didIteratorError,\n            _iteratorError,\n            _iterator,\n            _step,\n            provider,\n            _peerId,\n            _args3 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                peersToIgnore = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : [];\n\n                if (!(this._listenRelays.size >= this.maxListeners)) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 3:\n                knownHopsToDial = []; // Check if we have known hop peers to use and attempt to listen on the already connected\n\n                _iterator2 = _createForOfIteratorHelper(this._peerStore.metadataBook.data.entries());\n                _context3.prev = 5;\n\n                _iterator2.s();\n\n              case 7:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                _step2$value = _slicedToArray(_step2.value, 2), id = _step2$value[0], metadataMap = _step2$value[1];\n\n                if (!(this._listenRelays.has(id) || peersToIgnore.includes(id))) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                return _context3.abrupt(\"continue\", 23);\n\n              case 11:\n                supportsHop = metadataMap.get(HOP_METADATA_KEY); // Continue to next if it does not support Hop\n\n                if (!(!supportsHop || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE)) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                return _context3.abrupt(\"continue\", 23);\n\n              case 14:\n                _peerId2 = PeerId.createFromB58String(id);\n                connection = this._connectionManager.get(_peerId2); // If not connected, store for possible later use.\n\n                if (connection) {\n                  _context3.next = 19;\n                  break;\n                }\n\n                knownHopsToDial.push(_peerId2);\n                return _context3.abrupt(\"continue\", 23);\n\n              case 19:\n                _context3.next = 21;\n                return this._addListenRelay(connection, id);\n\n              case 21:\n                if (!(this._listenRelays.size >= this.maxListeners)) {\n                  _context3.next = 23;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 23:\n                _context3.next = 7;\n                break;\n\n              case 25:\n                _context3.next = 30;\n                break;\n\n              case 27:\n                _context3.prev = 27;\n                _context3.t0 = _context3[\"catch\"](5);\n\n                _iterator2.e(_context3.t0);\n\n              case 30:\n                _context3.prev = 30;\n\n                _iterator2.f();\n\n                return _context3.finish(30);\n\n              case 33:\n                _i = 0, _knownHopsToDial = knownHopsToDial;\n\n              case 34:\n                if (!(_i < _knownHopsToDial.length)) {\n                  _context3.next = 43;\n                  break;\n                }\n\n                peerId = _knownHopsToDial[_i];\n                _context3.next = 38;\n                return this._tryToListenOnRelay(peerId);\n\n              case 38:\n                if (!(this._listenRelays.size >= this.maxListeners)) {\n                  _context3.next = 40;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 40:\n                _i++;\n                _context3.next = 34;\n                break;\n\n              case 43:\n                _context3.prev = 43;\n                _context3.next = 46;\n                return namespaceToCid(RELAY_RENDEZVOUS_NS);\n\n              case 46:\n                cid = _context3.sent;\n                _iteratorAbruptCompletion = false;\n                _didIteratorError = false;\n                _context3.prev = 49;\n                _iterator = _asyncIterator(this._libp2p.contentRouting.findProviders(cid));\n\n              case 51:\n                _context3.next = 53;\n                return _iterator.next();\n\n              case 53:\n                if (!(_iteratorAbruptCompletion = !(_step = _context3.sent).done)) {\n                  _context3.next = 66;\n                  break;\n                }\n\n                provider = _step.value;\n\n                if (provider.multiaddrs.length) {\n                  _context3.next = 57;\n                  break;\n                }\n\n                return _context3.abrupt(\"continue\", 63);\n\n              case 57:\n                _peerId = provider.id;\n\n                this._peerStore.addressBook.add(_peerId, provider.multiaddrs);\n\n                _context3.next = 61;\n                return this._tryToListenOnRelay(_peerId);\n\n              case 61:\n                if (!(this._listenRelays.size >= this.maxListeners)) {\n                  _context3.next = 63;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 63:\n                _iteratorAbruptCompletion = false;\n                _context3.next = 51;\n                break;\n\n              case 66:\n                _context3.next = 72;\n                break;\n\n              case 68:\n                _context3.prev = 68;\n                _context3.t1 = _context3[\"catch\"](49);\n                _didIteratorError = true;\n                _iteratorError = _context3.t1;\n\n              case 72:\n                _context3.prev = 72;\n                _context3.prev = 73;\n\n                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                  _context3.next = 77;\n                  break;\n                }\n\n                _context3.next = 77;\n                return _iterator.return();\n\n              case 77:\n                _context3.prev = 77;\n\n                if (!_didIteratorError) {\n                  _context3.next = 80;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 80:\n                return _context3.finish(77);\n\n              case 81:\n                return _context3.finish(72);\n\n              case 82:\n                _context3.next = 87;\n                break;\n\n              case 84:\n                _context3.prev = 84;\n                _context3.t2 = _context3[\"catch\"](43);\n\n                this._onError(_context3.t2);\n\n              case 87:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[5, 27, 30, 33], [43, 84], [49, 68, 72, 82], [73,, 77, 81]]);\n      }));\n\n      function _listenOnAvailableHopRelays() {\n        return _listenOnAvailableHopRelays2.apply(this, arguments);\n      }\n\n      return _listenOnAvailableHopRelays;\n    }()\n    /**\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"_tryToListenOnRelay\",\n    value: function () {\n      var _tryToListenOnRelay2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(peerId) {\n        var connection;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                _context4.next = 3;\n                return this._libp2p.dial(peerId);\n\n              case 3:\n                connection = _context4.sent;\n                _context4.next = 6;\n                return this._addListenRelay(connection, peerId.toB58String());\n\n              case 6:\n                _context4.next = 11;\n                break;\n\n              case 8:\n                _context4.prev = 8;\n                _context4.t0 = _context4[\"catch\"](0);\n\n                this._onError(_context4.t0, \"could not connect and listen on known hop relay \".concat(peerId.toB58String()));\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 8]]);\n      }));\n\n      function _tryToListenOnRelay(_x4) {\n        return _tryToListenOnRelay2.apply(this, arguments);\n      }\n\n      return _tryToListenOnRelay;\n    }()\n  }]);\n\n  return AutoRelay;\n}();\n\nmodule.exports = AutoRelay;","map":{"version":3,"names":["debug","require","log","Object","assign","error","uint8ArrayFromString","fromString","uint8ArrayToString","toString","Multiaddr","PeerId","multicodec","relay","canHop","namespaceToCid","CIRCUIT_PROTO_CODE","HOP_METADATA_KEY","HOP_METADATA_VALUE","RELAY_RENDEZVOUS_NS","AutoRelay","libp2p","maxListeners","onError","_libp2p","_peerId","peerId","_peerStore","peerStore","_connectionManager","connectionManager","_transportManager","transportManager","_addressSorter","dialer","addressSorter","_listenRelays","Set","_onProtocolChange","bind","_onPeerDisconnected","on","_onError","msg","protocols","id","toB58String","hasProtocol","find","protocol","has","_removeListenRelay","connection","get","remoteAddr","protoCodes","includes","supportsHop","metadataBook","set","_addListenRelay","remotePeer","size","remoteAddrs","addressBook","getMultiaddrsForPeer","length","listenAddr","add","listen","delete","_listenOnAvailableHopRelays","peersToIgnore","knownHopsToDial","data","entries","metadataMap","createFromB58String","push","_tryToListenOnRelay","cid","contentRouting","findProviders","provider","multiaddrs","dial","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/circuit/auto-relay.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:auto-relay'), {\n  error: debug('libp2p:auto-relay:err')\n})\n\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { Multiaddr } = require('multiaddr')\nconst PeerId = require('peer-id')\n\nconst { relay: multicodec } = require('./multicodec')\nconst { canHop } = require('./circuit/hop')\nconst { namespaceToCid } = require('./utils')\nconst {\n  CIRCUIT_PROTO_CODE,\n  HOP_METADATA_KEY,\n  HOP_METADATA_VALUE,\n  RELAY_RENDEZVOUS_NS\n} = require('./constants')\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('../peer-store/address-book').Address} Address\n */\n\n/**\n * @typedef {Object} AutoRelayProperties\n * @property {import('../')} libp2p\n *\n * @typedef {Object} AutoRelayOptions\n * @property {number} [maxListeners = 1] - maximum number of relays to listen.\n * @property {(error: Error, msg?: string) => {}} [onError]\n */\n\nclass AutoRelay {\n  /**\n   * Creates an instance of AutoRelay.\n   *\n   * @class\n   * @param {AutoRelayProperties & AutoRelayOptions} props\n   */\n  constructor ({ libp2p, maxListeners = 1, onError }) {\n    this._libp2p = libp2p\n    this._peerId = libp2p.peerId\n    this._peerStore = libp2p.peerStore\n    this._connectionManager = libp2p.connectionManager\n    this._transportManager = libp2p.transportManager\n    this._addressSorter = libp2p.dialer.addressSorter\n\n    this.maxListeners = maxListeners\n\n    /**\n     * @type {Set<string>}\n     */\n    this._listenRelays = new Set()\n\n    this._onProtocolChange = this._onProtocolChange.bind(this)\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this)\n\n    this._peerStore.on('change:protocols', this._onProtocolChange)\n    this._connectionManager.on('peer:disconnect', this._onPeerDisconnected)\n\n    /**\n     * @param {Error} error\n     * @param {string} [msg]\n     */\n    this._onError = (error, msg) => {\n      log.error(msg || error)\n      onError && onError(error, msg)\n    }\n  }\n\n  /**\n   * Check if a peer supports the relay protocol.\n   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.\n   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if\n   * inside the threshold.\n   *\n   * @param {Object} props\n   * @param {PeerId} props.peerId\n   * @param {string[]} props.protocols\n   * @returns {Promise<void>}\n   */\n  async _onProtocolChange ({ peerId, protocols }) {\n    const id = peerId.toB58String()\n\n    // Check if it has the protocol\n    const hasProtocol = protocols.find(protocol => protocol === multicodec)\n\n    // If no protocol, check if we were keeping the peer before as a listenRelay\n    if (!hasProtocol && this._listenRelays.has(id)) {\n      this._removeListenRelay(id)\n      return\n    } else if (!hasProtocol || this._listenRelays.has(id)) {\n      return\n    }\n\n    // If protocol, check if can hop, store info in the metadataBook and listen on it\n    try {\n      const connection = this._connectionManager.get(peerId)\n      if (!connection) {\n        return\n      }\n\n      // Do not hop on a relayed connection\n      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {\n        log(`relayed connection to ${id} will not be used to hop on`)\n        return\n      }\n\n      const supportsHop = await canHop({ connection })\n\n      if (supportsHop) {\n        this._peerStore.metadataBook.set(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE))\n        await this._addListenRelay(connection, id)\n      }\n    } catch (err) {\n      this._onError(err)\n    }\n  }\n\n  /**\n   * Peer disconnects.\n   *\n   * @param {Connection} connection - connection to the peer\n   * @returns {void}\n   */\n  _onPeerDisconnected (connection) {\n    const peerId = connection.remotePeer\n    const id = peerId.toB58String()\n\n    // Not listening on this relay\n    if (!this._listenRelays.has(id)) {\n      return\n    }\n\n    this._removeListenRelay(id)\n  }\n\n  /**\n   * Attempt to listen on the given relay connection.\n   *\n   * @private\n   * @param {Connection} connection - connection to the peer\n   * @param {string} id - peer identifier string\n   * @returns {Promise<void>}\n   */\n  async _addListenRelay (connection, id) {\n    // Check if already listening on enough relays\n    if (this._listenRelays.size >= this.maxListeners) {\n      return\n    }\n\n    // Get peer known addresses and sort them per public addresses first\n    const remoteAddrs = this._peerStore.addressBook.getMultiaddrsForPeer(\n      connection.remotePeer, this._addressSorter\n    )\n\n    if (!remoteAddrs || !remoteAddrs.length) {\n      return\n    }\n\n    const listenAddr = `${remoteAddrs[0].toString()}/p2p-circuit`\n    this._listenRelays.add(id)\n\n    // Attempt to listen on relay\n    try {\n      await this._transportManager.listen([new Multiaddr(listenAddr)])\n      // Announce multiaddrs will update on listen success by TransportManager event being triggered\n    } catch (err) {\n      this._onError(err)\n      this._listenRelays.delete(id)\n    }\n  }\n\n  /**\n   * Remove listen relay.\n   *\n   * @private\n   * @param {string} id - peer identifier string.\n   * @returns {void}\n   */\n  _removeListenRelay (id) {\n    if (this._listenRelays.delete(id)) {\n      // TODO: this should be responsibility of the connMgr\n      this._listenOnAvailableHopRelays([id])\n    }\n  }\n\n  /**\n   * Try to listen on available hop relay connections.\n   * The following order will happen while we do not have enough relays.\n   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.\n   * 2. Dial and try to listen on the peers we know that support hop but are not connected.\n   * 3. Search the network.\n   *\n   * @param {string[]} [peersToIgnore]\n   * @returns {Promise<void>}\n   */\n  async _listenOnAvailableHopRelays (peersToIgnore = []) {\n    // TODO: The peer redial issue on disconnect should be handled by connection gating\n    // Check if already listening on enough relays\n    if (this._listenRelays.size >= this.maxListeners) {\n      return\n    }\n\n    const knownHopsToDial = []\n\n    // Check if we have known hop peers to use and attempt to listen on the already connected\n    for (const [id, metadataMap] of this._peerStore.metadataBook.data.entries()) {\n      // Continue to next if listening on this or peer to ignore\n      if (this._listenRelays.has(id) || peersToIgnore.includes(id)) {\n        continue\n      }\n\n      const supportsHop = metadataMap.get(HOP_METADATA_KEY)\n\n      // Continue to next if it does not support Hop\n      if (!supportsHop || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {\n        continue\n      }\n\n      const peerId = PeerId.createFromB58String(id)\n      const connection = this._connectionManager.get(peerId)\n\n      // If not connected, store for possible later use.\n      if (!connection) {\n        knownHopsToDial.push(peerId)\n        continue\n      }\n\n      await this._addListenRelay(connection, id)\n\n      // Check if already listening on enough relays\n      if (this._listenRelays.size >= this.maxListeners) {\n        return\n      }\n    }\n\n    // Try to listen on known peers that are not connected\n    for (const peerId of knownHopsToDial) {\n      await this._tryToListenOnRelay(peerId)\n\n      // Check if already listening on enough relays\n      if (this._listenRelays.size >= this.maxListeners) {\n        return\n      }\n    }\n\n    // Try to find relays to hop on the network\n    try {\n      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS)\n      for await (const provider of this._libp2p.contentRouting.findProviders(cid)) {\n        if (!provider.multiaddrs.length) {\n          continue\n        }\n\n        const peerId = provider.id\n        this._peerStore.addressBook.add(peerId, provider.multiaddrs)\n\n        await this._tryToListenOnRelay(peerId)\n\n        // Check if already listening on enough relays\n        if (this._listenRelays.size >= this.maxListeners) {\n          return\n        }\n      }\n    } catch (err) {\n      this._onError(err)\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async _tryToListenOnRelay (peerId) {\n    try {\n      const connection = await this._libp2p.dial(peerId)\n      await this._addListenRelay(connection, peerId.toB58String())\n    } catch (err) {\n      this._onError(err, `could not connect and listen on known hop relay ${peerId.toB58String()}`)\n    }\n  }\n}\n\nmodule.exports = AutoRelay\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}