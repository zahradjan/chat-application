{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass EventQueue {\n  constructor() {\n    this.pullQueue = [];\n    this.pushQueue = [];\n    this.eventHandlers = {};\n    this.isPaused = false;\n    this.isStopped = false;\n  }\n\n  push(value) {\n    if (this.isStopped) return;\n    const resolution = {\n      value,\n      done: false\n    };\n\n    if (this.pullQueue.length) {\n      const placeholder = this.pullQueue.shift();\n      if (placeholder) placeholder.resolve(resolution);\n    } else {\n      this.pushQueue.push(Promise.resolve(resolution));\n\n      if (this.highWaterMark !== undefined && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {\n        this.isPaused = true;\n\n        if (this.eventHandlers.highWater) {\n          this.eventHandlers.highWater();\n        } else if (console) {\n          console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);\n        }\n      }\n    }\n  }\n\n  stop() {\n    if (this.isStopped) return;\n    this.isStopped = true;\n    this.remove();\n\n    for (const placeholder of this.pullQueue) {\n      placeholder.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this.pullQueue.length = 0;\n  }\n\n  fail(error) {\n    if (this.isStopped) return;\n    this.isStopped = true;\n    this.remove();\n\n    if (this.pullQueue.length) {\n      for (const placeholder of this.pullQueue) {\n        placeholder.reject(error);\n      }\n\n      this.pullQueue.length = 0;\n    } else {\n      const rejection = Promise.reject(error);\n      /* Attach error handler to avoid leaking an unhandled promise rejection. */\n\n      rejection.catch(() => {});\n      this.pushQueue.push(rejection);\n    }\n  }\n\n  remove() {\n    Promise.resolve().then(() => {\n      if (this.removeCallback) this.removeCallback();\n    });\n  }\n\n  [Symbol.asyncIterator]() {\n    return {\n      next: value => {\n        const result = this.pushQueue.shift();\n\n        if (result) {\n          if (this.lowWaterMark !== undefined && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {\n            this.isPaused = false;\n\n            if (this.eventHandlers.lowWater) {\n              this.eventHandlers.lowWater();\n            }\n          }\n\n          return result;\n        } else if (this.isStopped) {\n          return Promise.resolve({\n            value: undefined,\n            done: true\n          });\n        } else {\n          return new Promise((resolve, reject) => {\n            this.pullQueue.push({\n              resolve,\n              reject\n            });\n          });\n        }\n      },\n      return: () => {\n        this.isStopped = true;\n        this.pushQueue.length = 0;\n        this.remove();\n        return Promise.resolve({\n          value: undefined,\n          done: true\n        });\n      }\n    };\n  }\n\n}\n\nclass EventIterator {\n  constructor(listen) {\n    let {\n      highWaterMark = 100,\n      lowWaterMark = 1\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const queue = new EventQueue();\n    queue.highWaterMark = highWaterMark;\n    queue.lowWaterMark = lowWaterMark;\n\n    queue.removeCallback = listen({\n      push: value => queue.push(value),\n      stop: () => queue.stop(),\n      fail: error => queue.fail(error),\n      on: (event, fn) => {\n        queue.eventHandlers[event] = fn;\n      }\n    }) || (() => {});\n\n    this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();\n\n    Object.freeze(this);\n  }\n\n}\n\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;","map":{"version":3,"names":["Object","defineProperty","exports","value","EventQueue","constructor","pullQueue","pushQueue","eventHandlers","isPaused","isStopped","push","resolution","done","length","placeholder","shift","resolve","Promise","highWaterMark","undefined","highWater","console","warn","stop","remove","fail","error","reject","rejection","catch","then","removeCallback","Symbol","asyncIterator","next","result","lowWaterMark","lowWater","return","EventIterator","listen","queue","on","event","fn","freeze","default"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/event-iterator/lib/event-iterator.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass EventQueue {\n    constructor() {\n        this.pullQueue = [];\n        this.pushQueue = [];\n        this.eventHandlers = {};\n        this.isPaused = false;\n        this.isStopped = false;\n    }\n    push(value) {\n        if (this.isStopped)\n            return;\n        const resolution = { value, done: false };\n        if (this.pullQueue.length) {\n            const placeholder = this.pullQueue.shift();\n            if (placeholder)\n                placeholder.resolve(resolution);\n        }\n        else {\n            this.pushQueue.push(Promise.resolve(resolution));\n            if (this.highWaterMark !== undefined &&\n                this.pushQueue.length >= this.highWaterMark &&\n                !this.isPaused) {\n                this.isPaused = true;\n                if (this.eventHandlers.highWater) {\n                    this.eventHandlers.highWater();\n                }\n                else if (console) {\n                    console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);\n                }\n            }\n        }\n    }\n    stop() {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        for (const placeholder of this.pullQueue) {\n            placeholder.resolve({ value: undefined, done: true });\n        }\n        this.pullQueue.length = 0;\n    }\n    fail(error) {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        if (this.pullQueue.length) {\n            for (const placeholder of this.pullQueue) {\n                placeholder.reject(error);\n            }\n            this.pullQueue.length = 0;\n        }\n        else {\n            const rejection = Promise.reject(error);\n            /* Attach error handler to avoid leaking an unhandled promise rejection. */\n            rejection.catch(() => { });\n            this.pushQueue.push(rejection);\n        }\n    }\n    remove() {\n        Promise.resolve().then(() => {\n            if (this.removeCallback)\n                this.removeCallback();\n        });\n    }\n    [Symbol.asyncIterator]() {\n        return {\n            next: (value) => {\n                const result = this.pushQueue.shift();\n                if (result) {\n                    if (this.lowWaterMark !== undefined &&\n                        this.pushQueue.length <= this.lowWaterMark &&\n                        this.isPaused) {\n                        this.isPaused = false;\n                        if (this.eventHandlers.lowWater) {\n                            this.eventHandlers.lowWater();\n                        }\n                    }\n                    return result;\n                }\n                else if (this.isStopped) {\n                    return Promise.resolve({ value: undefined, done: true });\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        this.pullQueue.push({ resolve, reject });\n                    });\n                }\n            },\n            return: () => {\n                this.isStopped = true;\n                this.pushQueue.length = 0;\n                this.remove();\n                return Promise.resolve({ value: undefined, done: true });\n            },\n        };\n    }\n}\nclass EventIterator {\n    constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {\n        const queue = new EventQueue();\n        queue.highWaterMark = highWaterMark;\n        queue.lowWaterMark = lowWaterMark;\n        queue.removeCallback =\n            listen({\n                push: value => queue.push(value),\n                stop: () => queue.stop(),\n                fail: error => queue.fail(error),\n                on: (event, fn) => {\n                    queue.eventHandlers[event] = fn;\n                },\n            }) || (() => { });\n        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();\n        Object.freeze(this);\n    }\n}\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}