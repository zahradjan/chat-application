{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar ipns = require('ipns');\n\nvar _require = require('multiformats/bases/base58'),\n    base58btc = _require.base58btc;\n\nvar PubsubDatastore = require('datastore-pubsub');\n\nvar _require2 = require('uint8arrays/from-string'),\n    uint8ArrayFromString = _require2.fromString;\n\nvar _require3 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require3.toString;\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('ipfs:ipns:pubsub'), {\n  error: debug('ipfs:ipns:pubsub:error')\n}); // Pubsub datastore aims to manage the pubsub subscriptions for IPNS\n\nvar IpnsPubsubDatastore = /*#__PURE__*/function () {\n  /**\n   * @param {import('libp2p-interfaces/src/pubsub')} pubsub\n   * @param {import('interface-datastore').Datastore} localDatastore\n   * @param {import('peer-id')} peerId\n   */\n  function IpnsPubsubDatastore(pubsub, localDatastore, peerId) {\n    _classCallCheck(this, IpnsPubsubDatastore);\n\n    /** @type {Record<string, string>} */\n    this._subscriptions = {}; // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this); // @ts-ignore will be fixed by https://github.com/ipfs/js-datastore-pubsub/pull/74\n\n    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey);\n  }\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   */\n\n\n  _createClass(IpnsPubsubDatastore, [{\n    key: \"put\",\n    value: function put(key, value) {\n      // @ts-ignore datastores take Key keys, this one takes Uint8Array keys\n      return this._pubsubDs.put(key, value);\n    }\n    /**\n     * Get a value from the pubsub datastore indexed by the received key properly encoded.\n     * Also, the identifier topic is subscribed to and the pubsub datastore records will be\n     * updated once new publishes occur.\n     *\n     * @param {Uint8Array} key - identifier of the value to be obtained.\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key) {\n        var res, err, ns, stringifiedTopic, id;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this._pubsubDs.get(key);\n\n              case 3:\n                res = _context.sent;\n                _context.next = 9;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](0);\n                err = _context.t0;\n\n              case 9:\n                // Add topic subscribed\n                ns = key.slice(0, ipns.namespaceLength);\n\n                if (uint8ArrayToString(ns) === ipns.namespace) {\n                  stringifiedTopic = base58btc.encode(key).substring(1);\n                  id = base58btc.encode(key.slice(ipns.namespaceLength)).substring(1);\n                  this._subscriptions[stringifiedTopic] = id;\n                  log(\"subscribed to pubsub topic \".concat(stringifiedTopic, \", id \").concat(id));\n                } // If no data was obtained, after storing the subscription, return the error.\n\n\n                if (!err) {\n                  _context.next = 13;\n                  break;\n                }\n\n                throw err;\n\n              case 13:\n                return _context.abrupt(\"return\", res);\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 6]]);\n      }));\n\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * Modify subscription key to have a proper encoding\n     *\n     * @param {Uint8Array | string} key\n     */\n\n  }, {\n    key: \"_handleSubscriptionKey\",\n    value: function _handleSubscriptionKey(key) {\n      if (key instanceof Uint8Array) {\n        key = uint8ArrayToString(key, 'base58btc');\n      }\n\n      var subscriber = this._subscriptions[key];\n\n      if (!subscriber) {\n        throw errcode(new Error(\"key \".concat(key, \" does not correspond to a subscription\")), 'ERR_INVALID_KEY');\n      }\n\n      var keys;\n\n      try {\n        keys = ipns.getIdKeys(uint8ArrayFromString(subscriber, 'base58btc'));\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n\n      return keys.routingKey.uint8Array();\n    }\n    /**\n     * Get pubsub subscriptions related to ipns.\n     */\n\n  }, {\n    key: \"getSubscriptions\",\n    value: function getSubscriptions() {\n      var subscriptions = Object.values(this._subscriptions).filter(Boolean);\n      return subscriptions.map(function (sub) {\n        return \"\".concat(ipns.namespace).concat(sub);\n      });\n    }\n    /**\n     * Cancel pubsub subscriptions related to ipns.\n     *\n     * @param {string} name - ipns path to cancel the pubsub subscription.\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function () {\n      var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name) {\n        var _this = this;\n\n        var stringifiedTopic, bufTopic;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(typeof name !== 'string')) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME');\n\n              case 2:\n                // Trim /ipns/ prefix from the name\n                if (name.startsWith(ipns.namespace)) {\n                  name = name.substring(ipns.namespaceLength);\n                }\n\n                stringifiedTopic = Object.keys(this._subscriptions).find(function (key) {\n                  return _this._subscriptions[key] === name;\n                }); // Not found topic\n\n                if (stringifiedTopic) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  canceled: false\n                });\n\n              case 6:\n                // Unsubscribe topic\n                bufTopic = uint8ArrayFromString(stringifiedTopic);\n\n                this._pubsubDs.unsubscribe(bufTopic);\n\n                delete this._subscriptions[stringifiedTopic];\n                log(\"unsubscribed pubsub \".concat(stringifiedTopic, \": \").concat(name));\n                return _context2.abrupt(\"return\", {\n                  canceled: true\n                });\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function cancel(_x2) {\n        return _cancel.apply(this, arguments);\n      }\n\n      return cancel;\n    }()\n  }]);\n\n  return IpnsPubsubDatastore;\n}();\n\nmodule.exports = IpnsPubsubDatastore;","map":{"version":3,"names":["ipns","require","base58btc","PubsubDatastore","uint8ArrayFromString","fromString","uint8ArrayToString","toString","errcode","debug","log","Object","assign","error","IpnsPubsubDatastore","pubsub","localDatastore","peerId","_subscriptions","_handleSubscriptionKey","bind","_pubsubDs","validator","key","value","put","get","res","err","ns","slice","namespaceLength","namespace","stringifiedTopic","encode","substring","id","Uint8Array","subscriber","Error","keys","getIdKeys","routingKey","uint8Array","subscriptions","values","filter","Boolean","map","sub","name","startsWith","find","canceled","bufTopic","unsubscribe","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/ipns/routing/pubsub-datastore.js"],"sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst { base58btc } = require('multiformats/bases/base58')\nconst PubsubDatastore = require('datastore-pubsub')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns:pubsub'), {\n  error: debug('ipfs:ipns:pubsub:error')\n})\n\n// Pubsub datastore aims to manage the pubsub subscriptions for IPNS\nclass IpnsPubsubDatastore {\n  /**\n   * @param {import('libp2p-interfaces/src/pubsub')} pubsub\n   * @param {import('interface-datastore').Datastore} localDatastore\n   * @param {import('peer-id')} peerId\n   */\n  constructor (pubsub, localDatastore, peerId) {\n    /** @type {Record<string, string>} */\n    this._subscriptions = {}\n\n    // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this)\n\n    // @ts-ignore will be fixed by https://github.com/ipfs/js-datastore-pubsub/pull/74\n    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey)\n  }\n\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   */\n  put (key, value) {\n    // @ts-ignore datastores take Key keys, this one takes Uint8Array keys\n    return this._pubsubDs.put(key, value)\n  }\n\n  /**\n   * Get a value from the pubsub datastore indexed by the received key properly encoded.\n   * Also, the identifier topic is subscribed to and the pubsub datastore records will be\n   * updated once new publishes occur.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   */\n  async get (key) {\n    let res\n    let err\n\n    try {\n      // @ts-ignore datastores take Key keys, this one takes Uint8Array keys\n      res = await this._pubsubDs.get(key)\n    } catch (e) {\n      err = e\n    }\n\n    // Add topic subscribed\n    const ns = key.slice(0, ipns.namespaceLength)\n\n    if (uint8ArrayToString(ns) === ipns.namespace) {\n      const stringifiedTopic = base58btc.encode(key).substring(1)\n      const id = base58btc.encode(key.slice(ipns.namespaceLength)).substring(1)\n\n      this._subscriptions[stringifiedTopic] = id\n\n      log(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`)\n    }\n\n    // If no data was obtained, after storing the subscription, return the error.\n    if (err) {\n      throw err\n    }\n\n    return res\n  }\n\n  /**\n   * Modify subscription key to have a proper encoding\n   *\n   * @param {Uint8Array | string} key\n   */\n  _handleSubscriptionKey (key) {\n    if (key instanceof Uint8Array) {\n      key = uint8ArrayToString(key, 'base58btc')\n    }\n\n    const subscriber = this._subscriptions[key]\n\n    if (!subscriber) {\n      throw errcode(new Error(`key ${key} does not correspond to a subscription`), 'ERR_INVALID_KEY')\n    }\n\n    let keys\n    try {\n      keys = ipns.getIdKeys(uint8ArrayFromString(subscriber, 'base58btc'))\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    return keys.routingKey.uint8Array()\n  }\n\n  /**\n   * Get pubsub subscriptions related to ipns.\n   */\n  getSubscriptions () {\n    const subscriptions = Object.values(this._subscriptions).filter(Boolean)\n\n    return subscriptions.map((sub) => `${ipns.namespace}${sub}`)\n  }\n\n  /**\n   * Cancel pubsub subscriptions related to ipns.\n   *\n   * @param {string} name - ipns path to cancel the pubsub subscription.\n   */\n  async cancel (name) { // eslint-disable-line require-await\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME')\n    }\n\n    // Trim /ipns/ prefix from the name\n    if (name.startsWith(ipns.namespace)) {\n      name = name.substring(ipns.namespaceLength)\n    }\n\n    const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name)\n\n    // Not found topic\n    if (!stringifiedTopic) {\n      return {\n        canceled: false\n      }\n    }\n\n    // Unsubscribe topic\n    const bufTopic = uint8ArrayFromString(stringifiedTopic)\n\n    this._pubsubDs.unsubscribe(bufTopic)\n\n    delete this._subscriptions[stringifiedTopic]\n    log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`)\n\n    return {\n      canceled: true\n    }\n  }\n}\n\nmodule.exports = IpnsPubsubDatastore\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}