{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar isBuffer = require('is-buffer');\n\nvar Shake = require('it-handshake');\n\nvar lp = require('it-length-prefixed');\n\nmodule.exports = function (duplex) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var shake = Shake(duplex);\n  var lpReader = lp.decode.fromReader(shake.reader, opts);\n  var isDone = false;\n  var W = {\n    read: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(bytes) {\n        var _yield$shake$reader$n, value, done;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return shake.reader.next(bytes);\n\n              case 2:\n                _yield$shake$reader$n = _context.sent;\n                value = _yield$shake$reader$n.value;\n                done = _yield$shake$reader$n.done;\n\n                if (!(done && value.length < bytes)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error('Couldn\\'t read enough bytes');\n\n              case 7:\n                isDone = done;\n\n                if (value) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw new Error('Value is null');\n\n              case 10:\n                return _context.abrupt(\"return\", value);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function read(_x) {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }(),\n    readLP: function () {\n      var _readLP = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _yield$lpReader$next, value, done;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return lpReader.next();\n\n              case 2:\n                _yield$lpReader$next = _context2.sent;\n                value = _yield$lpReader$next.value;\n                done = _yield$lpReader$next.done;\n                isDone = done;\n\n                if (value) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                throw new Error('Value is null');\n\n              case 8:\n                return _context2.abrupt(\"return\", value);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function readLP() {\n        return _readLP.apply(this, arguments);\n      }\n\n      return readLP;\n    }(),\n    readPB: function () {\n      var _readPB = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(proto) {\n        var value, buf;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return W.readLP();\n\n              case 2:\n                value = _context3.sent;\n\n                if (value) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                throw new Error('Value is null');\n\n              case 5:\n                // Is this a buffer?\n                buf = isBuffer(value) ? value : value.slice();\n                return _context3.abrupt(\"return\", proto.decode(buf));\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function readPB(_x2) {\n        return _readPB.apply(this, arguments);\n      }\n\n      return readPB;\n    }(),\n    write: function write(data) {\n      // just write\n      shake.writer.push(data);\n    },\n    writeLP: function writeLP(data) {\n      // encode, write\n      W.write(lp.encode.single(data, opts));\n    },\n    writePB: function writePB(data, proto) {\n      // encode, writeLP\n      W.writeLP(proto.encode(data));\n    },\n    pb: function pb(proto) {\n      return {\n        read: function read() {\n          return W.readPB(proto);\n        },\n        write: function write(d) {\n          return W.writePB(d, proto);\n        }\n      };\n    },\n    unwrap: function unwrap() {\n      // returns vanilla duplex again, terminates all reads/writes from this object\n      shake.rest();\n      return shake.stream;\n    }\n  };\n  return W;\n};","map":{"version":3,"names":["isBuffer","require","Shake","lp","module","exports","duplex","opts","shake","lpReader","decode","fromReader","reader","isDone","W","read","bytes","next","value","done","length","Error","readLP","readPB","proto","buf","slice","write","data","writer","push","writeLP","encode","single","writePB","pb","d","unwrap","rest","stream"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/it-pb-rpc/src/index.js"],"sourcesContent":["'use strict'\n\nconst isBuffer = require('is-buffer')\nconst Shake = require('it-handshake')\nconst lp = require('it-length-prefixed')\n\nmodule.exports = (duplex, opts = {}) => {\n  const shake = Shake(duplex)\n  const lpReader = lp.decode.fromReader(\n      shake.reader,\n      opts\n  )\n\n  let isDone = false\n\n  const W = {\n    read: async (bytes) => {\n      // just read\n\n      const { value, done } = await shake.reader.next(bytes)\n\n      if (done && value.length < bytes) {\n        throw new Error('Couldn\\'t read enough bytes')\n      }\n\n      isDone = done\n\n      if (!value) { throw new Error('Value is null') }\n      return value\n    },\n    readLP: async () => {\n      // read, decode\n      const { value, done } = await lpReader.next()\n\n      isDone = done\n\n      if (!value) { throw new Error('Value is null') }\n      return value\n    },\n    readPB: async (proto) => {\n      // readLP, decode\n      const value = await W.readLP()\n\n      if (!value) { throw new Error('Value is null') }\n\n      // Is this a buffer?\n      const buf = isBuffer(value) ? value : value.slice()\n\n      return proto.decode(buf)\n    },\n    write: (data) => {\n      // just write\n      shake.writer.push(data)\n    },\n    writeLP: (data) => {\n      // encode, write\n      W.write(lp.encode.single(data, opts))\n    },\n    writePB: (data, proto) => {\n      // encode, writeLP\n      W.writeLP(proto.encode(data))\n    },\n\n    pb: (proto) => {\n      return {\n        read: () => W.readPB(proto),\n        write: (d) => W.writePB(d, proto)\n      }\n    },\n\n    unwrap: () => {\n      // returns vanilla duplex again, terminates all reads/writes from this object\n      shake.rest()\n      return shake.stream\n    }\n  }\n\n  return W\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}