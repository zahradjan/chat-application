{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _assertThisInitialized = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar WantManager = require('./want-manager');\n\nvar Network = require('./network');\n\nvar DecisionEngine = require('./decision-engine');\n\nvar Notifications = require('./notifications');\n\nvar logger = require('./utils').logger;\n\nvar Stats = require('./stats');\n\nvar _require = require('native-abort-controller'),\n    AbortController = _require.AbortController;\n\nvar _require2 = require('any-signal'),\n    anySignal = _require2.anySignal;\n\nvar _require3 = require('interface-blockstore'),\n    BlockstoreAdapter = _require3.BlockstoreAdapter;\n\nvar _require4 = require('multiformats'),\n    CID = _require4.CID;\n/**\n * @typedef {import('./types').IPFSBitswap} IPFSBitswap\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types/message')} BitswapMessage\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n */\n\n\nvar defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nvar statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @implements {IPFSBitswap}\n */\n\nvar Bitswap = /*#__PURE__*/function (_BlockstoreAdapter) {\n  _inherits(Bitswap, _BlockstoreAdapter);\n\n  var _super = _createSuper(Bitswap);\n\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {Blockstore} blockstore\n   * @param {Object} [options]\n   * @param {boolean} [options.statsEnabled=false]\n   * @param {number} [options.statsComputeThrottleTimeout=1000]\n   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  function Bitswap(libp2p, blockstore) {\n    var _this3;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, Bitswap);\n\n    _this3 = _super.call(this);\n    _this3._libp2p = libp2p;\n    _this3._log = logger(_this3.peerId);\n    _this3._options = Object.assign({}, defaultOptions, options); // stats\n\n    _this3._stats = new Stats(statsKeys, {\n      enabled: _this3._options.statsEnabled,\n      computeThrottleTimeout: _this3._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: _this3._options.statsComputeThrottleMaxQueueSize\n    }); // the network delivers messages\n\n    _this3.network = new Network(libp2p, _assertThisInitialized(_this3), _this3._stats, {\n      hashers: options.hashers\n    }); // local database\n\n    _this3.blockstore = blockstore;\n    _this3.engine = new DecisionEngine(_this3.peerId, blockstore, _this3.network, _this3._stats); // handle message sending\n\n    _this3.wm = new WantManager(_this3.peerId, _this3.network, _this3._stats);\n    _this3.notifications = new Notifications(_this3.peerId);\n    _this3.started = false;\n    return _this3;\n  }\n\n  _createClass(Bitswap, [{\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this.started;\n    }\n    /**\n     * @type {PeerId}\n     */\n\n  }, {\n    key: \"peerId\",\n    get: function get() {\n      return this._libp2p.peerId;\n    }\n    /**\n     * handle messages received through the network\n     *\n     * @param {PeerId} peerId\n     * @param {BitswapMessage} incoming\n     */\n\n  }, {\n    key: \"_receiveMessage\",\n    value: function () {\n      var _receiveMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(peerId, incoming) {\n        var _this4 = this;\n\n        var received, _iterator3, _step3, _step3$value, cidStr, data, cid;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this.engine.messageReceived(peerId, incoming);\n\n              case 3:\n                _context.next = 8;\n                break;\n\n              case 5:\n                _context.prev = 5;\n                _context.t0 = _context[\"catch\"](0);\n\n                // Log instead of throwing an error so as to process as much as\n                // possible of the message. Currently `messageReceived` does not\n                // throw any errors, but this could change in the future.\n                this._log('failed to receive message', incoming);\n\n              case 8:\n                if (!(incoming.blocks.size === 0)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 10:\n                /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n                received = [];\n                _iterator3 = _createForOfIteratorHelper(incoming.blocks.entries());\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    _step3$value = _slicedToArray(_step3.value, 2), cidStr = _step3$value[0], data = _step3$value[1];\n                    cid = CID.parse(cidStr);\n                    received.push({\n                      wasWanted: this.wm.wantlist.contains(cid),\n                      cid: cid,\n                      data: data\n                    });\n                  } // quickly send out cancels, reduces chances of duplicate block receives\n\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                this.wm.cancelWants(received.filter(function (_ref) {\n                  var wasWanted = _ref.wasWanted;\n                  return wasWanted;\n                }).map(function (_ref2) {\n                  var cid = _ref2.cid;\n                  return cid;\n                }));\n                _context.next = 16;\n                return Promise.all(received.map(function (_ref3) {\n                  var cid = _ref3.cid,\n                      wasWanted = _ref3.wasWanted,\n                      data = _ref3.data;\n                  return _this4._handleReceivedBlock(peerId, cid, data, wasWanted);\n                }));\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 5]]);\n      }));\n\n      function _receiveMessage(_x, _x2) {\n        return _receiveMessage2.apply(this, arguments);\n      }\n\n      return _receiveMessage;\n    }()\n    /**\n     * @private\n     * @param {PeerId} peerId\n     * @param {CID} cid\n     * @param {Uint8Array} data\n     * @param {boolean} wasWanted\n     */\n\n  }, {\n    key: \"_handleReceivedBlock\",\n    value: function () {\n      var _handleReceivedBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peerId, cid, data, wasWanted) {\n        var has;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._log('received block');\n\n                _context2.next = 3;\n                return this.blockstore.has(cid);\n\n              case 3:\n                has = _context2.sent;\n\n                this._updateReceiveCounters(peerId.toB58String(), cid, data, has);\n\n                if (wasWanted) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 7:\n                _context2.next = 9;\n                return this.put(cid, data);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _handleReceivedBlock(_x3, _x4, _x5, _x6) {\n        return _handleReceivedBlock2.apply(this, arguments);\n      }\n\n      return _handleReceivedBlock;\n    }()\n    /**\n     * @private\n     * @param {string} peerIdStr\n     * @param {CID} cid\n     * @param {Uint8Array} data\n     * @param {boolean} exists\n     */\n\n  }, {\n    key: \"_updateReceiveCounters\",\n    value: function _updateReceiveCounters(peerIdStr, cid, data, exists) {\n      this._stats.push(peerIdStr, 'blocksReceived', 1);\n\n      this._stats.push(peerIdStr, 'dataReceived', data.length);\n\n      if (exists) {\n        this._stats.push(peerIdStr, 'dupBlksReceived', 1);\n\n        this._stats.push(peerIdStr, 'dupDataReceived', data.length);\n      }\n    }\n    /**\n     * handle errors on the receiving channel\n     *\n     * @param {Error} err\n     */\n\n  }, {\n    key: \"_receiveError\",\n    value: function _receiveError(err) {\n      this._log.error('ReceiveError: %s', err.message);\n    }\n    /**\n     * handle new peers\n     *\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"_onPeerConnected\",\n    value: function _onPeerConnected(peerId) {\n      this.wm.connected(peerId);\n    }\n    /**\n     * handle peers being disconnected\n     *\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"_onPeerDisconnected\",\n    value: function _onPeerDisconnected(peerId) {\n      this.wm.disconnected(peerId);\n      this.engine.peerDisconnected(peerId);\n\n      this._stats.disconnected(peerId);\n    }\n  }, {\n    key: \"enableStats\",\n    value: function enableStats() {\n      this._stats.enable();\n    }\n  }, {\n    key: \"disableStats\",\n    value: function disableStats() {\n      this._stats.disable();\n    }\n    /**\n     * Return the current wantlist for a given `peerId`\n     *\n     * @param {PeerId} peerId\n     * @param {any} [_options]\n     */\n\n  }, {\n    key: \"wantlistForPeer\",\n    value: function wantlistForPeer(peerId, _options) {\n      return this.engine.wantlistForPeer(peerId);\n    }\n    /**\n     * Return ledger information for a given `peerId`\n     *\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"ledgerForPeer\",\n    value: function ledgerForPeer(peerId) {\n      return this.engine.ledgerForPeer(peerId);\n    }\n    /**\n     * Fetch a given block by cid. If the block is in the local\n     * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n     *\n     * @param {CID} cid\n     * @param {Object} [options]\n     * @param {AbortSignal} [options.signal]\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(cid) {\n        var _this5 = this;\n\n        var options,\n            fetchFromNetwork,\n            promptedNetwork,\n            loadOrFetchFromNetwork,\n            controller,\n            signal,\n            block,\n            _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n\n                /**\n                 * @param {CID} cid\n                 * @param {Object} options\n                 * @param {AbortSignal} options.signal\n                 */\n                fetchFromNetwork = function fetchFromNetwork(cid, options) {\n                  // add it to the want list - n.b. later we will abort the AbortSignal\n                  // so no need to remove the blocks from the wantlist after we have it\n                  _this5.wm.wantBlocks([cid], options);\n\n                  return _this5.notifications.wantBlock(cid, options);\n                };\n\n                promptedNetwork = false;\n                /**\n                 *\n                 * @param {CID} cid\n                 * @param {Object} options\n                 * @param {AbortSignal} options.signal\n                 */\n\n                loadOrFetchFromNetwork = /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(cid, options) {\n                    var _block;\n\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            _context3.prev = 0;\n                            _context3.next = 3;\n                            return _this5.blockstore.get(cid, options);\n\n                          case 3:\n                            _block = _context3.sent;\n                            return _context3.abrupt(\"return\", _block);\n\n                          case 7:\n                            _context3.prev = 7;\n                            _context3.t0 = _context3[\"catch\"](0);\n\n                            if (!(_context3.t0.code !== 'ERR_NOT_FOUND')) {\n                              _context3.next = 11;\n                              break;\n                            }\n\n                            throw _context3.t0;\n\n                          case 11:\n                            if (!promptedNetwork) {\n                              promptedNetwork = true;\n\n                              _this5.network.findAndConnect(cid).catch(function (err) {\n                                return _this5._log.error(err);\n                              });\n                            } // we don't have the block locally so fetch it from the network\n\n\n                            return _context3.abrupt(\"return\", fetchFromNetwork(cid, options));\n\n                          case 13:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3, null, [[0, 7]]);\n                  }));\n\n                  return function loadOrFetchFromNetwork(_x8, _x9) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }(); // depending on implementation it's possible for blocks to come in while\n                // we do the async operations to get them from the blockstore leading to\n                // a race condition, so register for incoming block notifications as well\n                // as trying to get it from the datastore\n\n\n                controller = new AbortController();\n                signal = options.signal ? anySignal([options.signal, controller.signal]) : controller.signal;\n                _context4.next = 8;\n                return Promise.race([this.notifications.wantBlock(cid, {\n                  signal: signal\n                }), loadOrFetchFromNetwork(cid, {\n                  signal: signal\n                })]);\n\n              case 8:\n                block = _context4.sent;\n                // since we have the block we can now remove our listener\n                controller.abort();\n                return _context4.abrupt(\"return\", block);\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function get(_x7) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * Fetch a a list of blocks by cid. If the blocks are in the local\n     * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n     *\n     * @param {AsyncIterable<CID>|Iterable<CID>} cids\n     * @param {Object} [options]\n     * @param {AbortSignal} [options.signal]\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function getMany(cids) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, cid;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _iteratorAbruptCompletion = false;\n                _didIteratorError = false;\n                _context5.prev = 2;\n                _iterator = _asyncIterator(cids);\n\n              case 4:\n                _context5.next = 6;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 6:\n                if (!(_iteratorAbruptCompletion = !(_step = _context5.sent).done)) {\n                  _context5.next = 13;\n                  break;\n                }\n\n                cid = _step.value;\n                _context5.next = 10;\n                return _this.get(cid, options);\n\n              case 10:\n                _iteratorAbruptCompletion = false;\n                _context5.next = 4;\n                break;\n\n              case 13:\n                _context5.next = 19;\n                break;\n\n              case 15:\n                _context5.prev = 15;\n                _context5.t0 = _context5[\"catch\"](2);\n                _didIteratorError = true;\n                _iteratorError = _context5.t0;\n\n              case 19:\n                _context5.prev = 19;\n                _context5.prev = 20;\n\n                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                _context5.next = 24;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 24:\n                _context5.prev = 24;\n\n                if (!_didIteratorError) {\n                  _context5.next = 27;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 27:\n                return _context5.finish(24);\n\n              case 28:\n                return _context5.finish(19);\n\n              case 29:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[2, 15, 19, 29], [20,, 24, 28]]);\n      }))();\n    }\n    /**\n     * Removes the given CIDs from the wantlist independent of any ref counts.\n     *\n     * This will cause all outstanding promises for a given block to reject.\n     *\n     * If you want to cancel the want for a block without doing that, pass an\n     * AbortSignal in to `.get` or `.getMany` and abort it.\n     *\n     * @param {CID[]|CID} cids\n     */\n\n  }, {\n    key: \"unwant\",\n    value: function unwant(cids) {\n      var _this6 = this;\n\n      var cidsArray = Array.isArray(cids) ? cids : [cids];\n      this.wm.unwantBlocks(cidsArray);\n      cidsArray.forEach(function (cid) {\n        return _this6.notifications.unwantBlock(cid);\n      });\n    }\n    /**\n     * Removes the given keys from the want list. This may cause pending promises\n     * for blocks to never resolve.  If you wish these promises to abort instead\n     * call `unwant(cids)` instead.\n     *\n     * @param {CID[]|CID} cids\n     */\n\n  }, {\n    key: \"cancelWants\",\n    value: function cancelWants(cids) {\n      this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);\n    }\n    /**\n     * Put the given block to the underlying blockstore and\n     * send it to nodes that have it in their wantlist.\n     *\n     * @param {CID} cid\n     * @param {Uint8Array} block\n     * @param {any} [_options]\n     */\n\n  }, {\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(cid, block, _options) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.blockstore.put(cid, block);\n\n              case 2:\n                this._sendHaveBlockNotifications(cid, block);\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function put(_x10, _x11, _x12) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n    /**\n     * Put the given blocks to the underlying blockstore and\n     * send it to nodes that have it them their wantlist.\n     *\n     * @param {Iterable<Pair> | AsyncIterable<Pair>} source\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"putMany\",\n    value: function putMany(source, options) {\n      var _this2 = this;\n\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _step2$value, key, value;\n\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _iteratorAbruptCompletion2 = false;\n                _didIteratorError2 = false;\n                _context7.prev = 2;\n                _iterator2 = _asyncIterator(_this2.blockstore.putMany(source, options));\n\n              case 4:\n                _context7.next = 6;\n                return _awaitAsyncGenerator(_iterator2.next());\n\n              case 6:\n                if (!(_iteratorAbruptCompletion2 = !(_step2 = _context7.sent).done)) {\n                  _context7.next = 14;\n                  break;\n                }\n\n                _step2$value = _step2.value, key = _step2$value.key, value = _step2$value.value;\n\n                _this2._sendHaveBlockNotifications(key, value);\n\n                _context7.next = 11;\n                return {\n                  key: key,\n                  value: value\n                };\n\n              case 11:\n                _iteratorAbruptCompletion2 = false;\n                _context7.next = 4;\n                break;\n\n              case 14:\n                _context7.next = 20;\n                break;\n\n              case 16:\n                _context7.prev = 16;\n                _context7.t0 = _context7[\"catch\"](2);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context7.t0;\n\n              case 20:\n                _context7.prev = 20;\n                _context7.prev = 21;\n\n                if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                  _context7.next = 25;\n                  break;\n                }\n\n                _context7.next = 25;\n                return _awaitAsyncGenerator(_iterator2.return());\n\n              case 25:\n                _context7.prev = 25;\n\n                if (!_didIteratorError2) {\n                  _context7.next = 28;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 28:\n                return _context7.finish(25);\n\n              case 29:\n                return _context7.finish(20);\n\n              case 30:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, null, [[2, 16, 20, 30], [21,, 25, 29]]);\n      }))();\n    }\n    /**\n     * Sends notifications about the arrival of a block\n     *\n     * @private\n     * @param {CID} cid\n     * @param {Uint8Array} data\n     */\n\n  }, {\n    key: \"_sendHaveBlockNotifications\",\n    value: function _sendHaveBlockNotifications(cid, data) {\n      var _this7 = this;\n\n      this.notifications.hasBlock(cid, data);\n      this.engine.receivedBlocks([{\n        cid: cid,\n        data: data\n      }]); // Note: Don't wait for provide to finish before returning\n\n      this.network.provide(cid).catch(function (err) {\n        _this7._log.error('Failed to provide: %s', err.message);\n      });\n    }\n    /**\n     * Get the current list of wants\n     */\n\n  }, {\n    key: \"getWantlist\",\n    value: function getWantlist() {\n      return this.wm.wantlist.entries();\n    }\n    /**\n     * Get the current list of partners\n     */\n\n  }, {\n    key: \"peers\",\n    value: function peers() {\n      return this.engine.peers();\n    }\n    /**\n     * Get stats about the bitswap node\n     */\n\n  }, {\n    key: \"stat\",\n    value: function stat() {\n      return this._stats;\n    }\n    /**\n     * Start the bitswap node\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.wm.start();\n      this.network.start();\n      this.engine.start();\n      this.started = true;\n    }\n    /**\n     * Stop the bitswap node\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._stats.stop();\n\n      this.wm.stop();\n      this.network.stop();\n      this.engine.stop();\n      this.started = false;\n    }\n  }, {\n    key: \"unwrap\",\n    value: function unwrap() {\n      return this.blockstore;\n    }\n  }]);\n\n  return Bitswap;\n}(BlockstoreAdapter);\n\nmodule.exports = Bitswap;","map":{"version":3,"names":["WantManager","require","Network","DecisionEngine","Notifications","logger","Stats","AbortController","anySignal","BlockstoreAdapter","CID","defaultOptions","statsEnabled","statsComputeThrottleTimeout","statsComputeThrottleMaxQueueSize","statsKeys","Bitswap","libp2p","blockstore","options","_libp2p","_log","peerId","_options","Object","assign","_stats","enabled","computeThrottleTimeout","computeThrottleMaxQueueSize","network","hashers","engine","wm","notifications","started","incoming","messageReceived","blocks","size","received","entries","cidStr","data","cid","parse","push","wasWanted","wantlist","contains","cancelWants","filter","map","Promise","all","_handleReceivedBlock","has","_updateReceiveCounters","toB58String","put","peerIdStr","exists","length","err","error","message","connected","disconnected","peerDisconnected","enable","disable","wantlistForPeer","ledgerForPeer","fetchFromNetwork","wantBlocks","wantBlock","promptedNetwork","loadOrFetchFromNetwork","get","block","code","findAndConnect","catch","controller","signal","race","abort","cids","cidsArray","Array","isArray","unwantBlocks","forEach","unwantBlock","_sendHaveBlockNotifications","source","putMany","key","value","hasBlock","receivedBlocks","provide","peers","start","stop","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-bitswap/src/bitswap.js"],"sourcesContent":["'use strict'\n\nconst WantManager = require('./want-manager')\nconst Network = require('./network')\nconst DecisionEngine = require('./decision-engine')\nconst Notifications = require('./notifications')\nconst logger = require('./utils').logger\nconst Stats = require('./stats')\nconst { AbortController } = require('native-abort-controller')\nconst { anySignal } = require('any-signal')\nconst { BlockstoreAdapter } = require('interface-blockstore')\nconst { CID } = require('multiformats')\n\n/**\n * @typedef {import('./types').IPFSBitswap} IPFSBitswap\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types/message')} BitswapMessage\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n */\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n}\nconst statsKeys = [\n  'blocksReceived',\n  'dataReceived',\n  'dupBlksReceived',\n  'dupDataReceived',\n  'blocksSent',\n  'dataSent',\n  'providesBufferLength',\n  'wantListLength',\n  'peerCount'\n]\n\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @implements {IPFSBitswap}\n */\nclass Bitswap extends BlockstoreAdapter {\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {Blockstore} blockstore\n   * @param {Object} [options]\n   * @param {boolean} [options.statsEnabled=false]\n   * @param {number} [options.statsComputeThrottleTimeout=1000]\n   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  constructor (libp2p, blockstore, options = {}) {\n    super()\n\n    this._libp2p = libp2p\n    this._log = logger(this.peerId)\n\n    this._options = Object.assign({}, defaultOptions, options)\n\n    // stats\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    })\n\n    // the network delivers messages\n    this.network = new Network(libp2p, this, this._stats, {\n      hashers: options.hashers\n    })\n\n    // local database\n    this.blockstore = blockstore\n\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats)\n\n    // handle message sending\n    this.wm = new WantManager(this.peerId, this.network, this._stats)\n\n    this.notifications = new Notifications(this.peerId)\n\n    this.started = false\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * @type {PeerId}\n   */\n  get peerId () {\n    return this._libp2p.peerId\n  }\n\n  /**\n   * handle messages received through the network\n   *\n   * @param {PeerId} peerId\n   * @param {BitswapMessage} incoming\n   */\n  async _receiveMessage (peerId, incoming) {\n    try {\n      // Note: this allows the engine to respond to any wants in the message.\n      // Processing of the blocks in the message happens below, after the\n      // blocks have been added to the blockstore.\n      await this.engine.messageReceived(peerId, incoming)\n    } catch (err) {\n      // Log instead of throwing an error so as to process as much as\n      // possible of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming)\n    }\n\n    if (incoming.blocks.size === 0) {\n      return\n    }\n\n    /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n    const received = []\n\n    for (const [cidStr, data] of incoming.blocks.entries()) {\n      const cid = CID.parse(cidStr)\n\n      received.push({\n        wasWanted: this.wm.wantlist.contains(cid),\n        cid,\n        data\n      })\n    }\n\n    // quickly send out cancels, reduces chances of duplicate block receives\n    this.wm.cancelWants(\n      received\n        .filter(({ wasWanted }) => wasWanted)\n        .map(({ cid }) => cid)\n    )\n\n    await Promise.all(\n      received.map(\n        ({ cid, wasWanted, data }) => this._handleReceivedBlock(peerId, cid, data, wasWanted)\n      )\n    )\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} wasWanted\n   */\n  async _handleReceivedBlock (peerId, cid, data, wasWanted) {\n    this._log('received block')\n\n    const has = await this.blockstore.has(cid)\n\n    this._updateReceiveCounters(peerId.toB58String(), cid, data, has)\n\n    if (!wasWanted) {\n      return\n    }\n\n    await this.put(cid, data)\n  }\n\n  /**\n   * @private\n   * @param {string} peerIdStr\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} exists\n   */\n  _updateReceiveCounters (peerIdStr, cid, data, exists) {\n    this._stats.push(peerIdStr, 'blocksReceived', 1)\n    this._stats.push(peerIdStr, 'dataReceived', data.length)\n\n    if (exists) {\n      this._stats.push(peerIdStr, 'dupBlksReceived', 1)\n      this._stats.push(peerIdStr, 'dupDataReceived', data.length)\n    }\n  }\n\n  /**\n   * handle errors on the receiving channel\n   *\n   * @param {Error} err\n   */\n  _receiveError (err) {\n    this._log.error('ReceiveError: %s', err.message)\n  }\n\n  /**\n   * handle new peers\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerConnected (peerId) {\n    this.wm.connected(peerId)\n  }\n\n  /**\n   * handle peers being disconnected\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnected (peerId) {\n    this.wm.disconnected(peerId)\n    this.engine.peerDisconnected(peerId)\n    this._stats.disconnected(peerId)\n  }\n\n  enableStats () {\n    this._stats.enable()\n  }\n\n  disableStats () {\n    this._stats.disable()\n  }\n\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @param {any} [_options]\n   */\n  wantlistForPeer (peerId, _options) {\n    return this.engine.wantlistForPeer(peerId)\n  }\n\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   */\n  ledgerForPeer (peerId) {\n    return this.engine.ledgerForPeer(peerId)\n  }\n\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async get (cid, options = {}) {\n    /**\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.signal\n     */\n    const fetchFromNetwork = (cid, options) => {\n      // add it to the want list - n.b. later we will abort the AbortSignal\n      // so no need to remove the blocks from the wantlist after we have it\n      this.wm.wantBlocks([cid], options)\n\n      return this.notifications.wantBlock(cid, options)\n    }\n\n    let promptedNetwork = false\n\n    /**\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.signal\n     */\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        // have to await here as we want to handle ERR_NOT_FOUND\n        const block = await this.blockstore.get(cid, options)\n\n        return block\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n\n        if (!promptedNetwork) {\n          promptedNetwork = true\n\n          this.network.findAndConnect(cid)\n            .catch((err) => this._log.error(err))\n        }\n\n        // we don't have the block locally so fetch it from the network\n        return fetchFromNetwork(cid, options)\n      }\n    }\n\n    // depending on implementation it's possible for blocks to come in while\n    // we do the async operations to get them from the blockstore leading to\n    // a race condition, so register for incoming block notifications as well\n    // as trying to get it from the datastore\n    const controller = new AbortController()\n    const signal = options.signal\n      ? anySignal([options.signal, controller.signal])\n      : controller.signal\n\n    const block = await Promise.race([\n      this.notifications.wantBlock(cid, {\n        signal\n      }),\n      loadOrFetchFromNetwork(cid, {\n        signal\n      })\n    ])\n\n    // since we have the block we can now remove our listener\n    controller.abort()\n\n    return block\n  }\n\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterable<CID>|Iterable<CID>} cids\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * getMany (cids, options = {}) {\n    for await (const cid of cids) {\n      yield this.get(cid, options)\n    }\n  }\n\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {CID[]|CID} cids\n   */\n  unwant (cids) {\n    const cidsArray = Array.isArray(cids) ? cids : [cids]\n\n    this.wm.unwantBlocks(cidsArray)\n    cidsArray.forEach((cid) => this.notifications.unwantBlock(cid))\n  }\n\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {CID[]|CID} cids\n   */\n  cancelWants (cids) {\n    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids])\n  }\n\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {any} [_options]\n   */\n  async put (cid, block, _options) {\n    await this.blockstore.put(cid, block)\n    this._sendHaveBlockNotifications(cid, block)\n  }\n\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {Iterable<Pair> | AsyncIterable<Pair>} source\n   * @param {Options} [options]\n   */\n  async * putMany (source, options) {\n    for await (const { key, value } of this.blockstore.putMany(source, options)) {\n      this._sendHaveBlockNotifications(key, value)\n\n      yield { key, value }\n    }\n  }\n\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @private\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   */\n  _sendHaveBlockNotifications (cid, data) {\n    this.notifications.hasBlock(cid, data)\n    this.engine.receivedBlocks([{ cid, data }])\n    // Note: Don't wait for provide to finish before returning\n    this.network.provide(cid).catch((err) => {\n      this._log.error('Failed to provide: %s', err.message)\n    })\n  }\n\n  /**\n   * Get the current list of wants\n   */\n  getWantlist () {\n    return this.wm.wantlist.entries()\n  }\n\n  /**\n   * Get the current list of partners\n   */\n  peers () {\n    return this.engine.peers()\n  }\n\n  /**\n   * Get stats about the bitswap node\n   */\n  stat () {\n    return this._stats\n  }\n\n  /**\n   * Start the bitswap node\n   */\n  start () {\n    this.wm.start()\n    this.network.start()\n    this.engine.start()\n    this.started = true\n  }\n\n  /**\n   * Stop the bitswap node\n   */\n  stop () {\n    this._stats.stop()\n    this.wm.stop()\n    this.network.stop()\n    this.engine.stop()\n    this.started = false\n  }\n\n  unwrap () {\n    return this.blockstore\n  }\n}\n\nmodule.exports = Bitswap\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}