{"ast":null,"code":"'use strict';\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst _get = require('just-safe-get');\n\nconst _set = require('just-safe-set');\n\nconst errCode = require('err-code');\n\nconst errors = require('./errors');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  hasWithFallback,\n  getWithFallback // @ts-ignore\n\n} = require('ipfs-repo-migrations/src/utils');\n\nconst configKey = new Key('config');\n/**\n * @typedef {import('./types').Config} Config\n */\n\n/**\n * @param {import('interface-datastore').Datastore} store\n */\n\nmodule.exports = store => {\n  const setQueue = new Queue({\n    concurrency: 1\n  });\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     * @returns {Promise<Config>}\n     */\n    async getAll() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      const encodedValue = await getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store, {\n        signal: options.signal\n      });\n      return JSON.parse(uint8ArrayToString(encodedValue));\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {string} key - the config key to get\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     */\n    async get(key) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (key == null) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`);\n      }\n\n      const config = await this.getAll(options);\n\n      const value = _get(config, key);\n\n      if (value === undefined) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`);\n      }\n\n      return value;\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {string} key - the config key to be written\n     * @param {any} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    set(key, value) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      // @ts-ignore ts thinks key will only be a string, but it may not be\n      if (typeof key !== 'string' && !(key instanceof String)) {\n        throw errCode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY');\n      }\n\n      if (value === undefined || value instanceof Uint8Array) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal));\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Config} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    replace(value) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!value || value instanceof Uint8Array) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal));\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     */\n    async exists() {\n      // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      return hasWithFallback(configKey, store.has.bind(store), store);\n    }\n\n  };\n  return configStore;\n  /**\n   * @param {{ key: any; value: any; }} m\n   * @param {AbortSignal | undefined} signal\n   */\n\n  async function _maybeDoSet(m, signal) {\n    if (signal && signal.aborted) {\n      return;\n    }\n\n    const key = m.key;\n    const value = m.value;\n\n    if (key) {\n      const config = await configStore.getAll();\n\n      if (typeof config === 'object' && config !== null) {\n        _set(config, key, value);\n      }\n\n      return _saveAll(config);\n    }\n\n    return _saveAll(value);\n  }\n  /**\n   * @param {unknown} config\n   */\n\n\n  function _saveAll(config) {\n    const buf = uint8ArrayFromString(JSON.stringify(config, null, 2));\n    return store.put(configKey, buf);\n  }\n};","map":{"version":3,"names":["Key","require","default","Queue","_get","_set","errCode","errors","toString","uint8ArrayToString","fromString","uint8ArrayFromString","hasWithFallback","getWithFallback","configKey","module","exports","store","setQueue","concurrency","configStore","getAll","options","encodedValue","get","bind","has","signal","JSON","parse","key","NotFoundError","config","value","undefined","set","String","Error","Uint8Array","add","_maybeDoSet","replace","exists","m","aborted","_saveAll","buf","stringify","put"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-repo/src/config.js"],"sourcesContent":["'use strict'\n\nconst { Key } = require('interface-datastore')\nconst { default: Queue } = require('p-queue')\nconst _get = require('just-safe-get')\nconst _set = require('just-safe-set')\nconst errCode = require('err-code')\nconst errors = require('./errors')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst {\n  hasWithFallback,\n  getWithFallback\n// @ts-ignore\n} = require('ipfs-repo-migrations/src/utils')\n\nconst configKey = new Key('config')\n\n/**\n * @typedef {import('./types').Config} Config\n */\n\n/**\n * @param {import('interface-datastore').Datastore} store\n */\nmodule.exports = (store) => {\n  const setQueue = new Queue({ concurrency: 1 })\n\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     * @returns {Promise<Config>}\n     */\n    async getAll (options = {}) { // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      const encodedValue = await getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store, {\n        signal: options.signal\n      })\n\n      return JSON.parse(uint8ArrayToString(encodedValue))\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {string} key - the config key to get\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     */\n    async get (key, options = {}) {\n      if (key == null) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`)\n      }\n\n      const config = await this.getAll(options)\n      const value = _get(config, key)\n\n      if (value === undefined) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`)\n      }\n\n      return value\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {string} key - the config key to be written\n     * @param {any} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    set (key, value, options = {}) {\n      // @ts-ignore ts thinks key will only be a string, but it may not be\n      if (typeof key !== 'string' && !(key instanceof String)) {\n        throw errCode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY')\n      }\n\n      if (value === undefined || (value instanceof Uint8Array)) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Config} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    replace (value, options = {}) {\n      if (!value || (value instanceof Uint8Array)) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     */\n    async exists () { // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      return hasWithFallback(configKey, store.has.bind(store), store)\n    }\n  }\n\n  return configStore\n\n  /**\n   * @param {{ key: any; value: any; }} m\n   * @param {AbortSignal | undefined} signal\n   */\n  async function _maybeDoSet (m, signal) {\n    if (signal && signal.aborted) {\n      return\n    }\n\n    const key = m.key\n    const value = m.value\n    if (key) {\n      const config = await configStore.getAll()\n      if (typeof config === 'object' && config !== null) {\n        _set(config, key, value)\n      }\n      return _saveAll(config)\n    }\n    return _saveAll(value)\n  }\n\n  /**\n   * @param {unknown} config\n   */\n  function _saveAll (config) {\n    const buf = uint8ArrayFromString(JSON.stringify(config, null, 2))\n    return store.put(configKey, buf)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}