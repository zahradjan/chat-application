{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _toArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toArray.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar isIpfs = require('is-ipfs');\n\nvar _require = require('multiformats/cid'),\n    CID = _require.CID;\n\nvar PeerID = require('peer-id');\n\nvar withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nvar _require2 = require('../utils'),\n    res = _require2.resolve;\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-utils/src/multibases')} config.bases\n * @param {import('ipfs-core-types/src/name').API} config.name\n */\n\n\nmodule.exports = function (_ref) {\n  var repo = _ref.repo,\n      codecs = _ref.codecs,\n      bases = _ref.bases,\n      name = _ref.name;\n\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"resolve\"]}\n   */\n  function resolve(_x) {\n    return _resolve.apply(this, arguments);\n  }\n\n  function _resolve() {\n    _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(path) {\n      var opts,\n          _iteratorAbruptCompletion,\n          _didIteratorError,\n          _iteratorError,\n          _iterator,\n          _step,\n          resolvedPath,\n          _path$split,\n          _path$split2,\n          schema,\n          hash,\n          rest,\n          base,\n          bytes,\n          str,\n          cid,\n          results,\n          value,\n          remainderPath,\n          _iteratorAbruptCompletion2,\n          _didIteratorError2,\n          _iteratorError2,\n          _iterator2,\n          _step2,\n          result,\n          _args = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n              if (isIpfs.path(path)) {\n                _context.next = 3;\n                break;\n              }\n\n              throw new Error('invalid argument ' + path);\n\n            case 3:\n              if (!isIpfs.ipnsPath(path)) {\n                _context.next = 32;\n                break;\n              }\n\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context.prev = 6;\n              _iterator = _asyncIterator(name.resolve(path, opts));\n\n            case 8:\n              _context.next = 10;\n              return _iterator.next();\n\n            case 10:\n              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                _context.next = 16;\n                break;\n              }\n\n              resolvedPath = _step.value;\n              path = resolvedPath;\n\n            case 13:\n              _iteratorAbruptCompletion = false;\n              _context.next = 8;\n              break;\n\n            case 16:\n              _context.next = 22;\n              break;\n\n            case 18:\n              _context.prev = 18;\n              _context.t0 = _context[\"catch\"](6);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 22:\n              _context.prev = 22;\n              _context.prev = 23;\n\n              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                _context.next = 27;\n                break;\n              }\n\n              _context.next = 27;\n              return _iterator.return();\n\n            case 27:\n              _context.prev = 27;\n\n              if (!_didIteratorError) {\n                _context.next = 30;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 30:\n              return _context.finish(27);\n\n            case 31:\n              return _context.finish(22);\n\n            case 32:\n              _path$split = path.split('/'), _path$split2 = _toArray(_path$split), schema = _path$split2[1], hash = _path$split2[2], rest = _path$split2.slice(3); // ['', 'ipfs', 'hash', ...path]\n\n              if (!opts.cidBase) {\n                _context.next = 39;\n                break;\n              }\n\n              _context.next = 36;\n              return bases.getBase(opts.cidBase);\n\n            case 36:\n              _context.t1 = _context.sent;\n              _context.next = 40;\n              break;\n\n            case 39:\n              _context.t1 = undefined;\n\n            case 40:\n              base = _context.t1;\n              bytes = parseBytes(hash); // nothing to resolve return the input\n\n              if (!(rest.length === 0)) {\n                _context.next = 45;\n                break;\n              }\n\n              str = base ? base.encoder.encode(bytes) : hash;\n              return _context.abrupt(\"return\", \"/\".concat(schema, \"/\").concat(str));\n\n            case 45:\n              cid = CID.decode(bytes);\n              path = rest.join('/');\n              results = res(cid, path, codecs, repo, opts);\n              value = cid;\n              remainderPath = path;\n              _iteratorAbruptCompletion2 = false;\n              _didIteratorError2 = false;\n              _context.prev = 52;\n              _iterator2 = _asyncIterator(results);\n\n            case 54:\n              _context.next = 56;\n              return _iterator2.next();\n\n            case 56:\n              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context.sent).done)) {\n                _context.next = 62;\n                break;\n              }\n\n              result = _step2.value;\n\n              if (CID.asCID(result.value)) {\n                value = result.value;\n                remainderPath = result.remainderPath;\n              }\n\n            case 59:\n              _iteratorAbruptCompletion2 = false;\n              _context.next = 54;\n              break;\n\n            case 62:\n              _context.next = 68;\n              break;\n\n            case 64:\n              _context.prev = 64;\n              _context.t2 = _context[\"catch\"](52);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context.t2;\n\n            case 68:\n              _context.prev = 68;\n              _context.prev = 69;\n\n              if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                _context.next = 73;\n                break;\n              }\n\n              _context.next = 73;\n              return _iterator2.return();\n\n            case 73:\n              _context.prev = 73;\n\n              if (!_didIteratorError2) {\n                _context.next = 76;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 76:\n              return _context.finish(73);\n\n            case 77:\n              return _context.finish(68);\n\n            case 78:\n              return _context.abrupt(\"return\", \"/ipfs/\".concat(value.toString(base && base.encoder)).concat(remainderPath ? '/' + remainderPath : ''));\n\n            case 79:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[6, 18, 22, 32], [23,, 27, 31], [52, 64, 68, 78], [69,, 73, 77]]);\n    }));\n    return _resolve.apply(this, arguments);\n  }\n\n  return withTimeoutOption(resolve);\n};\n/**\n * Parse the input as a PeerID or a CID or throw an error\n *\n * @param {string} str\n */\n\n\nfunction parseBytes(str) {\n  try {\n    return PeerID.parse(str).toBytes();\n  } catch (_unused) {\n    return CID.parse(str).bytes;\n  }\n}","map":{"version":3,"names":["isIpfs","require","CID","PeerID","withTimeoutOption","res","resolve","module","exports","repo","codecs","bases","name","path","opts","Error","ipnsPath","resolvedPath","split","schema","hash","rest","cidBase","getBase","undefined","base","bytes","parseBytes","length","str","encoder","encode","cid","decode","join","results","value","remainderPath","result","asCID","toString","parse","toBytes"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/resolve.js"],"sourcesContent":["'use strict'\n\nconst isIpfs = require('is-ipfs')\nconst { CID } = require('multiformats/cid')\nconst PeerID = require('peer-id')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { resolve: res } = require('../utils')\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-utils/src/multibases')} config.bases\n * @param {import('ipfs-core-types/src/name').API} config.name\n */\nmodule.exports = ({ repo, codecs, bases, name }) => {\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"resolve\"]}\n   */\n  async function resolve (path, opts = {}) {\n    if (!isIpfs.path(path)) {\n      throw new Error('invalid argument ' + path)\n    }\n\n    if (isIpfs.ipnsPath(path)) {\n      for await (const resolvedPath of name.resolve(path, opts)) {\n        path = resolvedPath\n      }\n    }\n\n    const [, schema, hash, ...rest] = path.split('/') // ['', 'ipfs', 'hash', ...path]\n    const base = opts.cidBase ? await bases.getBase(opts.cidBase) : undefined\n    const bytes = parseBytes(hash)\n\n    // nothing to resolve return the input\n    if (rest.length === 0) {\n      const str = base ? base.encoder.encode(bytes) : hash\n\n      return `/${schema}/${str}`\n    }\n\n    const cid = CID.decode(bytes)\n\n    path = rest.join('/')\n\n    const results = res(cid, path, codecs, repo, opts)\n    let value = cid\n    let remainderPath = path\n\n    for await (const result of results) {\n      if (CID.asCID(result.value)) {\n        value = result.value\n        remainderPath = result.remainderPath\n      }\n    }\n\n    return `/ipfs/${value.toString(base && base.encoder)}${remainderPath ? '/' + remainderPath : ''}`\n  }\n\n  return withTimeoutOption(resolve)\n}\n\n/**\n * Parse the input as a PeerID or a CID or throw an error\n *\n * @param {string} str\n */\nfunction parseBytes (str) {\n  try {\n    return PeerID.parse(str).toBytes()\n  } catch {\n    return CID.parse(str).bytes\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}