{"ast":null,"code":"'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst cbor = require('cborg');\n\nconst pinset = require('./pin-set');\n\nconst {\n  cidToKey,\n  PIN_DS_KEY,\n  PinTypes\n} = require('./utils');\n\nconst length = require('it-length');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst mhd = require('multiformats/hashes/digest');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('../../src/types').MigrationProgressCallback} MigrationProgressCallback\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n */\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\n\n\nasync function pinsToDatastore(blockstore, datastore, pinstore, onProgress) {\n  if (!(await datastore.has(PIN_DS_KEY))) {\n    return;\n  }\n\n  const mh = await datastore.get(PIN_DS_KEY);\n  const cid = CID.decode(mh);\n  const pinRootBuf = await blockstore.get(cid);\n  const pinRoot = dagPb.decode(pinRootBuf);\n  let counter = 0;\n  const pinCount = (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.recursive))) + (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.direct)));\n\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.recursive)) {\n    counter++;\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n\n    const pin = {\n      depth: Infinity\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n\n    await pinstore.put(cidToKey(cid), cbor.encode(pin));\n    onProgress(counter / pinCount * 100, `Migrated recursive pin ${cid}`);\n  }\n\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.direct)) {\n    counter++;\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n\n    const pin = {\n      depth: 0\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n\n    await pinstore.put(cidToKey(cid), cbor.encode(pin));\n    onProgress(counter / pinCount * 100, `Migrated direct pin ${cid}`);\n  }\n\n  await blockstore.delete(cid);\n  await datastore.delete(PIN_DS_KEY);\n}\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\n\n\nasync function pinsToDAG(blockstore, datastore, pinstore, onProgress) {\n  const recursivePins = [];\n  const directPins = [];\n  let counter = 0;\n  const pinCount = await length(pinstore.queryKeys({}));\n\n  for await (const {\n    key,\n    value\n  } of pinstore.query({})) {\n    counter++;\n    const pin = cbor.decode(value);\n    const cid = CID.create(pin.version || 0, pin.codec || dagPb.code, mhd.decode(base32.decode('b' + key.toString().toLowerCase().split('/').pop())));\n\n    if (pin.depth === 0) {\n      onProgress(counter / pinCount * 100, `Reverted direct pin ${cid}`);\n      directPins.push(cid);\n    } else {\n      onProgress(counter / pinCount * 100, `Reverted recursive pin ${cid}`);\n      recursivePins.push(cid);\n    }\n  }\n\n  onProgress(100, 'Updating pin root');\n  const pinRoot = {\n    Links: [await pinset.storeSet(blockstore, PinTypes.direct, directPins), await pinset.storeSet(blockstore, PinTypes.recursive, recursivePins)]\n  };\n  const buf = dagPb.encode(pinRoot);\n  const digest = await sha256.digest(buf);\n  const cid = CID.createV0(digest);\n  await blockstore.put(cid, buf);\n  await datastore.put(PIN_DS_KEY, cid.bytes);\n}\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {MigrationProgressCallback} onProgress\n * @param {*} fn\n */\n\n\nasync function process(backends, onProgress, fn) {\n  const blockstore = backends.blocks;\n  const datastore = backends.datastore;\n  const pinstore = backends.pins;\n  await blockstore.open();\n  await datastore.open();\n  await pinstore.open();\n\n  try {\n    await fn(blockstore, datastore, pinstore, onProgress);\n  } finally {\n    await pinstore.close();\n    await datastore.close();\n    await blockstore.close();\n  }\n}\n/** @type {Migration} */\n\n\nmodule.exports = {\n  version: 9,\n  description: 'Migrates pins to datastore',\n  migrate: function (backends) {\n    let onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n    return process(backends, onProgress, pinsToDatastore);\n  },\n  revert: function (backends) {\n    let onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n    return process(backends, onProgress, pinsToDAG);\n  }\n};","map":{"version":3,"names":["CID","require","dagPb","cbor","pinset","cidToKey","PIN_DS_KEY","PinTypes","length","sha256","mhd","base32","pinsToDatastore","blockstore","datastore","pinstore","onProgress","has","mh","get","cid","decode","pinRootBuf","pinRoot","counter","pinCount","loadSet","recursive","direct","pin","depth","Infinity","version","code","codec","put","encode","delete","pinsToDAG","recursivePins","directPins","queryKeys","key","value","query","create","toString","toLowerCase","split","pop","push","Links","storeSet","buf","digest","createV0","bytes","process","backends","fn","blocks","pins","open","close","module","exports","description","migrate","revert"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-repo-migrations/migrations/migration-9/index.js"],"sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst dagPb = require('@ipld/dag-pb')\nconst cbor = require('cborg')\nconst pinset = require('./pin-set')\nconst { cidToKey, PIN_DS_KEY, PinTypes } = require('./utils')\nconst length = require('it-length')\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst mhd = require('multiformats/hashes/digest')\nconst { base32 } = require('multiformats/bases/base32')\n\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('../../src/types').MigrationProgressCallback} MigrationProgressCallback\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n */\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\nasync function pinsToDatastore (blockstore, datastore, pinstore, onProgress) {\n  if (!await datastore.has(PIN_DS_KEY)) {\n    return\n  }\n\n  const mh = await datastore.get(PIN_DS_KEY)\n  const cid = CID.decode(mh)\n  const pinRootBuf = await blockstore.get(cid)\n  const pinRoot = dagPb.decode(pinRootBuf)\n  let counter = 0\n  const pinCount = (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.recursive))) + (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.direct)))\n\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.recursive)) {\n    counter++\n\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n    const pin = {\n      depth: Infinity\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    await pinstore.put(cidToKey(cid), cbor.encode(pin))\n\n    onProgress((counter / pinCount) * 100, `Migrated recursive pin ${cid}`)\n  }\n\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.direct)) {\n    counter++\n\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n    const pin = {\n      depth: 0\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    await pinstore.put(cidToKey(cid), cbor.encode(pin))\n\n    onProgress((counter / pinCount) * 100, `Migrated direct pin ${cid}`)\n  }\n\n  await blockstore.delete(cid)\n  await datastore.delete(PIN_DS_KEY)\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\nasync function pinsToDAG (blockstore, datastore, pinstore, onProgress) {\n  const recursivePins = []\n  const directPins = []\n  let counter = 0\n  const pinCount = await length(pinstore.queryKeys({}))\n\n  for await (const { key, value } of pinstore.query({})) {\n    counter++\n    const pin = cbor.decode(value)\n    const cid = CID.create(\n      pin.version || 0,\n      pin.codec || dagPb.code,\n      mhd.decode(base32.decode('b' + key.toString().toLowerCase().split('/').pop()))\n    )\n\n    if (pin.depth === 0) {\n      onProgress((counter / pinCount) * 100, `Reverted direct pin ${cid}`)\n\n      directPins.push(cid)\n    } else {\n      onProgress((counter / pinCount) * 100, `Reverted recursive pin ${cid}`)\n\n      recursivePins.push(cid)\n    }\n  }\n\n  onProgress(100, 'Updating pin root')\n  const pinRoot = {\n    Links: [\n      await pinset.storeSet(blockstore, PinTypes.direct, directPins),\n      await pinset.storeSet(blockstore, PinTypes.recursive, recursivePins)\n    ]\n  }\n  const buf = dagPb.encode(pinRoot)\n  const digest = await sha256.digest(buf)\n  const cid = CID.createV0(digest)\n\n  await blockstore.put(cid, buf)\n  await datastore.put(PIN_DS_KEY, cid.bytes)\n}\n\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {MigrationProgressCallback} onProgress\n * @param {*} fn\n */\nasync function process (backends, onProgress, fn) {\n  const blockstore = backends.blocks\n  const datastore = backends.datastore\n  const pinstore = backends.pins\n\n  await blockstore.open()\n  await datastore.open()\n  await pinstore.open()\n\n  try {\n    await fn(blockstore, datastore, pinstore, onProgress)\n  } finally {\n    await pinstore.close()\n    await datastore.close()\n    await blockstore.close()\n  }\n}\n\n/** @type {Migration} */\nmodule.exports = {\n  version: 9,\n  description: 'Migrates pins to datastore',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDatastore)\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDAG)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}