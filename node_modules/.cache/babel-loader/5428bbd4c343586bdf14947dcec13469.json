{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _assertThisInitialized = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('libp2p:persistent-peer-store'), {\n  error: debug('libp2p:persistent-peer-store:err')\n});\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar _require2 = require('multiaddr'),\n    Multiaddr = _require2.Multiaddr;\n\nvar PeerId = require('peer-id');\n\nvar _require3 = require('multiformats/bases/base32'),\n    base32 = _require3.base32;\n\nvar PeerStore = require('..');\n\nvar _require4 = require('./consts'),\n    NAMESPACE_ADDRESS = _require4.NAMESPACE_ADDRESS,\n    NAMESPACE_COMMON = _require4.NAMESPACE_COMMON,\n    NAMESPACE_KEYS = _require4.NAMESPACE_KEYS,\n    NAMESPACE_METADATA = _require4.NAMESPACE_METADATA,\n    NAMESPACE_PROTOCOL = _require4.NAMESPACE_PROTOCOL;\n\nvar _require5 = require('./pb/address-book'),\n    Addresses = _require5.Addresses;\n\nvar _require6 = require('./pb/proto-book'),\n    Protocols = _require6.Protocols;\n/**\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('../address-book.js').Address} Address\n */\n\n/**\n * @typedef {Object} PersistentPeerStoreProperties\n * @property {PeerId} peerId\n * @property {import('interface-datastore').Datastore} datastore\n *\n * @typedef {Object} PersistentPeerStoreOptions\n * @property {number} [threshold = 5] - Number of dirty peers allowed before commit data.\n */\n\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\n\n\nvar PersistentPeerStore = /*#__PURE__*/function (_PeerStore) {\n  _inherits(PersistentPeerStore, _PeerStore);\n\n  var _super = _createSuper(PersistentPeerStore);\n\n  /**\n   * @class\n   * @param {PersistentPeerStoreProperties & PersistentPeerStoreOptions} properties\n   */\n  function PersistentPeerStore(_ref) {\n    var _this;\n\n    var peerId = _ref.peerId,\n        datastore = _ref.datastore,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === void 0 ? 5 : _ref$threshold;\n\n    _classCallCheck(this, PersistentPeerStore);\n\n    _this = _super.call(this, {\n      peerId: peerId\n    });\n    /**\n     * Backend datastore used to persist data.\n     */\n\n    _this._datastore = datastore;\n    /**\n     * Peers modified after the latest data persisted.\n     */\n\n    _this._dirtyPeers = new Set();\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    _this._dirtyMetadata = new Map();\n    _this.threshold = threshold;\n    _this._addDirtyPeer = _this._addDirtyPeer.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Start Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  _createClass(PersistentPeerStore, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                log('PeerStore is starting'); // Handlers for dirty peers\n\n                this.on('change:protocols', this._addDirtyPeer);\n                this.on('change:multiaddrs', this._addDirtyPeer);\n                this.on('change:pubkey', this._addDirtyPeerKey);\n                this.on('change:metadata', this._addDirtyPeerMetadata); // Load data\n\n                _iteratorAbruptCompletion = false;\n                _didIteratorError = false;\n                _context.prev = 7;\n                _iterator = _asyncIterator(this._datastore.query({\n                  prefix: NAMESPACE_COMMON\n                }));\n\n              case 9:\n                _context.next = 11;\n                return _iterator.next();\n\n              case 11:\n                if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                  _context.next = 18;\n                  break;\n                }\n\n                entry = _step.value;\n                _context.next = 15;\n                return this._processDatastoreEntry(entry);\n\n              case 15:\n                _iteratorAbruptCompletion = false;\n                _context.next = 9;\n                break;\n\n              case 18:\n                _context.next = 24;\n                break;\n\n              case 20:\n                _context.prev = 20;\n                _context.t0 = _context[\"catch\"](7);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 24:\n                _context.prev = 24;\n                _context.prev = 25;\n\n                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                  _context.next = 29;\n                  break;\n                }\n\n                _context.next = 29;\n                return _iterator.return();\n\n              case 29:\n                _context.prev = 29;\n\n                if (!_didIteratorError) {\n                  _context.next = 32;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 32:\n                return _context.finish(29);\n\n              case 33:\n                return _context.finish(24);\n\n              case 34:\n                log('PeerStore started');\n\n              case 35:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 20, 24, 34], [25,, 29, 33]]);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * Stop Persistent PeerStore.\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                log('PeerStore is stopping');\n                this.removeAllListeners();\n                _context2.next = 4;\n                return this._commitData();\n\n              case 4:\n                log('PeerStore stopped');\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * Add modified peer to the dirty set\n     *\n     * @private\n     * @param {Object} params\n     * @param {PeerId} params.peerId\n     */\n\n  }, {\n    key: \"_addDirtyPeer\",\n    value: function _addDirtyPeer(_ref2) {\n      var peerId = _ref2.peerId;\n      var peerIdstr = peerId.toB58String();\n      log('add dirty peer', peerIdstr);\n\n      this._dirtyPeers.add(peerIdstr);\n\n      if (this._dirtyPeers.size >= this.threshold) {\n        // Commit current data\n        this._commitData().catch(function (err) {\n          log.error('error committing data', err);\n        });\n      }\n    }\n    /**\n     * Add modified peer key to the dirty set\n     *\n     * @private\n     * @param {Object} params\n     * @param {PeerId} params.peerId\n     */\n\n  }, {\n    key: \"_addDirtyPeerKey\",\n    value: function _addDirtyPeerKey(_ref3) {\n      var peerId = _ref3.peerId;\n\n      // Not add if inline key available\n      if (peerId.hasInlinePublicKey()) {\n        return;\n      }\n\n      var peerIdstr = peerId.toB58String();\n      log('add dirty peer key', peerIdstr);\n\n      this._dirtyPeers.add(peerIdstr);\n\n      if (this._dirtyPeers.size >= this.threshold) {\n        // Commit current data\n        this._commitData().catch(function (err) {\n          log.error('error committing data', err);\n        });\n      }\n    }\n    /**\n     * Add modified metadata peer to the set.\n     *\n     * @private\n     * @param {Object} params\n     * @param {PeerId} params.peerId\n     * @param {string} params.metadata\n     */\n\n  }, {\n    key: \"_addDirtyPeerMetadata\",\n    value: function _addDirtyPeerMetadata(_ref4) {\n      var peerId = _ref4.peerId,\n          metadata = _ref4.metadata;\n      var peerIdstr = peerId.toB58String();\n      log('add dirty metadata peer', peerIdstr);\n\n      this._dirtyPeers.add(peerIdstr); // Add dirty metadata key\n\n\n      var mData = this._dirtyMetadata.get(peerIdstr) || new Set();\n      mData.add(metadata);\n\n      this._dirtyMetadata.set(peerIdstr, mData);\n\n      if (this._dirtyPeers.size >= this.threshold) {\n        // Commit current data\n        this._commitData().catch(function (err) {\n          log.error('error committing data', err);\n        });\n      }\n    }\n    /**\n     * Add all the peers current data to a datastore batch and commit it.\n     *\n     * @private\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_commitData\",\n    value: function () {\n      var _commitData2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var commitPeers, batch, _i, _commitPeers, peerIdStr, peerId;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                commitPeers = Array.from(this._dirtyPeers);\n\n                if (commitPeers.length) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 3:\n                // Clear Dirty Peers set\n                this._dirtyPeers.clear();\n\n                log('create batch commit');\n                batch = this._datastore.batch();\n\n                for (_i = 0, _commitPeers = commitPeers; _i < _commitPeers.length; _i++) {\n                  peerIdStr = _commitPeers[_i];\n                  // PeerId\n                  peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromB58String(peerIdStr); // Address Book\n\n                  this._batchAddressBook(peerId, batch); // Key Book\n\n\n                  !peerId.hasInlinePublicKey() && this._batchKeyBook(peerId, batch); // Metadata Book\n\n                  this._batchMetadataBook(peerId, batch); // Proto Book\n\n\n                  this._batchProtoBook(peerId, batch);\n                }\n\n                _context3.next = 9;\n                return batch.commit();\n\n              case 9:\n                log('batch committed');\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _commitData() {\n        return _commitData2.apply(this, arguments);\n      }\n\n      return _commitData;\n    }()\n    /**\n     * Add address book data of the peer to the batch.\n     *\n     * @private\n     * @param {PeerId} peerId\n     * @param {Batch} batch\n     */\n\n  }, {\n    key: \"_batchAddressBook\",\n    value: function _batchAddressBook(peerId, batch) {\n      var b32key = peerId.toString();\n      var key = new Key(\"\".concat(NAMESPACE_ADDRESS).concat(b32key));\n      var entry = this.addressBook.data.get(peerId.toB58String());\n\n      try {\n        // Deleted from the book\n        if (!entry) {\n          batch.delete(key);\n          return;\n        }\n\n        var encodedData = Addresses.encode({\n          addrs: entry.addresses.map(function (address) {\n            return {\n              multiaddr: address.multiaddr.bytes,\n              isCertified: address.isCertified\n            };\n          }),\n          certifiedRecord: entry.record ? {\n            seq: entry.record.seqNumber,\n            raw: entry.record.raw\n          } : undefined\n        }).finish();\n        batch.put(key, encodedData);\n      } catch (err) {\n        log.error(err);\n      }\n    }\n    /**\n     * Add Key book data of the peer to the batch.\n     *\n     * @private\n     * @param {PeerId} peerId\n     * @param {Batch} batch\n     */\n\n  }, {\n    key: \"_batchKeyBook\",\n    value: function _batchKeyBook(peerId, batch) {\n      var b32key = peerId.toString();\n      var key = new Key(\"\".concat(NAMESPACE_KEYS).concat(b32key));\n\n      try {\n        // Deleted from the book\n        if (!peerId.pubKey) {\n          batch.delete(key);\n          return;\n        }\n\n        var encodedData = peerId.marshalPubKey();\n        batch.put(key, encodedData);\n      } catch (err) {\n        log.error(err);\n      }\n    }\n    /**\n     * Add metadata book data of the peer to the batch.\n     *\n     * @private\n     * @param {PeerId} peerId\n     * @param {Batch} batch\n     */\n\n  }, {\n    key: \"_batchMetadataBook\",\n    value: function _batchMetadataBook(peerId, batch) {\n      var _this2 = this;\n\n      var b32key = peerId.toString();\n      var dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || [];\n\n      try {\n        dirtyMetada.forEach(function (\n        /** @type {string} */\n        dirtyKey) {\n          var key = new Key(\"\".concat(NAMESPACE_METADATA).concat(b32key, \"/\").concat(dirtyKey));\n\n          var dirtyValue = _this2.metadataBook.getValue(peerId, dirtyKey);\n\n          if (dirtyValue) {\n            batch.put(key, dirtyValue);\n          } else {\n            batch.delete(key);\n          }\n        });\n      } catch (err) {\n        log.error(err);\n      }\n    }\n    /**\n     * Add proto book data of the peer to the batch.\n     *\n     * @private\n     * @param {PeerId} peerId\n     * @param {Batch} batch\n     */\n\n  }, {\n    key: \"_batchProtoBook\",\n    value: function _batchProtoBook(peerId, batch) {\n      var b32key = peerId.toString();\n      var key = new Key(\"\".concat(NAMESPACE_PROTOCOL).concat(b32key));\n      var protocols = this.protoBook.get(peerId);\n\n      try {\n        // Deleted from the book\n        if (!protocols) {\n          batch.delete(key);\n          return;\n        }\n\n        var encodedData = Protocols.encode({\n          protocols: protocols\n        }).finish();\n        batch.put(key, encodedData);\n      } catch (err) {\n        log.error(err);\n      }\n    }\n    /**\n     * Process datastore entry and add its data to the correct book.\n     *\n     * @private\n     * @param {Object} params\n     * @param {Key} params.key - datastore key\n     * @param {Uint8Array} params.value - datastore value stored\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_processDatastoreEntry\",\n    value: function () {\n      var _processDatastoreEntry2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref5) {\n        var key, value, keyParts, peerId, decoded;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                key = _ref5.key, value = _ref5.value;\n                _context4.prev = 1;\n                keyParts = key.toString().split('/');\n                peerId = PeerId.createFromBytes(base32.decode(keyParts[3]));\n                _context4.t0 = keyParts[2];\n                _context4.next = _context4.t0 === 'addrs' ? 7 : _context4.t0 === 'keys' ? 10 : _context4.t0 === 'metadata' ? 15 : _context4.t0 === 'protos' ? 17 : 20;\n                break;\n\n              case 7:\n                decoded = Addresses.decode(value); // @ts-ignore protected function\n\n                this.addressBook._setData(peerId, {\n                  addresses: decoded.addrs.map(function (address) {\n                    return {\n                      multiaddr: new Multiaddr(address.multiaddr),\n                      isCertified: Boolean(address.isCertified)\n                    };\n                  }),\n                  record: decoded.certifiedRecord ? {\n                    raw: decoded.certifiedRecord.raw,\n                    seqNumber: decoded.certifiedRecord.seq\n                  } : undefined\n                }, {\n                  emit: false\n                });\n\n                return _context4.abrupt(\"break\", 21);\n\n              case 10:\n                _context4.next = 12;\n                return PeerId.createFromPubKey(value);\n\n              case 12:\n                decoded = _context4.sent;\n\n                // @ts-ignore protected function\n                this.keyBook._setData(decoded, decoded, {\n                  emit: false\n                });\n\n                return _context4.abrupt(\"break\", 21);\n\n              case 15:\n                this.metadataBook._setValue(peerId, keyParts[4], value, {\n                  emit: false\n                });\n\n                return _context4.abrupt(\"break\", 21);\n\n              case 17:\n                decoded = Protocols.decode(value); // @ts-ignore protected function\n\n                this.protoBook._setData(peerId, new Set(decoded.protocols), {\n                  emit: false\n                });\n\n                return _context4.abrupt(\"break\", 21);\n\n              case 20:\n                log('invalid data persisted for: ', key.toString());\n\n              case 21:\n                _context4.next = 26;\n                break;\n\n              case 23:\n                _context4.prev = 23;\n                _context4.t1 = _context4[\"catch\"](1);\n                log.error(_context4.t1);\n\n              case 26:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[1, 23]]);\n      }));\n\n      function _processDatastoreEntry(_x) {\n        return _processDatastoreEntry2.apply(this, arguments);\n      }\n\n      return _processDatastoreEntry;\n    }()\n  }]);\n\n  return PersistentPeerStore;\n}(PeerStore);\n\nmodule.exports = PersistentPeerStore;","map":{"version":3,"names":["debug","require","log","Object","assign","error","Key","Multiaddr","PeerId","base32","PeerStore","NAMESPACE_ADDRESS","NAMESPACE_COMMON","NAMESPACE_KEYS","NAMESPACE_METADATA","NAMESPACE_PROTOCOL","Addresses","Protocols","PersistentPeerStore","peerId","datastore","threshold","_datastore","_dirtyPeers","Set","_dirtyMetadata","Map","_addDirtyPeer","bind","on","_addDirtyPeerKey","_addDirtyPeerMetadata","query","prefix","entry","_processDatastoreEntry","removeAllListeners","_commitData","peerIdstr","toB58String","add","size","catch","err","hasInlinePublicKey","metadata","mData","get","set","commitPeers","Array","from","length","clear","batch","peerIdStr","keyBook","data","createFromB58String","_batchAddressBook","_batchKeyBook","_batchMetadataBook","_batchProtoBook","commit","b32key","toString","key","addressBook","delete","encodedData","encode","addrs","addresses","map","address","multiaddr","bytes","isCertified","certifiedRecord","record","seq","seqNumber","raw","undefined","finish","put","pubKey","marshalPubKey","dirtyMetada","forEach","dirtyKey","dirtyValue","metadataBook","getValue","protocols","protoBook","value","keyParts","split","createFromBytes","decode","decoded","_setData","Boolean","emit","createFromPubKey","_setValue","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/peer-store/persistent/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:persistent-peer-store'), {\n  error: debug('libp2p:persistent-peer-store:err')\n})\nconst { Key } = require('interface-datastore')\nconst { Multiaddr } = require('multiaddr')\nconst PeerId = require('peer-id')\nconst { base32 } = require('multiformats/bases/base32')\n\nconst PeerStore = require('..')\n\nconst {\n  NAMESPACE_ADDRESS,\n  NAMESPACE_COMMON,\n  NAMESPACE_KEYS,\n  NAMESPACE_METADATA,\n  NAMESPACE_PROTOCOL\n} = require('./consts')\n\nconst { Addresses } = require('./pb/address-book')\nconst { Protocols } = require('./pb/proto-book')\n\n/**\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('../address-book.js').Address} Address\n */\n\n/**\n * @typedef {Object} PersistentPeerStoreProperties\n * @property {PeerId} peerId\n * @property {import('interface-datastore').Datastore} datastore\n *\n * @typedef {Object} PersistentPeerStoreOptions\n * @property {number} [threshold = 5] - Number of dirty peers allowed before commit data.\n */\n\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\nclass PersistentPeerStore extends PeerStore {\n  /**\n   * @class\n   * @param {PersistentPeerStoreProperties & PersistentPeerStoreOptions} properties\n   */\n  constructor ({ peerId, datastore, threshold = 5 }) {\n    super({ peerId })\n\n    /**\n     * Backend datastore used to persist data.\n     */\n    this._datastore = datastore\n\n    /**\n     * Peers modified after the latest data persisted.\n     */\n    this._dirtyPeers = new Set()\n\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     *\n     * @type {Map<string, Set<string>>}\n     */\n    this._dirtyMetadata = new Map()\n\n    this.threshold = threshold\n    this._addDirtyPeer = this._addDirtyPeer.bind(this)\n  }\n\n  /**\n   * Start Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n  async start () {\n    log('PeerStore is starting')\n\n    // Handlers for dirty peers\n    this.on('change:protocols', this._addDirtyPeer)\n    this.on('change:multiaddrs', this._addDirtyPeer)\n    this.on('change:pubkey', this._addDirtyPeerKey)\n    this.on('change:metadata', this._addDirtyPeerMetadata)\n\n    // Load data\n    for await (const entry of this._datastore.query({ prefix: NAMESPACE_COMMON })) {\n      await this._processDatastoreEntry(entry)\n    }\n\n    log('PeerStore started')\n  }\n\n  /**\n   * Stop Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n  async stop () {\n    log('PeerStore is stopping')\n    this.removeAllListeners()\n    await this._commitData()\n    log('PeerStore stopped')\n  }\n\n  /**\n   * Add modified peer to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n  _addDirtyPeer ({ peerId }) {\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty peer', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add modified peer key to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n  _addDirtyPeerKey ({ peerId }) {\n    // Not add if inline key available\n    if (peerId.hasInlinePublicKey()) {\n      return\n    }\n\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty peer key', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add modified metadata peer to the set.\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {string} params.metadata\n   */\n  _addDirtyPeerMetadata ({ peerId, metadata }) {\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty metadata peer', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    // Add dirty metadata key\n    const mData = this._dirtyMetadata.get(peerIdstr) || new Set()\n    mData.add(metadata)\n    this._dirtyMetadata.set(peerIdstr, mData)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add all the peers current data to a datastore batch and commit it.\n   *\n   * @private\n   * @returns {Promise<void>}\n   */\n  async _commitData () {\n    const commitPeers = Array.from(this._dirtyPeers)\n\n    if (!commitPeers.length) {\n      return\n    }\n\n    // Clear Dirty Peers set\n    this._dirtyPeers.clear()\n\n    log('create batch commit')\n    const batch = this._datastore.batch()\n    for (const peerIdStr of commitPeers) {\n      // PeerId\n      const peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromB58String(peerIdStr)\n\n      // Address Book\n      this._batchAddressBook(peerId, batch)\n\n      // Key Book\n      !peerId.hasInlinePublicKey() && this._batchKeyBook(peerId, batch)\n\n      // Metadata Book\n      this._batchMetadataBook(peerId, batch)\n\n      // Proto Book\n      this._batchProtoBook(peerId, batch)\n    }\n\n    await batch.commit()\n    log('batch committed')\n  }\n\n  /**\n   * Add address book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n  _batchAddressBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_ADDRESS}${b32key}`)\n\n    const entry = this.addressBook.data.get(peerId.toB58String())\n\n    try {\n      // Deleted from the book\n      if (!entry) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = Addresses.encode({\n        addrs: entry.addresses.map((address) => ({\n          multiaddr: address.multiaddr.bytes,\n          isCertified: address.isCertified\n        })),\n        certifiedRecord: entry.record\n          ? {\n              seq: entry.record.seqNumber,\n              raw: entry.record.raw\n            }\n          : undefined\n      }).finish()\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add Key book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n  _batchKeyBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_KEYS}${b32key}`)\n\n    try {\n      // Deleted from the book\n      if (!peerId.pubKey) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = peerId.marshalPubKey()\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add metadata book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n  _batchMetadataBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || []\n\n    try {\n      dirtyMetada.forEach((/** @type {string} */ dirtyKey) => {\n        const key = new Key(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`)\n        const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey)\n\n        if (dirtyValue) {\n          batch.put(key, dirtyValue)\n        } else {\n          batch.delete(key)\n        }\n      })\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add proto book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n  _batchProtoBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_PROTOCOL}${b32key}`)\n\n    const protocols = this.protoBook.get(peerId)\n\n    try {\n      // Deleted from the book\n      if (!protocols) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = Protocols.encode({ protocols }).finish()\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Process datastore entry and add its data to the correct book.\n   *\n   * @private\n   * @param {Object} params\n   * @param {Key} params.key - datastore key\n   * @param {Uint8Array} params.value - datastore value stored\n   * @returns {Promise<void>}\n   */\n  async _processDatastoreEntry ({ key, value }) {\n    try {\n      const keyParts = key.toString().split('/')\n      const peerId = PeerId.createFromBytes(base32.decode(keyParts[3]))\n\n      let decoded\n      switch (keyParts[2]) {\n        case 'addrs':\n          decoded = Addresses.decode(value)\n\n          // @ts-ignore protected function\n          this.addressBook._setData(\n            peerId,\n            {\n              addresses: decoded.addrs.map((address) => ({\n                multiaddr: new Multiaddr(address.multiaddr),\n                isCertified: Boolean(address.isCertified)\n              })),\n              record: decoded.certifiedRecord\n                ? {\n                    raw: decoded.certifiedRecord.raw,\n                    seqNumber: decoded.certifiedRecord.seq\n                  }\n                : undefined\n            },\n            { emit: false })\n          break\n        case 'keys':\n          decoded = await PeerId.createFromPubKey(value)\n\n          // @ts-ignore protected function\n          this.keyBook._setData(\n            decoded,\n            decoded,\n            { emit: false })\n          break\n        case 'metadata':\n          this.metadataBook._setValue(\n            peerId,\n            keyParts[4],\n            value,\n            { emit: false })\n          break\n        case 'protos':\n          decoded = Protocols.decode(value)\n\n          // @ts-ignore protected function\n          this.protoBook._setData(\n            peerId,\n            new Set(decoded.protocols),\n            { emit: false })\n          break\n        default:\n          log('invalid data persisted for: ', key.toString())\n      }\n    } catch (err) {\n      log.error(err)\n    }\n  }\n}\n\nmodule.exports = PersistentPeerStore\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}