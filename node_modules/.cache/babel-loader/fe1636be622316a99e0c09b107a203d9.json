{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar path = require('path');\n\nvar Store = require('orbit-db-store');\n\nvar EventStore = require('orbit-db-eventstore');\n\nvar FeedStore = require('orbit-db-feedstore');\n\nvar KeyValueStore = require('orbit-db-kvstore');\n\nvar CounterStore = require('orbit-db-counterstore');\n\nvar DocumentStore = require('orbit-db-docstore');\n\nvar Pubsub = require('orbit-db-pubsub');\n\nvar Cache = require('orbit-db-cache');\n\nvar Keystore = require('orbit-db-keystore');\n\nvar Identities = require('orbit-db-identity-provider');\n\nvar AccessControllers = require('orbit-db-access-controllers');\n\nvar OrbitDBAddress = require('./orbit-db-address');\n\nvar createDBManifest = require('./db-manifest');\n\nvar exchangeHeads = require('./exchange-heads');\n\nvar _require = require('./utils'),\n    isDefined = _require.isDefined,\n    io = _require.io;\n\nvar Storage = require('orbit-db-storage-adapter');\n\nvar migrations = require('./migrations');\n\nvar Logger = require('logplease');\n\nvar logger = Logger.create('orbit-db');\nLogger.setLogLevel('ERROR'); // Mapping for 'database type' -> Class\n\nvar databaseTypes = {\n  counter: CounterStore,\n  eventlog: EventStore,\n  feed: FeedStore,\n  docstore: DocumentStore,\n  keyvalue: KeyValueStore\n};\nvar defaultTimeout = 30000; // 30 seconds\n\nvar OrbitDB = /*#__PURE__*/function () {\n  function OrbitDB(ipfs, identity) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, OrbitDB);\n\n    if (!isDefined(ipfs)) {\n      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n    }\n\n    if (!isDefined(identity)) {\n      throw new Error('identity is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n    }\n\n    this._ipfs = ipfs;\n    this.identity = identity;\n    this.id = options.peerId;\n    this._pubsub = !options.offline ? new (options.broker ? options.broker : Pubsub)(this._ipfs, this.id) : null;\n    this.directory = options.directory || './orbitdb';\n    this.storage = options.storage;\n    this._directConnections = {};\n    this.caches = {};\n    this.caches[this.directory] = {\n      cache: options.cache,\n      handlers: new Set()\n    };\n    this.keystore = options.keystore;\n    this.stores = {}; // AccessControllers module can be passed in to enable\n    // testing with orbit-db-access-controller\n\n    AccessControllers = options.AccessControllers || AccessControllers;\n  }\n\n  _createClass(OrbitDB, [{\n    key: \"cache\",\n    get: function get() {\n      return this.caches[this.directory].cache;\n    }\n  }, {\n    key: \"feed\",\n    value:\n    /* Databases */\n    function () {\n      var _feed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(address) {\n        var options,\n            _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                options = Object.assign({\n                  create: true,\n                  type: 'feed'\n                }, options);\n                return _context.abrupt(\"return\", this.open(address, options));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function feed(_x) {\n        return _feed.apply(this, arguments);\n      }\n\n      return feed;\n    }()\n  }, {\n    key: \"log\",\n    value: function () {\n      var _log = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(address) {\n        var options,\n            _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n                options = Object.assign({\n                  create: true,\n                  type: 'eventlog'\n                }, options);\n                return _context2.abrupt(\"return\", this.open(address, options));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function log(_x2) {\n        return _log.apply(this, arguments);\n      }\n\n      return log;\n    }()\n  }, {\n    key: \"eventlog\",\n    value: function () {\n      var _eventlog = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(address) {\n        var options,\n            _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n                return _context3.abrupt(\"return\", this.log(address, options));\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function eventlog(_x3) {\n        return _eventlog.apply(this, arguments);\n      }\n\n      return eventlog;\n    }()\n  }, {\n    key: \"keyvalue\",\n    value: function () {\n      var _keyvalue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(address) {\n        var options,\n            _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n                options = Object.assign({\n                  create: true,\n                  type: 'keyvalue'\n                }, options);\n                return _context4.abrupt(\"return\", this.open(address, options));\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function keyvalue(_x4) {\n        return _keyvalue.apply(this, arguments);\n      }\n\n      return keyvalue;\n    }()\n  }, {\n    key: \"kvstore\",\n    value: function () {\n      var _kvstore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(address) {\n        var options,\n            _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                options = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};\n                return _context5.abrupt(\"return\", this.keyvalue(address, options));\n\n              case 2:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function kvstore(_x5) {\n        return _kvstore.apply(this, arguments);\n      }\n\n      return kvstore;\n    }()\n  }, {\n    key: \"counter\",\n    value: function () {\n      var _counter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(address) {\n        var options,\n            _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};\n                options = Object.assign({\n                  create: true,\n                  type: 'counter'\n                }, options);\n                return _context6.abrupt(\"return\", this.open(address, options));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function counter(_x6) {\n        return _counter.apply(this, arguments);\n      }\n\n      return counter;\n    }()\n  }, {\n    key: \"docs\",\n    value: function () {\n      var _docs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(address) {\n        var options,\n            _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n                options = Object.assign({\n                  create: true,\n                  type: 'docstore'\n                }, options);\n                return _context7.abrupt(\"return\", this.open(address, options));\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function docs(_x7) {\n        return _docs.apply(this, arguments);\n      }\n\n      return docs;\n    }()\n  }, {\n    key: \"docstore\",\n    value: function () {\n      var _docstore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(address) {\n        var options,\n            _args8 = arguments;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n                return _context8.abrupt(\"return\", this.docs(address, options));\n\n              case 2:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function docstore(_x8) {\n        return _docstore.apply(this, arguments);\n      }\n\n      return docstore;\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var _this = this;\n\n        var removeDirectConnect, databases, _i, _databases, db, caches, _i2, _caches, directory;\n\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                // Close a direct connection and remove it from internal state\n                removeDirectConnect = function removeDirectConnect(e) {\n                  _this._directConnections[e].close();\n\n                  delete _this._directConnections[e];\n                }; // Close all direct connections to peers\n\n\n                Object.keys(this._directConnections).forEach(removeDirectConnect); // Disconnect from pubsub\n\n                if (!this._pubsub) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                _context9.next = 5;\n                return this._pubsub.disconnect();\n\n              case 5:\n                _context9.next = 7;\n                return this.keystore.close();\n\n              case 7:\n                // Close all open databases\n                databases = Object.values(this.stores);\n                _i = 0, _databases = databases;\n\n              case 9:\n                if (!(_i < _databases.length)) {\n                  _context9.next = 17;\n                  break;\n                }\n\n                db = _databases[_i];\n                _context9.next = 13;\n                return db.close();\n\n              case 13:\n                delete this.stores[db.address.toString()];\n\n              case 14:\n                _i++;\n                _context9.next = 9;\n                break;\n\n              case 17:\n                caches = Object.keys(this.caches);\n                _i2 = 0, _caches = caches;\n\n              case 19:\n                if (!(_i2 < _caches.length)) {\n                  _context9.next = 27;\n                  break;\n                }\n\n                directory = _caches[_i2];\n                _context9.next = 23;\n                return this.caches[directory].cache.close();\n\n              case 23:\n                delete this.caches[directory];\n\n              case 24:\n                _i2++;\n                _context9.next = 19;\n                break;\n\n              case 27:\n                // Remove all databases from the state\n                this.stores = {};\n\n              case 28:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n\n      return disconnect;\n    }() // Alias for disconnect()\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.disconnect();\n\n              case 2:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n  }, {\n    key: \"_createCache\",\n    value: function () {\n      var _createCache2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(path) {\n        var cacheStorage;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.storage.createStore(path);\n\n              case 2:\n                cacheStorage = _context11.sent;\n                return _context11.abrupt(\"return\", new Cache(cacheStorage));\n\n              case 4:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function _createCache(_x9) {\n        return _createCache2.apply(this, arguments);\n      }\n\n      return _createCache;\n    }()\n    /* Private methods */\n\n  }, {\n    key: \"_createStore\",\n    value: function () {\n      var _createStore2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(type, address, options) {\n        var Store, accessController, opts, identity, store, addr;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                // Get the type -> class mapping\n                Store = databaseTypes[type];\n\n                if (Store) {\n                  _context12.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Invalid database type '\".concat(type, \"'\"));\n\n              case 3:\n                if (!options.accessControllerAddress) {\n                  _context12.next = 7;\n                  break;\n                }\n\n                _context12.next = 6;\n                return AccessControllers.resolve(this, options.accessControllerAddress, options.accessController);\n\n              case 6:\n                accessController = _context12.sent;\n\n              case 7:\n                opts = Object.assign({\n                  replicate: true\n                }, options, {\n                  accessController: accessController,\n                  cache: options.cache,\n                  onClose: this._onClose.bind(this),\n                  onDrop: this._onDrop.bind(this),\n                  onLoad: this._onLoad.bind(this)\n                });\n                identity = options.identity || this.identity;\n                store = new Store(this._ipfs, identity, address, opts);\n                store.events.on('write', this._onWrite.bind(this)); // ID of the store is the address as a string\n\n                addr = address.toString();\n                this.stores[addr] = store; // Subscribe to pubsub to get updates from peers,\n                // this is what hooks us into the message propagation layer\n                // and the p2p network\n\n                if (!(opts.replicate && this._pubsub)) {\n                  _context12.next = 16;\n                  break;\n                }\n\n                _context12.next = 16;\n                return this._pubsub.subscribe(addr, this._onMessage.bind(this), this._onPeerConnected.bind(this));\n\n              case 16:\n                return _context12.abrupt(\"return\", store);\n\n              case 17:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function _createStore(_x10, _x11, _x12) {\n        return _createStore2.apply(this, arguments);\n      }\n\n      return _createStore;\n    }() // Callback for local writes to the database. We the update to pubsub.\n\n  }, {\n    key: \"_onWrite\",\n    value: function _onWrite(address, entry, heads) {\n      if (!heads) throw new Error(\"'heads' not defined\");\n      if (this._pubsub) this._pubsub.publish(address, heads);\n    } // Callback for receiving a message from the network\n\n  }, {\n    key: \"_onMessage\",\n    value: function () {\n      var _onMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(address, heads, peer) {\n        var store;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                store = this.stores[address];\n                _context13.prev = 1;\n                logger.debug(\"Received \".concat(heads.length, \" heads for '\").concat(address, \"':\\n\"), JSON.stringify(heads.map(function (e) {\n                  return e.hash;\n                }), null, 2));\n\n                if (!(store && heads)) {\n                  _context13.next = 8;\n                  break;\n                }\n\n                if (!(heads.length > 0)) {\n                  _context13.next = 7;\n                  break;\n                }\n\n                _context13.next = 7;\n                return store.sync(heads);\n\n              case 7:\n                store.events.emit('peer.exchanged', peer, address, heads);\n\n              case 8:\n                _context13.next = 13;\n                break;\n\n              case 10:\n                _context13.prev = 10;\n                _context13.t0 = _context13[\"catch\"](1);\n                logger.error(_context13.t0);\n\n              case 13:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[1, 10]]);\n      }));\n\n      function _onMessage(_x13, _x14, _x15) {\n        return _onMessage2.apply(this, arguments);\n      }\n\n      return _onMessage;\n    }() // Callback for when a peer connected to a database\n\n  }, {\n    key: \"_onPeerConnected\",\n    value: function () {\n      var _onPeerConnected2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(address, peer) {\n        var _this2 = this;\n\n        var getStore, getDirectConnection, onChannelCreated, onMessage;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                logger.debug(\"New peer '\".concat(peer, \"' connected to '\").concat(address, \"'\"));\n\n                getStore = function getStore(address) {\n                  return _this2.stores[address];\n                };\n\n                getDirectConnection = function getDirectConnection(peer) {\n                  return _this2._directConnections[peer];\n                };\n\n                onChannelCreated = function onChannelCreated(channel) {\n                  _this2._directConnections[channel._receiverID] = channel;\n                };\n\n                onMessage = function onMessage(address, heads) {\n                  return _this2._onMessage(address, heads, peer);\n                };\n\n                _context14.next = 7;\n                return exchangeHeads(this._ipfs, address, peer, getStore, getDirectConnection, onMessage, onChannelCreated);\n\n              case 7:\n                if (getStore(address)) {\n                  getStore(address).events.emit('peer', peer);\n                }\n\n              case 8:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function _onPeerConnected(_x16, _x17) {\n        return _onPeerConnected2.apply(this, arguments);\n      }\n\n      return _onPeerConnected;\n    }() // Callback when database was closed\n\n  }, {\n    key: \"_onClose\",\n    value: function () {\n      var _onClose2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(db) {\n        var address, dir, cache;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                address = db.address.toString();\n                logger.debug(\"Close \".concat(address)); // Unsubscribe from pubsub\n\n                if (!this._pubsub) {\n                  _context15.next = 5;\n                  break;\n                }\n\n                _context15.next = 5;\n                return this._pubsub.unsubscribe(address);\n\n              case 5:\n                dir = db && db.options.directory ? db.options.directory : this.directory;\n                cache = this.caches[dir];\n\n                if (!(cache && cache.handlers.has(address))) {\n                  _context15.next = 12;\n                  break;\n                }\n\n                cache.handlers.delete(address);\n\n                if (cache.handlers.size) {\n                  _context15.next = 12;\n                  break;\n                }\n\n                _context15.next = 12;\n                return cache.cache.close();\n\n              case 12:\n                delete this.stores[address];\n\n              case 13:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function _onClose(_x18) {\n        return _onClose2.apply(this, arguments);\n      }\n\n      return _onClose;\n    }()\n  }, {\n    key: \"_onDrop\",\n    value: function () {\n      var _onDrop2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(db) {\n        var address, dir;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                address = db.address.toString();\n                dir = db && db.options.directory ? db.options.directory : this.directory;\n                _context16.next = 4;\n                return this._requestCache(address, dir, db._cache);\n\n              case 4:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function _onDrop(_x19) {\n        return _onDrop2.apply(this, arguments);\n      }\n\n      return _onDrop;\n    }()\n  }, {\n    key: \"_onLoad\",\n    value: function () {\n      var _onLoad2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(db) {\n        var address, dir;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                address = db.address.toString();\n                dir = db && db.options.directory ? db.options.directory : this.directory;\n                _context17.next = 4;\n                return this._requestCache(address, dir, db._cache);\n\n              case 4:\n                this.stores[address] = db;\n\n              case 5:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _onLoad(_x20) {\n        return _onLoad2.apply(this, arguments);\n      }\n\n      return _onLoad;\n    }()\n  }, {\n    key: \"_determineAddress\",\n    value: function () {\n      var _determineAddress2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(name, type) {\n        var options,\n            accessControllerAddress,\n            manifestHash,\n            _args18 = arguments;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                options = _args18.length > 2 && _args18[2] !== undefined ? _args18[2] : {};\n\n                if (OrbitDB.isValidType(type)) {\n                  _context18.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Invalid database type '\".concat(type, \"'\"));\n\n              case 3:\n                if (!OrbitDBAddress.isValid(name)) {\n                  _context18.next = 5;\n                  break;\n                }\n\n                throw new Error('Given database name is an address. Please give only the name of the database!');\n\n              case 5:\n                // Create an AccessController, use IPFS AC as the default\n                options.accessController = Object.assign({}, {\n                  name: name,\n                  type: 'ipfs'\n                }, options.accessController);\n                _context18.next = 8;\n                return AccessControllers.create(this, options.accessController.type, options.accessController || {});\n\n              case 8:\n                accessControllerAddress = _context18.sent;\n                _context18.next = 11;\n                return createDBManifest(this._ipfs, name, type, accessControllerAddress, options);\n\n              case 11:\n                manifestHash = _context18.sent;\n                return _context18.abrupt(\"return\", OrbitDBAddress.parse(OrbitDBAddress.join(manifestHash, name)));\n\n              case 13:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function _determineAddress(_x21, _x22) {\n        return _determineAddress2.apply(this, arguments);\n      }\n\n      return _determineAddress;\n    }()\n    /* Create and Open databases */\n\n    /*\n      options = {\n        accessController: { write: [] } // array of keys that can write to this database\n        overwrite: false, // whether we should overwrite the existing database if it exists\n      }\n    */\n\n  }, {\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(name, type) {\n        var options,\n            dbAddress,\n            haveDB,\n            _args19 = arguments;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                options = _args19.length > 2 && _args19[2] !== undefined ? _args19[2] : {};\n                logger.debug('create()');\n                logger.debug(\"Creating database '\".concat(name, \"' as \").concat(type)); // Create the database address\n\n                _context19.next = 5;\n                return this._determineAddress(name, type, options);\n\n              case 5:\n                dbAddress = _context19.sent;\n                _context19.next = 8;\n                return this._requestCache(dbAddress.toString(), options.directory);\n\n              case 8:\n                options.cache = _context19.sent;\n                _context19.next = 11;\n                return this._haveLocalData(options.cache, dbAddress);\n\n              case 11:\n                haveDB = _context19.sent;\n\n                if (!(haveDB && !options.overwrite)) {\n                  _context19.next = 14;\n                  break;\n                }\n\n                throw new Error(\"Database '\".concat(dbAddress, \"' already exists!\"));\n\n              case 14:\n                _context19.next = 16;\n                return this._migrate(options, dbAddress);\n\n              case 16:\n                _context19.next = 18;\n                return this._addManifestToCache(options.cache, dbAddress);\n\n              case 18:\n                logger.debug(\"Created database '\".concat(dbAddress, \"'\")); // Open the database\n\n                return _context19.abrupt(\"return\", this.open(dbAddress, options));\n\n              case 20:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function create(_x23, _x24) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"determineAddress\",\n    value: function () {\n      var _determineAddress3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(name, type) {\n        var options,\n            opts,\n            _args20 = arguments;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                options = _args20.length > 2 && _args20[2] !== undefined ? _args20[2] : {};\n                opts = Object.assign({}, {\n                  onlyHash: true\n                }, options);\n                return _context20.abrupt(\"return\", this._determineAddress(name, type, opts));\n\n              case 3:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function determineAddress(_x25, _x26) {\n        return _determineAddress3.apply(this, arguments);\n      }\n\n      return determineAddress;\n    }()\n  }, {\n    key: \"_requestCache\",\n    value: function () {\n      var _requestCache2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(address, directory, existingCache) {\n        var dir, newCache, cache;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                dir = directory || this.directory;\n\n                if (this.caches[dir]) {\n                  _context21.next = 9;\n                  break;\n                }\n\n                _context21.t0 = existingCache;\n\n                if (_context21.t0) {\n                  _context21.next = 7;\n                  break;\n                }\n\n                _context21.next = 6;\n                return this._createCache(dir);\n\n              case 6:\n                _context21.t0 = _context21.sent;\n\n              case 7:\n                newCache = _context21.t0;\n                this.caches[dir] = {\n                  cache: newCache,\n                  handlers: new Set()\n                };\n\n              case 9:\n                this.caches[dir].handlers.add(address);\n                cache = this.caches[dir].cache; // \"Wake up\" the caches if they need it\n\n                if (!cache) {\n                  _context21.next = 14;\n                  break;\n                }\n\n                _context21.next = 14;\n                return cache.open();\n\n              case 14:\n                return _context21.abrupt(\"return\", cache);\n\n              case 15:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function _requestCache(_x27, _x28, _x29) {\n        return _requestCache2.apply(this, arguments);\n      }\n\n      return _requestCache;\n    }()\n    /*\n        options = {\n          localOnly: false // if set to true, throws an error if database can't be found locally\n          create: false // whether to create the database\n          type: TODO\n          overwrite: TODO\n         }\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(address) {\n        var options,\n            dbAddress,\n            haveDB,\n            manifest,\n            _args22 = arguments;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                options = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : {};\n                logger.debug('open()');\n                options = Object.assign({\n                  localOnly: false,\n                  create: false\n                }, options);\n                logger.debug(\"Open database '\".concat(address, \"'\")); // If address is just the name of database, check the options to crate the database\n\n                if (OrbitDBAddress.isValid(address)) {\n                  _context22.next = 16;\n                  break;\n                }\n\n                if (options.create) {\n                  _context22.next = 9;\n                  break;\n                }\n\n                throw new Error('\\'options.create\\' set to \\'false\\'. If you want to create a database, set \\'options.create\\' to \\'true\\'.');\n\n              case 9:\n                if (!(options.create && !options.type)) {\n                  _context22.next = 13;\n                  break;\n                }\n\n                throw new Error(\"Database type not provided! Provide a type with 'options.type' (\".concat(OrbitDB.databaseTypes.join('|'), \")\"));\n\n              case 13:\n                logger.warn(\"Not a valid OrbitDB address '\".concat(address, \"', creating the database\"));\n                options.overwrite = options.overwrite ? options.overwrite : true;\n                return _context22.abrupt(\"return\", this.create(address, options.type, options));\n\n              case 16:\n                // Parse the database address\n                dbAddress = OrbitDBAddress.parse(address); // If database is already open, return early by returning the instance\n                // if (this.stores[dbAddress]) {\n                //   return this.stores[dbAddress]\n                // }\n\n                _context22.next = 19;\n                return this._requestCache(dbAddress.toString(), options.directory);\n\n              case 19:\n                options.cache = _context22.sent;\n                _context22.next = 22;\n                return this._haveLocalData(options.cache, dbAddress);\n\n              case 22:\n                haveDB = _context22.sent;\n                logger.debug((haveDB ? 'Found' : 'Didn\\'t find') + \" database '\".concat(dbAddress, \"'\")); // If we want to try and open the database local-only, throw an error\n                // if we don't have the database locally\n\n                if (!(options.localOnly && !haveDB)) {\n                  _context22.next = 27;\n                  break;\n                }\n\n                logger.warn(\"Database '\".concat(dbAddress, \"' doesn't exist!\"));\n                throw new Error(\"Database '\".concat(dbAddress, \"' doesn't exist!\"));\n\n              case 27:\n                logger.debug(\"Loading Manifest for '\".concat(dbAddress, \"'\"));\n                _context22.prev = 28;\n                _context22.next = 31;\n                return io.read(this._ipfs, dbAddress.root, {\n                  timeout: options.timeout || defaultTimeout\n                });\n\n              case 31:\n                manifest = _context22.sent;\n                logger.debug(\"Manifest for '\".concat(dbAddress, \"':\\n\").concat(JSON.stringify(manifest, null, 2)));\n                _context22.next = 43;\n                break;\n\n              case 35:\n                _context22.prev = 35;\n                _context22.t0 = _context22[\"catch\"](28);\n\n                if (!(_context22.t0.name === 'TimeoutError' && _context22.t0.code === 'ERR_TIMEOUT')) {\n                  _context22.next = 42;\n                  break;\n                }\n\n                console.error(_context22.t0);\n                throw new Error('ipfs unable to find and fetch manifest for this address.');\n\n              case 42:\n                throw _context22.t0;\n\n              case 43:\n                if (manifest.name !== dbAddress.path) {\n                  logger.warn(\"Manifest name '\".concat(manifest.name, \"' and path name '\").concat(dbAddress.path, \"' do not match\"));\n                } // Make sure the type from the manifest matches the type that was given as an option\n\n\n                if (!(options.type && manifest.type !== options.type)) {\n                  _context22.next = 46;\n                  break;\n                }\n\n                throw new Error(\"Database '\".concat(dbAddress, \"' is type '\").concat(manifest.type, \"' but was opened as '\").concat(options.type, \"'\"));\n\n              case 46:\n                _context22.next = 48;\n                return this._addManifestToCache(options.cache, dbAddress);\n\n              case 48:\n                // Open the the database\n                options = Object.assign({}, options, {\n                  accessControllerAddress: manifest.accessController,\n                  meta: manifest.meta\n                });\n                return _context22.abrupt(\"return\", this._createStore(options.type || manifest.type, dbAddress, options));\n\n              case 50:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this, [[28, 35]]);\n      }));\n\n      function open(_x30) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }() // Save the database locally\n\n  }, {\n    key: \"_addManifestToCache\",\n    value: function () {\n      var _addManifestToCache2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(cache, dbAddress) {\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.next = 2;\n                return cache.set(path.join(dbAddress.toString(), '_manifest'), dbAddress.root);\n\n              case 2:\n                logger.debug(\"Saved manifest to IPFS as '\".concat(dbAddress.root, \"'\"));\n\n              case 3:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23);\n      }));\n\n      function _addManifestToCache(_x31, _x32) {\n        return _addManifestToCache2.apply(this, arguments);\n      }\n\n      return _addManifestToCache;\n    }()\n    /**\n     * Check if we have the database, or part of it, saved locally\n     * @param  {[Cache]} cache [The OrbitDBCache instance containing the local data]\n     * @param  {[OrbitDBAddress]} dbAddress [Address of the database to check]\n     * @return {[Boolean]} [Returns true if we have cached the db locally, false if not]\n     */\n\n  }, {\n    key: \"_haveLocalData\",\n    value: function () {\n      var _haveLocalData2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(cache, dbAddress) {\n        var addr, data;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                if (cache) {\n                  _context24.next = 2;\n                  break;\n                }\n\n                return _context24.abrupt(\"return\", false);\n\n              case 2:\n                addr = dbAddress.toString();\n                _context24.next = 5;\n                return cache.get(path.join(addr, '_manifest'));\n\n              case 5:\n                data = _context24.sent;\n                return _context24.abrupt(\"return\", data !== undefined && data !== null);\n\n              case 7:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24);\n      }));\n\n      function _haveLocalData(_x33, _x34) {\n        return _haveLocalData2.apply(this, arguments);\n      }\n\n      return _haveLocalData;\n    }()\n    /**\n     * Runs all migrations inside the src/migration folder\n     * @param Object options  Options to pass into the migration\n     * @param OrbitDBAddress dbAddress Address of database in OrbitDBAddress format\n     */\n\n  }, {\n    key: \"_migrate\",\n    value: function () {\n      var _migrate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(options, dbAddress) {\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                _context25.next = 2;\n                return migrations.run(this, options, dbAddress);\n\n              case 2:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function _migrate(_x35, _x36) {\n        return _migrate2.apply(this, arguments);\n      }\n\n      return _migrate;\n    }()\n    /**\n     * Returns supported database types as an Array of strings\n     * Eg. [ 'counter', 'eventlog', 'feed', 'docstore', 'keyvalue']\n     * @return {[Array]} [Supported database types]\n     */\n\n  }], [{\n    key: \"Pubsub\",\n    get: function get() {\n      return Pubsub;\n    }\n  }, {\n    key: \"Cache\",\n    get: function get() {\n      return Cache;\n    }\n  }, {\n    key: \"Keystore\",\n    get: function get() {\n      return Keystore;\n    }\n  }, {\n    key: \"Identities\",\n    get: function get() {\n      return Identities;\n    }\n  }, {\n    key: \"AccessControllers\",\n    get: function get() {\n      return AccessControllers;\n    }\n  }, {\n    key: \"Storage\",\n    get: function get() {\n      return Storage;\n    }\n  }, {\n    key: \"OrbitDBAddress\",\n    get: function get() {\n      return OrbitDBAddress;\n    }\n  }, {\n    key: \"Store\",\n    get: function get() {\n      return Store;\n    }\n  }, {\n    key: \"EventStore\",\n    get: function get() {\n      return EventStore;\n    }\n  }, {\n    key: \"FeedStore\",\n    get: function get() {\n      return FeedStore;\n    }\n  }, {\n    key: \"KeyValueStore\",\n    get: function get() {\n      return KeyValueStore;\n    }\n  }, {\n    key: \"CounterStore\",\n    get: function get() {\n      return CounterStore;\n    }\n  }, {\n    key: \"DocumentStore\",\n    get: function get() {\n      return DocumentStore;\n    }\n  }, {\n    key: \"createInstance\",\n    value: function () {\n      var _createInstance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(ipfs) {\n        var options,\n            _ref,\n            id,\n            storageOptions,\n            keystorePath,\n            keyStorage,\n            cachePath,\n            cacheStorage,\n            finalOptions,\n            _args26 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                options = _args26.length > 1 && _args26[1] !== undefined ? _args26[1] : {};\n\n                if (isDefined(ipfs)) {\n                  _context26.next = 3;\n                  break;\n                }\n\n                throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n\n              case 3:\n                if (options.offline === undefined) {\n                  options.offline = false;\n                }\n\n                if (!(options.offline && !options.id)) {\n                  _context26.next = 6;\n                  break;\n                }\n\n                throw new Error('Offline mode requires passing an `id` in the options');\n\n              case 6:\n                if (!(options.id || options.offline)) {\n                  _context26.next = 10;\n                  break;\n                }\n\n                _context26.t0 = {\n                  id: options.id\n                };\n                _context26.next = 13;\n                break;\n\n              case 10:\n                _context26.next = 12;\n                return ipfs.id();\n\n              case 12:\n                _context26.t0 = _context26.sent;\n\n              case 13:\n                _ref = _context26.t0;\n                id = _ref.id;\n\n                if (!options.directory) {\n                  options.directory = './orbitdb';\n                }\n\n                if (!options.storage) {\n                  storageOptions = {}; // Create default `level` store\n\n                  options.storage = Storage(null, storageOptions);\n                }\n\n                if (options.identity && options.identity.provider.keystore) {\n                  options.keystore = options.identity.provider.keystore;\n                }\n\n                if (options.keystore) {\n                  _context26.next = 24;\n                  break;\n                }\n\n                keystorePath = path.join(options.directory, id, '/keystore');\n                _context26.next = 22;\n                return options.storage.createStore(keystorePath);\n\n              case 22:\n                keyStorage = _context26.sent;\n                options.keystore = new Keystore(keyStorage);\n\n              case 24:\n                if (options.identity) {\n                  _context26.next = 28;\n                  break;\n                }\n\n                _context26.next = 27;\n                return Identities.createIdentity({\n                  id: id,\n                  keystore: options.keystore\n                });\n\n              case 27:\n                options.identity = _context26.sent;\n\n              case 28:\n                if (options.cache) {\n                  _context26.next = 34;\n                  break;\n                }\n\n                cachePath = path.join(options.directory, id, '/cache');\n                _context26.next = 32;\n                return options.storage.createStore(cachePath);\n\n              case 32:\n                cacheStorage = _context26.sent;\n                options.cache = new Cache(cacheStorage);\n\n              case 34:\n                finalOptions = Object.assign({}, options, {\n                  peerId: id\n                });\n                return _context26.abrupt(\"return\", new OrbitDB(ipfs, options.identity, finalOptions));\n\n              case 36:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26);\n      }));\n\n      function createInstance(_x37) {\n        return _createInstance.apply(this, arguments);\n      }\n\n      return createInstance;\n    }()\n  }, {\n    key: \"databaseTypes\",\n    get: function get() {\n      return Object.keys(databaseTypes);\n    }\n  }, {\n    key: \"isValidType\",\n    value: function isValidType(type) {\n      return Object.keys(databaseTypes).includes(type);\n    }\n  }, {\n    key: \"addDatabaseType\",\n    value: function addDatabaseType(type, store) {\n      if (databaseTypes[type]) throw new Error(\"Type already exists: \".concat(type));\n      databaseTypes[type] = store;\n    }\n  }, {\n    key: \"getDatabaseTypes\",\n    value: function getDatabaseTypes() {\n      return databaseTypes;\n    }\n  }, {\n    key: \"isValidAddress\",\n    value: function isValidAddress(address) {\n      return OrbitDBAddress.isValid(address);\n    }\n  }, {\n    key: \"parseAddress\",\n    value: function parseAddress(address) {\n      return OrbitDBAddress.parse(address);\n    }\n  }]);\n\n  return OrbitDB;\n}();\n\nOrbitDB.prototype.AccessControllers = AccessControllers;\nOrbitDB.prototype.Identities = Identities;\nOrbitDB.prototype.Keystore = Keystore;\nmodule.exports = OrbitDB;","map":{"version":3,"names":["path","require","Store","EventStore","FeedStore","KeyValueStore","CounterStore","DocumentStore","Pubsub","Cache","Keystore","Identities","AccessControllers","OrbitDBAddress","createDBManifest","exchangeHeads","isDefined","io","Storage","migrations","Logger","logger","create","setLogLevel","databaseTypes","counter","eventlog","feed","docstore","keyvalue","defaultTimeout","OrbitDB","ipfs","identity","options","Error","_ipfs","id","peerId","_pubsub","offline","broker","directory","storage","_directConnections","caches","cache","handlers","Set","keystore","stores","address","Object","assign","type","open","log","docs","removeDirectConnect","e","close","keys","forEach","disconnect","databases","values","db","toString","createStore","cacheStorage","accessControllerAddress","resolve","accessController","opts","replicate","onClose","_onClose","bind","onDrop","_onDrop","onLoad","_onLoad","store","events","on","_onWrite","addr","subscribe","_onMessage","_onPeerConnected","entry","heads","publish","peer","debug","length","JSON","stringify","map","hash","sync","emit","error","getStore","getDirectConnection","onChannelCreated","channel","_receiverID","onMessage","unsubscribe","dir","has","delete","size","_requestCache","_cache","name","isValidType","isValid","manifestHash","parse","join","_determineAddress","dbAddress","_haveLocalData","haveDB","overwrite","_migrate","_addManifestToCache","onlyHash","existingCache","_createCache","newCache","add","localOnly","warn","read","root","timeout","manifest","code","console","meta","_createStore","set","get","data","undefined","run","storageOptions","provider","keystorePath","keyStorage","createIdentity","cachePath","finalOptions","includes","prototype","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db/src/OrbitDB.js"],"sourcesContent":["'use strict'\n\nconst path = require('path')\nconst Store = require('orbit-db-store')\nconst EventStore = require('orbit-db-eventstore')\nconst FeedStore = require('orbit-db-feedstore')\nconst KeyValueStore = require('orbit-db-kvstore')\nconst CounterStore = require('orbit-db-counterstore')\nconst DocumentStore = require('orbit-db-docstore')\nconst Pubsub = require('orbit-db-pubsub')\nconst Cache = require('orbit-db-cache')\nconst Keystore = require('orbit-db-keystore')\nconst Identities = require('orbit-db-identity-provider')\nlet AccessControllers = require('orbit-db-access-controllers')\nconst OrbitDBAddress = require('./orbit-db-address')\nconst createDBManifest = require('./db-manifest')\nconst exchangeHeads = require('./exchange-heads')\nconst { isDefined, io } = require('./utils')\nconst Storage = require('orbit-db-storage-adapter')\nconst migrations = require('./migrations')\n\nconst Logger = require('logplease')\nconst logger = Logger.create('orbit-db')\nLogger.setLogLevel('ERROR')\n\n// Mapping for 'database type' -> Class\nconst databaseTypes = {\n  counter: CounterStore,\n  eventlog: EventStore,\n  feed: FeedStore,\n  docstore: DocumentStore,\n  keyvalue: KeyValueStore\n}\n\nconst defaultTimeout = 30000 // 30 seconds\n\nclass OrbitDB {\n  constructor (ipfs, identity, options = {}) {\n    if (!isDefined(ipfs)) { throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance') }\n\n    if (!isDefined(identity)) { throw new Error('identity is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance') }\n\n    this._ipfs = ipfs\n    this.identity = identity\n    this.id = options.peerId\n    this._pubsub = !options.offline\n      ? new (\n          options.broker ? options.broker : Pubsub\n        )(this._ipfs, this.id)\n      : null\n    this.directory = options.directory || './orbitdb'\n    this.storage = options.storage\n    this._directConnections = {}\n\n    this.caches = {}\n    this.caches[this.directory] = { cache: options.cache, handlers: new Set() }\n    this.keystore = options.keystore\n    this.stores = {}\n\n    // AccessControllers module can be passed in to enable\n    // testing with orbit-db-access-controller\n    AccessControllers = options.AccessControllers || AccessControllers\n  }\n\n  static get Pubsub () { return Pubsub }\n  static get Cache () { return Cache }\n  static get Keystore () { return Keystore }\n  static get Identities () { return Identities }\n  static get AccessControllers () { return AccessControllers }\n  static get Storage () { return Storage }\n  static get OrbitDBAddress () { return OrbitDBAddress }\n\n  static get Store () { return Store }\n  static get EventStore () { return EventStore }\n  static get FeedStore () { return FeedStore }\n  static get KeyValueStore () { return KeyValueStore }\n  static get CounterStore () { return CounterStore }\n  static get DocumentStore () { return DocumentStore }\n\n  get cache () { return this.caches[this.directory].cache }\n\n  static async createInstance (ipfs, options = {}) {\n    if (!isDefined(ipfs)) { throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance') }\n\n    if (options.offline === undefined) {\n      options.offline = false\n    }\n\n    if (options.offline && !options.id) {\n      throw new Error('Offline mode requires passing an `id` in the options')\n    }\n\n    const { id } = options.id || options.offline ? ({ id: options.id }) : await ipfs.id()\n\n    if (!options.directory) { options.directory = './orbitdb' }\n\n    if (!options.storage) {\n      const storageOptions = {}\n\n      // Create default `level` store\n      options.storage = Storage(null, storageOptions)\n    }\n\n    if (options.identity && options.identity.provider.keystore) {\n      options.keystore = options.identity.provider.keystore\n    }\n\n    if (!options.keystore) {\n      const keystorePath = path.join(options.directory, id, '/keystore')\n      const keyStorage = await options.storage.createStore(keystorePath)\n      options.keystore = new Keystore(keyStorage)\n    }\n\n    if (!options.identity) {\n      options.identity = await Identities.createIdentity({\n        id: id,\n        keystore: options.keystore\n      })\n    }\n\n    if (!options.cache) {\n      const cachePath = path.join(options.directory, id, '/cache')\n      const cacheStorage = await options.storage.createStore(cachePath)\n      options.cache = new Cache(cacheStorage)\n    }\n\n    const finalOptions = Object.assign({}, options, { peerId: id })\n    return new OrbitDB(ipfs, options.identity, finalOptions)\n  }\n\n  /* Databases */\n  async feed (address, options = {}) {\n    options = Object.assign({ create: true, type: 'feed' }, options)\n    return this.open(address, options)\n  }\n\n  async log (address, options = {}) {\n    options = Object.assign({ create: true, type: 'eventlog' }, options)\n    return this.open(address, options)\n  }\n\n  async eventlog (address, options = {}) {\n    return this.log(address, options)\n  }\n\n  async keyvalue (address, options = {}) {\n    options = Object.assign({ create: true, type: 'keyvalue' }, options)\n    return this.open(address, options)\n  }\n\n  async kvstore (address, options = {}) {\n    return this.keyvalue(address, options)\n  }\n\n  async counter (address, options = {}) {\n    options = Object.assign({ create: true, type: 'counter' }, options)\n    return this.open(address, options)\n  }\n\n  async docs (address, options = {}) {\n    options = Object.assign({ create: true, type: 'docstore' }, options)\n    return this.open(address, options)\n  }\n\n  async docstore (address, options = {}) {\n    return this.docs(address, options)\n  }\n\n  async disconnect () {\n    // Close a direct connection and remove it from internal state\n    const removeDirectConnect = e => {\n      this._directConnections[e].close()\n      delete this._directConnections[e]\n    }\n\n    // Close all direct connections to peers\n    Object.keys(this._directConnections).forEach(removeDirectConnect)\n\n    // Disconnect from pubsub\n    if (this._pubsub) {\n      await this._pubsub.disconnect()\n    }\n\n    // close keystore\n    await this.keystore.close()\n\n    // Close all open databases\n    const databases = Object.values(this.stores)\n    for (const db of databases) {\n      await db.close()\n      delete this.stores[db.address.toString()]\n    }\n\n    const caches = Object.keys(this.caches)\n    for (const directory of caches) {\n      await this.caches[directory].cache.close()\n      delete this.caches[directory]\n    }\n\n    // Remove all databases from the state\n    this.stores = {}\n  }\n\n  // Alias for disconnect()\n  async stop () {\n    await this.disconnect()\n  }\n\n  async _createCache (path) {\n    const cacheStorage = await this.storage.createStore(path)\n    return new Cache(cacheStorage)\n  }\n\n  /* Private methods */\n  async _createStore (type, address, options) {\n    // Get the type -> class mapping\n    const Store = databaseTypes[type]\n\n    if (!Store) { throw new Error(`Invalid database type '${type}'`) }\n\n    let accessController\n    if (options.accessControllerAddress) {\n      accessController = await AccessControllers.resolve(this, options.accessControllerAddress, options.accessController)\n    }\n\n    const opts = Object.assign({ replicate: true }, options, {\n      accessController: accessController,\n      cache: options.cache,\n      onClose: this._onClose.bind(this),\n      onDrop: this._onDrop.bind(this),\n      onLoad: this._onLoad.bind(this)\n    })\n    const identity = options.identity || this.identity\n\n    const store = new Store(this._ipfs, identity, address, opts)\n    store.events.on('write', this._onWrite.bind(this))\n\n    // ID of the store is the address as a string\n    const addr = address.toString()\n    this.stores[addr] = store\n\n    // Subscribe to pubsub to get updates from peers,\n    // this is what hooks us into the message propagation layer\n    // and the p2p network\n    if (opts.replicate && this._pubsub) { await this._pubsub.subscribe(addr, this._onMessage.bind(this), this._onPeerConnected.bind(this)) }\n\n    return store\n  }\n\n  // Callback for local writes to the database. We the update to pubsub.\n  _onWrite (address, entry, heads) {\n    if (!heads) throw new Error(\"'heads' not defined\")\n    if (this._pubsub) this._pubsub.publish(address, heads)\n  }\n\n  // Callback for receiving a message from the network\n  async _onMessage (address, heads, peer) {\n    const store = this.stores[address]\n    try {\n      logger.debug(`Received ${heads.length} heads for '${address}':\\n`, JSON.stringify(heads.map(e => e.hash), null, 2))\n      if (store && heads) {\n        if (heads.length > 0) {\n          await store.sync(heads)\n        }\n        store.events.emit('peer.exchanged', peer, address, heads)\n      }\n    } catch (e) {\n      logger.error(e)\n    }\n  }\n\n  // Callback for when a peer connected to a database\n  async _onPeerConnected (address, peer) {\n    logger.debug(`New peer '${peer}' connected to '${address}'`)\n\n    const getStore = address => this.stores[address]\n    const getDirectConnection = peer => this._directConnections[peer]\n    const onChannelCreated = channel => { this._directConnections[channel._receiverID] = channel }\n\n    const onMessage = (address, heads) => this._onMessage(address, heads, peer)\n\n    await exchangeHeads(\n      this._ipfs,\n      address,\n      peer,\n      getStore,\n      getDirectConnection,\n      onMessage,\n      onChannelCreated\n    )\n\n    if (getStore(address)) { getStore(address).events.emit('peer', peer) }\n  }\n\n  // Callback when database was closed\n  async _onClose (db) {\n    const address = db.address.toString()\n    logger.debug(`Close ${address}`)\n\n    // Unsubscribe from pubsub\n    if (this._pubsub) {\n      await this._pubsub.unsubscribe(address)\n    }\n\n    const dir = db && db.options.directory ? db.options.directory : this.directory\n    const cache = this.caches[dir]\n\n    if (cache && cache.handlers.has(address)) {\n      cache.handlers.delete(address)\n      if (!cache.handlers.size) await cache.cache.close()\n    }\n\n    delete this.stores[address]\n  }\n\n  async _onDrop (db) {\n    const address = db.address.toString()\n    const dir = db && db.options.directory ? db.options.directory : this.directory\n    await this._requestCache(address, dir, db._cache)\n  }\n\n  async _onLoad (db) {\n    const address = db.address.toString()\n    const dir = db && db.options.directory ? db.options.directory : this.directory\n    await this._requestCache(address, dir, db._cache)\n    this.stores[address] = db\n  }\n\n  async _determineAddress (name, type, options = {}) {\n    if (!OrbitDB.isValidType(type)) { throw new Error(`Invalid database type '${type}'`) }\n\n    if (OrbitDBAddress.isValid(name)) { throw new Error('Given database name is an address. Please give only the name of the database!') }\n\n    // Create an AccessController, use IPFS AC as the default\n    options.accessController = Object.assign({}, { name: name, type: 'ipfs' }, options.accessController)\n    const accessControllerAddress = await AccessControllers.create(this, options.accessController.type, options.accessController || {})\n\n    // Save the manifest to IPFS\n    const manifestHash = await createDBManifest(this._ipfs, name, type, accessControllerAddress, options)\n\n    // Create the database address\n    return OrbitDBAddress.parse(OrbitDBAddress.join(manifestHash, name))\n  }\n\n  /* Create and Open databases */\n\n  /*\n    options = {\n      accessController: { write: [] } // array of keys that can write to this database\n      overwrite: false, // whether we should overwrite the existing database if it exists\n    }\n  */\n  async create (name, type, options = {}) {\n    logger.debug('create()')\n\n    logger.debug(`Creating database '${name}' as ${type}`)\n\n    // Create the database address\n    const dbAddress = await this._determineAddress(name, type, options)\n\n    options.cache = await this._requestCache(dbAddress.toString(), options.directory)\n\n    // Check if we have the database locally\n    const haveDB = await this._haveLocalData(options.cache, dbAddress)\n\n    if (haveDB && !options.overwrite) { throw new Error(`Database '${dbAddress}' already exists!`) }\n\n    await this._migrate(options, dbAddress)\n\n    // Save the database locally\n    await this._addManifestToCache(options.cache, dbAddress)\n\n    logger.debug(`Created database '${dbAddress}'`)\n\n    // Open the database\n    return this.open(dbAddress, options)\n  }\n\n  async determineAddress (name, type, options = {}) {\n    const opts = Object.assign({}, { onlyHash: true }, options)\n    return this._determineAddress(name, type, opts)\n  }\n\n  async _requestCache (address, directory, existingCache) {\n    const dir = directory || this.directory\n    if (!this.caches[dir]) {\n      const newCache = existingCache || await this._createCache(dir)\n      this.caches[dir] = { cache: newCache, handlers: new Set() }\n    }\n    this.caches[dir].handlers.add(address)\n    const cache = this.caches[dir].cache\n\n    // \"Wake up\" the caches if they need it\n    if (cache) await cache.open()\n\n    return cache\n  }\n\n  /*\n      options = {\n        localOnly: false // if set to true, throws an error if database can't be found locally\n        create: false // whether to create the database\n        type: TODO\n        overwrite: TODO\n\n      }\n   */\n  async open (address, options = {}) {\n    logger.debug('open()')\n\n    options = Object.assign({ localOnly: false, create: false }, options)\n    logger.debug(`Open database '${address}'`)\n\n    // If address is just the name of database, check the options to crate the database\n    if (!OrbitDBAddress.isValid(address)) {\n      if (!options.create) {\n        throw new Error('\\'options.create\\' set to \\'false\\'. If you want to create a database, set \\'options.create\\' to \\'true\\'.')\n      } else if (options.create && !options.type) {\n        throw new Error(`Database type not provided! Provide a type with 'options.type' (${OrbitDB.databaseTypes.join('|')})`)\n      } else {\n        logger.warn(`Not a valid OrbitDB address '${address}', creating the database`)\n        options.overwrite = options.overwrite ? options.overwrite : true\n        return this.create(address, options.type, options)\n      }\n    }\n\n    // Parse the database address\n    const dbAddress = OrbitDBAddress.parse(address)\n\n    // If database is already open, return early by returning the instance\n    // if (this.stores[dbAddress]) {\n    //   return this.stores[dbAddress]\n    // }\n\n    options.cache = await this._requestCache(dbAddress.toString(), options.directory)\n\n    // Check if we have the database\n    const haveDB = await this._haveLocalData(options.cache, dbAddress)\n\n    logger.debug((haveDB ? 'Found' : 'Didn\\'t find') + ` database '${dbAddress}'`)\n\n    // If we want to try and open the database local-only, throw an error\n    // if we don't have the database locally\n    if (options.localOnly && !haveDB) {\n      logger.warn(`Database '${dbAddress}' doesn't exist!`)\n      throw new Error(`Database '${dbAddress}' doesn't exist!`)\n    }\n\n    logger.debug(`Loading Manifest for '${dbAddress}'`)\n\n    let manifest\n    try {\n      // Get the database manifest from IPFS\n      manifest = await io.read(this._ipfs, dbAddress.root, { timeout: options.timeout || defaultTimeout })\n      logger.debug(`Manifest for '${dbAddress}':\\n${JSON.stringify(manifest, null, 2)}`)\n    } catch (e) {\n      if (e.name === 'TimeoutError' && e.code === 'ERR_TIMEOUT') {\n        console.error(e)\n        throw new Error('ipfs unable to find and fetch manifest for this address.')\n      } else {\n        throw e\n      }\n    }\n\n    if (manifest.name !== dbAddress.path) {\n      logger.warn(`Manifest name '${manifest.name}' and path name '${dbAddress.path}' do not match`)\n    }\n\n    // Make sure the type from the manifest matches the type that was given as an option\n    if (options.type && manifest.type !== options.type) {\n      throw new Error(`Database '${dbAddress}' is type '${manifest.type}' but was opened as '${options.type}'`)\n    }\n\n    // Save the database locally\n    await this._addManifestToCache(options.cache, dbAddress)\n\n    // Open the the database\n    options = Object.assign({}, options, { accessControllerAddress: manifest.accessController, meta: manifest.meta })\n    return this._createStore(options.type || manifest.type, dbAddress, options)\n  }\n\n  // Save the database locally\n  async _addManifestToCache (cache, dbAddress) {\n    await cache.set(path.join(dbAddress.toString(), '_manifest'), dbAddress.root)\n    logger.debug(`Saved manifest to IPFS as '${dbAddress.root}'`)\n  }\n\n  /**\n   * Check if we have the database, or part of it, saved locally\n   * @param  {[Cache]} cache [The OrbitDBCache instance containing the local data]\n   * @param  {[OrbitDBAddress]} dbAddress [Address of the database to check]\n   * @return {[Boolean]} [Returns true if we have cached the db locally, false if not]\n   */\n  async _haveLocalData (cache, dbAddress) {\n    if (!cache) {\n      return false\n    }\n\n    const addr = dbAddress.toString()\n    const data = await cache.get(path.join(addr, '_manifest'))\n    return data !== undefined && data !== null\n  }\n\n  /**\n   * Runs all migrations inside the src/migration folder\n   * @param Object options  Options to pass into the migration\n   * @param OrbitDBAddress dbAddress Address of database in OrbitDBAddress format\n   */\n  async _migrate (options, dbAddress) {\n    await migrations.run(this, options, dbAddress)\n  }\n\n  /**\n   * Returns supported database types as an Array of strings\n   * Eg. [ 'counter', 'eventlog', 'feed', 'docstore', 'keyvalue']\n   * @return {[Array]} [Supported database types]\n   */\n  static get databaseTypes () {\n    return Object.keys(databaseTypes)\n  }\n\n  static isValidType (type) {\n    return Object.keys(databaseTypes).includes(type)\n  }\n\n  static addDatabaseType (type, store) {\n    if (databaseTypes[type]) throw new Error(`Type already exists: ${type}`)\n    databaseTypes[type] = store\n  }\n\n  static getDatabaseTypes () {\n    return databaseTypes\n  }\n\n  static isValidAddress (address) {\n    return OrbitDBAddress.isValid(address)\n  }\n\n  static parseAddress (address) {\n    return OrbitDBAddress.parse(address)\n  }\n}\n\nOrbitDB.prototype.AccessControllers = AccessControllers\nOrbitDB.prototype.Identities = Identities\nOrbitDB.prototype.Keystore = Keystore\n\nmodule.exports = OrbitDB\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}