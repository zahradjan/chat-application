{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IKHandshake = void 0;\n\nconst ik_1 = require(\"./handshakes/ik\");\n\nconst buffer_1 = require(\"buffer\");\n\nconst encoder_1 = require(\"./encoder\");\n\nconst utils_1 = require(\"./utils\");\n\nconst errors_1 = require(\"./errors\");\n\nconst logger_1 = require(\"./logger\");\n\nclass IKHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {\n    this.isInitiator = isInitiator;\n    this.payload = buffer_1.Buffer.from(payload);\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n\n    this.ik = handshake !== null && handshake !== void 0 ? handshake : new ik_1.IK();\n    this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);\n    this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n  }\n\n  async stage0() {\n    logger_1.logLocalStaticKeys(this.session.hs.s);\n    logger_1.logRemoteStaticKey(this.session.hs.rs);\n\n    if (this.isInitiator) {\n      logger_1.logger('IK Stage 0 - Initiator sending message...');\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encoder_1.encode1(messageBuffer));\n      logger_1.logger('IK Stage 0 - Initiator sent message.');\n      logger_1.logLocalEphemeralKeys(this.session.hs.e);\n    } else {\n      logger_1.logger('IK Stage 0 - Responder receiving message...');\n      const receivedMsg = await this.connection.readLP();\n\n      try {\n        const receivedMessageBuffer = encoder_1.decode1(receivedMsg.slice());\n        const {\n          plaintext,\n          valid\n        } = this.ik.recvMessage(this.session, receivedMessageBuffer);\n\n        if (!valid) {\n          throw new Error('ik handshake stage 0 decryption validation fail');\n        }\n\n        logger_1.logger('IK Stage 0 - Responder got message, going to verify payload.');\n        const decodedPayload = await utils_1.decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await utils_1.getPeerIdFromPayload(decodedPayload));\n        await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        logger_1.logger('IK Stage 0 - Responder successfully verified payload!');\n        logger_1.logRemoteEphemeralKey(this.session.hs.re);\n      } catch (e) {\n        const err = e;\n        logger_1.logger('Responder breaking up with IK handshake in stage 0.');\n        throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${err.message}`);\n      }\n    }\n  }\n\n  async stage1() {\n    if (this.isInitiator) {\n      logger_1.logger('IK Stage 1 - Initiator receiving message...');\n      const receivedMsg = (await this.connection.readLP()).slice();\n      const receivedMessageBuffer = encoder_1.decode0(buffer_1.Buffer.from(receivedMsg));\n      const {\n        plaintext,\n        valid\n      } = this.ik.recvMessage(this.session, receivedMessageBuffer);\n      logger_1.logger('IK Stage 1 - Initiator got message, going to verify payload.');\n\n      try {\n        if (!valid) {\n          throw new Error('ik stage 1 decryption validation fail');\n        }\n\n        const decodedPayload = await utils_1.decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await utils_1.getPeerIdFromPayload(decodedPayload));\n        await utils_1.verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        logger_1.logger('IK Stage 1 - Initiator successfully verified payload!');\n        logger_1.logRemoteEphemeralKey(this.session.hs.re);\n      } catch (e) {\n        const err = e;\n        logger_1.logger('Initiator breaking up with IK handshake in stage 1.');\n        throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${err.message}`);\n      }\n    } else {\n      logger_1.logger('IK Stage 1 - Responder sending message...');\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encoder_1.encode0(messageBuffer));\n      logger_1.logger('IK Stage 1 - Responder sent message...');\n      logger_1.logLocalEphemeralKeys(this.session.hs.e);\n    }\n\n    logger_1.logCipherState(this.session);\n  }\n\n  decrypt(ciphertext, session) {\n    const cs = this.getCS(session, false);\n    return this.ik.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n  }\n\n  encrypt(plaintext, session) {\n    const cs = this.getCS(session);\n    return this.ik.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n  }\n\n  getLocalEphemeralKeys() {\n    if (!this.session.hs.e) {\n      throw new Error('Ephemeral keys do not exist.');\n    }\n\n    return this.session.hs.e;\n  }\n\n  getCS(session) {\n    let encryption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (!session.cs1 || !session.cs2) {\n      throw new Error('Handshake not completed properly, cipher state does not exist.');\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  setRemoteEarlyData(data) {\n    if (data) {\n      this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n\n}\n\nexports.IKHandshake = IKHandshake;","map":{"version":3,"mappings":"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","names":["IKHandshake","constructor","isInitiator","payload","prologue","staticKeypair","connection","remoteStaticKey","remotePeer","handshake","buffer_1","from","ik","ik_1","session","initSession","remoteEarlyData","alloc","stage0","logger_1","hs","s","rs","messageBuffer","sendMessage","writeLP","encoder_1","e","receivedMsg","readLP","receivedMessageBuffer","slice","plaintext","valid","recvMessage","Error","decodedPayload","utils_1","setRemoteEarlyData","data","re","err","errors_1","message","stage1","ns","decrypt","ciphertext","cs","getCS","decryptWithAd","encrypt","encryptWithAd","getLocalEphemeralKeys","encryption","cs1","cs2","buffer","byteOffset","length","exports"],"sourceRoot":"","sources":["../../src/handshake-ik.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}