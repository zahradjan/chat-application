{"ast":null,"code":"var _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar getIterator = require('get-iterator');\n\nvar AbortError = require('./AbortError'); // Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\n\n\nvar toAbortableSource = function toAbortableSource(source, signal, options) {\n  return toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{\n    signal: signal,\n    options: options\n  }]);\n};\n\nvar toMultiAbortableSource = function toMultiAbortableSource(source, signals) {\n  source = getIterator(source);\n  signals = signals.map(function (_ref) {\n    var signal = _ref.signal,\n        options = _ref.options;\n    return {\n      signal: signal,\n      options: options || {}\n    };\n  });\n\n  function abortable() {\n    return _abortable.apply(this, arguments);\n  }\n\n  function _abortable() {\n    _abortable = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      var nextAbortHandler, abortHandler, _iterator, _step, _signal2, result, _iterator2, _step2, _step2$value, signal, options, abortMessage, abortCode, abort, _ret, _iterator4, _step4, _signal3;\n\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              abortHandler = function abortHandler() {\n                if (nextAbortHandler) nextAbortHandler();\n              };\n\n              _iterator = _createForOfIteratorHelper(signals);\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  _signal2 = _step.value.signal;\n\n                  _signal2.addEventListener('abort', abortHandler);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n\n            case 3:\n              if (!true) {\n                _context2.next = 43;\n                break;\n              }\n\n              result = void 0;\n              _context2.prev = 5;\n              _iterator2 = _createForOfIteratorHelper(signals);\n              _context2.prev = 7;\n\n              _iterator2.s();\n\n            case 9:\n              if ((_step2 = _iterator2.n()).done) {\n                _context2.next = 16;\n                break;\n              }\n\n              _step2$value = _step2.value, signal = _step2$value.signal, options = _step2$value.options;\n\n              if (!signal.aborted) {\n                _context2.next = 14;\n                break;\n              }\n\n              abortMessage = options.abortMessage, abortCode = options.abortCode;\n              throw new AbortError(abortMessage, abortCode);\n\n            case 14:\n              _context2.next = 9;\n              break;\n\n            case 16:\n              _context2.next = 21;\n              break;\n\n            case 18:\n              _context2.prev = 18;\n              _context2.t0 = _context2[\"catch\"](7);\n\n              _iterator2.e(_context2.t0);\n\n            case 21:\n              _context2.prev = 21;\n\n              _iterator2.f();\n\n              return _context2.finish(21);\n\n            case 24:\n              abort = new Promise(function (resolve, reject) {\n                nextAbortHandler = function nextAbortHandler() {\n                  var _signals$find = signals.find(function (_ref2) {\n                    var signal = _ref2.signal;\n                    return signal.aborted;\n                  }),\n                      options = _signals$find.options;\n\n                  var abortMessage = options.abortMessage,\n                      abortCode = options.abortCode;\n                  reject(new AbortError(abortMessage, abortCode));\n                };\n              }); // Race the iterator and the abort signals\n\n              _context2.next = 27;\n              return _awaitAsyncGenerator(Promise.race([abort, source.next()]));\n\n            case 27:\n              result = _context2.sent;\n              nextAbortHandler = null;\n              _context2.next = 37;\n              break;\n\n            case 31:\n              _context2.prev = 31;\n              _context2.t1 = _context2[\"catch\"](5);\n              return _context2.delegateYield( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var _iterator3, _step3, _signal, aborter, isKnownAborter, p;\n\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _iterator3 = _createForOfIteratorHelper(signals);\n\n                        try {\n                          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                            _signal = _step3.value.signal;\n\n                            _signal.removeEventListener('abort', abortHandler);\n                          } // Might not have been aborted by a known signal\n\n                        } catch (err) {\n                          _iterator3.e(err);\n                        } finally {\n                          _iterator3.f();\n                        }\n\n                        aborter = signals.find(function (_ref3) {\n                          var signal = _ref3.signal;\n                          return signal.aborted;\n                        });\n                        isKnownAborter = _context2.t1.type === 'aborted' && aborter;\n\n                        if (!(isKnownAborter && aborter.options.onAbort)) {\n                          _context.next = 7;\n                          break;\n                        }\n\n                        _context.next = 7;\n                        return _awaitAsyncGenerator(aborter.options.onAbort(source));\n\n                      case 7:\n                        // End the iterator if it is a generator\n                        if (typeof source.return === 'function') {\n                          try {\n                            p = source.return();\n\n                            if (p instanceof Promise) {\n                              // eslint-disable-line max-depth\n                              p.catch(function (err) {\n                                if (aborter.options.onReturnError != null) {\n                                  aborter.options.onReturnError(err);\n                                }\n                              });\n                            }\n                          } catch (err) {\n                            if (aborter.options.onReturnError != null) {\n                              // eslint-disable-line max-depth\n                              aborter.options.onReturnError(err);\n                            }\n                          }\n                        }\n\n                        if (!(isKnownAborter && aborter.options.returnOnAbort)) {\n                          _context.next = 10;\n                          break;\n                        }\n\n                        return _context.abrupt(\"return\", {\n                          v: void 0\n                        });\n\n                      case 10:\n                        throw _context2.t1;\n\n                      case 11:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              })(), \"t2\", 34);\n\n            case 34:\n              _ret = _context2.t2;\n\n              if (!(typeof _ret === \"object\")) {\n                _context2.next = 37;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", _ret.v);\n\n            case 37:\n              if (!result.done) {\n                _context2.next = 39;\n                break;\n              }\n\n              return _context2.abrupt(\"break\", 43);\n\n            case 39:\n              _context2.next = 41;\n              return result.value;\n\n            case 41:\n              _context2.next = 3;\n              break;\n\n            case 43:\n              _iterator4 = _createForOfIteratorHelper(signals);\n\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  _signal3 = _step4.value.signal;\n\n                  _signal3.removeEventListener('abort', abortHandler);\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n\n            case 45:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[5, 31], [7, 18, 21, 24]]);\n    }));\n    return _abortable.apply(this, arguments);\n  }\n\n  return abortable();\n};\n\nvar toAbortableSink = function toAbortableSink(sink, signal, options) {\n  return toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{\n    signal: signal,\n    options: options\n  }]);\n};\n\nvar toMultiAbortableSink = function toMultiAbortableSink(sink, signals) {\n  return function (source) {\n    return sink(toMultiAbortableSource(source, signals));\n  };\n};\n\nvar toAbortableDuplex = function toAbortableDuplex(duplex, signal, options) {\n  return toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{\n    signal: signal,\n    options: options\n  }]);\n};\n\nvar toMultiAbortableDuplex = function toMultiAbortableDuplex(duplex, signals) {\n  return {\n    sink: toMultiAbortableSink(duplex.sink, signals),\n    source: toMultiAbortableSource(duplex.source, signals)\n  };\n};\n\nmodule.exports = toAbortableSource;\nmodule.exports.AbortError = AbortError;\nmodule.exports.source = toAbortableSource;\nmodule.exports.sink = toAbortableSink;\nmodule.exports.transform = toAbortableSink;\nmodule.exports.duplex = toAbortableDuplex;","map":{"version":3,"names":["getIterator","require","AbortError","toAbortableSource","source","signal","options","toMultiAbortableSource","Array","isArray","signals","map","abortable","abortHandler","nextAbortHandler","addEventListener","result","aborted","abortMessage","abortCode","abort","Promise","resolve","reject","find","race","next","removeEventListener","aborter","isKnownAborter","type","onAbort","return","p","catch","err","onReturnError","returnOnAbort","done","value","toAbortableSink","sink","toMultiAbortableSink","toAbortableDuplex","duplex","toMultiAbortableDuplex","module","exports","transform"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/abortable-iterator/index.js"],"sourcesContent":["const getIterator = require('get-iterator')\nconst AbortError = require('./AbortError')\n\n// Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\nconst toAbortableSource = (source, signal, options) => (\n  toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableSource = (source, signals) => {\n  source = getIterator(source)\n  signals = signals.map(({ signal, options }) => ({ signal, options: options || {} }))\n\n  async function * abortable () {\n    let nextAbortHandler\n    const abortHandler = () => {\n      if (nextAbortHandler) nextAbortHandler()\n    }\n\n    for (const { signal } of signals) {\n      signal.addEventListener('abort', abortHandler)\n    }\n\n    while (true) {\n      let result\n      try {\n        for (const { signal, options } of signals) {\n          if (signal.aborted) {\n            const { abortMessage, abortCode } = options\n            throw new AbortError(abortMessage, abortCode)\n          }\n        }\n\n        const abort = new Promise((resolve, reject) => {\n          nextAbortHandler = () => {\n            const { options } = signals.find(({ signal }) => signal.aborted)\n            const { abortMessage, abortCode } = options\n            reject(new AbortError(abortMessage, abortCode))\n          }\n        })\n\n        // Race the iterator and the abort signals\n        result = await Promise.race([abort, source.next()])\n        nextAbortHandler = null\n      } catch (err) {\n        for (const { signal } of signals) {\n          signal.removeEventListener('abort', abortHandler)\n        }\n\n        // Might not have been aborted by a known signal\n        const aborter = signals.find(({ signal }) => signal.aborted)\n        const isKnownAborter = err.type === 'aborted' && aborter\n\n        if (isKnownAborter && aborter.options.onAbort) {\n          // Do any custom abort handling for the iterator\n          await aborter.options.onAbort(source)\n        }\n\n        // End the iterator if it is a generator\n        if (typeof source.return === 'function') {\n          try {\n            const p = source.return()\n\n            if (p instanceof Promise) { // eslint-disable-line max-depth\n              p.catch(err => {\n                if (aborter.options.onReturnError != null) {\n                  aborter.options.onReturnError(err)\n                }\n              })\n            }\n          } catch (err) {\n            if (aborter.options.onReturnError != null) { // eslint-disable-line max-depth\n              aborter.options.onReturnError(err)\n            }\n          }\n        }\n\n        if (isKnownAborter && aborter.options.returnOnAbort) {\n          return\n        }\n\n        throw err\n      }\n\n      if (result.done) break\n      yield result.value\n    }\n\n    for (const { signal } of signals) {\n      signal.removeEventListener('abort', abortHandler)\n    }\n  }\n\n  return abortable()\n}\n\nconst toAbortableSink = (sink, signal, options) => (\n  toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableSink = (sink, signals) => source => (\n  sink(toMultiAbortableSource(source, signals))\n)\n\nconst toAbortableDuplex = (duplex, signal, options) => (\n  toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableDuplex = (duplex, signals) => ({\n  sink: toMultiAbortableSink(duplex.sink, signals),\n  source: toMultiAbortableSource(duplex.source, signals)\n})\n\nmodule.exports = toAbortableSource\nmodule.exports.AbortError = AbortError\nmodule.exports.source = toAbortableSource\nmodule.exports.sink = toAbortableSink\nmodule.exports.transform = toAbortableSink\nmodule.exports.duplex = toAbortableDuplex\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}