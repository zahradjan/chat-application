{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar lp = require('it-length-prefixed');\n\nvar _require = require('it-pipe'),\n    pipe = _require.pipe;\n\nvar MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');\n\nvar Message = require('./types/message');\n\nvar CONSTANTS = require('./constants');\n\nvar logger = require('./utils').logger;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n *\n * @typedef {Object} Provider\n * @property {PeerId} id\n * @property {Multiaddr[]} multiaddrs\n *\n * @typedef {Object} Stream\n * @property {AsyncIterable<Uint8Array>} source\n * @property {(output:AsyncIterable<Uint8Array>) => Promise<void>} sink\n */\n\n\nvar BITSWAP100 = '/ipfs/bitswap/1.0.0';\nvar BITSWAP110 = '/ipfs/bitswap/1.1.0';\nvar BITSWAP120 = '/ipfs/bitswap/1.2.0';\n\nvar Network = /*#__PURE__*/function () {\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {import('./bitswap')} bitswap\n   * @param {import('./stats')} stats\n   * @param {Object} [options]\n   * @param {boolean} [options.b100Only]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  function Network(libp2p, bitswap, stats) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, Network);\n\n    this._log = logger(libp2p.peerId, 'network');\n    this._libp2p = libp2p;\n    this._bitswap = bitswap;\n    this._protocols = [BITSWAP100];\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this._protocols.unshift(BITSWAP110);\n\n      this._protocols.unshift(BITSWAP120);\n    }\n\n    this._stats = stats;\n    this._running = false; // bind event listeners\n\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n    this._hashers = options.hashers || {};\n  }\n\n  _createClass(Network, [{\n    key: \"start\",\n    value: function start() {\n      this._running = true;\n\n      this._libp2p.handle(this._protocols, this._onConnection); // register protocol with topology\n\n\n      var topology = new MulticodecTopology({\n        multicodecs: this._protocols,\n        handlers: {\n          onConnect: this._onPeerConnect,\n          onDisconnect: this._onPeerDisconnect\n        }\n      });\n      this._registrarId = this._libp2p.registrar.register(topology); // All existing connections are like new ones for us\n\n      var _iterator3 = _createForOfIteratorHelper(this._libp2p.peerStore.peers.values()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var peer = _step3.value;\n\n          var conn = this._libp2p.connectionManager.get(peer.id);\n\n          conn && this._onPeerConnect(conn.remotePeer);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._running = false; // Unhandle both, libp2p doesn't care if it's not already handled\n\n      this._libp2p.unhandle(this._protocols); // unregister protocol and handlers\n\n\n      if (this._registrarId != null) {\n        this._libp2p.registrar.unregister(this._registrarId);\n      }\n    }\n    /**\n     * Handles both types of incoming bitswap messages\n     *\n     * @private\n     * @param {object} connection\n     * @param {string} connection.protocol - The protocol the stream is running\n     * @param {MuxedStream} connection.stream - A duplex iterable stream\n     * @param {Connection} connection.connection - A libp2p Connection\n     */\n\n  }, {\n    key: \"_onConnection\",\n    value: function () {\n      var _onConnection2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref) {\n        var _this = this;\n\n        var protocol, stream, connection;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                protocol = _ref.protocol, stream = _ref.stream, connection = _ref.connection;\n\n                if (this._running) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String());\n\n                _context2.prev = 4;\n                _context2.next = 7;\n                return pipe(stream, lp.decode(),\n                /*#__PURE__*/\n\n                /**\n                 * @param {AsyncIterable<Uint8Array>} source\n                 */\n                function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n                    var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, data, message;\n\n                    return _regeneratorRuntime().wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _iteratorAbruptCompletion = false;\n                            _didIteratorError = false;\n                            _context.prev = 2;\n                            _iterator = _asyncIterator(source);\n\n                          case 4:\n                            _context.next = 6;\n                            return _iterator.next();\n\n                          case 6:\n                            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                              _context.next = 23;\n                              break;\n                            }\n\n                            data = _step.value;\n                            _context.prev = 8;\n                            _context.next = 11;\n                            return Message.deserialize(data.slice(), _this._hashers);\n\n                          case 11:\n                            message = _context.sent;\n                            _context.next = 14;\n                            return _this._bitswap._receiveMessage(connection.remotePeer, message);\n\n                          case 14:\n                            _context.next = 20;\n                            break;\n\n                          case 16:\n                            _context.prev = 16;\n                            _context.t0 = _context[\"catch\"](8);\n\n                            _this._bitswap._receiveError(_context.t0);\n\n                            return _context.abrupt(\"break\", 23);\n\n                          case 20:\n                            _iteratorAbruptCompletion = false;\n                            _context.next = 4;\n                            break;\n\n                          case 23:\n                            _context.next = 29;\n                            break;\n\n                          case 25:\n                            _context.prev = 25;\n                            _context.t1 = _context[\"catch\"](2);\n                            _didIteratorError = true;\n                            _iteratorError = _context.t1;\n\n                          case 29:\n                            _context.prev = 29;\n                            _context.prev = 30;\n\n                            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                              _context.next = 34;\n                              break;\n                            }\n\n                            _context.next = 34;\n                            return _iterator.return();\n\n                          case 34:\n                            _context.prev = 34;\n\n                            if (!_didIteratorError) {\n                              _context.next = 37;\n                              break;\n                            }\n\n                            throw _iteratorError;\n\n                          case 37:\n                            return _context.finish(34);\n\n                          case 38:\n                            return _context.finish(29);\n\n                          case 39:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, null, [[2, 25, 29, 39], [8, 16], [30,, 34, 38]]);\n                  }));\n\n                  return function (_x2) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }());\n\n              case 7:\n                _context2.next = 12;\n                break;\n\n              case 9:\n                _context2.prev = 9;\n                _context2.t0 = _context2[\"catch\"](4);\n\n                this._log(_context2.t0);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[4, 9]]);\n      }));\n\n      function _onConnection(_x) {\n        return _onConnection2.apply(this, arguments);\n      }\n\n      return _onConnection;\n    }()\n    /**\n     * @private\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"_onPeerConnect\",\n    value: function _onPeerConnect(peerId) {\n      this._bitswap._onPeerConnected(peerId);\n    }\n    /**\n     * @private\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"_onPeerDisconnect\",\n    value: function _onPeerDisconnect(peerId) {\n      this._bitswap._onPeerDisconnected(peerId);\n    }\n    /**\n     * Find providers given a `cid`.\n     *\n     * @param {CID} cid\n     * @param {number} maxProviders\n     * @param {Object} [options]\n     * @param {AbortSignal} [options.signal]\n     * @returns {AsyncIterable<Provider>}\n     */\n\n  }, {\n    key: \"findProviders\",\n    value: function findProviders(cid, maxProviders) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this._libp2p.contentRouting.findProviders(cid, {\n        timeout: CONSTANTS.providerRequestTimeout,\n        maxNumProviders: maxProviders\n      });\n    }\n    /**\n     * Find the providers of a given `cid` and connect to them.\n     *\n     * @param {CID} cid\n     * @param {Object} [options]\n     * @param {AbortSignal} [options.signal]\n     */\n\n  }, {\n    key: \"findAndConnect\",\n    value: function () {\n      var _findAndConnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(cid, options) {\n        var _this2 = this;\n\n        var connectAttempts, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, provider;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                connectAttempts = [];\n                _iteratorAbruptCompletion2 = false;\n                _didIteratorError2 = false;\n                _context3.prev = 3;\n                _iterator2 = _asyncIterator(this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options));\n\n              case 5:\n                _context3.next = 7;\n                return _iterator2.next();\n\n              case 7:\n                if (!(_iteratorAbruptCompletion2 = !(_step2 = _context3.sent).done)) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                provider = _step2.value;\n\n                this._log(\"connecting to provider \".concat(provider.id));\n\n                connectAttempts.push(this.connectTo(provider.id, options).catch(function (err) {\n                  // Prevent unhandled promise rejection\n                  _this2._log.error(err);\n                }));\n\n              case 11:\n                _iteratorAbruptCompletion2 = false;\n                _context3.next = 5;\n                break;\n\n              case 14:\n                _context3.next = 20;\n                break;\n\n              case 16:\n                _context3.prev = 16;\n                _context3.t0 = _context3[\"catch\"](3);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context3.t0;\n\n              case 20:\n                _context3.prev = 20;\n                _context3.prev = 21;\n\n                if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                _context3.next = 25;\n                return _iterator2.return();\n\n              case 25:\n                _context3.prev = 25;\n\n                if (!_didIteratorError2) {\n                  _context3.next = 28;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 28:\n                return _context3.finish(25);\n\n              case 29:\n                return _context3.finish(20);\n\n              case 30:\n                _context3.next = 32;\n                return Promise.all(connectAttempts);\n\n              case 32:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 16, 20, 30], [21,, 25, 29]]);\n      }));\n\n      function findAndConnect(_x3, _x4) {\n        return _findAndConnect.apply(this, arguments);\n      }\n\n      return findAndConnect;\n    }()\n    /**\n     * Tell the network we can provide content for the passed CID\n     *\n     * @param {CID} cid\n     * @param {Object} [options]\n     * @param {AbortSignal} [options.signal]\n     */\n\n  }, {\n    key: \"provide\",\n    value: function () {\n      var _provide = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(cid, options) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._libp2p.contentRouting.provide(cid, options);\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function provide(_x5, _x6) {\n        return _provide.apply(this, arguments);\n      }\n\n      return provide;\n    }()\n    /**\n     * Connect to the given peer\n     * Send the given msg (instance of Message) to the given peer\n     *\n     * @param {PeerId} peer\n     * @param {Message} msg\n     */\n\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _sendMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(peer, msg) {\n        var stringId, connection, _yield$connection$new, stream, protocol, serialized;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this._running) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw new Error('network isn\\'t running');\n\n              case 2:\n                stringId = peer.toB58String();\n\n                this._log('sendMessage to %s', stringId, msg);\n\n                _context5.next = 6;\n                return this._libp2p.dial(peer);\n\n              case 6:\n                connection = _context5.sent;\n                _context5.next = 9;\n                return connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100]);\n\n              case 9:\n                _yield$connection$new = _context5.sent;\n                stream = _yield$connection$new.stream;\n                protocol = _yield$connection$new.protocol;\n                _context5.t0 = protocol;\n                _context5.next = _context5.t0 === BITSWAP100 ? 15 : _context5.t0 === BITSWAP110 ? 17 : _context5.t0 === BITSWAP120 ? 17 : 19;\n                break;\n\n              case 15:\n                serialized = msg.serializeToBitswap100();\n                return _context5.abrupt(\"break\", 20);\n\n              case 17:\n                serialized = msg.serializeToBitswap110();\n                return _context5.abrupt(\"break\", 20);\n\n              case 19:\n                throw new Error('Unknown protocol: ' + protocol);\n\n              case 20:\n                // Note: Don't wait for writeMessage() to complete\n                writeMessage(stream, serialized, this._log);\n\n                this._updateSentStats(peer, msg.blocks);\n\n              case 22:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function sendMessage(_x7, _x8) {\n        return _sendMessage.apply(this, arguments);\n      }\n\n      return sendMessage;\n    }()\n    /**\n     * Connects to another peer\n     *\n     * @param {PeerId|Multiaddr} peer\n     * @param {Object} [options]\n     * @param {AbortSignal} [options.signal]\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"connectTo\",\n    value: function () {\n      var _connectTo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(peer, options) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (this._running) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw new Error('network isn\\'t running');\n\n              case 2:\n                return _context6.abrupt(\"return\", this._libp2p.dial(peer, options));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function connectTo(_x9, _x10) {\n        return _connectTo.apply(this, arguments);\n      }\n\n      return connectTo;\n    }()\n    /**\n     * @private\n     * @param {PeerId} peer\n     * @param {Map<string, Uint8Array>} blocks\n     */\n\n  }, {\n    key: \"_updateSentStats\",\n    value: function _updateSentStats(peer, blocks) {\n      var peerId = peer.toB58String();\n\n      if (this._stats) {\n        var _iterator4 = _createForOfIteratorHelper(blocks.values()),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var block = _step4.value;\n\n            this._stats.push(peerId, 'dataSent', block.length);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        this._stats.push(peerId, 'blocksSent', blocks.size);\n      }\n    }\n  }]);\n\n  return Network;\n}();\n/**\n *\n * @param {MuxedStream} stream\n * @param {Uint8Array} msg\n * @param {*} log\n */\n\n\nfunction writeMessage(_x11, _x12, _x13) {\n  return _writeMessage.apply(this, arguments);\n}\n\nfunction _writeMessage() {\n  _writeMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(stream, msg, log) {\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.prev = 0;\n            _context7.next = 3;\n            return pipe([msg], lp.encode(), stream);\n\n          case 3:\n            _context7.next = 8;\n            break;\n\n          case 5:\n            _context7.prev = 5;\n            _context7.t0 = _context7[\"catch\"](0);\n            log(_context7.t0);\n\n          case 8:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7, null, [[0, 5]]);\n  }));\n  return _writeMessage.apply(this, arguments);\n}\n\nmodule.exports = Network;","map":{"version":3,"names":["lp","require","pipe","MulticodecTopology","Message","CONSTANTS","logger","BITSWAP100","BITSWAP110","BITSWAP120","Network","libp2p","bitswap","stats","options","_log","peerId","_libp2p","_bitswap","_protocols","b100Only","unshift","_stats","_running","_onPeerConnect","bind","_onPeerDisconnect","_onConnection","_hashers","hashers","handle","topology","multicodecs","handlers","onConnect","onDisconnect","_registrarId","registrar","register","peerStore","peers","values","peer","conn","connectionManager","get","id","remotePeer","unhandle","unregister","protocol","stream","connection","toB58String","decode","source","data","deserialize","slice","message","_receiveMessage","_receiveError","_onPeerConnected","_onPeerDisconnected","cid","maxProviders","contentRouting","findProviders","timeout","providerRequestTimeout","maxNumProviders","connectAttempts","maxProvidersPerRequest","provider","push","connectTo","catch","err","error","Promise","all","provide","msg","Error","stringId","dial","newStream","serialized","serializeToBitswap100","serializeToBitswap110","writeMessage","_updateSentStats","blocks","block","length","size","log","encode","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-bitswap/src/network.js"],"sourcesContent":["'use strict'\n\nconst lp = require('it-length-prefixed')\nconst { pipe } = require('it-pipe')\n\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology')\n\nconst Message = require('./types/message')\nconst CONSTANTS = require('./constants')\nconst logger = require('./utils').logger\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n *\n * @typedef {Object} Provider\n * @property {PeerId} id\n * @property {Multiaddr[]} multiaddrs\n *\n * @typedef {Object} Stream\n * @property {AsyncIterable<Uint8Array>} source\n * @property {(output:AsyncIterable<Uint8Array>) => Promise<void>} sink\n */\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0'\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0'\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0'\n\nclass Network {\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {import('./bitswap')} bitswap\n   * @param {import('./stats')} stats\n   * @param {Object} [options]\n   * @param {boolean} [options.b100Only]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  constructor (libp2p, bitswap, stats, options = {}) {\n    this._log = logger(libp2p.peerId, 'network')\n    this._libp2p = libp2p\n    this._bitswap = bitswap\n    this._protocols = [BITSWAP100]\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this._protocols.unshift(BITSWAP110)\n      this._protocols.unshift(BITSWAP120)\n    }\n\n    this._stats = stats\n    this._running = false\n\n    // bind event listeners\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)\n    this._onConnection = this._onConnection.bind(this)\n    this._hashers = options.hashers || {}\n  }\n\n  start () {\n    this._running = true\n    this._libp2p.handle(this._protocols, this._onConnection)\n\n    // register protocol with topology\n    const topology = new MulticodecTopology({\n      multicodecs: this._protocols,\n      handlers: {\n        onConnect: this._onPeerConnect,\n        onDisconnect: this._onPeerDisconnect\n      }\n    })\n    this._registrarId = this._libp2p.registrar.register(topology)\n\n    // All existing connections are like new ones for us\n    for (const peer of this._libp2p.peerStore.peers.values()) {\n      const conn = this._libp2p.connectionManager.get(peer.id)\n\n      conn && this._onPeerConnect(conn.remotePeer)\n    }\n  }\n\n  stop () {\n    this._running = false\n\n    // Unhandle both, libp2p doesn't care if it's not already handled\n    this._libp2p.unhandle(this._protocols)\n\n    // unregister protocol and handlers\n    if (this._registrarId != null) {\n      this._libp2p.registrar.unregister(this._registrarId)\n    }\n  }\n\n  /**\n   * Handles both types of incoming bitswap messages\n   *\n   * @private\n   * @param {object} connection\n   * @param {string} connection.protocol - The protocol the stream is running\n   * @param {MuxedStream} connection.stream - A duplex iterable stream\n   * @param {Connection} connection.connection - A libp2p Connection\n   */\n  async _onConnection ({ protocol, stream, connection }) {\n    if (!this._running) { return }\n    this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String())\n\n    try {\n      await pipe(\n        stream,\n        lp.decode(),\n        /**\n         * @param {AsyncIterable<Uint8Array>} source\n         */\n        async (source) => {\n          for await (const data of source) {\n            try {\n              const message = await Message.deserialize(data.slice(), this._hashers)\n              await this._bitswap._receiveMessage(connection.remotePeer, message)\n            } catch (err) {\n              this._bitswap._receiveError(err)\n              break\n            }\n          }\n        }\n      )\n    } catch (err) {\n      this._log(err)\n    }\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerConnect (peerId) {\n    this._bitswap._onPeerConnected(peerId)\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnect (peerId) {\n    this._bitswap._onPeerDisconnected(peerId)\n  }\n\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {number} maxProviders\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {AsyncIterable<Provider>}\n   */\n  findProviders (cid, maxProviders, options = {}) {\n    return this._libp2p.contentRouting.findProviders(\n      cid,\n      {\n        timeout: CONSTANTS.providerRequestTimeout,\n        maxNumProviders: maxProviders\n      }\n    )\n  }\n\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async findAndConnect (cid, options) {\n    const connectAttempts = []\n    for await (const provider of this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options)) {\n      this._log(`connecting to provider ${provider.id}`)\n      connectAttempts.push(\n        this.connectTo(provider.id, options)\n          .catch(err => {\n            // Prevent unhandled promise rejection\n            this._log.error(err)\n          })\n      )\n    }\n    await Promise.all(connectAttempts)\n  }\n\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async provide (cid, options) {\n    // @ts-expect-error - contentRouting takes no options\n    await this._libp2p.contentRouting.provide(cid, options)\n  }\n\n  /**\n   * Connect to the given peer\n   * Send the given msg (instance of Message) to the given peer\n   *\n   * @param {PeerId} peer\n   * @param {Message} msg\n   */\n  async sendMessage (peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running')\n\n    const stringId = peer.toB58String()\n    this._log('sendMessage to %s', stringId, msg)\n\n    const connection = await this._libp2p.dial(peer)\n    const { stream, protocol } = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100])\n\n    /** @type {Uint8Array} */\n    let serialized\n    switch (protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100()\n        break\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110()\n        break\n      default:\n        throw new Error('Unknown protocol: ' + protocol)\n    }\n\n    // Note: Don't wait for writeMessage() to complete\n    writeMessage(stream, serialized, this._log)\n\n    this._updateSentStats(peer, msg.blocks)\n  }\n\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  async connectTo (peer, options) { // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running')\n    }\n\n    return this._libp2p.dial(peer, options)\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peer\n   * @param {Map<string, Uint8Array>} blocks\n   */\n  _updateSentStats (peer, blocks) {\n    const peerId = peer.toB58String()\n\n    if (this._stats) {\n      for (const block of blocks.values()) {\n        this._stats.push(peerId, 'dataSent', block.length)\n      }\n\n      this._stats.push(peerId, 'blocksSent', blocks.size)\n    }\n  }\n}\n\n/**\n *\n * @param {MuxedStream} stream\n * @param {Uint8Array} msg\n * @param {*} log\n */\nasync function writeMessage (stream, msg, log) {\n  try {\n    await pipe(\n      [msg],\n      lp.encode(),\n      stream\n    )\n  } catch (err) {\n    log(err)\n  }\n}\n\nmodule.exports = Network\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}