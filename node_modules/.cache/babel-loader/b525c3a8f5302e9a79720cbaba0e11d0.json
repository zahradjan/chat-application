{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageDeliveries = exports.DeliveryRecordStatus = void 0;\n\nconst constants_1 = require(\"../constants\");\n\nconst denque_1 = __importDefault(require(\"denque\"));\n\nconst utils_1 = require(\"../utils\");\n\nvar DeliveryRecordStatus;\n\n(function (DeliveryRecordStatus) {\n  /**\n   * we don't know (yet) if the message is valid\n   */\n  DeliveryRecordStatus[DeliveryRecordStatus[\"unknown\"] = 0] = \"unknown\";\n  /**\n   * we know the message is valid\n   */\n\n  DeliveryRecordStatus[DeliveryRecordStatus[\"valid\"] = 1] = \"valid\";\n  /**\n   * we know the message is invalid\n   */\n\n  DeliveryRecordStatus[DeliveryRecordStatus[\"invalid\"] = 2] = \"invalid\";\n  /**\n   * we were instructed by the validator to ignore the message\n   */\n\n  DeliveryRecordStatus[DeliveryRecordStatus[\"ignored\"] = 3] = \"ignored\";\n})(DeliveryRecordStatus = exports.DeliveryRecordStatus || (exports.DeliveryRecordStatus = {}));\n/**\n * Map of message ID to DeliveryRecord\n *\n * Maintains an internal queue for efficient gc of old messages\n */\n\n\nclass MessageDeliveries {\n  constructor() {\n    this.records = new Map();\n    this.queue = new denque_1.default();\n  }\n\n  ensureRecord(msgId) {\n    const msgIdStr = utils_1.messageIdToString(msgId);\n    let drec = this.records.get(msgIdStr);\n\n    if (drec) {\n      return drec;\n    } // record doesn't exist yet\n    // create record\n\n\n    drec = {\n      status: DeliveryRecordStatus.unknown,\n      firstSeen: Date.now(),\n      validated: 0,\n      peers: new Set()\n    };\n    this.records.set(msgIdStr, drec); // and add msgId to the queue\n\n    const entry = {\n      msgId: msgIdStr,\n      expire: Date.now() + constants_1.TimeCacheDuration\n    };\n    this.queue.push(entry);\n    return drec;\n  }\n\n  gc() {\n    const now = Date.now(); // queue is sorted by expiry time\n    // remove expired messages, remove from queue until first un-expired message found\n\n    let head = this.queue.peekFront();\n\n    while (head && head.expire < now) {\n      this.records.delete(head.msgId);\n      this.queue.shift();\n      head = this.queue.peekFront();\n    }\n  }\n\n  clear() {\n    this.records.clear();\n    this.queue.clear();\n  }\n\n}\n\nexports.MessageDeliveries = MessageDeliveries;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MessageDeliveries","DeliveryRecordStatus","constants_1","require","denque_1","utils_1","constructor","records","Map","queue","default","ensureRecord","msgId","msgIdStr","messageIdToString","drec","get","status","unknown","firstSeen","Date","now","validated","peers","Set","set","entry","expire","TimeCacheDuration","push","gc","head","peekFront","delete","shift","clear"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-gossipsub/src/score/message-deliveries.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageDeliveries = exports.DeliveryRecordStatus = void 0;\nconst constants_1 = require(\"../constants\");\nconst denque_1 = __importDefault(require(\"denque\"));\nconst utils_1 = require(\"../utils\");\nvar DeliveryRecordStatus;\n(function (DeliveryRecordStatus) {\n    /**\n     * we don't know (yet) if the message is valid\n     */\n    DeliveryRecordStatus[DeliveryRecordStatus[\"unknown\"] = 0] = \"unknown\";\n    /**\n     * we know the message is valid\n     */\n    DeliveryRecordStatus[DeliveryRecordStatus[\"valid\"] = 1] = \"valid\";\n    /**\n     * we know the message is invalid\n     */\n    DeliveryRecordStatus[DeliveryRecordStatus[\"invalid\"] = 2] = \"invalid\";\n    /**\n     * we were instructed by the validator to ignore the message\n     */\n    DeliveryRecordStatus[DeliveryRecordStatus[\"ignored\"] = 3] = \"ignored\";\n})(DeliveryRecordStatus = exports.DeliveryRecordStatus || (exports.DeliveryRecordStatus = {}));\n/**\n * Map of message ID to DeliveryRecord\n *\n * Maintains an internal queue for efficient gc of old messages\n */\nclass MessageDeliveries {\n    constructor() {\n        this.records = new Map();\n        this.queue = new denque_1.default();\n    }\n    ensureRecord(msgId) {\n        const msgIdStr = utils_1.messageIdToString(msgId);\n        let drec = this.records.get(msgIdStr);\n        if (drec) {\n            return drec;\n        }\n        // record doesn't exist yet\n        // create record\n        drec = {\n            status: DeliveryRecordStatus.unknown,\n            firstSeen: Date.now(),\n            validated: 0,\n            peers: new Set()\n        };\n        this.records.set(msgIdStr, drec);\n        // and add msgId to the queue\n        const entry = {\n            msgId: msgIdStr,\n            expire: Date.now() + constants_1.TimeCacheDuration\n        };\n        this.queue.push(entry);\n        return drec;\n    }\n    gc() {\n        const now = Date.now();\n        // queue is sorted by expiry time\n        // remove expired messages, remove from queue until first un-expired message found\n        let head = this.queue.peekFront();\n        while (head && head.expire < now) {\n            this.records.delete(head.msgId);\n            this.queue.shift();\n            head = this.queue.peekFront();\n        }\n    }\n    clear() {\n        this.records.clear();\n        this.queue.clear();\n    }\n}\nexports.MessageDeliveries = MessageDeliveries;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}