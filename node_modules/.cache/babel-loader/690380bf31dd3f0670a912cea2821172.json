{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _defineProperty = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _codecCodes;\n\nvar Block = require('multiformats/block');\n\nvar _require = require('multiformats/cid'),\n    CID = _require.CID;\n\nvar dagPb = require('@ipld/dag-pb');\n\nvar dagCbor = require('@ipld/dag-cbor');\n\nvar _require2 = require('multiformats/hashes/sha2'),\n    hasher = _require2.sha256;\n\nvar mhtype = 'sha2-256';\n\nvar _require3 = require('multiformats/bases/base58'),\n    base58btc = _require3.base58btc;\n\nvar defaultBase = base58btc;\n\nvar unsupportedCodecError = function unsupportedCodecError() {\n  return new Error('unsupported codec');\n};\n\nvar cidifyString = function cidifyString(str) {\n  if (!str) {\n    return str;\n  }\n\n  if (Array.isArray(str)) {\n    return str.map(cidifyString);\n  }\n\n  return CID.parse(str);\n};\n\nvar stringifyCid = function stringifyCid(cid) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!cid || typeof cid === 'string') {\n    return cid;\n  }\n\n  if (Array.isArray(cid)) {\n    return cid.map(stringifyCid);\n  }\n\n  if (cid['/']) {\n    return cid['/'];\n  }\n\n  var base = options.base || defaultBase;\n  return cid.toString(base);\n};\n\nvar codecCodes = (_codecCodes = {}, _defineProperty(_codecCodes, dagPb.code, dagPb), _defineProperty(_codecCodes, dagCbor.code, dagCbor), _codecCodes);\nvar codecMap = {\n  // staying backward compatible\n  // old writeObj function was never raw codec; defaulted to cbor via ipfs.dag\n  raw: dagCbor,\n  'dag-pb': dagPb,\n  'dag-cbor': dagCbor\n};\n\nfunction read(_x, _x2) {\n  return _read.apply(this, arguments);\n}\n\nfunction _read() {\n  _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ipfs, cid) {\n    var options,\n        codec,\n        bytes,\n        block,\n        value,\n        links,\n        _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n            cid = cidifyString(stringifyCid(cid));\n            codec = codecCodes[cid.code];\n\n            if (codec) {\n              _context.next = 5;\n              break;\n            }\n\n            throw unsupportedCodecError();\n\n          case 5:\n            _context.next = 7;\n            return ipfs.block.get(cid, {\n              timeout: options.timeout\n            });\n\n          case 7:\n            bytes = _context.sent;\n            _context.next = 10;\n            return Block.decode({\n              bytes: bytes,\n              codec: codec,\n              hasher: hasher\n            });\n\n          case 10:\n            block = _context.sent;\n\n            if (!(block.cid.code === dagPb.code)) {\n              _context.next = 13;\n              break;\n            }\n\n            return _context.abrupt(\"return\", JSON.parse(new TextDecoder().decode(block.value.Data)));\n\n          case 13:\n            if (!(block.cid.code === dagCbor.code)) {\n              _context.next = 18;\n              break;\n            }\n\n            value = block.value;\n            links = options.links || [];\n            links.forEach(function (prop) {\n              if (value[prop]) {\n                value[prop] = stringifyCid(value[prop], options);\n              }\n            });\n            return _context.abrupt(\"return\", value);\n\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _read.apply(this, arguments);\n}\n\nfunction write(_x3, _x4, _x5) {\n  return _write.apply(this, arguments);\n}\n\nfunction _write() {\n  _write = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(ipfs, format, value) {\n    var options,\n        codec,\n        links,\n        block,\n        cid,\n        _args2 = arguments;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};\n            if (options.format === 'dag-pb') format = options.format;\n            codec = codecMap[format];\n\n            if (codec) {\n              _context2.next = 5;\n              break;\n            }\n\n            throw unsupportedCodecError();\n\n          case 5:\n            if (codec.code === dagPb.code) {\n              value = typeof value === 'string' ? value : JSON.stringify(value);\n              value = {\n                Data: new TextEncoder().encode(value),\n                Links: []\n              };\n            }\n\n            if (codec.code === dagCbor.code) {\n              links = options.links || [];\n              links.forEach(function (prop) {\n                if (value[prop]) {\n                  value[prop] = cidifyString(value[prop]);\n                }\n              });\n            }\n\n            _context2.next = 9;\n            return Block.encode({\n              value: value,\n              codec: codec,\n              hasher: hasher\n            });\n\n          case 9:\n            block = _context2.sent;\n            _context2.next = 12;\n            return ipfs.block.put(block.bytes, {\n              cid: block.cid.bytes,\n              version: block.cid.version,\n              format: format,\n              mhtype: mhtype,\n              pin: options.pin,\n              timeout: options.timeout\n            });\n\n          case 12:\n            cid = codec.code === dagPb.code ? block.cid.toV0() : block.cid;\n            return _context2.abrupt(\"return\", cid.toString(options.base || defaultBase));\n\n          case 14:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _write.apply(this, arguments);\n}\n\nmodule.exports = {\n  read: read,\n  write: write\n};","map":{"version":3,"names":["Block","require","CID","dagPb","dagCbor","hasher","sha256","mhtype","base58btc","defaultBase","unsupportedCodecError","Error","cidifyString","str","Array","isArray","map","parse","stringifyCid","cid","options","base","toString","codecCodes","code","codecMap","raw","read","ipfs","codec","block","get","timeout","bytes","decode","JSON","TextDecoder","value","Data","links","forEach","prop","write","format","stringify","TextEncoder","encode","Links","put","version","pin","toV0","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-io/index.js"],"sourcesContent":["'use strict'\nconst Block = require('multiformats/block')\nconst { CID } = require('multiformats/cid')\nconst dagPb = require('@ipld/dag-pb')\nconst dagCbor = require('@ipld/dag-cbor')\nconst { sha256: hasher } = require('multiformats/hashes/sha2')\nconst mhtype = 'sha2-256'\nconst { base58btc } = require('multiformats/bases/base58')\nconst defaultBase = base58btc\nconst unsupportedCodecError = () => new Error('unsupported codec')\n\nconst cidifyString = (str) => {\n  if (!str) {\n    return str\n  }\n\n  if (Array.isArray(str)) {\n    return str.map(cidifyString)\n  }\n\n  return CID.parse(str)\n}\n\nconst stringifyCid = (cid, options = {}) => {\n  if (!cid || typeof cid === 'string') {\n    return cid\n  }\n\n  if (Array.isArray(cid)) {\n    return cid.map(stringifyCid)\n  }\n\n  if (cid['/']) {\n    return cid['/']\n  }\n\n  const base = options.base || defaultBase\n  return cid.toString(base)\n}\n\nconst codecCodes = {\n  [dagPb.code]: dagPb,\n  [dagCbor.code]: dagCbor\n}\nconst codecMap = {\n  // staying backward compatible\n  // old writeObj function was never raw codec; defaulted to cbor via ipfs.dag\n  raw: dagCbor,\n  'dag-pb': dagPb,\n  'dag-cbor': dagCbor\n}\n\nasync function read (ipfs, cid, options = {}) {\n  cid = cidifyString(stringifyCid(cid))\n\n  const codec = codecCodes[cid.code]\n  if (!codec) throw unsupportedCodecError()\n\n  const bytes = await ipfs.block.get(cid, { timeout: options.timeout })\n  const block = await Block.decode({ bytes, codec, hasher })\n\n  if (block.cid.code === dagPb.code) {\n    return JSON.parse(new TextDecoder().decode(block.value.Data))\n  }\n  if (block.cid.code === dagCbor.code) {\n    const value = block.value\n    const links = options.links || []\n    links.forEach((prop) => {\n      if (value[prop]) {\n        value[prop] = stringifyCid(value[prop], options)\n      }\n    })\n    return value\n  }\n}\n\nasync function write (ipfs, format, value, options = {}) {\n  if (options.format === 'dag-pb') format = options.format\n  const codec = codecMap[format]\n  if (!codec) throw unsupportedCodecError()\n\n  if (codec.code === dagPb.code) {\n    value = typeof value === 'string' ? value : JSON.stringify(value)\n    value = { Data: new TextEncoder().encode(value), Links: [] }\n  }\n  if (codec.code === dagCbor.code) {\n    const links = options.links || []\n    links.forEach((prop) => {\n      if (value[prop]) {\n        value[prop] = cidifyString(value[prop])\n      }\n    })\n  }\n\n  const block = await Block.encode({ value, codec, hasher })\n  await ipfs.block.put(block.bytes, {\n    cid: block.cid.bytes,\n    version: block.cid.version,\n    format,\n    mhtype,\n    pin: options.pin,\n    timeout: options.timeout\n  })\n\n  const cid = codec.code === dagPb.code\n    ? block.cid.toV0()\n    : block.cid\n  return cid.toString(options.base || defaultBase)\n}\n\nmodule.exports = {\n  read,\n  write\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}