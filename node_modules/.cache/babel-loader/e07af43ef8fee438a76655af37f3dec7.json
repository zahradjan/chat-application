{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer'); // @ts-ignore\n\n\nconst BufferList = require('bl/BufferList');\n\nconst varintDecode = require('./varint-decode'); // Maximum length of the length section of the message\n\n\nconst MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\n\nconst MAX_DATA_LENGTH = 1024 * 1024 * 4;\nconst Empty = Buffer.alloc(0);\nconst ReadModes = {\n  LENGTH: 'readLength',\n  DATA: 'readData'\n};\nconst ReadHandlers = {\n  /**\n   * @param {BufferList} chunk\n   * @param {BufferList} buffer\n   * @param {import('./types').ReadState | undefined} state\n   * @param {import('./types').DecoderOptions} options\n   * @returns {import('./types').ReadResult}\n   */\n  [ReadModes.LENGTH]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.LENGTH, chunk.length)\n    buffer = buffer.append(chunk);\n    let dataLength;\n\n    try {\n      dataLength = options.lengthDecoder(buffer);\n    } catch (err) {\n      if (buffer.length > options.maxLengthLength) {\n        throw Object.assign(err, {\n          message: 'message length too long',\n          code: 'ERR_MSG_LENGTH_TOO_LONG'\n        });\n      }\n\n      if (err instanceof RangeError) {\n        return {\n          mode: ReadModes.LENGTH,\n          buffer,\n          chunk: undefined,\n          state: undefined,\n          data: undefined\n        };\n      }\n\n      throw err;\n    }\n\n    if (dataLength > options.maxDataLength) {\n      throw Object.assign(new Error('message data too long'), {\n        code: 'ERR_MSG_DATA_TOO_LONG'\n      });\n    }\n\n    chunk = buffer.shallowSlice(options.lengthDecoder.bytes);\n    buffer = new BufferList();\n    if (options.onLength) options.onLength(dataLength);\n\n    if (dataLength <= 0) {\n      if (options.onData) options.onData(Empty);\n      return {\n        mode: ReadModes.LENGTH,\n        chunk,\n        buffer,\n        data: Empty\n      };\n    }\n\n    return {\n      mode: ReadModes.DATA,\n      chunk,\n      buffer,\n      state: {\n        dataLength\n      },\n      data: undefined\n    };\n  },\n\n  /**\n   * @param {BufferList} chunk\n   * @param {BufferList} buffer\n   * @param {import('./types').ReadState | undefined} state\n   * @param {import('./types').DecoderOptions} options\n   * @returns {import('./types').ReadResult}\n   */\n  [ReadModes.DATA]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.DATA, chunk.length)\n    buffer = buffer.append(chunk);\n\n    if (!state) {\n      throw new Error('state is required');\n    }\n\n    if (buffer.length < state.dataLength) {\n      return {\n        mode: ReadModes.DATA,\n        buffer,\n        state,\n        chunk: undefined,\n        data: undefined\n      };\n    }\n\n    const {\n      dataLength\n    } = state;\n    const data = buffer.shallowSlice(0, dataLength);\n    const nextChunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : undefined;\n    buffer = new BufferList();\n    if (options.onData) options.onData(data);\n    return {\n      mode: ReadModes.LENGTH,\n      chunk: nextChunk,\n      buffer,\n      state: undefined,\n      data\n    };\n  }\n};\n/**\n * @param {any} [options]\n */\n\nfunction decode(options) {\n  options = options || {};\n  /**\n   * @type {import('./types').DecoderOptions}\n   */\n\n  const opts = {\n    lengthDecoder: options.lengthDecoder || varintDecode,\n    maxLengthLength: options.maxLengthLength || MAX_LENGTH_LENGTH,\n    maxDataLength: options.maxDataLength || MAX_DATA_LENGTH,\n    onLength: options.onLength,\n    onData: options.onData\n  };\n  /**\n   * @param {AsyncIterable<BufferList>} source\n   */\n\n  const decoder = async function* (source) {\n    let buffer = new BufferList();\n    let mode = ReadModes.LENGTH; // current parsing mode\n\n    let state; // accumulated state for the current mode\n\n    for await (const chunk of source) {\n      /** @type {BufferList | undefined} */\n      let nextChunk = chunk; // Each chunk may contain multiple messages - keep calling handler for the\n      // current parsing mode until all handlers have consumed the chunk.\n\n      while (nextChunk) {\n        const result = ReadHandlers[mode](nextChunk, buffer, state, opts);\n        mode = result.mode;\n        nextChunk = result.chunk;\n        buffer = result.buffer;\n        state = result.state;\n\n        if (result.data) {\n          yield result.data;\n        }\n      }\n    }\n\n    if (buffer.length) {\n      throw Object.assign(new Error('unexpected end of input'), {\n        code: 'ERR_UNEXPECTED_EOF'\n      });\n    }\n  };\n\n  return decoder;\n}\n/**\n * @param {*} reader\n * @param {import('./types').DecoderOptions} [options]\n * @returns\n */\n\n\ndecode.fromReader = (reader, options) => {\n  let byteLength = 1; // Read single byte chunks until the length is known\n\n  const varByteSource = {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    next: async () => {\n      try {\n        return await reader.next(byteLength);\n      } catch (err) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return {\n            done: true,\n            value: null\n          };\n        }\n\n        throw err;\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1;\n      }\n    }\n  };\n  /**\n   * Once the length has been parsed, read chunk for that length\n   *\n   * @param {number} l\n   */\n\n  const onLength = l => {\n    byteLength = l;\n  };\n\n  return decode({ ...(options || {}),\n    onLength\n  })(varByteSource);\n};\n\nmodule.exports = decode;\nmodule.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH;\nmodule.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH;","map":{"version":3,"names":["Buffer","require","BufferList","varintDecode","MAX_LENGTH_LENGTH","MAX_DATA_LENGTH","Empty","alloc","ReadModes","LENGTH","DATA","ReadHandlers","chunk","buffer","state","options","append","dataLength","lengthDecoder","err","length","maxLengthLength","Object","assign","message","code","RangeError","mode","undefined","data","maxDataLength","Error","shallowSlice","bytes","onLength","onData","nextChunk","decode","opts","decoder","source","result","fromReader","reader","byteLength","varByteSource","Symbol","asyncIterator","next","done","value","l","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/it-length-prefixed/src/decode.js"],"sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\n// @ts-ignore\nconst BufferList = require('bl/BufferList')\nconst varintDecode = require('./varint-decode')\n\n// Maximum length of the length section of the message\nconst MAX_LENGTH_LENGTH = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nconst MAX_DATA_LENGTH = 1024 * 1024 * 4\n\nconst Empty = Buffer.alloc(0)\nconst ReadModes = { LENGTH: 'readLength', DATA: 'readData' }\n\nconst ReadHandlers = {\n  /**\n   * @param {BufferList} chunk\n   * @param {BufferList} buffer\n   * @param {import('./types').ReadState | undefined} state\n   * @param {import('./types').DecoderOptions} options\n   * @returns {import('./types').ReadResult}\n   */\n  [ReadModes.LENGTH]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.LENGTH, chunk.length)\n    buffer = buffer.append(chunk)\n\n    let dataLength\n    try {\n      dataLength = options.lengthDecoder(buffer)\n    } catch (err) {\n      if (buffer.length > options.maxLengthLength) {\n        throw Object.assign(err, { message: 'message length too long', code: 'ERR_MSG_LENGTH_TOO_LONG' })\n      }\n      if (err instanceof RangeError) {\n        return { mode: ReadModes.LENGTH, buffer, chunk: undefined, state: undefined, data: undefined }\n      }\n      throw err\n    }\n\n    if (dataLength > options.maxDataLength) {\n      throw Object.assign(new Error('message data too long'), { code: 'ERR_MSG_DATA_TOO_LONG' })\n    }\n\n    chunk = buffer.shallowSlice(options.lengthDecoder.bytes)\n    buffer = new BufferList()\n\n    if (options.onLength) options.onLength(dataLength)\n\n    if (dataLength <= 0) {\n      if (options.onData) options.onData(Empty)\n      return { mode: ReadModes.LENGTH, chunk, buffer, data: Empty }\n    }\n\n    return { mode: ReadModes.DATA, chunk, buffer, state: { dataLength }, data: undefined }\n  },\n\n  /**\n   * @param {BufferList} chunk\n   * @param {BufferList} buffer\n   * @param {import('./types').ReadState | undefined} state\n   * @param {import('./types').DecoderOptions} options\n   * @returns {import('./types').ReadResult}\n   */\n  [ReadModes.DATA]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.DATA, chunk.length)\n    buffer = buffer.append(chunk)\n\n    if (!state) {\n      throw new Error('state is required')\n    }\n\n    if (buffer.length < state.dataLength) {\n      return { mode: ReadModes.DATA, buffer, state, chunk: undefined, data: undefined }\n    }\n\n    const { dataLength } = state\n    const data = buffer.shallowSlice(0, dataLength)\n\n    const nextChunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : undefined\n    buffer = new BufferList()\n\n    if (options.onData) options.onData(data)\n    return { mode: ReadModes.LENGTH, chunk: nextChunk, buffer, state: undefined, data }\n  }\n}\n\n/**\n * @param {any} [options]\n */\nfunction decode (options) {\n  options = options || {}\n\n  /**\n   * @type {import('./types').DecoderOptions}\n   */\n  const opts = {\n    lengthDecoder: options.lengthDecoder || varintDecode,\n    maxLengthLength: options.maxLengthLength || MAX_LENGTH_LENGTH,\n    maxDataLength: options.maxDataLength || MAX_DATA_LENGTH,\n    onLength: options.onLength,\n    onData: options.onData\n  }\n\n  /**\n   * @param {AsyncIterable<BufferList>} source\n   */\n  const decoder = async function * (source) {\n    let buffer = new BufferList()\n    let mode = ReadModes.LENGTH // current parsing mode\n    let state // accumulated state for the current mode\n\n    for await (const chunk of source) {\n      /** @type {BufferList | undefined} */\n      let nextChunk = chunk\n\n      // Each chunk may contain multiple messages - keep calling handler for the\n      // current parsing mode until all handlers have consumed the chunk.\n      while (nextChunk) {\n        const result = ReadHandlers[mode](nextChunk, buffer, state, opts)\n\n        mode = result.mode\n        nextChunk = result.chunk\n        buffer = result.buffer\n        state = result.state\n\n        if (result.data) {\n          yield result.data\n        }\n      }\n    }\n\n    if (buffer.length) {\n      throw Object.assign(new Error('unexpected end of input'), { code: 'ERR_UNEXPECTED_EOF' })\n    }\n  }\n\n  return decoder\n}\n\n/**\n * @param {*} reader\n * @param {import('./types').DecoderOptions} [options]\n * @returns\n */\ndecode.fromReader = (reader, options) => {\n  let byteLength = 1 // Read single byte chunks until the length is known\n\n  const varByteSource = {\n    [Symbol.asyncIterator] () { return this },\n    next: async () => {\n      try {\n        return await reader.next(byteLength)\n      } catch (err) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return { done: true, value: null }\n        }\n        throw err\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1\n      }\n    }\n  }\n\n  /**\n   * Once the length has been parsed, read chunk for that length\n   *\n   * @param {number} l\n   */\n  const onLength = l => { byteLength = l }\n  return decode({\n    ...(options || {}),\n    onLength\n  })(varByteSource)\n}\n\nmodule.exports = decode\nmodule.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH\nmodule.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}