{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar errcode = require('err-code');\n\nvar secp = require('@noble/secp256k1');\n\nvar _require = require('multiformats/hashes/sha2'),\n    sha256 = _require.sha256;\n\nmodule.exports = function () {\n  var privateKeyLength = 32;\n\n  function generateKey() {\n    return secp.utils.randomPrivateKey();\n  }\n  /**\n   * Hash and sign message with private key\n   *\n   * @param {number | bigint | (string | Uint8Array)} key\n   * @param {Uint8Array} msg\n   */\n\n\n  function hashAndSign(_x, _x2) {\n    return _hashAndSign.apply(this, arguments);\n  }\n  /**\n   * Hash message and verify signature with public key\n   *\n   * @param {secp.Point | (string | Uint8Array)} key\n   * @param {(string | Uint8Array) | secp.Signature} sig\n   * @param {Uint8Array} msg\n   */\n\n\n  function _hashAndSign() {\n    _hashAndSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, msg) {\n      var _yield$sha256$digest, digest;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return sha256.digest(msg);\n\n            case 2:\n              _yield$sha256$digest = _context.sent;\n              digest = _yield$sha256$digest.digest;\n              _context.prev = 4;\n              _context.next = 7;\n              return secp.sign(digest, key);\n\n            case 7:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](4);\n              throw errcode(_context.t0, 'ERR_INVALID_INPUT');\n\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[4, 10]]);\n    }));\n    return _hashAndSign.apply(this, arguments);\n  }\n\n  function hashAndVerify(_x3, _x4, _x5) {\n    return _hashAndVerify.apply(this, arguments);\n  }\n\n  function _hashAndVerify() {\n    _hashAndVerify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key, sig, msg) {\n      var _yield$sha256$digest2, digest;\n\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return sha256.digest(msg);\n\n            case 3:\n              _yield$sha256$digest2 = _context2.sent;\n              digest = _yield$sha256$digest2.digest;\n              return _context2.abrupt(\"return\", secp.verify(sig, digest, key));\n\n            case 8:\n              _context2.prev = 8;\n              _context2.t0 = _context2[\"catch\"](0);\n              throw errcode(_context2.t0, 'ERR_INVALID_INPUT');\n\n            case 11:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 8]]);\n    }));\n    return _hashAndVerify.apply(this, arguments);\n  }\n\n  function compressPublicKey(key) {\n    var point = secp.Point.fromHex(key).toRawBytes(true);\n    return point;\n  }\n\n  function decompressPublicKey(key) {\n    var point = secp.Point.fromHex(key).toRawBytes(false);\n    return point;\n  }\n\n  function validatePrivateKey(key) {\n    try {\n      secp.getPublicKey(key, true);\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_PRIVATE_KEY');\n    }\n  }\n\n  function validatePublicKey(key) {\n    try {\n      secp.Point.fromHex(key);\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_PUBLIC_KEY');\n    }\n  }\n\n  function computePublicKey(privateKey) {\n    try {\n      return secp.getPublicKey(privateKey, true);\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_PRIVATE_KEY');\n    }\n  }\n\n  return {\n    generateKey: generateKey,\n    privateKeyLength: privateKeyLength,\n    hashAndSign: hashAndSign,\n    hashAndVerify: hashAndVerify,\n    compressPublicKey: compressPublicKey,\n    decompressPublicKey: decompressPublicKey,\n    validatePrivateKey: validatePrivateKey,\n    validatePublicKey: validatePublicKey,\n    computePublicKey: computePublicKey\n  };\n};","map":{"version":3,"names":["errcode","require","secp","sha256","module","exports","privateKeyLength","generateKey","utils","randomPrivateKey","hashAndSign","key","msg","digest","sign","hashAndVerify","sig","verify","compressPublicKey","point","Point","fromHex","toRawBytes","decompressPublicKey","validatePrivateKey","getPublicKey","err","validatePublicKey","computePublicKey","privateKey"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-delegated-content-routing/node_modules/libp2p-crypto/src/keys/secp256k1.js"],"sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst secp = require('@noble/secp256k1')\nconst { sha256 } = require('multiformats/hashes/sha2')\n\nmodule.exports = () => {\n  const privateKeyLength = 32\n\n  function generateKey () {\n    return secp.utils.randomPrivateKey()\n  }\n\n  /**\n   * Hash and sign message with private key\n   *\n   * @param {number | bigint | (string | Uint8Array)} key\n   * @param {Uint8Array} msg\n   */\n  async function hashAndSign (key, msg) {\n    const { digest } = await sha256.digest(msg)\n    try {\n      return await secp.sign(digest, key)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_INPUT')\n    }\n  }\n\n  /**\n   * Hash message and verify signature with public key\n   *\n   * @param {secp.Point | (string | Uint8Array)} key\n   * @param {(string | Uint8Array) | secp.Signature} sig\n   * @param {Uint8Array} msg\n   */\n  async function hashAndVerify (key, sig, msg) {\n    try {\n      const { digest } = await sha256.digest(msg)\n      return secp.verify(sig, digest, key)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_INPUT')\n    }\n  }\n\n  function compressPublicKey (key) {\n    const point = secp.Point.fromHex(key).toRawBytes(true)\n    return point\n  }\n\n  function decompressPublicKey (key) {\n    const point = secp.Point.fromHex(key).toRawBytes(false)\n    return point\n  }\n\n  function validatePrivateKey (key) {\n    try {\n      secp.getPublicKey(key, true)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_PRIVATE_KEY')\n    }\n  }\n\n  function validatePublicKey (key) {\n    try {\n      secp.Point.fromHex(key)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_PUBLIC_KEY')\n    }\n  }\n\n  function computePublicKey (privateKey) {\n    try {\n      return secp.getPublicKey(privateKey, true)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_PRIVATE_KEY')\n    }\n  }\n\n  return {\n    generateKey,\n    privateKeyLength,\n    hashAndSign,\n    hashAndVerify,\n    compressPublicKey,\n    decompressPublicKey,\n    validatePrivateKey,\n    validatePublicKey,\n    computePublicKey\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}