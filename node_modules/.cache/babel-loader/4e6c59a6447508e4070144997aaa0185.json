{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _assertThisInitialized = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _get = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/get.js\").default;\n\nvar _getPrototypeOf = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('libp2p'), {\n  error: debug('libp2p:err')\n});\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar errCode = require('err-code');\n\nvar PeerId = require('peer-id');\n\nvar _require2 = require('multiaddr'),\n    Multiaddr = _require2.Multiaddr;\n\nvar PeerRouting = require('./peer-routing');\n\nvar ContentRouting = require('./content-routing');\n\nvar getPeer = require('./get-peer');\n\nvar _require3 = require('./config'),\n    validateConfig = _require3.validate;\n\nvar _require4 = require('./errors'),\n    codes = _require4.codes,\n    messages = _require4.messages;\n\nvar AddressManager = require('./address-manager');\n\nvar ConnectionManager = require('./connection-manager');\n\nvar Circuit = require('./circuit/transport');\n\nvar Relay = require('./circuit');\n\nvar Dialer = require('./dialer');\n\nvar Keychain = require('./keychain');\n\nvar Metrics = require('./metrics');\n\nvar TransportManager = require('./transport-manager');\n\nvar Upgrader = require('./upgrader');\n\nvar PeerStore = require('./peer-store');\n\nvar PubsubAdapter = require('./pubsub-adapter');\n\nvar PersistentPeerStore = require('./peer-store/persistent');\n\nvar Registrar = require('./registrar');\n\nvar _ping = require('./ping');\n\nvar IdentifyService = require('./identify');\n\nvar NatManager = require('./nat-manager');\n\nvar _require5 = require('./record/utils'),\n    updateSelfPeerRecord = _require5.updateSelfPeerRecord;\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n * @typedef {import('libp2p-interfaces/src/peer-discovery/types').PeerDiscoveryFactory} PeerDiscoveryFactory\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/pubsub')} Pubsub\n * @typedef {import('libp2p-interfaces/src/pubsub').PubsubOptions} PubsubOptions\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('./pnet')} Protector\n */\n\n/**\n * @typedef {Object} HandlerProps\n * @property {Connection} connection\n * @property {MuxedStream} stream\n * @property {string} protocol\n *\n * @typedef {Object} RandomWalkOptions\n * @property {boolean} [enabled = false]\n * @property {number} [queriesPerPeriod = 1]\n * @property {number} [interval = 300e3]\n * @property {number} [timeout = 10e3]\n *\n * @typedef {Object} DhtOptions\n * @property {boolean} [enabled = false]\n * @property {number} [kBucketSize = 20]\n * @property {RandomWalkOptions} [randomWalk]\n * @property {boolean} [clientMode]\n * @property {import('libp2p-interfaces/src/types').DhtSelectors} [selectors]\n * @property {import('libp2p-interfaces/src/types').DhtValidators} [validators]\n *\n * @typedef {Object} KeychainOptions\n * @property {Datastore} [datastore]\n *\n * @typedef {Object} PeerStoreOptions\n * @property {boolean} persistence\n *\n * @typedef {Object} PubsubLocalOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} MetricsOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} RelayOptions\n * @property {boolean} [enabled = true]\n * @property {import('./circuit').RelayAdvertiseOptions} [advertise]\n * @property {import('./circuit').HopOptions} [hop]\n * @property {import('./circuit').AutoRelayOptions} [autoRelay]\n *\n * @typedef {Object} Libp2pConfig\n * @property {DhtOptions} [dht] dht module options\n * @property {import('./nat-manager').NatManagerOptions} [nat]\n * @property {Record<string, Object|boolean>} [peerDiscovery]\n * @property {PubsubLocalOptions & PubsubOptions} [pubsub] pubsub module options\n * @property {RelayOptions} [relay]\n * @property {Record<string, Object>} [transport] transport options indexed by transport key\n *\n * @typedef {Object} Libp2pModules\n * @property {TransportFactory[]} transport\n * @property {MuxerFactory[]} streamMuxer\n * @property {Crypto[]} connEncryption\n * @property {PeerDiscoveryFactory[]} [peerDiscovery]\n * @property {PeerRoutingModule[]} [peerRouting]\n * @property {ContentRoutingModule[]} [contentRouting]\n * @property {Object} [dht]\n * @property {{new(...args: any[]): Pubsub}} [pubsub]\n * @property {Protector} [connProtector]\n *\n * @typedef {Object} Libp2pOptions\n * @property {Libp2pModules} modules libp2p modules to use\n * @property {import('./address-manager').AddressManagerOptions} [addresses]\n * @property {import('./connection-manager').ConnectionManagerOptions} [connectionManager]\n * @property {Datastore} [datastore]\n * @property {import('./dialer').DialerOptions} [dialer]\n * @property {import('./identify/index').HostProperties} [host] libp2p host\n * @property {KeychainOptions & import('./keychain/index').KeychainOptions} [keychain]\n * @property {MetricsOptions & import('./metrics').MetricsOptions} [metrics]\n * @property {import('./peer-routing').PeerRoutingOptions} [peerRouting]\n * @property {PeerStoreOptions & import('./peer-store/persistent').PersistentPeerStoreOptions} [peerStore]\n * @property {import('./transport-manager').TransportManagerOptions} [transportManager]\n * @property {Libp2pConfig} [config]\n *\n * @typedef {Object} constructorOptions\n * @property {PeerId} peerId\n *\n * @typedef {Object} CreateOptions\n * @property {PeerId} [peerId]\n *\n * @extends {EventEmitter}\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\n\n\nvar Libp2p = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Libp2p, _EventEmitter);\n\n  var _super = _createSuper(Libp2p);\n\n  /**\n   * Libp2p node.\n   *\n   * @class\n   * @param {Libp2pOptions & constructorOptions} _options\n   */\n  function Libp2p(_options) {\n    var _this;\n\n    _classCallCheck(this, Libp2p);\n\n    _this = _super.call(this); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    _this._options = validateConfig(_options);\n    /** @type {PeerId} */\n\n    _this.peerId = _this._options.peerId;\n    _this.datastore = _this._options.datastore;\n    _this.peerStore = _this.datastore && _this._options.peerStore.persistence ? new PersistentPeerStore(_objectSpread({\n      peerId: _this.peerId,\n      datastore: _this.datastore\n    }, _this._options.peerStore)) : new PeerStore({\n      peerId: _this.peerId\n    }); // Addresses {listen, announce, noAnnounce}\n\n    _this.addresses = _this._options.addresses;\n    _this.addressManager = new AddressManager(_this.peerId, _this._options.addresses); // when addresses change, update our peer record\n\n    _this.addressManager.on('change:addresses', function () {\n      updateSelfPeerRecord(_assertThisInitialized(_this)).catch(function (err) {\n        log.error('Error updating self peer record', err);\n      });\n    });\n\n    _this._modules = _this._options.modules;\n    _this._config = _this._options.config;\n    _this._transport = []; // Transport instances/references\n\n    _this._discovery = new Map(); // Discovery service instances/references\n    // Create the Connection Manager\n\n    _this.connectionManager = new ConnectionManager(_assertThisInitialized(_this), _objectSpread({\n      autoDial: _this._config.peerDiscovery.autoDial\n    }, _this._options.connectionManager)); // Create Metrics\n\n    if (_this._options.metrics.enabled) {\n      _this.metrics = new Metrics(_objectSpread(_objectSpread({}, _this._options.metrics), {}, {\n        connectionManager: _this.connectionManager\n      }));\n    } // Create keychain\n\n\n    if (_this._options.keychain && _this._options.keychain.datastore) {\n      log('creating keychain');\n      var keychainOpts = Keychain.generateOptions();\n      _this.keychain = new Keychain(_this._options.keychain.datastore, _objectSpread(_objectSpread({}, keychainOpts), _this._options.keychain));\n      log('keychain constructed');\n    } // Setup the Upgrader\n\n\n    _this.upgrader = new Upgrader({\n      localPeer: _this.peerId,\n      metrics: _this.metrics,\n      onConnection: function onConnection(connection) {\n        return _this.connectionManager.onConnect(connection);\n      },\n      onConnectionEnd: function onConnectionEnd(connection) {\n        return _this.connectionManager.onDisconnect(connection);\n      }\n    }); // Setup the transport manager\n\n    _this.transportManager = new TransportManager({\n      libp2p: _assertThisInitialized(_this),\n      upgrader: _this.upgrader,\n      faultTolerance: _this._options.transportManager.faultTolerance\n    }); // Create the Nat Manager\n\n    _this.natManager = new NatManager(_objectSpread({\n      peerId: _this.peerId,\n      addressManager: _this.addressManager,\n      transportManager: _this.transportManager\n    }, _this._options.config.nat)); // Create the Registrar\n\n    _this.registrar = new Registrar({\n      peerStore: _this.peerStore,\n      connectionManager: _this.connectionManager\n    });\n    _this.handle = _this.handle.bind(_assertThisInitialized(_this));\n    _this.registrar.handle = _this.handle; // Attach crypto channels\n\n    if (!_this._modules.connEncryption || !_this._modules.connEncryption.length) {\n      throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED);\n    }\n\n    var cryptos = _this._modules.connEncryption;\n    cryptos.forEach(function (crypto) {\n      _this.upgrader.cryptos.set(crypto.protocol, crypto);\n    });\n    _this.dialer = new Dialer(_objectSpread({\n      transportManager: _this.transportManager,\n      peerStore: _this.peerStore\n    }, _this._options.dialer));\n\n    _this._modules.transport.forEach(function (Transport) {\n      var key = Transport.prototype[Symbol.toStringTag];\n      var transportOptions = _this._config.transport[key];\n\n      _this.transportManager.add(key, Transport, transportOptions);\n    });\n\n    if (_this._config.relay.enabled) {\n      // @ts-ignore Circuit prototype\n      _this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);\n\n      _this.relay = new Relay(_assertThisInitialized(_this));\n    } // Attach stream multiplexers\n\n\n    if (_this._modules.streamMuxer) {\n      var muxers = _this._modules.streamMuxer;\n      muxers.forEach(function (muxer) {\n        _this.upgrader.muxers.set(muxer.multicodec, muxer);\n      }); // Add the identify service since we can multiplex\n\n      _this.identifyService = new IdentifyService({\n        libp2p: _assertThisInitialized(_this)\n      });\n\n      _this.handle(Object.values(IdentifyService.getProtocolStr(_assertThisInitialized(_this))), _this.identifyService.handleMessage);\n    } // Attach private network protector\n\n\n    if (_this._modules.connProtector) {\n      _this.upgrader.protector = _this._modules.connProtector;\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {\n      // eslint-disable-line no-undef\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (_this._modules.dht) {\n      var DHT = _this._modules.dht; // @ts-ignore Object is not constructable\n\n      _this._dht = new DHT(_objectSpread({\n        libp2p: _assertThisInitialized(_this),\n        dialer: _this.dialer,\n        peerId: _this.peerId,\n        peerStore: _this.peerStore,\n        registrar: _this.registrar,\n        datastore: _this.datastore\n      }, _this._config.dht));\n    } // Create pubsub if provided\n\n\n    if (_this._modules.pubsub) {\n      var Pubsub = _this._modules.pubsub; // using pubsub adapter with *DEPRECATED* handlers functionality\n\n      /** @type {Pubsub} */\n\n      _this.pubsub = PubsubAdapter(Pubsub, _assertThisInitialized(_this), _this._config.pubsub);\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    _this.peerRouting = new PeerRouting(_assertThisInitialized(_this));\n    _this.contentRouting = new ContentRouting(_assertThisInitialized(_this)); // Mount default protocols\n\n    _ping.mount(_assertThisInitialized(_this));\n\n    _this._onDiscoveryPeer = _this._onDiscoveryPeer.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   *\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {boolean}\n   */\n\n\n  _createClass(Libp2p, [{\n    key: \"emit\",\n    value: function emit(eventName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      // TODO: do we still need this?\n      // @ts-ignore _events does not exist in libp2p\n      if (eventName === 'error' && !this._events.error) {\n        log.error(args);\n        return false;\n      } else {\n        var _get2;\n\n        return (_get2 = _get(_getPrototypeOf(Libp2p.prototype), \"emit\", this)).call.apply(_get2, [this, eventName].concat(args));\n      }\n    }\n    /**\n     * Starts the libp2p node and all its subsystems\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                log('libp2p is starting');\n                _context.prev = 1;\n                _context.next = 4;\n                return this._onStarting();\n\n              case 4:\n                _context.next = 6;\n                return this._onDidStart();\n\n              case 6:\n                log('libp2p has started');\n                _context.next = 16;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](1);\n                this.emit('error', _context.t0);\n                log.error('An error occurred starting libp2p', _context.t0);\n                _context.next = 15;\n                return this.stop();\n\n              case 15:\n                throw _context.t0;\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 9]]);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * Stop the libp2p node by closing its listeners and open connections\n     *\n     * @async\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _iterator, _step, service;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                log('libp2p is stopping');\n                _context2.prev = 1;\n                this._isStarted = false;\n                this.relay && this.relay.stop();\n                this.peerRouting.stop();\n                _iterator = _createForOfIteratorHelper(this._discovery.values());\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    service = _step.value;\n                    service.removeListener('peer', this._onDiscoveryPeer);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                _context2.next = 9;\n                return Promise.all(Array.from(this._discovery.values(), function (s) {\n                  return s.stop();\n                }));\n\n              case 9:\n                this._discovery = new Map();\n                _context2.next = 12;\n                return this.peerStore.stop();\n\n              case 12:\n                _context2.next = 14;\n                return this.connectionManager.stop();\n\n              case 14:\n                _context2.next = 16;\n                return Promise.all([this.pubsub && this.pubsub.stop(), this._dht && this._dht.stop(), this.metrics && this.metrics.stop()]);\n\n              case 16:\n                _context2.next = 18;\n                return this.natManager.stop();\n\n              case 18:\n                _context2.next = 20;\n                return this.transportManager.close();\n\n              case 20:\n                _ping.unmount(this);\n\n                this.dialer.destroy();\n                _context2.next = 27;\n                break;\n\n              case 24:\n                _context2.prev = 24;\n                _context2.t0 = _context2[\"catch\"](1);\n\n                if (_context2.t0) {\n                  log.error(_context2.t0);\n                  this.emit('error', _context2.t0);\n                }\n\n              case 27:\n                log('libp2p has stopped');\n\n              case 28:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 24]]);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * Load keychain keys from the datastore.\n     * Imports the private key as 'self', if needed.\n     *\n     * @async\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"loadKeychain\",\n    value: function () {\n      var _loadKeychain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.keychain) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                _context3.prev = 2;\n                _context3.next = 5;\n                return this.keychain.findKeyByName('self');\n\n              case 5:\n                _context3.next = 11;\n                break;\n\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](2);\n                _context3.next = 11;\n                return this.keychain.importPeer('self', this.peerId);\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[2, 7]]);\n      }));\n\n      function loadKeychain() {\n        return _loadKeychain.apply(this, arguments);\n      }\n\n      return loadKeychain;\n    }()\n  }, {\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this._isStarted;\n    }\n    /**\n     * Gets a Map of the current connections. The keys are the stringified\n     * `PeerId` of the peer. The value is an array of Connections to that peer.\n     *\n     * @returns {Map<string, Connection[]>}\n     */\n\n  }, {\n    key: \"connections\",\n    get: function get() {\n      return this.connectionManager.connections;\n    }\n    /**\n     * Dials to the provided peer. If successful, the known metadata of the\n     * peer will be added to the nodes `peerStore`\n     *\n     * @param {PeerId|Multiaddr|string} peer - The peer to dial\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"dial\",\n    value: function dial(peer, options) {\n      return this._dial(peer, options);\n    }\n    /**\n     * Dials to the provided peer and tries to handshake with the given protocols in order.\n     * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n     * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n     *\n     * @async\n     * @param {PeerId|Multiaddr|string} peer - The peer to dial\n     * @param {string[]|string} protocols\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     */\n\n  }, {\n    key: \"dialProtocol\",\n    value: function () {\n      var _dialProtocol = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(peer, protocols, options) {\n        var connection;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(!protocols || !protocols.length)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);\n\n              case 2:\n                _context4.next = 4;\n                return this._dial(peer, options);\n\n              case 4:\n                connection = _context4.sent;\n                return _context4.abrupt(\"return\", connection.newStream(protocols));\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function dialProtocol(_x, _x2, _x3) {\n        return _dialProtocol.apply(this, arguments);\n      }\n\n      return dialProtocol;\n    }()\n    /**\n     * @async\n     * @param {PeerId|Multiaddr|string} peer - The peer to dial\n     * @param {object} [options]\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"_dial\",\n    value: function () {\n      var _dial2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(peer, options) {\n        var _getPeer, id, multiaddrs, connection;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _getPeer = getPeer(peer), id = _getPeer.id, multiaddrs = _getPeer.multiaddrs;\n\n                if (!id.equals(this.peerId)) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                throw errCode(new Error('Cannot dial self'), codes.ERR_DIALED_SELF);\n\n              case 3:\n                connection = this.connectionManager.get(id);\n\n                if (connection) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                _context5.next = 7;\n                return this.dialer.connectToPeer(peer, options);\n\n              case 7:\n                connection = _context5.sent;\n                _context5.next = 11;\n                break;\n\n              case 10:\n                if (multiaddrs) {\n                  this.peerStore.addressBook.add(id, multiaddrs);\n                }\n\n              case 11:\n                return _context5.abrupt(\"return\", connection);\n\n              case 12:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _dial(_x4, _x5) {\n        return _dial2.apply(this, arguments);\n      }\n\n      return _dial;\n    }()\n    /**\n     * Get a deduplicated list of peer advertising multiaddrs by concatenating\n     * the listen addresses used by transports with any configured\n     * announce addresses as well as observed addresses reported by peers.\n     *\n     * If Announce addrs are specified, configured listen addresses will be\n     * ignored though observed addresses will still be included.\n     *\n     * @returns {Multiaddr[]}\n     */\n\n  }, {\n    key: \"multiaddrs\",\n    get: function get() {\n      var addrs = this.addressManager.getAnnounceAddrs().map(function (ma) {\n        return ma.toString();\n      });\n\n      if (!addrs.length) {\n        // no configured announce addrs, add configured listen addresses\n        addrs = this.transportManager.getAddrs().map(function (ma) {\n          return ma.toString();\n        });\n      }\n\n      addrs = addrs.concat(this.addressManager.getObservedAddrs().map(function (ma) {\n        return ma.toString();\n      }));\n      var announceFilter = this._options.addresses.announceFilter; // dedupe multiaddrs\n\n      var addrSet = new Set(addrs); // Create advertising list\n\n      return announceFilter(Array.from(addrSet).map(function (str) {\n        return new Multiaddr(str);\n      }));\n    }\n    /**\n     * Disconnects all connections to the given `peer`\n     *\n     * @param {PeerId|Multiaddr|string} peer - the peer to close connections to\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"hangUp\",\n    value: function () {\n      var _hangUp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(peer) {\n        var _getPeer2, id, connections;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _getPeer2 = getPeer(peer), id = _getPeer2.id;\n                connections = this.connectionManager.connections.get(id.toB58String());\n\n                if (connections) {\n                  _context6.next = 4;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 4:\n                _context6.next = 6;\n                return Promise.all(connections.map(function (connection) {\n                  return connection.close();\n                }));\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function hangUp(_x6) {\n        return _hangUp.apply(this, arguments);\n      }\n\n      return hangUp;\n    }()\n    /**\n     * Pings the given peer in order to obtain the operation latency.\n     *\n     * @param {PeerId|Multiaddr|string} peer - The peer to ping\n     * @returns {Promise<number>}\n     */\n\n  }, {\n    key: \"ping\",\n    value: function ping(peer) {\n      var _getPeer3 = getPeer(peer),\n          id = _getPeer3.id,\n          multiaddrs = _getPeer3.multiaddrs; // If received multiaddr, ping it\n\n\n      if (multiaddrs) {\n        return _ping(this, multiaddrs[0]);\n      }\n\n      return _ping(this, id);\n    }\n    /**\n     * Registers the `handler` for each protocol\n     *\n     * @param {string[]|string} protocols\n     * @param {(props: HandlerProps) => void} handler\n     */\n\n  }, {\n    key: \"handle\",\n    value: function handle(protocols, handler) {\n      var _this2 = this;\n\n      protocols = Array.isArray(protocols) ? protocols : [protocols];\n      protocols.forEach(function (protocol) {\n        _this2.upgrader.protocols.set(protocol, handler);\n      }); // Add new protocols to self protocols in the Protobook\n\n      this.peerStore.protoBook.add(this.peerId, protocols);\n    }\n    /**\n     * Removes the handler for each protocol. The protocol\n     * will no longer be supported on streams.\n     *\n     * @param {string[]|string} protocols\n     */\n\n  }, {\n    key: \"unhandle\",\n    value: function unhandle(protocols) {\n      var _this3 = this;\n\n      protocols = Array.isArray(protocols) ? protocols : [protocols];\n      protocols.forEach(function (protocol) {\n        _this3.upgrader.protocols.delete(protocol);\n      }); // Remove protocols from self protocols in the Protobook\n\n      this.peerStore.protoBook.remove(this.peerId, protocols);\n    }\n  }, {\n    key: \"_onStarting\",\n    value: function () {\n      var _onStarting2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var addrs;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                // Listen on the provided transports for the provided addresses\n                addrs = this.addressManager.getListenAddrs();\n                _context7.next = 3;\n                return this.transportManager.listen(addrs);\n\n              case 3:\n                // Manage your NATs\n                this.natManager.start(); // Start PeerStore\n\n                _context7.next = 6;\n                return this.peerStore.start();\n\n              case 6:\n                if (this._config.pubsub.enabled) {\n                  this.pubsub && this.pubsub.start();\n                } // DHT subsystem\n\n\n                if (this._config.dht.enabled) {\n                  this._dht && this._dht.start(); // TODO: this should be modified once random-walk is used as\n                  // the other discovery modules\n\n                  this._dht.on('peer', this._onDiscoveryPeer);\n                } // Start metrics if present\n\n\n                this.metrics && this.metrics.start();\n\n              case 9:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function _onStarting() {\n        return _onStarting2.apply(this, arguments);\n      }\n\n      return _onStarting;\n    }()\n    /**\n     * Called when libp2p has started and before it returns\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_onDidStart\",\n    value: function () {\n      var _onDidStart2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _this4 = this;\n\n        var _iterator2, _step2, peer;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this._isStarted = true;\n                this.peerStore.on('peer', function (peerId) {\n                  _this4.emit('peer:discovery', peerId);\n\n                  _this4._maybeConnect(peerId);\n                }); // Once we start, emit any peers we may have already discovered\n                // TODO: this should be removed, as we already discovered these peers in the past\n\n                _iterator2 = _createForOfIteratorHelper(this.peerStore.peers.values());\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    peer = _step2.value;\n                    this.emit('peer:discovery', peer.id);\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                this.connectionManager.start(); // Peer discovery\n\n                _context8.next = 7;\n                return this._setupPeerDiscovery();\n\n              case 7:\n                // Relay\n                this.relay && this.relay.start();\n                this.peerRouting.start();\n\n              case 9:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function _onDidStart() {\n        return _onDidStart2.apply(this, arguments);\n      }\n\n      return _onDidStart;\n    }()\n    /**\n     * Called whenever peer discovery services emit `peer` events.\n     * Known peers may be emitted.\n     *\n     * @private\n     * @param {{ id: PeerId, multiaddrs: Multiaddr[], protocols: string[] }} peer\n     */\n\n  }, {\n    key: \"_onDiscoveryPeer\",\n    value: function _onDiscoveryPeer(peer) {\n      if (peer.id.toB58String() === this.peerId.toB58String()) {\n        log.error(new Error(codes.ERR_DISCOVERED_SELF));\n        return;\n      }\n\n      peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs);\n      peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols);\n    }\n    /**\n     * Will dial to the given `peerId` if the current number of\n     * connected peers is less than the configured `ConnectionManager`\n     * minConnections.\n     *\n     * @private\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"_maybeConnect\",\n    value: function () {\n      var _maybeConnect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(peerId) {\n        var minConnections;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!(this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId))) {\n                  _context9.next = 12;\n                  break;\n                }\n\n                minConnections = this._options.connectionManager.minConnections || 0;\n\n                if (!(minConnections > this.connectionManager.size)) {\n                  _context9.next = 12;\n                  break;\n                }\n\n                log('connecting to discovered peer %s', peerId.toB58String());\n                _context9.prev = 4;\n                _context9.next = 7;\n                return this.dialer.connectToPeer(peerId);\n\n              case 7:\n                _context9.next = 12;\n                break;\n\n              case 9:\n                _context9.prev = 9;\n                _context9.t0 = _context9[\"catch\"](4);\n                log.error(\"could not connect to discovered peer \".concat(peerId.toB58String(), \" with \").concat(_context9.t0));\n\n              case 12:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[4, 9]]);\n      }));\n\n      function _maybeConnect(_x7) {\n        return _maybeConnect2.apply(this, arguments);\n      }\n\n      return _maybeConnect;\n    }()\n    /**\n     * Initializes and starts peer discovery services\n     *\n     * @async\n     * @private\n     */\n\n  }, {\n    key: \"_setupPeerDiscovery\",\n    value: function () {\n      var _setupPeerDiscovery2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _this5 = this;\n\n        var setupService, _iterator3, _step3, DiscoveryService, _iterator4, _step4, Transport;\n\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                /**\n                 * @param {PeerDiscoveryFactory} DiscoveryService\n                 */\n                setupService = function setupService(DiscoveryService) {\n                  var config = {\n                    enabled: true // on by default\n\n                  };\n\n                  if (DiscoveryService.tag && _this5._config.peerDiscovery && _this5._config.peerDiscovery[DiscoveryService.tag]) {\n                    // @ts-ignore PeerDiscovery not understood as an Object for spread\n                    config = _objectSpread(_objectSpread({}, config), _this5._config.peerDiscovery[DiscoveryService.tag]);\n                  }\n\n                  if (config.enabled && !_this5._discovery.has(DiscoveryService.tag)) {\n                    // not already added\n                    var discoveryService;\n\n                    if (typeof DiscoveryService === 'function') {\n                      // @ts-ignore DiscoveryService has no constructor type inferred\n                      discoveryService = new DiscoveryService(Object.assign({}, config, {\n                        peerId: _this5.peerId,\n                        libp2p: _this5\n                      }));\n                    } else {\n                      discoveryService = DiscoveryService;\n                    }\n\n                    discoveryService.on('peer', _this5._onDiscoveryPeer);\n\n                    _this5._discovery.set(DiscoveryService.tag, discoveryService);\n                  }\n                }; // Discovery modules\n\n\n                _iterator3 = _createForOfIteratorHelper(this._modules.peerDiscovery || []);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    DiscoveryService = _step3.value;\n                    setupService(DiscoveryService);\n                  } // Transport modules with discovery\n\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                _iterator4 = _createForOfIteratorHelper(this.transportManager.getTransports());\n\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    Transport = _step4.value;\n\n                    // @ts-ignore Transport interface does not include discovery\n                    if (Transport.discovery) {\n                      // @ts-ignore Transport interface does not include discovery\n                      setupService(Transport.discovery);\n                    }\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n\n                _context10.next = 7;\n                return Promise.all(Array.from(this._discovery.values(), function (d) {\n                  return d.start();\n                }));\n\n              case 7:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function _setupPeerDiscovery() {\n        return _setupPeerDiscovery2.apply(this, arguments);\n      }\n\n      return _setupPeerDiscovery;\n    }()\n  }], [{\n    key: \"create\",\n    value:\n    /**\n     * Like `new Libp2p(options)` except it will create a `PeerId`\n     * instance if one is not provided in options.\n     *\n     * @param {Libp2pOptions & CreateOptions} options - Libp2p configuration options\n     * @returns {Promise<Libp2p>}\n     */\n    function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(options) {\n        var peerId;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!options.peerId) {\n                  _context11.next = 2;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", new Libp2p(options));\n\n              case 2:\n                _context11.next = 4;\n                return PeerId.create();\n\n              case 4:\n                peerId = _context11.sent;\n                options.peerId = peerId; // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n\n                return _context11.abrupt(\"return\", new Libp2p(options));\n\n              case 7:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11);\n      }));\n\n      function create(_x8) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }]);\n\n  return Libp2p;\n}(EventEmitter);\n\nmodule.exports = Libp2p;","map":{"version":3,"names":["debug","require","log","Object","assign","error","EventEmitter","errCode","PeerId","Multiaddr","PeerRouting","ContentRouting","getPeer","validateConfig","validate","codes","messages","AddressManager","ConnectionManager","Circuit","Relay","Dialer","Keychain","Metrics","TransportManager","Upgrader","PeerStore","PubsubAdapter","PersistentPeerStore","Registrar","ping","IdentifyService","NatManager","updateSelfPeerRecord","Libp2p","_options","peerId","datastore","peerStore","persistence","addresses","addressManager","on","catch","err","_modules","modules","_config","config","_transport","_discovery","Map","connectionManager","autoDial","peerDiscovery","metrics","enabled","keychain","keychainOpts","generateOptions","upgrader","localPeer","onConnection","connection","onConnect","onConnectionEnd","onDisconnect","transportManager","libp2p","faultTolerance","natManager","nat","registrar","handle","bind","connEncryption","length","Error","CONN_ENCRYPTION_REQUIRED","cryptos","forEach","crypto","set","protocol","dialer","transport","Transport","key","prototype","Symbol","toStringTag","transportOptions","add","relay","streamMuxer","muxers","muxer","multicodec","identifyService","values","getProtocolStr","handleMessage","connProtector","protector","globalThis","process","undefined","env","LIBP2P_FORCE_PNET","dht","DHT","_dht","pubsub","Pubsub","peerRouting","contentRouting","mount","_onDiscoveryPeer","eventName","args","_events","_onStarting","_onDidStart","emit","stop","_isStarted","service","removeListener","Promise","all","Array","from","s","close","unmount","destroy","findKeyByName","importPeer","connections","peer","options","_dial","protocols","ERR_INVALID_PROTOCOLS_FOR_STREAM","newStream","id","multiaddrs","equals","ERR_DIALED_SELF","get","connectToPeer","addressBook","addrs","getAnnounceAddrs","map","ma","toString","getAddrs","concat","getObservedAddrs","announceFilter","addrSet","Set","str","toB58String","handler","isArray","protoBook","delete","remove","getListenAddrs","listen","start","_maybeConnect","peers","_setupPeerDiscovery","ERR_DISCOVERED_SELF","minConnections","size","setupService","DiscoveryService","tag","has","discoveryService","getTransports","discovery","d","create","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p'), {\n  error: debug('libp2p:err')\n})\nconst { EventEmitter } = require('events')\n\nconst errCode = require('err-code')\nconst PeerId = require('peer-id')\nconst { Multiaddr } = require('multiaddr')\n\nconst PeerRouting = require('./peer-routing')\nconst ContentRouting = require('./content-routing')\nconst getPeer = require('./get-peer')\nconst { validate: validateConfig } = require('./config')\nconst { codes, messages } = require('./errors')\n\nconst AddressManager = require('./address-manager')\nconst ConnectionManager = require('./connection-manager')\nconst Circuit = require('./circuit/transport')\nconst Relay = require('./circuit')\nconst Dialer = require('./dialer')\nconst Keychain = require('./keychain')\nconst Metrics = require('./metrics')\nconst TransportManager = require('./transport-manager')\nconst Upgrader = require('./upgrader')\nconst PeerStore = require('./peer-store')\nconst PubsubAdapter = require('./pubsub-adapter')\nconst PersistentPeerStore = require('./peer-store/persistent')\nconst Registrar = require('./registrar')\nconst ping = require('./ping')\nconst IdentifyService = require('./identify')\nconst NatManager = require('./nat-manager')\nconst { updateSelfPeerRecord } = require('./record/utils')\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n * @typedef {import('libp2p-interfaces/src/peer-discovery/types').PeerDiscoveryFactory} PeerDiscoveryFactory\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/pubsub')} Pubsub\n * @typedef {import('libp2p-interfaces/src/pubsub').PubsubOptions} PubsubOptions\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('./pnet')} Protector\n */\n\n/**\n * @typedef {Object} HandlerProps\n * @property {Connection} connection\n * @property {MuxedStream} stream\n * @property {string} protocol\n *\n * @typedef {Object} RandomWalkOptions\n * @property {boolean} [enabled = false]\n * @property {number} [queriesPerPeriod = 1]\n * @property {number} [interval = 300e3]\n * @property {number} [timeout = 10e3]\n *\n * @typedef {Object} DhtOptions\n * @property {boolean} [enabled = false]\n * @property {number} [kBucketSize = 20]\n * @property {RandomWalkOptions} [randomWalk]\n * @property {boolean} [clientMode]\n * @property {import('libp2p-interfaces/src/types').DhtSelectors} [selectors]\n * @property {import('libp2p-interfaces/src/types').DhtValidators} [validators]\n *\n * @typedef {Object} KeychainOptions\n * @property {Datastore} [datastore]\n *\n * @typedef {Object} PeerStoreOptions\n * @property {boolean} persistence\n *\n * @typedef {Object} PubsubLocalOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} MetricsOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} RelayOptions\n * @property {boolean} [enabled = true]\n * @property {import('./circuit').RelayAdvertiseOptions} [advertise]\n * @property {import('./circuit').HopOptions} [hop]\n * @property {import('./circuit').AutoRelayOptions} [autoRelay]\n *\n * @typedef {Object} Libp2pConfig\n * @property {DhtOptions} [dht] dht module options\n * @property {import('./nat-manager').NatManagerOptions} [nat]\n * @property {Record<string, Object|boolean>} [peerDiscovery]\n * @property {PubsubLocalOptions & PubsubOptions} [pubsub] pubsub module options\n * @property {RelayOptions} [relay]\n * @property {Record<string, Object>} [transport] transport options indexed by transport key\n *\n * @typedef {Object} Libp2pModules\n * @property {TransportFactory[]} transport\n * @property {MuxerFactory[]} streamMuxer\n * @property {Crypto[]} connEncryption\n * @property {PeerDiscoveryFactory[]} [peerDiscovery]\n * @property {PeerRoutingModule[]} [peerRouting]\n * @property {ContentRoutingModule[]} [contentRouting]\n * @property {Object} [dht]\n * @property {{new(...args: any[]): Pubsub}} [pubsub]\n * @property {Protector} [connProtector]\n *\n * @typedef {Object} Libp2pOptions\n * @property {Libp2pModules} modules libp2p modules to use\n * @property {import('./address-manager').AddressManagerOptions} [addresses]\n * @property {import('./connection-manager').ConnectionManagerOptions} [connectionManager]\n * @property {Datastore} [datastore]\n * @property {import('./dialer').DialerOptions} [dialer]\n * @property {import('./identify/index').HostProperties} [host] libp2p host\n * @property {KeychainOptions & import('./keychain/index').KeychainOptions} [keychain]\n * @property {MetricsOptions & import('./metrics').MetricsOptions} [metrics]\n * @property {import('./peer-routing').PeerRoutingOptions} [peerRouting]\n * @property {PeerStoreOptions & import('./peer-store/persistent').PersistentPeerStoreOptions} [peerStore]\n * @property {import('./transport-manager').TransportManagerOptions} [transportManager]\n * @property {Libp2pConfig} [config]\n *\n * @typedef {Object} constructorOptions\n * @property {PeerId} peerId\n *\n * @typedef {Object} CreateOptions\n * @property {PeerId} [peerId]\n *\n * @extends {EventEmitter}\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\nclass Libp2p extends EventEmitter {\n  /**\n   * Like `new Libp2p(options)` except it will create a `PeerId`\n   * instance if one is not provided in options.\n   *\n   * @param {Libp2pOptions & CreateOptions} options - Libp2p configuration options\n   * @returns {Promise<Libp2p>}\n   */\n  static async create (options) {\n    if (options.peerId) {\n      // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n      return new Libp2p(options)\n    }\n\n    const peerId = await PeerId.create()\n\n    options.peerId = peerId\n    // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n    return new Libp2p(options)\n  }\n\n  /**\n   * Libp2p node.\n   *\n   * @class\n   * @param {Libp2pOptions & constructorOptions} _options\n   */\n  constructor (_options) {\n    super()\n    // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n    this._options = validateConfig(_options)\n\n    /** @type {PeerId} */\n    this.peerId = this._options.peerId\n    this.datastore = this._options.datastore\n\n    this.peerStore = (this.datastore && this._options.peerStore.persistence)\n      ? new PersistentPeerStore({\n        peerId: this.peerId,\n        datastore: this.datastore,\n        ...this._options.peerStore\n      })\n      : new PeerStore({ peerId: this.peerId })\n\n    // Addresses {listen, announce, noAnnounce}\n    this.addresses = this._options.addresses\n    this.addressManager = new AddressManager(this.peerId, this._options.addresses)\n\n    // when addresses change, update our peer record\n    this.addressManager.on('change:addresses', () => {\n      updateSelfPeerRecord(this).catch(err => {\n        log.error('Error updating self peer record', err)\n      })\n    })\n\n    this._modules = this._options.modules\n    this._config = this._options.config\n    this._transport = [] // Transport instances/references\n    this._discovery = new Map() // Discovery service instances/references\n\n    // Create the Connection Manager\n    this.connectionManager = new ConnectionManager(this, {\n      autoDial: this._config.peerDiscovery.autoDial,\n      ...this._options.connectionManager\n    })\n\n    // Create Metrics\n    if (this._options.metrics.enabled) {\n      this.metrics = new Metrics({\n        ...this._options.metrics,\n        connectionManager: this.connectionManager\n      })\n    }\n\n    // Create keychain\n    if (this._options.keychain && this._options.keychain.datastore) {\n      log('creating keychain')\n\n      const keychainOpts = Keychain.generateOptions()\n\n      this.keychain = new Keychain(this._options.keychain.datastore, {\n        ...keychainOpts,\n        ...this._options.keychain\n      })\n\n      log('keychain constructed')\n    }\n\n    // Setup the Upgrader\n    this.upgrader = new Upgrader({\n      localPeer: this.peerId,\n      metrics: this.metrics,\n      onConnection: (connection) => this.connectionManager.onConnect(connection),\n      onConnectionEnd: (connection) => this.connectionManager.onDisconnect(connection)\n    })\n\n    // Setup the transport manager\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader,\n      faultTolerance: this._options.transportManager.faultTolerance\n    })\n\n    // Create the Nat Manager\n    this.natManager = new NatManager({\n      peerId: this.peerId,\n      addressManager: this.addressManager,\n      transportManager: this.transportManager,\n      // @ts-ignore Nat typedef is not understood as Object\n      ...this._options.config.nat\n    })\n\n    // Create the Registrar\n    this.registrar = new Registrar({\n      peerStore: this.peerStore,\n      connectionManager: this.connectionManager\n    })\n\n    this.handle = this.handle.bind(this)\n    this.registrar.handle = this.handle\n\n    // Attach crypto channels\n    if (!this._modules.connEncryption || !this._modules.connEncryption.length) {\n      throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED)\n    }\n    const cryptos = this._modules.connEncryption\n    cryptos.forEach((crypto) => {\n      this.upgrader.cryptos.set(crypto.protocol, crypto)\n    })\n\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      peerStore: this.peerStore,\n      ...this._options.dialer\n    })\n\n    this._modules.transport.forEach((Transport) => {\n      const key = Transport.prototype[Symbol.toStringTag]\n      const transportOptions = this._config.transport[key]\n      this.transportManager.add(key, Transport, transportOptions)\n    })\n\n    if (this._config.relay.enabled) {\n      // @ts-ignore Circuit prototype\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit)\n      this.relay = new Relay(this)\n    }\n\n    // Attach stream multiplexers\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer\n      muxers.forEach((muxer) => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer)\n      })\n\n      // Add the identify service since we can multiplex\n      this.identifyService = new IdentifyService({ libp2p: this })\n      this.handle(Object.values(IdentifyService.getProtocolStr(this)), this.identifyService.handleMessage)\n    }\n\n    // Attach private network protector\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) { // eslint-disable-line no-undef\n      throw new Error('Private network is enforced, but no protector was provided')\n    }\n\n    // dht provided components (peerRouting, contentRouting, dht)\n    if (this._modules.dht) {\n      const DHT = this._modules.dht\n      // @ts-ignore Object is not constructable\n      this._dht = new DHT({\n        libp2p: this,\n        dialer: this.dialer,\n        peerId: this.peerId,\n        peerStore: this.peerStore,\n        registrar: this.registrar,\n        datastore: this.datastore,\n        ...this._config.dht\n      })\n    }\n\n    // Create pubsub if provided\n    if (this._modules.pubsub) {\n      const Pubsub = this._modules.pubsub\n      // using pubsub adapter with *DEPRECATED* handlers functionality\n      /** @type {Pubsub} */\n      this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub)\n    }\n\n    // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n    this.peerRouting = new PeerRouting(this)\n    this.contentRouting = new ContentRouting(this)\n\n    // Mount default protocols\n    ping.mount(this)\n\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this)\n  }\n\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   *\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {boolean}\n   */\n  emit (eventName, ...args) {\n    // TODO: do we still need this?\n    // @ts-ignore _events does not exist in libp2p\n    if (eventName === 'error' && !this._events.error) {\n      log.error(args)\n      return false\n    } else {\n      return super.emit(eventName, ...args)\n    }\n  }\n\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n  async start () {\n    log('libp2p is starting')\n\n    try {\n      await this._onStarting()\n      await this._onDidStart()\n      log('libp2p has started')\n    } catch (err) {\n      this.emit('error', err)\n      log.error('An error occurred starting libp2p', err)\n      await this.stop()\n      throw err\n    }\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n  async stop () {\n    log('libp2p is stopping')\n\n    try {\n      this._isStarted = false\n\n      this.relay && this.relay.stop()\n      this.peerRouting.stop()\n\n      for (const service of this._discovery.values()) {\n        service.removeListener('peer', this._onDiscoveryPeer)\n      }\n\n      await Promise.all(Array.from(this._discovery.values(), s => s.stop()))\n\n      this._discovery = new Map()\n\n      await this.peerStore.stop()\n      await this.connectionManager.stop()\n\n      await Promise.all([\n        this.pubsub && this.pubsub.stop(),\n        this._dht && this._dht.stop(),\n        this.metrics && this.metrics.stop()\n      ])\n\n      await this.natManager.stop()\n      await this.transportManager.close()\n\n      ping.unmount(this)\n      this.dialer.destroy()\n    } catch (err) {\n      if (err) {\n        log.error(err)\n        this.emit('error', err)\n      }\n    }\n    log('libp2p has stopped')\n  }\n\n  /**\n   * Load keychain keys from the datastore.\n   * Imports the private key as 'self', if needed.\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n  async loadKeychain () {\n    if (!this.keychain) {\n      return\n    }\n\n    try {\n      await this.keychain.findKeyByName('self')\n    } catch (err) {\n      await this.keychain.importPeer('self', this.peerId)\n    }\n  }\n\n  isStarted () {\n    return this._isStarted\n  }\n\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   *\n   * @returns {Map<string, Connection[]>}\n   */\n  get connections () {\n    return this.connectionManager.connections\n  }\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  dial (peer, options) {\n    return this._dial(peer, options)\n  }\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async dialProtocol (peer, protocols, options) {\n    if (!protocols || !protocols.length) {\n      throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM)\n    }\n\n    const connection = await this._dial(peer, options)\n    return connection.newStream(protocols)\n  }\n\n  /**\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @returns {Promise<Connection>}\n   */\n  async _dial (peer, options) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    if (id.equals(this.peerId)) {\n      throw errCode(new Error('Cannot dial self'), codes.ERR_DIALED_SELF)\n    }\n\n    let connection = this.connectionManager.get(id)\n\n    if (!connection) {\n      connection = await this.dialer.connectToPeer(peer, options)\n    } else if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    return connection\n  }\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @returns {Multiaddr[]}\n   */\n  get multiaddrs () {\n    let addrs = this.addressManager.getAnnounceAddrs().map(ma => ma.toString())\n\n    if (!addrs.length) {\n      // no configured announce addrs, add configured listen addresses\n      addrs = this.transportManager.getAddrs().map(ma => ma.toString())\n    }\n\n    addrs = addrs.concat(this.addressManager.getObservedAddrs().map(ma => ma.toString()))\n\n    const announceFilter = this._options.addresses.announceFilter\n\n    // dedupe multiaddrs\n    const addrSet = new Set(addrs)\n\n    // Create advertising list\n    return announceFilter(Array.from(addrSet).map(str => new Multiaddr(str)))\n  }\n\n  /**\n   * Disconnects all connections to the given `peer`\n   *\n   * @param {PeerId|Multiaddr|string} peer - the peer to close connections to\n   * @returns {Promise<void>}\n   */\n  async hangUp (peer) {\n    const { id } = getPeer(peer)\n\n    const connections = this.connectionManager.connections.get(id.toB58String())\n\n    if (!connections) {\n      return\n    }\n\n    await Promise.all(\n      connections.map(connection => {\n        return connection.close()\n      })\n    )\n  }\n\n  /**\n   * Pings the given peer in order to obtain the operation latency.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to ping\n   * @returns {Promise<number>}\n   */\n  ping (peer) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    // If received multiaddr, ping it\n    if (multiaddrs) {\n      return ping(this, multiaddrs[0])\n    }\n\n    return ping(this, id)\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   *\n   * @param {string[]|string} protocols\n   * @param {(props: HandlerProps) => void} handler\n   */\n  handle (protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler)\n    })\n\n    // Add new protocols to self protocols in the Protobook\n    this.peerStore.protoBook.add(this.peerId, protocols)\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @param {string[]|string} protocols\n   */\n  unhandle (protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol)\n    })\n\n    // Remove protocols from self protocols in the Protobook\n    this.peerStore.protoBook.remove(this.peerId, protocols)\n  }\n\n  async _onStarting () {\n    // Listen on the provided transports for the provided addresses\n    const addrs = this.addressManager.getListenAddrs()\n    await this.transportManager.listen(addrs)\n\n    // Manage your NATs\n    this.natManager.start()\n\n    // Start PeerStore\n    await this.peerStore.start()\n\n    if (this._config.pubsub.enabled) {\n      this.pubsub && this.pubsub.start()\n    }\n\n    // DHT subsystem\n    if (this._config.dht.enabled) {\n      this._dht && this._dht.start()\n\n      // TODO: this should be modified once random-walk is used as\n      // the other discovery modules\n      this._dht.on('peer', this._onDiscoveryPeer)\n    }\n\n    // Start metrics if present\n    this.metrics && this.metrics.start()\n  }\n\n  /**\n   * Called when libp2p has started and before it returns\n   *\n   * @private\n   */\n  async _onDidStart () {\n    this._isStarted = true\n\n    this.peerStore.on('peer', peerId => {\n      this.emit('peer:discovery', peerId)\n      this._maybeConnect(peerId)\n    })\n\n    // Once we start, emit any peers we may have already discovered\n    // TODO: this should be removed, as we already discovered these peers in the past\n    for (const peer of this.peerStore.peers.values()) {\n      this.emit('peer:discovery', peer.id)\n    }\n\n    this.connectionManager.start()\n\n    // Peer discovery\n    await this._setupPeerDiscovery()\n\n    // Relay\n    this.relay && this.relay.start()\n\n    this.peerRouting.start()\n  }\n\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   *\n   * @private\n   * @param {{ id: PeerId, multiaddrs: Multiaddr[], protocols: string[] }} peer\n   */\n  _onDiscoveryPeer (peer) {\n    if (peer.id.toB58String() === this.peerId.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF))\n      return\n    }\n\n    peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs)\n    peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols)\n  }\n\n  /**\n   * Will dial to the given `peerId` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minConnections.\n   *\n   * @private\n   * @param {PeerId} peerId\n   */\n  async _maybeConnect (peerId) {\n    // If auto dialing is on and we have no connection to the peer, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {\n      const minConnections = this._options.connectionManager.minConnections || 0\n      if (minConnections > this.connectionManager.size) {\n        log('connecting to discovered peer %s', peerId.toB58String())\n        try {\n          await this.dialer.connectToPeer(peerId)\n        } catch (err) {\n          log.error(`could not connect to discovered peer ${peerId.toB58String()} with ${err}`)\n        }\n      }\n    }\n  }\n\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n  async _setupPeerDiscovery () {\n    /**\n     * @param {PeerDiscoveryFactory} DiscoveryService\n     */\n    const setupService = (DiscoveryService) => {\n      let config = {\n        enabled: true // on by default\n      }\n\n      if (DiscoveryService.tag &&\n        this._config.peerDiscovery &&\n        this._config.peerDiscovery[DiscoveryService.tag]) {\n        // @ts-ignore PeerDiscovery not understood as an Object for spread\n        config = { ...config, ...this._config.peerDiscovery[DiscoveryService.tag] }\n      }\n\n      if (config.enabled &&\n        !this._discovery.has(DiscoveryService.tag)) { // not already added\n        let discoveryService\n\n        if (typeof DiscoveryService === 'function') {\n          // @ts-ignore DiscoveryService has no constructor type inferred\n          discoveryService = new DiscoveryService(Object.assign({}, config, {\n            peerId: this.peerId,\n            libp2p: this\n          }))\n        } else {\n          discoveryService = DiscoveryService\n        }\n\n        discoveryService.on('peer', this._onDiscoveryPeer)\n        this._discovery.set(DiscoveryService.tag, discoveryService)\n      }\n    }\n\n    // Discovery modules\n    for (const DiscoveryService of this._modules.peerDiscovery || []) {\n      setupService(DiscoveryService)\n    }\n\n    // Transport modules with discovery\n    for (const Transport of this.transportManager.getTransports()) {\n      // @ts-ignore Transport interface does not include discovery\n      if (Transport.discovery) {\n        // @ts-ignore Transport interface does not include discovery\n        setupService(Transport.discovery)\n      }\n    }\n\n    await Promise.all(Array.from(this._discovery.values(), d => d.start()))\n  }\n}\n\nmodule.exports = Libp2p\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAMC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcJ,KAAK,CAAC,QAAD,CAAnB,EAA+B;EACzCK,KAAK,EAAEL,KAAK,CAAC,YAAD;AAD6B,CAA/B,CAAZ;;AAGA,eAAyBC,OAAO,CAAC,QAAD,CAAhC;AAAA,IAAQK,YAAR,YAAQA,YAAR;;AAEA,IAAMC,OAAO,GAAGN,OAAO,CAAC,UAAD,CAAvB;;AACA,IAAMO,MAAM,GAAGP,OAAO,CAAC,SAAD,CAAtB;;AACA,gBAAsBA,OAAO,CAAC,WAAD,CAA7B;AAAA,IAAQQ,SAAR,aAAQA,SAAR;;AAEA,IAAMC,WAAW,GAAGT,OAAO,CAAC,gBAAD,CAA3B;;AACA,IAAMU,cAAc,GAAGV,OAAO,CAAC,mBAAD,CAA9B;;AACA,IAAMW,OAAO,GAAGX,OAAO,CAAC,YAAD,CAAvB;;AACA,gBAAqCA,OAAO,CAAC,UAAD,CAA5C;AAAA,IAAkBY,cAAlB,aAAQC,QAAR;;AACA,gBAA4Bb,OAAO,CAAC,UAAD,CAAnC;AAAA,IAAQc,KAAR,aAAQA,KAAR;AAAA,IAAeC,QAAf,aAAeA,QAAf;;AAEA,IAAMC,cAAc,GAAGhB,OAAO,CAAC,mBAAD,CAA9B;;AACA,IAAMiB,iBAAiB,GAAGjB,OAAO,CAAC,sBAAD,CAAjC;;AACA,IAAMkB,OAAO,GAAGlB,OAAO,CAAC,qBAAD,CAAvB;;AACA,IAAMmB,KAAK,GAAGnB,OAAO,CAAC,WAAD,CAArB;;AACA,IAAMoB,MAAM,GAAGpB,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAMqB,QAAQ,GAAGrB,OAAO,CAAC,YAAD,CAAxB;;AACA,IAAMsB,OAAO,GAAGtB,OAAO,CAAC,WAAD,CAAvB;;AACA,IAAMuB,gBAAgB,GAAGvB,OAAO,CAAC,qBAAD,CAAhC;;AACA,IAAMwB,QAAQ,GAAGxB,OAAO,CAAC,YAAD,CAAxB;;AACA,IAAMyB,SAAS,GAAGzB,OAAO,CAAC,cAAD,CAAzB;;AACA,IAAM0B,aAAa,GAAG1B,OAAO,CAAC,kBAAD,CAA7B;;AACA,IAAM2B,mBAAmB,GAAG3B,OAAO,CAAC,yBAAD,CAAnC;;AACA,IAAM4B,SAAS,GAAG5B,OAAO,CAAC,aAAD,CAAzB;;AACA,IAAM6B,KAAI,GAAG7B,OAAO,CAAC,QAAD,CAApB;;AACA,IAAM8B,eAAe,GAAG9B,OAAO,CAAC,YAAD,CAA/B;;AACA,IAAM+B,UAAU,GAAG/B,OAAO,CAAC,eAAD,CAA1B;;AACA,gBAAiCA,OAAO,CAAC,gBAAD,CAAxC;AAAA,IAAQgC,oBAAR,aAAQA,oBAAR;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACMC,M;;;;;EAqBJ;AACF;AACA;AACA;AACA;AACA;EACE,gBAAaC,QAAb,EAAuB;IAAA;;IAAA;;IACrB,0BADqB,CAErB;IACA;;IACA,MAAKA,QAAL,GAAgBtB,cAAc,CAACsB,QAAD,CAA9B;IAEA;;IACA,MAAKC,MAAL,GAAc,MAAKD,QAAL,CAAcC,MAA5B;IACA,MAAKC,SAAL,GAAiB,MAAKF,QAAL,CAAcE,SAA/B;IAEA,MAAKC,SAAL,GAAkB,MAAKD,SAAL,IAAkB,MAAKF,QAAL,CAAcG,SAAd,CAAwBC,WAA3C,GACb,IAAIX,mBAAJ;MACAQ,MAAM,EAAE,MAAKA,MADb;MAEAC,SAAS,EAAE,MAAKA;IAFhB,GAGG,MAAKF,QAAL,CAAcG,SAHjB,EADa,GAMb,IAAIZ,SAAJ,CAAc;MAAEU,MAAM,EAAE,MAAKA;IAAf,CAAd,CANJ,CAVqB,CAkBrB;;IACA,MAAKI,SAAL,GAAiB,MAAKL,QAAL,CAAcK,SAA/B;IACA,MAAKC,cAAL,GAAsB,IAAIxB,cAAJ,CAAmB,MAAKmB,MAAxB,EAAgC,MAAKD,QAAL,CAAcK,SAA9C,CAAtB,CApBqB,CAsBrB;;IACA,MAAKC,cAAL,CAAoBC,EAApB,CAAuB,kBAAvB,EAA2C,YAAM;MAC/CT,oBAAoB,+BAApB,CAA2BU,KAA3B,CAAiC,UAAAC,GAAG,EAAI;QACtC1C,GAAG,CAACG,KAAJ,CAAU,iCAAV,EAA6CuC,GAA7C;MACD,CAFD;IAGD,CAJD;;IAMA,MAAKC,QAAL,GAAgB,MAAKV,QAAL,CAAcW,OAA9B;IACA,MAAKC,OAAL,GAAe,MAAKZ,QAAL,CAAca,MAA7B;IACA,MAAKC,UAAL,GAAkB,EAAlB,CA/BqB,CA+BA;;IACrB,MAAKC,UAAL,GAAkB,IAAIC,GAAJ,EAAlB,CAhCqB,CAgCO;IAE5B;;IACA,MAAKC,iBAAL,GAAyB,IAAIlC,iBAAJ;MACvBmC,QAAQ,EAAE,MAAKN,OAAL,CAAaO,aAAb,CAA2BD;IADd,GAEpB,MAAKlB,QAAL,CAAciB,iBAFM,EAAzB,CAnCqB,CAwCrB;;IACA,IAAI,MAAKjB,QAAL,CAAcoB,OAAd,CAAsBC,OAA1B,EAAmC;MACjC,MAAKD,OAAL,GAAe,IAAIhC,OAAJ,iCACV,MAAKY,QAAL,CAAcoB,OADJ;QAEbH,iBAAiB,EAAE,MAAKA;MAFX,GAAf;IAID,CA9CoB,CAgDrB;;;IACA,IAAI,MAAKjB,QAAL,CAAcsB,QAAd,IAA0B,MAAKtB,QAAL,CAAcsB,QAAd,CAAuBpB,SAArD,EAAgE;MAC9DnC,GAAG,CAAC,mBAAD,CAAH;MAEA,IAAMwD,YAAY,GAAGpC,QAAQ,CAACqC,eAAT,EAArB;MAEA,MAAKF,QAAL,GAAgB,IAAInC,QAAJ,CAAa,MAAKa,QAAL,CAAcsB,QAAd,CAAuBpB,SAApC,kCACXqB,YADW,GAEX,MAAKvB,QAAL,CAAcsB,QAFH,EAAhB;MAKAvD,GAAG,CAAC,sBAAD,CAAH;IACD,CA5DoB,CA8DrB;;;IACA,MAAK0D,QAAL,GAAgB,IAAInC,QAAJ,CAAa;MAC3BoC,SAAS,EAAE,MAAKzB,MADW;MAE3BmB,OAAO,EAAE,MAAKA,OAFa;MAG3BO,YAAY,EAAE,sBAACC,UAAD;QAAA,OAAgB,MAAKX,iBAAL,CAAuBY,SAAvB,CAAiCD,UAAjC,CAAhB;MAAA,CAHa;MAI3BE,eAAe,EAAE,yBAACF,UAAD;QAAA,OAAgB,MAAKX,iBAAL,CAAuBc,YAAvB,CAAoCH,UAApC,CAAhB;MAAA;IAJU,CAAb,CAAhB,CA/DqB,CAsErB;;IACA,MAAKI,gBAAL,GAAwB,IAAI3C,gBAAJ,CAAqB;MAC3C4C,MAAM,+BADqC;MAE3CR,QAAQ,EAAE,MAAKA,QAF4B;MAG3CS,cAAc,EAAE,MAAKlC,QAAL,CAAcgC,gBAAd,CAA+BE;IAHJ,CAArB,CAAxB,CAvEqB,CA6ErB;;IACA,MAAKC,UAAL,GAAkB,IAAItC,UAAJ;MAChBI,MAAM,EAAE,MAAKA,MADG;MAEhBK,cAAc,EAAE,MAAKA,cAFL;MAGhB0B,gBAAgB,EAAE,MAAKA;IAHP,GAKb,MAAKhC,QAAL,CAAca,MAAd,CAAqBuB,GALR,EAAlB,CA9EqB,CAsFrB;;IACA,MAAKC,SAAL,GAAiB,IAAI3C,SAAJ,CAAc;MAC7BS,SAAS,EAAE,MAAKA,SADa;MAE7Bc,iBAAiB,EAAE,MAAKA;IAFK,CAAd,CAAjB;IAKA,MAAKqB,MAAL,GAAc,MAAKA,MAAL,CAAYC,IAAZ,+BAAd;IACA,MAAKF,SAAL,CAAeC,MAAf,GAAwB,MAAKA,MAA7B,CA7FqB,CA+FrB;;IACA,IAAI,CAAC,MAAK5B,QAAL,CAAc8B,cAAf,IAAiC,CAAC,MAAK9B,QAAL,CAAc8B,cAAd,CAA6BC,MAAnE,EAA2E;MACzE,MAAMrE,OAAO,CAAC,IAAIsE,KAAJ,CAAU7D,QAAQ,CAAC8D,wBAAnB,CAAD,EAA+C/D,KAAK,CAAC+D,wBAArD,CAAb;IACD;;IACD,IAAMC,OAAO,GAAG,MAAKlC,QAAL,CAAc8B,cAA9B;IACAI,OAAO,CAACC,OAAR,CAAgB,UAACC,MAAD,EAAY;MAC1B,MAAKrB,QAAL,CAAcmB,OAAd,CAAsBG,GAAtB,CAA0BD,MAAM,CAACE,QAAjC,EAA2CF,MAA3C;IACD,CAFD;IAIA,MAAKG,MAAL,GAAc,IAAI/D,MAAJ;MACZ8C,gBAAgB,EAAE,MAAKA,gBADX;MAEZ7B,SAAS,EAAE,MAAKA;IAFJ,GAGT,MAAKH,QAAL,CAAciD,MAHL,EAAd;;IAMA,MAAKvC,QAAL,CAAcwC,SAAd,CAAwBL,OAAxB,CAAgC,UAACM,SAAD,EAAe;MAC7C,IAAMC,GAAG,GAAGD,SAAS,CAACE,SAAV,CAAoBC,MAAM,CAACC,WAA3B,CAAZ;MACA,IAAMC,gBAAgB,GAAG,MAAK5C,OAAL,CAAasC,SAAb,CAAuBE,GAAvB,CAAzB;;MACA,MAAKpB,gBAAL,CAAsByB,GAAtB,CAA0BL,GAA1B,EAA+BD,SAA/B,EAA0CK,gBAA1C;IACD,CAJD;;IAMA,IAAI,MAAK5C,OAAL,CAAa8C,KAAb,CAAmBrC,OAAvB,EAAgC;MAC9B;MACA,MAAKW,gBAAL,CAAsByB,GAAtB,CAA0BzE,OAAO,CAACqE,SAAR,CAAkBC,MAAM,CAACC,WAAzB,CAA1B,EAAiEvE,OAAjE;;MACA,MAAK0E,KAAL,GAAa,IAAIzE,KAAJ,+BAAb;IACD,CAxHoB,CA0HrB;;;IACA,IAAI,MAAKyB,QAAL,CAAciD,WAAlB,EAA+B;MAC7B,IAAMC,MAAM,GAAG,MAAKlD,QAAL,CAAciD,WAA7B;MACAC,MAAM,CAACf,OAAP,CAAe,UAACgB,KAAD,EAAW;QACxB,MAAKpC,QAAL,CAAcmC,MAAd,CAAqBb,GAArB,CAAyBc,KAAK,CAACC,UAA/B,EAA2CD,KAA3C;MACD,CAFD,EAF6B,CAM7B;;MACA,MAAKE,eAAL,GAAuB,IAAInE,eAAJ,CAAoB;QAAEqC,MAAM;MAAR,CAApB,CAAvB;;MACA,MAAKK,MAAL,CAAYtE,MAAM,CAACgG,MAAP,CAAcpE,eAAe,CAACqE,cAAhB,+BAAd,CAAZ,EAAiE,MAAKF,eAAL,CAAqBG,aAAtF;IACD,CApIoB,CAsIrB;;;IACA,IAAI,MAAKxD,QAAL,CAAcyD,aAAlB,EAAiC;MAC/B,MAAK1C,QAAL,CAAc2C,SAAd,GAA0B,MAAK1D,QAAL,CAAcyD,aAAxC;IACD,CAFD,MAEO,IAAIE,UAAU,CAACC,OAAX,KAAuBC,SAAvB,IAAoCF,UAAU,CAACC,OAAX,CAAmBE,GAAvD,IAA8DH,UAAU,CAACC,OAAX,CAAmBE,GAAnB,CAAuBC,iBAAzF,EAA4G;MAAE;MACnH,MAAM,IAAI/B,KAAJ,CAAU,4DAAV,CAAN;IACD,CA3IoB,CA6IrB;;;IACA,IAAI,MAAKhC,QAAL,CAAcgE,GAAlB,EAAuB;MACrB,IAAMC,GAAG,GAAG,MAAKjE,QAAL,CAAcgE,GAA1B,CADqB,CAErB;;MACA,MAAKE,IAAL,GAAY,IAAID,GAAJ;QACV1C,MAAM,+BADI;QAEVgB,MAAM,EAAE,MAAKA,MAFH;QAGVhD,MAAM,EAAE,MAAKA,MAHH;QAIVE,SAAS,EAAE,MAAKA,SAJN;QAKVkC,SAAS,EAAE,MAAKA,SALN;QAMVnC,SAAS,EAAE,MAAKA;MANN,GAOP,MAAKU,OAAL,CAAa8D,GAPN,EAAZ;IASD,CA1JoB,CA4JrB;;;IACA,IAAI,MAAKhE,QAAL,CAAcmE,MAAlB,EAA0B;MACxB,IAAMC,MAAM,GAAG,MAAKpE,QAAL,CAAcmE,MAA7B,CADwB,CAExB;;MACA;;MACA,MAAKA,MAAL,GAAcrF,aAAa,CAACsF,MAAD,iCAAe,MAAKlE,OAAL,CAAaiE,MAA5B,CAA3B;IACD,CAlKoB,CAoKrB;IACA;;;IACA,MAAKE,WAAL,GAAmB,IAAIxG,WAAJ,+BAAnB;IACA,MAAKyG,cAAL,GAAsB,IAAIxG,cAAJ,+BAAtB,CAvKqB,CAyKrB;;IACAmB,KAAI,CAACsF,KAAL;;IAEA,MAAKC,gBAAL,GAAwB,MAAKA,gBAAL,CAAsB3C,IAAtB,+BAAxB;IA5KqB;EA6KtB;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACE,cAAM4C,SAAN,EAA0B;MAAA,kCAANC,IAAM;QAANA,IAAM;MAAA;;MACxB;MACA;MACA,IAAID,SAAS,KAAK,OAAd,IAAyB,CAAC,KAAKE,OAAL,CAAanH,KAA3C,EAAkD;QAChDH,GAAG,CAACG,KAAJ,CAAUkH,IAAV;QACA,OAAO,KAAP;MACD,CAHD,MAGO;QAAA;;QACL,gGAAkBD,SAAlB,SAAgCC,IAAhC;MACD;IACF;IAED;AACF;AACA;AACA;AACA;;;;;8EACE;QAAA;UAAA;YAAA;cAAA;gBACErH,GAAG,CAAC,oBAAD,CAAH;gBADF;gBAAA;gBAAA,OAIU,KAAKuH,WAAL,EAJV;;cAAA;gBAAA;gBAAA,OAKU,KAAKC,WAAL,EALV;;cAAA;gBAMIxH,GAAG,CAAC,oBAAD,CAAH;gBANJ;gBAAA;;cAAA;gBAAA;gBAAA;gBAQI,KAAKyH,IAAL,CAAU,OAAV;gBACAzH,GAAG,CAACG,KAAJ,CAAU,mCAAV;gBATJ;gBAAA,OAUU,KAAKuH,IAAL,EAVV;;cAAA;gBAAA;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAeA;AACF;AACA;AACA;AACA;AACA;;;;;6EACE;QAAA;;QAAA;UAAA;YAAA;cAAA;gBACE1H,GAAG,CAAC,oBAAD,CAAH;gBADF;gBAII,KAAK2H,UAAL,GAAkB,KAAlB;gBAEA,KAAKhC,KAAL,IAAc,KAAKA,KAAL,CAAW+B,IAAX,EAAd;gBACA,KAAKV,WAAL,CAAiBU,IAAjB;gBAPJ,uCAS0B,KAAK1E,UAAL,CAAgBiD,MAAhB,EAT1B;;gBAAA;kBASI,oDAAgD;oBAArC2B,OAAqC;oBAC9CA,OAAO,CAACC,cAAR,CAAuB,MAAvB,EAA+B,KAAKV,gBAApC;kBACD;gBAXL;kBAAA;gBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAaUW,OAAO,CAACC,GAAR,CAAYC,KAAK,CAACC,IAAN,CAAW,KAAKjF,UAAL,CAAgBiD,MAAhB,EAAX,EAAqC,UAAAiC,CAAC;kBAAA,OAAIA,CAAC,CAACR,IAAF,EAAJ;gBAAA,CAAtC,CAAZ,CAbV;;cAAA;gBAeI,KAAK1E,UAAL,GAAkB,IAAIC,GAAJ,EAAlB;gBAfJ;gBAAA,OAiBU,KAAKb,SAAL,CAAesF,IAAf,EAjBV;;cAAA;gBAAA;gBAAA,OAkBU,KAAKxE,iBAAL,CAAuBwE,IAAvB,EAlBV;;cAAA;gBAAA;gBAAA,OAoBUI,OAAO,CAACC,GAAR,CAAY,CAChB,KAAKjB,MAAL,IAAe,KAAKA,MAAL,CAAYY,IAAZ,EADC,EAEhB,KAAKb,IAAL,IAAa,KAAKA,IAAL,CAAUa,IAAV,EAFG,EAGhB,KAAKrE,OAAL,IAAgB,KAAKA,OAAL,CAAaqE,IAAb,EAHA,CAAZ,CApBV;;cAAA;gBAAA;gBAAA,OA0BU,KAAKtD,UAAL,CAAgBsD,IAAhB,EA1BV;;cAAA;gBAAA;gBAAA,OA2BU,KAAKzD,gBAAL,CAAsBkE,KAAtB,EA3BV;;cAAA;gBA6BIvG,KAAI,CAACwG,OAAL,CAAa,IAAb;;gBACA,KAAKlD,MAAL,CAAYmD,OAAZ;gBA9BJ;gBAAA;;cAAA;gBAAA;gBAAA;;gBAgCI,kBAAS;kBACPrI,GAAG,CAACG,KAAJ;kBACA,KAAKsH,IAAL,CAAU,OAAV;gBACD;;cAnCL;gBAqCEzH,GAAG,CAAC,oBAAD,CAAH;;cArCF;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAwCA;AACF;AACA;AACA;AACA;AACA;AACA;;;;;qFACE;QAAA;UAAA;YAAA;cAAA;gBAAA,IACO,KAAKuD,QADZ;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAAA;gBAAA;gBAAA,OAMU,KAAKA,QAAL,CAAc+E,aAAd,CAA4B,MAA5B,CANV;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBAAA;gBAAA,OAQU,KAAK/E,QAAL,CAAcgF,UAAd,CAAyB,MAAzB,EAAiC,KAAKrG,MAAtC,CARV;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;WAYA,qBAAa;MACX,OAAO,KAAKyF,UAAZ;IACD;IAED;AACF;AACA;AACA;AACA;AACA;;;;SACE,eAAmB;MACjB,OAAO,KAAKzE,iBAAL,CAAuBsF,WAA9B;IACD;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,cAAMC,IAAN,EAAYC,OAAZ,EAAqB;MACnB,OAAO,KAAKC,KAAL,CAAWF,IAAX,EAAiBC,OAAjB,CAAP;IACD;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;qFACE,kBAAoBD,IAApB,EAA0BG,SAA1B,EAAqCF,OAArC;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,MACM,CAACE,SAAD,IAAc,CAACA,SAAS,CAAClE,MAD/B;kBAAA;kBAAA;gBAAA;;gBAAA,MAEUrE,OAAO,CAAC,IAAIsE,KAAJ,CAAU,6CAAV,CAAD,EAA2D9D,KAAK,CAACgI,gCAAjE,CAFjB;;cAAA;gBAAA;gBAAA,OAK2B,KAAKF,KAAL,CAAWF,IAAX,EAAiBC,OAAjB,CAL3B;;cAAA;gBAKQ7E,UALR;gBAAA,kCAMSA,UAAU,CAACiF,SAAX,CAAqBF,SAArB,CANT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IASA;AACF;AACA;AACA;AACA;AACA;;;;;8EACE,kBAAaH,IAAb,EAAmBC,OAAnB;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAA,WAC6BhI,OAAO,CAAC+H,IAAD,CADpC,EACUM,EADV,YACUA,EADV,EACcC,UADd,YACcA,UADd;;gBAAA,KAGMD,EAAE,CAACE,MAAH,CAAU,KAAK/G,MAAf,CAHN;kBAAA;kBAAA;gBAAA;;gBAAA,MAIU7B,OAAO,CAAC,IAAIsE,KAAJ,CAAU,kBAAV,CAAD,EAAgC9D,KAAK,CAACqI,eAAtC,CAJjB;;cAAA;gBAOMrF,UAPN,GAOmB,KAAKX,iBAAL,CAAuBiG,GAAvB,CAA2BJ,EAA3B,CAPnB;;gBAAA,IASOlF,UATP;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAUuB,KAAKqB,MAAL,CAAYkE,aAAZ,CAA0BX,IAA1B,EAAgCC,OAAhC,CAVvB;;cAAA;gBAUI7E,UAVJ;gBAAA;gBAAA;;cAAA;gBAWS,IAAImF,UAAJ,EAAgB;kBACrB,KAAK5G,SAAL,CAAeiH,WAAf,CAA2B3D,GAA3B,CAA+BqD,EAA/B,EAAmCC,UAAnC;gBACD;;cAbH;gBAAA,kCAeSnF,UAfT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAkBA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;SACE,eAAkB;MAChB,IAAIyF,KAAK,GAAG,KAAK/G,cAAL,CAAoBgH,gBAApB,GAAuCC,GAAvC,CAA2C,UAAAC,EAAE;QAAA,OAAIA,EAAE,CAACC,QAAH,EAAJ;MAAA,CAA7C,CAAZ;;MAEA,IAAI,CAACJ,KAAK,CAAC5E,MAAX,EAAmB;QACjB;QACA4E,KAAK,GAAG,KAAKrF,gBAAL,CAAsB0F,QAAtB,GAAiCH,GAAjC,CAAqC,UAAAC,EAAE;UAAA,OAAIA,EAAE,CAACC,QAAH,EAAJ;QAAA,CAAvC,CAAR;MACD;;MAEDJ,KAAK,GAAGA,KAAK,CAACM,MAAN,CAAa,KAAKrH,cAAL,CAAoBsH,gBAApB,GAAuCL,GAAvC,CAA2C,UAAAC,EAAE;QAAA,OAAIA,EAAE,CAACC,QAAH,EAAJ;MAAA,CAA7C,CAAb,CAAR;MAEA,IAAMI,cAAc,GAAG,KAAK7H,QAAL,CAAcK,SAAd,CAAwBwH,cAA/C,CAVgB,CAYhB;;MACA,IAAMC,OAAO,GAAG,IAAIC,GAAJ,CAAQV,KAAR,CAAhB,CAbgB,CAehB;;MACA,OAAOQ,cAAc,CAAC9B,KAAK,CAACC,IAAN,CAAW8B,OAAX,EAAoBP,GAApB,CAAwB,UAAAS,GAAG;QAAA,OAAI,IAAI1J,SAAJ,CAAc0J,GAAd,CAAJ;MAAA,CAA3B,CAAD,CAArB;IACD;IAED;AACF;AACA;AACA;AACA;AACA;;;;;+EACE,kBAAcxB,IAAd;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAA,YACiB/H,OAAO,CAAC+H,IAAD,CADxB,EACUM,EADV,aACUA,EADV;gBAGQP,WAHR,GAGsB,KAAKtF,iBAAL,CAAuBsF,WAAvB,CAAmCW,GAAnC,CAAuCJ,EAAE,CAACmB,WAAH,EAAvC,CAHtB;;gBAAA,IAKO1B,WALP;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAAA;gBAAA,OASQV,OAAO,CAACC,GAAR,CACJS,WAAW,CAACgB,GAAZ,CAAgB,UAAA3F,UAAU,EAAI;kBAC5B,OAAOA,UAAU,CAACsE,KAAX,EAAP;gBACD,CAFD,CADI,CATR;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAgBA;AACF;AACA;AACA;AACA;AACA;;;;WACE,cAAMM,IAAN,EAAY;MACV,gBAA2B/H,OAAO,CAAC+H,IAAD,CAAlC;MAAA,IAAQM,EAAR,aAAQA,EAAR;MAAA,IAAYC,UAAZ,aAAYA,UAAZ,CADU,CAGV;;;MACA,IAAIA,UAAJ,EAAgB;QACd,OAAOpH,KAAI,CAAC,IAAD,EAAOoH,UAAU,CAAC,CAAD,CAAjB,CAAX;MACD;;MAED,OAAOpH,KAAI,CAAC,IAAD,EAAOmH,EAAP,CAAX;IACD;IAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,gBAAQH,SAAR,EAAmBuB,OAAnB,EAA4B;MAAA;;MAC1BvB,SAAS,GAAGZ,KAAK,CAACoC,OAAN,CAAcxB,SAAd,IAA2BA,SAA3B,GAAuC,CAACA,SAAD,CAAnD;MACAA,SAAS,CAAC9D,OAAV,CAAkB,UAAAG,QAAQ,EAAI;QAC5B,MAAI,CAACvB,QAAL,CAAckF,SAAd,CAAwB5D,GAAxB,CAA4BC,QAA5B,EAAsCkF,OAAtC;MACD,CAFD,EAF0B,CAM1B;;MACA,KAAK/H,SAAL,CAAeiI,SAAf,CAAyB3E,GAAzB,CAA6B,KAAKxD,MAAlC,EAA0C0G,SAA1C;IACD;IAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,kBAAUA,SAAV,EAAqB;MAAA;;MACnBA,SAAS,GAAGZ,KAAK,CAACoC,OAAN,CAAcxB,SAAd,IAA2BA,SAA3B,GAAuC,CAACA,SAAD,CAAnD;MACAA,SAAS,CAAC9D,OAAV,CAAkB,UAAAG,QAAQ,EAAI;QAC5B,MAAI,CAACvB,QAAL,CAAckF,SAAd,CAAwB0B,MAAxB,CAA+BrF,QAA/B;MACD,CAFD,EAFmB,CAMnB;;MACA,KAAK7C,SAAL,CAAeiI,SAAf,CAAyBE,MAAzB,CAAgC,KAAKrI,MAArC,EAA6C0G,SAA7C;IACD;;;;oFAED;QAAA;QAAA;UAAA;YAAA;cAAA;gBACE;gBACMU,KAFR,GAEgB,KAAK/G,cAAL,CAAoBiI,cAApB,EAFhB;gBAAA;gBAAA,OAGQ,KAAKvG,gBAAL,CAAsBwG,MAAtB,CAA6BnB,KAA7B,CAHR;;cAAA;gBAKE;gBACA,KAAKlF,UAAL,CAAgBsG,KAAhB,GANF,CAQE;;gBARF;gBAAA,OASQ,KAAKtI,SAAL,CAAesI,KAAf,EATR;;cAAA;gBAWE,IAAI,KAAK7H,OAAL,CAAaiE,MAAb,CAAoBxD,OAAxB,EAAiC;kBAC/B,KAAKwD,MAAL,IAAe,KAAKA,MAAL,CAAY4D,KAAZ,EAAf;gBACD,CAbH,CAeE;;;gBACA,IAAI,KAAK7H,OAAL,CAAa8D,GAAb,CAAiBrD,OAArB,EAA8B;kBAC5B,KAAKuD,IAAL,IAAa,KAAKA,IAAL,CAAU6D,KAAV,EAAb,CAD4B,CAG5B;kBACA;;kBACA,KAAK7D,IAAL,CAAUrE,EAAV,CAAa,MAAb,EAAqB,KAAK2E,gBAA1B;gBACD,CAtBH,CAwBE;;;gBACA,KAAK9D,OAAL,IAAgB,KAAKA,OAAL,CAAaqH,KAAb,EAAhB;;cAzBF;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IA4BA;AACF;AACA;AACA;AACA;;;;;oFACE;QAAA;;QAAA;;QAAA;UAAA;YAAA;cAAA;gBACE,KAAK/C,UAAL,GAAkB,IAAlB;gBAEA,KAAKvF,SAAL,CAAeI,EAAf,CAAkB,MAAlB,EAA0B,UAAAN,MAAM,EAAI;kBAClC,MAAI,CAACuF,IAAL,CAAU,gBAAV,EAA4BvF,MAA5B;;kBACA,MAAI,CAACyI,aAAL,CAAmBzI,MAAnB;gBACD,CAHD,EAHF,CAQE;gBACA;;gBATF,wCAUqB,KAAKE,SAAL,CAAewI,KAAf,CAAqB3E,MAArB,EAVrB;;gBAAA;kBAUE,uDAAkD;oBAAvCwC,IAAuC;oBAChD,KAAKhB,IAAL,CAAU,gBAAV,EAA4BgB,IAAI,CAACM,EAAjC;kBACD;gBAZH;kBAAA;gBAAA;kBAAA;gBAAA;;gBAcE,KAAK7F,iBAAL,CAAuBwH,KAAvB,GAdF,CAgBE;;gBAhBF;gBAAA,OAiBQ,KAAKG,mBAAL,EAjBR;;cAAA;gBAmBE;gBACA,KAAKlF,KAAL,IAAc,KAAKA,KAAL,CAAW+E,KAAX,EAAd;gBAEA,KAAK1D,WAAL,CAAiB0D,KAAjB;;cAtBF;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAyBA;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,0BAAkBjC,IAAlB,EAAwB;MACtB,IAAIA,IAAI,CAACM,EAAL,CAAQmB,WAAR,OAA0B,KAAKhI,MAAL,CAAYgI,WAAZ,EAA9B,EAAyD;QACvDlK,GAAG,CAACG,KAAJ,CAAU,IAAIwE,KAAJ,CAAU9D,KAAK,CAACiK,mBAAhB,CAAV;QACA;MACD;;MAEDrC,IAAI,CAACO,UAAL,IAAmB,KAAK5G,SAAL,CAAeiH,WAAf,CAA2B3D,GAA3B,CAA+B+C,IAAI,CAACM,EAApC,EAAwCN,IAAI,CAACO,UAA7C,CAAnB;MACAP,IAAI,CAACG,SAAL,IAAkB,KAAKxG,SAAL,CAAeiI,SAAf,CAAyBrF,GAAzB,CAA6ByD,IAAI,CAACM,EAAlC,EAAsCN,IAAI,CAACG,SAA3C,CAAlB;IACD;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;sFACE,kBAAqB1G,MAArB;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,MAEM,KAAKW,OAAL,CAAaO,aAAb,CAA2BD,QAA3B,KAAwC,IAAxC,IAAgD,CAAC,KAAKD,iBAAL,CAAuBiG,GAAvB,CAA2BjH,MAA3B,CAFvD;kBAAA;kBAAA;gBAAA;;gBAGU6I,cAHV,GAG2B,KAAK9I,QAAL,CAAciB,iBAAd,CAAgC6H,cAAhC,IAAkD,CAH7E;;gBAAA,MAIQA,cAAc,GAAG,KAAK7H,iBAAL,CAAuB8H,IAJhD;kBAAA;kBAAA;gBAAA;;gBAKMhL,GAAG,CAAC,kCAAD,EAAqCkC,MAAM,CAACgI,WAAP,EAArC,CAAH;gBALN;gBAAA;gBAAA,OAOc,KAAKhF,MAAL,CAAYkE,aAAZ,CAA0BlH,MAA1B,CAPd;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBASQlC,GAAG,CAACG,KAAJ,gDAAkD+B,MAAM,CAACgI,WAAP,EAAlD;;cATR;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAeA;AACF;AACA;AACA;AACA;AACA;;;;;4FACE;QAAA;;QAAA;;QAAA;UAAA;YAAA;cAAA;gBACE;AACJ;AACA;gBACUe,YAJR,GAIuB,SAAfA,YAAe,CAACC,gBAAD,EAAsB;kBACzC,IAAIpI,MAAM,GAAG;oBACXQ,OAAO,EAAE,IADE,CACG;;kBADH,CAAb;;kBAIA,IAAI4H,gBAAgB,CAACC,GAAjB,IACF,MAAI,CAACtI,OAAL,CAAaO,aADX,IAEF,MAAI,CAACP,OAAL,CAAaO,aAAb,CAA2B8H,gBAAgB,CAACC,GAA5C,CAFF,EAEoD;oBAClD;oBACArI,MAAM,mCAAQA,MAAR,GAAmB,MAAI,CAACD,OAAL,CAAaO,aAAb,CAA2B8H,gBAAgB,CAACC,GAA5C,CAAnB,CAAN;kBACD;;kBAED,IAAIrI,MAAM,CAACQ,OAAP,IACF,CAAC,MAAI,CAACN,UAAL,CAAgBoI,GAAhB,CAAoBF,gBAAgB,CAACC,GAArC,CADH,EAC8C;oBAAE;oBAC9C,IAAIE,gBAAJ;;oBAEA,IAAI,OAAOH,gBAAP,KAA4B,UAAhC,EAA4C;sBAC1C;sBACAG,gBAAgB,GAAG,IAAIH,gBAAJ,CAAqBjL,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB4C,MAAlB,EAA0B;wBAChEZ,MAAM,EAAE,MAAI,CAACA,MADmD;wBAEhEgC,MAAM,EAAE;sBAFwD,CAA1B,CAArB,CAAnB;oBAID,CAND,MAMO;sBACLmH,gBAAgB,GAAGH,gBAAnB;oBACD;;oBAEDG,gBAAgB,CAAC7I,EAAjB,CAAoB,MAApB,EAA4B,MAAI,CAAC2E,gBAAjC;;oBACA,MAAI,CAACnE,UAAL,CAAgBgC,GAAhB,CAAoBkG,gBAAgB,CAACC,GAArC,EAA0CE,gBAA1C;kBACD;gBACF,CAjCH,EAmCE;;;gBAnCF,wCAoCiC,KAAK1I,QAAL,CAAcS,aAAd,IAA+B,EApChE;;gBAAA;kBAoCE,uDAAkE;oBAAvD8H,gBAAuD;oBAChED,YAAY,CAACC,gBAAD,CAAZ;kBACD,CAtCH,CAwCE;;gBAxCF;kBAAA;gBAAA;kBAAA;gBAAA;;gBAAA,wCAyC0B,KAAKjH,gBAAL,CAAsBqH,aAAtB,EAzC1B;;gBAAA;kBAyCE,uDAA+D;oBAApDlG,SAAoD;;oBAC7D;oBACA,IAAIA,SAAS,CAACmG,SAAd,EAAyB;sBACvB;sBACAN,YAAY,CAAC7F,SAAS,CAACmG,SAAX,CAAZ;oBACD;kBACF;gBA/CH;kBAAA;gBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAiDQzD,OAAO,CAACC,GAAR,CAAYC,KAAK,CAACC,IAAN,CAAW,KAAKjF,UAAL,CAAgBiD,MAAhB,EAAX,EAAqC,UAAAuF,CAAC;kBAAA,OAAIA,CAAC,CAACd,KAAF,EAAJ;gBAAA,CAAtC,CAAZ,CAjDR;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;IApkBA;AACF;AACA;AACA;AACA;AACA;AACA;;+EACE,mBAAqBhC,OAArB;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,KACMA,OAAO,CAACxG,MADd;kBAAA;kBAAA;gBAAA;;gBAAA,mCAGW,IAAIF,MAAJ,CAAW0G,OAAX,CAHX;;cAAA;gBAAA;gBAAA,OAMuBpI,MAAM,CAACmL,MAAP,EANvB;;cAAA;gBAMQvJ,MANR;gBAQEwG,OAAO,CAACxG,MAAR,GAAiBA,MAAjB,CARF,CASE;;gBATF,mCAUS,IAAIF,MAAJ,CAAW0G,OAAX,CAVT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;EARmBtI,Y;;AA0nBrBsL,MAAM,CAACC,OAAP,GAAiB3J,MAAjB"},"metadata":{},"sourceType":"script"}