{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar createLock = require('./utils/create-lock');\n\nvar isIpfs = require('is-ipfs');\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('ipfs-core-utils/src/multihashes')} Multihashes\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n *\n * @typedef {object} MfsContext\n * @property {IPFSRepo} repo\n * @property {Multihashes} hashers\n */\n\n/**\n * These operations are read-locked at the function level and will execute simultaneously\n *\n * @type {Record<string, any>}\n */\n\n\nvar readOperations = {\n  stat: require('./stat')\n};\n/**\n * These operations are locked at the function level and will execute in series\n *\n * @type {Record<string, any>}\n */\n\nvar writeOperations = {\n  chmod: require('./chmod'),\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm'),\n  touch: require('./touch')\n};\n/**\n * These operations are asynchronous and manage their own locking\n *\n * @type {Record<string, any>}\n */\n\nvar unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n};\n/**\n * @param {object} arg\n * @param {MfsContext} arg.options\n * @param {*} arg.mfs\n * @param {*} arg.operations\n * @param {*} arg.lock\n */\n\nvar wrap = function wrap(_ref2) {\n  var options = _ref2.options,\n      mfs = _ref2.mfs,\n      operations = _ref2.operations,\n      lock = _ref2.lock;\n  Object.keys(operations).forEach(function (key) {\n    mfs[key] = lock(operations[key](options));\n  });\n};\n\nvar defaultOptions = {\n  repoOwner: true,\n  repo: null\n};\n/**\n * @param {object} options\n * @param {IPFSRepo} options.repo\n * @param {boolean} options.repoOwner\n * @param {Multihashes} options.hashers\n */\n\nfunction createMfs(options) {\n  var _Object$assign = Object.assign({}, defaultOptions || {}, options),\n      repoOwner = _Object$assign.repoOwner;\n\n  var lock = createLock(repoOwner);\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n\n  var readLock = function readLock(operation) {\n    return lock.readLock(operation);\n  };\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n\n\n  var writeLock = function writeLock(operation) {\n    return lock.writeLock(operation);\n  };\n  /** @type {Record<string, any>} */\n\n\n  var mfs = {};\n  wrap({\n    options: options,\n    mfs: mfs,\n    operations: readOperations,\n    lock: readLock\n  });\n  wrap({\n    options: options,\n    mfs: mfs,\n    operations: writeOperations,\n    lock: writeLock\n  });\n  Object.keys(unwrappedOperations).forEach(function (key) {\n    mfs[key] = unwrappedOperations[key](options);\n  });\n  return mfs;\n}\n/**\n * @param {object} context\n * @param {IPFSRepo} context.repo\n * @param {import('../../types').Preload} context.preload\n * @param {import('..').Options} context.options\n * @param {Multihashes} context.hashers\n * @returns {import('ipfs-core-types/src/files').API}\n */\n\n\nmodule.exports = function (_ref3) {\n  var repo = _ref3.repo,\n      preload = _ref3.preload,\n      hashers = _ref3.hashers,\n      constructorOptions = _ref3.options;\n  var methods = createMfs({\n    repo: repo,\n    repoOwner: Boolean(constructorOptions.repoOwner),\n    hashers: hashers\n  });\n  /**\n   * @param {any} fn\n   */\n\n  var withPreload = function withPreload(fn) {\n    /**\n     * @param  {...any} args\n     */\n    var wrapped = function wrapped() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // @ts-ignore cannot derive type of arg\n      var paths = args.filter(function (arg) {\n        return isIpfs.ipfsPath(arg) || isIpfs.cid(arg);\n      });\n\n      if (paths.length) {\n        var options = args[args.length - 1]; // @ts-ignore it's a PreloadOptions, honest\n\n        if (options && options.preload !== false) {\n          paths.forEach(function (path) {\n            return preload(path);\n          });\n        }\n      }\n\n      return fn.apply(void 0, args);\n    };\n\n    return wrapped;\n  };\n\n  return _objectSpread(_objectSpread({}, methods), {}, {\n    chmod: methods.chmod,\n    cp: withPreload(methods.cp),\n    mkdir: methods.mkdir,\n    stat: withPreload(methods.stat),\n    rm: methods.rm,\n    read: withPreload(methods.read),\n    touch: methods.touch,\n    write: methods.write,\n    mv: withPreload(methods.mv),\n    flush: methods.flush,\n    ls: withPreload( /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var _iteratorAbruptCompletion,\n          _didIteratorError,\n          _iteratorError,\n          _iterator,\n          _step,\n          file,\n          _args = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context.prev = 2;\n              _iterator = _asyncIterator(methods.ls.apply(methods, _args));\n\n            case 4:\n              _context.next = 6;\n              return _awaitAsyncGenerator(_iterator.next());\n\n            case 6:\n              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                _context.next = 13;\n                break;\n              }\n\n              file = _step.value;\n              _context.next = 10;\n              return _objectSpread(_objectSpread({}, file), {}, {\n                size: file.size || 0\n              });\n\n            case 10:\n              _iteratorAbruptCompletion = false;\n              _context.next = 4;\n              break;\n\n            case 13:\n              _context.next = 19;\n              break;\n\n            case 15:\n              _context.prev = 15;\n              _context.t0 = _context[\"catch\"](2);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 19:\n              _context.prev = 19;\n              _context.prev = 20;\n\n              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                _context.next = 24;\n                break;\n              }\n\n              _context.next = 24;\n              return _awaitAsyncGenerator(_iterator.return());\n\n            case 24:\n              _context.prev = 24;\n\n              if (!_didIteratorError) {\n                _context.next = 27;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 27:\n              return _context.finish(24);\n\n            case 28:\n              return _context.finish(19);\n\n            case 29:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 15, 19, 29], [20,, 24, 28]]);\n    })))\n  });\n};","map":{"version":3,"names":["createLock","require","isIpfs","readOperations","stat","writeOperations","chmod","cp","flush","mkdir","mv","rm","touch","unwrappedOperations","write","read","ls","wrap","options","mfs","operations","lock","Object","keys","forEach","key","defaultOptions","repoOwner","repo","createMfs","assign","readLock","operation","writeLock","module","exports","preload","hashers","constructorOptions","methods","Boolean","withPreload","fn","wrapped","args","paths","filter","arg","ipfsPath","cid","length","path","file","size"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/index.js"],"sourcesContent":["'use strict'\n\nconst createLock = require('./utils/create-lock')\nconst isIpfs = require('is-ipfs')\n\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('ipfs-core-utils/src/multihashes')} Multihashes\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n *\n * @typedef {object} MfsContext\n * @property {IPFSRepo} repo\n * @property {Multihashes} hashers\n */\n\n/**\n * These operations are read-locked at the function level and will execute simultaneously\n *\n * @type {Record<string, any>}\n */\nconst readOperations = {\n  stat: require('./stat')\n}\n\n/**\n * These operations are locked at the function level and will execute in series\n *\n * @type {Record<string, any>}\n */\nconst writeOperations = {\n  chmod: require('./chmod'),\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm'),\n  touch: require('./touch')\n}\n\n/**\n * These operations are asynchronous and manage their own locking\n *\n * @type {Record<string, any>}\n */\nconst unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n}\n\n/**\n * @param {object} arg\n * @param {MfsContext} arg.options\n * @param {*} arg.mfs\n * @param {*} arg.operations\n * @param {*} arg.lock\n */\nconst wrap = ({\n  options, mfs, operations, lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options))\n  })\n}\n\nconst defaultOptions = {\n  repoOwner: true,\n  repo: null\n}\n\n/**\n * @param {object} options\n * @param {IPFSRepo} options.repo\n * @param {boolean} options.repoOwner\n * @param {Multihashes} options.hashers\n */\nfunction createMfs (options) {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options)\n\n  const lock = createLock(repoOwner)\n\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n  const readLock = (operation) => {\n    return lock.readLock(operation)\n  }\n\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n  const writeLock = (operation) => {\n    return lock.writeLock(operation)\n  }\n\n  /** @type {Record<string, any>} */\n  const mfs = {}\n\n  wrap({\n    options, mfs, operations: readOperations, lock: readLock\n  })\n  wrap({\n    options, mfs, operations: writeOperations, lock: writeLock\n  })\n\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options)\n  })\n\n  return mfs\n}\n\n/**\n * @param {object} context\n * @param {IPFSRepo} context.repo\n * @param {import('../../types').Preload} context.preload\n * @param {import('..').Options} context.options\n * @param {Multihashes} context.hashers\n * @returns {import('ipfs-core-types/src/files').API}\n */\nmodule.exports = ({ repo, preload, hashers, options: constructorOptions }) => {\n  const methods = createMfs({\n    repo,\n    repoOwner: Boolean(constructorOptions.repoOwner),\n    hashers\n  })\n\n  /**\n   * @param {any} fn\n   */\n  const withPreload = fn => {\n    /**\n     * @param  {...any} args\n     */\n    const wrapped = (...args) => {\n      // @ts-ignore cannot derive type of arg\n      const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg))\n\n      if (paths.length) {\n        const options = args[args.length - 1]\n        // @ts-ignore it's a PreloadOptions, honest\n        if (options && options.preload !== false) {\n          paths.forEach(path => preload(path))\n        }\n      }\n\n      return fn(...args)\n    }\n\n    return wrapped\n  }\n\n  return {\n    ...methods,\n    chmod: methods.chmod,\n    cp: withPreload(methods.cp),\n    mkdir: methods.mkdir,\n    stat: withPreload(methods.stat),\n    rm: methods.rm,\n    read: withPreload(methods.read),\n    touch: methods.touch,\n    write: methods.write,\n    mv: withPreload(methods.mv),\n    flush: methods.flush,\n    ls: withPreload(async function * (/** @type {...any} */ ...args) {\n      for await (const file of methods.ls(...args)) {\n        yield { ...file, size: file.size || 0 }\n      }\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}