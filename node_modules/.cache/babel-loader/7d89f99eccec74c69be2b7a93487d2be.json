{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar AccessController = require('./access-controller-interface');\n\nvar AccessControllerManifest = require('./access-controller-manifest');\n\nvar LegacyIPFSAccessController = require('./legacy-ipfs-access-controller');\n\nvar IPFSAccessController = require('./ipfs-access-controller');\n\nvar OrbitDBAccessController = require('./orbitdb-access-controller');\n\nvar supportedTypes = {\n  'legacy-ipfs': LegacyIPFSAccessController,\n  ipfs: IPFSAccessController,\n  orbitdb: OrbitDBAccessController\n};\n\nvar getHandlerFor = function getHandlerFor(type) {\n  if (!AccessControllers.isSupported(type)) {\n    throw new Error(\"AccessController type '\".concat(type, \"' is not supported\"));\n  }\n\n  return supportedTypes[type];\n};\n\nvar AccessControllers = /*#__PURE__*/function () {\n  function AccessControllers() {\n    _classCallCheck(this, AccessControllers);\n  }\n\n  _createClass(AccessControllers, null, [{\n    key: \"AccessController\",\n    get: function get() {\n      return AccessController;\n    }\n  }, {\n    key: \"isSupported\",\n    value: function isSupported(type) {\n      return Object.keys(supportedTypes).includes(type);\n    }\n  }, {\n    key: \"addAccessController\",\n    value: function addAccessController(options) {\n      if (!options.AccessController) {\n        throw new Error('AccessController class needs to be given as an option');\n      }\n\n      if (!options.AccessController.type || typeof options.AccessController.type !== 'string') {\n        throw new Error('Given AccessController class needs to implement: static get type() { /* return a string */}.');\n      }\n\n      supportedTypes[options.AccessController.type] = options.AccessController;\n    }\n  }, {\n    key: \"addAccessControllers\",\n    value: function addAccessControllers(options) {\n      var accessControllers = options.AccessControllers;\n\n      if (!accessControllers) {\n        throw new Error('AccessController classes need to be given as an option');\n      }\n\n      accessControllers.forEach(function (accessController) {\n        AccessControllers.addAccessController({\n          AccessController: accessController\n        });\n      });\n    }\n  }, {\n    key: \"removeAccessController\",\n    value: function removeAccessController(type) {\n      delete supportedTypes[type];\n    }\n  }, {\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(orbitdb, manifestAddress) {\n        var options,\n            _yield$AccessControll,\n            type,\n            params,\n            AccessController,\n            accessController,\n            _args = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n                _context.next = 3;\n                return AccessControllerManifest.resolve(orbitdb._ipfs, manifestAddress, options);\n\n              case 3:\n                _yield$AccessControll = _context.sent;\n                type = _yield$AccessControll.type;\n                params = _yield$AccessControll.params;\n                AccessController = getHandlerFor(type);\n                _context.next = 9;\n                return AccessController.create(orbitdb, Object.assign({}, options, params));\n\n              case 9:\n                accessController = _context.sent;\n                _context.next = 12;\n                return accessController.load(params.address);\n\n              case 12:\n                return _context.abrupt(\"return\", accessController);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function resolve(_x, _x2) {\n        return _resolve.apply(this, arguments);\n      }\n\n      return resolve;\n    }()\n  }, {\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(orbitdb, type) {\n        var options,\n            AccessController,\n            ac,\n            params,\n            hash,\n            _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n                AccessController = getHandlerFor(type);\n                _context2.next = 4;\n                return AccessController.create(orbitdb, options);\n\n              case 4:\n                ac = _context2.sent;\n                _context2.next = 7;\n                return ac.save();\n\n              case 7:\n                params = _context2.sent;\n                _context2.next = 10;\n                return AccessControllerManifest.create(orbitdb._ipfs, type, params);\n\n              case 10:\n                hash = _context2.sent;\n                return _context2.abrupt(\"return\", hash);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function create(_x3, _x4) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }]);\n\n  return AccessControllers;\n}();\n\nmodule.exports = AccessControllers;","map":{"version":3,"names":["AccessController","require","AccessControllerManifest","LegacyIPFSAccessController","IPFSAccessController","OrbitDBAccessController","supportedTypes","ipfs","orbitdb","getHandlerFor","type","AccessControllers","isSupported","Error","Object","keys","includes","options","accessControllers","forEach","accessController","addAccessController","manifestAddress","resolve","_ipfs","params","create","assign","load","address","ac","save","hash","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-access-controllers/src/access-controllers.js"],"sourcesContent":["'use strict'\n\nconst AccessController = require('./access-controller-interface')\nconst AccessControllerManifest = require('./access-controller-manifest')\nconst LegacyIPFSAccessController = require('./legacy-ipfs-access-controller')\nconst IPFSAccessController = require('./ipfs-access-controller')\nconst OrbitDBAccessController = require('./orbitdb-access-controller')\n\nconst supportedTypes = {\n  'legacy-ipfs': LegacyIPFSAccessController,\n  ipfs: IPFSAccessController,\n  orbitdb: OrbitDBAccessController\n}\n\nconst getHandlerFor = (type) => {\n  if (!AccessControllers.isSupported(type)) {\n    throw new Error(`AccessController type '${type}' is not supported`)\n  }\n  return supportedTypes[type]\n}\n\nclass AccessControllers {\n  static get AccessController () { return AccessController }\n\n  static isSupported (type) {\n    return Object.keys(supportedTypes).includes(type)\n  }\n\n  static addAccessController (options) {\n    if (!options.AccessController) {\n      throw new Error('AccessController class needs to be given as an option')\n    }\n\n    if (!options.AccessController.type ||\n      typeof options.AccessController.type !== 'string') {\n      throw new Error('Given AccessController class needs to implement: static get type() { /* return a string */}.')\n    }\n\n    supportedTypes[options.AccessController.type] = options.AccessController\n  }\n\n  static addAccessControllers (options) {\n    const accessControllers = options.AccessControllers\n    if (!accessControllers) {\n      throw new Error('AccessController classes need to be given as an option')\n    }\n\n    accessControllers.forEach((accessController) => {\n      AccessControllers.addAccessController({ AccessController: accessController })\n    })\n  }\n\n  static removeAccessController (type) {\n    delete supportedTypes[type]\n  }\n\n  static async resolve (orbitdb, manifestAddress, options = {}) {\n    const { type, params } = await AccessControllerManifest.resolve(orbitdb._ipfs, manifestAddress, options)\n    const AccessController = getHandlerFor(type)\n    const accessController = await AccessController.create(orbitdb, Object.assign({}, options, params))\n    await accessController.load(params.address)\n    return accessController\n  }\n\n  static async create (orbitdb, type, options = {}) {\n    const AccessController = getHandlerFor(type)\n    const ac = await AccessController.create(orbitdb, options)\n    const params = await ac.save()\n    const hash = await AccessControllerManifest.create(orbitdb._ipfs, type, params)\n    return hash\n  }\n}\n\nmodule.exports = AccessControllers\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}