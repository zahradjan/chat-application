{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst removeLink = require('./utils/remove-link');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst toTrail = require('./utils/to-trail');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} recursive\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nconst defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  shardSplitThreshold: 1000\n};\n/**\n * @param {MfsContext} context\n */\n\nmodule.exports = context => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"rm\"]}\n   */\n  async function mfsRm(paths) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /** @type {DefaultOptions} */\n    const options = mergeOptions(defaultOptions, opts);\n\n    if (!Array.isArray(paths)) {\n      paths = [paths];\n    }\n\n    const sources = await Promise.all(paths.map(path => toMfsPath(context, path, options)));\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS');\n    }\n\n    sources.forEach(source => {\n      if (source.path === '/') {\n        throw errCode(new Error('Cannot delete root'), 'ERR_INVALID_PARAMS');\n      }\n    });\n\n    for (const source of sources) {\n      await removePath(context, source.path, options);\n    }\n  }\n\n  return withTimeoutOption(mfsRm);\n};\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {DefaultOptions} options\n */\n\n\nconst removePath = async (context, path, options) => {\n  const mfsPath = await toMfsPath(context, path, options);\n  const trail = await toTrail(context, mfsPath.mfsPath);\n  const child = trail[trail.length - 1];\n  trail.pop();\n  const parent = trail[trail.length - 1];\n\n  if (!parent) {\n    throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND');\n  }\n\n  if (child.type === 'directory' && !options.recursive) {\n    throw errCode(new Error(`${path} is a directory, use -r to remove directories`), 'ERR_WAS_DIR');\n  }\n\n  const {\n    cid\n  } = await removeLink(context, {\n    parentCid: parent.cid,\n    name: child.name,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  });\n  parent.cid = cid; // update the tree with the new child\n\n  const newRootCid = await updateTree(context, trail, options); // Update the MFS record with the new CID for the root of the tree\n\n  await updateMfsRoot(context, newRootCid, options);\n};","map":{"version":3,"names":["errCode","require","updateTree","updateMfsRoot","removeLink","toMfsPath","toTrail","withTimeoutOption","mergeOptions","bind","ignoreUndefined","defaultOptions","recursive","cidVersion","hashAlg","flush","shardSplitThreshold","module","exports","context","mfsRm","paths","opts","options","Array","isArray","sources","Promise","all","map","path","length","Error","forEach","source","removePath","mfsPath","trail","child","pop","parent","type","cid","parentCid","name","newRootCid"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/rm.js"],"sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst removeLink = require('./utils/remove-link')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst toTrail = require('./utils/to-trail')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} recursive\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  shardSplitThreshold: 1000\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"rm\"]}\n   */\n  async function mfsRm (paths, opts = {}) {\n    /** @type {DefaultOptions} */\n    const options = mergeOptions(defaultOptions, opts)\n\n    if (!Array.isArray(paths)) {\n      paths = [paths]\n    }\n\n    const sources = await Promise.all(\n      paths.map(path => toMfsPath(context, path, options))\n    )\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS')\n    }\n\n    sources.forEach(source => {\n      if (source.path === '/') {\n        throw errCode(new Error('Cannot delete root'), 'ERR_INVALID_PARAMS')\n      }\n    })\n\n    for (const source of sources) {\n      await removePath(context, source.path, options)\n    }\n  }\n\n  return withTimeoutOption(mfsRm)\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {DefaultOptions} options\n */\nconst removePath = async (context, path, options) => {\n  const mfsPath = await toMfsPath(context, path, options)\n  const trail = await toTrail(context, mfsPath.mfsPath)\n  const child = trail[trail.length - 1]\n  trail.pop()\n  const parent = trail[trail.length - 1]\n\n  if (!parent) {\n    throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND')\n  }\n\n  if (child.type === 'directory' && !options.recursive) {\n    throw errCode(new Error(`${path} is a directory, use -r to remove directories`), 'ERR_WAS_DIR')\n  }\n\n  const {\n    cid\n  } = await removeLink(context, {\n    parentCid: parent.cid,\n    name: child.name,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  })\n\n  parent.cid = cid\n\n  // update the tree with the new child\n  const newRootCid = await updateTree(context, trail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}