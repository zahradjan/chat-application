{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _toArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toArray.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar debug = require('debug');\n\nvar errcode = require('err-code');\n\nvar mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nvar _require = require('multiformats/cid'),\n    CID = _require.CID;\n\nvar PeerId = require('peer-id'); // @ts-ignore no types\n\n\nvar isDomain = require('is-domain-name');\n\nvar _require2 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require2.toString;\n\nvar log = Object.assign(debug('ipfs:name:resolve'), {\n  error: debug('ipfs:name:resolve:error')\n});\n\nvar _require3 = require('../../utils'),\n    OFFLINE_ERROR = _require3.OFFLINE_ERROR;\n\nvar withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\n\n\nvar appendRemainder = function appendRemainder(result, remainder) {\n  return remainder.length > 0 ? result + '/' + remainder.join('/') : result;\n};\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('ipfs-core-types/src/root').API[\"dns\"]} config.dns\n * @param {import('../ipns')} config.ipns\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('../../types').Options} config.options\n */\n\n\nmodule.exports = function (_ref) {\n  var dns = _ref.dns,\n      ipns = _ref.ipns,\n      peerId = _ref.peerId,\n      isOnline = _ref.isOnline,\n      offline = _ref.options.offline;\n\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"resolve\"]}\n   */\n  function resolve(_x) {\n    return _resolve.apply(this, arguments);\n  }\n\n  function _resolve() {\n    _resolve = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(name) {\n      var options,\n          _name$slice$split,\n          _name$slice$split2,\n          namespace,\n          hash,\n          remainder,\n          value,\n          _args = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n              // eslint-disable-line require-await\n              options = mergeOptions({\n                nocache: false,\n                recursive: true\n              }, options); // TODO: params related logic should be in the core implementation\n\n              if (!(offline && options && options.nocache)) {\n                _context.next = 4;\n                break;\n              }\n\n              throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');\n\n            case 4:\n              // Set node id as name for being resolved, if it is not received\n              if (!name) {\n                name = peerId.toB58String();\n              }\n\n              if (!name.startsWith('/ipns/')) {\n                name = \"/ipns/\".concat(name);\n              }\n\n              _name$slice$split = name.slice(1).split('/'), _name$slice$split2 = _toArray(_name$slice$split), namespace = _name$slice$split2[0], hash = _name$slice$split2[1], remainder = _name$slice$split2.slice(2);\n              _context.prev = 7;\n\n              if (hash.substring(0, 1) === '1') {\n                PeerId.parse(hash);\n              } else {\n                CID.parse(hash);\n              }\n\n              _context.next = 24;\n              break;\n\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context[\"catch\"](7);\n\n              if (!isDomain(hash)) {\n                _context.next = 22;\n                break;\n              }\n\n              _context.t1 = appendRemainder;\n              _context.next = 17;\n              return _awaitAsyncGenerator(dns(hash, options));\n\n            case 17:\n              _context.t2 = _context.sent;\n              _context.t3 = remainder;\n              _context.next = 21;\n              return (0, _context.t1)(_context.t2, _context.t3);\n\n            case 21:\n              return _context.abrupt(\"return\");\n\n            case 22:\n              log.error(_context.t0);\n              throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');\n\n            case 24:\n              if (!(!isOnline() && !offline)) {\n                _context.next = 26;\n                break;\n              }\n\n              throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n\n            case 26:\n              _context.next = 28;\n              return _awaitAsyncGenerator(ipns.resolve(\"/\".concat(namespace, \"/\").concat(hash), options));\n\n            case 28:\n              value = _context.sent;\n              _context.next = 31;\n              return appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder);\n\n            case 31:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[7, 11]]);\n    }));\n    return _resolve.apply(this, arguments);\n  }\n\n  return withTimeoutOption(resolve);\n};","map":{"version":3,"names":["debug","require","errcode","mergeOptions","bind","ignoreUndefined","CID","PeerId","isDomain","uint8ArrayToString","toString","log","Object","assign","error","OFFLINE_ERROR","withTimeoutOption","appendRemainder","result","remainder","length","join","module","exports","dns","ipns","peerId","isOnline","offline","options","resolve","name","nocache","recursive","Error","toB58String","startsWith","slice","split","namespace","hash","substring","parse","value","Uint8Array"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/name/resolve.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst errcode = require('err-code')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst { CID } = require('multiformats/cid')\nconst PeerId = require('peer-id')\n// @ts-ignore no types\nconst isDomain = require('is-domain-name')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst log = Object.assign(debug('ipfs:name:resolve'), {\n  error: debug('ipfs:name:resolve:error')\n})\n\nconst { OFFLINE_ERROR } = require('../../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\nconst appendRemainder = (result, remainder) =>\n  remainder.length > 0\n    ? result + '/' + remainder.join('/')\n    : result\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('ipfs-core-types/src/root').API[\"dns\"]} config.dns\n * @param {import('../ipns')} config.ipns\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('../../types').Options} config.options\n */\nmodule.exports = ({ dns, ipns, peerId, isOnline, options: { offline } }) => {\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"resolve\"]}\n   */\n  async function * resolve (name, options = {}) { // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options)\n\n    // TODO: params related logic should be in the core implementation\n    if (offline && options && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE')\n    }\n\n    // Set node id as name for being resolved, if it is not received\n    if (!name) {\n      name = peerId.toB58String()\n    }\n\n    if (!name.startsWith('/ipns/')) {\n      name = `/ipns/${name}`\n    }\n\n    const [namespace, hash, ...remainder] = name.slice(1).split('/')\n    try {\n      if (hash.substring(0, 1) === '1') {\n        PeerId.parse(hash)\n      } else {\n        CID.parse(hash)\n      }\n    } catch (err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder(await dns(hash, options), remainder)\n        return\n      }\n\n      log.error(err)\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME')\n    }\n\n    // multihash is valid lets resolve with IPNS\n    // IPNS resolve needs a online daemon\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    // TODO: convert ipns.resolve to return an iterator\n    const value = await ipns.resolve(`/${namespace}/${hash}`, options)\n    yield appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder)\n  }\n\n  return withTimeoutOption(resolve)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}