{"ast":null,"code":"'use strict'; // @ts-ignore - TODO vmx 2021-03-31\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar dagPb = require('@ipld/dag-pb');\n\nvar _require = require('multiformats/cid'),\n    CID = _require.CID;\n\nvar log = require('debug')('ipfs:mfs:core:utils:remove-link');\n\nvar _require2 = require('ipfs-unixfs'),\n    UnixFS = _require2.UnixFS;\n\nvar _require3 = require('./hamt-utils'),\n    generatePath = _require3.generatePath,\n    updateHamtDirectory = _require3.updateHamtDirectory;\n\nvar errCode = require('err-code');\n/**\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} RemoveLinkOptions\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {CID} [parentCid]\n * @property {PBNode} [parent]\n *\n * @typedef {object} RemoveLinkOptionsInternal\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {PBNode} parent\n */\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptions} options\n */\n\n\nvar removeLink = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(context, options) {\n    var parent, parentCid, block, meta;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            parent = options.parent;\n\n            if (!options.parentCid) {\n              _context.next = 10;\n              break;\n            }\n\n            parentCid = CID.asCID(options.parentCid);\n\n            if (!(parentCid === null)) {\n              _context.next = 5;\n              break;\n            }\n\n            throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n\n          case 5:\n            log(\"Loading parent node \".concat(parentCid));\n            _context.next = 8;\n            return context.repo.blocks.get(parentCid);\n\n          case 8:\n            block = _context.sent;\n            parent = dagPb.decode(block);\n\n          case 10:\n            if (parent) {\n              _context.next = 12;\n              break;\n            }\n\n            throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n\n          case 12:\n            if (options.name) {\n              _context.next = 14;\n              break;\n            }\n\n            throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n\n          case 14:\n            if (parent.Data) {\n              _context.next = 16;\n              break;\n            }\n\n            throw errCode(new Error('Parent node had no data'), 'ERR_INVALID_NODE');\n\n          case 16:\n            meta = UnixFS.unmarshal(parent.Data);\n\n            if (!(meta.type === 'hamt-sharded-directory')) {\n              _context.next = 20;\n              break;\n            }\n\n            log(\"Removing \".concat(options.name, \" from sharded directory\"));\n            return _context.abrupt(\"return\", removeFromShardedDirectory(context, _objectSpread(_objectSpread({}, options), {}, {\n              parent: parent\n            })));\n\n          case 20:\n            log(\"Removing link \".concat(options.name, \" regular directory\"));\n            return _context.abrupt(\"return\", removeFromDirectory(context, _objectSpread(_objectSpread({}, options), {}, {\n              parent: parent\n            })));\n\n          case 22:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function removeLink(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nvar removeFromDirectory = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(context, options) {\n    var parentBlock, hasher, hash, parentCid;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            // Remove existing link if it exists\n            options.parent.Links = options.parent.Links.filter(function (link) {\n              return link.Name !== options.name;\n            });\n            _context2.next = 3;\n            return dagPb.encode(options.parent);\n\n          case 3:\n            parentBlock = _context2.sent;\n            _context2.next = 6;\n            return context.hashers.getHasher(options.hashAlg);\n\n          case 6:\n            hasher = _context2.sent;\n            _context2.next = 9;\n            return hasher.digest(parentBlock);\n\n          case 9:\n            hash = _context2.sent;\n            parentCid = CID.create(options.cidVersion, dagPb.code, hash);\n            _context2.next = 13;\n            return context.repo.blocks.put(parentCid, parentBlock);\n\n          case 13:\n            log(\"Updated regular directory \".concat(parentCid));\n            return _context2.abrupt(\"return\", {\n              node: options.parent,\n              cid: parentCid\n            });\n\n          case 15:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function removeFromDirectory(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nvar removeFromShardedDirectory = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(context, options) {\n    var _yield$generatePath, rootBucket, path, _yield$updateShard, node;\n\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return generatePath(context, options.name, options.parent);\n\n          case 2:\n            _yield$generatePath = _context3.sent;\n            rootBucket = _yield$generatePath.rootBucket;\n            path = _yield$generatePath.path;\n            _context3.next = 7;\n            return rootBucket.del(options.name);\n\n          case 7:\n            _context3.next = 9;\n            return updateShard(context, path, options.name, options);\n\n          case 9:\n            _yield$updateShard = _context3.sent;\n            node = _yield$updateShard.node;\n            return _context3.abrupt(\"return\", updateHamtDirectory(context, node.Links, rootBucket, options));\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function removeFromShardedDirectory(_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {{ bucket: Bucket, prefix: string, node?: PBNode }[]} positions\n * @param {string} name\n * @param {RemoveLinkOptionsInternal} options\n * @returns {Promise<{ node: PBNode, cid: CID, size: number }>}\n */\n\n\nvar updateShard = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(context, positions, name, options) {\n    var last, bucket, prefix, node, link, links, result, cid, size, newName, _link;\n\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            last = positions.pop();\n\n            if (last) {\n              _context4.next = 3;\n              break;\n            }\n\n            throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n\n          case 3:\n            bucket = last.bucket, prefix = last.prefix, node = last.node;\n\n            if (node) {\n              _context4.next = 6;\n              break;\n            }\n\n            throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n\n          case 6:\n            link = node.Links.find(function (link) {\n              return (link.Name || '').substring(0, 2) === prefix;\n            });\n\n            if (link) {\n              _context4.next = 9;\n              break;\n            }\n\n            throw errCode(new Error(\"No link found with prefix \".concat(prefix, \" for file \").concat(name)), 'ERR_NOT_FOUND');\n\n          case 9:\n            if (!(link.Name === \"\".concat(prefix).concat(name))) {\n              _context4.next = 15;\n              break;\n            }\n\n            log(\"Removing existing link \".concat(link.Name));\n            links = node.Links.filter(function (nodeLink) {\n              return nodeLink.Name !== link.Name;\n            });\n            _context4.next = 14;\n            return bucket.del(name);\n\n          case 14:\n            return _context4.abrupt(\"return\", updateHamtDirectory(context, links, bucket, options));\n\n          case 15:\n            log(\"Descending into sub-shard \".concat(link.Name, \" for \").concat(prefix).concat(name));\n            _context4.next = 18;\n            return updateShard(context, positions, name, options);\n\n          case 18:\n            result = _context4.sent;\n            cid = result.cid;\n            size = result.size;\n            newName = prefix;\n\n            if (result.node.Links.length === 1) {\n              log(\"Removing subshard for \".concat(prefix)); // convert shard back to normal dir\n\n              _link = result.node.Links[0];\n              newName = \"\".concat(prefix).concat((_link.Name || '').substring(2));\n              cid = _link.Hash;\n              size = _link.Tsize || 0;\n            }\n\n            log(\"Updating shard \".concat(prefix, \" with name \").concat(newName));\n            return _context4.abrupt(\"return\", updateShardParent(context, bucket, node, prefix, newName, size, cid, options));\n\n          case 25:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function updateShard(_x7, _x8, _x9, _x10) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {Bucket} bucket\n * @param {PBNode} parent\n * @param {string} oldName\n * @param {string} newName\n * @param {number} size\n * @param {CID} cid\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nvar updateShardParent = function updateShardParent(context, bucket, parent, oldName, newName, size, cid, options) {\n  // Remove existing link if it exists\n  var parentLinks = parent.Links.filter(function (link) {\n    return link.Name !== oldName;\n  });\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  });\n  return updateHamtDirectory(context, parentLinks, bucket, options);\n};\n\nmodule.exports = removeLink;","map":{"version":3,"names":["dagPb","require","CID","log","UnixFS","generatePath","updateHamtDirectory","errCode","removeLink","context","options","parent","parentCid","asCID","Error","repo","blocks","get","block","decode","name","Data","meta","unmarshal","type","removeFromShardedDirectory","removeFromDirectory","Links","filter","link","Name","encode","parentBlock","hashers","getHasher","hashAlg","hasher","digest","hash","create","cidVersion","code","put","node","cid","rootBucket","path","del","updateShard","positions","last","pop","bucket","prefix","find","substring","links","nodeLink","result","size","newName","length","Hash","Tsize","updateShardParent","oldName","parentLinks","push","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/utils/remove-link.js"],"sourcesContent":["'use strict'\n\n// @ts-ignore - TODO vmx 2021-03-31\nconst dagPb = require('@ipld/dag-pb')\nconst { CID } = require('multiformats/cid')\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link')\nconst { UnixFS } = require('ipfs-unixfs')\nconst {\n  generatePath,\n  updateHamtDirectory\n} = require('./hamt-utils')\nconst errCode = require('err-code')\n\n/**\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} RemoveLinkOptions\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {CID} [parentCid]\n * @property {PBNode} [parent]\n *\n * @typedef {object} RemoveLinkOptionsInternal\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {PBNode} parent\n */\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptions} options\n */\nconst removeLink = async (context, options) => {\n  let parent = options.parent\n\n  if (options.parentCid) {\n    const parentCid = CID.asCID(options.parentCid)\n    if (parentCid === null) {\n      throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID')\n    }\n\n    log(`Loading parent node ${parentCid}`)\n    const block = await context.repo.blocks.get(parentCid)\n    parent = dagPb.decode(block)\n  }\n\n  if (!parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT')\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME')\n  }\n\n  if (!parent.Data) {\n    throw errCode(new Error('Parent node had no data'), 'ERR_INVALID_NODE')\n  }\n\n  const meta = UnixFS.unmarshal(parent.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`)\n\n    return removeFromShardedDirectory(context, {\n      ...options,\n      parent\n    })\n  }\n\n  log(`Removing link ${options.name} regular directory`)\n\n  return removeFromDirectory(context, {\n    ...options,\n    parent\n  })\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromDirectory = async (context, options) => {\n  // Remove existing link if it exists\n  options.parent.Links = options.parent.Links.filter((link) => {\n    return link.Name !== options.name\n  })\n\n  const parentBlock = await dagPb.encode(options.parent)\n  const hasher = await context.hashers.getHasher(options.hashAlg)\n  const hash = await hasher.digest(parentBlock)\n  const parentCid = CID.create(options.cidVersion, dagPb.code, hash)\n\n  await context.repo.blocks.put(parentCid, parentBlock)\n\n  log(`Updated regular directory ${parentCid}`)\n\n  return {\n    node: options.parent,\n    cid: parentCid\n  }\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket, path\n  } = await generatePath(context, options.name, options.parent)\n\n  await rootBucket.del(options.name)\n\n  const {\n    node\n  } = await updateShard(context, path, options.name, options)\n\n  return updateHamtDirectory(context, node.Links, rootBucket, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {{ bucket: Bucket, prefix: string, node?: PBNode }[]} positions\n * @param {string} name\n * @param {RemoveLinkOptionsInternal} options\n * @returns {Promise<{ node: PBNode, cid: CID, size: number }>}\n */\nconst updateShard = async (context, positions, name, options) => {\n  const last = positions.pop()\n\n  if (!last) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT')\n  }\n\n  const {\n    bucket,\n    prefix,\n    node\n  } = last\n\n  if (!node) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT')\n  }\n\n  const link = node.Links\n    .find(link => (link.Name || '').substring(0, 2) === prefix)\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${name}`), 'ERR_NOT_FOUND')\n  }\n\n  if (link.Name === `${prefix}${name}`) {\n    log(`Removing existing link ${link.Name}`)\n\n    const links = node.Links.filter((nodeLink) => {\n      return nodeLink.Name !== link.Name\n    })\n\n    await bucket.del(name)\n\n    return updateHamtDirectory(context, links, bucket, options)\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${name}`)\n\n  const result = await updateShard(context, positions, name, options)\n\n  let cid = result.cid\n  let size = result.size\n  let newName = prefix\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`)\n\n    // convert shard back to normal dir\n    const link = result.node.Links[0]\n\n    newName = `${prefix}${(link.Name || '').substring(2)}`\n    cid = link.Hash\n    size = link.Tsize || 0\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`)\n\n  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {Bucket} bucket\n * @param {PBNode} parent\n * @param {string} oldName\n * @param {string} newName\n * @param {number} size\n * @param {CID} cid\n * @param {RemoveLinkOptionsInternal} options\n */\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  // Remove existing link if it exists\n  const parentLinks = parent.Links.filter((link) => {\n    return link.Name !== oldName\n  })\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  })\n\n  return updateHamtDirectory(context, parentLinks, bucket, options)\n}\n\nmodule.exports = removeLink\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}