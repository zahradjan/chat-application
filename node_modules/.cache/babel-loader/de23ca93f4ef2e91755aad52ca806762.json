{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PeerScore = void 0;\n\nvar peer_score_params_1 = require(\"./peer-score-params\");\n\nvar peer_stats_1 = require(\"./peer-stats\");\n\nvar compute_score_1 = require(\"./compute-score\");\n\nvar message_deliveries_1 = require(\"./message-deliveries\");\n\nvar constants_1 = require(\"../constants\");\n\nvar peer_id_1 = __importDefault(require(\"peer-id\"));\n\nvar debug = require(\"debug\");\n\nvar pubsubErrors = require(\"libp2p-interfaces/src/pubsub/errors\");\n\nvar _pubsubErrors$codes = pubsubErrors.codes,\n    ERR_INVALID_SIGNATURE = _pubsubErrors$codes.ERR_INVALID_SIGNATURE,\n    ERR_MISSING_SIGNATURE = _pubsubErrors$codes.ERR_MISSING_SIGNATURE;\nvar log = debug('libp2p:gossipsub:score');\n\nvar PeerScore = /*#__PURE__*/function () {\n  function PeerScore(params, connectionManager, msgId) {\n    _classCallCheck(this, PeerScore);\n\n    peer_score_params_1.validatePeerScoreParams(params);\n    this.params = params;\n    this._connectionManager = connectionManager;\n    this.peerStats = new Map();\n    this.peerIPs = new Map();\n    this.deliveryRecords = new message_deliveries_1.MessageDeliveries();\n    this.msgId = msgId;\n  }\n  /**\n   * Start PeerScore instance\n   * @returns {void}\n   */\n\n\n  _createClass(PeerScore, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      if (this._backgroundInterval) {\n        log('Peer score already running');\n        return;\n      }\n\n      this._backgroundInterval = setInterval(function () {\n        return _this.background();\n      }, this.params.decayInterval);\n      log('started');\n    }\n    /**\n     * Stop PeerScore instance\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this._backgroundInterval) {\n        log('Peer score already stopped');\n        return;\n      }\n\n      clearInterval(this._backgroundInterval);\n      delete this._backgroundInterval;\n      this.peerIPs.clear();\n      this.peerStats.clear();\n      this.deliveryRecords.clear();\n      log('stopped');\n    }\n    /**\n     * Periodic maintenance\n     * @returns {void}\n     */\n\n  }, {\n    key: \"background\",\n    value: function background() {\n      this._refreshScores();\n\n      this._updateIPs();\n\n      this.deliveryRecords.gc();\n    }\n    /**\n     * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_refreshScores\",\n    value: function _refreshScores() {\n      var _this2 = this;\n\n      var now = Date.now();\n      var decayToZero = this.params.decayToZero;\n      this.peerStats.forEach(function (pstats, id) {\n        if (!pstats.connected) {\n          // has the retention perious expired?\n          if (now > pstats.expire) {\n            // yes, throw it away (but clean up the IP tracking first)\n            _this2._removeIPs(id, pstats.ips);\n\n            _this2.peerStats.delete(id);\n          } // we don't decay retained scores, as the peer is not active.\n          // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n          // unless the retention period has ellapsed.\n          // similarly, a well behaved peer does not lose its score by getting disconnected.\n\n\n          return;\n        }\n\n        Object.entries(pstats.topics).forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              topic = _ref2[0],\n              tstats = _ref2[1];\n\n          var tparams = _this2.params.topics[topic];\n\n          if (!tparams) {\n            // we are not scoring this topic\n            // should be unreachable, we only add scored topics to pstats\n            return;\n          } // decay counters\n\n\n          tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;\n\n          if (tstats.firstMessageDeliveries < decayToZero) {\n            tstats.firstMessageDeliveries = 0;\n          }\n\n          tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;\n\n          if (tstats.meshMessageDeliveries < decayToZero) {\n            tstats.meshMessageDeliveries = 0;\n          }\n\n          tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;\n\n          if (tstats.meshFailurePenalty < decayToZero) {\n            tstats.meshFailurePenalty = 0;\n          }\n\n          tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;\n\n          if (tstats.invalidMessageDeliveries < decayToZero) {\n            tstats.invalidMessageDeliveries = 0;\n          } // update mesh time and activate mesh message delivery parameter if need be\n\n\n          if (tstats.inMesh) {\n            tstats.meshTime = now - tstats.graftTime;\n\n            if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n              tstats.meshMessageDeliveriesActive = true;\n            }\n          }\n        }); // decay P7 counter\n\n        pstats.behaviourPenalty *= _this2.params.behaviourPenaltyDecay;\n\n        if (pstats.behaviourPenalty < decayToZero) {\n          pstats.behaviourPenalty = 0;\n        }\n      });\n    }\n    /**\n     * Return the score for a peer\n     * @param {string} id\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"score\",\n    value: function score(id) {\n      var pstats = this.peerStats.get(id);\n\n      if (!pstats) {\n        return 0;\n      }\n\n      return compute_score_1.computeScore(id, pstats, this.params, this.peerIPs);\n    }\n    /**\n     * Apply a behavioural penalty to a peer\n     * @param {string} id\n     * @param {Number} penalty\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addPenalty\",\n    value: function addPenalty(id, penalty) {\n      var pstats = this.peerStats.get(id);\n\n      if (!pstats) {\n        return;\n      }\n\n      pstats.behaviourPenalty += penalty;\n    }\n    /**\n     * @param {string} id\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addPeer\",\n    value: function addPeer(id) {\n      // create peer stats (not including topic stats for each topic to be scored)\n      // topic stats will be added as needed\n      var pstats = peer_stats_1.createPeerStats({\n        connected: true\n      });\n      this.peerStats.set(id, pstats); // get + update peer IPs\n\n      var ips = this._getIPs(id);\n\n      this._setIPs(id, ips, pstats.ips);\n\n      pstats.ips = ips;\n    }\n    /**\n     * @param {string} id\n     * @returns {void}\n     */\n\n  }, {\n    key: \"removePeer\",\n    value: function removePeer(id) {\n      var _this3 = this;\n\n      var pstats = this.peerStats.get(id);\n\n      if (!pstats) {\n        return;\n      } // decide whether to retain the score; this currently only retains non-positive scores\n      // to dissuade attacks on the score function.\n\n\n      if (this.score(id) > 0) {\n        this._removeIPs(id, pstats.ips);\n\n        this.peerStats.delete(id);\n        return;\n      } // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n      // reset to 0 and mesh delivery penalties applied.\n\n\n      Object.entries(pstats.topics).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            topic = _ref4[0],\n            tstats = _ref4[1];\n\n        tstats.firstMessageDeliveries = 0;\n        var threshold = _this3.params.topics[topic].meshMessageDeliveriesThreshold;\n\n        if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n          var deficit = threshold - tstats.meshMessageDeliveries;\n          tstats.meshFailurePenalty += deficit * deficit;\n        }\n\n        tstats.inMesh = false;\n        tstats.meshMessageDeliveriesActive = false;\n      });\n      pstats.connected = false;\n      pstats.expire = Date.now() + this.params.retainScore;\n    }\n    /**\n     * @param {string} id\n     * @param {String} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"graft\",\n    value: function graft(id, topic) {\n      var pstats = this.peerStats.get(id);\n\n      if (!pstats) {\n        return;\n      }\n\n      var tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n      if (!tstats) {\n        return;\n      }\n\n      tstats.inMesh = true;\n      tstats.graftTime = Date.now();\n      tstats.meshTime = 0;\n      tstats.meshMessageDeliveriesActive = false;\n    }\n    /**\n     * @param {string} id\n     * @param {string} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"prune\",\n    value: function prune(id, topic) {\n      var pstats = this.peerStats.get(id);\n\n      if (!pstats) {\n        return;\n      }\n\n      var tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n      if (!tstats) {\n        return;\n      } // sticky mesh delivery rate failure penalty\n\n\n      var threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n\n      if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n        var deficit = threshold - tstats.meshMessageDeliveries;\n        tstats.meshFailurePenalty += deficit * deficit;\n      }\n\n      tstats.inMesh = false;\n      tstats.meshMessageDeliveriesActive = false;\n    }\n    /**\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"validateMessage\",\n    value: function validateMessage(message) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.t0 = this.deliveryRecords;\n                _context.next = 3;\n                return this.msgId(message);\n\n              case 3:\n                _context.t1 = _context.sent;\n\n                _context.t0.ensureRecord.call(_context.t0, _context.t1);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"deliverMessage\",\n    value: function deliverMessage(message) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this4 = this;\n\n        var id, drec, now;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                id = message.receivedFrom;\n\n                this._markFirstMessageDelivery(id, message);\n\n                _context2.t0 = this.deliveryRecords;\n                _context2.next = 5;\n                return this.msgId(message);\n\n              case 5:\n                _context2.t1 = _context2.sent;\n                drec = _context2.t0.ensureRecord.call(_context2.t0, _context2.t1);\n                now = Date.now(); // defensive check that this is the first delivery trace -- delivery status should be unknown\n\n                if (!(drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                log('unexpected delivery: message from %s was first seen %s ago and has delivery status %d', id, now - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n                return _context2.abrupt(\"return\");\n\n              case 11:\n                // mark the message as valid and reward mesh peers that have already forwarded it to us\n                drec.status = message_deliveries_1.DeliveryRecordStatus.valid;\n                drec.validated = now;\n                drec.peers.forEach(function (p) {\n                  // this check is to make sure a peer can't send us a message twice and get a double count\n                  // if it is a first delivery.\n                  if (p !== id) {\n                    _this4._markDuplicateMessageDelivery(p, message);\n                  }\n                });\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * @param {InMessage} message\n     * @param {string} reason\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"rejectMessage\",\n    value: function rejectMessage(message, reason) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _this5 = this;\n\n        var id, drec;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                id = message.receivedFrom;\n                _context3.t0 = reason;\n                _context3.next = _context3.t0 === ERR_MISSING_SIGNATURE ? 4 : _context3.t0 === ERR_INVALID_SIGNATURE ? 4 : 6;\n                break;\n\n              case 4:\n                this._markInvalidMessageDelivery(id, message);\n\n                return _context3.abrupt(\"return\");\n\n              case 6:\n                _context3.t1 = this.deliveryRecords;\n                _context3.next = 9;\n                return this.msgId(message);\n\n              case 9:\n                _context3.t2 = _context3.sent;\n                drec = _context3.t1.ensureRecord.call(_context3.t1, _context3.t2);\n\n                if (!(drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown)) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                log('unexpected rejection: message from %s was first seen %s ago and has delivery status %d', id, Date.now() - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n                return _context3.abrupt(\"return\");\n\n              case 14:\n                _context3.t3 = reason;\n                _context3.next = _context3.t3 === constants_1.ERR_TOPIC_VALIDATOR_IGNORE ? 17 : 19;\n                break;\n\n              case 17:\n                // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n                drec.status = message_deliveries_1.DeliveryRecordStatus.ignored;\n                return _context3.abrupt(\"return\");\n\n              case 19:\n                // mark the message as invalid and penalize peers that have already forwarded it.\n                drec.status = message_deliveries_1.DeliveryRecordStatus.invalid;\n\n                this._markInvalidMessageDelivery(id, message);\n\n                drec.peers.forEach(function (p) {\n                  _this5._markInvalidMessageDelivery(p, message);\n                });\n\n              case 22:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"duplicateMessage\",\n    value: function duplicateMessage(message) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var id, drec;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                id = message.receivedFrom;\n                _context4.t0 = this.deliveryRecords;\n                _context4.next = 4;\n                return this.msgId(message);\n\n              case 4:\n                _context4.t1 = _context4.sent;\n                drec = _context4.t0.ensureRecord.call(_context4.t0, _context4.t1);\n\n                if (!drec.peers.has(id)) {\n                  _context4.next = 8;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 8:\n                _context4.t2 = drec.status;\n                _context4.next = _context4.t2 === message_deliveries_1.DeliveryRecordStatus.unknown ? 11 : _context4.t2 === message_deliveries_1.DeliveryRecordStatus.valid ? 13 : _context4.t2 === message_deliveries_1.DeliveryRecordStatus.invalid ? 16 : 18;\n                break;\n\n              case 11:\n                // the message is being validated; track the peer delivery and wait for\n                // the Deliver/Reject/Ignore notification.\n                drec.peers.add(id);\n                return _context4.abrupt(\"break\", 18);\n\n              case 13:\n                // mark the peer delivery time to only count a duplicate delivery once.\n                drec.peers.add(id);\n\n                this._markDuplicateMessageDelivery(id, message, drec.validated);\n\n                return _context4.abrupt(\"break\", 18);\n\n              case 16:\n                // we no longer track delivery time\n                this._markInvalidMessageDelivery(id, message);\n\n                return _context4.abrupt(\"break\", 18);\n\n              case 18:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n     * @param {string} id\n     * @param {InMessage} message\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_markInvalidMessageDelivery\",\n    value: function _markInvalidMessageDelivery(id, message) {\n      var _this6 = this;\n\n      var pstats = this.peerStats.get(id);\n\n      if (!pstats) {\n        return;\n      }\n\n      message.topicIDs.forEach(function (topic) {\n        var tstats = peer_stats_1.ensureTopicStats(topic, pstats, _this6.params);\n\n        if (!tstats) {\n          return;\n        }\n\n        tstats.invalidMessageDeliveries += 1;\n      });\n    }\n    /**\n     * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n     * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n     * @param {string} id\n     * @param {InMessage} message\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_markFirstMessageDelivery\",\n    value: function _markFirstMessageDelivery(id, message) {\n      var _this7 = this;\n\n      var pstats = this.peerStats.get(id);\n\n      if (!pstats) {\n        return;\n      }\n\n      message.topicIDs.forEach(function (topic) {\n        var tstats = peer_stats_1.ensureTopicStats(topic, pstats, _this7.params);\n\n        if (!tstats) {\n          return;\n        }\n\n        var cap = _this7.params.topics[topic].firstMessageDeliveriesCap;\n        tstats.firstMessageDeliveries += 1;\n\n        if (tstats.firstMessageDeliveries > cap) {\n          tstats.firstMessageDeliveries = cap;\n        }\n\n        if (!tstats.inMesh) {\n          return;\n        }\n\n        cap = _this7.params.topics[topic].meshMessageDeliveriesCap;\n        tstats.meshMessageDeliveries += 1;\n\n        if (tstats.meshMessageDeliveries > cap) {\n          tstats.meshMessageDeliveries = cap;\n        }\n      });\n    }\n    /**\n     * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n     * as long the message was received within the P3 window.\n     * @param {string} id\n     * @param {InMessage} message\n     * @param {number} validatedTime\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_markDuplicateMessageDelivery\",\n    value: function _markDuplicateMessageDelivery(id, message) {\n      var _this8 = this;\n\n      var validatedTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var pstats = this.peerStats.get(id);\n\n      if (!pstats) {\n        return;\n      }\n\n      var now = validatedTime ? Date.now() : 0;\n      message.topicIDs.forEach(function (topic) {\n        var tstats = peer_stats_1.ensureTopicStats(topic, pstats, _this8.params);\n\n        if (!tstats) {\n          return;\n        }\n\n        if (!tstats.inMesh) {\n          return;\n        }\n\n        var tparams = _this8.params.topics[topic]; // check against the mesh delivery window -- if the validated time is passed as 0, then\n        // the message was received before we finished validation and thus falls within the mesh\n        // delivery window.\n\n        if (validatedTime && now > validatedTime + tparams.meshMessageDeliveriesWindow) {\n          return;\n        }\n\n        var cap = tparams.meshMessageDeliveriesCap;\n        tstats.meshMessageDeliveries += 1;\n\n        if (tstats.meshMessageDeliveries > cap) {\n          tstats.meshMessageDeliveries = cap;\n        }\n      });\n    }\n    /**\n     * Gets the current IPs for a peer.\n     * @param {string} id\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"_getIPs\",\n    value: function _getIPs(id) {\n      return this._connectionManager.getAll(peer_id_1.default.createFromB58String(id)).map(function (c) {\n        return c.remoteAddr.toOptions().host;\n      });\n    }\n    /**\n     * Adds tracking for the new IPs in the list, and removes tracking from the obsolete IPs.\n     * @param {string} id\n     * @param {Array<string>} newIPs\n     * @param {Array<string>} oldIPs\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_setIPs\",\n    value: function _setIPs(id, newIPs, oldIPs) {\n      // add the new IPs to the tracking\n      // eslint-disable-next-line no-labels\n      var _iterator = _createForOfIteratorHelper(newIPs),\n          _step;\n\n      try {\n        addNewIPs: for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ip = _step.value;\n\n          // check if it is in the old ips list\n          var _iterator3 = _createForOfIteratorHelper(oldIPs),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var xip = _step3.value;\n\n              if (ip === xip) {\n                // eslint-disable-next-line no-labels\n                continue addNewIPs;\n              }\n            } // no, it's a new one -- add it to the tracker\n\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n\n          var peers = this.peerIPs.get(ip);\n\n          if (!peers) {\n            peers = new Set();\n            this.peerIPs.set(ip, peers);\n          }\n\n          peers.add(id);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      } // remove the obsolete old IPs from the tracking\n      // eslint-disable-next-line no-labels\n\n\n      var _iterator2 = _createForOfIteratorHelper(oldIPs),\n          _step2;\n\n      try {\n        removeOldIPs: for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _ip = _step2.value;\n\n          // check if it is in the new ips list\n          var _iterator4 = _createForOfIteratorHelper(newIPs),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _xip = _step4.value;\n\n              if (_ip === _xip) {\n                // eslint-disable-next-line no-labels\n                continue removeOldIPs;\n              }\n            } // no, its obselete -- remove it from the tracker\n\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          var _peers = this.peerIPs.get(_ip);\n\n          if (!_peers) {\n            continue;\n          }\n\n          _peers.delete(id);\n\n          if (!_peers.size) {\n            this.peerIPs.delete(_ip);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * Removes an IP list from the tracking list for a peer.\n     * @param {string} id\n     * @param {Array<string>} ips\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_removeIPs\",\n    value: function _removeIPs(id, ips) {\n      var _this9 = this;\n\n      ips.forEach(function (ip) {\n        var peers = _this9.peerIPs.get(ip);\n\n        if (!peers) {\n          return;\n        }\n\n        peers.delete(id);\n\n        if (!peers.size) {\n          _this9.peerIPs.delete(ip);\n        }\n      });\n    }\n    /**\n     * Update all peer IPs to currently open connections\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_updateIPs\",\n    value: function _updateIPs() {\n      var _this10 = this;\n\n      this.peerStats.forEach(function (pstats, id) {\n        var newIPs = _this10._getIPs(id);\n\n        _this10._setIPs(id, newIPs, pstats.ips);\n\n        pstats.ips = newIPs;\n      });\n    }\n  }]);\n\n  return PeerScore;\n}();\n\nexports.PeerScore = PeerScore;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","PeerScore","peer_score_params_1","require","peer_stats_1","compute_score_1","message_deliveries_1","constants_1","peer_id_1","debug","pubsubErrors","codes","ERR_INVALID_SIGNATURE","ERR_MISSING_SIGNATURE","log","params","connectionManager","msgId","validatePeerScoreParams","_connectionManager","peerStats","Map","peerIPs","deliveryRecords","MessageDeliveries","_backgroundInterval","setInterval","background","decayInterval","clearInterval","clear","_refreshScores","_updateIPs","gc","now","Date","decayToZero","forEach","pstats","id","connected","expire","_removeIPs","ips","delete","entries","topics","topic","tstats","tparams","firstMessageDeliveries","firstMessageDeliveriesDecay","meshMessageDeliveries","meshMessageDeliveriesDecay","meshFailurePenalty","meshFailurePenaltyDecay","invalidMessageDeliveries","invalidMessageDeliveriesDecay","inMesh","meshTime","graftTime","meshMessageDeliveriesActivation","meshMessageDeliveriesActive","behaviourPenalty","behaviourPenaltyDecay","get","computeScore","penalty","createPeerStats","set","_getIPs","_setIPs","score","threshold","meshMessageDeliveriesThreshold","deficit","retainScore","ensureTopicStats","message","ensureRecord","receivedFrom","_markFirstMessageDelivery","drec","status","DeliveryRecordStatus","unknown","firstSeen","valid","validated","peers","p","_markDuplicateMessageDelivery","reason","_markInvalidMessageDelivery","ERR_TOPIC_VALIDATOR_IGNORE","ignored","invalid","has","add","topicIDs","cap","firstMessageDeliveriesCap","meshMessageDeliveriesCap","validatedTime","meshMessageDeliveriesWindow","getAll","default","createFromB58String","map","c","remoteAddr","toOptions","host","newIPs","oldIPs","addNewIPs","ip","xip","Set","removeOldIPs","size"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-gossipsub/src/score/peer-score.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PeerScore = void 0;\nconst peer_score_params_1 = require(\"./peer-score-params\");\nconst peer_stats_1 = require(\"./peer-stats\");\nconst compute_score_1 = require(\"./compute-score\");\nconst message_deliveries_1 = require(\"./message-deliveries\");\nconst constants_1 = require(\"../constants\");\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\nconst debug = require(\"debug\");\nconst pubsubErrors = require(\"libp2p-interfaces/src/pubsub/errors\");\nconst { ERR_INVALID_SIGNATURE, ERR_MISSING_SIGNATURE } = pubsubErrors.codes;\nconst log = debug('libp2p:gossipsub:score');\nclass PeerScore {\n    constructor(params, connectionManager, msgId) {\n        peer_score_params_1.validatePeerScoreParams(params);\n        this.params = params;\n        this._connectionManager = connectionManager;\n        this.peerStats = new Map();\n        this.peerIPs = new Map();\n        this.deliveryRecords = new message_deliveries_1.MessageDeliveries();\n        this.msgId = msgId;\n    }\n    /**\n     * Start PeerScore instance\n     * @returns {void}\n     */\n    start() {\n        if (this._backgroundInterval) {\n            log('Peer score already running');\n            return;\n        }\n        this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);\n        log('started');\n    }\n    /**\n     * Stop PeerScore instance\n     * @returns {void}\n     */\n    stop() {\n        if (!this._backgroundInterval) {\n            log('Peer score already stopped');\n            return;\n        }\n        clearInterval(this._backgroundInterval);\n        delete this._backgroundInterval;\n        this.peerIPs.clear();\n        this.peerStats.clear();\n        this.deliveryRecords.clear();\n        log('stopped');\n    }\n    /**\n     * Periodic maintenance\n     * @returns {void}\n     */\n    background() {\n        this._refreshScores();\n        this._updateIPs();\n        this.deliveryRecords.gc();\n    }\n    /**\n     * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n     * @returns {void}\n     */\n    _refreshScores() {\n        const now = Date.now();\n        const decayToZero = this.params.decayToZero;\n        this.peerStats.forEach((pstats, id) => {\n            if (!pstats.connected) {\n                // has the retention perious expired?\n                if (now > pstats.expire) {\n                    // yes, throw it away (but clean up the IP tracking first)\n                    this._removeIPs(id, pstats.ips);\n                    this.peerStats.delete(id);\n                }\n                // we don't decay retained scores, as the peer is not active.\n                // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n                // unless the retention period has ellapsed.\n                // similarly, a well behaved peer does not lose its score by getting disconnected.\n                return;\n            }\n            Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n                const tparams = this.params.topics[topic];\n                if (!tparams) {\n                    // we are not scoring this topic\n                    // should be unreachable, we only add scored topics to pstats\n                    return;\n                }\n                // decay counters\n                tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;\n                if (tstats.firstMessageDeliveries < decayToZero) {\n                    tstats.firstMessageDeliveries = 0;\n                }\n                tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;\n                if (tstats.meshMessageDeliveries < decayToZero) {\n                    tstats.meshMessageDeliveries = 0;\n                }\n                tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;\n                if (tstats.meshFailurePenalty < decayToZero) {\n                    tstats.meshFailurePenalty = 0;\n                }\n                tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;\n                if (tstats.invalidMessageDeliveries < decayToZero) {\n                    tstats.invalidMessageDeliveries = 0;\n                }\n                // update mesh time and activate mesh message delivery parameter if need be\n                if (tstats.inMesh) {\n                    tstats.meshTime = now - tstats.graftTime;\n                    if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n                        tstats.meshMessageDeliveriesActive = true;\n                    }\n                }\n            });\n            // decay P7 counter\n            pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;\n            if (pstats.behaviourPenalty < decayToZero) {\n                pstats.behaviourPenalty = 0;\n            }\n        });\n    }\n    /**\n     * Return the score for a peer\n     * @param {string} id\n     * @returns {Number}\n     */\n    score(id) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return 0;\n        }\n        return compute_score_1.computeScore(id, pstats, this.params, this.peerIPs);\n    }\n    /**\n     * Apply a behavioural penalty to a peer\n     * @param {string} id\n     * @param {Number} penalty\n     * @returns {void}\n     */\n    addPenalty(id, penalty) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        pstats.behaviourPenalty += penalty;\n    }\n    /**\n     * @param {string} id\n     * @returns {void}\n     */\n    addPeer(id) {\n        // create peer stats (not including topic stats for each topic to be scored)\n        // topic stats will be added as needed\n        const pstats = peer_stats_1.createPeerStats({\n            connected: true\n        });\n        this.peerStats.set(id, pstats);\n        // get + update peer IPs\n        const ips = this._getIPs(id);\n        this._setIPs(id, ips, pstats.ips);\n        pstats.ips = ips;\n    }\n    /**\n     * @param {string} id\n     * @returns {void}\n     */\n    removePeer(id) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        // decide whether to retain the score; this currently only retains non-positive scores\n        // to dissuade attacks on the score function.\n        if (this.score(id) > 0) {\n            this._removeIPs(id, pstats.ips);\n            this.peerStats.delete(id);\n            return;\n        }\n        // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n        // reset to 0 and mesh delivery penalties applied.\n        Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n            tstats.firstMessageDeliveries = 0;\n            const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n            if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n                const deficit = threshold - tstats.meshMessageDeliveries;\n                tstats.meshFailurePenalty += deficit * deficit;\n            }\n            tstats.inMesh = false;\n            tstats.meshMessageDeliveriesActive = false;\n        });\n        pstats.connected = false;\n        pstats.expire = Date.now() + this.params.retainScore;\n    }\n    /**\n     * @param {string} id\n     * @param {String} topic\n     * @returns {void}\n     */\n    graft(id, topic) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n        if (!tstats) {\n            return;\n        }\n        tstats.inMesh = true;\n        tstats.graftTime = Date.now();\n        tstats.meshTime = 0;\n        tstats.meshMessageDeliveriesActive = false;\n    }\n    /**\n     * @param {string} id\n     * @param {string} topic\n     * @returns {void}\n     */\n    prune(id, topic) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n        if (!tstats) {\n            return;\n        }\n        // sticky mesh delivery rate failure penalty\n        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n            const deficit = threshold - tstats.meshMessageDeliveries;\n            tstats.meshFailurePenalty += deficit * deficit;\n        }\n        tstats.inMesh = false;\n        tstats.meshMessageDeliveriesActive = false;\n    }\n    /**\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n    validateMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.deliveryRecords.ensureRecord(yield this.msgId(message));\n        });\n    }\n    /**\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n    deliverMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const id = message.receivedFrom;\n            this._markFirstMessageDelivery(id, message);\n            const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));\n            const now = Date.now();\n            // defensive check that this is the first delivery trace -- delivery status should be unknown\n            if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {\n                log('unexpected delivery: message from %s was first seen %s ago and has delivery status %d', id, now - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n                return;\n            }\n            // mark the message as valid and reward mesh peers that have already forwarded it to us\n            drec.status = message_deliveries_1.DeliveryRecordStatus.valid;\n            drec.validated = now;\n            drec.peers.forEach(p => {\n                // this check is to make sure a peer can't send us a message twice and get a double count\n                // if it is a first delivery.\n                if (p !== id) {\n                    this._markDuplicateMessageDelivery(p, message);\n                }\n            });\n        });\n    }\n    /**\n     * @param {InMessage} message\n     * @param {string} reason\n     * @returns {Promise<void>}\n     */\n    rejectMessage(message, reason) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const id = message.receivedFrom;\n            switch (reason) {\n                case ERR_MISSING_SIGNATURE:\n                case ERR_INVALID_SIGNATURE:\n                    this._markInvalidMessageDelivery(id, message);\n                    return;\n            }\n            const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));\n            // defensive check that this is the first rejection -- delivery status should be unknown\n            if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {\n                log('unexpected rejection: message from %s was first seen %s ago and has delivery status %d', id, Date.now() - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n                return;\n            }\n            switch (reason) {\n                case constants_1.ERR_TOPIC_VALIDATOR_IGNORE:\n                    // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n                    drec.status = message_deliveries_1.DeliveryRecordStatus.ignored;\n                    return;\n            }\n            // mark the message as invalid and penalize peers that have already forwarded it.\n            drec.status = message_deliveries_1.DeliveryRecordStatus.invalid;\n            this._markInvalidMessageDelivery(id, message);\n            drec.peers.forEach(p => {\n                this._markInvalidMessageDelivery(p, message);\n            });\n        });\n    }\n    /**\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n    duplicateMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const id = message.receivedFrom;\n            const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));\n            if (drec.peers.has(id)) {\n                // we have already seen this duplicate\n                return;\n            }\n            switch (drec.status) {\n                case message_deliveries_1.DeliveryRecordStatus.unknown:\n                    // the message is being validated; track the peer delivery and wait for\n                    // the Deliver/Reject/Ignore notification.\n                    drec.peers.add(id);\n                    break;\n                case message_deliveries_1.DeliveryRecordStatus.valid:\n                    // mark the peer delivery time to only count a duplicate delivery once.\n                    drec.peers.add(id);\n                    this._markDuplicateMessageDelivery(id, message, drec.validated);\n                    break;\n                case message_deliveries_1.DeliveryRecordStatus.invalid:\n                    // we no longer track delivery time\n                    this._markInvalidMessageDelivery(id, message);\n                    break;\n            }\n        });\n    }\n    /**\n     * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n     * @param {string} id\n     * @param {InMessage} message\n     * @returns {void}\n     */\n    _markInvalidMessageDelivery(id, message) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        message.topicIDs.forEach(topic => {\n            const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n            if (!tstats) {\n                return;\n            }\n            tstats.invalidMessageDeliveries += 1;\n        });\n    }\n    /**\n     * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n     * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n     * @param {string} id\n     * @param {InMessage} message\n     * @returns {void}\n     */\n    _markFirstMessageDelivery(id, message) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        message.topicIDs.forEach(topic => {\n            const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n            if (!tstats) {\n                return;\n            }\n            let cap = this.params.topics[topic].firstMessageDeliveriesCap;\n            tstats.firstMessageDeliveries += 1;\n            if (tstats.firstMessageDeliveries > cap) {\n                tstats.firstMessageDeliveries = cap;\n            }\n            if (!tstats.inMesh) {\n                return;\n            }\n            cap = this.params.topics[topic].meshMessageDeliveriesCap;\n            tstats.meshMessageDeliveries += 1;\n            if (tstats.meshMessageDeliveries > cap) {\n                tstats.meshMessageDeliveries = cap;\n            }\n        });\n    }\n    /**\n     * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n     * as long the message was received within the P3 window.\n     * @param {string} id\n     * @param {InMessage} message\n     * @param {number} validatedTime\n     * @returns {void}\n     */\n    _markDuplicateMessageDelivery(id, message, validatedTime = 0) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        const now = validatedTime ? Date.now() : 0;\n        message.topicIDs.forEach(topic => {\n            const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n            if (!tstats) {\n                return;\n            }\n            if (!tstats.inMesh) {\n                return;\n            }\n            const tparams = this.params.topics[topic];\n            // check against the mesh delivery window -- if the validated time is passed as 0, then\n            // the message was received before we finished validation and thus falls within the mesh\n            // delivery window.\n            if (validatedTime && now > validatedTime + tparams.meshMessageDeliveriesWindow) {\n                return;\n            }\n            const cap = tparams.meshMessageDeliveriesCap;\n            tstats.meshMessageDeliveries += 1;\n            if (tstats.meshMessageDeliveries > cap) {\n                tstats.meshMessageDeliveries = cap;\n            }\n        });\n    }\n    /**\n     * Gets the current IPs for a peer.\n     * @param {string} id\n     * @returns {Array<string>}\n     */\n    _getIPs(id) {\n        return this._connectionManager.getAll(peer_id_1.default.createFromB58String(id))\n            .map(c => c.remoteAddr.toOptions().host);\n    }\n    /**\n     * Adds tracking for the new IPs in the list, and removes tracking from the obsolete IPs.\n     * @param {string} id\n     * @param {Array<string>} newIPs\n     * @param {Array<string>} oldIPs\n     * @returns {void}\n     */\n    _setIPs(id, newIPs, oldIPs) {\n        // add the new IPs to the tracking\n        // eslint-disable-next-line no-labels\n        addNewIPs: for (const ip of newIPs) {\n            // check if it is in the old ips list\n            for (const xip of oldIPs) {\n                if (ip === xip) {\n                    // eslint-disable-next-line no-labels\n                    continue addNewIPs;\n                }\n            }\n            // no, it's a new one -- add it to the tracker\n            let peers = this.peerIPs.get(ip);\n            if (!peers) {\n                peers = new Set();\n                this.peerIPs.set(ip, peers);\n            }\n            peers.add(id);\n        }\n        // remove the obsolete old IPs from the tracking\n        // eslint-disable-next-line no-labels\n        removeOldIPs: for (const ip of oldIPs) {\n            // check if it is in the new ips list\n            for (const xip of newIPs) {\n                if (ip === xip) {\n                    // eslint-disable-next-line no-labels\n                    continue removeOldIPs;\n                }\n            }\n            // no, its obselete -- remove it from the tracker\n            const peers = this.peerIPs.get(ip);\n            if (!peers) {\n                continue;\n            }\n            peers.delete(id);\n            if (!peers.size) {\n                this.peerIPs.delete(ip);\n            }\n        }\n    }\n    /**\n     * Removes an IP list from the tracking list for a peer.\n     * @param {string} id\n     * @param {Array<string>} ips\n     * @returns {void}\n     */\n    _removeIPs(id, ips) {\n        ips.forEach(ip => {\n            const peers = this.peerIPs.get(ip);\n            if (!peers) {\n                return;\n            }\n            peers.delete(id);\n            if (!peers.size) {\n                this.peerIPs.delete(ip);\n            }\n        });\n    }\n    /**\n     * Update all peer IPs to currently open connections\n     * @returns {void}\n     */\n    _updateIPs() {\n        this.peerStats.forEach((pstats, id) => {\n            const newIPs = this._getIPs(id);\n            this._setIPs(id, newIPs, pstats.ips);\n            pstats.ips = newIPs;\n        });\n    }\n}\nexports.PeerScore = PeerScore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}