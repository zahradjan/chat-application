{"ast":null,"code":"'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst {\n  ipfs: {\n    pin: {\n      Set: PinSet\n    }\n  }\n} = require('./pin'); // @ts-ignore\n\n\nconst fnv1a = require('fnv1a');\n\nconst varint = require('varint');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  DEFAULT_FANOUT,\n  MAX_ITEMS,\n  EMPTY_KEY\n} = require('./utils');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst {\n  compare: uint8ArrayCompare\n} = require('uint8arrays/compare');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\n\n\nfunction readHeader(rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data;\n\n  if (!rootData) {\n    throw new Error('No data present');\n  }\n\n  const hdrLength = varint.decode(rootData);\n  const vBytes = varint.decode.bytes;\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  });\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`);\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n/**\n * @param {number} seed\n * @param {CID} key\n */\n\n\nfunction hash(seed, key) {\n  const buffer = new Uint8Array(4);\n  const dataView = new DataView(buffer.buffer);\n  dataView.setUint32(0, seed, true);\n  const encodedKey = uint8ArrayFromString(key.toString());\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength);\n  return fnv1a(uint8ArrayToString(data));\n}\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\n\n\nasync function* walkItems(blockstore, node) {\n  const pbh = readHeader(node);\n  let idx = 0;\n\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      // the first pbh.header.fanout links are fanout bins\n      // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n      const linkHash = link.Hash;\n\n      if (!EMPTY_KEY.equals(linkHash)) {\n        // walk the links of this fanout bin\n        const buf = await blockstore.get(linkHash);\n        const node = dagPb.decode(buf);\n        yield* walkItems(blockstore, node);\n      }\n    } else {\n      // otherwise, the link is a pin\n      yield link.Hash;\n    }\n\n    idx++;\n  }\n}\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\n\n\nasync function* loadSet(blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name);\n\n  if (!link) {\n    throw new Error('No link found with name ' + name);\n  }\n\n  const buf = await blockstore.get(link.Hash);\n  const node = dagPb.decode(buf);\n  yield* walkItems(blockstore, node);\n}\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\n\n\nfunction storeItems(blockstore, items) {\n  return storePins(items, 0);\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n\n  async function storePins(pins, depth) {\n    const pbHeader = PinSet.encode({\n      version: 1,\n      fanout: DEFAULT_FANOUT,\n      seed: depth\n    }).finish();\n    const header = varint.encode(pbHeader.length);\n    const headerBuf = uint8ArrayConcat([header, pbHeader]);\n    const fanoutLinks = [];\n\n    for (let i = 0; i < DEFAULT_FANOUT; i++) {\n      fanoutLinks.push({\n        Name: '',\n        Tsize: 1,\n        Hash: EMPTY_KEY\n      });\n    }\n\n    if (pins.length <= MAX_ITEMS) {\n      const nodes = pins.map(item => {\n        return {\n          link: {\n            Name: '',\n            Tsize: 1,\n            Hash: item.key\n          },\n          data: item.data || new Uint8Array()\n        };\n      }) // sorting makes any ordering of `pins` produce the same DAGNode\n      .sort((a, b) => {\n        return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes);\n      });\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link));\n      const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)]);\n      return {\n        Data: rootData,\n        Links: rootLinks\n      };\n    } else {\n      // If the array of pins is > MAX_ITEMS, we:\n      //  - distribute the pins among `DEFAULT_FANOUT` bins\n      //    - create a DAGNode for each bin\n      //      - add each pin as a DAGLink to that bin\n      //  - create a root DAGNode\n      //    - add each bin as a DAGLink\n      //  - send that root DAGNode via callback\n      // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n      // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n      /** @type {Pin[][]} */\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % DEFAULT_FANOUT; // @ts-ignore\n\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n        return bins;\n      }, []);\n      let idx = 0;\n\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1);\n        await storeChild(child, idx);\n        idx++;\n      }\n\n      return {\n        Data: headerBuf,\n        Links: fanoutLinks\n      };\n    }\n    /**\n     * @param {PBNode} child\n     * @param {number} binIdx\n     */\n\n\n    async function storeChild(child, binIdx) {\n      const buf = dagPb.encode(child);\n      const digest = await sha256.digest(buf);\n      const cid = CID.createV0(digest);\n      await blockstore.put(cid, buf);\n      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length;\n      fanoutLinks[binIdx] = {\n        Name: '',\n        Tsize: size,\n        Hash: cid\n      };\n    }\n  }\n}\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\n\n\nasync function storeSet(blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid\n    };\n  }));\n  const buf = dagPb.encode(rootNode);\n  const digest = await sha256.digest(buf);\n  const cid = CID.createV0(digest);\n  await blockstore.put(cid, buf);\n  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length;\n  return {\n    Name: type,\n    Tsize: size,\n    Hash: cid\n  };\n}\n\nmodule.exports = {\n  loadSet,\n  storeSet\n};","map":{"version":3,"names":["CID","require","ipfs","pin","Set","PinSet","fnv1a","varint","dagPb","DEFAULT_FANOUT","MAX_ITEMS","EMPTY_KEY","concat","uint8ArrayConcat","compare","uint8ArrayCompare","toString","uint8ArrayToString","fromString","uint8ArrayFromString","sha256","readHeader","rootNode","rootData","Data","Error","hdrLength","decode","vBytes","bytes","length","hdrSlice","slice","header","toObject","defaults","arrays","longs","Number","objects","version","fanout","Links","data","hash","seed","key","buffer","Uint8Array","dataView","DataView","setUint32","encodedKey","byteLength","walkItems","blockstore","node","pbh","idx","link","linkHash","Hash","equals","buf","get","loadSet","name","find","l","Name","storeItems","items","storePins","pins","depth","pbHeader","encode","finish","headerBuf","fanoutLinks","i","push","Tsize","nodes","map","item","sort","a","b","rootLinks","bins","reduce","n","bin","child","storeChild","binIdx","digest","cid","createV0","put","size","acc","curr","storeSet","type","cids","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-repo-migrations/migrations/migration-9/pin-set.js"],"sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst {\n  ipfs: {\n    pin: {\n      Set: PinSet\n    }\n  }\n} = require('./pin')\n\n// @ts-ignore\nconst fnv1a = require('fnv1a')\nconst varint = require('varint')\nconst dagPb = require('@ipld/dag-pb')\nconst { DEFAULT_FANOUT, MAX_ITEMS, EMPTY_KEY } = require('./utils')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst { compare: uint8ArrayCompare } = require('uint8arrays/compare')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { sha256 } = require('multiformats/hashes/sha2')\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\nfunction readHeader (rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data\n\n  if (!rootData) {\n    throw new Error('No data present')\n  }\n\n  const hdrLength = varint.decode(rootData)\n  const vBytes = varint.decode.bytes\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length')\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length')\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes)\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  })\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`)\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout')\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  }\n}\n\n/**\n * @param {number} seed\n * @param {CID} key\n */\nfunction hash (seed, key) {\n  const buffer = new Uint8Array(4)\n  const dataView = new DataView(buffer.buffer)\n  dataView.setUint32(0, seed, true)\n  const encodedKey = uint8ArrayFromString(key.toString())\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength)\n\n  return fnv1a(uint8ArrayToString(data))\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\nasync function * walkItems (blockstore, node) {\n  const pbh = readHeader(node)\n  let idx = 0\n\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      // the first pbh.header.fanout links are fanout bins\n      // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n      const linkHash = link.Hash\n\n      if (!EMPTY_KEY.equals(linkHash)) {\n        // walk the links of this fanout bin\n        const buf = await blockstore.get(linkHash)\n        const node = dagPb.decode(buf)\n\n        yield * walkItems(blockstore, node)\n      }\n    } else {\n      // otherwise, the link is a pin\n      yield link.Hash\n    }\n\n    idx++\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\nasync function * loadSet (blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name)\n\n  if (!link) {\n    throw new Error('No link found with name ' + name)\n  }\n\n  const buf = await blockstore.get(link.Hash)\n  const node = dagPb.decode(buf)\n\n  yield * walkItems(blockstore, node)\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\nfunction storeItems (blockstore, items) {\n  return storePins(items, 0)\n\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n  async function storePins (pins, depth) {\n    const pbHeader = PinSet.encode({\n      version: 1,\n      fanout: DEFAULT_FANOUT,\n      seed: depth\n    }).finish()\n\n    const header = varint.encode(pbHeader.length)\n    const headerBuf = uint8ArrayConcat([header, pbHeader])\n    const fanoutLinks = []\n\n    for (let i = 0; i < DEFAULT_FANOUT; i++) {\n      fanoutLinks.push({\n        Name: '',\n        Tsize: 1,\n        Hash: EMPTY_KEY\n      })\n    }\n\n    if (pins.length <= MAX_ITEMS) {\n      const nodes = pins\n        .map(item => {\n          return ({\n            link: {\n              Name: '',\n              Tsize: 1,\n              Hash: item.key\n            },\n            data: item.data || new Uint8Array()\n          })\n        })\n        // sorting makes any ordering of `pins` produce the same DAGNode\n        .sort((a, b) => {\n          return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes)\n        })\n\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link))\n      const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)])\n\n      return {\n        Data: rootData,\n        Links: rootLinks\n      }\n    } else {\n      // If the array of pins is > MAX_ITEMS, we:\n      //  - distribute the pins among `DEFAULT_FANOUT` bins\n      //    - create a DAGNode for each bin\n      //      - add each pin as a DAGLink to that bin\n      //  - create a root DAGNode\n      //    - add each bin as a DAGLink\n      //  - send that root DAGNode via callback\n      // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n      // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n      /** @type {Pin[][]} */\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % DEFAULT_FANOUT\n        // @ts-ignore\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin]\n        return bins\n      }, [])\n\n      let idx = 0\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1)\n\n        await storeChild(child, idx)\n\n        idx++\n      }\n\n      return {\n        Data: headerBuf,\n        Links: fanoutLinks\n      }\n    }\n\n    /**\n     * @param {PBNode} child\n     * @param {number} binIdx\n     */\n    async function storeChild (child, binIdx) {\n      const buf = dagPb.encode(child)\n      const digest = await sha256.digest(buf)\n      const cid = CID.createV0(digest)\n\n      await blockstore.put(cid, buf)\n\n      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length\n\n      fanoutLinks[binIdx] = {\n        Name: '',\n        Tsize: size,\n        Hash: cid\n      }\n    }\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\nasync function storeSet (blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid\n    }\n  }))\n  const buf = dagPb.encode(rootNode)\n  const digest = await sha256.digest(buf)\n  const cid = CID.createV0(digest)\n\n  await blockstore.put(cid, buf)\n\n  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length\n\n  return {\n    Name: type,\n    Tsize: size,\n    Hash: cid\n  }\n}\n\nmodule.exports = {\n  loadSet,\n  storeSet\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}