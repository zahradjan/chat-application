{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst filter = require('it-filter');\n\nconst map = require('it-map');\n\nconst take = require('it-take');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * Store the multiaddrs from every peer in the passed peer store\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {import('../peer-store')} peerStore\n */\n\n\nfunction storeAddresses(source, peerStore) {\n  return map(source, peer => {\n    // ensure we have the addresses for a given peer\n    peerStore.addressBook.add(peer.id, peer.multiaddrs);\n    return peer;\n  });\n}\n/**\n * Filter peers by unique peer id\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n */\n\n\nfunction uniquePeers(source) {\n  /** @type Set<string> */\n  const seen = new Set();\n  return filter(source, peer => {\n    // dedupe by peer id\n    if (seen.has(peer.id.toString())) {\n      return false;\n    }\n\n    seen.add(peer.id.toString());\n    return true;\n  });\n}\n/**\n * Require at least `min` peers to be yielded from `source`\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} min\n */\n\n\nasync function* requirePeers(source) {\n  let min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let seen = 0;\n\n  for await (const peer of source) {\n    seen++;\n    yield peer;\n  }\n\n  if (seen < min) {\n    throw errCode(new Error('not found'), 'NOT_FOUND');\n  }\n}\n/**\n * If `max` is passed, only take that number of peers from the source\n * otherwise take all the peers\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} [max]\n */\n\n\nfunction maybeLimitSource(source, max) {\n  if (max) {\n    return take(source, max);\n  }\n\n  return source;\n}\n\nmodule.exports = {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n};","map":{"version":3,"names":["errCode","require","filter","map","take","storeAddresses","source","peerStore","peer","addressBook","add","id","multiaddrs","uniquePeers","seen","Set","has","toString","requirePeers","min","Error","maybeLimitSource","max","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/content-routing/utils.js"],"sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst filter = require('it-filter')\nconst map = require('it-map')\nconst take = require('it-take')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * Store the multiaddrs from every peer in the passed peer store\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {import('../peer-store')} peerStore\n */\nfunction storeAddresses (source, peerStore) {\n  return map(source, (peer) => {\n    // ensure we have the addresses for a given peer\n    peerStore.addressBook.add(peer.id, peer.multiaddrs)\n\n    return peer\n  })\n}\n\n/**\n * Filter peers by unique peer id\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n */\nfunction uniquePeers (source) {\n  /** @type Set<string> */\n  const seen = new Set()\n\n  return filter(source, (peer) => {\n    // dedupe by peer id\n    if (seen.has(peer.id.toString())) {\n      return false\n    }\n\n    seen.add(peer.id.toString())\n\n    return true\n  })\n}\n\n/**\n * Require at least `min` peers to be yielded from `source`\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} min\n */\nasync function * requirePeers (source, min = 1) {\n  let seen = 0\n\n  for await (const peer of source) {\n    seen++\n\n    yield peer\n  }\n\n  if (seen < min) {\n    throw errCode(new Error('not found'), 'NOT_FOUND')\n  }\n}\n\n/**\n * If `max` is passed, only take that number of peers from the source\n * otherwise take all the peers\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} [max]\n */\nfunction maybeLimitSource (source, max) {\n  if (max) {\n    return take(source, max)\n  }\n\n  return source\n}\n\nmodule.exports = {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n}\n"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,QAAD,CAAnB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,SAAD,CAApB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,cAAT,CAAyBC,MAAzB,EAAiCC,SAAjC,EAA4C;EAC1C,OAAOJ,GAAG,CAACG,MAAD,EAAUE,IAAD,IAAU;IAC3B;IACAD,SAAS,CAACE,WAAV,CAAsBC,GAAtB,CAA0BF,IAAI,CAACG,EAA/B,EAAmCH,IAAI,CAACI,UAAxC;IAEA,OAAOJ,IAAP;EACD,CALS,CAAV;AAMD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASK,WAAT,CAAsBP,MAAtB,EAA8B;EAC5B;EACA,MAAMQ,IAAI,GAAG,IAAIC,GAAJ,EAAb;EAEA,OAAOb,MAAM,CAACI,MAAD,EAAUE,IAAD,IAAU;IAC9B;IACA,IAAIM,IAAI,CAACE,GAAL,CAASR,IAAI,CAACG,EAAL,CAAQM,QAAR,EAAT,CAAJ,EAAkC;MAChC,OAAO,KAAP;IACD;;IAEDH,IAAI,CAACJ,GAAL,CAASF,IAAI,CAACG,EAAL,CAAQM,QAAR,EAAT;IAEA,OAAO,IAAP;EACD,CATY,CAAb;AAUD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,gBAAiBC,YAAjB,CAA+BZ,MAA/B,EAAgD;EAAA,IAATa,GAAS,uEAAH,CAAG;EAC9C,IAAIL,IAAI,GAAG,CAAX;;EAEA,WAAW,MAAMN,IAAjB,IAAyBF,MAAzB,EAAiC;IAC/BQ,IAAI;IAEJ,MAAMN,IAAN;EACD;;EAED,IAAIM,IAAI,GAAGK,GAAX,EAAgB;IACd,MAAMnB,OAAO,CAAC,IAAIoB,KAAJ,CAAU,WAAV,CAAD,EAAyB,WAAzB,CAAb;EACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,gBAAT,CAA2Bf,MAA3B,EAAmCgB,GAAnC,EAAwC;EACtC,IAAIA,GAAJ,EAAS;IACP,OAAOlB,IAAI,CAACE,MAAD,EAASgB,GAAT,CAAX;EACD;;EAED,OAAOhB,MAAP;AACD;;AAEDiB,MAAM,CAACC,OAAP,GAAiB;EACfnB,cADe;EAEfQ,WAFe;EAGfK,YAHe;EAIfG;AAJe,CAAjB"},"metadata":{},"sourceType":"script"}