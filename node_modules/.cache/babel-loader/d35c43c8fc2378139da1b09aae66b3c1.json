{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst {\n  RPC\n} = require('./rpc');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst SignPrefix = uint8ArrayFromString('libp2p-pubsub:');\n\nconst {\n  normalizeOutRpcMessage\n} = require('../utils');\n/**\n * @typedef {import('..').InMessage}\n */\n\n/**\n * Signs the provided message with the given `peerId`\n *\n * @param {PeerId} peerId\n * @param {InMessage} message\n * @returns {Promise<InMessage>}\n */\n\n\nasync function signMessage(peerId, message) {\n  // Get the message in bytes, and prepend with the pubsub prefix\n  const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(normalizeOutRpcMessage(message)).finish()]);\n  const signature = await peerId.privKey.sign(bytes);\n  return { ...message,\n    signature: signature,\n    key: peerId.pubKey.bytes\n  };\n}\n/**\n * Verifies the signature of the given message\n *\n * @param {InMessage} message\n * @returns {Promise<boolean>}\n */\n\n\nasync function verifySignature(message) {\n  if (!message.signature) {\n    throw new Error('Message must contain a signature to be verified');\n  }\n\n  if (!message.from) {\n    throw new Error('Message must contain a from property to be verified');\n  } // Get message sans the signature\n\n\n  const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode({ ...message,\n    from: PeerId.createFromB58String(message.from).toBytes(),\n    signature: undefined,\n    key: undefined\n  }).finish()]); // Get the public key\n\n  const pubKey = await messagePublicKey(message); // verify the base message\n\n  return pubKey.verify(bytes, message.signature);\n}\n/**\n * Returns the PublicKey associated with the given message.\n * If no, valid PublicKey can be retrieved an error will be returned.\n *\n * @param {InMessage} message\n * @returns {Promise<PublicKey>}\n */\n\n\nasync function messagePublicKey(message) {\n  // should be available in the from property of the message (peer id)\n  if (!message.from) {\n    throw new Error('Could not get the public key from the originator id');\n  }\n\n  const from = PeerId.createFromB58String(message.from);\n\n  if (message.key) {\n    const keyPeerId = await PeerId.createFromPubKey(message.key); // the key belongs to the sender, return the key\n\n    if (keyPeerId.equals(from)) return keyPeerId.pubKey; // We couldn't validate pubkey is from the originator, error\n\n    throw new Error('Public Key does not match the originator');\n  } else if (from.pubKey) {\n    return from.pubKey;\n  } else {\n    throw new Error('Could not get the public key from the originator id');\n  }\n}\n/**\n * @typedef {import('..').InMessage} InMessage\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n */\n\n\nmodule.exports = {\n  messagePublicKey,\n  signMessage,\n  SignPrefix,\n  verifySignature\n};","map":{"version":3,"names":["PeerId","require","RPC","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","SignPrefix","normalizeOutRpcMessage","signMessage","peerId","message","bytes","Message","encode","finish","signature","privKey","sign","key","pubKey","verifySignature","Error","from","createFromB58String","toBytes","undefined","messagePublicKey","verify","keyPeerId","createFromPubKey","equals","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-interfaces/src/pubsub/message/sign.js"],"sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { RPC } = require('./rpc')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst SignPrefix = uint8ArrayFromString('libp2p-pubsub:')\nconst { normalizeOutRpcMessage } = require('../utils')\n\n/**\n * @typedef {import('..').InMessage}\n */\n\n/**\n * Signs the provided message with the given `peerId`\n *\n * @param {PeerId} peerId\n * @param {InMessage} message\n * @returns {Promise<InMessage>}\n */\nasync function signMessage (peerId, message) {\n  // Get the message in bytes, and prepend with the pubsub prefix\n  const bytes = uint8ArrayConcat([\n    SignPrefix,\n    RPC.Message.encode(normalizeOutRpcMessage(message)).finish()\n  ])\n\n  const signature = await peerId.privKey.sign(bytes)\n\n  return {\n    ...message,\n    signature: signature,\n    key: peerId.pubKey.bytes\n  }\n}\n\n/**\n * Verifies the signature of the given message\n *\n * @param {InMessage} message\n * @returns {Promise<boolean>}\n */\nasync function verifySignature (message) {\n  if (!message.signature) {\n    throw new Error('Message must contain a signature to be verified')\n  }\n\n  if (!message.from) {\n    throw new Error('Message must contain a from property to be verified')\n  }\n\n  // Get message sans the signature\n  const bytes = uint8ArrayConcat([\n    SignPrefix,\n    RPC.Message.encode({\n      ...message,\n      from: PeerId.createFromB58String(message.from).toBytes(),\n      signature: undefined,\n      key: undefined\n    }).finish()\n  ])\n\n  // Get the public key\n  const pubKey = await messagePublicKey(message)\n\n  // verify the base message\n  return pubKey.verify(bytes, message.signature)\n}\n\n/**\n * Returns the PublicKey associated with the given message.\n * If no, valid PublicKey can be retrieved an error will be returned.\n *\n * @param {InMessage} message\n * @returns {Promise<PublicKey>}\n */\nasync function messagePublicKey (message) {\n  // should be available in the from property of the message (peer id)\n  if (!message.from) {\n    throw new Error('Could not get the public key from the originator id')\n  }\n\n  const from = PeerId.createFromB58String(message.from)\n\n  if (message.key) {\n    const keyPeerId = await PeerId.createFromPubKey(message.key)\n\n    // the key belongs to the sender, return the key\n    if (keyPeerId.equals(from)) return keyPeerId.pubKey\n    // We couldn't validate pubkey is from the originator, error\n    throw new Error('Public Key does not match the originator')\n  } else if (from.pubKey) {\n    return from.pubKey\n  } else {\n    throw new Error('Could not get the public key from the originator id')\n  }\n}\n\n/**\n * @typedef {import('..').InMessage} InMessage\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n */\n\nmodule.exports = {\n  messagePublicKey,\n  signMessage,\n  SignPrefix,\n  verifySignature\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}