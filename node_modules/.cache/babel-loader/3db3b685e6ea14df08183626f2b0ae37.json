{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:persistent-peer-store'), {\n  error: debug('libp2p:persistent-peer-store:err')\n});\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst PeerStore = require('..');\n\nconst {\n  NAMESPACE_ADDRESS,\n  NAMESPACE_COMMON,\n  NAMESPACE_KEYS,\n  NAMESPACE_METADATA,\n  NAMESPACE_PROTOCOL\n} = require('./consts');\n\nconst {\n  Addresses\n} = require('./pb/address-book');\n\nconst {\n  Protocols\n} = require('./pb/proto-book');\n/**\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('../address-book.js').Address} Address\n */\n\n/**\n * @typedef {Object} PersistentPeerStoreProperties\n * @property {PeerId} peerId\n * @property {import('interface-datastore').Datastore} datastore\n *\n * @typedef {Object} PersistentPeerStoreOptions\n * @property {number} [threshold = 5] - Number of dirty peers allowed before commit data.\n */\n\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\n\n\nclass PersistentPeerStore extends PeerStore {\n  /**\n   * @class\n   * @param {PersistentPeerStoreProperties & PersistentPeerStoreOptions} properties\n   */\n  constructor(_ref) {\n    let {\n      peerId,\n      datastore,\n      threshold = 5\n    } = _ref;\n    super({\n      peerId\n    });\n    /**\n     * Backend datastore used to persist data.\n     */\n\n    this._datastore = datastore;\n    /**\n     * Peers modified after the latest data persisted.\n     */\n\n    this._dirtyPeers = new Set();\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this._dirtyMetadata = new Map();\n    this.threshold = threshold;\n    this._addDirtyPeer = this._addDirtyPeer.bind(this);\n  }\n  /**\n   * Start Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async start() {\n    log('PeerStore is starting'); // Handlers for dirty peers\n\n    this.on('change:protocols', this._addDirtyPeer);\n    this.on('change:multiaddrs', this._addDirtyPeer);\n    this.on('change:pubkey', this._addDirtyPeerKey);\n    this.on('change:metadata', this._addDirtyPeerMetadata); // Load data\n\n    for await (const entry of this._datastore.query({\n      prefix: NAMESPACE_COMMON\n    })) {\n      await this._processDatastoreEntry(entry);\n    }\n\n    log('PeerStore started');\n  }\n  /**\n   * Stop Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async stop() {\n    log('PeerStore is stopping');\n    this.removeAllListeners();\n    await this._commitData();\n    log('PeerStore stopped');\n  }\n  /**\n   * Add modified peer to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n\n\n  _addDirtyPeer(_ref2) {\n    let {\n      peerId\n    } = _ref2;\n    const peerIdstr = peerId.toB58String();\n    log('add dirty peer', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add modified peer key to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n\n\n  _addDirtyPeerKey(_ref3) {\n    let {\n      peerId\n    } = _ref3;\n\n    // Not add if inline key available\n    if (peerId.hasInlinePublicKey()) {\n      return;\n    }\n\n    const peerIdstr = peerId.toB58String();\n    log('add dirty peer key', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add modified metadata peer to the set.\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {string} params.metadata\n   */\n\n\n  _addDirtyPeerMetadata(_ref4) {\n    let {\n      peerId,\n      metadata\n    } = _ref4;\n    const peerIdstr = peerId.toB58String();\n    log('add dirty metadata peer', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr); // Add dirty metadata key\n\n\n    const mData = this._dirtyMetadata.get(peerIdstr) || new Set();\n    mData.add(metadata);\n\n    this._dirtyMetadata.set(peerIdstr, mData);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add all the peers current data to a datastore batch and commit it.\n   *\n   * @private\n   * @returns {Promise<void>}\n   */\n\n\n  async _commitData() {\n    const commitPeers = Array.from(this._dirtyPeers);\n\n    if (!commitPeers.length) {\n      return;\n    } // Clear Dirty Peers set\n\n\n    this._dirtyPeers.clear();\n\n    log('create batch commit');\n\n    const batch = this._datastore.batch();\n\n    for (const peerIdStr of commitPeers) {\n      // PeerId\n      const peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromB58String(peerIdStr); // Address Book\n\n      this._batchAddressBook(peerId, batch); // Key Book\n\n\n      !peerId.hasInlinePublicKey() && this._batchKeyBook(peerId, batch); // Metadata Book\n\n      this._batchMetadataBook(peerId, batch); // Proto Book\n\n\n      this._batchProtoBook(peerId, batch);\n    }\n\n    await batch.commit();\n    log('batch committed');\n  }\n  /**\n   * Add address book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n\n\n  _batchAddressBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_ADDRESS}${b32key}`);\n    const entry = this.addressBook.data.get(peerId.toB58String());\n\n    try {\n      // Deleted from the book\n      if (!entry) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = Addresses.encode({\n        addrs: entry.addresses.map(address => ({\n          multiaddr: address.multiaddr.bytes,\n          isCertified: address.isCertified\n        })),\n        certifiedRecord: entry.record ? {\n          seq: entry.record.seqNumber,\n          raw: entry.record.raw\n        } : undefined\n      }).finish();\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add Key book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n\n\n  _batchKeyBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_KEYS}${b32key}`);\n\n    try {\n      // Deleted from the book\n      if (!peerId.pubKey) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = peerId.marshalPubKey();\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add metadata book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n\n\n  _batchMetadataBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || [];\n\n    try {\n      dirtyMetada.forEach((\n      /** @type {string} */\n      dirtyKey) => {\n        const key = new Key(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`);\n        const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey);\n\n        if (dirtyValue) {\n          batch.put(key, dirtyValue);\n        } else {\n          batch.delete(key);\n        }\n      });\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add proto book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n\n\n  _batchProtoBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_PROTOCOL}${b32key}`);\n    const protocols = this.protoBook.get(peerId);\n\n    try {\n      // Deleted from the book\n      if (!protocols) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = Protocols.encode({\n        protocols\n      }).finish();\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Process datastore entry and add its data to the correct book.\n   *\n   * @private\n   * @param {Object} params\n   * @param {Key} params.key - datastore key\n   * @param {Uint8Array} params.value - datastore value stored\n   * @returns {Promise<void>}\n   */\n\n\n  async _processDatastoreEntry(_ref5) {\n    let {\n      key,\n      value\n    } = _ref5;\n\n    try {\n      const keyParts = key.toString().split('/');\n      const peerId = PeerId.createFromBytes(base32.decode(keyParts[3]));\n      let decoded;\n\n      switch (keyParts[2]) {\n        case 'addrs':\n          decoded = Addresses.decode(value); // @ts-ignore protected function\n\n          this.addressBook._setData(peerId, {\n            addresses: decoded.addrs.map(address => ({\n              multiaddr: new Multiaddr(address.multiaddr),\n              isCertified: Boolean(address.isCertified)\n            })),\n            record: decoded.certifiedRecord ? {\n              raw: decoded.certifiedRecord.raw,\n              seqNumber: decoded.certifiedRecord.seq\n            } : undefined\n          }, {\n            emit: false\n          });\n\n          break;\n\n        case 'keys':\n          decoded = await PeerId.createFromPubKey(value); // @ts-ignore protected function\n\n          this.keyBook._setData(decoded, decoded, {\n            emit: false\n          });\n\n          break;\n\n        case 'metadata':\n          this.metadataBook._setValue(peerId, keyParts[4], value, {\n            emit: false\n          });\n\n          break;\n\n        case 'protos':\n          decoded = Protocols.decode(value); // @ts-ignore protected function\n\n          this.protoBook._setData(peerId, new Set(decoded.protocols), {\n            emit: false\n          });\n\n          break;\n\n        default:\n          log('invalid data persisted for: ', key.toString());\n      }\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n}\n\nmodule.exports = PersistentPeerStore;","map":{"version":3,"names":["debug","require","log","Object","assign","error","Key","Multiaddr","PeerId","base32","PeerStore","NAMESPACE_ADDRESS","NAMESPACE_COMMON","NAMESPACE_KEYS","NAMESPACE_METADATA","NAMESPACE_PROTOCOL","Addresses","Protocols","PersistentPeerStore","constructor","peerId","datastore","threshold","_datastore","_dirtyPeers","Set","_dirtyMetadata","Map","_addDirtyPeer","bind","start","on","_addDirtyPeerKey","_addDirtyPeerMetadata","entry","query","prefix","_processDatastoreEntry","stop","removeAllListeners","_commitData","peerIdstr","toB58String","add","size","catch","err","hasInlinePublicKey","metadata","mData","get","set","commitPeers","Array","from","length","clear","batch","peerIdStr","keyBook","data","createFromB58String","_batchAddressBook","_batchKeyBook","_batchMetadataBook","_batchProtoBook","commit","b32key","toString","key","addressBook","delete","encodedData","encode","addrs","addresses","map","address","multiaddr","bytes","isCertified","certifiedRecord","record","seq","seqNumber","raw","undefined","finish","put","pubKey","marshalPubKey","dirtyMetada","forEach","dirtyKey","dirtyValue","metadataBook","getValue","protocols","protoBook","value","keyParts","split","createFromBytes","decode","decoded","_setData","Boolean","emit","createFromPubKey","_setValue","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/peer-store/persistent/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:persistent-peer-store'), {\n  error: debug('libp2p:persistent-peer-store:err')\n})\nconst { Key } = require('interface-datastore')\nconst { Multiaddr } = require('multiaddr')\nconst PeerId = require('peer-id')\nconst { base32 } = require('multiformats/bases/base32')\n\nconst PeerStore = require('..')\n\nconst {\n  NAMESPACE_ADDRESS,\n  NAMESPACE_COMMON,\n  NAMESPACE_KEYS,\n  NAMESPACE_METADATA,\n  NAMESPACE_PROTOCOL\n} = require('./consts')\n\nconst { Addresses } = require('./pb/address-book')\nconst { Protocols } = require('./pb/proto-book')\n\n/**\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('../address-book.js').Address} Address\n */\n\n/**\n * @typedef {Object} PersistentPeerStoreProperties\n * @property {PeerId} peerId\n * @property {import('interface-datastore').Datastore} datastore\n *\n * @typedef {Object} PersistentPeerStoreOptions\n * @property {number} [threshold = 5] - Number of dirty peers allowed before commit data.\n */\n\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\nclass PersistentPeerStore extends PeerStore {\n  /**\n   * @class\n   * @param {PersistentPeerStoreProperties & PersistentPeerStoreOptions} properties\n   */\n  constructor ({ peerId, datastore, threshold = 5 }) {\n    super({ peerId })\n\n    /**\n     * Backend datastore used to persist data.\n     */\n    this._datastore = datastore\n\n    /**\n     * Peers modified after the latest data persisted.\n     */\n    this._dirtyPeers = new Set()\n\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     *\n     * @type {Map<string, Set<string>>}\n     */\n    this._dirtyMetadata = new Map()\n\n    this.threshold = threshold\n    this._addDirtyPeer = this._addDirtyPeer.bind(this)\n  }\n\n  /**\n   * Start Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n  async start () {\n    log('PeerStore is starting')\n\n    // Handlers for dirty peers\n    this.on('change:protocols', this._addDirtyPeer)\n    this.on('change:multiaddrs', this._addDirtyPeer)\n    this.on('change:pubkey', this._addDirtyPeerKey)\n    this.on('change:metadata', this._addDirtyPeerMetadata)\n\n    // Load data\n    for await (const entry of this._datastore.query({ prefix: NAMESPACE_COMMON })) {\n      await this._processDatastoreEntry(entry)\n    }\n\n    log('PeerStore started')\n  }\n\n  /**\n   * Stop Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n  async stop () {\n    log('PeerStore is stopping')\n    this.removeAllListeners()\n    await this._commitData()\n    log('PeerStore stopped')\n  }\n\n  /**\n   * Add modified peer to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n  _addDirtyPeer ({ peerId }) {\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty peer', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add modified peer key to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n  _addDirtyPeerKey ({ peerId }) {\n    // Not add if inline key available\n    if (peerId.hasInlinePublicKey()) {\n      return\n    }\n\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty peer key', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add modified metadata peer to the set.\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {string} params.metadata\n   */\n  _addDirtyPeerMetadata ({ peerId, metadata }) {\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty metadata peer', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    // Add dirty metadata key\n    const mData = this._dirtyMetadata.get(peerIdstr) || new Set()\n    mData.add(metadata)\n    this._dirtyMetadata.set(peerIdstr, mData)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add all the peers current data to a datastore batch and commit it.\n   *\n   * @private\n   * @returns {Promise<void>}\n   */\n  async _commitData () {\n    const commitPeers = Array.from(this._dirtyPeers)\n\n    if (!commitPeers.length) {\n      return\n    }\n\n    // Clear Dirty Peers set\n    this._dirtyPeers.clear()\n\n    log('create batch commit')\n    const batch = this._datastore.batch()\n    for (const peerIdStr of commitPeers) {\n      // PeerId\n      const peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromB58String(peerIdStr)\n\n      // Address Book\n      this._batchAddressBook(peerId, batch)\n\n      // Key Book\n      !peerId.hasInlinePublicKey() && this._batchKeyBook(peerId, batch)\n\n      // Metadata Book\n      this._batchMetadataBook(peerId, batch)\n\n      // Proto Book\n      this._batchProtoBook(peerId, batch)\n    }\n\n    await batch.commit()\n    log('batch committed')\n  }\n\n  /**\n   * Add address book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n  _batchAddressBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_ADDRESS}${b32key}`)\n\n    const entry = this.addressBook.data.get(peerId.toB58String())\n\n    try {\n      // Deleted from the book\n      if (!entry) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = Addresses.encode({\n        addrs: entry.addresses.map((address) => ({\n          multiaddr: address.multiaddr.bytes,\n          isCertified: address.isCertified\n        })),\n        certifiedRecord: entry.record\n          ? {\n              seq: entry.record.seqNumber,\n              raw: entry.record.raw\n            }\n          : undefined\n      }).finish()\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add Key book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n  _batchKeyBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_KEYS}${b32key}`)\n\n    try {\n      // Deleted from the book\n      if (!peerId.pubKey) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = peerId.marshalPubKey()\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add metadata book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n  _batchMetadataBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || []\n\n    try {\n      dirtyMetada.forEach((/** @type {string} */ dirtyKey) => {\n        const key = new Key(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`)\n        const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey)\n\n        if (dirtyValue) {\n          batch.put(key, dirtyValue)\n        } else {\n          batch.delete(key)\n        }\n      })\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add proto book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n  _batchProtoBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_PROTOCOL}${b32key}`)\n\n    const protocols = this.protoBook.get(peerId)\n\n    try {\n      // Deleted from the book\n      if (!protocols) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = Protocols.encode({ protocols }).finish()\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Process datastore entry and add its data to the correct book.\n   *\n   * @private\n   * @param {Object} params\n   * @param {Key} params.key - datastore key\n   * @param {Uint8Array} params.value - datastore value stored\n   * @returns {Promise<void>}\n   */\n  async _processDatastoreEntry ({ key, value }) {\n    try {\n      const keyParts = key.toString().split('/')\n      const peerId = PeerId.createFromBytes(base32.decode(keyParts[3]))\n\n      let decoded\n      switch (keyParts[2]) {\n        case 'addrs':\n          decoded = Addresses.decode(value)\n\n          // @ts-ignore protected function\n          this.addressBook._setData(\n            peerId,\n            {\n              addresses: decoded.addrs.map((address) => ({\n                multiaddr: new Multiaddr(address.multiaddr),\n                isCertified: Boolean(address.isCertified)\n              })),\n              record: decoded.certifiedRecord\n                ? {\n                    raw: decoded.certifiedRecord.raw,\n                    seqNumber: decoded.certifiedRecord.seq\n                  }\n                : undefined\n            },\n            { emit: false })\n          break\n        case 'keys':\n          decoded = await PeerId.createFromPubKey(value)\n\n          // @ts-ignore protected function\n          this.keyBook._setData(\n            decoded,\n            decoded,\n            { emit: false })\n          break\n        case 'metadata':\n          this.metadataBook._setValue(\n            peerId,\n            keyParts[4],\n            value,\n            { emit: false })\n          break\n        case 'protos':\n          decoded = Protocols.decode(value)\n\n          // @ts-ignore protected function\n          this.protoBook._setData(\n            peerId,\n            new Set(decoded.protocols),\n            { emit: false })\n          break\n        default:\n          log('invalid data persisted for: ', key.toString())\n      }\n    } catch (err) {\n      log.error(err)\n    }\n  }\n}\n\nmodule.exports = PersistentPeerStore\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}