{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar PeerDistanceList = require('../peer-list/peer-distance-list');\n\nvar EventEmitter = require('events');\n\nvar Path = require('./path');\n\nvar WorkerQueue = require('./worker-queue');\n\nvar utils = require('../utils');\n/**\n * @typedef {import('peer-id')} PeerId\n */\n\n/**\n * Manages a single run of the query.\n */\n\n\nvar Run = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Run, _EventEmitter);\n\n  var _super = _createSuper(Run);\n\n  /**\n   * Creates a Run.\n   *\n   * @param {import('./index')} query\n   */\n  function Run(query) {\n    var _this;\n\n    _classCallCheck(this, Run);\n\n    _this = _super.call(this);\n    _this.query = query;\n    _this.running = false;\n    /** @type {WorkerQueue[]} */\n\n    _this.workers = []; // The peers that have been queried (including error responses)\n\n    _this.peersSeen = new Set(); // The errors received when querying peers\n\n    /** @type {Error[]} */\n\n    _this.errors = []; // The closest K peers that have been queried successfully\n    // (this member is initialized when the worker queues start)\n\n    /** @type {PeerDistanceList | null} */\n\n    _this.peersQueried = null;\n    return _this;\n  }\n  /**\n   * Stop all the workers\n   */\n\n\n  _createClass(Run, [{\n    key: \"stop\",\n    value: function stop() {\n      if (!this.running) {\n        return;\n      }\n\n      this.running = false;\n\n      var _iterator = _createForOfIteratorHelper(this.workers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var worker = _step.value;\n          worker.stop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Execute the run with the given initial set of peers.\n     *\n     * @param {PeerId[]} peers\n     */\n\n  }, {\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(peers) {\n        var paths, numPaths, i, res, _i, _paths, path;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                /** @type {import('./path')[]} */\n                paths = []; // array of states per disjoint path\n                // Create disjoint paths\n\n                numPaths = Math.min(this.query.dht.disjointPaths, peers.length);\n\n                for (i = 0; i < numPaths; i++) {\n                  paths.push(new Path(this, this.query.makePath(i, numPaths)));\n                } // Assign peers to paths round-robin style\n\n\n                peers.forEach(function (peer, i) {\n                  paths[i % numPaths].addInitialPeer(peer);\n                }); // Execute the query along each disjoint path\n\n                _context.next = 6;\n                return this.executePaths(paths);\n\n              case 6:\n                res = {\n                  // The closest K peers we were able to query successfully\n                  finalSet: new Set(this.peersQueried && this.peersQueried.peers),\n\n                  /** @type {import('./index').QueryResult[]} */\n                  paths: []\n                }; // Collect the results from each completed path\n\n                for (_i = 0, _paths = paths; _i < _paths.length; _i++) {\n                  path = _paths[_i];\n\n                  if (path.res && (path.res.pathComplete || path.res.queryComplete)) {\n                    path.res.success = true;\n                    res.paths.push(path.res);\n                  }\n                }\n\n                return _context.abrupt(\"return\", res);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function execute(_x) {\n        return _execute.apply(this, arguments);\n      }\n\n      return execute;\n    }()\n    /**\n     * Execute all paths through the DHT.\n     *\n     * @param {Array<Path>} paths\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"executePaths\",\n    value: function () {\n      var _executePaths = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(paths) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.running = true;\n                this.emit('start');\n                _context2.prev = 2;\n                _context2.next = 5;\n                return Promise.all(paths.map(function (path) {\n                  return path.execute();\n                }));\n\n              case 5:\n                _context2.prev = 5;\n                // Ensure all workers are stopped\n                this.stop(); // Completed the Run\n\n                this.emit('complete');\n                return _context2.finish(5);\n\n              case 9:\n                if (!(this.errors.length === this.peersSeen.size)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                throw this.errors[0];\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2,, 5, 9]]);\n      }));\n\n      function executePaths(_x2) {\n        return _executePaths.apply(this, arguments);\n      }\n\n      return executePaths;\n    }()\n    /**\n     * Initialize the list of queried peers, then start a worker queue for the\n     * given path.\n     *\n     * @param {Path} path\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"workerQueue\",\n    value: function () {\n      var _workerQueue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(path) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.init();\n\n              case 2:\n                _context3.next = 4;\n                return this.startWorker(path);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function workerQueue(_x3) {\n        return _workerQueue.apply(this, arguments);\n      }\n\n      return workerQueue;\n    }()\n    /**\n     * Create and start a worker queue for a particular path.\n     *\n     * @param {Path} path\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"startWorker\",\n    value: function () {\n      var _startWorker = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(path) {\n        var worker;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                worker = new WorkerQueue(this.query.dht, this, path, this.query._log);\n                this.workers.push(worker);\n                _context4.next = 4;\n                return worker.execute();\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function startWorker(_x4) {\n        return _startWorker.apply(this, arguments);\n      }\n\n      return startWorker;\n    }()\n    /**\n     * Initialize the list of closest peers we've queried - this is shared by all\n     * paths in the run.\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _this2 = this;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!this.peersQueried) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 2:\n                if (!this.peersQueriedPromise) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                _context6.next = 5;\n                return this.peersQueriedPromise;\n\n              case 5:\n                return _context6.abrupt(\"return\");\n\n              case 6:\n                // This promise is temporarily stored so that others may await its completion\n                this.peersQueriedPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n                  var dhtKey;\n                  return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                    while (1) {\n                      switch (_context5.prev = _context5.next) {\n                        case 0:\n                          _context5.next = 2;\n                          return utils.convertBuffer(_this2.query.key);\n\n                        case 2:\n                          dhtKey = _context5.sent;\n                          _this2.peersQueried = new PeerDistanceList(dhtKey, _this2.query.dht.kBucketSize);\n\n                        case 4:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }\n                  }, _callee5);\n                }))(); // After PeerDistanceList is initialized, clean up\n\n                _context6.next = 9;\n                return this.peersQueriedPromise;\n\n              case 9:\n                delete this.peersQueriedPromise;\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n    /**\n     * If we've queried K peers, and the remaining peers in the given `worker`'s queue\n     * are all further from the key than the peers we've already queried, then we should\n     * stop querying on that `worker`.\n     *\n     * @param {WorkerQueue} worker\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: \"continueQuerying\",\n    value: function () {\n      var _continueQuerying = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(worker) {\n        var running, someCloser;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(this.peersQueried && this.peersQueried.length < this.peersQueried.capacity)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", true);\n\n              case 2:\n                // Get all the peers that are currently being queried.\n                // Note that this function gets called right after a peer has been popped\n                // off the head of the closest peers queue so it will include that peer.\n                running = Array.from(worker.queuedPeerIds); // Check if any of the peers that are currently being queried are closer\n                // to the key than the peers we've already queried\n\n                _context7.t0 = this.peersQueried;\n\n                if (!_context7.t0) {\n                  _context7.next = 8;\n                  break;\n                }\n\n                _context7.next = 7;\n                return this.peersQueried.anyCloser(running);\n\n              case 7:\n                _context7.t0 = _context7.sent;\n\n              case 8:\n                someCloser = _context7.t0;\n\n                if (!someCloser) {\n                  _context7.next = 11;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", true);\n\n              case 11:\n                return _context7.abrupt(\"return\", false);\n\n              case 12:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function continueQuerying(_x5) {\n        return _continueQuerying.apply(this, arguments);\n      }\n\n      return continueQuerying;\n    }()\n  }]);\n\n  return Run;\n}(EventEmitter);\n\nmodule.exports = Run;","map":{"version":3,"names":["PeerDistanceList","require","EventEmitter","Path","WorkerQueue","utils","Run","query","running","workers","peersSeen","Set","errors","peersQueried","worker","stop","peers","paths","numPaths","Math","min","dht","disjointPaths","length","i","push","makePath","forEach","peer","addInitialPeer","executePaths","res","finalSet","path","pathComplete","queryComplete","success","emit","Promise","all","map","execute","size","init","startWorker","_log","peersQueriedPromise","convertBuffer","key","dhtKey","kBucketSize","capacity","Array","from","queuedPeerIds","anyCloser","someCloser","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-kad-dht/src/query/run.js"],"sourcesContent":["'use strict'\n\nconst PeerDistanceList = require('../peer-list/peer-distance-list')\nconst EventEmitter = require('events')\n\nconst Path = require('./path')\nconst WorkerQueue = require('./worker-queue')\nconst utils = require('../utils')\n\n/**\n * @typedef {import('peer-id')} PeerId\n */\n\n/**\n * Manages a single run of the query.\n */\nclass Run extends EventEmitter {\n  /**\n   * Creates a Run.\n   *\n   * @param {import('./index')} query\n   */\n  constructor (query) {\n    super()\n\n    this.query = query\n\n    this.running = false\n\n    /** @type {WorkerQueue[]} */\n    this.workers = []\n\n    // The peers that have been queried (including error responses)\n    this.peersSeen = new Set()\n\n    // The errors received when querying peers\n    /** @type {Error[]} */\n    this.errors = []\n\n    // The closest K peers that have been queried successfully\n    // (this member is initialized when the worker queues start)\n    /** @type {PeerDistanceList | null} */\n    this.peersQueried = null\n  }\n\n  /**\n   * Stop all the workers\n   */\n  stop () {\n    if (!this.running) {\n      return\n    }\n\n    this.running = false\n    for (const worker of this.workers) {\n      worker.stop()\n    }\n  }\n\n  /**\n   * Execute the run with the given initial set of peers.\n   *\n   * @param {PeerId[]} peers\n   */\n  async execute (peers) {\n    /** @type {import('./path')[]} */\n    const paths = [] // array of states per disjoint path\n\n    // Create disjoint paths\n    const numPaths = Math.min(this.query.dht.disjointPaths, peers.length)\n    for (let i = 0; i < numPaths; i++) {\n      paths.push(new Path(this, this.query.makePath(i, numPaths)))\n    }\n\n    // Assign peers to paths round-robin style\n    peers.forEach((peer, i) => {\n      paths[i % numPaths].addInitialPeer(peer)\n    })\n\n    // Execute the query along each disjoint path\n    await this.executePaths(paths)\n\n    const res = {\n      // The closest K peers we were able to query successfully\n      finalSet: new Set(this.peersQueried && this.peersQueried.peers),\n\n      /** @type {import('./index').QueryResult[]} */\n      paths: []\n    }\n\n    // Collect the results from each completed path\n    for (const path of paths) {\n      if (path.res && (path.res.pathComplete || path.res.queryComplete)) {\n        path.res.success = true\n        res.paths.push(path.res)\n      }\n    }\n\n    return res\n  }\n\n  /**\n   * Execute all paths through the DHT.\n   *\n   * @param {Array<Path>} paths\n   * @returns {Promise<void>}\n   */\n  async executePaths (paths) {\n    this.running = true\n\n    this.emit('start')\n    try {\n      await Promise.all(paths.map(path => path.execute()))\n    } finally {\n      // Ensure all workers are stopped\n      this.stop()\n      // Completed the Run\n      this.emit('complete')\n    }\n\n    // If all queries errored out, something is seriously wrong, so callback\n    // with an error\n    if (this.errors.length === this.peersSeen.size) {\n      throw this.errors[0]\n    }\n  }\n\n  /**\n   * Initialize the list of queried peers, then start a worker queue for the\n   * given path.\n   *\n   * @param {Path} path\n   * @returns {Promise<void>}\n   */\n  async workerQueue (path) {\n    await this.init()\n    await this.startWorker(path)\n  }\n\n  /**\n   * Create and start a worker queue for a particular path.\n   *\n   * @param {Path} path\n   * @returns {Promise<void>}\n   */\n  async startWorker (path) {\n    const worker = new WorkerQueue(this.query.dht, this, path, this.query._log)\n    this.workers.push(worker)\n    await worker.execute()\n  }\n\n  /**\n   * Initialize the list of closest peers we've queried - this is shared by all\n   * paths in the run.\n   *\n   * @returns {Promise<void>}\n   */\n  async init () {\n    if (this.peersQueried) {\n      return\n    }\n\n    // We only want to initialize the PeerDistanceList once for the run\n    if (this.peersQueriedPromise) {\n      await this.peersQueriedPromise\n      return\n    }\n\n    // This promise is temporarily stored so that others may await its completion\n    this.peersQueriedPromise = (async () => {\n      const dhtKey = await utils.convertBuffer(this.query.key)\n      this.peersQueried = new PeerDistanceList(dhtKey, this.query.dht.kBucketSize)\n    })()\n\n    // After PeerDistanceList is initialized, clean up\n    await this.peersQueriedPromise\n    delete this.peersQueriedPromise\n  }\n\n  /**\n   * If we've queried K peers, and the remaining peers in the given `worker`'s queue\n   * are all further from the key than the peers we've already queried, then we should\n   * stop querying on that `worker`.\n   *\n   * @param {WorkerQueue} worker\n   * @returns {Promise<boolean>}\n   */\n  async continueQuerying (worker) {\n    // If we haven't queried K peers yet, keep going\n    if (this.peersQueried && this.peersQueried.length < this.peersQueried.capacity) {\n      return true\n    }\n\n    // Get all the peers that are currently being queried.\n    // Note that this function gets called right after a peer has been popped\n    // off the head of the closest peers queue so it will include that peer.\n    const running = Array.from(worker.queuedPeerIds)\n\n    // Check if any of the peers that are currently being queried are closer\n    // to the key than the peers we've already queried\n    const someCloser = this.peersQueried && await this.peersQueried.anyCloser(running)\n\n    // Some are closer, the worker should keep going\n    if (someCloser) {\n      return true\n    }\n\n    // None are closer, the worker can stop\n    return false\n  }\n}\n\nmodule.exports = Run\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}