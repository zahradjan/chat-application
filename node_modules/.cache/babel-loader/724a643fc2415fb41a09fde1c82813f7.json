{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst {\n  Key,\n  Errors\n} = require('interface-datastore');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns:publisher'), {\n  error: debug('ipfs:ipns:publisher:error')\n});\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst ipns = require('ipns');\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n */\n\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultRecordLifetime = 60 * 60 * 1000; // IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\n\nclass IpnsPublisher {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor(routing, datastore) {\n    this._routing = routing;\n    this._datastore = datastore;\n  }\n  /**\n   * Publish record with a eol\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n\n\n  async publishWithEOL(privKey, value, lifetime) {\n    if (!privKey || !privKey.bytes) {\n      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n    }\n\n    const peerId = await PeerId.createFromPrivKey(privKey.bytes);\n    const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId);\n    return this._putRecordToRouting(record, peerId);\n  }\n  /**\n   * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n\n\n  publish(privKey, value) {\n    return this.publishWithEOL(privKey, value, defaultRecordLifetime);\n  }\n  /**\n   * @param {IPNSEntry} record\n   * @param {PeerId} peerId\n   */\n\n\n  async _putRecordToRouting(record, peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    } // @ts-ignore - accessing private property isn't allowed\n\n\n    const publicKey = peerId._pubKey;\n    const embedPublicKeyRecord = await ipns.embedPublicKey(publicKey, record);\n    const keys = ipns.getIdKeys(peerId.toBytes());\n    await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record); // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n    // We will be able to deprecate this part in the future, since the public keys will be only\n    // in IPNS record and the peerId.\n\n    await this._publishPublicKey(keys.routingPubKey, publicKey);\n    return embedPublicKeyRecord || record;\n  }\n  /**\n   * @param {Key} key\n   * @param {IPNSEntry} entry\n   */\n\n\n  async _publishEntry(key, entry) {\n    const k = Key.asKey(key);\n\n    if (!k) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    let entryData;\n\n    try {\n      // Marshal record\n      entryData = ipns.marshal(entry);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    } // Add record to routing (buffer key)\n\n\n    try {\n      const res = await this._routing.put(k.uint8Array(), entryData);\n      log(`ipns record for ${uint8ArrayToString(k.uint8Array(), 'base64')} was stored in the routing`);\n      return res;\n    } catch (err) {\n      const errMsg = `ipns record for ${uint8ArrayToString(k.uint8Array(), 'base64')} could not be stored in the routing`;\n      log.error(errMsg);\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n    }\n  }\n  /**\n   * @param {Key} key\n   * @param {PublicKey} publicKey\n   */\n\n\n  async _publishPublicKey(key, publicKey) {\n    const k = Key.asKey(key);\n\n    if (!k) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    if (!publicKey || !publicKey.bytes) {\n      const errMsg = 'one or more of the provided parameters are not defined';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER');\n    } // Add public key to routing (buffer key)\n\n\n    try {\n      const res = await this._routing.put(k.uint8Array(), publicKey.bytes);\n      log(`public key for ${uint8ArrayToString(k.uint8Array(), 'base64')} was stored in the routing`);\n      return res;\n    } catch (err) {\n      const errMsg = `public key for ${uint8ArrayToString(k.uint8Array(), 'base64')} could not be stored in the routing`;\n      log.error(errMsg);\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n    }\n  }\n  /**\n   * Returns the record this node has published corresponding to the given peer ID.\n   *\n   * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n   *\n   * @param {PeerId} peerId\n   * @param {object} options\n   * @param {boolean} [options.checkRouting]\n   */\n\n\n  async _getPublished(peerId) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!PeerId.isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    const checkRouting = options.checkRouting !== false;\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id)); // unmarshal data\n\n      return this._unmarshalData(dsVal);\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');\n      }\n\n      if (!checkRouting) {\n        throw errcode(err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED');\n      } // Try to get from routing\n\n\n      try {\n        const keys = ipns.getIdKeys(peerId.toBytes());\n        const res = await this._routing.get(keys.routingKey.uint8Array()); // unmarshal data\n\n        return this._unmarshalData(res);\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n    }\n  }\n  /**\n   * @param {Uint8Array} data\n   */\n\n\n  _unmarshalData(data) {\n    try {\n      return ipns.unmarshal(data);\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA');\n    }\n  }\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {PeerId} peerId\n   */\n\n\n  async _updateOrCreateRecord(privKey, value, lifetime, peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    };\n    let record;\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions);\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id} ${err.stack}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD');\n      }\n    } // Determinate the record sequence number\n\n\n    let seqNumber = 0n;\n\n    if (record && record.sequence !== undefined) {\n      seqNumber = !uint8ArrayEquals(record.value, value) ? BigInt(record.sequence) + 1n : BigInt(record.sequence);\n    }\n\n    let entryData;\n\n    try {\n      // Create record\n      entryData = await ipns.create(privKey, value, seqNumber, lifetime);\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be created`;\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD');\n    } // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData); // Store the new record\n\n      await this._datastore.put(ipns.getLocalKey(peerId.id), data);\n      log(`ipns record for ${uint8ArrayToString(value, 'base32')} was stored in the datastore`);\n      return entryData;\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE');\n    }\n  }\n\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;\nexports = module.exports = IpnsPublisher;","map":{"version":3,"names":["PeerId","require","Key","Errors","errcode","debug","log","Object","assign","error","toString","uint8ArrayToString","equals","uint8ArrayEquals","ipns","ERR_NOT_FOUND","notFoundError","code","defaultRecordLifetime","IpnsPublisher","constructor","routing","datastore","_routing","_datastore","publishWithEOL","privKey","value","lifetime","bytes","Error","peerId","createFromPrivKey","record","_updateOrCreateRecord","_putRecordToRouting","publish","isPeerId","errMsg","publicKey","_pubKey","embedPublicKeyRecord","embedPublicKey","keys","getIdKeys","toBytes","_publishEntry","routingKey","_publishPublicKey","routingPubKey","key","entry","k","asKey","entryData","marshal","err","res","put","uint8Array","_getPublished","options","checkRouting","dsVal","get","getLocalKey","id","_unmarshalData","data","unmarshal","getPublishedOptions","stack","seqNumber","sequence","undefined","BigInt","create","exports","module"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/ipns/publisher.js"],"sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { Key, Errors } = require('interface-datastore')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns:publisher'), {\n  error: debug('ipfs:ipns:publisher:error')\n})\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\n\nconst ipns = require('ipns')\n\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n */\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst defaultRecordLifetime = 60 * 60 * 1000\n\n// IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\nclass IpnsPublisher {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor (routing, datastore) {\n    this._routing = routing\n    this._datastore = datastore\n  }\n\n  /**\n   * Publish record with a eol\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n  async publishWithEOL (privKey, value, lifetime) {\n    if (!privKey || !privKey.bytes) {\n      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY')\n    }\n\n    const peerId = await PeerId.createFromPrivKey(privKey.bytes)\n    const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId)\n\n    return this._putRecordToRouting(record, peerId)\n  }\n\n  /**\n   * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n  publish (privKey, value) {\n    return this.publishWithEOL(privKey, value, defaultRecordLifetime)\n  }\n\n  /**\n   * @param {IPNSEntry} record\n   * @param {PeerId} peerId\n   */\n  async _putRecordToRouting (record, peerId) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    // @ts-ignore - accessing private property isn't allowed\n    const publicKey = peerId._pubKey\n    const embedPublicKeyRecord = await ipns.embedPublicKey(publicKey, record)\n    const keys = ipns.getIdKeys(peerId.toBytes())\n\n    await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record)\n\n    // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n    // We will be able to deprecate this part in the future, since the public keys will be only\n    // in IPNS record and the peerId.\n    await this._publishPublicKey(keys.routingPubKey, publicKey)\n\n    return embedPublicKeyRecord || record\n  }\n\n  /**\n   * @param {Key} key\n   * @param {IPNSEntry} entry\n   */\n  async _publishEntry (key, entry) {\n    const k = Key.asKey(key)\n\n    if (!k) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    let entryData\n    try {\n      // Marshal record\n      entryData = ipns.marshal(entry)\n    } catch (err) {\n      log.error(err)\n\n      throw err\n    }\n\n    // Add record to routing (buffer key)\n    try {\n      const res = await this._routing.put(k.uint8Array(), entryData)\n      log(`ipns record for ${uint8ArrayToString(k.uint8Array(), 'base64')} was stored in the routing`)\n\n      return res\n    } catch (err) {\n      const errMsg = `ipns record for ${uint8ArrayToString(k.uint8Array(), 'base64')} could not be stored in the routing`\n      log.error(errMsg)\n      log.error(err)\n\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING')\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {PublicKey} publicKey\n   */\n  async _publishPublicKey (key, publicKey) {\n    const k = Key.asKey(key)\n\n    if (!k) {\n      const errMsg = 'datastore key does not have a valid format'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!publicKey || !publicKey.bytes) {\n      const errMsg = 'one or more of the provided parameters are not defined'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER')\n    }\n\n    // Add public key to routing (buffer key)\n    try {\n      const res = await this._routing.put(k.uint8Array(), publicKey.bytes)\n      log(`public key for ${uint8ArrayToString(k.uint8Array(), 'base64')} was stored in the routing`)\n\n      return res\n    } catch (err) {\n      const errMsg = `public key for ${uint8ArrayToString(k.uint8Array(), 'base64')} could not be stored in the routing`\n      log.error(errMsg)\n      log.error(err)\n\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING')\n    }\n  }\n\n  /**\n   * Returns the record this node has published corresponding to the given peer ID.\n   *\n   * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n   *\n   * @param {PeerId} peerId\n   * @param {object} options\n   * @param {boolean} [options.checkRouting]\n   */\n  async _getPublished (peerId, options = {}) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const checkRouting = options.checkRouting !== false\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id))\n\n      // unmarshal data\n      return this._unmarshalData(dsVal)\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE')\n      }\n\n      if (!checkRouting) {\n        throw errcode(err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED')\n      }\n\n      // Try to get from routing\n      try {\n        const keys = ipns.getIdKeys(peerId.toBytes())\n        const res = await this._routing.get(keys.routingKey.uint8Array())\n\n        // unmarshal data\n        return this._unmarshalData(res)\n      } catch (err) {\n        log.error(err)\n\n        throw err\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  _unmarshalData (data) {\n    try {\n      return ipns.unmarshal(data)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA')\n    }\n  }\n\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {PeerId} peerId\n   */\n  async _updateOrCreateRecord (privKey, value, lifetime, peerId) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    }\n\n    let record\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions)\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id} ${err.stack}`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD')\n      }\n    }\n\n    // Determinate the record sequence number\n    let seqNumber = 0n\n\n    if (record && record.sequence !== undefined) {\n      seqNumber = !uint8ArrayEquals(record.value, value) ? BigInt(record.sequence) + 1n : BigInt(record.sequence)\n    }\n\n    let entryData\n\n    try {\n      // Create record\n      entryData = await ipns.create(privKey, value, seqNumber, lifetime)\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be created`\n\n      log.error(err)\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD')\n    }\n\n    // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData)\n\n      // Store the new record\n      await this._datastore.put(ipns.getLocalKey(peerId.id), data)\n\n      log(`ipns record for ${uint8ArrayToString(value, 'base32')} was stored in the datastore`)\n\n      return entryData\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE')\n    }\n  }\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime\nexports = module.exports = IpnsPublisher\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}