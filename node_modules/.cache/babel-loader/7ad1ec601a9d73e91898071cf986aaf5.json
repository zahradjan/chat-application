{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar abortable = require('abortable-iterator');\n\nvar log = require('debug')('libp2p:mplex:stream');\n\nvar pushable = require('it-pushable');\n\nvar BufferList = require('bl/BufferList');\n\nvar errCode = require('err-code');\n\nvar _require = require('./restrict-size'),\n    MAX_MSG_SIZE = _require.MAX_MSG_SIZE;\n\nvar _require2 = require('./message-types'),\n    InitiatorMessageTypes = _require2.InitiatorMessageTypes,\n    ReceiverMessageTypes = _require2.ReceiverMessageTypes;\n\nvar ERR_MPLEX_STREAM_RESET = 'ERR_MPLEX_STREAM_RESET';\nvar ERR_MPLEX_STREAM_ABORT = 'ERR_MPLEX_STREAM_ABORT';\n/**\n * @param {object} options\n * @param {number} options.id\n * @param {string} options.name\n * @param {function(*)} options.send - Called to send data through the stream\n * @param {function(Error)} [options.onEnd] - Called whenever the stream ends\n * @param {string} [options.type] - One of ['initiator','receiver']. Defaults to 'initiator'\n * @param {number} [options.maxMsgSize] - Max size of an mplex message in bytes. Writes > size are automatically split. Defaults to 1MB\n * @returns {*} A muxed stream\n */\n\nmodule.exports = function (_ref) {\n  var id = _ref.id,\n      name = _ref.name,\n      send = _ref.send,\n      _ref$onEnd = _ref.onEnd,\n      onEnd = _ref$onEnd === void 0 ? function () {} : _ref$onEnd,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? 'initiator' : _ref$type,\n      _ref$maxMsgSize = _ref.maxMsgSize,\n      maxMsgSize = _ref$maxMsgSize === void 0 ? MAX_MSG_SIZE : _ref$maxMsgSize;\n  var abortController = new AbortController();\n  var resetController = new AbortController();\n  var Types = type === 'initiator' ? InitiatorMessageTypes : ReceiverMessageTypes;\n  var externalId = type === 'initiator' ? \"i\".concat(id) : \"r\".concat(id);\n  name = String(name == null ? id : name);\n  var sourceEnded = false;\n  var sinkEnded = false;\n  var endErr;\n\n  var onSourceEnd = function onSourceEnd(err) {\n    if (sourceEnded) return;\n    sourceEnded = true;\n    log('%s stream %s source end', type, name, err);\n    if (err && !endErr) endErr = err;\n\n    if (sinkEnded) {\n      stream.timeline.close = Date.now();\n      onEnd(endErr);\n    }\n  };\n\n  var onSinkEnd = function onSinkEnd(err) {\n    if (sinkEnded) return;\n    sinkEnded = true;\n    log('%s stream %s sink end', type, name, err);\n    if (err && !endErr) endErr = err;\n\n    if (sourceEnded) {\n      stream.timeline.close = Date.now();\n      onEnd(endErr);\n    }\n  };\n\n  var stream = {\n    // Close for reading\n    close: function close() {\n      return stream.source.end();\n    },\n    // Close for reading and writing (local error)\n    abort: function abort(err) {\n      log('%s stream %s abort', type, name, err); // End the source with the passed error\n\n      stream.source.end(err);\n      abortController.abort();\n      onSinkEnd(err);\n    },\n    // Close immediately for reading and writing (remote error)\n    reset: function reset() {\n      var err = errCode(new Error('stream reset'), ERR_MPLEX_STREAM_RESET);\n      resetController.abort();\n      stream.source.end(err);\n      onSinkEnd(err);\n    },\n    sink: function () {\n      var _sink = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, data;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                source = abortable(source, [{\n                  signal: abortController.signal,\n                  options: {\n                    abortMessage: 'stream aborted',\n                    abortCode: ERR_MPLEX_STREAM_ABORT\n                  }\n                }, {\n                  signal: resetController.signal,\n                  options: {\n                    abortMessage: 'stream reset',\n                    abortCode: ERR_MPLEX_STREAM_RESET\n                  }\n                }]);\n\n                if (type === 'initiator') {\n                  // If initiator, open a new stream\n                  send({\n                    id: id,\n                    type: Types.NEW_STREAM,\n                    data: name\n                  });\n                }\n\n                _context.prev = 2;\n                _iteratorAbruptCompletion = false;\n                _didIteratorError = false;\n                _context.prev = 5;\n                _iterator = _asyncIterator(source);\n\n              case 7:\n                _context.next = 9;\n                return _iterator.next();\n\n              case 9:\n                if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                  _context.next = 23;\n                  break;\n                }\n\n                data = _step.value;\n\n              case 11:\n                if (!data.length) {\n                  _context.next = 20;\n                  break;\n                }\n\n                if (!(data.length <= maxMsgSize)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                send({\n                  id: id,\n                  type: Types.MESSAGE,\n                  data: data\n                });\n                return _context.abrupt(\"break\", 20);\n\n              case 15:\n                data = BufferList.isBufferList(data) ? data : new BufferList(data);\n                send({\n                  id: id,\n                  type: Types.MESSAGE,\n                  data: data.shallowSlice(0, maxMsgSize)\n                });\n                data.consume(maxMsgSize);\n                _context.next = 11;\n                break;\n\n              case 20:\n                _iteratorAbruptCompletion = false;\n                _context.next = 7;\n                break;\n\n              case 23:\n                _context.next = 29;\n                break;\n\n              case 25:\n                _context.prev = 25;\n                _context.t0 = _context[\"catch\"](5);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 29:\n                _context.prev = 29;\n                _context.prev = 30;\n\n                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                  _context.next = 34;\n                  break;\n                }\n\n                _context.next = 34;\n                return _iterator.return();\n\n              case 34:\n                _context.prev = 34;\n\n                if (!_didIteratorError) {\n                  _context.next = 37;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 37:\n                return _context.finish(34);\n\n              case 38:\n                return _context.finish(29);\n\n              case 39:\n                _context.next = 46;\n                break;\n\n              case 41:\n                _context.prev = 41;\n                _context.t1 = _context[\"catch\"](2);\n\n                // Send no more data if this stream was remotely reset\n                if (_context.t1.code === ERR_MPLEX_STREAM_RESET) {\n                  log('%s stream %s reset', type, name);\n                } else {\n                  log('%s stream %s error', type, name, _context.t1);\n                  send({\n                    id: id,\n                    type: Types.RESET\n                  });\n                }\n\n                stream.source.end(_context.t1);\n                return _context.abrupt(\"return\", onSinkEnd(_context.t1));\n\n              case 46:\n                send({\n                  id: id,\n                  type: Types.CLOSE\n                });\n                onSinkEnd();\n\n              case 48:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 41], [5, 25, 29, 39], [30,, 34, 38]]);\n      }));\n\n      function sink(_x) {\n        return _sink.apply(this, arguments);\n      }\n\n      return sink;\n    }(),\n    source: pushable(onSourceEnd),\n    timeline: {\n      open: Date.now(),\n      close: null\n    },\n    id: externalId\n  };\n  return stream;\n};","map":{"version":3,"names":["abortable","require","log","pushable","BufferList","errCode","MAX_MSG_SIZE","InitiatorMessageTypes","ReceiverMessageTypes","ERR_MPLEX_STREAM_RESET","ERR_MPLEX_STREAM_ABORT","module","exports","id","name","send","onEnd","type","maxMsgSize","abortController","AbortController","resetController","Types","externalId","String","sourceEnded","sinkEnded","endErr","onSourceEnd","err","stream","timeline","close","Date","now","onSinkEnd","source","end","abort","reset","Error","sink","signal","options","abortMessage","abortCode","NEW_STREAM","data","length","MESSAGE","isBufferList","shallowSlice","consume","code","RESET","CLOSE","open"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-mplex/src/stream.js"],"sourcesContent":["'use strict'\n\nconst abortable = require('abortable-iterator')\nconst log = require('debug')('libp2p:mplex:stream')\nconst pushable = require('it-pushable')\nconst BufferList = require('bl/BufferList')\nconst errCode = require('err-code')\nconst { MAX_MSG_SIZE } = require('./restrict-size')\nconst { InitiatorMessageTypes, ReceiverMessageTypes } = require('./message-types')\n\nconst ERR_MPLEX_STREAM_RESET = 'ERR_MPLEX_STREAM_RESET'\nconst ERR_MPLEX_STREAM_ABORT = 'ERR_MPLEX_STREAM_ABORT'\n\n/**\n * @param {object} options\n * @param {number} options.id\n * @param {string} options.name\n * @param {function(*)} options.send - Called to send data through the stream\n * @param {function(Error)} [options.onEnd] - Called whenever the stream ends\n * @param {string} [options.type] - One of ['initiator','receiver']. Defaults to 'initiator'\n * @param {number} [options.maxMsgSize] - Max size of an mplex message in bytes. Writes > size are automatically split. Defaults to 1MB\n * @returns {*} A muxed stream\n */\nmodule.exports = ({ id, name, send, onEnd = () => {}, type = 'initiator', maxMsgSize = MAX_MSG_SIZE }) => {\n  const abortController = new AbortController()\n  const resetController = new AbortController()\n  const Types = type === 'initiator' ? InitiatorMessageTypes : ReceiverMessageTypes\n  const externalId = type === 'initiator' ? (`i${id}`) : `r${id}`\n\n  name = String(name == null ? id : name)\n\n  let sourceEnded = false\n  let sinkEnded = false\n  let endErr\n\n  const onSourceEnd = err => {\n    if (sourceEnded) return\n    sourceEnded = true\n    log('%s stream %s source end', type, name, err)\n    if (err && !endErr) endErr = err\n    if (sinkEnded) {\n      stream.timeline.close = Date.now()\n      onEnd(endErr)\n    }\n  }\n\n  const onSinkEnd = err => {\n    if (sinkEnded) return\n    sinkEnded = true\n    log('%s stream %s sink end', type, name, err)\n    if (err && !endErr) endErr = err\n    if (sourceEnded) {\n      stream.timeline.close = Date.now()\n      onEnd(endErr)\n    }\n  }\n\n  const stream = {\n    // Close for reading\n    close: () => stream.source.end(),\n    // Close for reading and writing (local error)\n    abort: err => {\n      log('%s stream %s abort', type, name, err)\n      // End the source with the passed error\n      stream.source.end(err)\n      abortController.abort()\n      onSinkEnd(err)\n    },\n    // Close immediately for reading and writing (remote error)\n    reset: () => {\n      const err = errCode(new Error('stream reset'), ERR_MPLEX_STREAM_RESET)\n      resetController.abort()\n      stream.source.end(err)\n      onSinkEnd(err)\n    },\n    sink: async source => {\n      source = abortable(source, [\n        { signal: abortController.signal, options: { abortMessage: 'stream aborted', abortCode: ERR_MPLEX_STREAM_ABORT } },\n        { signal: resetController.signal, options: { abortMessage: 'stream reset', abortCode: ERR_MPLEX_STREAM_RESET } }\n      ])\n\n      if (type === 'initiator') { // If initiator, open a new stream\n        send({ id, type: Types.NEW_STREAM, data: name })\n      }\n\n      try {\n        for await (let data of source) {\n          while (data.length) {\n            if (data.length <= maxMsgSize) {\n              send({ id, type: Types.MESSAGE, data })\n              break\n            }\n            data = BufferList.isBufferList(data) ? data : new BufferList(data)\n            send({ id, type: Types.MESSAGE, data: data.shallowSlice(0, maxMsgSize) })\n            data.consume(maxMsgSize)\n          }\n        }\n      } catch (err) {\n        // Send no more data if this stream was remotely reset\n        if (err.code === ERR_MPLEX_STREAM_RESET) {\n          log('%s stream %s reset', type, name)\n        } else {\n          log('%s stream %s error', type, name, err)\n          send({ id, type: Types.RESET })\n        }\n\n        stream.source.end(err)\n        return onSinkEnd(err)\n      }\n\n      send({ id, type: Types.CLOSE })\n      onSinkEnd()\n    },\n    source: pushable(onSourceEnd),\n    timeline: {\n      open: Date.now(),\n      close: null\n    },\n    id: externalId\n  }\n\n  return stream\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}