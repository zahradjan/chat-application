{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decryptStream = exports.encryptStream = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst constants_1 = require(\"./constants\"); // Returns generator that encrypts payload from the user\n\n\nfunction encryptStream(handshake) {\n  return async function* (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n        let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n        yield data;\n      }\n    }\n  };\n}\n\nexports.encryptStream = encryptStream; // Decrypt received payload to the user\n\nfunction decryptStream(handshake) {\n  return async function* (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {\n        let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;\n\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const chunk = chunkBuffer.slice(i, end);\n        const {\n          plaintext: decrypted,\n          valid\n        } = await handshake.decrypt(chunk, handshake.session);\n\n        if (!valid) {\n          throw new Error('Failed to validate decrypted chunk');\n        }\n\n        yield decrypted;\n      }\n    }\n  };\n}\n\nexports.decryptStream = decryptStream;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAEA,2C,CAMA;;;AACA,SAAgBA,aAAhB,CAA+BC,SAA/B,EAAoD;EAClD,OAAO,iBAAkBC,MAAlB,EAAwB;IAC7B,WAAW,MAAMC,KAAjB,IAA0BD,MAA1B,EAAkC;MAChC,MAAME,WAAW,GAAGC,gBAAOC,IAAP,CAAYH,KAAK,CAACI,MAAlB,EAA0BJ,KAAK,CAACK,UAAhC,EAA4CL,KAAK,CAACM,MAAlD,CAApB;;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,WAAW,CAACK,MAAhC,EAAwCC,CAAC,IAAIC,kDAA7C,EAAqF;QACnF,IAAIC,GAAG,GAAGF,CAAC,GAAGC,kDAAd;;QACA,IAAIC,GAAG,GAAGR,WAAW,CAACK,MAAtB,EAA8B;UAC5BG,GAAG,GAAGR,WAAW,CAACK,MAAlB;QACD;;QAED,MAAMI,IAAI,GAAGZ,SAAS,CAACa,OAAV,CAAkBV,WAAW,CAACW,KAAZ,CAAkBL,CAAlB,EAAqBE,GAArB,CAAlB,EAA6CX,SAAS,CAACe,OAAvD,CAAb;QACA,MAAMH,IAAN;MACD;IACF;EACF,CAdD;AAeD;;AAhBDI,sC,CAkBA;;AACA,SAAgBC,aAAhB,CAA+BjB,SAA/B,EAAoD;EAClD,OAAO,iBAAkBC,MAAlB,EAAwB;IAC7B,WAAW,MAAMC,KAAjB,IAA0BD,MAA1B,EAAkC;MAChC,MAAME,WAAW,GAAGC,gBAAOC,IAAP,CAAYH,KAAK,CAACI,MAAlB,EAA0BJ,KAAK,CAACK,UAAhC,EAA4CL,KAAK,CAACM,MAAlD,CAApB;;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,WAAW,CAACK,MAAhC,EAAwCC,CAAC,IAAIC,sCAA7C,EAAyE;QACvE,IAAIC,GAAG,GAAGF,CAAC,GAAGC,sCAAd;;QACA,IAAIC,GAAG,GAAGR,WAAW,CAACK,MAAtB,EAA8B;UAC5BG,GAAG,GAAGR,WAAW,CAACK,MAAlB;QACD;;QAED,MAAMN,KAAK,GAAGC,WAAW,CAACW,KAAZ,CAAkBL,CAAlB,EAAqBE,GAArB,CAAd;QACA,MAAM;UAAEO,SAAS,EAAEC,SAAb;UAAwBC;QAAxB,IAAkC,MAAMpB,SAAS,CAACqB,OAAV,CAAkBnB,KAAlB,EAAyBF,SAAS,CAACe,OAAnC,CAA9C;;QACA,IAAI,CAACK,KAAL,EAAY;UACV,MAAM,IAAIE,KAAJ,CAAU,oCAAV,CAAN;QACD;;QACD,MAAMH,SAAN;MACD;IACF;EACF,CAlBD;AAmBD;;AApBDH","names":["encryptStream","handshake","source","chunk","chunkBuffer","buffer_1","from","buffer","byteOffset","length","i","constants_1","end","data","encrypt","slice","session","exports","decryptStream","plaintext","decrypted","valid","decrypt","Error"],"sourceRoot":"","sources":["../../src/crypto.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}