{"ast":null,"code":"'use strict';\n\nconst WantManager = require('./want-manager');\n\nconst Network = require('./network');\n\nconst DecisionEngine = require('./decision-engine');\n\nconst Notifications = require('./notifications');\n\nconst logger = require('./utils').logger;\n\nconst Stats = require('./stats');\n\nconst {\n  AbortController\n} = require('native-abort-controller');\n\nconst {\n  anySignal\n} = require('any-signal');\n\nconst {\n  BlockstoreAdapter\n} = require('interface-blockstore');\n\nconst {\n  CID\n} = require('multiformats');\n/**\n * @typedef {import('./types').IPFSBitswap} IPFSBitswap\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types/message')} BitswapMessage\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n */\n\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nconst statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @implements {IPFSBitswap}\n */\n\nclass Bitswap extends BlockstoreAdapter {\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {Blockstore} blockstore\n   * @param {Object} [options]\n   * @param {boolean} [options.statsEnabled=false]\n   * @param {number} [options.statsComputeThrottleTimeout=1000]\n   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  constructor(libp2p, blockstore) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this._libp2p = libp2p;\n    this._log = logger(this.peerId);\n    this._options = Object.assign({}, defaultOptions, options); // stats\n\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    }); // the network delivers messages\n\n    this.network = new Network(libp2p, this, this._stats, {\n      hashers: options.hashers\n    }); // local database\n\n    this.blockstore = blockstore;\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats); // handle message sending\n\n    this.wm = new WantManager(this.peerId, this.network, this._stats);\n    this.notifications = new Notifications(this.peerId);\n    this.started = false;\n  }\n\n  isStarted() {\n    return this.started;\n  }\n  /**\n   * @type {PeerId}\n   */\n\n\n  get peerId() {\n    return this._libp2p.peerId;\n  }\n  /**\n   * handle messages received through the network\n   *\n   * @param {PeerId} peerId\n   * @param {BitswapMessage} incoming\n   */\n\n\n  async _receiveMessage(peerId, incoming) {\n    try {\n      // Note: this allows the engine to respond to any wants in the message.\n      // Processing of the blocks in the message happens below, after the\n      // blocks have been added to the blockstore.\n      await this.engine.messageReceived(peerId, incoming);\n    } catch (err) {\n      // Log instead of throwing an error so as to process as much as\n      // possible of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming);\n    }\n\n    if (incoming.blocks.size === 0) {\n      return;\n    }\n    /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n\n\n    const received = [];\n\n    for (const [cidStr, data] of incoming.blocks.entries()) {\n      const cid = CID.parse(cidStr);\n      received.push({\n        wasWanted: this.wm.wantlist.contains(cid),\n        cid,\n        data\n      });\n    } // quickly send out cancels, reduces chances of duplicate block receives\n\n\n    this.wm.cancelWants(received.filter(_ref => {\n      let {\n        wasWanted\n      } = _ref;\n      return wasWanted;\n    }).map(_ref2 => {\n      let {\n        cid\n      } = _ref2;\n      return cid;\n    }));\n    await Promise.all(received.map(_ref3 => {\n      let {\n        cid,\n        wasWanted,\n        data\n      } = _ref3;\n      return this._handleReceivedBlock(peerId, cid, data, wasWanted);\n    }));\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} wasWanted\n   */\n\n\n  async _handleReceivedBlock(peerId, cid, data, wasWanted) {\n    this._log('received block');\n\n    const has = await this.blockstore.has(cid);\n\n    this._updateReceiveCounters(peerId.toB58String(), cid, data, has);\n\n    if (!wasWanted) {\n      return;\n    }\n\n    await this.put(cid, data);\n  }\n  /**\n   * @private\n   * @param {string} peerIdStr\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} exists\n   */\n\n\n  _updateReceiveCounters(peerIdStr, cid, data, exists) {\n    this._stats.push(peerIdStr, 'blocksReceived', 1);\n\n    this._stats.push(peerIdStr, 'dataReceived', data.length);\n\n    if (exists) {\n      this._stats.push(peerIdStr, 'dupBlksReceived', 1);\n\n      this._stats.push(peerIdStr, 'dupDataReceived', data.length);\n    }\n  }\n  /**\n   * handle errors on the receiving channel\n   *\n   * @param {Error} err\n   */\n\n\n  _receiveError(err) {\n    this._log.error('ReceiveError: %s', err.message);\n  }\n  /**\n   * handle new peers\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerConnected(peerId) {\n    this.wm.connected(peerId);\n  }\n  /**\n   * handle peers being disconnected\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerDisconnected(peerId) {\n    this.wm.disconnected(peerId);\n    this.engine.peerDisconnected(peerId);\n\n    this._stats.disconnected(peerId);\n  }\n\n  enableStats() {\n    this._stats.enable();\n  }\n\n  disableStats() {\n    this._stats.disable();\n  }\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @param {any} [_options]\n   */\n\n\n  wantlistForPeer(peerId, _options) {\n    return this.engine.wantlistForPeer(peerId);\n  }\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  ledgerForPeer(peerId) {\n    return this.engine.ledgerForPeer(peerId);\n  }\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async get(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.signal\n     */\n    const fetchFromNetwork = (cid, options) => {\n      // add it to the want list - n.b. later we will abort the AbortSignal\n      // so no need to remove the blocks from the wantlist after we have it\n      this.wm.wantBlocks([cid], options);\n      return this.notifications.wantBlock(cid, options);\n    };\n\n    let promptedNetwork = false;\n    /**\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.signal\n     */\n\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        // have to await here as we want to handle ERR_NOT_FOUND\n        const block = await this.blockstore.get(cid, options);\n        return block;\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n\n        if (!promptedNetwork) {\n          promptedNetwork = true;\n          this.network.findAndConnect(cid).catch(err => this._log.error(err));\n        } // we don't have the block locally so fetch it from the network\n\n\n        return fetchFromNetwork(cid, options);\n      }\n    }; // depending on implementation it's possible for blocks to come in while\n    // we do the async operations to get them from the blockstore leading to\n    // a race condition, so register for incoming block notifications as well\n    // as trying to get it from the datastore\n\n\n    const controller = new AbortController();\n    const signal = options.signal ? anySignal([options.signal, controller.signal]) : controller.signal;\n    const block = await Promise.race([this.notifications.wantBlock(cid, {\n      signal\n    }), loadOrFetchFromNetwork(cid, {\n      signal\n    })]); // since we have the block we can now remove our listener\n\n    controller.abort();\n    return block;\n  }\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterable<CID>|Iterable<CID>} cids\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async *getMany(cids) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for await (const cid of cids) {\n      yield this.get(cid, options);\n    }\n  }\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {CID[]|CID} cids\n   */\n\n\n  unwant(cids) {\n    const cidsArray = Array.isArray(cids) ? cids : [cids];\n    this.wm.unwantBlocks(cidsArray);\n    cidsArray.forEach(cid => this.notifications.unwantBlock(cid));\n  }\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {CID[]|CID} cids\n   */\n\n\n  cancelWants(cids) {\n    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);\n  }\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {any} [_options]\n   */\n\n\n  async put(cid, block, _options) {\n    await this.blockstore.put(cid, block);\n\n    this._sendHaveBlockNotifications(cid, block);\n  }\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {Iterable<Pair> | AsyncIterable<Pair>} source\n   * @param {Options} [options]\n   */\n\n\n  async *putMany(source, options) {\n    for await (const {\n      key,\n      value\n    } of this.blockstore.putMany(source, options)) {\n      this._sendHaveBlockNotifications(key, value);\n\n      yield {\n        key,\n        value\n      };\n    }\n  }\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @private\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   */\n\n\n  _sendHaveBlockNotifications(cid, data) {\n    this.notifications.hasBlock(cid, data);\n    this.engine.receivedBlocks([{\n      cid,\n      data\n    }]); // Note: Don't wait for provide to finish before returning\n\n    this.network.provide(cid).catch(err => {\n      this._log.error('Failed to provide: %s', err.message);\n    });\n  }\n  /**\n   * Get the current list of wants\n   */\n\n\n  getWantlist() {\n    return this.wm.wantlist.entries();\n  }\n  /**\n   * Get the current list of partners\n   */\n\n\n  peers() {\n    return this.engine.peers();\n  }\n  /**\n   * Get stats about the bitswap node\n   */\n\n\n  stat() {\n    return this._stats;\n  }\n  /**\n   * Start the bitswap node\n   */\n\n\n  start() {\n    this.wm.start();\n    this.network.start();\n    this.engine.start();\n    this.started = true;\n  }\n  /**\n   * Stop the bitswap node\n   */\n\n\n  stop() {\n    this._stats.stop();\n\n    this.wm.stop();\n    this.network.stop();\n    this.engine.stop();\n    this.started = false;\n  }\n\n  unwrap() {\n    return this.blockstore;\n  }\n\n}\n\nmodule.exports = Bitswap;","map":{"version":3,"names":["WantManager","require","Network","DecisionEngine","Notifications","logger","Stats","AbortController","anySignal","BlockstoreAdapter","CID","defaultOptions","statsEnabled","statsComputeThrottleTimeout","statsComputeThrottleMaxQueueSize","statsKeys","Bitswap","constructor","libp2p","blockstore","options","_libp2p","_log","peerId","_options","Object","assign","_stats","enabled","computeThrottleTimeout","computeThrottleMaxQueueSize","network","hashers","engine","wm","notifications","started","isStarted","_receiveMessage","incoming","messageReceived","err","blocks","size","received","cidStr","data","entries","cid","parse","push","wasWanted","wantlist","contains","cancelWants","filter","map","Promise","all","_handleReceivedBlock","has","_updateReceiveCounters","toB58String","put","peerIdStr","exists","length","_receiveError","error","message","_onPeerConnected","connected","_onPeerDisconnected","disconnected","peerDisconnected","enableStats","enable","disableStats","disable","wantlistForPeer","ledgerForPeer","get","fetchFromNetwork","wantBlocks","wantBlock","promptedNetwork","loadOrFetchFromNetwork","block","code","findAndConnect","catch","controller","signal","race","abort","getMany","cids","unwant","cidsArray","Array","isArray","unwantBlocks","forEach","unwantBlock","_sendHaveBlockNotifications","putMany","source","key","value","hasBlock","receivedBlocks","provide","getWantlist","peers","stat","start","stop","unwrap","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-bitswap/src/bitswap.js"],"sourcesContent":["'use strict'\n\nconst WantManager = require('./want-manager')\nconst Network = require('./network')\nconst DecisionEngine = require('./decision-engine')\nconst Notifications = require('./notifications')\nconst logger = require('./utils').logger\nconst Stats = require('./stats')\nconst { AbortController } = require('native-abort-controller')\nconst { anySignal } = require('any-signal')\nconst { BlockstoreAdapter } = require('interface-blockstore')\nconst { CID } = require('multiformats')\n\n/**\n * @typedef {import('./types').IPFSBitswap} IPFSBitswap\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types/message')} BitswapMessage\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n */\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n}\nconst statsKeys = [\n  'blocksReceived',\n  'dataReceived',\n  'dupBlksReceived',\n  'dupDataReceived',\n  'blocksSent',\n  'dataSent',\n  'providesBufferLength',\n  'wantListLength',\n  'peerCount'\n]\n\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @implements {IPFSBitswap}\n */\nclass Bitswap extends BlockstoreAdapter {\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {Blockstore} blockstore\n   * @param {Object} [options]\n   * @param {boolean} [options.statsEnabled=false]\n   * @param {number} [options.statsComputeThrottleTimeout=1000]\n   * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  constructor (libp2p, blockstore, options = {}) {\n    super()\n\n    this._libp2p = libp2p\n    this._log = logger(this.peerId)\n\n    this._options = Object.assign({}, defaultOptions, options)\n\n    // stats\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    })\n\n    // the network delivers messages\n    this.network = new Network(libp2p, this, this._stats, {\n      hashers: options.hashers\n    })\n\n    // local database\n    this.blockstore = blockstore\n\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats)\n\n    // handle message sending\n    this.wm = new WantManager(this.peerId, this.network, this._stats)\n\n    this.notifications = new Notifications(this.peerId)\n\n    this.started = false\n  }\n\n  isStarted () {\n    return this.started\n  }\n\n  /**\n   * @type {PeerId}\n   */\n  get peerId () {\n    return this._libp2p.peerId\n  }\n\n  /**\n   * handle messages received through the network\n   *\n   * @param {PeerId} peerId\n   * @param {BitswapMessage} incoming\n   */\n  async _receiveMessage (peerId, incoming) {\n    try {\n      // Note: this allows the engine to respond to any wants in the message.\n      // Processing of the blocks in the message happens below, after the\n      // blocks have been added to the blockstore.\n      await this.engine.messageReceived(peerId, incoming)\n    } catch (err) {\n      // Log instead of throwing an error so as to process as much as\n      // possible of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming)\n    }\n\n    if (incoming.blocks.size === 0) {\n      return\n    }\n\n    /** @type { { cid: CID, wasWanted: boolean, data: Uint8Array }[] } */\n    const received = []\n\n    for (const [cidStr, data] of incoming.blocks.entries()) {\n      const cid = CID.parse(cidStr)\n\n      received.push({\n        wasWanted: this.wm.wantlist.contains(cid),\n        cid,\n        data\n      })\n    }\n\n    // quickly send out cancels, reduces chances of duplicate block receives\n    this.wm.cancelWants(\n      received\n        .filter(({ wasWanted }) => wasWanted)\n        .map(({ cid }) => cid)\n    )\n\n    await Promise.all(\n      received.map(\n        ({ cid, wasWanted, data }) => this._handleReceivedBlock(peerId, cid, data, wasWanted)\n      )\n    )\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} wasWanted\n   */\n  async _handleReceivedBlock (peerId, cid, data, wasWanted) {\n    this._log('received block')\n\n    const has = await this.blockstore.has(cid)\n\n    this._updateReceiveCounters(peerId.toB58String(), cid, data, has)\n\n    if (!wasWanted) {\n      return\n    }\n\n    await this.put(cid, data)\n  }\n\n  /**\n   * @private\n   * @param {string} peerIdStr\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   * @param {boolean} exists\n   */\n  _updateReceiveCounters (peerIdStr, cid, data, exists) {\n    this._stats.push(peerIdStr, 'blocksReceived', 1)\n    this._stats.push(peerIdStr, 'dataReceived', data.length)\n\n    if (exists) {\n      this._stats.push(peerIdStr, 'dupBlksReceived', 1)\n      this._stats.push(peerIdStr, 'dupDataReceived', data.length)\n    }\n  }\n\n  /**\n   * handle errors on the receiving channel\n   *\n   * @param {Error} err\n   */\n  _receiveError (err) {\n    this._log.error('ReceiveError: %s', err.message)\n  }\n\n  /**\n   * handle new peers\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerConnected (peerId) {\n    this.wm.connected(peerId)\n  }\n\n  /**\n   * handle peers being disconnected\n   *\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnected (peerId) {\n    this.wm.disconnected(peerId)\n    this.engine.peerDisconnected(peerId)\n    this._stats.disconnected(peerId)\n  }\n\n  enableStats () {\n    this._stats.enable()\n  }\n\n  disableStats () {\n    this._stats.disable()\n  }\n\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @param {any} [_options]\n   */\n  wantlistForPeer (peerId, _options) {\n    return this.engine.wantlistForPeer(peerId)\n  }\n\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   */\n  ledgerForPeer (peerId) {\n    return this.engine.ledgerForPeer(peerId)\n  }\n\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async get (cid, options = {}) {\n    /**\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.signal\n     */\n    const fetchFromNetwork = (cid, options) => {\n      // add it to the want list - n.b. later we will abort the AbortSignal\n      // so no need to remove the blocks from the wantlist after we have it\n      this.wm.wantBlocks([cid], options)\n\n      return this.notifications.wantBlock(cid, options)\n    }\n\n    let promptedNetwork = false\n\n    /**\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.signal\n     */\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        // have to await here as we want to handle ERR_NOT_FOUND\n        const block = await this.blockstore.get(cid, options)\n\n        return block\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n\n        if (!promptedNetwork) {\n          promptedNetwork = true\n\n          this.network.findAndConnect(cid)\n            .catch((err) => this._log.error(err))\n        }\n\n        // we don't have the block locally so fetch it from the network\n        return fetchFromNetwork(cid, options)\n      }\n    }\n\n    // depending on implementation it's possible for blocks to come in while\n    // we do the async operations to get them from the blockstore leading to\n    // a race condition, so register for incoming block notifications as well\n    // as trying to get it from the datastore\n    const controller = new AbortController()\n    const signal = options.signal\n      ? anySignal([options.signal, controller.signal])\n      : controller.signal\n\n    const block = await Promise.race([\n      this.notifications.wantBlock(cid, {\n        signal\n      }),\n      loadOrFetchFromNetwork(cid, {\n        signal\n      })\n    ])\n\n    // since we have the block we can now remove our listener\n    controller.abort()\n\n    return block\n  }\n\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterable<CID>|Iterable<CID>} cids\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async * getMany (cids, options = {}) {\n    for await (const cid of cids) {\n      yield this.get(cid, options)\n    }\n  }\n\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {CID[]|CID} cids\n   */\n  unwant (cids) {\n    const cidsArray = Array.isArray(cids) ? cids : [cids]\n\n    this.wm.unwantBlocks(cidsArray)\n    cidsArray.forEach((cid) => this.notifications.unwantBlock(cid))\n  }\n\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {CID[]|CID} cids\n   */\n  cancelWants (cids) {\n    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids])\n  }\n\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @param {any} [_options]\n   */\n  async put (cid, block, _options) {\n    await this.blockstore.put(cid, block)\n    this._sendHaveBlockNotifications(cid, block)\n  }\n\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {Iterable<Pair> | AsyncIterable<Pair>} source\n   * @param {Options} [options]\n   */\n  async * putMany (source, options) {\n    for await (const { key, value } of this.blockstore.putMany(source, options)) {\n      this._sendHaveBlockNotifications(key, value)\n\n      yield { key, value }\n    }\n  }\n\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @private\n   * @param {CID} cid\n   * @param {Uint8Array} data\n   */\n  _sendHaveBlockNotifications (cid, data) {\n    this.notifications.hasBlock(cid, data)\n    this.engine.receivedBlocks([{ cid, data }])\n    // Note: Don't wait for provide to finish before returning\n    this.network.provide(cid).catch((err) => {\n      this._log.error('Failed to provide: %s', err.message)\n    })\n  }\n\n  /**\n   * Get the current list of wants\n   */\n  getWantlist () {\n    return this.wm.wantlist.entries()\n  }\n\n  /**\n   * Get the current list of partners\n   */\n  peers () {\n    return this.engine.peers()\n  }\n\n  /**\n   * Get stats about the bitswap node\n   */\n  stat () {\n    return this._stats\n  }\n\n  /**\n   * Start the bitswap node\n   */\n  start () {\n    this.wm.start()\n    this.network.start()\n    this.engine.start()\n    this.started = true\n  }\n\n  /**\n   * Stop the bitswap node\n   */\n  stop () {\n    this._stats.stop()\n    this.wm.stop()\n    this.network.stop()\n    this.engine.stop()\n    this.started = false\n  }\n\n  unwrap () {\n    return this.blockstore\n  }\n}\n\nmodule.exports = Bitswap\n"],"mappings":"AAAA;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAME,cAAc,GAAGF,OAAO,CAAC,mBAAD,CAA9B;;AACA,MAAMG,aAAa,GAAGH,OAAO,CAAC,iBAAD,CAA7B;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,SAAD,CAAP,CAAmBI,MAAlC;;AACA,MAAMC,KAAK,GAAGL,OAAO,CAAC,SAAD,CAArB;;AACA,MAAM;EAAEM;AAAF,IAAsBN,OAAO,CAAC,yBAAD,CAAnC;;AACA,MAAM;EAAEO;AAAF,IAAgBP,OAAO,CAAC,YAAD,CAA7B;;AACA,MAAM;EAAEQ;AAAF,IAAwBR,OAAO,CAAC,sBAAD,CAArC;;AACA,MAAM;EAAES;AAAF,IAAUT,OAAO,CAAC,cAAD,CAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMU,cAAc,GAAG;EACrBC,YAAY,EAAE,KADO;EAErBC,2BAA2B,EAAE,IAFR;EAGrBC,gCAAgC,EAAE;AAHb,CAAvB;AAKA,MAAMC,SAAS,GAAG,CAChB,gBADgB,EAEhB,cAFgB,EAGhB,iBAHgB,EAIhB,iBAJgB,EAKhB,YALgB,EAMhB,UANgB,EAOhB,sBAPgB,EAQhB,gBARgB,EAShB,WATgB,CAAlB;AAYA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,OAAN,SAAsBP,iBAAtB,CAAwC;EACtC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEQ,WAAW,CAAEC,MAAF,EAAUC,UAAV,EAAoC;IAAA,IAAdC,OAAc,uEAAJ,EAAI;IAC7C;IAEA,KAAKC,OAAL,GAAeH,MAAf;IACA,KAAKI,IAAL,GAAYjB,MAAM,CAAC,KAAKkB,MAAN,CAAlB;IAEA,KAAKC,QAAL,GAAgBC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBf,cAAlB,EAAkCS,OAAlC,CAAhB,CAN6C,CAQ7C;;IACA,KAAKO,MAAL,GAAc,IAAIrB,KAAJ,CAAUS,SAAV,EAAqB;MACjCa,OAAO,EAAE,KAAKJ,QAAL,CAAcZ,YADU;MAEjCiB,sBAAsB,EAAE,KAAKL,QAAL,CAAcX,2BAFL;MAGjCiB,2BAA2B,EAAE,KAAKN,QAAL,CAAcV;IAHV,CAArB,CAAd,CAT6C,CAe7C;;IACA,KAAKiB,OAAL,GAAe,IAAI7B,OAAJ,CAAYgB,MAAZ,EAAoB,IAApB,EAA0B,KAAKS,MAA/B,EAAuC;MACpDK,OAAO,EAAEZ,OAAO,CAACY;IADmC,CAAvC,CAAf,CAhB6C,CAoB7C;;IACA,KAAKb,UAAL,GAAkBA,UAAlB;IAEA,KAAKc,MAAL,GAAc,IAAI9B,cAAJ,CAAmB,KAAKoB,MAAxB,EAAgCJ,UAAhC,EAA4C,KAAKY,OAAjD,EAA0D,KAAKJ,MAA/D,CAAd,CAvB6C,CAyB7C;;IACA,KAAKO,EAAL,GAAU,IAAIlC,WAAJ,CAAgB,KAAKuB,MAArB,EAA6B,KAAKQ,OAAlC,EAA2C,KAAKJ,MAAhD,CAAV;IAEA,KAAKQ,aAAL,GAAqB,IAAI/B,aAAJ,CAAkB,KAAKmB,MAAvB,CAArB;IAEA,KAAKa,OAAL,GAAe,KAAf;EACD;;EAEDC,SAAS,GAAI;IACX,OAAO,KAAKD,OAAZ;EACD;EAED;AACF;AACA;;;EACY,IAANb,MAAM,GAAI;IACZ,OAAO,KAAKF,OAAL,CAAaE,MAApB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACuB,MAAfe,eAAe,CAAEf,MAAF,EAAUgB,QAAV,EAAoB;IACvC,IAAI;MACF;MACA;MACA;MACA,MAAM,KAAKN,MAAL,CAAYO,eAAZ,CAA4BjB,MAA5B,EAAoCgB,QAApC,CAAN;IACD,CALD,CAKE,OAAOE,GAAP,EAAY;MACZ;MACA;MACA;MACA,KAAKnB,IAAL,CAAU,2BAAV,EAAuCiB,QAAvC;IACD;;IAED,IAAIA,QAAQ,CAACG,MAAT,CAAgBC,IAAhB,KAAyB,CAA7B,EAAgC;MAC9B;IACD;IAED;;;IACA,MAAMC,QAAQ,GAAG,EAAjB;;IAEA,KAAK,MAAM,CAACC,MAAD,EAASC,IAAT,CAAX,IAA6BP,QAAQ,CAACG,MAAT,CAAgBK,OAAhB,EAA7B,EAAwD;MACtD,MAAMC,GAAG,GAAGtC,GAAG,CAACuC,KAAJ,CAAUJ,MAAV,CAAZ;MAEAD,QAAQ,CAACM,IAAT,CAAc;QACZC,SAAS,EAAE,KAAKjB,EAAL,CAAQkB,QAAR,CAAiBC,QAAjB,CAA0BL,GAA1B,CADC;QAEZA,GAFY;QAGZF;MAHY,CAAd;IAKD,CA5BsC,CA8BvC;;;IACA,KAAKZ,EAAL,CAAQoB,WAAR,CACEV,QAAQ,CACLW,MADH,CACU;MAAA,IAAC;QAAEJ;MAAF,CAAD;MAAA,OAAmBA,SAAnB;IAAA,CADV,EAEGK,GAFH,CAEO;MAAA,IAAC;QAAER;MAAF,CAAD;MAAA,OAAaA,GAAb;IAAA,CAFP,CADF;IAMA,MAAMS,OAAO,CAACC,GAAR,CACJd,QAAQ,CAACY,GAAT,CACE;MAAA,IAAC;QAAER,GAAF;QAAOG,SAAP;QAAkBL;MAAlB,CAAD;MAAA,OAA8B,KAAKa,oBAAL,CAA0BpC,MAA1B,EAAkCyB,GAAlC,EAAuCF,IAAvC,EAA6CK,SAA7C,CAA9B;IAAA,CADF,CADI,CAAN;EAKD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EAC4B,MAApBQ,oBAAoB,CAAEpC,MAAF,EAAUyB,GAAV,EAAeF,IAAf,EAAqBK,SAArB,EAAgC;IACxD,KAAK7B,IAAL,CAAU,gBAAV;;IAEA,MAAMsC,GAAG,GAAG,MAAM,KAAKzC,UAAL,CAAgByC,GAAhB,CAAoBZ,GAApB,CAAlB;;IAEA,KAAKa,sBAAL,CAA4BtC,MAAM,CAACuC,WAAP,EAA5B,EAAkDd,GAAlD,EAAuDF,IAAvD,EAA6Dc,GAA7D;;IAEA,IAAI,CAACT,SAAL,EAAgB;MACd;IACD;;IAED,MAAM,KAAKY,GAAL,CAASf,GAAT,EAAcF,IAAd,CAAN;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEe,sBAAsB,CAAEG,SAAF,EAAahB,GAAb,EAAkBF,IAAlB,EAAwBmB,MAAxB,EAAgC;IACpD,KAAKtC,MAAL,CAAYuB,IAAZ,CAAiBc,SAAjB,EAA4B,gBAA5B,EAA8C,CAA9C;;IACA,KAAKrC,MAAL,CAAYuB,IAAZ,CAAiBc,SAAjB,EAA4B,cAA5B,EAA4ClB,IAAI,CAACoB,MAAjD;;IAEA,IAAID,MAAJ,EAAY;MACV,KAAKtC,MAAL,CAAYuB,IAAZ,CAAiBc,SAAjB,EAA4B,iBAA5B,EAA+C,CAA/C;;MACA,KAAKrC,MAAL,CAAYuB,IAAZ,CAAiBc,SAAjB,EAA4B,iBAA5B,EAA+ClB,IAAI,CAACoB,MAApD;IACD;EACF;EAED;AACF;AACA;AACA;AACA;;;EACEC,aAAa,CAAE1B,GAAF,EAAO;IAClB,KAAKnB,IAAL,CAAU8C,KAAV,CAAgB,kBAAhB,EAAoC3B,GAAG,CAAC4B,OAAxC;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEC,gBAAgB,CAAE/C,MAAF,EAAU;IACxB,KAAKW,EAAL,CAAQqC,SAAR,CAAkBhD,MAAlB;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEiD,mBAAmB,CAAEjD,MAAF,EAAU;IAC3B,KAAKW,EAAL,CAAQuC,YAAR,CAAqBlD,MAArB;IACA,KAAKU,MAAL,CAAYyC,gBAAZ,CAA6BnD,MAA7B;;IACA,KAAKI,MAAL,CAAY8C,YAAZ,CAAyBlD,MAAzB;EACD;;EAEDoD,WAAW,GAAI;IACb,KAAKhD,MAAL,CAAYiD,MAAZ;EACD;;EAEDC,YAAY,GAAI;IACd,KAAKlD,MAAL,CAAYmD,OAAZ;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEC,eAAe,CAAExD,MAAF,EAAUC,QAAV,EAAoB;IACjC,OAAO,KAAKS,MAAL,CAAY8C,eAAZ,CAA4BxD,MAA5B,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEyD,aAAa,CAAEzD,MAAF,EAAU;IACrB,OAAO,KAAKU,MAAL,CAAY+C,aAAZ,CAA0BzD,MAA1B,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACW,MAAH0D,GAAG,CAAEjC,GAAF,EAAqB;IAAA,IAAd5B,OAAc,uEAAJ,EAAI;;IAC5B;AACJ;AACA;AACA;AACA;IACI,MAAM8D,gBAAgB,GAAG,CAAClC,GAAD,EAAM5B,OAAN,KAAkB;MACzC;MACA;MACA,KAAKc,EAAL,CAAQiD,UAAR,CAAmB,CAACnC,GAAD,CAAnB,EAA0B5B,OAA1B;MAEA,OAAO,KAAKe,aAAL,CAAmBiD,SAAnB,CAA6BpC,GAA7B,EAAkC5B,OAAlC,CAAP;IACD,CAND;;IAQA,IAAIiE,eAAe,GAAG,KAAtB;IAEA;AACJ;AACA;AACA;AACA;AACA;;IACI,MAAMC,sBAAsB,GAAG,OAAOtC,GAAP,EAAY5B,OAAZ,KAAwB;MACrD,IAAI;QACF;QACA,MAAMmE,KAAK,GAAG,MAAM,KAAKpE,UAAL,CAAgB8D,GAAhB,CAAoBjC,GAApB,EAAyB5B,OAAzB,CAApB;QAEA,OAAOmE,KAAP;MACD,CALD,CAKE,OAAO9C,GAAP,EAAY;QACZ,IAAIA,GAAG,CAAC+C,IAAJ,KAAa,eAAjB,EAAkC;UAChC,MAAM/C,GAAN;QACD;;QAED,IAAI,CAAC4C,eAAL,EAAsB;UACpBA,eAAe,GAAG,IAAlB;UAEA,KAAKtD,OAAL,CAAa0D,cAAb,CAA4BzC,GAA5B,EACG0C,KADH,CACUjD,GAAD,IAAS,KAAKnB,IAAL,CAAU8C,KAAV,CAAgB3B,GAAhB,CADlB;QAED,CAVW,CAYZ;;;QACA,OAAOyC,gBAAgB,CAAClC,GAAD,EAAM5B,OAAN,CAAvB;MACD;IACF,CArBD,CAtB4B,CA6C5B;IACA;IACA;IACA;;;IACA,MAAMuE,UAAU,GAAG,IAAIpF,eAAJ,EAAnB;IACA,MAAMqF,MAAM,GAAGxE,OAAO,CAACwE,MAAR,GACXpF,SAAS,CAAC,CAACY,OAAO,CAACwE,MAAT,EAAiBD,UAAU,CAACC,MAA5B,CAAD,CADE,GAEXD,UAAU,CAACC,MAFf;IAIA,MAAML,KAAK,GAAG,MAAM9B,OAAO,CAACoC,IAAR,CAAa,CAC/B,KAAK1D,aAAL,CAAmBiD,SAAnB,CAA6BpC,GAA7B,EAAkC;MAChC4C;IADgC,CAAlC,CAD+B,EAI/BN,sBAAsB,CAACtC,GAAD,EAAM;MAC1B4C;IAD0B,CAAN,CAJS,CAAb,CAApB,CAtD4B,CA+D5B;;IACAD,UAAU,CAACG,KAAX;IAEA,OAAOP,KAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACiB,OAAPQ,OAAO,CAAEC,IAAF,EAAsB;IAAA,IAAd5E,OAAc,uEAAJ,EAAI;;IACnC,WAAW,MAAM4B,GAAjB,IAAwBgD,IAAxB,EAA8B;MAC5B,MAAM,KAAKf,GAAL,CAASjC,GAAT,EAAc5B,OAAd,CAAN;IACD;EACF;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE6E,MAAM,CAAED,IAAF,EAAQ;IACZ,MAAME,SAAS,GAAGC,KAAK,CAACC,OAAN,CAAcJ,IAAd,IAAsBA,IAAtB,GAA6B,CAACA,IAAD,CAA/C;IAEA,KAAK9D,EAAL,CAAQmE,YAAR,CAAqBH,SAArB;IACAA,SAAS,CAACI,OAAV,CAAmBtD,GAAD,IAAS,KAAKb,aAAL,CAAmBoE,WAAnB,CAA+BvD,GAA/B,CAA3B;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEM,WAAW,CAAE0C,IAAF,EAAQ;IACjB,KAAK9D,EAAL,CAAQoB,WAAR,CAAoB6C,KAAK,CAACC,OAAN,CAAcJ,IAAd,IAAsBA,IAAtB,GAA6B,CAACA,IAAD,CAAjD;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACW,MAAHjC,GAAG,CAAEf,GAAF,EAAOuC,KAAP,EAAc/D,QAAd,EAAwB;IAC/B,MAAM,KAAKL,UAAL,CAAgB4C,GAAhB,CAAoBf,GAApB,EAAyBuC,KAAzB,CAAN;;IACA,KAAKiB,2BAAL,CAAiCxD,GAAjC,EAAsCuC,KAAtC;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACiB,OAAPkB,OAAO,CAAEC,MAAF,EAAUtF,OAAV,EAAmB;IAChC,WAAW,MAAM;MAAEuF,GAAF;MAAOC;IAAP,CAAjB,IAAmC,KAAKzF,UAAL,CAAgBsF,OAAhB,CAAwBC,MAAxB,EAAgCtF,OAAhC,CAAnC,EAA6E;MAC3E,KAAKoF,2BAAL,CAAiCG,GAAjC,EAAsCC,KAAtC;;MAEA,MAAM;QAAED,GAAF;QAAOC;MAAP,CAAN;IACD;EACF;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEJ,2BAA2B,CAAExD,GAAF,EAAOF,IAAP,EAAa;IACtC,KAAKX,aAAL,CAAmB0E,QAAnB,CAA4B7D,GAA5B,EAAiCF,IAAjC;IACA,KAAKb,MAAL,CAAY6E,cAAZ,CAA2B,CAAC;MAAE9D,GAAF;MAAOF;IAAP,CAAD,CAA3B,EAFsC,CAGtC;;IACA,KAAKf,OAAL,CAAagF,OAAb,CAAqB/D,GAArB,EAA0B0C,KAA1B,CAAiCjD,GAAD,IAAS;MACvC,KAAKnB,IAAL,CAAU8C,KAAV,CAAgB,uBAAhB,EAAyC3B,GAAG,CAAC4B,OAA7C;IACD,CAFD;EAGD;EAED;AACF;AACA;;;EACE2C,WAAW,GAAI;IACb,OAAO,KAAK9E,EAAL,CAAQkB,QAAR,CAAiBL,OAAjB,EAAP;EACD;EAED;AACF;AACA;;;EACEkE,KAAK,GAAI;IACP,OAAO,KAAKhF,MAAL,CAAYgF,KAAZ,EAAP;EACD;EAED;AACF;AACA;;;EACEC,IAAI,GAAI;IACN,OAAO,KAAKvF,MAAZ;EACD;EAED;AACF;AACA;;;EACEwF,KAAK,GAAI;IACP,KAAKjF,EAAL,CAAQiF,KAAR;IACA,KAAKpF,OAAL,CAAaoF,KAAb;IACA,KAAKlF,MAAL,CAAYkF,KAAZ;IACA,KAAK/E,OAAL,GAAe,IAAf;EACD;EAED;AACF;AACA;;;EACEgF,IAAI,GAAI;IACN,KAAKzF,MAAL,CAAYyF,IAAZ;;IACA,KAAKlF,EAAL,CAAQkF,IAAR;IACA,KAAKrF,OAAL,CAAaqF,IAAb;IACA,KAAKnF,MAAL,CAAYmF,IAAZ;IACA,KAAKhF,OAAL,GAAe,KAAf;EACD;;EAEDiF,MAAM,GAAI;IACR,OAAO,KAAKlG,UAAZ;EACD;;AArZqC;;AAwZxCmG,MAAM,CAACC,OAAP,GAAiBvG,OAAjB"},"metadata":{},"sourceType":"script"}