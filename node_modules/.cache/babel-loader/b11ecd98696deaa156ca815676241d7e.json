{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar fs = typeof window === 'object' || typeof self === 'object' ? null : eval('require(\"fs\")'); // eslint-disable-line\n\nvar level = require('level');\n\nvar crypto = require('libp2p-crypto');\n\nvar secp256k1 = require('secp256k1');\n\nvar LRU = require('lru');\n\nvar Buffer = require('safe-buffer/').Buffer;\n\nvar _require = require('./verifiers'),\n    verifier = _require.verifier;\n\nfunction createStore() {\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : './keystore';\n\n  if (fs && fs.mkdirSync) {\n    fs.mkdirSync(path, {\n      recursive: true\n    });\n  }\n\n  return level(path);\n}\n\nvar verifiedCache = new LRU(1000);\n\nvar Keystore = /*#__PURE__*/function () {\n  function Keystore() {\n    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Keystore);\n\n    if (typeof input === 'string') {\n      this._store = createStore(input);\n    } else if (typeof input.open === 'function') {\n      this._store = input;\n    } else if (typeof input.store === 'string') {\n      this._store = createStore(input.store);\n    } else {\n      this._store = input.store || createStore();\n    }\n\n    this._cache = input.cache || new LRU(100);\n  }\n\n  _createClass(Keystore, [{\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._store) {\n                  _context.next = 4;\n                  break;\n                }\n\n                _context.next = 3;\n                return this._store.open();\n\n              case 3:\n                return _context.abrupt(\"return\", Promise.resolve());\n\n              case 4:\n                return _context.abrupt(\"return\", Promise.reject(new Error('Keystore: No store found to open')));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function open() {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this._store) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                _context2.next = 4;\n                return this._store.close();\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }, {\n    key: \"hasKey\",\n    value: function () {\n      var _hasKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(id) {\n        var hasKey, storedKey;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (id) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new Error('id needed to check a key');\n\n              case 2:\n                if (!(this._store.status && this._store.status !== 'open')) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", Promise.resolve(null));\n\n              case 4:\n                hasKey = false;\n                _context3.prev = 5;\n                _context3.t0 = this._cache.get(id);\n\n                if (_context3.t0) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                _context3.next = 10;\n                return this._store.get(id);\n\n              case 10:\n                _context3.t0 = _context3.sent;\n\n              case 11:\n                storedKey = _context3.t0;\n                hasKey = storedKey !== undefined && storedKey !== null;\n                _context3.next = 18;\n                break;\n\n              case 15:\n                _context3.prev = 15;\n                _context3.t1 = _context3[\"catch\"](5);\n                // Catches 'Error: ENOENT: no such file or directory, open <path>'\n                console.error('Error: ENOENT: no such file or directory');\n\n              case 18:\n                return _context3.abrupt(\"return\", hasKey);\n\n              case 19:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[5, 15]]);\n      }));\n\n      function hasKey(_x) {\n        return _hasKey.apply(this, arguments);\n      }\n\n      return hasKey;\n    }()\n  }, {\n    key: \"createKey\",\n    value: function () {\n      var _createKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(id) {\n        var genKeyPair, keys, decompressedKey, key;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (id) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('id needed to create a key');\n\n              case 2:\n                if (!(this._store.status && this._store.status !== 'open')) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", Promise.resolve(null));\n\n              case 4:\n                genKeyPair = function genKeyPair() {\n                  return new Promise(function (resolve, reject) {\n                    crypto.keys.generateKeyPair('secp256k1', 256, function (err, key) {\n                      if (!err) {\n                        resolve(key);\n                      }\n\n                      reject(err);\n                    });\n                  });\n                };\n\n                _context4.next = 7;\n                return genKeyPair();\n\n              case 7:\n                keys = _context4.sent;\n                decompressedKey = Buffer.from(secp256k1.publicKeyConvert(keys.public.marshal(), false));\n                key = {\n                  publicKey: decompressedKey.toString('hex'),\n                  privateKey: keys.marshal().toString('hex')\n                };\n                _context4.prev = 10;\n                _context4.next = 13;\n                return this._store.put(id, JSON.stringify(key));\n\n              case 13:\n                _context4.next = 18;\n                break;\n\n              case 15:\n                _context4.prev = 15;\n                _context4.t0 = _context4[\"catch\"](10);\n                console.log(_context4.t0);\n\n              case 18:\n                this._cache.set(id, key);\n\n                return _context4.abrupt(\"return\", keys);\n\n              case 20:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[10, 15]]);\n      }));\n\n      function createKey(_x2) {\n        return _createKey.apply(this, arguments);\n      }\n\n      return createKey;\n    }()\n  }, {\n    key: \"getKey\",\n    value: function () {\n      var _getKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(id) {\n        var cachedKey, storedKey, deserializedKey, genPrivKey;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (id) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw new Error('id needed to get a key');\n\n              case 2:\n                if (this._store) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                _context5.next = 5;\n                return this.open();\n\n              case 5:\n                if (!(this._store.status && this._store.status !== 'open')) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", Promise.resolve(null));\n\n              case 7:\n                cachedKey = this._cache.get(id);\n                _context5.prev = 8;\n                _context5.t0 = cachedKey;\n\n                if (_context5.t0) {\n                  _context5.next = 14;\n                  break;\n                }\n\n                _context5.next = 13;\n                return this._store.get(id);\n\n              case 13:\n                _context5.t0 = _context5.sent;\n\n              case 14:\n                storedKey = _context5.t0;\n                _context5.next = 19;\n                break;\n\n              case 17:\n                _context5.prev = 17;\n                _context5.t1 = _context5[\"catch\"](8);\n\n              case 19:\n                if (storedKey) {\n                  _context5.next = 21;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 21:\n                deserializedKey = cachedKey || JSON.parse(storedKey);\n\n                if (deserializedKey) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 24:\n                if (!cachedKey) {\n                  this._cache.set(id, deserializedKey);\n                }\n\n                genPrivKey = function genPrivKey(pk) {\n                  return new Promise(function (resolve, reject) {\n                    crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(pk, function (err, key) {\n                      if (!err) {\n                        resolve(key);\n                      }\n\n                      reject(err);\n                    });\n                  });\n                };\n\n                return _context5.abrupt(\"return\", genPrivKey(Buffer.from(deserializedKey.privateKey, 'hex')));\n\n              case 27:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[8, 17]]);\n      }));\n\n      function getKey(_x3) {\n        return _getKey.apply(this, arguments);\n      }\n\n      return getKey;\n    }()\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(key, data) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (key) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw new Error('No signing key given');\n\n              case 2:\n                if (data) {\n                  _context6.next = 4;\n                  break;\n                }\n\n                throw new Error('Given input data was undefined');\n\n              case 4:\n                if (!Buffer.isBuffer(data)) {\n                  data = Buffer.from(data);\n                }\n\n                return _context6.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  key.sign(data, function (err, signature) {\n                    if (!err) {\n                      resolve(signature.toString('hex'));\n                    }\n\n                    reject(err);\n                  });\n                }));\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function sign(_x4, _x5) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n  }, {\n    key: \"getPublic\",\n    value: function getPublic(keys) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var formats = ['hex', 'buffer'];\n      var decompress = typeof options.decompress === 'undefined' ? true : options.decompress;\n      var format = options.format || 'hex';\n\n      if (formats.indexOf(format) === -1) {\n        throw new Error('Supported formats are `hex` and `buffer`');\n      }\n\n      var pubKey = keys.public.marshal();\n\n      if (decompress) {\n        pubKey = Buffer.from(secp256k1.publicKeyConvert(pubKey, false));\n      }\n\n      return format === 'buffer' ? pubKey : pubKey.toString('hex');\n    }\n  }, {\n    key: \"verify\",\n    value: function () {\n      var _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(signature, publicKey, data) {\n        var v,\n            _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                v = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : 'v1';\n                return _context7.abrupt(\"return\", Keystore.verify(signature, publicKey, data, v));\n\n              case 2:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function verify(_x6, _x7, _x8) {\n        return _verify.apply(this, arguments);\n      }\n\n      return verify;\n    }()\n  }], [{\n    key: \"verify\",\n    value: function () {\n      var _verify2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(signature, publicKey, data) {\n        var v,\n            cached,\n            res,\n            verified,\n            compare,\n            _args8 = arguments;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                v = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : 'v1';\n                cached = verifiedCache.get(signature);\n                res = false;\n\n                if (cached) {\n                  _context8.next = 11;\n                  break;\n                }\n\n                _context8.next = 6;\n                return verifier(v).verify(signature, publicKey, data);\n\n              case 6:\n                verified = _context8.sent;\n                res = verified;\n\n                if (verified) {\n                  verifiedCache.set(signature, {\n                    publicKey: publicKey,\n                    data: data\n                  });\n                }\n\n                _context8.next = 13;\n                break;\n\n              case 11:\n                compare = function compare(cached, data, v) {\n                  var match;\n\n                  if (v === 'v0') {\n                    match = Buffer.compare(Buffer.alloc(30, cached), Buffer.alloc(30, data)) === 0;\n                  } else {\n                    match = Buffer.isBuffer(data) ? Buffer.compare(cached, data) === 0 : cached === data;\n                  }\n\n                  return match;\n                };\n\n                res = cached.publicKey === publicKey && compare(cached.data, data, v);\n\n              case 13:\n                return _context8.abrupt(\"return\", res);\n\n              case 14:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function verify(_x9, _x10, _x11) {\n        return _verify2.apply(this, arguments);\n      }\n\n      return verify;\n    }()\n  }]);\n\n  return Keystore;\n}();\n\nmodule.exports = Keystore;","map":{"version":3,"names":["fs","window","self","eval","level","require","crypto","secp256k1","LRU","Buffer","verifier","createStore","path","mkdirSync","recursive","verifiedCache","Keystore","input","_store","open","store","_cache","cache","Promise","resolve","reject","Error","close","id","status","hasKey","get","storedKey","undefined","console","error","genKeyPair","keys","generateKeyPair","err","key","decompressedKey","from","publicKeyConvert","public","marshal","publicKey","toString","privateKey","put","JSON","stringify","log","set","cachedKey","deserializedKey","parse","genPrivKey","pk","supportedKeys","unmarshalSecp256k1PrivateKey","data","isBuffer","sign","signature","options","formats","decompress","format","indexOf","pubKey","v","verify","cached","res","verified","compare","match","alloc","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-keystore/src/keystore.js"],"sourcesContent":["'use strict'\n\nconst fs = (typeof window === 'object' || typeof self === 'object') ? null : eval('require(\"fs\")') // eslint-disable-line\nconst level = require('level')\nconst crypto = require('libp2p-crypto')\nconst secp256k1 = require('secp256k1')\nconst LRU = require('lru')\nconst Buffer = require('safe-buffer/').Buffer\nconst { verifier } = require('./verifiers')\n\nfunction createStore (path = './keystore') {\n  if (fs && fs.mkdirSync) {\n    fs.mkdirSync(path, { recursive: true })\n  }\n  return level(path)\n}\nconst verifiedCache = new LRU(1000)\n\nclass Keystore {\n  constructor (input = {}) {\n    if (typeof input === 'string') {\n      this._store = createStore(input)\n    } else if (typeof input.open === 'function') {\n      this._store = input\n    } else if (typeof input.store === 'string') {\n      this._store = createStore(input.store)\n    } else {\n      this._store = input.store || createStore()\n    }\n    this._cache = input.cache || new LRU(100)\n  }\n\n  async open () {\n    if (this._store) {\n      await this._store.open()\n      return Promise.resolve()\n    }\n    return Promise.reject(new Error('Keystore: No store found to open'))\n  }\n\n  async close () {\n    if (!this._store) return\n    await this._store.close()\n  }\n\n  async hasKey (id) {\n    if (!id) {\n      throw new Error('id needed to check a key')\n    }\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null)\n    }\n\n    let hasKey = false\n    try {\n      let storedKey = this._cache.get(id) || await this._store.get(id)\n      hasKey = storedKey !== undefined && storedKey !== null\n    } catch (e) {\n      // Catches 'Error: ENOENT: no such file or directory, open <path>'\n      console.error('Error: ENOENT: no such file or directory')\n    }\n\n    return hasKey\n  }\n\n  async createKey (id) {\n    if (!id) {\n      throw new Error('id needed to create a key')\n    }\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null)\n    }\n\n    const genKeyPair = () => new Promise((resolve, reject) => {\n      crypto.keys.generateKeyPair('secp256k1', 256, (err, key) => {\n        if (!err) {\n          resolve(key)\n        }\n        reject(err)\n      })\n    })\n\n    const keys = await genKeyPair()\n    const decompressedKey = Buffer.from(secp256k1.publicKeyConvert(keys.public.marshal(), false))\n    const key = {\n      publicKey: decompressedKey.toString('hex'),\n      privateKey: keys.marshal().toString('hex')\n    }\n\n    try {\n      await this._store.put(id, JSON.stringify(key))\n    } catch (e) {\n      console.log(e)\n    }\n    this._cache.set(id, key)\n\n    return keys\n  }\n\n  async getKey (id) {\n    if (!id) {\n      throw new Error('id needed to get a key')\n    }\n    if (!this._store) {\n      await this.open()\n    }\n    if (this._store.status && this._store.status !== 'open') {\n      return Promise.resolve(null)\n    }\n\n    const cachedKey = this._cache.get(id)\n    let storedKey\n    try {\n      storedKey = cachedKey || await this._store.get(id)\n    } catch (e) {\n      // ignore ENOENT error\n    }\n\n    if (!storedKey) {\n      return\n    }\n\n    const deserializedKey = cachedKey || JSON.parse(storedKey)\n    if (!deserializedKey) {\n      return\n    }\n\n    if (!cachedKey) {\n      this._cache.set(id, deserializedKey)\n    }\n\n    const genPrivKey = (pk) => new Promise((resolve, reject) => {\n      crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(pk, (err, key) => {\n        if (!err) {\n          resolve(key)\n        }\n        reject(err)\n      })\n    })\n\n    return genPrivKey(Buffer.from(deserializedKey.privateKey, 'hex'))\n  }\n\n  async sign (key, data) {\n    if (!key) {\n      throw new Error('No signing key given')\n    }\n\n    if (!data) {\n      throw new Error('Given input data was undefined')\n    }\n\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data)\n    }\n\n    return new Promise((resolve, reject) => {\n      key.sign(data, (err, signature) => {\n        if (!err) {\n          resolve(signature.toString('hex'))\n        }\n        reject(err)\n      })\n    })\n  }\n\n  getPublic (keys, options = {}) {\n    const formats = ['hex', 'buffer']\n    const decompress = typeof options.decompress === 'undefined' ? true : options.decompress\n    const format = options.format || 'hex'\n    if (formats.indexOf(format) === -1) {\n      throw new Error('Supported formats are `hex` and `buffer`')\n    }\n    let pubKey = keys.public.marshal()\n    if (decompress) {\n      pubKey = Buffer.from(secp256k1.publicKeyConvert(pubKey, false))\n    }\n    return format === 'buffer' ? pubKey : pubKey.toString('hex')\n  }\n\n  async verify (signature, publicKey, data, v = 'v1') {\n    return Keystore.verify(signature, publicKey, data, v)\n  }\n\n  static async verify (signature, publicKey, data, v = 'v1') {\n    const cached = verifiedCache.get(signature)\n    let res = false\n    if (!cached) {\n      const verified = await verifier(v).verify(signature, publicKey, data)\n      res = verified\n      if (verified) {\n        verifiedCache.set(signature, { publicKey, data })\n      }\n    } else {\n      const compare = (cached, data, v) => {\n        let match\n        if (v === 'v0') {\n          match = Buffer.compare(Buffer.alloc(30, cached), Buffer.alloc(30, data)) === 0\n        } else {\n          match = Buffer.isBuffer(data) ? Buffer.compare(cached, data) === 0 : cached === data\n        }\n        return match\n      }\n      res = cached.publicKey === publicKey && compare(cached.data, data, v)\n    }\n    return res\n  }\n}\n\nmodule.exports = Keystore\n"],"mappings":"AAAA;;;;;;;;;;AAEA,IAAMA,EAAE,GAAI,OAAOC,MAAP,KAAkB,QAAlB,IAA8B,OAAOC,IAAP,KAAgB,QAA/C,GAA2D,IAA3D,GAAkEC,IAAI,CAAC,eAAD,CAAjF,C,CAAmG;;AACnG,IAAMC,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,eAAD,CAAtB;;AACA,IAAME,SAAS,GAAGF,OAAO,CAAC,WAAD,CAAzB;;AACA,IAAMG,GAAG,GAAGH,OAAO,CAAC,KAAD,CAAnB;;AACA,IAAMI,MAAM,GAAGJ,OAAO,CAAC,cAAD,CAAP,CAAwBI,MAAvC;;AACA,eAAqBJ,OAAO,CAAC,aAAD,CAA5B;AAAA,IAAQK,QAAR,YAAQA,QAAR;;AAEA,SAASC,WAAT,GAA2C;EAAA,IAArBC,IAAqB,uEAAd,YAAc;;EACzC,IAAIZ,EAAE,IAAIA,EAAE,CAACa,SAAb,EAAwB;IACtBb,EAAE,CAACa,SAAH,CAAaD,IAAb,EAAmB;MAAEE,SAAS,EAAE;IAAb,CAAnB;EACD;;EACD,OAAOV,KAAK,CAACQ,IAAD,CAAZ;AACD;;AACD,IAAMG,aAAa,GAAG,IAAIP,GAAJ,CAAQ,IAAR,CAAtB;;IAEMQ,Q;EACJ,oBAAyB;IAAA,IAAZC,KAAY,uEAAJ,EAAI;;IAAA;;IACvB,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;MAC7B,KAAKC,MAAL,GAAcP,WAAW,CAACM,KAAD,CAAzB;IACD,CAFD,MAEO,IAAI,OAAOA,KAAK,CAACE,IAAb,KAAsB,UAA1B,EAAsC;MAC3C,KAAKD,MAAL,GAAcD,KAAd;IACD,CAFM,MAEA,IAAI,OAAOA,KAAK,CAACG,KAAb,KAAuB,QAA3B,EAAqC;MAC1C,KAAKF,MAAL,GAAcP,WAAW,CAACM,KAAK,CAACG,KAAP,CAAzB;IACD,CAFM,MAEA;MACL,KAAKF,MAAL,GAAcD,KAAK,CAACG,KAAN,IAAeT,WAAW,EAAxC;IACD;;IACD,KAAKU,MAAL,GAAcJ,KAAK,CAACK,KAAN,IAAe,IAAId,GAAJ,CAAQ,GAAR,CAA7B;EACD;;;;;6EAED;QAAA;UAAA;YAAA;cAAA;gBAAA,KACM,KAAKU,MADX;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAEU,KAAKA,MAAL,CAAYC,IAAZ,EAFV;;cAAA;gBAAA,iCAGWI,OAAO,CAACC,OAAR,EAHX;;cAAA;gBAAA,iCAKSD,OAAO,CAACE,MAAR,CAAe,IAAIC,KAAJ,CAAU,kCAAV,CAAf,CALT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;8EAQA;QAAA;UAAA;YAAA;cAAA;gBAAA,IACO,KAAKR,MADZ;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAAA;gBAAA,OAEQ,KAAKA,MAAL,CAAYS,KAAZ,EAFR;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;+EAKA,kBAAcC,EAAd;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,IACOA,EADP;kBAAA;kBAAA;gBAAA;;gBAAA,MAEU,IAAIF,KAAJ,CAAU,0BAAV,CAFV;;cAAA;gBAAA,MAIM,KAAKR,MAAL,CAAYW,MAAZ,IAAsB,KAAKX,MAAL,CAAYW,MAAZ,KAAuB,MAJnD;kBAAA;kBAAA;gBAAA;;gBAAA,kCAKWN,OAAO,CAACC,OAAR,CAAgB,IAAhB,CALX;;cAAA;gBAQMM,MARN,GAQe,KARf;gBAAA;gBAAA,eAUoB,KAAKT,MAAL,CAAYU,GAAZ,CAAgBH,EAAhB,CAVpB;;gBAAA;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAUiD,KAAKV,MAAL,CAAYa,GAAZ,CAAgBH,EAAhB,CAVjD;;cAAA;gBAAA;;cAAA;gBAUQI,SAVR;gBAWIF,MAAM,GAAGE,SAAS,KAAKC,SAAd,IAA2BD,SAAS,KAAK,IAAlD;gBAXJ;gBAAA;;cAAA;gBAAA;gBAAA;gBAaI;gBACAE,OAAO,CAACC,KAAR,CAAc,0CAAd;;cAdJ;gBAAA,kCAiBSL,MAjBT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;kFAoBA,kBAAiBF,EAAjB;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,IACOA,EADP;kBAAA;kBAAA;gBAAA;;gBAAA,MAEU,IAAIF,KAAJ,CAAU,2BAAV,CAFV;;cAAA;gBAAA,MAIM,KAAKR,MAAL,CAAYW,MAAZ,IAAsB,KAAKX,MAAL,CAAYW,MAAZ,KAAuB,MAJnD;kBAAA;kBAAA;gBAAA;;gBAAA,kCAKWN,OAAO,CAACC,OAAR,CAAgB,IAAhB,CALX;;cAAA;gBAQQY,UARR,GAQqB,SAAbA,UAAa;kBAAA,OAAM,IAAIb,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;oBACxDnB,MAAM,CAAC+B,IAAP,CAAYC,eAAZ,CAA4B,WAA5B,EAAyC,GAAzC,EAA8C,UAACC,GAAD,EAAMC,GAAN,EAAc;sBAC1D,IAAI,CAACD,GAAL,EAAU;wBACRf,OAAO,CAACgB,GAAD,CAAP;sBACD;;sBACDf,MAAM,CAACc,GAAD,CAAN;oBACD,CALD;kBAMD,CAPwB,CAAN;gBAAA,CARrB;;gBAAA;gBAAA,OAiBqBH,UAAU,EAjB/B;;cAAA;gBAiBQC,IAjBR;gBAkBQI,eAlBR,GAkB0BhC,MAAM,CAACiC,IAAP,CAAYnC,SAAS,CAACoC,gBAAV,CAA2BN,IAAI,CAACO,MAAL,CAAYC,OAAZ,EAA3B,EAAkD,KAAlD,CAAZ,CAlB1B;gBAmBQL,GAnBR,GAmBc;kBACVM,SAAS,EAAEL,eAAe,CAACM,QAAhB,CAAyB,KAAzB,CADD;kBAEVC,UAAU,EAAEX,IAAI,CAACQ,OAAL,GAAeE,QAAf,CAAwB,KAAxB;gBAFF,CAnBd;gBAAA;gBAAA;gBAAA,OAyBU,KAAK7B,MAAL,CAAY+B,GAAZ,CAAgBrB,EAAhB,EAAoBsB,IAAI,CAACC,SAAL,CAAeX,GAAf,CAApB,CAzBV;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBA2BIN,OAAO,CAACkB,GAAR;;cA3BJ;gBA6BE,KAAK/B,MAAL,CAAYgC,GAAZ,CAAgBzB,EAAhB,EAAoBY,GAApB;;gBA7BF,kCA+BSH,IA/BT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;+EAkCA,kBAAcT,EAAd;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,IACOA,EADP;kBAAA;kBAAA;gBAAA;;gBAAA,MAEU,IAAIF,KAAJ,CAAU,wBAAV,CAFV;;cAAA;gBAAA,IAIO,KAAKR,MAJZ;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAKU,KAAKC,IAAL,EALV;;cAAA;gBAAA,MAOM,KAAKD,MAAL,CAAYW,MAAZ,IAAsB,KAAKX,MAAL,CAAYW,MAAZ,KAAuB,MAPnD;kBAAA;kBAAA;gBAAA;;gBAAA,kCAQWN,OAAO,CAACC,OAAR,CAAgB,IAAhB,CARX;;cAAA;gBAWQ8B,SAXR,GAWoB,KAAKjC,MAAL,CAAYU,GAAZ,CAAgBH,EAAhB,CAXpB;gBAAA;gBAAA,eAcgB0B,SAdhB;;gBAAA;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAcmC,KAAKpC,MAAL,CAAYa,GAAZ,CAAgBH,EAAhB,CAdnC;;cAAA;gBAAA;;cAAA;gBAcII,SAdJ;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA,IAmBOA,SAnBP;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAuBQuB,eAvBR,GAuB0BD,SAAS,IAAIJ,IAAI,CAACM,KAAL,CAAWxB,SAAX,CAvBvC;;gBAAA,IAwBOuB,eAxBP;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBA4BE,IAAI,CAACD,SAAL,EAAgB;kBACd,KAAKjC,MAAL,CAAYgC,GAAZ,CAAgBzB,EAAhB,EAAoB2B,eAApB;gBACD;;gBAEKE,UAhCR,GAgCqB,SAAbA,UAAa,CAACC,EAAD;kBAAA,OAAQ,IAAInC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;oBAC1DnB,MAAM,CAAC+B,IAAP,CAAYsB,aAAZ,CAA0BpD,SAA1B,CAAoCqD,4BAApC,CAAiEF,EAAjE,EAAqE,UAACnB,GAAD,EAAMC,GAAN,EAAc;sBACjF,IAAI,CAACD,GAAL,EAAU;wBACRf,OAAO,CAACgB,GAAD,CAAP;sBACD;;sBACDf,MAAM,CAACc,GAAD,CAAN;oBACD,CALD;kBAMD,CAP0B,CAAR;gBAAA,CAhCrB;;gBAAA,kCAyCSkB,UAAU,CAAChD,MAAM,CAACiC,IAAP,CAAYa,eAAe,CAACP,UAA5B,EAAwC,KAAxC,CAAD,CAzCnB;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;6EA4CA,kBAAYR,GAAZ,EAAiBqB,IAAjB;QAAA;UAAA;YAAA;cAAA;gBAAA,IACOrB,GADP;kBAAA;kBAAA;gBAAA;;gBAAA,MAEU,IAAId,KAAJ,CAAU,sBAAV,CAFV;;cAAA;gBAAA,IAKOmC,IALP;kBAAA;kBAAA;gBAAA;;gBAAA,MAMU,IAAInC,KAAJ,CAAU,gCAAV,CANV;;cAAA;gBASE,IAAI,CAACjB,MAAM,CAACqD,QAAP,CAAgBD,IAAhB,CAAL,EAA4B;kBAC1BA,IAAI,GAAGpD,MAAM,CAACiC,IAAP,CAAYmB,IAAZ,CAAP;gBACD;;gBAXH,kCAaS,IAAItC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;kBACtCe,GAAG,CAACuB,IAAJ,CAASF,IAAT,EAAe,UAACtB,GAAD,EAAMyB,SAAN,EAAoB;oBACjC,IAAI,CAACzB,GAAL,EAAU;sBACRf,OAAO,CAACwC,SAAS,CAACjB,QAAV,CAAmB,KAAnB,CAAD,CAAP;oBACD;;oBACDtB,MAAM,CAACc,GAAD,CAAN;kBACD,CALD;gBAMD,CAPM,CAbT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;WAuBA,mBAAWF,IAAX,EAA+B;MAAA,IAAd4B,OAAc,uEAAJ,EAAI;MAC7B,IAAMC,OAAO,GAAG,CAAC,KAAD,EAAQ,QAAR,CAAhB;MACA,IAAMC,UAAU,GAAG,OAAOF,OAAO,CAACE,UAAf,KAA8B,WAA9B,GAA4C,IAA5C,GAAmDF,OAAO,CAACE,UAA9E;MACA,IAAMC,MAAM,GAAGH,OAAO,CAACG,MAAR,IAAkB,KAAjC;;MACA,IAAIF,OAAO,CAACG,OAAR,CAAgBD,MAAhB,MAA4B,CAAC,CAAjC,EAAoC;QAClC,MAAM,IAAI1C,KAAJ,CAAU,0CAAV,CAAN;MACD;;MACD,IAAI4C,MAAM,GAAGjC,IAAI,CAACO,MAAL,CAAYC,OAAZ,EAAb;;MACA,IAAIsB,UAAJ,EAAgB;QACdG,MAAM,GAAG7D,MAAM,CAACiC,IAAP,CAAYnC,SAAS,CAACoC,gBAAV,CAA2B2B,MAA3B,EAAmC,KAAnC,CAAZ,CAAT;MACD;;MACD,OAAOF,MAAM,KAAK,QAAX,GAAsBE,MAAtB,GAA+BA,MAAM,CAACvB,QAAP,CAAgB,KAAhB,CAAtC;IACD;;;;+EAED,kBAAciB,SAAd,EAAyBlB,SAAzB,EAAoCe,IAApC;QAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAA0CU,CAA1C,8DAA8C,IAA9C;gBAAA,kCACSvD,QAAQ,CAACwD,MAAT,CAAgBR,SAAhB,EAA2BlB,SAA3B,EAAsCe,IAAtC,EAA4CU,CAA5C,CADT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;gFAIA,kBAAqBP,SAArB,EAAgClB,SAAhC,EAA2Ce,IAA3C;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAiDU,CAAjD,8DAAqD,IAArD;gBACQE,MADR,GACiB1D,aAAa,CAACgB,GAAd,CAAkBiC,SAAlB,CADjB;gBAEMU,GAFN,GAEY,KAFZ;;gBAAA,IAGOD,MAHP;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAI2B/D,QAAQ,CAAC6D,CAAD,CAAR,CAAYC,MAAZ,CAAmBR,SAAnB,EAA8BlB,SAA9B,EAAyCe,IAAzC,CAJ3B;;cAAA;gBAIUc,QAJV;gBAKID,GAAG,GAAGC,QAAN;;gBACA,IAAIA,QAAJ,EAAc;kBACZ5D,aAAa,CAACsC,GAAd,CAAkBW,SAAlB,EAA6B;oBAAElB,SAAS,EAATA,SAAF;oBAAae,IAAI,EAAJA;kBAAb,CAA7B;gBACD;;gBARL;gBAAA;;cAAA;gBAUUe,OAVV,GAUoB,SAAVA,OAAU,CAACH,MAAD,EAASZ,IAAT,EAAeU,CAAf,EAAqB;kBACnC,IAAIM,KAAJ;;kBACA,IAAIN,CAAC,KAAK,IAAV,EAAgB;oBACdM,KAAK,GAAGpE,MAAM,CAACmE,OAAP,CAAenE,MAAM,CAACqE,KAAP,CAAa,EAAb,EAAiBL,MAAjB,CAAf,EAAyChE,MAAM,CAACqE,KAAP,CAAa,EAAb,EAAiBjB,IAAjB,CAAzC,MAAqE,CAA7E;kBACD,CAFD,MAEO;oBACLgB,KAAK,GAAGpE,MAAM,CAACqD,QAAP,CAAgBD,IAAhB,IAAwBpD,MAAM,CAACmE,OAAP,CAAeH,MAAf,EAAuBZ,IAAvB,MAAiC,CAAzD,GAA6DY,MAAM,KAAKZ,IAAhF;kBACD;;kBACD,OAAOgB,KAAP;gBACD,CAlBL;;gBAmBIH,GAAG,GAAGD,MAAM,CAAC3B,SAAP,KAAqBA,SAArB,IAAkC8B,OAAO,CAACH,MAAM,CAACZ,IAAR,EAAcA,IAAd,EAAoBU,CAApB,CAA/C;;cAnBJ;gBAAA,kCAqBSG,GArBT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;;;AAyBFK,MAAM,CAACC,OAAP,GAAiBhE,QAAjB"},"metadata":{},"sourceType":"script"}