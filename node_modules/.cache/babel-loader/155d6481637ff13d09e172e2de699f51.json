{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:peer-store:address-book'), {\n  error: debug('libp2p:peer-store:address-book:err')\n});\n\nconst errcode = require('err-code');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst Book = require('./book');\n\nconst PeerRecord = require('../record/peer-record');\n\nconst {\n  codes: {\n    ERR_INVALID_PARAMETERS\n  }\n} = require('../errors');\n\nconst Envelope = require('../record/envelope');\n/**\n * @typedef {import('./')} PeerStore\n */\n\n/**\n * @typedef {Object} Address\n * @property {Multiaddr} multiaddr peer multiaddr.\n * @property {boolean} isCertified obtained from a signed peer record.\n *\n * @typedef {Object} CertifiedRecord\n * @property {Uint8Array} raw raw envelope.\n * @property {number} seqNumber seq counter.\n *\n * @typedef {Object} Entry\n * @property {Address[]} addresses peer Addresses.\n * @property {CertifiedRecord} record certified peer record.\n */\n\n/**\n * @extends {Book}\n */\n\n\nclass AddressBook extends Book {\n  /**\n   * The AddressBook is responsible for keeping the known multiaddrs of a peer.\n   *\n   * @class\n   * @param {PeerStore} peerStore\n   */\n  constructor(peerStore) {\n    /**\n     * PeerStore Event emitter, used by the AddressBook to emit:\n     * \"peer\" - emitted when a peer is discovered by the node.\n     * \"change:multiaddrs\" - emitted when the known multiaddrs of a peer change.\n     */\n    super({\n      peerStore,\n      eventName: 'change:multiaddrs',\n      eventProperty: 'multiaddrs',\n      eventTransformer: data => {\n        if (!data.addresses) {\n          return [];\n        }\n\n        return data.addresses.map((\n        /** @type {Address} */\n        address) => address.multiaddr);\n      }\n    });\n    /**\n     * Map known peers to their known Address Entries.\n     *\n     * @type {Map<string, Entry>}\n     */\n\n    this.data = new Map();\n  }\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   *\n   * @param {Envelope} envelope\n   * @returns {boolean}\n   */\n\n\n  consumePeerRecord(envelope) {\n    let peerRecord;\n\n    try {\n      peerRecord = PeerRecord.createFromProtobuf(envelope.payload);\n    } catch (err) {\n      log.error('invalid peer record received');\n      return false;\n    } // Verify peerId\n\n\n    if (!peerRecord.peerId.equals(envelope.peerId)) {\n      log('signing key does not match PeerId in the PeerRecord');\n      return false;\n    } // ensure the record has multiaddrs\n\n\n    if (!peerRecord.multiaddrs || !peerRecord.multiaddrs.length) {\n      return false;\n    }\n\n    const peerId = peerRecord.peerId;\n    const id = peerId.toB58String();\n    const entry = this.data.get(id) || {\n      record: undefined\n    };\n    const storedRecord = entry.record; // ensure seq is greater than, or equal to, the last received\n\n    if (storedRecord && storedRecord.seqNumber >= peerRecord.seqNumber) {\n      return false;\n    }\n\n    const addresses = this._toAddresses(peerRecord.multiaddrs, true); // Replace unsigned addresses by the new ones from the record\n    // TODO: Once we have ttls for the addresses, we should merge these in.\n\n\n    this._setData(peerId, {\n      addresses,\n      record: {\n        raw: envelope.marshal(),\n        seqNumber: peerRecord.seqNumber\n      }\n    });\n\n    log(`stored provided peer record for ${id}`);\n    return true;\n  }\n  /**\n   * Get the raw Envelope for a peer. Returns\n   * undefined if no Envelope is found.\n   *\n   * @param {PeerId} peerId\n   * @returns {Uint8Array|undefined}\n   */\n\n\n  getRawEnvelope(peerId) {\n    const entry = this.data.get(peerId.toB58String());\n\n    if (!entry || !entry.record || !entry.record.raw) {\n      return undefined;\n    }\n\n    return entry.record.raw;\n  }\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   *\n   * @param {PeerId} peerId\n   * @returns {Promise<Envelope|void>|undefined}\n   */\n\n\n  getPeerRecord(peerId) {\n    const raw = this.getRawEnvelope(peerId);\n\n    if (!raw) {\n      return undefined;\n    }\n\n    return Envelope.createFromProtobuf(raw);\n  }\n  /**\n   * Set known multiaddrs of a provided peer.\n   * This will replace previously stored multiaddrs, if available.\n   * Replacing stored multiaddrs might result in losing obtained certified addresses.\n   * If you are not sure, it's recommended to use `add` instead.\n   *\n   * @override\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {AddressBook}\n   */\n\n\n  set(peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const addresses = this._toAddresses(multiaddrs); // Not replace multiaddrs\n\n\n    if (!addresses.length) {\n      return this;\n    }\n\n    const id = peerId.toB58String();\n    const entry = this.data.get(id); // Already knows the peer\n\n    if (entry && entry.addresses && entry.addresses.length === addresses.length) {\n      const intersection = entry.addresses.filter(addr => addresses.some(newAddr => addr.multiaddr.equals(newAddr.multiaddr))); // Are new addresses equal to the old ones?\n      // If yes, no changes needed!\n\n      if (intersection.length === entry.addresses.length) {\n        log(`the addresses provided to store are equal to the already stored for ${id}`);\n        return this;\n      }\n    }\n\n    this._setData(peerId, {\n      addresses,\n      record: entry && entry.record\n    });\n\n    log(`stored provided multiaddrs for ${id}`); // Notify the existance of a new peer\n\n    if (!entry) {\n      this._ps.emit('peer', peerId);\n    }\n\n    return this;\n  }\n  /**\n   * Add known addresses of a provided peer.\n   * If the peer is not known, it is set with the given addresses.\n   *\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {AddressBook}\n   */\n\n\n  add(peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const addresses = this._toAddresses(multiaddrs);\n\n    const id = peerId.toB58String(); // No addresses to be added\n\n    if (!addresses.length) {\n      return this;\n    }\n\n    const entry = this.data.get(id);\n\n    if (entry && entry.addresses) {\n      // Add recorded uniquely to the new array (Union)\n      entry.addresses.forEach(addr => {\n        if (!addresses.find(r => r.multiaddr.equals(addr.multiaddr))) {\n          addresses.push(addr);\n        }\n      }); // If the recorded length is equal to the new after the unique union\n      // The content is the same, no need to update.\n\n      if (entry.addresses.length === addresses.length) {\n        log(`the addresses provided to store are already stored for ${id}`);\n        return this;\n      }\n    }\n\n    this._setData(peerId, {\n      addresses,\n      record: entry && entry.record\n    });\n\n    log(`added provided multiaddrs for ${id}`); // Notify the existance of a new peer\n\n    if (!(entry && entry.addresses)) {\n      this._ps.emit('peer', peerId);\n    }\n\n    return this;\n  }\n  /**\n   * Get the known data of a provided peer.\n   *\n   * @override\n   * @param {PeerId} peerId\n   * @returns {Address[]|undefined}\n   */\n\n\n  get(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const entry = this.data.get(peerId.toB58String());\n    return entry && entry.addresses ? [...entry.addresses] : undefined;\n  }\n  /**\n   * Transforms received multiaddrs into Address.\n   *\n   * @private\n   * @param {Multiaddr[]} multiaddrs\n   * @param {boolean} [isCertified]\n   * @returns {Address[]}\n   */\n\n\n  _toAddresses(multiaddrs) {\n    let isCertified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!multiaddrs) {\n      log.error('multiaddrs must be provided to store data');\n      throw errcode(new Error('multiaddrs must be provided'), ERR_INVALID_PARAMETERS);\n    } // create Address for each address\n\n    /** @type {Address[]} */\n\n\n    const addresses = [];\n    multiaddrs.forEach(addr => {\n      if (!Multiaddr.isMultiaddr(addr)) {\n        log.error(`multiaddr ${addr} must be an instance of multiaddr`);\n        throw errcode(new Error(`multiaddr ${addr} must be an instance of multiaddr`), ERR_INVALID_PARAMETERS);\n      } // Guarantee no replicates\n\n\n      if (!addresses.find(a => a.multiaddr.equals(addr))) {\n        addresses.push({\n          multiaddr: addr,\n          isCertified\n        });\n      }\n    });\n    return addresses;\n  }\n  /**\n   * Get the known multiaddrs for a given peer. All returned multiaddrs\n   * will include the encapsulated `PeerId` of the peer.\n   * Returns `undefined` if there are no known multiaddrs for the given peer.\n   *\n   * @param {PeerId} peerId\n   * @param {(addresses: Address[]) => Address[]} [addressSorter]\n   * @returns {Multiaddr[]|undefined}\n   */\n\n\n  getMultiaddrsForPeer(peerId) {\n    let addressSorter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ms => ms;\n\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const entry = this.data.get(peerId.toB58String());\n\n    if (!entry || !entry.addresses) {\n      return undefined;\n    }\n\n    return addressSorter(entry.addresses || []).map(address => {\n      const multiaddr = address.multiaddr;\n      const idString = multiaddr.getPeerId();\n      if (idString && idString === peerId.toB58String()) return multiaddr;\n      return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`);\n    });\n  }\n\n}\n\nmodule.exports = AddressBook;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errcode","Multiaddr","PeerId","Book","PeerRecord","codes","ERR_INVALID_PARAMETERS","Envelope","AddressBook","constructor","peerStore","eventName","eventProperty","eventTransformer","data","addresses","map","address","multiaddr","Map","consumePeerRecord","envelope","peerRecord","createFromProtobuf","payload","err","peerId","equals","multiaddrs","length","id","toB58String","entry","get","record","undefined","storedRecord","seqNumber","_toAddresses","_setData","raw","marshal","getRawEnvelope","getPeerRecord","set","isPeerId","Error","intersection","filter","addr","some","newAddr","_ps","emit","add","forEach","find","r","push","isCertified","isMultiaddr","a","getMultiaddrsForPeer","addressSorter","ms","idString","getPeerId","encapsulate","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/peer-store/address-book.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:peer-store:address-book'), {\n  error: debug('libp2p:peer-store:address-book:err')\n})\nconst errcode = require('err-code')\n\nconst { Multiaddr } = require('multiaddr')\nconst PeerId = require('peer-id')\n\nconst Book = require('./book')\nconst PeerRecord = require('../record/peer-record')\n\nconst {\n  codes: { ERR_INVALID_PARAMETERS }\n} = require('../errors')\nconst Envelope = require('../record/envelope')\n\n/**\n * @typedef {import('./')} PeerStore\n */\n\n/**\n * @typedef {Object} Address\n * @property {Multiaddr} multiaddr peer multiaddr.\n * @property {boolean} isCertified obtained from a signed peer record.\n *\n * @typedef {Object} CertifiedRecord\n * @property {Uint8Array} raw raw envelope.\n * @property {number} seqNumber seq counter.\n *\n * @typedef {Object} Entry\n * @property {Address[]} addresses peer Addresses.\n * @property {CertifiedRecord} record certified peer record.\n */\n\n/**\n * @extends {Book}\n */\nclass AddressBook extends Book {\n  /**\n   * The AddressBook is responsible for keeping the known multiaddrs of a peer.\n   *\n   * @class\n   * @param {PeerStore} peerStore\n   */\n  constructor (peerStore) {\n    /**\n     * PeerStore Event emitter, used by the AddressBook to emit:\n     * \"peer\" - emitted when a peer is discovered by the node.\n     * \"change:multiaddrs\" - emitted when the known multiaddrs of a peer change.\n     */\n    super({\n      peerStore,\n      eventName: 'change:multiaddrs',\n      eventProperty: 'multiaddrs',\n      eventTransformer: (data) => {\n        if (!data.addresses) {\n          return []\n        }\n        return data.addresses.map((/** @type {Address} */ address) => address.multiaddr)\n      }\n    })\n\n    /**\n     * Map known peers to their known Address Entries.\n     *\n     * @type {Map<string, Entry>}\n     */\n    this.data = new Map()\n  }\n\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   *\n   * @param {Envelope} envelope\n   * @returns {boolean}\n   */\n  consumePeerRecord (envelope) {\n    let peerRecord\n    try {\n      peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n    } catch (err) {\n      log.error('invalid peer record received')\n      return false\n    }\n\n    // Verify peerId\n    if (!peerRecord.peerId.equals(envelope.peerId)) {\n      log('signing key does not match PeerId in the PeerRecord')\n      return false\n    }\n\n    // ensure the record has multiaddrs\n    if (!peerRecord.multiaddrs || !peerRecord.multiaddrs.length) {\n      return false\n    }\n\n    const peerId = peerRecord.peerId\n    const id = peerId.toB58String()\n    const entry = this.data.get(id) || { record: undefined }\n    const storedRecord = entry.record\n\n    // ensure seq is greater than, or equal to, the last received\n    if (storedRecord && storedRecord.seqNumber >= peerRecord.seqNumber) {\n      return false\n    }\n\n    const addresses = this._toAddresses(peerRecord.multiaddrs, true)\n\n    // Replace unsigned addresses by the new ones from the record\n    // TODO: Once we have ttls for the addresses, we should merge these in.\n    this._setData(peerId, {\n      addresses,\n      record: {\n        raw: envelope.marshal(),\n        seqNumber: peerRecord.seqNumber\n      }\n    })\n    log(`stored provided peer record for ${id}`)\n\n    return true\n  }\n\n  /**\n   * Get the raw Envelope for a peer. Returns\n   * undefined if no Envelope is found.\n   *\n   * @param {PeerId} peerId\n   * @returns {Uint8Array|undefined}\n   */\n  getRawEnvelope (peerId) {\n    const entry = this.data.get(peerId.toB58String())\n\n    if (!entry || !entry.record || !entry.record.raw) {\n      return undefined\n    }\n\n    return entry.record.raw\n  }\n\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   *\n   * @param {PeerId} peerId\n   * @returns {Promise<Envelope|void>|undefined}\n   */\n  getPeerRecord (peerId) {\n    const raw = this.getRawEnvelope(peerId)\n\n    if (!raw) {\n      return undefined\n    }\n\n    return Envelope.createFromProtobuf(raw)\n  }\n\n  /**\n   * Set known multiaddrs of a provided peer.\n   * This will replace previously stored multiaddrs, if available.\n   * Replacing stored multiaddrs might result in losing obtained certified addresses.\n   * If you are not sure, it's recommended to use `add` instead.\n   *\n   * @override\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {AddressBook}\n   */\n  set (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const addresses = this._toAddresses(multiaddrs)\n\n    // Not replace multiaddrs\n    if (!addresses.length) {\n      return this\n    }\n\n    const id = peerId.toB58String()\n    const entry = this.data.get(id)\n\n    // Already knows the peer\n    if (entry && entry.addresses && entry.addresses.length === addresses.length) {\n      const intersection = entry.addresses.filter((addr) => addresses.some((newAddr) => addr.multiaddr.equals(newAddr.multiaddr)))\n\n      // Are new addresses equal to the old ones?\n      // If yes, no changes needed!\n      if (intersection.length === entry.addresses.length) {\n        log(`the addresses provided to store are equal to the already stored for ${id}`)\n        return this\n      }\n    }\n\n    this._setData(peerId, {\n      addresses,\n      record: entry && entry.record\n    })\n    log(`stored provided multiaddrs for ${id}`)\n\n    // Notify the existance of a new peer\n    if (!entry) {\n      this._ps.emit('peer', peerId)\n    }\n\n    return this\n  }\n\n  /**\n   * Add known addresses of a provided peer.\n   * If the peer is not known, it is set with the given addresses.\n   *\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {AddressBook}\n   */\n  add (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const addresses = this._toAddresses(multiaddrs)\n    const id = peerId.toB58String()\n\n    // No addresses to be added\n    if (!addresses.length) {\n      return this\n    }\n\n    const entry = this.data.get(id)\n\n    if (entry && entry.addresses) {\n      // Add recorded uniquely to the new array (Union)\n      entry.addresses.forEach((addr) => {\n        if (!addresses.find(r => r.multiaddr.equals(addr.multiaddr))) {\n          addresses.push(addr)\n        }\n      })\n\n      // If the recorded length is equal to the new after the unique union\n      // The content is the same, no need to update.\n      if (entry.addresses.length === addresses.length) {\n        log(`the addresses provided to store are already stored for ${id}`)\n        return this\n      }\n    }\n\n    this._setData(peerId, {\n      addresses,\n      record: entry && entry.record\n    })\n\n    log(`added provided multiaddrs for ${id}`)\n\n    // Notify the existance of a new peer\n    if (!(entry && entry.addresses)) {\n      this._ps.emit('peer', peerId)\n    }\n\n    return this\n  }\n\n  /**\n   * Get the known data of a provided peer.\n   *\n   * @override\n   * @param {PeerId} peerId\n   * @returns {Address[]|undefined}\n   */\n  get (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const entry = this.data.get(peerId.toB58String())\n\n    return entry && entry.addresses ? [...entry.addresses] : undefined\n  }\n\n  /**\n   * Transforms received multiaddrs into Address.\n   *\n   * @private\n   * @param {Multiaddr[]} multiaddrs\n   * @param {boolean} [isCertified]\n   * @returns {Address[]}\n   */\n  _toAddresses (multiaddrs, isCertified = false) {\n    if (!multiaddrs) {\n      log.error('multiaddrs must be provided to store data')\n      throw errcode(new Error('multiaddrs must be provided'), ERR_INVALID_PARAMETERS)\n    }\n\n    // create Address for each address\n    /** @type {Address[]} */\n    const addresses = []\n    multiaddrs.forEach((addr) => {\n      if (!Multiaddr.isMultiaddr(addr)) {\n        log.error(`multiaddr ${addr} must be an instance of multiaddr`)\n        throw errcode(new Error(`multiaddr ${addr} must be an instance of multiaddr`), ERR_INVALID_PARAMETERS)\n      }\n\n      // Guarantee no replicates\n      if (!addresses.find((a) => a.multiaddr.equals(addr))) {\n        addresses.push({\n          multiaddr: addr,\n          isCertified\n        })\n      }\n    })\n\n    return addresses\n  }\n\n  /**\n   * Get the known multiaddrs for a given peer. All returned multiaddrs\n   * will include the encapsulated `PeerId` of the peer.\n   * Returns `undefined` if there are no known multiaddrs for the given peer.\n   *\n   * @param {PeerId} peerId\n   * @param {(addresses: Address[]) => Address[]} [addressSorter]\n   * @returns {Multiaddr[]|undefined}\n   */\n  getMultiaddrsForPeer (peerId, addressSorter = (ms) => ms) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const entry = this.data.get(peerId.toB58String())\n    if (!entry || !entry.addresses) {\n      return undefined\n    }\n\n    return addressSorter(\n      entry.addresses || []\n    ).map((address) => {\n      const multiaddr = address.multiaddr\n\n      const idString = multiaddr.getPeerId()\n      if (idString && idString === peerId.toB58String()) return multiaddr\n\n      return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`)\n    })\n  }\n}\n\nmodule.exports = AddressBook\n"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcJ,KAAK,CAAC,gCAAD,CAAnB,EAAuD;EACjEK,KAAK,EAAEL,KAAK,CAAC,oCAAD;AADqD,CAAvD,CAAZ;;AAGA,MAAMM,OAAO,GAAGL,OAAO,CAAC,UAAD,CAAvB;;AAEA,MAAM;EAAEM;AAAF,IAAgBN,OAAO,CAAC,WAAD,CAA7B;;AACA,MAAMO,MAAM,GAAGP,OAAO,CAAC,SAAD,CAAtB;;AAEA,MAAMQ,IAAI,GAAGR,OAAO,CAAC,QAAD,CAApB;;AACA,MAAMS,UAAU,GAAGT,OAAO,CAAC,uBAAD,CAA1B;;AAEA,MAAM;EACJU,KAAK,EAAE;IAAEC;EAAF;AADH,IAEFX,OAAO,CAAC,WAAD,CAFX;;AAGA,MAAMY,QAAQ,GAAGZ,OAAO,CAAC,oBAAD,CAAxB;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMa,WAAN,SAA0BL,IAA1B,CAA+B;EAC7B;AACF;AACA;AACA;AACA;AACA;EACEM,WAAW,CAAEC,SAAF,EAAa;IACtB;AACJ;AACA;AACA;AACA;IACI,MAAM;MACJA,SADI;MAEJC,SAAS,EAAE,mBAFP;MAGJC,aAAa,EAAE,YAHX;MAIJC,gBAAgB,EAAGC,IAAD,IAAU;QAC1B,IAAI,CAACA,IAAI,CAACC,SAAV,EAAqB;UACnB,OAAO,EAAP;QACD;;QACD,OAAOD,IAAI,CAACC,SAAL,CAAeC,GAAf,CAAmB;QAAC;QAAuBC,OAAxB,KAAoCA,OAAO,CAACC,SAA/D,CAAP;MACD;IATG,CAAN;IAYA;AACJ;AACA;AACA;AACA;;IACI,KAAKJ,IAAL,GAAY,IAAIK,GAAJ,EAAZ;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEC,iBAAiB,CAAEC,QAAF,EAAY;IAC3B,IAAIC,UAAJ;;IACA,IAAI;MACFA,UAAU,GAAGlB,UAAU,CAACmB,kBAAX,CAA8BF,QAAQ,CAACG,OAAvC,CAAb;IACD,CAFD,CAEE,OAAOC,GAAP,EAAY;MACZ7B,GAAG,CAACG,KAAJ,CAAU,8BAAV;MACA,OAAO,KAAP;IACD,CAP0B,CAS3B;;;IACA,IAAI,CAACuB,UAAU,CAACI,MAAX,CAAkBC,MAAlB,CAAyBN,QAAQ,CAACK,MAAlC,CAAL,EAAgD;MAC9C9B,GAAG,CAAC,qDAAD,CAAH;MACA,OAAO,KAAP;IACD,CAb0B,CAe3B;;;IACA,IAAI,CAAC0B,UAAU,CAACM,UAAZ,IAA0B,CAACN,UAAU,CAACM,UAAX,CAAsBC,MAArD,EAA6D;MAC3D,OAAO,KAAP;IACD;;IAED,MAAMH,MAAM,GAAGJ,UAAU,CAACI,MAA1B;IACA,MAAMI,EAAE,GAAGJ,MAAM,CAACK,WAAP,EAAX;IACA,MAAMC,KAAK,GAAG,KAAKlB,IAAL,CAAUmB,GAAV,CAAcH,EAAd,KAAqB;MAAEI,MAAM,EAAEC;IAAV,CAAnC;IACA,MAAMC,YAAY,GAAGJ,KAAK,CAACE,MAA3B,CAvB2B,CAyB3B;;IACA,IAAIE,YAAY,IAAIA,YAAY,CAACC,SAAb,IAA0Bf,UAAU,CAACe,SAAzD,EAAoE;MAClE,OAAO,KAAP;IACD;;IAED,MAAMtB,SAAS,GAAG,KAAKuB,YAAL,CAAkBhB,UAAU,CAACM,UAA7B,EAAyC,IAAzC,CAAlB,CA9B2B,CAgC3B;IACA;;;IACA,KAAKW,QAAL,CAAcb,MAAd,EAAsB;MACpBX,SADoB;MAEpBmB,MAAM,EAAE;QACNM,GAAG,EAAEnB,QAAQ,CAACoB,OAAT,EADC;QAENJ,SAAS,EAAEf,UAAU,CAACe;MAFhB;IAFY,CAAtB;;IAOAzC,GAAG,CAAE,mCAAkCkC,EAAG,EAAvC,CAAH;IAEA,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEY,cAAc,CAAEhB,MAAF,EAAU;IACtB,MAAMM,KAAK,GAAG,KAAKlB,IAAL,CAAUmB,GAAV,CAAcP,MAAM,CAACK,WAAP,EAAd,CAAd;;IAEA,IAAI,CAACC,KAAD,IAAU,CAACA,KAAK,CAACE,MAAjB,IAA2B,CAACF,KAAK,CAACE,MAAN,CAAaM,GAA7C,EAAkD;MAChD,OAAOL,SAAP;IACD;;IAED,OAAOH,KAAK,CAACE,MAAN,CAAaM,GAApB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEG,aAAa,CAAEjB,MAAF,EAAU;IACrB,MAAMc,GAAG,GAAG,KAAKE,cAAL,CAAoBhB,MAApB,CAAZ;;IAEA,IAAI,CAACc,GAAL,EAAU;MACR,OAAOL,SAAP;IACD;;IAED,OAAO5B,QAAQ,CAACgB,kBAAT,CAA4BiB,GAA5B,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEI,GAAG,CAAElB,MAAF,EAAUE,UAAV,EAAsB;IACvB,IAAI,CAAC1B,MAAM,CAAC2C,QAAP,CAAgBnB,MAAhB,CAAL,EAA8B;MAC5B9B,GAAG,CAACG,KAAJ,CAAU,qDAAV;MACA,MAAMC,OAAO,CAAC,IAAI8C,KAAJ,CAAU,uCAAV,CAAD,EAAqDxC,sBAArD,CAAb;IACD;;IAED,MAAMS,SAAS,GAAG,KAAKuB,YAAL,CAAkBV,UAAlB,CAAlB,CANuB,CAQvB;;;IACA,IAAI,CAACb,SAAS,CAACc,MAAf,EAAuB;MACrB,OAAO,IAAP;IACD;;IAED,MAAMC,EAAE,GAAGJ,MAAM,CAACK,WAAP,EAAX;IACA,MAAMC,KAAK,GAAG,KAAKlB,IAAL,CAAUmB,GAAV,CAAcH,EAAd,CAAd,CAduB,CAgBvB;;IACA,IAAIE,KAAK,IAAIA,KAAK,CAACjB,SAAf,IAA4BiB,KAAK,CAACjB,SAAN,CAAgBc,MAAhB,KAA2Bd,SAAS,CAACc,MAArE,EAA6E;MAC3E,MAAMkB,YAAY,GAAGf,KAAK,CAACjB,SAAN,CAAgBiC,MAAhB,CAAwBC,IAAD,IAAUlC,SAAS,CAACmC,IAAV,CAAgBC,OAAD,IAAaF,IAAI,CAAC/B,SAAL,CAAeS,MAAf,CAAsBwB,OAAO,CAACjC,SAA9B,CAA5B,CAAjC,CAArB,CAD2E,CAG3E;MACA;;MACA,IAAI6B,YAAY,CAAClB,MAAb,KAAwBG,KAAK,CAACjB,SAAN,CAAgBc,MAA5C,EAAoD;QAClDjC,GAAG,CAAE,uEAAsEkC,EAAG,EAA3E,CAAH;QACA,OAAO,IAAP;MACD;IACF;;IAED,KAAKS,QAAL,CAAcb,MAAd,EAAsB;MACpBX,SADoB;MAEpBmB,MAAM,EAAEF,KAAK,IAAIA,KAAK,CAACE;IAFH,CAAtB;;IAIAtC,GAAG,CAAE,kCAAiCkC,EAAG,EAAtC,CAAH,CAhCuB,CAkCvB;;IACA,IAAI,CAACE,KAAL,EAAY;MACV,KAAKoB,GAAL,CAASC,IAAT,CAAc,MAAd,EAAsB3B,MAAtB;IACD;;IAED,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE4B,GAAG,CAAE5B,MAAF,EAAUE,UAAV,EAAsB;IACvB,IAAI,CAAC1B,MAAM,CAAC2C,QAAP,CAAgBnB,MAAhB,CAAL,EAA8B;MAC5B9B,GAAG,CAACG,KAAJ,CAAU,qDAAV;MACA,MAAMC,OAAO,CAAC,IAAI8C,KAAJ,CAAU,uCAAV,CAAD,EAAqDxC,sBAArD,CAAb;IACD;;IAED,MAAMS,SAAS,GAAG,KAAKuB,YAAL,CAAkBV,UAAlB,CAAlB;;IACA,MAAME,EAAE,GAAGJ,MAAM,CAACK,WAAP,EAAX,CAPuB,CASvB;;IACA,IAAI,CAAChB,SAAS,CAACc,MAAf,EAAuB;MACrB,OAAO,IAAP;IACD;;IAED,MAAMG,KAAK,GAAG,KAAKlB,IAAL,CAAUmB,GAAV,CAAcH,EAAd,CAAd;;IAEA,IAAIE,KAAK,IAAIA,KAAK,CAACjB,SAAnB,EAA8B;MAC5B;MACAiB,KAAK,CAACjB,SAAN,CAAgBwC,OAAhB,CAAyBN,IAAD,IAAU;QAChC,IAAI,CAAClC,SAAS,CAACyC,IAAV,CAAeC,CAAC,IAAIA,CAAC,CAACvC,SAAF,CAAYS,MAAZ,CAAmBsB,IAAI,CAAC/B,SAAxB,CAApB,CAAL,EAA8D;UAC5DH,SAAS,CAAC2C,IAAV,CAAeT,IAAf;QACD;MACF,CAJD,EAF4B,CAQ5B;MACA;;MACA,IAAIjB,KAAK,CAACjB,SAAN,CAAgBc,MAAhB,KAA2Bd,SAAS,CAACc,MAAzC,EAAiD;QAC/CjC,GAAG,CAAE,0DAAyDkC,EAAG,EAA9D,CAAH;QACA,OAAO,IAAP;MACD;IACF;;IAED,KAAKS,QAAL,CAAcb,MAAd,EAAsB;MACpBX,SADoB;MAEpBmB,MAAM,EAAEF,KAAK,IAAIA,KAAK,CAACE;IAFH,CAAtB;;IAKAtC,GAAG,CAAE,iCAAgCkC,EAAG,EAArC,CAAH,CArCuB,CAuCvB;;IACA,IAAI,EAAEE,KAAK,IAAIA,KAAK,CAACjB,SAAjB,CAAJ,EAAiC;MAC/B,KAAKqC,GAAL,CAASC,IAAT,CAAc,MAAd,EAAsB3B,MAAtB;IACD;;IAED,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEO,GAAG,CAAEP,MAAF,EAAU;IACX,IAAI,CAACxB,MAAM,CAAC2C,QAAP,CAAgBnB,MAAhB,CAAL,EAA8B;MAC5B,MAAM1B,OAAO,CAAC,IAAI8C,KAAJ,CAAU,uCAAV,CAAD,EAAqDxC,sBAArD,CAAb;IACD;;IAED,MAAM0B,KAAK,GAAG,KAAKlB,IAAL,CAAUmB,GAAV,CAAcP,MAAM,CAACK,WAAP,EAAd,CAAd;IAEA,OAAOC,KAAK,IAAIA,KAAK,CAACjB,SAAf,GAA2B,CAAC,GAAGiB,KAAK,CAACjB,SAAV,CAA3B,GAAkDoB,SAAzD;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEG,YAAY,CAAEV,UAAF,EAAmC;IAAA,IAArB+B,WAAqB,uEAAP,KAAO;;IAC7C,IAAI,CAAC/B,UAAL,EAAiB;MACfhC,GAAG,CAACG,KAAJ,CAAU,2CAAV;MACA,MAAMC,OAAO,CAAC,IAAI8C,KAAJ,CAAU,6BAAV,CAAD,EAA2CxC,sBAA3C,CAAb;IACD,CAJ4C,CAM7C;;IACA;;;IACA,MAAMS,SAAS,GAAG,EAAlB;IACAa,UAAU,CAAC2B,OAAX,CAAoBN,IAAD,IAAU;MAC3B,IAAI,CAAChD,SAAS,CAAC2D,WAAV,CAAsBX,IAAtB,CAAL,EAAkC;QAChCrD,GAAG,CAACG,KAAJ,CAAW,aAAYkD,IAAK,mCAA5B;QACA,MAAMjD,OAAO,CAAC,IAAI8C,KAAJ,CAAW,aAAYG,IAAK,mCAA5B,CAAD,EAAkE3C,sBAAlE,CAAb;MACD,CAJ0B,CAM3B;;;MACA,IAAI,CAACS,SAAS,CAACyC,IAAV,CAAgBK,CAAD,IAAOA,CAAC,CAAC3C,SAAF,CAAYS,MAAZ,CAAmBsB,IAAnB,CAAtB,CAAL,EAAsD;QACpDlC,SAAS,CAAC2C,IAAV,CAAe;UACbxC,SAAS,EAAE+B,IADE;UAEbU;QAFa,CAAf;MAID;IACF,CAbD;IAeA,OAAO5C,SAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE+C,oBAAoB,CAAEpC,MAAF,EAAsC;IAAA,IAA5BqC,aAA4B,uEAAXC,EAAD,IAAQA,EAAI;;IACxD,IAAI,CAAC9D,MAAM,CAAC2C,QAAP,CAAgBnB,MAAhB,CAAL,EAA8B;MAC5B,MAAM1B,OAAO,CAAC,IAAI8C,KAAJ,CAAU,uCAAV,CAAD,EAAqDxC,sBAArD,CAAb;IACD;;IAED,MAAM0B,KAAK,GAAG,KAAKlB,IAAL,CAAUmB,GAAV,CAAcP,MAAM,CAACK,WAAP,EAAd,CAAd;;IACA,IAAI,CAACC,KAAD,IAAU,CAACA,KAAK,CAACjB,SAArB,EAAgC;MAC9B,OAAOoB,SAAP;IACD;;IAED,OAAO4B,aAAa,CAClB/B,KAAK,CAACjB,SAAN,IAAmB,EADD,CAAb,CAELC,GAFK,CAEAC,OAAD,IAAa;MACjB,MAAMC,SAAS,GAAGD,OAAO,CAACC,SAA1B;MAEA,MAAM+C,QAAQ,GAAG/C,SAAS,CAACgD,SAAV,EAAjB;MACA,IAAID,QAAQ,IAAIA,QAAQ,KAAKvC,MAAM,CAACK,WAAP,EAA7B,EAAmD,OAAOb,SAAP;MAEnD,OAAOA,SAAS,CAACiD,WAAV,CAAuB,QAAOzC,MAAM,CAACK,WAAP,EAAqB,EAAnD,CAAP;IACD,CATM,CAAP;EAUD;;AAtT4B;;AAyT/BqC,MAAM,CAACC,OAAP,GAAiB7D,WAAjB"},"metadata":{},"sourceType":"script"}