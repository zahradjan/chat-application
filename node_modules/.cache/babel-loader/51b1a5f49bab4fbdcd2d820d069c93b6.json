{"ast":null,"code":"'use strict'; // JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\n\nconst BITS_PER_BYTE = 7;\nmodule.exports = class SparseArray {\n  constructor() {\n    this._bitArrays = [];\n    this._data = [];\n    this._length = 0;\n    this._changedLength = false;\n    this._changedData = false;\n  }\n\n  set(index, value) {\n    let pos = this._internalPositionFor(index, false);\n\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos);\n\n        this._unsetBit(index);\n\n        this._changedLength = true;\n        this._changedData = true;\n      }\n    } else {\n      let needsSort = false;\n\n      if (pos === -1) {\n        pos = this._data.length;\n\n        this._setBit(index);\n\n        this._changedData = true;\n      } else {\n        needsSort = true;\n      }\n\n      this._setInternalPos(pos, index, value, needsSort);\n\n      this._changedLength = true;\n    }\n  }\n\n  unset(index) {\n    this.set(index, undefined);\n  }\n\n  get(index) {\n    this._sortData();\n\n    const pos = this._internalPositionFor(index, true);\n\n    if (pos === -1) {\n      return undefined;\n    }\n\n    return this._data[pos][1];\n  }\n\n  push(value) {\n    this.set(this.length, value);\n    return this.length;\n  }\n\n  get length() {\n    this._sortData();\n\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1];\n      this._length = last ? last[0] + 1 : 0;\n      this._changedLength = false;\n    }\n\n    return this._length;\n  }\n\n  forEach(iterator) {\n    let i = 0;\n\n    while (i < this.length) {\n      iterator(this.get(i), i, this);\n      i++;\n    }\n  }\n\n  map(iterator) {\n    let i = 0;\n    let mapped = new Array(this.length);\n\n    while (i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this);\n      i++;\n    }\n\n    return mapped;\n  }\n\n  reduce(reducer, initialValue) {\n    let i = 0;\n    let acc = initialValue;\n\n    while (i < this.length) {\n      const value = this.get(i);\n      acc = reducer(acc, value, i);\n      i++;\n    }\n\n    return acc;\n  }\n\n  find(finder) {\n    let i = 0,\n        found,\n        last;\n\n    while (i < this.length && !found) {\n      last = this.get(i);\n      found = finder(last);\n      i++;\n    }\n\n    return found ? last : undefined;\n  }\n\n  _internalPositionFor(index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate);\n\n    if (bytePos >= this._bitArrays.length) {\n      return -1;\n    }\n\n    const byte = this._bitArrays[bytePos];\n    const bitPos = index - bytePos * BITS_PER_BYTE;\n    const exists = (byte & 1 << bitPos) > 0;\n\n    if (!exists) {\n      return -1;\n    }\n\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);\n\n    const mask = ~(0xffffffff << bitPos + 1);\n    const bytePopCount = popCount(byte & mask);\n    const arrayPos = previousPopCount + bytePopCount - 1;\n    return arrayPos;\n  }\n\n  _bytePosFor(index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE);\n    const targetLength = bytePos + 1;\n\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0);\n    }\n\n    return bytePos;\n  }\n\n  _setBit(index) {\n    const bytePos = this._bytePosFor(index, false);\n\n    this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false);\n\n    this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data = this._data;\n    const elem = [index, value];\n\n    if (needsSort) {\n      this._sortData();\n\n      data[pos] = elem;\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem);\n        } else if (data[0][0] <= index) {\n          data.unshift(elem);\n        } else {\n          const randomIndex = Math.round(data.length / 2);\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));\n        }\n      } else {\n        this._data.push(elem);\n      }\n\n      this._changedData = true;\n      this._changedLength = true;\n    }\n  }\n\n  _unsetInternalPos(pos) {\n    this._data.splice(pos, 1);\n  }\n\n  _sortData() {\n    if (this._changedData) {\n      this._data.sort(sortInternal);\n    }\n\n    this._changedData = false;\n  }\n\n  bitField() {\n    const bytes = [];\n    let pendingBitsForResultingByte = 8;\n    let pendingBitsForNewByte = 0;\n    let resultingByte = 0;\n    let newByte;\n\n    const pending = this._bitArrays.slice();\n\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift();\n        pendingBitsForNewByte = 7;\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);\n      const mask = ~(0b11111111 << usingBits);\n      const masked = newByte & mask;\n      resultingByte |= masked << 8 - pendingBitsForResultingByte;\n      newByte = newByte >>> usingBits;\n      pendingBitsForNewByte -= usingBits;\n      pendingBitsForResultingByte -= usingBits;\n\n      if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {\n        bytes.push(resultingByte);\n        resultingByte = 0;\n        pendingBitsForResultingByte = 8;\n      }\n    } // remove trailing zeroes\n\n\n    for (var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i];\n\n      if (value === 0) {\n        bytes.pop();\n      } else {\n        break;\n      }\n    }\n\n    return bytes;\n  }\n\n  compactArray() {\n    this._sortData();\n\n    return this._data.map(valueOnly);\n  }\n\n};\n\nfunction popCountReduce(count, byte) {\n  return count + popCount(byte);\n}\n\nfunction popCount(_v) {\n  let v = _v;\n  v = v - (v >> 1 & 0x55555555); // reuse input as temporary\n\n  v = (v & 0x33333333) + (v >> 2 & 0x33333333); // temp\n\n  return (v + (v >> 4) & 0xF0F0F0F) * 0x1010101 >> 24;\n}\n\nfunction sortInternal(a, b) {\n  return a[0] - b[0];\n}\n\nfunction valueOnly(elem) {\n  return elem[1];\n}","map":{"version":3,"names":["BITS_PER_BYTE","module","exports","SparseArray","constructor","_bitArrays","_data","_length","_changedLength","_changedData","set","index","value","pos","_internalPositionFor","undefined","_unsetInternalPos","_unsetBit","needsSort","length","_setBit","_setInternalPos","unset","get","_sortData","push","last","forEach","iterator","i","map","mapped","Array","reduce","reducer","initialValue","acc","find","finder","found","noCreate","bytePos","_bytePosFor","byte","bitPos","exists","previousPopCount","slice","popCountReduce","mask","bytePopCount","popCount","arrayPos","Math","floor","targetLength","data","elem","unshift","randomIndex","round","concat","splice","sort","sortInternal","bitField","bytes","pendingBitsForResultingByte","pendingBitsForNewByte","resultingByte","newByte","pending","shift","usingBits","min","masked","pop","compactArray","valueOnly","count","_v","v","a","b"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/sparse-array/index.js"],"sourcesContent":["'use strict'\n\n// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\nconst BITS_PER_BYTE = 7\n\nmodule.exports = class SparseArray {\n  constructor () {\n    this._bitArrays = []\n    this._data = []\n    this._length = 0\n    this._changedLength = false\n    this._changedData = false\n  }\n\n  set (index, value) {\n    let pos = this._internalPositionFor(index, false)\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos)\n        this._unsetBit(index)\n        this._changedLength = true\n        this._changedData = true\n      }\n    } else {\n      let needsSort = false\n      if (pos === -1) {\n        pos = this._data.length\n        this._setBit(index)\n        this._changedData = true\n      } else {\n        needsSort = true\n      }\n      this._setInternalPos(pos, index, value, needsSort)\n      this._changedLength = true\n    }\n  }\n\n  unset (index) {\n    this.set(index, undefined)\n  }\n\n  get (index) {\n    this._sortData()\n    const pos = this._internalPositionFor(index, true)\n    if (pos === -1) {\n      return undefined\n    }\n    return this._data[pos][1]\n  }\n\n  push (value) {\n    this.set(this.length, value)\n    return this.length\n  }\n\n  get length () {\n    this._sortData()\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1]\n      this._length = last ? last[0] + 1 : 0\n      this._changedLength = false\n    }\n    return this._length\n  }\n\n  forEach (iterator) {\n    let i = 0\n    while(i < this.length) {\n      iterator(this.get(i), i, this)\n      i++\n    }\n  }\n\n  map (iterator) {\n    let i = 0\n    let mapped = new Array(this.length)\n    while(i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this)\n      i++\n    }\n    return mapped\n  }\n\n  reduce (reducer, initialValue) {\n    let i = 0\n    let acc = initialValue\n    while(i < this.length) {\n      const value = this.get(i)\n      acc = reducer(acc, value, i)\n      i++\n    }\n    return acc\n  }\n\n  find (finder) {\n    let i = 0, found, last\n    while ((i < this.length) && !found) {\n      last = this.get(i)\n      found = finder(last)\n      i++\n    }\n    return found ? last : undefined\n  }\n\n  _internalPositionFor (index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate)\n    if (bytePos >= this._bitArrays.length) {\n      return -1\n    }\n    const byte = this._bitArrays[bytePos]\n    const bitPos = index - bytePos * BITS_PER_BYTE\n    const exists = (byte & (1 << bitPos)) > 0\n    if (!exists) {\n      return -1\n    }\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0)\n\n    const mask = ~(0xffffffff << (bitPos + 1))\n    const bytePopCount = popCount(byte & mask)\n    const arrayPos = previousPopCount + bytePopCount - 1\n    return arrayPos\n  }\n\n  _bytePosFor (index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE)\n    const targetLength = bytePos + 1\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0)\n    }\n    return bytePos\n  }\n\n  _setBit (index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] |= (1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] &= ~(1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data =this._data\n    const elem = [index, value]\n    if (needsSort) {\n      this._sortData()\n      data[pos] = elem\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem)\n        } else if (data[0][0] <= index) {\n          data.unshift(elem)\n        } else {\n          const randomIndex = Math.round(data.length / 2)\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex))\n        }\n      } else {\n        this._data.push(elem)\n      }\n      this._changedData = true\n      this._changedLength = true\n    }\n  }\n\n  _unsetInternalPos (pos) {\n    this._data.splice(pos, 1)\n  }\n\n  _sortData () {\n    if (this._changedData) {\n      this._data.sort(sortInternal)\n    }\n\n    this._changedData = false\n  }\n\n  bitField () {\n    const bytes = []\n    let pendingBitsForResultingByte = 8\n    let pendingBitsForNewByte = 0\n    let resultingByte = 0\n    let newByte\n    const pending = this._bitArrays.slice()\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift()\n        pendingBitsForNewByte = 7\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte)\n      const mask = ~(0b11111111 << usingBits)\n      const masked = newByte & mask\n      resultingByte |= masked << (8 - pendingBitsForResultingByte)\n      newByte = newByte >>> usingBits\n      pendingBitsForNewByte -= usingBits\n      pendingBitsForResultingByte -= usingBits\n\n      if (!pendingBitsForResultingByte || (!pendingBitsForNewByte && !pending.length)) {\n        bytes.push(resultingByte)\n        resultingByte = 0\n        pendingBitsForResultingByte = 8\n      }\n    }\n\n    // remove trailing zeroes\n    for(var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i]\n      if (value === 0) {\n        bytes.pop()\n      } else {\n        break\n      }\n    }\n\n    return bytes\n  }\n\n  compactArray () {\n    this._sortData()\n    return this._data.map(valueOnly)\n  }\n}\n\nfunction popCountReduce (count, byte) {\n  return count + popCount(byte)\n}\n\nfunction popCount(_v) {\n  let v = _v\n  v = v - ((v >> 1) & 0x55555555)                    // reuse input as temporary\n  v = (v & 0x33333333) + ((v >> 2) & 0x33333333)     // temp\n  return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n}\n\nfunction sortInternal (a, b) {\n  return a[0] - b[0]\n}\n\nfunction valueOnly (elem) {\n  return elem[1]\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}