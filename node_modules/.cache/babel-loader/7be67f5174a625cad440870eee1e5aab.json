{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar ConsumableBuffer = require('./consumable-buffer');\n\nvar _require = require('uint8arrays/concat'),\n    uint8ArrayConcat = _require.concat;\n/**\n * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n */\n\n\nfunction wrapHash(hashFn) {\n  /**\n   * @param {InfiniteHash | Uint8Array} value\n   */\n  function hashing(value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value;\n    } else {\n      return new InfiniteHash(value, hashFn);\n    }\n  }\n\n  return hashing;\n}\n\nvar InfiniteHash = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {Uint8Array} value\n   * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n   */\n  function InfiniteHash(value, hashFn) {\n    _classCallCheck(this, InfiniteHash);\n\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays');\n    }\n\n    this._value = value;\n    this._hashFn = hashFn;\n    this._depth = -1;\n    this._availableBits = 0;\n    this._currentBufferIndex = 0;\n    /** @type {ConsumableBuffer[]} */\n\n    this._buffers = [];\n  }\n  /**\n   * @param {number} bits\n   */\n\n\n  _createClass(InfiniteHash, [{\n    key: \"take\",\n    value: function () {\n      var _take = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(bits) {\n        var pendingBits, result, hash, available, took;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                pendingBits = bits;\n\n              case 1:\n                if (!(this._availableBits < pendingBits)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 4;\n                return this._produceMoreBits();\n\n              case 4:\n                _context.next = 1;\n                break;\n\n              case 6:\n                result = 0;\n\n                while (pendingBits > 0) {\n                  hash = this._buffers[this._currentBufferIndex];\n                  available = Math.min(hash.availableBits(), pendingBits);\n                  took = hash.take(available);\n                  result = (result << available) + took;\n                  pendingBits -= available;\n                  this._availableBits -= available;\n\n                  if (hash.availableBits() === 0) {\n                    this._currentBufferIndex++;\n                  }\n                }\n\n                return _context.abrupt(\"return\", result);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function take(_x) {\n        return _take.apply(this, arguments);\n      }\n\n      return take;\n    }()\n    /**\n     * @param {number} bits\n     */\n\n  }, {\n    key: \"untake\",\n    value: function untake(bits) {\n      var pendingBits = bits;\n\n      while (pendingBits > 0) {\n        var hash = this._buffers[this._currentBufferIndex];\n        var availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);\n        hash.untake(availableForUntake);\n        pendingBits -= availableForUntake;\n        this._availableBits += availableForUntake;\n\n        if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n          this._depth--;\n          this._currentBufferIndex--;\n        }\n      }\n    }\n  }, {\n    key: \"_produceMoreBits\",\n    value: function () {\n      var _produceMoreBits2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var value, hashValue, buffer;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._depth++;\n                value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value;\n                _context2.next = 4;\n                return this._hashFn(value);\n\n              case 4:\n                hashValue = _context2.sent;\n                buffer = new ConsumableBuffer(hashValue);\n\n                this._buffers.push(buffer);\n\n                this._availableBits += buffer.availableBits();\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _produceMoreBits() {\n        return _produceMoreBits2.apply(this, arguments);\n      }\n\n      return _produceMoreBits;\n    }()\n  }]);\n\n  return InfiniteHash;\n}();\n\nmodule.exports = wrapHash;\nmodule.exports.InfiniteHash = InfiniteHash;","map":{"version":3,"names":["ConsumableBuffer","require","uint8ArrayConcat","concat","wrapHash","hashFn","hashing","value","InfiniteHash","Uint8Array","Error","_value","_hashFn","_depth","_availableBits","_currentBufferIndex","_buffers","bits","pendingBits","_produceMoreBits","result","hash","available","Math","min","availableBits","took","take","availableForUntake","totalBits","untake","from","hashValue","buffer","push","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/hamt-sharding/src/consumable-hash.js"],"sourcesContent":["'use strict'\n\nconst ConsumableBuffer = require('./consumable-buffer')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\n\n/**\n * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n */\nfunction wrapHash (hashFn) {\n  /**\n   * @param {InfiniteHash | Uint8Array} value\n   */\n  function hashing (value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nclass InfiniteHash {\n  /**\n   *\n   * @param {Uint8Array} value\n   * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n   */\n  constructor (value, hashFn) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n\n    /** @type {ConsumableBuffer[]} */\n    this._buffers = []\n  }\n\n  /**\n   * @param {number} bits\n   */\n  async take (bits) {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * @param {number} bits\n   */\n  untake (bits) {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits () {\n    this._depth++\n\n    const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n\nmodule.exports = wrapHash\nmodule.exports.InfiniteHash = InfiniteHash\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}