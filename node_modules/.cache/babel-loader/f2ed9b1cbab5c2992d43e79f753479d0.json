{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:upgrader'), {\n  error: debug('libp2p:upgrader:err')\n});\n\nconst errCode = require('err-code'); // @ts-ignore multistream-select does not export types\n\n\nconst Multistream = require('multistream-select');\n\nconst {\n  Connection\n} = require('libp2p-interfaces/src/connection');\n\nconst PeerId = require('peer-id');\n\nconst {\n  pipe\n} = require('it-pipe'); // @ts-ignore mutable-proxy does not export types\n\n\nconst mutableProxy = require('mutable-proxy');\n\nconst {\n  codes\n} = require('./errors');\n/**\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').Muxer} Muxer\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @typedef CryptoResult\n * @property {MultiaddrConnection} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {import('./metrics')} [options.metrics]\n   * @param {Map<string, Crypto>} [options.cryptos]\n   * @param {Map<string, MuxerFactory>} [options.muxers]\n   * @param {(connection: Connection) => void} options.onConnection - Called when a connection is upgraded\n   * @param {(connection: Connection) => void} options.onConnectionEnd\n   */\n  constructor(_ref) {\n    let {\n      localPeer,\n      metrics,\n      cryptos = new Map(),\n      muxers = new Map(),\n      onConnectionEnd = () => {},\n      onConnection = () => {}\n    } = _ref;\n    this.localPeer = localPeer;\n    this.metrics = metrics;\n    this.cryptos = cryptos;\n    this.muxers = muxers;\n    /** @type {import(\"./pnet\") | null} */\n\n    this.protector = null;\n    this.protocols = new Map();\n    this.onConnection = onConnection;\n    this.onConnectionEnd = onConnectionEnd;\n  }\n  /**\n   * Upgrades an inbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  async upgradeInbound(maConn) {\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let Muxer;\n    let cryptoProtocol;\n    let setPeer;\n    let proxyPeer;\n\n    if (this.metrics) {\n      ({\n        setTarget: setPeer,\n        proxy: proxyPeer\n      } = mutableProxy());\n      const idString = (Math.random() * 1e9).toString(36) + Date.now();\n      setPeer({\n        toB58String: () => idString\n      });\n      maConn = this.metrics.trackStream({\n        stream: maConn,\n        remotePeer: proxyPeer\n      });\n    }\n\n    log('Starting the inbound connection upgrade'); // Protect\n\n    let protectedConn = maConn;\n\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn);\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos)); // Multiplex the connection\n\n      if (this.muxers.size) {\n        ({\n          stream: upgradedConn,\n          Muxer\n        } = await this._multiplexInbound(encryptedConn, this.muxers));\n      } else {\n        upgradedConn = encryptedConn;\n      }\n    } catch (err) {\n      log.error('Failed to upgrade inbound connection', err);\n      await maConn.close(err);\n      throw err;\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n      setPeer(remotePeer);\n    }\n\n    log('Successfully upgraded inbound connection');\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'inbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    });\n  }\n  /**\n   * Upgrades an outbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  async upgradeOutbound(maConn) {\n    const idStr = maConn.remoteAddr.getPeerId();\n\n    if (!idStr) {\n      throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR);\n    }\n\n    const remotePeerId = PeerId.createFromB58String(idStr);\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let cryptoProtocol;\n    let Muxer;\n    let setPeer;\n    let proxyPeer;\n\n    if (this.metrics) {\n      ({\n        setTarget: setPeer,\n        proxy: proxyPeer\n      } = mutableProxy());\n      const idString = (Math.random() * 1e9).toString(36) + Date.now();\n      setPeer({\n        toB58String: () => idString\n      });\n      maConn = this.metrics.trackStream({\n        stream: maConn,\n        remotePeer: proxyPeer\n      });\n    }\n\n    log('Starting the outbound connection upgrade'); // Protect\n\n    let protectedConn = maConn;\n\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn);\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos)); // Multiplex the connection\n\n      if (this.muxers.size) {\n        ({\n          stream: upgradedConn,\n          Muxer\n        } = await this._multiplexOutbound(encryptedConn, this.muxers));\n      } else {\n        upgradedConn = encryptedConn;\n      }\n    } catch (err) {\n      log.error('Failed to upgrade outbound connection', err);\n      await maConn.close(err);\n      throw err;\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n      setPeer(remotePeer);\n    }\n\n    log('Successfully upgraded outbound connection');\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    });\n  }\n  /**\n   * A convenience method for generating a new `Connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {string} options.cryptoProtocol - The crypto protocol that was negotiated\n   * @param {'inbound' | 'outbound'} options.direction - One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} options.maConn - The transport layer connection\n   * @param {MuxedStream | MultiaddrConnection} options.upgradedConn - A duplex connection returned from multiplexer and/or crypto selection\n   * @param {MuxerFactory} [options.Muxer] - The muxer to be used for muxing\n   * @param {PeerId} options.remotePeer - The peer the connection is with\n   * @returns {Connection}\n   */\n\n\n  _createConnection(_ref2) {\n    var _this = this;\n\n    let {\n      cryptoProtocol,\n      direction,\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    } = _ref2;\n\n    /** @type {import(\"libp2p-interfaces/src/stream-muxer/types\").Muxer} */\n    let muxer;\n    /** @type {import(\"libp2p-interfaces/src/connection/connection\").CreatedMuxedStream | undefined} */\n\n    let newStream;\n    /** @type {Connection} */\n\n    let connection; // eslint-disable-line prefer-const\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: async muxedStream => {\n          if (!connection) return;\n          const mss = new Multistream.Listener(muxedStream);\n\n          try {\n            const {\n              stream,\n              protocol\n            } = await mss.handle(Array.from(this.protocols.keys()));\n            log('%s: incoming stream opened on %s', direction, protocol);\n            if (this.metrics) this.metrics.trackStream({\n              stream,\n              remotePeer,\n              protocol\n            });\n            connection.addStream(muxedStream, {\n              protocol\n            });\n\n            this._onStream({\n              connection,\n              stream: { ...muxedStream,\n                ...stream\n              },\n              protocol\n            });\n          } catch (err) {\n            log.error(err);\n          }\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id);\n        }\n      });\n\n      newStream = async protocols => {\n        log('%s: starting new stream on %s', direction, protocols);\n        const muxedStream = muxer.newStream();\n        const mss = new Multistream.Dialer(muxedStream);\n\n        try {\n          const {\n            stream,\n            protocol\n          } = await mss.select(protocols);\n          if (this.metrics) this.metrics.trackStream({\n            stream,\n            remotePeer,\n            protocol\n          });\n          return {\n            stream: { ...muxedStream,\n              ...stream\n            },\n            protocol\n          };\n        } catch (err) {\n          log.error('could not create new stream', err);\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL);\n        }\n      }; // Pipe all data through the muxer\n\n\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error);\n    }\n\n    const _timeline = maConn.timeline;\n    maConn.timeline = new Proxy(_timeline, {\n      set: function () {\n        if (connection && (arguments.length <= 1 ? undefined : arguments[1]) === 'close' && (arguments.length <= 2 ? undefined : arguments[2]) && !_timeline.close) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.stat.status === 'open') {\n                await connection.close();\n              }\n            } catch (err) {\n              log.error(err);\n            } finally {\n              _this.onConnectionEnd(connection);\n            }\n          })();\n        }\n\n        return Reflect.set(...arguments);\n      }\n    });\n    maConn.timeline.upgraded = Date.now();\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED');\n    }; // Create the connection\n\n\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        // @ts-ignore\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed(),\n      close: async () => {\n        await maConn.close(); // Ensure remaining streams are aborted\n\n        if (muxer) {\n          muxer.streams.map(stream => stream.abort());\n        }\n      }\n    });\n    this.onConnection(connection);\n    return connection;\n  }\n  /**\n   * Routes incoming streams to the correct handler\n   *\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection - The connection the stream belongs to\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   */\n\n\n  _onStream(_ref3) {\n    let {\n      connection,\n      stream,\n      protocol\n    } = _ref3;\n    const handler = this.protocols.get(protocol);\n    handler({\n      connection,\n      stream,\n      protocol\n    });\n  }\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  async _encryptInbound(localPeer, connection, cryptos) {\n    const mss = new Multistream.Listener(connection);\n    const protocols = Array.from(cryptos.keys());\n    log('handling inbound crypto protocol selection', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.handle(protocols);\n      const crypto = cryptos.get(protocol);\n      log('encrypting inbound connection...');\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`);\n      }\n\n      return { ...(await crypto.secureInbound(localPeer, stream)),\n        protocol\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {MultiaddrConnection} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  async _encryptOutbound(localPeer, connection, remotePeerId, cryptos) {\n    const mss = new Multistream.Dialer(connection);\n    const protocols = Array.from(cryptos.keys());\n    log('selecting outbound crypto protocol', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.select(protocols);\n      const crypto = cryptos.get(protocol);\n      log('encrypting outbound connection to %j', remotePeerId);\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`);\n      }\n\n      return { ...(await crypto.secureOutbound(localPeer, stream, remotePeerId)),\n        protocol\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n\n\n  async _multiplexOutbound(connection, muxers) {\n    const dialer = new Multistream.Dialer(connection);\n    const protocols = Array.from(muxers.keys());\n    log('outbound selecting muxer %s', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await dialer.select(protocols);\n      log('%s selected as muxer protocol', protocol);\n      const Muxer = muxers.get(protocol);\n      return {\n        stream,\n        Muxer\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n\n\n  async _multiplexInbound(connection, muxers) {\n    const listener = new Multistream.Listener(connection);\n    const protocols = Array.from(muxers.keys());\n    log('inbound handling muxers %s', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await listener.handle(protocols);\n      const Muxer = muxers.get(protocol);\n      return {\n        stream,\n        Muxer\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n\n}\n\nmodule.exports = Upgrader;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errCode","Multistream","Connection","PeerId","pipe","mutableProxy","codes","Upgrader","constructor","localPeer","metrics","cryptos","Map","muxers","onConnectionEnd","onConnection","protector","protocols","upgradeInbound","maConn","encryptedConn","remotePeer","upgradedConn","Muxer","cryptoProtocol","setPeer","proxyPeer","setTarget","proxy","idString","Math","random","toString","Date","now","toB58String","trackStream","stream","protectedConn","protect","conn","protocol","_encryptInbound","size","_multiplexInbound","err","close","updatePlaceholder","_createConnection","direction","upgradeOutbound","idStr","remoteAddr","getPeerId","Error","ERR_INVALID_MULTIADDR","remotePeerId","createFromB58String","_encryptOutbound","_multiplexOutbound","muxer","newStream","connection","onStream","muxedStream","mss","Listener","handle","Array","from","keys","addStream","_onStream","onStreamEnd","removeStream","id","Dialer","select","ERR_UNSUPPORTED_PROTOCOL","catch","_timeline","timeline","Proxy","set","stat","status","Reflect","upgraded","errConnectionNotMultiplexed","localAddr","multiplexer","multicodec","encryption","getStreams","streams","map","abort","handler","get","crypto","secureInbound","ERR_ENCRYPTION_FAILED","secureOutbound","dialer","ERR_MUXER_UNAVAILABLE","listener","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/upgrader.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:upgrader'), {\n  error: debug('libp2p:upgrader:err')\n})\nconst errCode = require('err-code')\n// @ts-ignore multistream-select does not export types\nconst Multistream = require('multistream-select')\nconst { Connection } = require('libp2p-interfaces/src/connection')\nconst PeerId = require('peer-id')\nconst { pipe } = require('it-pipe')\n// @ts-ignore mutable-proxy does not export types\nconst mutableProxy = require('mutable-proxy')\n\nconst { codes } = require('./errors')\n\n/**\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').Muxer} Muxer\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @typedef CryptoResult\n * @property {MultiaddrConnection} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {import('./metrics')} [options.metrics]\n   * @param {Map<string, Crypto>} [options.cryptos]\n   * @param {Map<string, MuxerFactory>} [options.muxers]\n   * @param {(connection: Connection) => void} options.onConnection - Called when a connection is upgraded\n   * @param {(connection: Connection) => void} options.onConnectionEnd\n   */\n  constructor ({\n    localPeer,\n    metrics,\n    cryptos = new Map(),\n    muxers = new Map(),\n    onConnectionEnd = () => {},\n    onConnection = () => {}\n  }) {\n    this.localPeer = localPeer\n    this.metrics = metrics\n    this.cryptos = cryptos\n    this.muxers = muxers\n    /** @type {import(\"./pnet\") | null} */\n    this.protector = null\n    this.protocols = new Map()\n    this.onConnection = onConnection\n    this.onConnectionEnd = onConnectionEnd\n  }\n\n  /**\n   * Upgrades an inbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeInbound (maConn) {\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let Muxer\n    let cryptoProtocol\n    let setPeer\n    let proxyPeer\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (Math.random() * 1e9).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the inbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos))\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexInbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (err) {\n      log.error('Failed to upgrade inbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded inbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'inbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * Upgrades an outbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeOutbound (maConn) {\n    const idStr = maConn.remoteAddr.getPeerId()\n    if (!idStr) {\n      throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR)\n    }\n\n    const remotePeerId = PeerId.createFromB58String(idStr)\n\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let cryptoProtocol\n    let Muxer\n    let setPeer\n    let proxyPeer\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (Math.random() * 1e9).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the outbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos))\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexOutbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (err) {\n      log.error('Failed to upgrade outbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded outbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {string} options.cryptoProtocol - The crypto protocol that was negotiated\n   * @param {'inbound' | 'outbound'} options.direction - One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} options.maConn - The transport layer connection\n   * @param {MuxedStream | MultiaddrConnection} options.upgradedConn - A duplex connection returned from multiplexer and/or crypto selection\n   * @param {MuxerFactory} [options.Muxer] - The muxer to be used for muxing\n   * @param {PeerId} options.remotePeer - The peer the connection is with\n   * @returns {Connection}\n   */\n  _createConnection ({\n    cryptoProtocol,\n    direction,\n    maConn,\n    upgradedConn,\n    Muxer,\n    remotePeer\n  }) {\n    /** @type {import(\"libp2p-interfaces/src/stream-muxer/types\").Muxer} */\n    let muxer\n    /** @type {import(\"libp2p-interfaces/src/connection/connection\").CreatedMuxedStream | undefined} */\n    let newStream\n    /** @type {Connection} */\n    let connection // eslint-disable-line prefer-const\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: async muxedStream => {\n          if (!connection) return\n          const mss = new Multistream.Listener(muxedStream)\n          try {\n            const { stream, protocol } = await mss.handle(Array.from(this.protocols.keys()))\n            log('%s: incoming stream opened on %s', direction, protocol)\n            if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n            connection.addStream(muxedStream, { protocol })\n            this._onStream({ connection, stream: { ...muxedStream, ...stream }, protocol })\n          } catch (err) {\n            log.error(err)\n          }\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id)\n        }\n      })\n\n      newStream = async (protocols) => {\n        log('%s: starting new stream on %s', direction, protocols)\n        const muxedStream = muxer.newStream()\n        const mss = new Multistream.Dialer(muxedStream)\n        try {\n          const { stream, protocol } = await mss.select(protocols)\n          if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n          return { stream: { ...muxedStream, ...stream }, protocol }\n        } catch (err) {\n          log.error('could not create new stream', err)\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL)\n        }\n      }\n\n      // Pipe all data through the muxer\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error)\n    }\n\n    const _timeline = maConn.timeline\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection && args[1] === 'close' && args[2] && !_timeline.close) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.stat.status === 'open') {\n                await connection.close()\n              }\n            } catch (err) {\n              log.error(err)\n            } finally {\n              this.onConnectionEnd(connection)\n            }\n          })()\n        }\n\n        return Reflect.set(...args)\n      }\n    })\n    maConn.timeline.upgraded = Date.now()\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED')\n    }\n\n    // Create the connection\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        // @ts-ignore\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed(),\n      close: async () => {\n        await maConn.close()\n        // Ensure remaining streams are aborted\n        if (muxer) {\n          muxer.streams.map(stream => stream.abort())\n        }\n      }\n    })\n\n    this.onConnection(connection)\n\n    return connection\n  }\n\n  /**\n   * Routes incoming streams to the correct handler\n   *\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection - The connection the stream belongs to\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   */\n  _onStream ({ connection, stream, protocol }) {\n    const handler = this.protocols.get(protocol)\n    handler({ connection, stream, protocol })\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptInbound (localPeer, connection, cryptos) {\n    const mss = new Multistream.Listener(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('handling inbound crypto protocol selection', protocols)\n\n    try {\n      const { stream, protocol } = await mss.handle(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting inbound connection...')\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      return {\n        ...await crypto.secureInbound(localPeer, stream),\n        protocol\n      }\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {MultiaddrConnection} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptOutbound (localPeer, connection, remotePeerId, cryptos) {\n    const mss = new Multistream.Dialer(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('selecting outbound crypto protocol', protocols)\n\n    try {\n      const { stream, protocol } = await mss.select(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting outbound connection to %j', remotePeerId)\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      return {\n        ...await crypto.secureOutbound(localPeer, stream, remotePeerId),\n        protocol\n      }\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n  async _multiplexOutbound (connection, muxers) {\n    const dialer = new Multistream.Dialer(connection)\n    const protocols = Array.from(muxers.keys())\n    log('outbound selecting muxer %s', protocols)\n    try {\n      const { stream, protocol } = await dialer.select(protocols)\n      log('%s selected as muxer protocol', protocol)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n  async _multiplexInbound (connection, muxers) {\n    const listener = new Multistream.Listener(connection)\n    const protocols = Array.from(muxers.keys())\n    log('inbound handling muxers %s', protocols)\n    try {\n      const { stream, protocol } = await listener.handle(protocols)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n}\n\nmodule.exports = Upgrader\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}