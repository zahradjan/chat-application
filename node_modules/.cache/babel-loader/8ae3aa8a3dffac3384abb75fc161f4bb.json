{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar _asyncGeneratorDelegate = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate.js\").default;\n\nvar _require = require('multiformats/cid'),\n    CID = _require.CID;\n\nvar log = require('debug')('ipfs:repo:gc');\n\nvar _require2 = require('interface-datastore'),\n    Errors = _require2.Errors;\n\nvar ERR_NOT_FOUND = Errors.notFoundError().code;\n\nvar parallelBatch = require('it-parallel-batch');\n\nvar _require3 = require('it-pipe'),\n    pipe = _require3.pipe;\n\nvar merge = require('it-merge');\n\nvar map = require('it-map');\n\nvar filter = require('it-filter');\n\nvar _require4 = require('interface-datastore'),\n    Key = _require4.Key;\n\nvar _require5 = require('multiformats/bases/base32'),\n    base32 = _require5.base32;\n\nvar walkDag = require('./utils/walk-dag'); // Limit on the number of parallel block remove operations\n\n\nvar BLOCK_RM_CONCURRENCY = 256;\nvar MFS_ROOT_KEY = new Key('/local/filesroot');\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./pins').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\n\nmodule.exports = function (_ref) {\n  var gcLock = _ref.gcLock,\n      pins = _ref.pins,\n      blockstore = _ref.blockstore,\n      root = _ref.root,\n      loadCodec = _ref.loadCodec;\n\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  function gc() {\n    return _gc.apply(this, arguments);\n  }\n\n  function _gc() {\n    _gc = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var start, release, markedSet, blockKeys;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              start = Date.now();\n              log('Creating set of marked blocks');\n              _context.next = 4;\n              return _awaitAsyncGenerator(gcLock.writeLock());\n\n            case 4:\n              release = _context.sent;\n              _context.prev = 5;\n              _context.next = 8;\n              return _awaitAsyncGenerator(createMarkedSet({\n                pins: pins,\n                blockstore: blockstore,\n                root: root,\n                loadCodec: loadCodec\n              }));\n\n            case 8:\n              markedSet = _context.sent;\n              // Get all blocks keys from the blockstore\n              blockKeys = blockstore.queryKeys({}); // Delete blocks that are not being used\n              // @ts-ignore ts cannot tell that we filter out null results\n\n              return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(deleteUnmarkedBlocks({\n                blockstore: blockstore\n              }, markedSet, blockKeys)), _awaitAsyncGenerator), \"t0\", 11);\n\n            case 11:\n              log(\"Complete (\".concat(Date.now() - start, \"ms)\"));\n\n            case 12:\n              _context.prev = 12;\n              release();\n              return _context.finish(12);\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[5,, 12, 15]]);\n    }));\n    return _gc.apply(this, arguments);\n  }\n\n  return gc;\n};\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pins').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\n\n\nfunction createMarkedSet(_x4) {\n  return _createMarkedSet.apply(this, arguments);\n}\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\n\n\nfunction _createMarkedSet() {\n  _createMarkedSet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {\n    var pins, blockstore, loadCodec, root, mfsSource, pinsSource, output, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, cid;\n\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            pins = _ref2.pins, blockstore = _ref2.blockstore, loadCodec = _ref2.loadCodec, root = _ref2.root;\n            mfsSource = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n              var mh, rootCid;\n              return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                while (1) {\n                  switch (_context5.prev = _context5.next) {\n                    case 0:\n                      _context5.prev = 0;\n                      _context5.next = 3;\n                      return _awaitAsyncGenerator(root.get(MFS_ROOT_KEY));\n\n                    case 3:\n                      mh = _context5.sent;\n                      _context5.next = 12;\n                      break;\n\n                    case 6:\n                      _context5.prev = 6;\n                      _context5.t0 = _context5[\"catch\"](0);\n\n                      if (!(_context5.t0.code === ERR_NOT_FOUND)) {\n                        _context5.next = 11;\n                        break;\n                      }\n\n                      log('No blocks in MFS');\n                      return _context5.abrupt(\"return\");\n\n                    case 11:\n                      throw _context5.t0;\n\n                    case 12:\n                      rootCid = CID.decode(mh);\n                      _context5.next = 15;\n                      return rootCid;\n\n                    case 15:\n                      return _context5.delegateYield(_asyncGeneratorDelegate(_asyncIterator(walkDag(rootCid, blockstore, loadCodec)), _awaitAsyncGenerator), \"t1\", 16);\n\n                    case 16:\n                    case \"end\":\n                      return _context5.stop();\n                  }\n                }\n              }, _callee5, null, [[0, 6]]);\n            }))();\n            pinsSource = merge(map(pins.recursiveKeys(), function (_ref5) {\n              var cid = _ref5.cid;\n              return cid;\n            }), pins.indirectKeys(), map(pins.directKeys(), function (_ref6) {\n              var cid = _ref6.cid;\n              return cid;\n            }), mfsSource);\n            output = new Set();\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context6.prev = 6;\n            _iterator = _asyncIterator(merge(pinsSource, mfsSource));\n\n          case 8:\n            _context6.next = 10;\n            return _iterator.next();\n\n          case 10:\n            if (!(_iteratorAbruptCompletion = !(_step = _context6.sent).done)) {\n              _context6.next = 16;\n              break;\n            }\n\n            cid = _step.value;\n            output.add(base32.encode(cid.multihash.bytes));\n\n          case 13:\n            _iteratorAbruptCompletion = false;\n            _context6.next = 8;\n            break;\n\n          case 16:\n            _context6.next = 22;\n            break;\n\n          case 18:\n            _context6.prev = 18;\n            _context6.t0 = _context6[\"catch\"](6);\n            _didIteratorError = true;\n            _iteratorError = _context6.t0;\n\n          case 22:\n            _context6.prev = 22;\n            _context6.prev = 23;\n\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context6.next = 27;\n              break;\n            }\n\n            _context6.next = 27;\n            return _iterator.return();\n\n          case 27:\n            _context6.prev = 27;\n\n            if (!_didIteratorError) {\n              _context6.next = 30;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 30:\n            return _context6.finish(27);\n\n          case 31:\n            return _context6.finish(22);\n\n          case 32:\n            return _context6.abrupt(\"return\", output);\n\n          case 33:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6, null, [[6, 18, 22, 32], [23,, 27, 31]]);\n  }));\n  return _createMarkedSet.apply(this, arguments);\n}\n\nfunction deleteUnmarkedBlocks(_x, _x2, _x3) {\n  return _deleteUnmarkedBlocks.apply(this, arguments);\n}\n\nfunction _deleteUnmarkedBlocks() {\n  _deleteUnmarkedBlocks = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref3, markedSet, blockKeys) {\n    var blockstore, blocksCount, removedBlocksCount, removeBlock;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            blockstore = _ref3.blockstore;\n            // Iterate through all blocks and find those that are not in the marked set\n            // blockKeys yields { key: Key() }\n            blocksCount = 0;\n            removedBlocksCount = 0;\n            /**\n             * @param {CID} cid\n             */\n\n            removeBlock = /*#__PURE__*/function () {\n              var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(cid) {\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        return _context3.abrupt(\"return\", /*#__PURE__*/function () {\n                          var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                            var b32, msg;\n                            return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                              while (1) {\n                                switch (_context2.prev = _context2.next) {\n                                  case 0:\n                                    blocksCount++;\n                                    _context2.prev = 1;\n                                    b32 = base32.encode(cid.multihash.bytes);\n\n                                    if (!markedSet.has(b32)) {\n                                      _context2.next = 5;\n                                      break;\n                                    }\n\n                                    return _context2.abrupt(\"return\", null);\n\n                                  case 5:\n                                    _context2.prev = 5;\n                                    _context2.next = 8;\n                                    return blockstore.delete(cid);\n\n                                  case 8:\n                                    removedBlocksCount++;\n                                    _context2.next = 14;\n                                    break;\n\n                                  case 11:\n                                    _context2.prev = 11;\n                                    _context2.t0 = _context2[\"catch\"](5);\n                                    return _context2.abrupt(\"return\", {\n                                      err: new Error(\"Could not delete block with CID \".concat(cid, \": \").concat(_context2.t0.message))\n                                    });\n\n                                  case 14:\n                                    return _context2.abrupt(\"return\", {\n                                      cid: cid\n                                    });\n\n                                  case 17:\n                                    _context2.prev = 17;\n                                    _context2.t1 = _context2[\"catch\"](1);\n                                    msg = \"Could delete block with CID \".concat(cid);\n                                    log(msg, _context2.t1);\n                                    return _context2.abrupt(\"return\", {\n                                      err: new Error(msg + \": \".concat(_context2.t1.message))\n                                    });\n\n                                  case 22:\n                                  case \"end\":\n                                    return _context2.stop();\n                                }\n                              }\n                            }, _callee2, null, [[1, 17], [5, 11]]);\n                          }));\n\n                          function remove() {\n                            return _remove.apply(this, arguments);\n                          }\n\n                          return remove;\n                        }());\n\n                      case 1:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3);\n              }));\n\n              return function removeBlock(_x5) {\n                return _ref4.apply(this, arguments);\n              };\n            }();\n\n            return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pipe(parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY), // filter nulls (blocks that were retained)\n            function (source) {\n              return filter(source, Boolean);\n            })), _awaitAsyncGenerator), \"t0\", 5);\n\n          case 5:\n            log(\"Marked set has \".concat(markedSet.size, \" unique blocks. Blockstore has \").concat(blocksCount, \" blocks. \") + \"Deleted \".concat(removedBlocksCount, \" blocks.\"));\n\n          case 6:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _deleteUnmarkedBlocks.apply(this, arguments);\n}","map":{"version":3,"names":["require","CID","log","Errors","ERR_NOT_FOUND","notFoundError","code","parallelBatch","pipe","merge","map","filter","Key","base32","walkDag","BLOCK_RM_CONCURRENCY","MFS_ROOT_KEY","module","exports","gcLock","pins","blockstore","root","loadCodec","gc","start","Date","now","writeLock","release","createMarkedSet","markedSet","blockKeys","queryKeys","deleteUnmarkedBlocks","mfsSource","get","mh","rootCid","decode","pinsSource","recursiveKeys","cid","indirectKeys","directKeys","output","Set","add","encode","multihash","bytes","blocksCount","removedBlocksCount","removeBlock","b32","has","delete","err","Error","message","msg","remove","source","Boolean","size"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-repo/src/gc.js"],"sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst log = require('debug')('ipfs:repo:gc')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst parallelBatch = require('it-parallel-batch')\nconst { pipe } = require('it-pipe')\nconst merge = require('it-merge')\nconst map = require('it-map')\nconst filter = require('it-filter')\nconst { Key } = require('interface-datastore')\nconst { base32 } = require('multiformats/bases/base32')\nconst walkDag = require('./utils/walk-dag')\n\n// Limit on the number of parallel block remove operations\nconst BLOCK_RM_CONCURRENCY = 256\n\nconst MFS_ROOT_KEY = new Key('/local/filesroot')\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./pins').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nmodule.exports = ({ gcLock, pins, blockstore, root, loadCodec }) => {\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  async function * gc () {\n    const start = Date.now()\n    log('Creating set of marked blocks')\n\n    const release = await gcLock.writeLock()\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({ pins, blockstore, root, loadCodec })\n      // Get all blocks keys from the blockstore\n      const blockKeys = blockstore.queryKeys({})\n\n      // Delete blocks that are not being used\n      // @ts-ignore ts cannot tell that we filter out null results\n      yield * deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys)\n\n      log(`Complete (${Date.now() - start}ms)`)\n    } finally {\n      release()\n    }\n  }\n\n  return gc\n}\n\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pins').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nasync function createMarkedSet ({ pins, blockstore, loadCodec, root }) {\n  const mfsSource = (async function * () {\n    let mh\n    try {\n      mh = await root.get(MFS_ROOT_KEY)\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS')\n        return\n      }\n\n      throw err\n    }\n\n    const rootCid = CID.decode(mh)\n    yield rootCid\n    yield * walkDag(rootCid, blockstore, loadCodec)\n  })()\n\n  const pinsSource = merge(\n    map(pins.recursiveKeys(), ({ cid }) => cid),\n    pins.indirectKeys(),\n    map(pins.directKeys(), ({ cid }) => cid),\n    mfsSource\n  )\n\n  const output = new Set()\n\n  for await (const cid of merge(pinsSource, mfsSource)) {\n    output.add(base32.encode(cid.multihash.bytes))\n  }\n\n  return output\n}\n\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\nasync function * deleteUnmarkedBlocks ({ blockstore }, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0\n  let removedBlocksCount = 0\n\n  /**\n   * @param {CID} cid\n   */\n  const removeBlock = async (cid) => {\n    return async function remove () {\n      blocksCount++\n\n      try {\n        const b32 = base32.encode(cid.multihash.bytes)\n\n        if (markedSet.has(b32)) {\n          return null\n        }\n\n        try {\n          await blockstore.delete(cid)\n          removedBlocksCount++\n        } catch (err) {\n          return {\n            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n          }\n        }\n\n        return { cid }\n      } catch (err) {\n        const msg = `Could delete block with CID ${cid}`\n        log(msg, err)\n        return { err: new Error(msg + `: ${err.message}`) }\n      }\n    }\n  }\n\n  yield * pipe(\n    parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY),\n    // filter nulls (blocks that were retained)\n    source => filter(source, Boolean)\n  )\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` +\n  `Deleted ${removedBlocksCount} blocks.`)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}