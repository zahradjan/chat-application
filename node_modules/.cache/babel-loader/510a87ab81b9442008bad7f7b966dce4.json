{"ast":null,"code":"/* eslint-env browser */\n'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar TLRU = require('../utils/tlru');\n\nvar _require = require('p-queue'),\n    PQueue = _require.default;\n\nvar HTTP = require('ipfs-utils/src/http'); // Avoid sending multiple queries for the same hostname by caching results\n\n\nvar cache = new TLRU(1000); // TODO: /api/v0/dns does not return TTL yet: https://github.com/ipfs/go-ipfs/issues/5884\n// However we know browsers themselves cache DNS records for at least 1 minute,\n// which acts a provisional default ttl: https://stackoverflow.com/a/36917902/11518426\n\nvar ttl = 60 * 1000; // browsers limit concurrent connections per host,\n// we don't want preload calls to exhaust the limit (~6)\n\nvar httpQueue = new PQueue({\n  concurrency: 4\n});\n/**\n * @param {{ Path: string, Message: string }} response\n */\n\nvar ipfsPath = function ipfsPath(response) {\n  if (response.Path) return response.Path;\n  throw new Error(response.Message);\n};\n/**\n * @param {string} fqdn\n * @param {object} opts\n */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(fqdn, opts) {\n    var resolveDnslink;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            // eslint-disable-line require-await\n\n            /**\n             * @param {string} fqdn\n             * @param {object} opts\n             * @param {boolean} [opts.nocache]\n             */\n            resolveDnslink = /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(fqdn) {\n                var opts,\n                    searchParams,\n                    query,\n                    _response,\n                    response,\n                    _args2 = arguments;\n\n                return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        opts = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n                        // @ts-ignore - URLSearchParams does not take boolean options, only strings\n                        searchParams = new URLSearchParams(opts);\n                        searchParams.set('arg', fqdn); // try cache first\n\n                        query = searchParams.toString();\n\n                        if (!(!opts.nocache && cache.has(query))) {\n                          _context2.next = 7;\n                          break;\n                        }\n\n                        _response = cache.get(query);\n                        return _context2.abrupt(\"return\", ipfsPath(_response));\n\n                      case 7:\n                        _context2.next = 9;\n                        return httpQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                          var res, query, json;\n                          return _regeneratorRuntime().wrap(function _callee$(_context) {\n                            while (1) {\n                              switch (_context.prev = _context.next) {\n                                case 0:\n                                  _context.next = 2;\n                                  return HTTP.get('https://ipfs.io/api/v0/dns', {\n                                    searchParams: searchParams\n                                  });\n\n                                case 2:\n                                  res = _context.sent;\n                                  query = new URL(res.url).search.slice(1);\n                                  _context.next = 6;\n                                  return res.json();\n\n                                case 6:\n                                  json = _context.sent;\n                                  cache.set(query, json, ttl);\n                                  return _context.abrupt(\"return\", json);\n\n                                case 9:\n                                case \"end\":\n                                  return _context.stop();\n                              }\n                            }\n                          }, _callee);\n                        })));\n\n                      case 9:\n                        response = _context2.sent;\n                        return _context2.abrupt(\"return\", ipfsPath(response));\n\n                      case 11:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n\n              return function resolveDnslink(_x3) {\n                return _ref2.apply(this, arguments);\n              };\n            }();\n\n            return _context3.abrupt(\"return\", resolveDnslink(fqdn, opts));\n\n          case 2:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["TLRU","require","PQueue","default","HTTP","cache","ttl","httpQueue","concurrency","ipfsPath","response","Path","Error","Message","module","exports","fqdn","opts","resolveDnslink","searchParams","URLSearchParams","set","query","toString","nocache","has","get","add","res","URL","url","search","slice","json"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/runtime/dns-browser.js"],"sourcesContent":["/* eslint-env browser */\n'use strict'\n\nconst TLRU = require('../utils/tlru')\nconst { default: PQueue } = require('p-queue')\nconst HTTP = require('ipfs-utils/src/http')\n\n// Avoid sending multiple queries for the same hostname by caching results\nconst cache = new TLRU(1000)\n// TODO: /api/v0/dns does not return TTL yet: https://github.com/ipfs/go-ipfs/issues/5884\n// However we know browsers themselves cache DNS records for at least 1 minute,\n// which acts a provisional default ttl: https://stackoverflow.com/a/36917902/11518426\nconst ttl = 60 * 1000\n\n// browsers limit concurrent connections per host,\n// we don't want preload calls to exhaust the limit (~6)\nconst httpQueue = new PQueue({ concurrency: 4 })\n\n/**\n * @param {{ Path: string, Message: string }} response\n */\nconst ipfsPath = (response) => {\n  if (response.Path) return response.Path\n  throw new Error(response.Message)\n}\n\n/**\n * @param {string} fqdn\n * @param {object} opts\n */\nmodule.exports = async (fqdn, opts) => { // eslint-disable-line require-await\n  /**\n   * @param {string} fqdn\n   * @param {object} opts\n   * @param {boolean} [opts.nocache]\n   */\n  const resolveDnslink = async (fqdn, opts = {}) => {\n    // @ts-ignore - URLSearchParams does not take boolean options, only strings\n    const searchParams = new URLSearchParams(opts)\n    searchParams.set('arg', fqdn)\n\n    // try cache first\n    const query = searchParams.toString()\n    if (!opts.nocache && cache.has(query)) {\n      const response = cache.get(query)\n      return ipfsPath(response)\n    }\n\n    // fallback to delegated DNS resolver\n    const response = await httpQueue.add(async () => {\n      // Delegated HTTP resolver sending DNSLink queries to ipfs.io\n      // TODO: replace hardcoded host with configurable DNS over HTTPS: https://github.com/ipfs/js-ipfs/issues/2212\n      const res = await HTTP.get('https://ipfs.io/api/v0/dns', { searchParams })\n      const query = new URL(res.url).search.slice(1)\n      const json = await res.json()\n      cache.set(query, json, ttl)\n\n      return json\n    })\n    return ipfsPath(response)\n  }\n\n  return resolveDnslink(fqdn, opts)\n}\n"],"mappings":"AAAA;AACA;;;;;;AAEA,IAAMA,IAAI,GAAGC,OAAO,CAAC,eAAD,CAApB;;AACA,eAA4BA,OAAO,CAAC,SAAD,CAAnC;AAAA,IAAiBC,MAAjB,YAAQC,OAAR;;AACA,IAAMC,IAAI,GAAGH,OAAO,CAAC,qBAAD,CAApB,C,CAEA;;;AACA,IAAMI,KAAK,GAAG,IAAIL,IAAJ,CAAS,IAAT,CAAd,C,CACA;AACA;AACA;;AACA,IAAMM,GAAG,GAAG,KAAK,IAAjB,C,CAEA;AACA;;AACA,IAAMC,SAAS,GAAG,IAAIL,MAAJ,CAAW;EAAEM,WAAW,EAAE;AAAf,CAAX,CAAlB;AAEA;AACA;AACA;;AACA,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACC,QAAD,EAAc;EAC7B,IAAIA,QAAQ,CAACC,IAAb,EAAmB,OAAOD,QAAQ,CAACC,IAAhB;EACnB,MAAM,IAAIC,KAAJ,CAAUF,QAAQ,CAACG,OAAnB,CAAN;AACD,CAHD;AAKA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP;EAAA,sEAAiB,kBAAOC,IAAP,EAAaC,IAAb;IAAA;IAAA;MAAA;QAAA;UAAA;YAAwB;;YACvC;AACF;AACA;AACA;AACA;YACQC,cANS;cAAA,uEAMQ,kBAAOF,IAAP;gBAAA;gBAAA;gBAAA;gBAAA;gBAAA;gBAAA;;gBAAA;kBAAA;oBAAA;sBAAA;wBAAaC,IAAb,8DAAoB,EAApB;wBACrB;wBACME,YAFe,GAEA,IAAIC,eAAJ,CAAoBH,IAApB,CAFA;wBAGrBE,YAAY,CAACE,GAAb,CAAiB,KAAjB,EAAwBL,IAAxB,EAHqB,CAKrB;;wBACMM,KANe,GAMPH,YAAY,CAACI,QAAb,EANO;;wBAAA,MAOjB,CAACN,IAAI,CAACO,OAAN,IAAiBnB,KAAK,CAACoB,GAAN,CAAUH,KAAV,CAPA;0BAAA;0BAAA;wBAAA;;wBAQbZ,SARa,GAQFL,KAAK,CAACqB,GAAN,CAAUJ,KAAV,CARE;wBAAA,kCASZb,QAAQ,CAACC,SAAD,CATI;;sBAAA;wBAAA;wBAAA,OAaEH,SAAS,CAACoB,GAAV,0EAAc;0BAAA;0BAAA;4BAAA;8BAAA;gCAAA;kCAAA;kCAAA,OAGjBvB,IAAI,CAACsB,GAAL,CAAS,4BAAT,EAAuC;oCAAEP,YAAY,EAAZA;kCAAF,CAAvC,CAHiB;;gCAAA;kCAG7BS,GAH6B;kCAI7BN,KAJ6B,GAIrB,IAAIO,GAAJ,CAAQD,GAAG,CAACE,GAAZ,EAAiBC,MAAjB,CAAwBC,KAAxB,CAA8B,CAA9B,CAJqB;kCAAA;kCAAA,OAKhBJ,GAAG,CAACK,IAAJ,EALgB;;gCAAA;kCAK7BA,IAL6B;kCAMnC5B,KAAK,CAACgB,GAAN,CAAUC,KAAV,EAAiBW,IAAjB,EAAuB3B,GAAvB;kCANmC,iCAQ5B2B,IAR4B;;gCAAA;gCAAA;kCAAA;8BAAA;4BAAA;0BAAA;wBAAA,CAAd,GAbF;;sBAAA;wBAafvB,QAbe;wBAAA,kCAuBdD,QAAQ,CAACC,QAAD,CAvBM;;sBAAA;sBAAA;wBAAA;oBAAA;kBAAA;gBAAA;cAAA,CANR;;cAAA,gBAMTQ,cANS;gBAAA;cAAA;YAAA;;YAAA,kCAgCRA,cAAc,CAACF,IAAD,EAAOC,IAAP,CAhCN;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAAjB;;EAAA;IAAA;EAAA;AAAA"},"metadata":{},"sourceType":"script"}