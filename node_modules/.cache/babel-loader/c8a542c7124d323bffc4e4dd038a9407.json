{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _require = require('multiformats/cid'),\n    CID = _require.CID;\n\nvar b32 = require('multiformats/bases/base32');\n\nvar b36 = require('multiformats/bases/base36');\n\nvar b58 = require('multiformats/bases/base58');\n\nvar b64 = require('multiformats/bases/base64');\n\nvar _require2 = require('multiformats/bases/base58'),\n    base58btc = _require2.base58btc;\n\nvar _require3 = require('multiformats/bases/base32'),\n    base32 = _require3.base32;\n\nvar _require4 = require('multiformats/bases/base16'),\n    base16 = _require4.base16;\n\nvar Digest = require('multiformats/hashes/digest');\n\nvar cryptoKeys = require('libp2p-crypto/src/keys');\n\nvar withIs = require('class-is');\n\nvar _require5 = require('./proto'),\n    PeerIdProto = _require5.PeerIdProto;\n\nvar _require6 = require('uint8arrays/equals'),\n    uint8ArrayEquals = _require6.equals;\n\nvar _require7 = require('uint8arrays/from-string'),\n    uint8ArrayFromString = _require7.fromString;\n\nvar _require8 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require8.toString;\n\nvar _require9 = require('multiformats/hashes/identity'),\n    identity = _require9.identity;\n\nvar bases = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, b32), b36), b58), b64);\n\nvar baseDecoder = Object.keys(bases).reduce(function (acc, curr) {\n  return acc.or(bases[curr]);\n}, base32.decoder); // these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\n\nvar DAG_PB_CODE = 0x70;\nvar LIBP2P_KEY_CODE = 0x72;\n\nvar PeerId = /*#__PURE__*/function () {\n  function PeerId(id, privKey, pubKey) {\n    _classCallCheck(this, PeerId);\n\n    if (!(id instanceof Uint8Array)) {\n      throw new Error('invalid id provided');\n    }\n\n    if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {\n      throw new Error('inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = base58btc.encode(this.id).substring(1);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  _createClass(PeerId, [{\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    },\n    set: function set(val) {\n      throw new Error('Id is immutable');\n    }\n  }, {\n    key: \"privKey\",\n    get: function get() {\n      return this._privKey;\n    },\n    set: function set(privKey) {\n      this._privKey = privKey;\n    }\n  }, {\n    key: \"pubKey\",\n    get: function get() {\n      if (this._pubKey) {\n        return this._pubKey;\n      }\n\n      if (this._privKey) {\n        return this._privKey.public;\n      }\n\n      try {\n        var decoded = Digest.decode(this.id);\n\n        if (decoded.code === identity.code) {\n          this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);\n        }\n      } catch (_) {// Ignore, there is no valid public key\n      }\n\n      return this._pubKey;\n    },\n    set: function set(pubKey) {\n      this._pubKey = pubKey;\n    } // Return the protobuf version of the public key, matching go ipfs formatting\n\n  }, {\n    key: \"marshalPubKey\",\n    value: function marshalPubKey() {\n      if (this.pubKey) {\n        return cryptoKeys.marshalPublicKey(this.pubKey);\n      }\n    } // Return the protobuf version of the private key, matching go ipfs formatting\n\n  }, {\n    key: \"marshalPrivKey\",\n    value: function marshalPrivKey() {\n      if (this.privKey) {\n        return cryptoKeys.marshalPrivateKey(this.privKey);\n      }\n    } // Return the protobuf version of the peer-id\n\n  }, {\n    key: \"marshal\",\n    value: function marshal(excludePriv) {\n      return PeerIdProto.encode({\n        id: this.toBytes(),\n        pubKey: this.marshalPubKey(),\n        privKey: excludePriv ? null : this.marshalPrivKey()\n      }).finish();\n    }\n  }, {\n    key: \"toPrint\",\n    value: function toPrint() {\n      var pid = this.toB58String(); // All sha256 nodes start with Qm\n      // We can skip the Qm to make the peer.ID more useful\n\n      if (pid.startsWith('Qm')) {\n        pid = pid.slice(2);\n      }\n\n      var maxRunes = 6;\n\n      if (pid.length < maxRunes) {\n        maxRunes = pid.length;\n      }\n\n      return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n    } // return the jsonified version of the key, matching the formatting\n    // of go-ipfs for its config file\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        id: this.toB58String(),\n        privKey: toB64Opt(this.marshalPrivKey()),\n        pubKey: toB64Opt(this.marshalPubKey())\n      };\n    } // encode/decode functions\n\n  }, {\n    key: \"toHexString\",\n    value: function toHexString() {\n      return base16.encode(this.id).substring(1);\n    }\n  }, {\n    key: \"toBytes\",\n    value: function toBytes() {\n      return this.id;\n    }\n  }, {\n    key: \"toB58String\",\n    value: function toB58String() {\n      return this._idB58String;\n    } // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!this._idCIDString) {\n        var cid = CID.createV1(LIBP2P_KEY_CODE, Digest.decode(this.id));\n        Object.defineProperty(this, '_idCIDString', {\n          value: cid.toString(),\n          enumerable: false\n        });\n      }\n\n      return this._idCIDString;\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId.\n     *\n     * @param {Uint8Array|PeerId} id\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(id) {\n      if (id instanceof Uint8Array) {\n        return uint8ArrayEquals(this.id, id);\n      } else if (id.id) {\n        return uint8ArrayEquals(this.id, id.id);\n      } else {\n        throw new Error('not valid Id');\n      }\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId.\n     *\n     * @deprecated Use `.equals`\n     * @param {Uint8Array|PeerId} id\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(id) {\n      return this.equals(id);\n    }\n    /*\n     * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      // TODO: needs better checking\n      return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && this.pubKey.bytes instanceof Uint8Array && uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes));\n    }\n    /**\n     * Check if the PeerId has an inline public key.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"hasInlinePublicKey\",\n    value: function hasInlinePublicKey() {\n      try {\n        var decoded = Digest.decode(this.id);\n\n        if (decoded.code === identity.code) {\n          return true;\n        }\n      } catch (_) {// Ignore, there is no valid public key\n      }\n\n      return false;\n    }\n  }]);\n\n  return PeerId;\n}();\n\nvar PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\n\nvar computeDigest = function computeDigest(pubKey) {\n  if (pubKey.bytes.length <= 42) {\n    return Digest.create(identity.code, pubKey.bytes).bytes;\n  } else {\n    return pubKey.hash();\n  }\n};\n\nvar computePeerId = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(privKey, pubKey) {\n    var digest;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return computeDigest(pubKey);\n\n          case 2:\n            digest = _context.sent;\n            return _context.abrupt(\"return\", new PeerIdWithIs(digest, privKey, pubKey));\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function computePeerId(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}(); // generation\n\n\nexports.create = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(opts) {\n    var key;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            opts = opts || {};\n            opts.bits = opts.bits || 2048;\n            opts.keyType = opts.keyType || 'RSA';\n            _context2.next = 5;\n            return cryptoKeys.generateKeyPair(opts.keyType, opts.bits);\n\n          case 5:\n            key = _context2.sent;\n            return _context2.abrupt(\"return\", computePeerId(key, key.public));\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(base16.decode('f' + str));\n};\n\nexports.createFromBytes = function (buf) {\n  try {\n    var cid = CID.decode(buf);\n\n    if (!validMulticodec(cid)) {\n      throw new Error('Supplied PeerID CID is invalid');\n    }\n\n    return exports.createFromCID(cid);\n  } catch (_unused) {\n    var digest = Digest.decode(buf);\n\n    if (digest.code !== identity.code) {\n      throw new Error('Supplied PeerID CID is invalid');\n    }\n\n    return new PeerIdWithIs(buf);\n  }\n};\n\nexports.createFromB58String = function (str) {\n  return exports.createFromBytes(base58btc.decode('z' + str));\n};\n\nvar validMulticodec = function validMulticodec(cid) {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.code === LIBP2P_KEY_CODE || cid.code === DAG_PB_CODE;\n};\n\nexports.createFromCID = function (cid) {\n  cid = CID.asCID(cid);\n\n  if (!cid || !validMulticodec(cid)) {\n    throw new Error('Supplied PeerID CID is invalid');\n  }\n\n  return new PeerIdWithIs(cid.multihash.bytes);\n}; // Public Key input will be a Uint8Array\n\n\nexports.createFromPubKey = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key) {\n    var buf, pubKey;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            buf = key;\n\n            if (typeof buf === 'string') {\n              buf = uint8ArrayFromString(key, 'base64pad');\n            }\n\n            if (buf instanceof Uint8Array) {\n              _context3.next = 4;\n              break;\n            }\n\n            throw new Error('Supplied key is neither a base64 string nor a Uint8Array');\n\n          case 4:\n            _context3.next = 6;\n            return cryptoKeys.unmarshalPublicKey(buf);\n\n          case 6:\n            pubKey = _context3.sent;\n            return _context3.abrupt(\"return\", computePeerId(undefined, pubKey));\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}(); // Private key input will be a string\n\n\nexports.createFromPrivKey = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(key) {\n    var privKey;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (typeof key === 'string') {\n              key = uint8ArrayFromString(key, 'base64pad');\n            }\n\n            if (key instanceof Uint8Array) {\n              _context4.next = 3;\n              break;\n            }\n\n            throw new Error('Supplied key is neither a base64 string nor a Uint8Array');\n\n          case 3:\n            _context4.next = 5;\n            return cryptoKeys.unmarshalPrivateKey(key);\n\n          case 5:\n            privKey = _context4.sent;\n            return _context4.abrupt(\"return\", computePeerId(privKey, privKey.public));\n\n          case 7:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function (_x5) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.createFromJSON = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(obj) {\n    var id, rawPrivKey, rawPubKey, pub, privKey, privDigest, pubDigest;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            id = base58btc.decode('z' + obj.id);\n            rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, 'base64pad');\n            rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, 'base64pad');\n            _context5.t0 = rawPubKey;\n\n            if (!_context5.t0) {\n              _context5.next = 8;\n              break;\n            }\n\n            _context5.next = 7;\n            return cryptoKeys.unmarshalPublicKey(rawPubKey);\n\n          case 7:\n            _context5.t0 = _context5.sent;\n\n          case 8:\n            pub = _context5.t0;\n\n            if (rawPrivKey) {\n              _context5.next = 11;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", new PeerIdWithIs(id, undefined, pub));\n\n          case 11:\n            _context5.next = 13;\n            return cryptoKeys.unmarshalPrivateKey(rawPrivKey);\n\n          case 13:\n            privKey = _context5.sent;\n            _context5.next = 16;\n            return computeDigest(privKey.public);\n\n          case 16:\n            privDigest = _context5.sent;\n\n            if (!pub) {\n              _context5.next = 21;\n              break;\n            }\n\n            _context5.next = 20;\n            return computeDigest(pub);\n\n          case 20:\n            pubDigest = _context5.sent;\n\n          case 21:\n            if (!(pub && !uint8ArrayEquals(privDigest, pubDigest))) {\n              _context5.next = 23;\n              break;\n            }\n\n            throw new Error('Public and private key do not match');\n\n          case 23:\n            if (!(id && !uint8ArrayEquals(privDigest, id))) {\n              _context5.next = 25;\n              break;\n            }\n\n            throw new Error('Id and private key do not match');\n\n          case 25:\n            return _context5.abrupt(\"return\", new PeerIdWithIs(id, privKey, pub));\n\n          case 26:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function (_x6) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nexports.createFromProtobuf = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(buf) {\n    var _PeerIdProto$decode, id, privKey, pubKey, pubDigest, privDigest;\n\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (typeof buf === 'string') {\n              buf = uint8ArrayFromString(buf, 'base16');\n            }\n\n            _PeerIdProto$decode = PeerIdProto.decode(buf), id = _PeerIdProto$decode.id, privKey = _PeerIdProto$decode.privKey, pubKey = _PeerIdProto$decode.pubKey;\n\n            if (!privKey) {\n              _context6.next = 8;\n              break;\n            }\n\n            _context6.next = 5;\n            return cryptoKeys.unmarshalPrivateKey(privKey);\n\n          case 5:\n            _context6.t0 = _context6.sent;\n            _context6.next = 9;\n            break;\n\n          case 8:\n            _context6.t0 = false;\n\n          case 9:\n            privKey = _context6.t0;\n\n            if (!pubKey) {\n              _context6.next = 16;\n              break;\n            }\n\n            _context6.next = 13;\n            return cryptoKeys.unmarshalPublicKey(pubKey);\n\n          case 13:\n            _context6.t1 = _context6.sent;\n            _context6.next = 17;\n            break;\n\n          case 16:\n            _context6.t1 = false;\n\n          case 17:\n            pubKey = _context6.t1;\n\n            if (!privKey) {\n              _context6.next = 22;\n              break;\n            }\n\n            _context6.next = 21;\n            return computeDigest(privKey.public);\n\n          case 21:\n            privDigest = _context6.sent;\n\n          case 22:\n            if (!pubKey) {\n              _context6.next = 26;\n              break;\n            }\n\n            _context6.next = 25;\n            return computeDigest(pubKey);\n\n          case 25:\n            pubDigest = _context6.sent;\n\n          case 26:\n            if (!privKey) {\n              _context6.next = 31;\n              break;\n            }\n\n            if (!pubKey) {\n              _context6.next = 30;\n              break;\n            }\n\n            if (uint8ArrayEquals(privDigest, pubDigest)) {\n              _context6.next = 30;\n              break;\n            }\n\n            throw new Error('Public and private key do not match');\n\n          case 30:\n            return _context6.abrupt(\"return\", new PeerIdWithIs(privDigest, privKey, privKey.public));\n\n          case 31:\n            if (!pubKey) {\n              _context6.next = 33;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", new PeerIdWithIs(pubDigest, undefined, pubKey));\n\n          case 33:\n            if (!id) {\n              _context6.next = 35;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", new PeerIdWithIs(id));\n\n          case 35:\n            throw new Error('Protobuf did not contain any usable key material');\n\n          case 36:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function (_x7) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nexports.parse = function (str) {\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519 key or sha2-256 hash of rsa public key\n    // base58btc encoded either way\n    str = \"z\".concat(str);\n  }\n\n  return exports.createFromBytes(baseDecoder.decode(str));\n};\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return uint8ArrayToString(val, 'base64pad');\n  }\n}","map":{"version":3,"names":["require","CID","b32","b36","b58","b64","base58btc","base32","base16","Digest","cryptoKeys","withIs","PeerIdProto","uint8ArrayEquals","equals","uint8ArrayFromString","fromString","uint8ArrayToString","toString","identity","bases","baseDecoder","Object","keys","reduce","acc","curr","or","decoder","DAG_PB_CODE","LIBP2P_KEY_CODE","PeerId","id","privKey","pubKey","Uint8Array","Error","public","bytes","_id","_idB58String","encode","substring","_privKey","_pubKey","val","decoded","decode","code","unmarshalPublicKey","digest","_","marshalPublicKey","marshalPrivateKey","excludePriv","toBytes","marshalPubKey","marshalPrivKey","finish","pid","toB58String","startsWith","slice","maxRunes","length","substr","toB64Opt","_idCIDString","cid","createV1","defineProperty","value","enumerable","Boolean","PeerIdWithIs","className","symbolName","exports","module","computeDigest","create","hash","computePeerId","opts","bits","keyType","generateKeyPair","key","createFromHexString","str","createFromBytes","buf","validMulticodec","createFromCID","createFromB58String","asCID","multihash","createFromPubKey","undefined","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","rawPrivKey","rawPubKey","pub","privDigest","pubDigest","createFromProtobuf","parse","charAt","isPeerId","peerId"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-delegated-content-routing/node_modules/peer-id/src/index.js"],"sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst b32 = require('multiformats/bases/base32')\nconst b36 = require('multiformats/bases/base36')\nconst b58 = require('multiformats/bases/base58')\nconst b64 = require('multiformats/bases/base64')\nconst { base58btc } = require('multiformats/bases/base58')\nconst { base32 } = require('multiformats/bases/base32')\nconst { base16 } = require('multiformats/bases/base16')\nconst Digest = require('multiformats/hashes/digest')\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst withIs = require('class-is')\nconst { PeerIdProto } = require('./proto')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { identity } = require('multiformats/hashes/identity')\n\nconst bases = {\n  ...b32,\n  ...b36,\n  ...b58,\n  ...b64\n}\nconst baseDecoder = Object.keys(bases).reduce(\n  (acc, curr) => acc.or(bases[curr]),\n  base32.decoder\n)\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst DAG_PB_CODE = 0x70\nconst LIBP2P_KEY_CODE = 0x72\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    if (!(id instanceof Uint8Array)) {\n      throw new Error('invalid id provided')\n    }\n\n    if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {\n      throw new Error('inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = base58btc.encode(this.id).substring(1)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n\n    try {\n      const decoded = Digest.decode(this.id)\n\n      if (decoded.code === identity.code) {\n        this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest)\n      }\n    } catch (_) {\n      // Ignore, there is no valid public key\n    }\n\n    return this._pubKey\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  // Return the protobuf version of the peer-id\n  marshal (excludePriv) {\n    return PeerIdProto.encode({\n      id: this.toBytes(),\n      pubKey: this.marshalPubKey(),\n      privKey: excludePriv ? null : this.marshalPrivKey()\n    }).finish()\n  }\n\n  toPrint () {\n    let pid = this.toB58String()\n    // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2)\n    }\n    let maxRunes = 6\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>'\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return base16.encode(this.id).substring(1)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toString () {\n    if (!this._idCIDString) {\n      const cid = CID.createV1(LIBP2P_KEY_CODE, Digest.decode(this.id))\n\n      Object.defineProperty(this, '_idCIDString', {\n        value: cid.toString(),\n        enumerable: false\n      })\n    }\n    return this._idCIDString\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   *\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n  equals (id) {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.id, id)\n    } else if (id.id) {\n      return uint8ArrayEquals(this.id, id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   *\n   * @deprecated Use `.equals`\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n  isEqual (id) {\n    return this.equals(id)\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid () {\n    // TODO: needs better checking\n    return Boolean(this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      this.pubKey.bytes instanceof Uint8Array &&\n        uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes))\n  }\n\n  /**\n   * Check if the PeerId has an inline public key.\n   *\n   * @returns {boolean}\n   */\n  hasInlinePublicKey () {\n    try {\n      const decoded = Digest.decode(this.id)\n\n      if (decoded.code === identity.code) {\n        return true\n      }\n    } catch (_) {\n      // Ignore, there is no valid public key\n    }\n\n    return false\n  }\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n})\n\nexports = module.exports = PeerIdWithIs\n\nconst computeDigest = (pubKey) => {\n  if (pubKey.bytes.length <= 42) {\n    return Digest.create(identity.code, pubKey.bytes).bytes\n  } else {\n    return pubKey.hash()\n  }\n}\n\nconst computePeerId = async (privKey, pubKey) => {\n  const digest = await computeDigest(pubKey)\n  return new PeerIdWithIs(digest, privKey, pubKey)\n}\n\n// generation\nexports.create = async (opts) => {\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n  opts.keyType = opts.keyType || 'RSA'\n\n  const key = await cryptoKeys.generateKeyPair(opts.keyType, opts.bits)\n  return computePeerId(key, key.public)\n}\n\nexports.createFromHexString = (str) => {\n  return new PeerIdWithIs(base16.decode('f' + str))\n}\n\nexports.createFromBytes = (buf) => {\n  try {\n    const cid = CID.decode(buf)\n\n    if (!validMulticodec(cid)) {\n      throw new Error('Supplied PeerID CID is invalid')\n    }\n\n    return exports.createFromCID(cid)\n  } catch {\n    const digest = Digest.decode(buf)\n\n    if (digest.code !== identity.code) {\n      throw new Error('Supplied PeerID CID is invalid')\n    }\n\n    return new PeerIdWithIs(buf)\n  }\n}\n\nexports.createFromB58String = (str) => {\n  return exports.createFromBytes(base58btc.decode('z' + str))\n}\n\nconst validMulticodec = (cid) => {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.code === LIBP2P_KEY_CODE || cid.code === DAG_PB_CODE\n}\n\nexports.createFromCID = (cid) => {\n  cid = CID.asCID(cid)\n\n  if (!cid || !validMulticodec(cid)) {\n    throw new Error('Supplied PeerID CID is invalid')\n  }\n\n  return new PeerIdWithIs(cid.multihash.bytes)\n}\n\n// Public Key input will be a Uint8Array\nexports.createFromPubKey = async (key) => {\n  let buf = key\n\n  if (typeof buf === 'string') {\n    buf = uint8ArrayFromString(key, 'base64pad')\n  }\n\n  if (!(buf instanceof Uint8Array)) {\n    throw new Error('Supplied key is neither a base64 string nor a Uint8Array')\n  }\n\n  const pubKey = await cryptoKeys.unmarshalPublicKey(buf)\n  return computePeerId(undefined, pubKey)\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = async (key) => {\n  if (typeof key === 'string') {\n    key = uint8ArrayFromString(key, 'base64pad')\n  }\n\n  if (!(key instanceof Uint8Array)) {\n    throw new Error('Supplied key is neither a base64 string nor a Uint8Array')\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(key)\n  return computePeerId(privKey, privKey.public)\n}\n\nexports.createFromJSON = async (obj) => {\n  const id = base58btc.decode('z' + obj.id)\n  const rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, 'base64pad')\n  const rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, 'base64pad')\n  const pub = rawPubKey && await cryptoKeys.unmarshalPublicKey(rawPubKey)\n\n  if (!rawPrivKey) {\n    return new PeerIdWithIs(id, undefined, pub)\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(rawPrivKey)\n  const privDigest = await computeDigest(privKey.public)\n\n  let pubDigest\n\n  if (pub) {\n    pubDigest = await computeDigest(pub)\n  }\n\n  if (pub && !uint8ArrayEquals(privDigest, pubDigest)) {\n    throw new Error('Public and private key do not match')\n  }\n\n  if (id && !uint8ArrayEquals(privDigest, id)) {\n    throw new Error('Id and private key do not match')\n  }\n\n  return new PeerIdWithIs(id, privKey, pub)\n}\n\nexports.createFromProtobuf = async (buf) => {\n  if (typeof buf === 'string') {\n    buf = uint8ArrayFromString(buf, 'base16')\n  }\n\n  let { id, privKey, pubKey } = PeerIdProto.decode(buf)\n\n  privKey = privKey ? await cryptoKeys.unmarshalPrivateKey(privKey) : false\n  pubKey = pubKey ? await cryptoKeys.unmarshalPublicKey(pubKey) : false\n\n  let pubDigest\n  let privDigest\n\n  if (privKey) {\n    privDigest = await computeDigest(privKey.public)\n  }\n\n  if (pubKey) {\n    pubDigest = await computeDigest(pubKey)\n  }\n\n  if (privKey) {\n    if (pubKey) {\n      if (!uint8ArrayEquals(privDigest, pubDigest)) {\n        throw new Error('Public and private key do not match')\n      }\n    }\n    return new PeerIdWithIs(privDigest, privKey, privKey.public)\n  }\n\n  // TODO: val id and pubDigest\n\n  if (pubKey) {\n    return new PeerIdWithIs(pubDigest, undefined, pubKey)\n  }\n\n  if (id) {\n    return new PeerIdWithIs(id)\n  }\n\n  throw new Error('Protobuf did not contain any usable key material')\n}\n\nexports.parse = (str) => {\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519 key or sha2-256 hash of rsa public key\n    // base58btc encoded either way\n    str = `z${str}`\n  }\n\n  return exports.createFromBytes(baseDecoder.decode(str))\n}\n\nexports.isPeerId = (peerId) => {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return uint8ArrayToString(val, 'base64pad')\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}