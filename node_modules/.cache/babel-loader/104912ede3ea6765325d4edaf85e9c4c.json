{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar NanoDate = require('timestamp-nano');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar Digest = require('multiformats/hashes/digest');\n\nvar _require2 = require('multiformats/hashes/identity'),\n    identity = _require2.identity;\n\nvar errCode = require('err-code');\n\nvar _require3 = require('multiformats/bases/base32'),\n    base32upper = _require3.base32upper;\n\nvar _require4 = require('uint8arrays/from-string'),\n    uint8ArrayFromString = _require4.fromString;\n\nvar _require5 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require5.toString;\n\nvar _require6 = require('uint8arrays/concat'),\n    uint8ArrayConcat = _require6.concat;\n\nvar _require7 = require('uint8arrays/equals'),\n    uint8ArrayEquals = _require7.equals;\n\nvar cborg = require('cborg');\n\nvar Long = require('long');\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('jsipns'), {\n  error: debug('jsipns:error')\n});\n\nvar _require8 = require('./pb/ipns.js'),\n    ipnsEntryProto = _require8.IpnsEntry;\n\nvar _require9 = require('./utils'),\n    parseRFC3339 = _require9.parseRFC3339;\n\nvar ERRORS = require('./errors');\n\nvar ID_MULTIHASH_CODE = identity.code;\nvar namespace = '/ipns/';\nvar IPNS_PREFIX = uint8ArrayFromString('/ipns/');\n/**\n * @typedef {import('./types').IPNSEntry} IPNSEntry\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n */\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {PrivateKey} privateKey - private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {number} lifetime - lifetime of the record (in milliseconds).\n */\n\nvar create = function create(privateKey, value, seq, lifetime) {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  var expirationDate = new NanoDate(Date.now() + Number(lifetime));\n  var validityType = ipnsEntryProto.ValidityType.EOL;\n\n  var _lifetime$toString$sp = lifetime.toString().split('.'),\n      _lifetime$toString$sp2 = _slicedToArray(_lifetime$toString$sp, 2),\n      ms = _lifetime$toString$sp2[0],\n      ns = _lifetime$toString$sp2[1];\n\n  var lifetimeNs = BigInt(ms) * 100000n + BigInt(ns || 0);\n  return _create(privateKey, value, seq, validityType, expirationDate, lifetimeNs);\n};\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n *\n * @param {PrivateKey} privateKey - private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {string} expiration - expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n */\n\n\nvar createWithExpiration = function createWithExpiration(privateKey, value, seq, expiration) {\n  var expirationDate = NanoDate.fromString(expiration);\n  var validityType = ipnsEntryProto.ValidityType.EOL;\n  var ttlMs = expirationDate.toDate().getTime() - Date.now();\n  var ttlNs = BigInt(ttlMs) * 100000n + BigInt(expirationDate.getNano());\n  return _create(privateKey, value, seq, validityType, expirationDate, ttlNs);\n};\n/**\n * @param {PrivateKey} privateKey\n * @param {Uint8Array} value\n * @param {number | bigint} seq\n * @param {number} validityType\n * @param {NanoDate} expirationDate\n * @param {bigint} ttl\n * @returns {Promise<IPNSEntry>}\n */\n\n\nvar _create = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(privateKey, value, seq, validityType, expirationDate, ttl) {\n    var isoValidity, signatureV1, data, sigData, signatureV2, entry;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            seq = BigInt(seq);\n            isoValidity = uint8ArrayFromString(expirationDate.toString());\n            _context.next = 4;\n            return sign(privateKey, value, validityType, isoValidity);\n\n          case 4:\n            signatureV1 = _context.sent;\n            data = createCborData(value, isoValidity, validityType, seq, ttl);\n            sigData = ipnsEntryDataForV2Sig(data);\n            _context.next = 9;\n            return privateKey.sign(sigData);\n\n          case 9:\n            signatureV2 = _context.sent;\n            entry = {\n              value: value,\n              signature: signatureV1,\n              validityType: validityType,\n              validity: isoValidity,\n              sequence: seq,\n              ttl: ttl,\n              signatureV2: signatureV2,\n              data: data\n            };\n            log(\"ipns entry for \".concat(value, \" created\"));\n            return _context.abrupt(\"return\", entry);\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function _create(_x, _x2, _x3, _x4, _x5, _x6) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {Uint8Array} value\n * @param {Uint8Array} validity\n * @param {number} validityType\n * @param {bigint} sequence\n * @param {bigint} ttl\n */\n\n\nvar createCborData = function createCborData(value, validity, validityType, sequence, ttl) {\n  var data = {\n    Value: value,\n    Validity: validity,\n    ValidityType: validityType,\n    Sequence: sequence,\n    TTL: ttl\n  };\n  return cborg.encode(data);\n};\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {PublicKey} publicKey - public key for validating the record.\n * @param {IPNSEntry} entry - ipns entry record.\n */\n\n\nvar _validate = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(publicKey, entry) {\n    var value, validityType, validity, dataForSignature, signature, isValid, validityDate;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            value = entry.value, validityType = entry.validityType, validity = entry.validity;\n            /** @type {Uint8Array} */\n\n            // Check v2 signature if it's available, otherwise use the v1 signature\n            if (entry.signatureV2 && entry.data) {\n              signature = entry.signatureV2;\n              dataForSignature = ipnsEntryDataForV2Sig(entry.data);\n              validateCborDataMatchesPbData(entry);\n            } else {\n              signature = entry.signature;\n              dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n            } // Validate Signature\n\n\n            _context2.prev = 2;\n            _context2.next = 5;\n            return publicKey.verify(dataForSignature, signature);\n\n          case 5:\n            isValid = _context2.sent;\n            _context2.next = 11;\n            break;\n\n          case 8:\n            _context2.prev = 8;\n            _context2.t0 = _context2[\"catch\"](2);\n            isValid = false;\n\n          case 11:\n            if (isValid) {\n              _context2.next = 14;\n              break;\n            }\n\n            log.error('record signature verification failed');\n            throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n\n          case 14:\n            if (!(validityType === ipnsEntryProto.ValidityType.EOL)) {\n              _context2.next = 28;\n              break;\n            }\n\n            _context2.prev = 15;\n            validityDate = parseRFC3339(uint8ArrayToString(validity));\n            _context2.next = 23;\n            break;\n\n          case 19:\n            _context2.prev = 19;\n            _context2.t1 = _context2[\"catch\"](15);\n            log.error('unrecognized validity format (not an rfc3339 format)');\n            throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT);\n\n          case 23:\n            if (!(validityDate.getTime() < Date.now())) {\n              _context2.next = 26;\n              break;\n            }\n\n            log.error('record has expired');\n            throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD);\n\n          case 26:\n            _context2.next = 31;\n            break;\n\n          case 28:\n            if (!validityType) {\n              _context2.next = 31;\n              break;\n            }\n\n            log.error('unrecognized validity type');\n            throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n\n          case 31:\n            log(\"ipns entry for \".concat(value, \" is valid\"));\n\n          case 32:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[2, 8], [15, 19]]);\n  }));\n\n  return function validate(_x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * @param {IPNSEntry} entry\n */\n\n\nvar validateCborDataMatchesPbData = function validateCborDataMatchesPbData(entry) {\n  if (!entry.data) {\n    throw errCode(new Error('Record data is missing'), ERRORS.ERR_INVALID_RECORD_DATA);\n  }\n\n  var data = cborg.decode(entry.data);\n\n  if (Number.isInteger(data.Sequence)) {\n    // sequence must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.Sequence = BigInt(data.Sequence);\n  }\n\n  if (Number.isInteger(data.TTL)) {\n    // ttl must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.TTL = BigInt(data.TTL);\n  }\n\n  if (!uint8ArrayEquals(data.Value, entry.value)) {\n    throw errCode(new Error('Field \"value\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (!uint8ArrayEquals(data.Validity, entry.validity)) {\n    throw errCode(new Error('Field \"validity\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.ValidityType !== entry.validityType) {\n    throw errCode(new Error('Field \"validityType\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.Sequence !== entry.sequence) {\n    throw errCode(new Error('Field \"sequence\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.TTL !== entry.ttl) {\n    throw errCode(new Error('Field \"ttl\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n};\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validate a record upon receipt, they need\n * the public key associated with it. For old RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {PublicKey} publicKey - public key to embed.\n * @param {IPNSEntry} entry - ipns entry record.\n */\n\n\nvar embedPublicKey = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(publicKey, entry) {\n    var error, peerId, extractedPublicKey;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(!publicKey || !publicKey.bytes || !entry)) {\n              _context3.next = 4;\n              break;\n            }\n\n            error = new Error('one or more of the provided parameters are not defined');\n            log.error(error);\n            throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n\n          case 4:\n            _context3.prev = 4;\n            _context3.next = 7;\n            return PeerId.createFromPubKey(publicKey.bytes);\n\n          case 7:\n            peerId = _context3.sent;\n            _context3.next = 13;\n            break;\n\n          case 10:\n            _context3.prev = 10;\n            _context3.t0 = _context3[\"catch\"](4);\n            throw errCode(_context3.t0, ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY);\n\n          case 13:\n            _context3.prev = 13;\n            extractedPublicKey = extractPublicKeyFromId(peerId);\n            _context3.next = 21;\n            break;\n\n          case 17:\n            _context3.prev = 17;\n            _context3.t1 = _context3[\"catch\"](13);\n            log.error(_context3.t1);\n            throw errCode(_context3.t1, ERRORS.ERR_PUBLIC_KEY_FROM_ID);\n\n          case 21:\n            if (!extractedPublicKey) {\n              _context3.next = 23;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", null);\n\n          case 23:\n            _context3.prev = 23;\n            entry.pubKey = crypto.keys.marshalPublicKey(publicKey);\n            _context3.next = 31;\n            break;\n\n          case 27:\n            _context3.prev = 27;\n            _context3.t2 = _context3[\"catch\"](23);\n            log.error(_context3.t2);\n            throw _context3.t2;\n\n          case 31:\n            return _context3.abrupt(\"return\", entry);\n\n          case 32:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[4, 10], [13, 17], [23, 27]]);\n  }));\n\n  return function embedPublicKey(_x9, _x10) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Extracts a public key from the passed PeerId, falling\n * back to the pubKey embedded in the ipns record.\n *\n * @param {PeerId} peerId - peer identifier object.\n * @param {IPNSEntry} entry - ipns entry record.\n */\n\n\nvar extractPublicKey = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(peerId, entry) {\n    var error, pubKey, otherId;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!(!entry || !peerId)) {\n              _context4.next = 4;\n              break;\n            }\n\n            error = new Error('one or more of the provided parameters are not defined');\n            log.error(error);\n            throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n\n          case 4:\n            if (!entry.pubKey) {\n              _context4.next = 20;\n              break;\n            }\n\n            _context4.prev = 5;\n            pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey);\n            _context4.next = 13;\n            break;\n\n          case 9:\n            _context4.prev = 9;\n            _context4.t0 = _context4[\"catch\"](5);\n            log.error(_context4.t0);\n            throw _context4.t0;\n\n          case 13:\n            _context4.next = 15;\n            return PeerId.createFromPubKey(entry.pubKey);\n\n          case 15:\n            otherId = _context4.sent;\n\n            if (otherId.equals(peerId)) {\n              _context4.next = 18;\n              break;\n            }\n\n            throw errCode(new Error('Embedded public key did not match PeerID'), ERRORS.ERR_INVALID_EMBEDDED_KEY);\n\n          case 18:\n            _context4.next = 21;\n            break;\n\n          case 20:\n            if (peerId.pubKey) {\n              pubKey = peerId.pubKey;\n            }\n\n          case 21:\n            if (!pubKey) {\n              _context4.next = 23;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", pubKey);\n\n          case 23:\n            throw errCode(new Error('no public key is available'), ERRORS.ERR_UNDEFINED_PARAMETER);\n\n          case 24:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[5, 9]]);\n  }));\n\n  return function extractPublicKey(_x11, _x12) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n/**\n * rawStdEncoding with RFC4648\n *\n * @param {Uint8Array} key\n */\n\n\nvar rawStdEncoding = function rawStdEncoding(key) {\n  return base32upper.encode(key).slice(1);\n};\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Uint8Array} key - peer identifier object.\n */\n\n\nvar getLocalKey = function getLocalKey(key) {\n  return new Key(\"/ipns/\".concat(rawStdEncoding(key)));\n};\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Uint8Array} pid - peer identifier represented by the multihash of the public key as Uint8Array.\n */\n\n\nvar getIdKeys = function getIdKeys(pid) {\n  var pkBuffer = uint8ArrayFromString('/pk/');\n  var ipnsBuffer = uint8ArrayFromString('/ipns/');\n  return {\n    routingPubKey: new Key(uint8ArrayConcat([pkBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(uint8ArrayConcat([pkBuffer, pid]))),\n    routingKey: new Key(uint8ArrayConcat([ipnsBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(uint8ArrayConcat([ipnsBuffer, pid])))\n  };\n};\n/**\n * Sign ipns record data\n *\n * @param {PrivateKey} privateKey\n * @param {Uint8Array} value\n * @param {number} validityType\n * @param {Uint8Array} validity\n */\n\n\nvar sign = function sign(privateKey, value, validityType, validity) {\n  try {\n    var dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n    return privateKey.sign(dataForSignature);\n  } catch (error) {\n    log.error('record signature creation failed');\n    throw errCode(new Error('record signature creation failed: ' + error.message), ERRORS.ERR_SIGNATURE_CREATION);\n  }\n};\n/**\n * Utility for getting the validity type code name of a validity\n *\n * @param {number} validityType\n */\n\n\nvar getValidityType = function getValidityType(validityType) {\n  if (validityType.toString() === '0') {\n    return 'EOL';\n  }\n\n  var error = new Error(\"unrecognized validity type \".concat(validityType.toString()));\n  log.error(error);\n  throw errCode(error, ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n};\n/**\n * Utility for creating the record data for being signed\n *\n * @param {Uint8Array} value\n * @param {number} validityType\n * @param {Uint8Array} validity\n */\n\n\nvar ipnsEntryDataForV1Sig = function ipnsEntryDataForV1Sig(value, validityType, validity) {\n  var validityTypeBuffer = uint8ArrayFromString(getValidityType(validityType));\n  return uint8ArrayConcat([value, validity, validityTypeBuffer]);\n};\n/**\n * Utility for creating the record data for being signed\n *\n * @param {Uint8Array} data\n */\n\n\nvar ipnsEntryDataForV2Sig = function ipnsEntryDataForV2Sig(data) {\n  var entryData = uint8ArrayFromString('ipns-signature:');\n  return uint8ArrayConcat([entryData, data]);\n};\n/**\n * Utility for extracting the public key from a peer-id\n *\n * @param {PeerId} peerId\n */\n\n\nvar extractPublicKeyFromId = function extractPublicKeyFromId(peerId) {\n  var digest = Digest.decode(peerId.id);\n\n  if (digest.code !== ID_MULTIHASH_CODE) {\n    return null;\n  }\n\n  return crypto.keys.unmarshalPublicKey(digest.digest);\n};\n/**\n * @param {IPNSEntry} obj\n */\n\n\nvar marshal = function marshal(obj) {\n  return ipnsEntryProto.encode(_objectSpread(_objectSpread({}, obj), {}, {\n    sequence: Long.fromString(obj.sequence.toString()),\n    ttl: obj.ttl == null ? undefined : Long.fromString(obj.ttl.toString())\n  })).finish();\n};\n/**\n * @param {Uint8Array} buf\n * @returns {IPNSEntry}\n */\n\n\nvar unmarshal = function unmarshal(buf) {\n  var message = ipnsEntryProto.decode(buf);\n  var object = ipnsEntryProto.toObject(message, {\n    defaults: false,\n    arrays: true,\n    objects: false\n  });\n  return {\n    value: object.value,\n    signature: object.signature,\n    validityType: object.validityType,\n    validity: object.validity,\n    sequence: Object.hasOwnProperty.call(object, 'sequence') ? BigInt(\"\".concat(object.sequence)) : 0n,\n    pubKey: object.pubKey,\n    ttl: Object.hasOwnProperty.call(object, 'ttl') ? BigInt(\"\".concat(object.ttl)) : undefined,\n    signatureV2: object.signatureV2,\n    data: object.data\n  };\n};\n\nvar validator = {\n  /**\n   * @param {Uint8Array} marshalledData\n   * @param {Uint8Array} key\n   */\n  validate: function () {\n    var _validate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(marshalledData, key) {\n      var receivedEntry, bufferId, peerId, pubKey;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              receivedEntry = unmarshal(marshalledData);\n              bufferId = key.slice(IPNS_PREFIX.length);\n              peerId = PeerId.createFromBytes(bufferId); // extract public key\n\n              _context5.next = 5;\n              return extractPublicKey(peerId, receivedEntry);\n\n            case 5:\n              pubKey = _context5.sent;\n              _context5.next = 8;\n              return _validate(pubKey, receivedEntry);\n\n            case 8:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    function validate(_x13, _x14) {\n      return _validate2.apply(this, arguments);\n    }\n\n    return validate;\n  }(),\n\n  /**\n   * @param {Uint8Array} dataA\n   * @param {Uint8Array} dataB\n   */\n  select: function select(dataA, dataB) {\n    var entryA = unmarshal(dataA);\n    var entryB = unmarshal(dataB); // having a newer signature version is better than an older signature version\n\n    if (entryA.signatureV2 && !entryB.signatureV2) {\n      return 0;\n    } else if (entryB.signatureV2 && !entryA.signatureV2) {\n      return 1;\n    } // choose later sequence number\n\n\n    if (entryA.sequence > entryB.sequence) {\n      return 0;\n    } else if (entryA.sequence < entryB.sequence) {\n      return 1;\n    } // choose longer lived record if sequence numbers the same\n\n\n    var entryAValidityDate = parseRFC3339(uint8ArrayToString(entryA.validity));\n    var entryBValidityDate = parseRFC3339(uint8ArrayToString(entryB.validity));\n    return entryBValidityDate.getTime() > entryAValidityDate.getTime() ? 1 : 0;\n  }\n};\nmodule.exports = {\n  // create ipns entry record\n  create: create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration: createWithExpiration,\n  // validate ipns entry record\n  validate: _validate,\n  // embed public key in the record\n  embedPublicKey: embedPublicKey,\n  // extract public key from the record\n  extractPublicKey: extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey: getLocalKey,\n  // get keys for routing\n  getIdKeys: getIdKeys,\n  // marshal\n  marshal: marshal,\n  // unmarshal\n  unmarshal: unmarshal,\n  // validator\n  validator: validator,\n  // namespace\n  namespace: namespace,\n  namespaceLength: namespace.length\n};","map":{"version":3,"names":["NanoDate","require","Key","crypto","PeerId","Digest","identity","errCode","base32upper","uint8ArrayFromString","fromString","uint8ArrayToString","toString","uint8ArrayConcat","concat","uint8ArrayEquals","equals","cborg","Long","debug","log","Object","assign","error","ipnsEntryProto","IpnsEntry","parseRFC3339","ERRORS","ID_MULTIHASH_CODE","code","namespace","IPNS_PREFIX","create","privateKey","value","seq","lifetime","expirationDate","Date","now","Number","validityType","ValidityType","EOL","split","ms","ns","lifetimeNs","BigInt","_create","createWithExpiration","expiration","ttlMs","toDate","getTime","ttlNs","getNano","ttl","isoValidity","sign","signatureV1","data","createCborData","sigData","ipnsEntryDataForV2Sig","signatureV2","entry","signature","validity","sequence","Value","Validity","Sequence","TTL","encode","validate","publicKey","dataForSignature","validateCborDataMatchesPbData","ipnsEntryDataForV1Sig","verify","isValid","Error","ERR_SIGNATURE_VERIFICATION","validityDate","ERR_UNRECOGNIZED_FORMAT","ERR_IPNS_EXPIRED_RECORD","ERR_UNRECOGNIZED_VALIDITY","ERR_INVALID_RECORD_DATA","decode","isInteger","embedPublicKey","bytes","ERR_UNDEFINED_PARAMETER","createFromPubKey","peerId","ERR_PEER_ID_FROM_PUBLIC_KEY","extractedPublicKey","extractPublicKeyFromId","ERR_PUBLIC_KEY_FROM_ID","pubKey","keys","marshalPublicKey","extractPublicKey","unmarshalPublicKey","otherId","ERR_INVALID_EMBEDDED_KEY","rawStdEncoding","key","slice","getLocalKey","getIdKeys","pid","pkBuffer","ipnsBuffer","routingPubKey","pkKey","routingKey","ipnsKey","message","ERR_SIGNATURE_CREATION","getValidityType","validityTypeBuffer","entryData","digest","id","marshal","obj","undefined","finish","unmarshal","buf","object","toObject","defaults","arrays","objects","hasOwnProperty","call","validator","marshalledData","receivedEntry","bufferId","length","createFromBytes","select","dataA","dataB","entryA","entryB","entryAValidityDate","entryBValidityDate","module","exports","namespaceLength"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipns/src/index.js"],"sourcesContent":["'use strict'\n\nconst NanoDate = require('timestamp-nano')\nconst { Key } = require('interface-datastore')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst Digest = require('multiformats/hashes/digest')\nconst { identity } = require('multiformats/hashes/identity')\nconst errCode = require('err-code')\nconst { base32upper } = require('multiformats/bases/base32')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst cborg = require('cborg')\nconst Long = require('long')\n\nconst debug = require('debug')\nconst log = Object.assign(debug('jsipns'), {\n  error: debug('jsipns:error')\n})\n\nconst {\n  IpnsEntry: ipnsEntryProto\n} = require('./pb/ipns.js')\nconst { parseRFC3339 } = require('./utils')\nconst ERRORS = require('./errors')\n\nconst ID_MULTIHASH_CODE = identity.code\n\nconst namespace = '/ipns/'\nconst IPNS_PREFIX = uint8ArrayFromString('/ipns/')\n\n/**\n * @typedef {import('./types').IPNSEntry} IPNSEntry\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n */\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {PrivateKey} privateKey - private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {number} lifetime - lifetime of the record (in milliseconds).\n */\nconst create = (privateKey, value, seq, lifetime) => {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  const expirationDate = new NanoDate(Date.now() + Number(lifetime))\n  const validityType = ipnsEntryProto.ValidityType.EOL\n  const [ms, ns] = lifetime.toString().split('.')\n  const lifetimeNs = BigInt(ms) * 100000n + BigInt(ns || 0)\n\n  return _create(privateKey, value, seq, validityType, expirationDate, lifetimeNs)\n}\n\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n *\n * @param {PrivateKey} privateKey - private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {string} expiration - expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n */\nconst createWithExpiration = (privateKey, value, seq, expiration) => {\n  const expirationDate = NanoDate.fromString(expiration)\n  const validityType = ipnsEntryProto.ValidityType.EOL\n\n  const ttlMs = expirationDate.toDate().getTime() - Date.now()\n  const ttlNs = (BigInt(ttlMs) * 100000n) + BigInt(expirationDate.getNano())\n\n  return _create(privateKey, value, seq, validityType, expirationDate, ttlNs)\n}\n\n/**\n * @param {PrivateKey} privateKey\n * @param {Uint8Array} value\n * @param {number | bigint} seq\n * @param {number} validityType\n * @param {NanoDate} expirationDate\n * @param {bigint} ttl\n * @returns {Promise<IPNSEntry>}\n */\nconst _create = async (privateKey, value, seq, validityType, expirationDate, ttl) => {\n  seq = BigInt(seq)\n  const isoValidity = uint8ArrayFromString(expirationDate.toString())\n  const signatureV1 = await sign(privateKey, value, validityType, isoValidity)\n  const data = createCborData(value, isoValidity, validityType, seq, ttl)\n  const sigData = ipnsEntryDataForV2Sig(data)\n  const signatureV2 = await privateKey.sign(sigData)\n\n  const entry = {\n    value,\n    signature: signatureV1,\n    validityType: validityType,\n    validity: isoValidity,\n    sequence: seq,\n    ttl,\n    signatureV2,\n    data\n  }\n\n  log(`ipns entry for ${value} created`)\n  return entry\n}\n\n/**\n * @param {Uint8Array} value\n * @param {Uint8Array} validity\n * @param {number} validityType\n * @param {bigint} sequence\n * @param {bigint} ttl\n */\nconst createCborData = (value, validity, validityType, sequence, ttl) => {\n  const data = {\n    Value: value,\n    Validity: validity,\n    ValidityType: validityType,\n    Sequence: sequence,\n    TTL: ttl\n  }\n\n  return cborg.encode(data)\n}\n\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {PublicKey} publicKey - public key for validating the record.\n * @param {IPNSEntry} entry - ipns entry record.\n */\nconst validate = async (publicKey, entry) => {\n  const { value, validityType, validity } = entry\n\n  /** @type {Uint8Array} */\n  let dataForSignature\n  let signature\n\n  // Check v2 signature if it's available, otherwise use the v1 signature\n  if (entry.signatureV2 && entry.data) {\n    signature = entry.signatureV2\n    dataForSignature = ipnsEntryDataForV2Sig(entry.data)\n\n    validateCborDataMatchesPbData(entry)\n  } else {\n    signature = entry.signature\n    dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity)\n  }\n\n  // Validate Signature\n  let isValid\n  try {\n    isValid = await publicKey.verify(dataForSignature, signature)\n  } catch (err) {\n    isValid = false\n  }\n  if (!isValid) {\n    log.error('record signature verification failed')\n    throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  // Validate according to the validity type\n  if (validityType === ipnsEntryProto.ValidityType.EOL) {\n    let validityDate\n\n    try {\n      validityDate = parseRFC3339(uint8ArrayToString(validity))\n    } catch (e) {\n      log.error('unrecognized validity format (not an rfc3339 format)')\n      throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT)\n    }\n\n    if (validityDate.getTime() < Date.now()) {\n      log.error('record has expired')\n      throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD)\n    }\n  } else if (validityType) {\n    log.error('unrecognized validity type')\n    throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n  }\n\n  log(`ipns entry for ${value} is valid`)\n}\n\n/**\n * @param {IPNSEntry} entry\n */\nconst validateCborDataMatchesPbData = (entry) => {\n  if (!entry.data) {\n    throw errCode(new Error('Record data is missing'), ERRORS.ERR_INVALID_RECORD_DATA)\n  }\n\n  const data = cborg.decode(entry.data)\n\n  if (Number.isInteger(data.Sequence)) {\n    // sequence must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.Sequence = BigInt(data.Sequence)\n  }\n\n  if (Number.isInteger(data.TTL)) {\n    // ttl must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.TTL = BigInt(data.TTL)\n  }\n\n  if (!uint8ArrayEquals(data.Value, entry.value)) {\n    throw errCode(new Error('Field \"value\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (!uint8ArrayEquals(data.Validity, entry.validity)) {\n    throw errCode(new Error('Field \"validity\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (data.ValidityType !== entry.validityType) {\n    throw errCode(new Error('Field \"validityType\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (data.Sequence !== entry.sequence) {\n    throw errCode(new Error('Field \"sequence\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (data.TTL !== entry.ttl) {\n    throw errCode(new Error('Field \"ttl\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n}\n\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validate a record upon receipt, they need\n * the public key associated with it. For old RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {PublicKey} publicKey - public key to embed.\n * @param {IPNSEntry} entry - ipns entry record.\n */\nconst embedPublicKey = async (publicKey, entry) => {\n  if (!publicKey || !publicKey.bytes || !entry) {\n    const error = new Error('one or more of the provided parameters are not defined')\n    log.error(error)\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER)\n  }\n\n  // Create a peer id from the public key.\n  let peerId\n  try {\n    peerId = await PeerId.createFromPubKey(publicKey.bytes)\n  } catch (err) {\n    throw errCode(err, ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY)\n  }\n\n  // Try to extract the public key from the ID. If we can, no need to embed it\n  let extractedPublicKey\n  try {\n    extractedPublicKey = extractPublicKeyFromId(peerId)\n  } catch (err) {\n    log.error(err)\n    throw errCode(err, ERRORS.ERR_PUBLIC_KEY_FROM_ID)\n  }\n\n  if (extractedPublicKey) {\n    return null\n  }\n\n  // If we failed to extract the public key from the peer ID, embed it in the record.\n  try {\n    entry.pubKey = crypto.keys.marshalPublicKey(publicKey)\n  } catch (err) {\n    log.error(err)\n    throw err\n  }\n  return entry\n}\n\n/**\n * Extracts a public key from the passed PeerId, falling\n * back to the pubKey embedded in the ipns record.\n *\n * @param {PeerId} peerId - peer identifier object.\n * @param {IPNSEntry} entry - ipns entry record.\n */\nconst extractPublicKey = async (peerId, entry) => {\n  if (!entry || !peerId) {\n    const error = new Error('one or more of the provided parameters are not defined')\n\n    log.error(error)\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER)\n  }\n\n  let pubKey\n\n  if (entry.pubKey) {\n    try {\n      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    const otherId = await PeerId.createFromPubKey(entry.pubKey)\n\n    if (!otherId.equals(peerId)) {\n      throw errCode(new Error('Embedded public key did not match PeerID'), ERRORS.ERR_INVALID_EMBEDDED_KEY)\n    }\n  } else if (peerId.pubKey) {\n    pubKey = peerId.pubKey\n  }\n\n  if (pubKey) {\n    return pubKey\n  }\n\n  throw errCode(new Error('no public key is available'), ERRORS.ERR_UNDEFINED_PARAMETER)\n}\n\n/**\n * rawStdEncoding with RFC4648\n *\n * @param {Uint8Array} key\n */\nconst rawStdEncoding = (key) => base32upper.encode(key).slice(1)\n\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Uint8Array} key - peer identifier object.\n */\nconst getLocalKey = (key) => new Key(`/ipns/${rawStdEncoding(key)}`)\n\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Uint8Array} pid - peer identifier represented by the multihash of the public key as Uint8Array.\n */\nconst getIdKeys = (pid) => {\n  const pkBuffer = uint8ArrayFromString('/pk/')\n  const ipnsBuffer = uint8ArrayFromString('/ipns/')\n\n  return {\n    routingPubKey: new Key(uint8ArrayConcat([pkBuffer, pid]), false), // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(uint8ArrayConcat([pkBuffer, pid]))),\n    routingKey: new Key(uint8ArrayConcat([ipnsBuffer, pid]), false), // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(uint8ArrayConcat([ipnsBuffer, pid])))\n  }\n}\n\n/**\n * Sign ipns record data\n *\n * @param {PrivateKey} privateKey\n * @param {Uint8Array} value\n * @param {number} validityType\n * @param {Uint8Array} validity\n */\nconst sign = (privateKey, value, validityType, validity) => {\n  try {\n    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity)\n\n    return privateKey.sign(dataForSignature)\n  } catch (error) {\n    log.error('record signature creation failed')\n    throw errCode(new Error('record signature creation failed: ' + error.message), ERRORS.ERR_SIGNATURE_CREATION)\n  }\n}\n\n/**\n * Utility for getting the validity type code name of a validity\n *\n * @param {number} validityType\n */\nconst getValidityType = (validityType) => {\n  if (validityType.toString() === '0') {\n    return 'EOL'\n  }\n\n  const error = new Error(`unrecognized validity type ${validityType.toString()}`)\n  log.error(error)\n  throw errCode(error, ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n}\n\n/**\n * Utility for creating the record data for being signed\n *\n * @param {Uint8Array} value\n * @param {number} validityType\n * @param {Uint8Array} validity\n */\nconst ipnsEntryDataForV1Sig = (value, validityType, validity) => {\n  const validityTypeBuffer = uint8ArrayFromString(getValidityType(validityType))\n\n  return uint8ArrayConcat([value, validity, validityTypeBuffer])\n}\n\n/**\n * Utility for creating the record data for being signed\n *\n * @param {Uint8Array} data\n */\nconst ipnsEntryDataForV2Sig = (data) => {\n  const entryData = uint8ArrayFromString('ipns-signature:')\n\n  return uint8ArrayConcat([entryData, data])\n}\n\n/**\n * Utility for extracting the public key from a peer-id\n *\n * @param {PeerId} peerId\n */\nconst extractPublicKeyFromId = (peerId) => {\n  const digest = Digest.decode(peerId.id)\n\n  if (digest.code !== ID_MULTIHASH_CODE) {\n    return null\n  }\n\n  return crypto.keys.unmarshalPublicKey(digest.digest)\n}\n\n/**\n * @param {IPNSEntry} obj\n */\nconst marshal = (obj) => {\n  return ipnsEntryProto.encode({\n    ...obj,\n    sequence: Long.fromString(obj.sequence.toString()),\n    ttl: obj.ttl == null ? undefined : Long.fromString(obj.ttl.toString())\n  }).finish()\n}\n\n/**\n * @param {Uint8Array} buf\n * @returns {IPNSEntry}\n */\nconst unmarshal = (buf) => {\n  const message = ipnsEntryProto.decode(buf)\n  const object = ipnsEntryProto.toObject(message, {\n    defaults: false,\n    arrays: true,\n    objects: false\n  })\n\n  return {\n    value: object.value,\n    signature: object.signature,\n    validityType: object.validityType,\n    validity: object.validity,\n    sequence: Object.hasOwnProperty.call(object, 'sequence') ? BigInt(`${object.sequence}`) : 0n,\n    pubKey: object.pubKey,\n    ttl: Object.hasOwnProperty.call(object, 'ttl') ? BigInt(`${object.ttl}`) : undefined,\n    signatureV2: object.signatureV2,\n    data: object.data\n  }\n}\n\nconst validator = {\n  /**\n   * @param {Uint8Array} marshalledData\n   * @param {Uint8Array} key\n   */\n  validate: async (marshalledData, key) => {\n    const receivedEntry = unmarshal(marshalledData)\n    const bufferId = key.slice(IPNS_PREFIX.length)\n    const peerId = PeerId.createFromBytes(bufferId)\n\n    // extract public key\n    const pubKey = await extractPublicKey(peerId, receivedEntry)\n\n    // Record validation\n    await validate(pubKey, receivedEntry)\n  },\n\n  /**\n   * @param {Uint8Array} dataA\n   * @param {Uint8Array} dataB\n   */\n  select: (dataA, dataB) => {\n    const entryA = unmarshal(dataA)\n    const entryB = unmarshal(dataB)\n\n    // having a newer signature version is better than an older signature version\n    if (entryA.signatureV2 && !entryB.signatureV2) {\n      return 0\n    } else if (entryB.signatureV2 && !entryA.signatureV2) {\n      return 1\n    }\n\n    // choose later sequence number\n    if (entryA.sequence > entryB.sequence) {\n      return 0\n    } else if (entryA.sequence < entryB.sequence) {\n      return 1\n    }\n\n    // choose longer lived record if sequence numbers the same\n    const entryAValidityDate = parseRFC3339(uint8ArrayToString(entryA.validity))\n    const entryBValidityDate = parseRFC3339(uint8ArrayToString(entryB.validity))\n\n    return entryBValidityDate.getTime() > entryAValidityDate.getTime() ? 1 : 0\n  }\n}\n\nmodule.exports = {\n  // create ipns entry record\n  create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration,\n  // validate ipns entry record\n  validate,\n  // embed public key in the record\n  embedPublicKey,\n  // extract public key from the record\n  extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey,\n  // get keys for routing\n  getIdKeys,\n  // marshal\n  marshal,\n  // unmarshal\n  unmarshal,\n  // validator\n  validator,\n  // namespace\n  namespace,\n  namespaceLength: namespace.length\n}\n"],"mappings":"AAAA;;;;;;;;;;AAEA,IAAMA,QAAQ,GAAGC,OAAO,CAAC,gBAAD,CAAxB;;AACA,eAAgBA,OAAO,CAAC,qBAAD,CAAvB;AAAA,IAAQC,GAAR,YAAQA,GAAR;;AACA,IAAMC,MAAM,GAAGF,OAAO,CAAC,eAAD,CAAtB;;AACA,IAAMG,MAAM,GAAGH,OAAO,CAAC,SAAD,CAAtB;;AACA,IAAMI,MAAM,GAAGJ,OAAO,CAAC,4BAAD,CAAtB;;AACA,gBAAqBA,OAAO,CAAC,8BAAD,CAA5B;AAAA,IAAQK,QAAR,aAAQA,QAAR;;AACA,IAAMC,OAAO,GAAGN,OAAO,CAAC,UAAD,CAAvB;;AACA,gBAAwBA,OAAO,CAAC,2BAAD,CAA/B;AAAA,IAAQO,WAAR,aAAQA,WAAR;;AACA,gBAA6CP,OAAO,CAAC,yBAAD,CAApD;AAAA,IAAoBQ,oBAApB,aAAQC,UAAR;;AACA,gBAAyCT,OAAO,CAAC,uBAAD,CAAhD;AAAA,IAAkBU,kBAAlB,aAAQC,QAAR;;AACA,gBAAqCX,OAAO,CAAC,oBAAD,CAA5C;AAAA,IAAgBY,gBAAhB,aAAQC,MAAR;;AACA,gBAAqCb,OAAO,CAAC,oBAAD,CAA5C;AAAA,IAAgBc,gBAAhB,aAAQC,MAAR;;AACA,IAAMC,KAAK,GAAGhB,OAAO,CAAC,OAAD,CAArB;;AACA,IAAMiB,IAAI,GAAGjB,OAAO,CAAC,MAAD,CAApB;;AAEA,IAAMkB,KAAK,GAAGlB,OAAO,CAAC,OAAD,CAArB;;AACA,IAAMmB,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcH,KAAK,CAAC,QAAD,CAAnB,EAA+B;EACzCI,KAAK,EAAEJ,KAAK,CAAC,cAAD;AAD6B,CAA/B,CAAZ;;AAIA,gBAEIlB,OAAO,CAAC,cAAD,CAFX;AAAA,IACauB,cADb,aACEC,SADF;;AAGA,gBAAyBxB,OAAO,CAAC,SAAD,CAAhC;AAAA,IAAQyB,YAAR,aAAQA,YAAR;;AACA,IAAMC,MAAM,GAAG1B,OAAO,CAAC,UAAD,CAAtB;;AAEA,IAAM2B,iBAAiB,GAAGtB,QAAQ,CAACuB,IAAnC;AAEA,IAAMC,SAAS,GAAG,QAAlB;AACA,IAAMC,WAAW,GAAGtB,oBAAoB,CAAC,QAAD,CAAxC;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMuB,MAAM,GAAG,SAATA,MAAS,CAACC,UAAD,EAAaC,KAAb,EAAoBC,GAApB,EAAyBC,QAAzB,EAAsC;EACnD;EACA,IAAMC,cAAc,GAAG,IAAIrC,QAAJ,CAAasC,IAAI,CAACC,GAAL,KAAaC,MAAM,CAACJ,QAAD,CAAhC,CAAvB;EACA,IAAMK,YAAY,GAAGjB,cAAc,CAACkB,YAAf,CAA4BC,GAAjD;;EACA,4BAAiBP,QAAQ,CAACxB,QAAT,GAAoBgC,KAApB,CAA0B,GAA1B,CAAjB;EAAA;EAAA,IAAOC,EAAP;EAAA,IAAWC,EAAX;;EACA,IAAMC,UAAU,GAAGC,MAAM,CAACH,EAAD,CAAN,GAAa,OAAb,GAAuBG,MAAM,CAACF,EAAE,IAAI,CAAP,CAAhD;EAEA,OAAOG,OAAO,CAAChB,UAAD,EAAaC,KAAb,EAAoBC,GAApB,EAAyBM,YAAzB,EAAuCJ,cAAvC,EAAuDU,UAAvD,CAAd;AACD,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMG,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACjB,UAAD,EAAaC,KAAb,EAAoBC,GAApB,EAAyBgB,UAAzB,EAAwC;EACnE,IAAMd,cAAc,GAAGrC,QAAQ,CAACU,UAAT,CAAoByC,UAApB,CAAvB;EACA,IAAMV,YAAY,GAAGjB,cAAc,CAACkB,YAAf,CAA4BC,GAAjD;EAEA,IAAMS,KAAK,GAAGf,cAAc,CAACgB,MAAf,GAAwBC,OAAxB,KAAoChB,IAAI,CAACC,GAAL,EAAlD;EACA,IAAMgB,KAAK,GAAIP,MAAM,CAACI,KAAD,CAAN,GAAgB,OAAjB,GAA4BJ,MAAM,CAACX,cAAc,CAACmB,OAAf,EAAD,CAAhD;EAEA,OAAOP,OAAO,CAAChB,UAAD,EAAaC,KAAb,EAAoBC,GAApB,EAAyBM,YAAzB,EAAuCJ,cAAvC,EAAuDkB,KAAvD,CAAd;AACD,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMN,OAAO;EAAA,sEAAG,iBAAOhB,UAAP,EAAmBC,KAAnB,EAA0BC,GAA1B,EAA+BM,YAA/B,EAA6CJ,cAA7C,EAA6DoB,GAA7D;IAAA;IAAA;MAAA;QAAA;UAAA;YACdtB,GAAG,GAAGa,MAAM,CAACb,GAAD,CAAZ;YACMuB,WAFQ,GAEMjD,oBAAoB,CAAC4B,cAAc,CAACzB,QAAf,EAAD,CAF1B;YAAA;YAAA,OAGY+C,IAAI,CAAC1B,UAAD,EAAaC,KAAb,EAAoBO,YAApB,EAAkCiB,WAAlC,CAHhB;;UAAA;YAGRE,WAHQ;YAIRC,IAJQ,GAIDC,cAAc,CAAC5B,KAAD,EAAQwB,WAAR,EAAqBjB,YAArB,EAAmCN,GAAnC,EAAwCsB,GAAxC,CAJb;YAKRM,OALQ,GAKEC,qBAAqB,CAACH,IAAD,CALvB;YAAA;YAAA,OAMY5B,UAAU,CAAC0B,IAAX,CAAgBI,OAAhB,CANZ;;UAAA;YAMRE,WANQ;YAQRC,KARQ,GAQA;cACZhC,KAAK,EAALA,KADY;cAEZiC,SAAS,EAAEP,WAFC;cAGZnB,YAAY,EAAEA,YAHF;cAIZ2B,QAAQ,EAAEV,WAJE;cAKZW,QAAQ,EAAElC,GALE;cAMZsB,GAAG,EAAHA,GANY;cAOZQ,WAAW,EAAXA,WAPY;cAQZJ,IAAI,EAAJA;YARY,CARA;YAmBdzC,GAAG,0BAAmBc,KAAnB,cAAH;YAnBc,iCAoBPgC,KApBO;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAAH;;EAAA,gBAAPjB,OAAO;IAAA;EAAA;AAAA,GAAb;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMa,cAAc,GAAG,SAAjBA,cAAiB,CAAC5B,KAAD,EAAQkC,QAAR,EAAkB3B,YAAlB,EAAgC4B,QAAhC,EAA0CZ,GAA1C,EAAkD;EACvE,IAAMI,IAAI,GAAG;IACXS,KAAK,EAAEpC,KADI;IAEXqC,QAAQ,EAAEH,QAFC;IAGX1B,YAAY,EAAED,YAHH;IAIX+B,QAAQ,EAAEH,QAJC;IAKXI,GAAG,EAAEhB;EALM,CAAb;EAQA,OAAOxC,KAAK,CAACyD,MAAN,CAAab,IAAb,CAAP;AACD,CAVD;AAYA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMc,SAAQ;EAAA,uEAAG,kBAAOC,SAAP,EAAkBV,KAAlB;IAAA;IAAA;MAAA;QAAA;UAAA;YACPhC,KADO,GAC2BgC,KAD3B,CACPhC,KADO,EACAO,YADA,GAC2ByB,KAD3B,CACAzB,YADA,EACc2B,QADd,GAC2BF,KAD3B,CACcE,QADd;YAGf;;YAIA;YACA,IAAIF,KAAK,CAACD,WAAN,IAAqBC,KAAK,CAACL,IAA/B,EAAqC;cACnCM,SAAS,GAAGD,KAAK,CAACD,WAAlB;cACAY,gBAAgB,GAAGb,qBAAqB,CAACE,KAAK,CAACL,IAAP,CAAxC;cAEAiB,6BAA6B,CAACZ,KAAD,CAA7B;YACD,CALD,MAKO;cACLC,SAAS,GAAGD,KAAK,CAACC,SAAlB;cACAU,gBAAgB,GAAGE,qBAAqB,CAAC7C,KAAD,EAAQO,YAAR,EAAsB2B,QAAtB,CAAxC;YACD,CAhBc,CAkBf;;;YAlBe;YAAA;YAAA,OAqBGQ,SAAS,CAACI,MAAV,CAAiBH,gBAAjB,EAAmCV,SAAnC,CArBH;;UAAA;YAqBbc,OArBa;YAAA;YAAA;;UAAA;YAAA;YAAA;YAuBbA,OAAO,GAAG,KAAV;;UAvBa;YAAA,IAyBVA,OAzBU;cAAA;cAAA;YAAA;;YA0Bb7D,GAAG,CAACG,KAAJ,CAAU,sCAAV;YA1Ba,MA2BPhB,OAAO,CAAC,IAAI2E,KAAJ,CAAU,sCAAV,CAAD,EAAoDvD,MAAM,CAACwD,0BAA3D,CA3BA;;UAAA;YAAA,MA+BX1C,YAAY,KAAKjB,cAAc,CAACkB,YAAf,CAA4BC,GA/BlC;cAAA;cAAA;YAAA;;YAAA;YAmCXyC,YAAY,GAAG1D,YAAY,CAACf,kBAAkB,CAACyD,QAAD,CAAnB,CAA3B;YAnCW;YAAA;;UAAA;YAAA;YAAA;YAqCXhD,GAAG,CAACG,KAAJ,CAAU,sDAAV;YArCW,MAsCLhB,OAAO,CAAC,IAAI2E,KAAJ,CAAU,sDAAV,CAAD,EAAoEvD,MAAM,CAAC0D,uBAA3E,CAtCF;;UAAA;YAAA,MAyCTD,YAAY,CAAC9B,OAAb,KAAyBhB,IAAI,CAACC,GAAL,EAzChB;cAAA;cAAA;YAAA;;YA0CXnB,GAAG,CAACG,KAAJ,CAAU,oBAAV;YA1CW,MA2CLhB,OAAO,CAAC,IAAI2E,KAAJ,CAAU,oBAAV,CAAD,EAAkCvD,MAAM,CAAC2D,uBAAzC,CA3CF;;UAAA;YAAA;YAAA;;UAAA;YAAA,KA6CJ7C,YA7CI;cAAA;cAAA;YAAA;;YA8CbrB,GAAG,CAACG,KAAJ,CAAU,4BAAV;YA9Ca,MA+CPhB,OAAO,CAAC,IAAI2E,KAAJ,CAAU,4BAAV,CAAD,EAA0CvD,MAAM,CAAC4D,yBAAjD,CA/CA;;UAAA;YAkDfnE,GAAG,0BAAmBc,KAAnB,eAAH;;UAlDe;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAAH;;EAAA,gBAARyC,QAAQ;IAAA;EAAA;AAAA,GAAd;AAqDA;AACA;AACA;;;AACA,IAAMG,6BAA6B,GAAG,SAAhCA,6BAAgC,CAACZ,KAAD,EAAW;EAC/C,IAAI,CAACA,KAAK,CAACL,IAAX,EAAiB;IACf,MAAMtD,OAAO,CAAC,IAAI2E,KAAJ,CAAU,wBAAV,CAAD,EAAsCvD,MAAM,CAAC6D,uBAA7C,CAAb;EACD;;EAED,IAAM3B,IAAI,GAAG5C,KAAK,CAACwE,MAAN,CAAavB,KAAK,CAACL,IAAnB,CAAb;;EAEA,IAAIrB,MAAM,CAACkD,SAAP,CAAiB7B,IAAI,CAACW,QAAtB,CAAJ,EAAqC;IACnC;IACAX,IAAI,CAACW,QAAL,GAAgBxB,MAAM,CAACa,IAAI,CAACW,QAAN,CAAtB;EACD;;EAED,IAAIhC,MAAM,CAACkD,SAAP,CAAiB7B,IAAI,CAACY,GAAtB,CAAJ,EAAgC;IAC9B;IACAZ,IAAI,CAACY,GAAL,GAAWzB,MAAM,CAACa,IAAI,CAACY,GAAN,CAAjB;EACD;;EAED,IAAI,CAAC1D,gBAAgB,CAAC8C,IAAI,CAACS,KAAN,EAAaJ,KAAK,CAAChC,KAAnB,CAArB,EAAgD;IAC9C,MAAM3B,OAAO,CAAC,IAAI2E,KAAJ,CAAU,uDAAV,CAAD,EAAqEvD,MAAM,CAACwD,0BAA5E,CAAb;EACD;;EAED,IAAI,CAACpE,gBAAgB,CAAC8C,IAAI,CAACU,QAAN,EAAgBL,KAAK,CAACE,QAAtB,CAArB,EAAsD;IACpD,MAAM7D,OAAO,CAAC,IAAI2E,KAAJ,CAAU,0DAAV,CAAD,EAAwEvD,MAAM,CAACwD,0BAA/E,CAAb;EACD;;EAED,IAAItB,IAAI,CAACnB,YAAL,KAAsBwB,KAAK,CAACzB,YAAhC,EAA8C;IAC5C,MAAMlC,OAAO,CAAC,IAAI2E,KAAJ,CAAU,8DAAV,CAAD,EAA4EvD,MAAM,CAACwD,0BAAnF,CAAb;EACD;;EAED,IAAItB,IAAI,CAACW,QAAL,KAAkBN,KAAK,CAACG,QAA5B,EAAsC;IACpC,MAAM9D,OAAO,CAAC,IAAI2E,KAAJ,CAAU,0DAAV,CAAD,EAAwEvD,MAAM,CAACwD,0BAA/E,CAAb;EACD;;EAED,IAAItB,IAAI,CAACY,GAAL,KAAaP,KAAK,CAACT,GAAvB,EAA4B;IAC1B,MAAMlD,OAAO,CAAC,IAAI2E,KAAJ,CAAU,qDAAV,CAAD,EAAmEvD,MAAM,CAACwD,0BAA1E,CAAb;EACD;AACF,CApCD;AAsCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMQ,cAAc;EAAA,uEAAG,kBAAOf,SAAP,EAAkBV,KAAlB;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,MACjB,CAACU,SAAD,IAAc,CAACA,SAAS,CAACgB,KAAzB,IAAkC,CAAC1B,KADlB;cAAA;cAAA;YAAA;;YAEb3C,KAFa,GAEL,IAAI2D,KAAJ,CAAU,wDAAV,CAFK;YAGnB9D,GAAG,CAACG,KAAJ,CAAUA,KAAV;YAHmB,MAIbhB,OAAO,CAACgB,KAAD,EAAQI,MAAM,CAACkE,uBAAf,CAJM;;UAAA;YAAA;YAAA;YAAA,OAUJzF,MAAM,CAAC0F,gBAAP,CAAwBlB,SAAS,CAACgB,KAAlC,CAVI;;UAAA;YAUnBG,MAVmB;YAAA;YAAA;;UAAA;YAAA;YAAA;YAAA,MAYbxF,OAAO,eAAMoB,MAAM,CAACqE,2BAAb,CAZM;;UAAA;YAAA;YAkBnBC,kBAAkB,GAAGC,sBAAsB,CAACH,MAAD,CAA3C;YAlBmB;YAAA;;UAAA;YAAA;YAAA;YAoBnB3E,GAAG,CAACG,KAAJ;YApBmB,MAqBbhB,OAAO,eAAMoB,MAAM,CAACwE,sBAAb,CArBM;;UAAA;YAAA,KAwBjBF,kBAxBiB;cAAA;cAAA;YAAA;;YAAA,kCAyBZ,IAzBY;;UAAA;YAAA;YA8BnB/B,KAAK,CAACkC,MAAN,GAAejG,MAAM,CAACkG,IAAP,CAAYC,gBAAZ,CAA6B1B,SAA7B,CAAf;YA9BmB;YAAA;;UAAA;YAAA;YAAA;YAgCnBxD,GAAG,CAACG,KAAJ;YAhCmB;;UAAA;YAAA,kCAmCd2C,KAnCc;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAAH;;EAAA,gBAAdyB,cAAc;IAAA;EAAA;AAAA,GAApB;AAsCA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMY,gBAAgB;EAAA,uEAAG,kBAAOR,MAAP,EAAe7B,KAAf;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,MACnB,CAACA,KAAD,IAAU,CAAC6B,MADQ;cAAA;cAAA;YAAA;;YAEfxE,KAFe,GAEP,IAAI2D,KAAJ,CAAU,wDAAV,CAFO;YAIrB9D,GAAG,CAACG,KAAJ,CAAUA,KAAV;YAJqB,MAKfhB,OAAO,CAACgB,KAAD,EAAQI,MAAM,CAACkE,uBAAf,CALQ;;UAAA;YAAA,KAUnB3B,KAAK,CAACkC,MAVa;cAAA;cAAA;YAAA;;YAAA;YAYnBA,MAAM,GAAGjG,MAAM,CAACkG,IAAP,CAAYG,kBAAZ,CAA+BtC,KAAK,CAACkC,MAArC,CAAT;YAZmB;YAAA;;UAAA;YAAA;YAAA;YAcnBhF,GAAG,CAACG,KAAJ;YAdmB;;UAAA;YAAA;YAAA,OAkBCnB,MAAM,CAAC0F,gBAAP,CAAwB5B,KAAK,CAACkC,MAA9B,CAlBD;;UAAA;YAkBfK,OAlBe;;YAAA,IAoBhBA,OAAO,CAACzF,MAAR,CAAe+E,MAAf,CApBgB;cAAA;cAAA;YAAA;;YAAA,MAqBbxF,OAAO,CAAC,IAAI2E,KAAJ,CAAU,0CAAV,CAAD,EAAwDvD,MAAM,CAAC+E,wBAA/D,CArBM;;UAAA;YAAA;YAAA;;UAAA;YAuBhB,IAAIX,MAAM,CAACK,MAAX,EAAmB;cACxBA,MAAM,GAAGL,MAAM,CAACK,MAAhB;YACD;;UAzBsB;YAAA,KA2BnBA,MA3BmB;cAAA;cAAA;YAAA;;YAAA,kCA4BdA,MA5Bc;;UAAA;YAAA,MA+BjB7F,OAAO,CAAC,IAAI2E,KAAJ,CAAU,4BAAV,CAAD,EAA0CvD,MAAM,CAACkE,uBAAjD,CA/BU;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAAH;;EAAA,gBAAhBU,gBAAgB;IAAA;EAAA;AAAA,GAAtB;AAkCA;AACA;AACA;AACA;AACA;;;AACA,IAAMI,cAAc,GAAG,SAAjBA,cAAiB,CAACC,GAAD;EAAA,OAASpG,WAAW,CAACkE,MAAZ,CAAmBkC,GAAnB,EAAwBC,KAAxB,CAA8B,CAA9B,CAAT;AAAA,CAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAACF,GAAD;EAAA,OAAS,IAAI1G,GAAJ,iBAAiByG,cAAc,CAACC,GAAD,CAA/B,EAAT;AAAA,CAApB;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMG,SAAS,GAAG,SAAZA,SAAY,CAACC,GAAD,EAAS;EACzB,IAAMC,QAAQ,GAAGxG,oBAAoB,CAAC,MAAD,CAArC;EACA,IAAMyG,UAAU,GAAGzG,oBAAoB,CAAC,QAAD,CAAvC;EAEA,OAAO;IACL0G,aAAa,EAAE,IAAIjH,GAAJ,CAAQW,gBAAgB,CAAC,CAACoG,QAAD,EAAWD,GAAX,CAAD,CAAxB,EAA2C,KAA3C,CADV;IAC6D;IAClEI,KAAK,EAAE,IAAIlH,GAAJ,CAAQyG,cAAc,CAAC9F,gBAAgB,CAAC,CAACoG,QAAD,EAAWD,GAAX,CAAD,CAAjB,CAAtB,CAFF;IAGLK,UAAU,EAAE,IAAInH,GAAJ,CAAQW,gBAAgB,CAAC,CAACqG,UAAD,EAAaF,GAAb,CAAD,CAAxB,EAA6C,KAA7C,CAHP;IAG4D;IACjEM,OAAO,EAAE,IAAIpH,GAAJ,CAAQyG,cAAc,CAAC9F,gBAAgB,CAAC,CAACqG,UAAD,EAAaF,GAAb,CAAD,CAAjB,CAAtB;EAJJ,CAAP;AAMD,CAVD;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMrD,IAAI,GAAG,SAAPA,IAAO,CAAC1B,UAAD,EAAaC,KAAb,EAAoBO,YAApB,EAAkC2B,QAAlC,EAA+C;EAC1D,IAAI;IACF,IAAMS,gBAAgB,GAAGE,qBAAqB,CAAC7C,KAAD,EAAQO,YAAR,EAAsB2B,QAAtB,CAA9C;IAEA,OAAOnC,UAAU,CAAC0B,IAAX,CAAgBkB,gBAAhB,CAAP;EACD,CAJD,CAIE,OAAOtD,KAAP,EAAc;IACdH,GAAG,CAACG,KAAJ,CAAU,kCAAV;IACA,MAAMhB,OAAO,CAAC,IAAI2E,KAAJ,CAAU,uCAAuC3D,KAAK,CAACgG,OAAvD,CAAD,EAAkE5F,MAAM,CAAC6F,sBAAzE,CAAb;EACD;AACF,CATD;AAWA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,eAAe,GAAG,SAAlBA,eAAkB,CAAChF,YAAD,EAAkB;EACxC,IAAIA,YAAY,CAAC7B,QAAb,OAA4B,GAAhC,EAAqC;IACnC,OAAO,KAAP;EACD;;EAED,IAAMW,KAAK,GAAG,IAAI2D,KAAJ,sCAAwCzC,YAAY,CAAC7B,QAAb,EAAxC,EAAd;EACAQ,GAAG,CAACG,KAAJ,CAAUA,KAAV;EACA,MAAMhB,OAAO,CAACgB,KAAD,EAAQI,MAAM,CAAC4D,yBAAf,CAAb;AACD,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMR,qBAAqB,GAAG,SAAxBA,qBAAwB,CAAC7C,KAAD,EAAQO,YAAR,EAAsB2B,QAAtB,EAAmC;EAC/D,IAAMsD,kBAAkB,GAAGjH,oBAAoB,CAACgH,eAAe,CAAChF,YAAD,CAAhB,CAA/C;EAEA,OAAO5B,gBAAgB,CAAC,CAACqB,KAAD,EAAQkC,QAAR,EAAkBsD,kBAAlB,CAAD,CAAvB;AACD,CAJD;AAMA;AACA;AACA;AACA;AACA;;;AACA,IAAM1D,qBAAqB,GAAG,SAAxBA,qBAAwB,CAACH,IAAD,EAAU;EACtC,IAAM8D,SAAS,GAAGlH,oBAAoB,CAAC,iBAAD,CAAtC;EAEA,OAAOI,gBAAgB,CAAC,CAAC8G,SAAD,EAAY9D,IAAZ,CAAD,CAAvB;AACD,CAJD;AAMA;AACA;AACA;AACA;AACA;;;AACA,IAAMqC,sBAAsB,GAAG,SAAzBA,sBAAyB,CAACH,MAAD,EAAY;EACzC,IAAM6B,MAAM,GAAGvH,MAAM,CAACoF,MAAP,CAAcM,MAAM,CAAC8B,EAArB,CAAf;;EAEA,IAAID,MAAM,CAAC/F,IAAP,KAAgBD,iBAApB,EAAuC;IACrC,OAAO,IAAP;EACD;;EAED,OAAOzB,MAAM,CAACkG,IAAP,CAAYG,kBAAZ,CAA+BoB,MAAM,CAACA,MAAtC,CAAP;AACD,CARD;AAUA;AACA;AACA;;;AACA,IAAME,OAAO,GAAG,SAAVA,OAAU,CAACC,GAAD,EAAS;EACvB,OAAOvG,cAAc,CAACkD,MAAf,iCACFqD,GADE;IAEL1D,QAAQ,EAAEnD,IAAI,CAACR,UAAL,CAAgBqH,GAAG,CAAC1D,QAAJ,CAAazD,QAAb,EAAhB,CAFL;IAGL6C,GAAG,EAAEsE,GAAG,CAACtE,GAAJ,IAAW,IAAX,GAAkBuE,SAAlB,GAA8B9G,IAAI,CAACR,UAAL,CAAgBqH,GAAG,CAACtE,GAAJ,CAAQ7C,QAAR,EAAhB;EAH9B,IAIJqH,MAJI,EAAP;AAKD,CAND;AAQA;AACA;AACA;AACA;;;AACA,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAACC,GAAD,EAAS;EACzB,IAAMZ,OAAO,GAAG/F,cAAc,CAACiE,MAAf,CAAsB0C,GAAtB,CAAhB;EACA,IAAMC,MAAM,GAAG5G,cAAc,CAAC6G,QAAf,CAAwBd,OAAxB,EAAiC;IAC9Ce,QAAQ,EAAE,KADoC;IAE9CC,MAAM,EAAE,IAFsC;IAG9CC,OAAO,EAAE;EAHqC,CAAjC,CAAf;EAMA,OAAO;IACLtG,KAAK,EAAEkG,MAAM,CAAClG,KADT;IAELiC,SAAS,EAAEiE,MAAM,CAACjE,SAFb;IAGL1B,YAAY,EAAE2F,MAAM,CAAC3F,YAHhB;IAIL2B,QAAQ,EAAEgE,MAAM,CAAChE,QAJZ;IAKLC,QAAQ,EAAEhD,MAAM,CAACoH,cAAP,CAAsBC,IAAtB,CAA2BN,MAA3B,EAAmC,UAAnC,IAAiDpF,MAAM,WAAIoF,MAAM,CAAC/D,QAAX,EAAvD,GAAgF,EALrF;IAML+B,MAAM,EAAEgC,MAAM,CAAChC,MANV;IAOL3C,GAAG,EAAEpC,MAAM,CAACoH,cAAP,CAAsBC,IAAtB,CAA2BN,MAA3B,EAAmC,KAAnC,IAA4CpF,MAAM,WAAIoF,MAAM,CAAC3E,GAAX,EAAlD,GAAsEuE,SAPtE;IAQL/D,WAAW,EAAEmE,MAAM,CAACnE,WARf;IASLJ,IAAI,EAAEuE,MAAM,CAACvE;EATR,CAAP;AAWD,CAnBD;;AAqBA,IAAM8E,SAAS,GAAG;EAChB;AACF;AACA;AACA;EACEhE,QAAQ;IAAA,4EAAE,kBAAOiE,cAAP,EAAuBhC,GAAvB;MAAA;MAAA;QAAA;UAAA;YAAA;cACFiC,aADE,GACcX,SAAS,CAACU,cAAD,CADvB;cAEFE,QAFE,GAESlC,GAAG,CAACC,KAAJ,CAAU9E,WAAW,CAACgH,MAAtB,CAFT;cAGFhD,MAHE,GAGO3F,MAAM,CAAC4I,eAAP,CAAuBF,QAAvB,CAHP,EAKR;;cALQ;cAAA,OAMavC,gBAAgB,CAACR,MAAD,EAAS8C,aAAT,CAN7B;;YAAA;cAMFzC,MANE;cAAA;cAAA,OASFzB,SAAQ,CAACyB,MAAD,EAASyC,aAAT,CATN;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAAF;;IAAA;MAAA;IAAA;;IAAA;EAAA,GALQ;;EAiBhB;AACF;AACA;AACA;EACEI,MAAM,EAAE,gBAACC,KAAD,EAAQC,KAAR,EAAkB;IACxB,IAAMC,MAAM,GAAGlB,SAAS,CAACgB,KAAD,CAAxB;IACA,IAAMG,MAAM,GAAGnB,SAAS,CAACiB,KAAD,CAAxB,CAFwB,CAIxB;;IACA,IAAIC,MAAM,CAACnF,WAAP,IAAsB,CAACoF,MAAM,CAACpF,WAAlC,EAA+C;MAC7C,OAAO,CAAP;IACD,CAFD,MAEO,IAAIoF,MAAM,CAACpF,WAAP,IAAsB,CAACmF,MAAM,CAACnF,WAAlC,EAA+C;MACpD,OAAO,CAAP;IACD,CATuB,CAWxB;;;IACA,IAAImF,MAAM,CAAC/E,QAAP,GAAkBgF,MAAM,CAAChF,QAA7B,EAAuC;MACrC,OAAO,CAAP;IACD,CAFD,MAEO,IAAI+E,MAAM,CAAC/E,QAAP,GAAkBgF,MAAM,CAAChF,QAA7B,EAAuC;MAC5C,OAAO,CAAP;IACD,CAhBuB,CAkBxB;;;IACA,IAAMiF,kBAAkB,GAAG5H,YAAY,CAACf,kBAAkB,CAACyI,MAAM,CAAChF,QAAR,CAAnB,CAAvC;IACA,IAAMmF,kBAAkB,GAAG7H,YAAY,CAACf,kBAAkB,CAAC0I,MAAM,CAACjF,QAAR,CAAnB,CAAvC;IAEA,OAAOmF,kBAAkB,CAACjG,OAAnB,KAA+BgG,kBAAkB,CAAChG,OAAnB,EAA/B,GAA8D,CAA9D,GAAkE,CAAzE;EACD;AA5Ce,CAAlB;AA+CAkG,MAAM,CAACC,OAAP,GAAiB;EACf;EACAzH,MAAM,EAANA,MAFe;EAGf;EACAkB,oBAAoB,EAApBA,oBAJe;EAKf;EACAyB,QAAQ,EAARA,SANe;EAOf;EACAgB,cAAc,EAAdA,cARe;EASf;EACAY,gBAAgB,EAAhBA,gBAVe;EAWf;EACAO,WAAW,EAAXA,WAZe;EAaf;EACAC,SAAS,EAATA,SAde;EAef;EACAe,OAAO,EAAPA,OAhBe;EAiBf;EACAI,SAAS,EAATA,SAlBe;EAmBf;EACAS,SAAS,EAATA,SApBe;EAqBf;EACA7G,SAAS,EAATA,SAtBe;EAuBf4H,eAAe,EAAE5H,SAAS,CAACiH;AAvBZ,CAAjB"},"metadata":{},"sourceType":"script"}