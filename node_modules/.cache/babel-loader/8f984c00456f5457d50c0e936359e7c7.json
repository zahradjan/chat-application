{"ast":null,"code":"'use strict';\n\nconst Clock = require('./lamport-clock');\n\nconst {\n  isDefined,\n  io\n} = require('./utils');\n\nconst stringify = require('json-stringify-deterministic');\n\nconst IpfsNotDefinedError = () => new Error('Ipfs instance not defined');\n\nconst IPLD_LINKS = ['next', 'refs'];\n\nconst getWriteFormatForVersion = v => v === 0 ? 'dag-pb' : 'dag-cbor';\n\nconst getWriteFormat = e => Entry.isEntry(e) ? getWriteFormatForVersion(e.v) : getWriteFormatForVersion(e);\n/*\n * @description\n * An ipfs-log entry\n */\n\n\nclass Entry {\n  /**\n   * Create an Entry\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {string} logId The unique identifier for this log\n   * @param {*} data Data of the entry to be added. Can be any JSON.stringifyable data\n   * @param {Array<string|Entry>} [next=[]] Parent hashes or entries\n   * @param {LamportClock} [clock] The lamport clock\n   * @returns {Promise<Entry>}\n   * @example\n   * const entry = await Entry.create(ipfs, identity, 'hello')\n   * console.log(entry)\n   * // { hash: null, payload: \"hello\", next: [] }\n   */\n  static async create(ipfs, identity, logId, data) {\n    let next = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    let clock = arguments.length > 5 ? arguments[5] : undefined;\n    let refs = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n    let pin = arguments.length > 7 ? arguments[7] : undefined;\n    if (!isDefined(ipfs)) throw IpfsNotDefinedError();\n    if (!isDefined(identity)) throw new Error('Identity is required, cannot create entry');\n    if (!isDefined(logId)) throw new Error('Entry requires an id');\n    if (!isDefined(data)) throw new Error('Entry requires data');\n    if (!isDefined(next) || !Array.isArray(next)) throw new Error(\"'next' argument is not an array\"); // Clean the next objects and convert to hashes\n\n    const toEntry = e => e.hash ? e.hash : e;\n\n    const nexts = next.filter(isDefined).map(toEntry);\n    const entry = {\n      hash: null,\n      // \"zd...Foo\", we'll set the hash after persisting the entry\n      id: logId,\n      // For determining a unique chain\n      payload: data,\n      // Can be any JSON.stringifyable data\n      next: nexts,\n      // Array of hashes\n      refs: refs,\n      v: 2,\n      // To tag the version of this data structure\n      clock: clock || new Clock(identity.publicKey)\n    };\n    const signature = await identity.provider.sign(identity, Entry.toBuffer(entry));\n    entry.key = identity.publicKey;\n    entry.identity = identity.toJSON();\n    entry.sig = signature;\n    entry.hash = await Entry.toMultihash(ipfs, entry, pin);\n    return entry;\n  }\n  /**\n   * Verifies an entry signature.\n   *\n   * @param {IdentityProvider} identityProvider The identity provider to use\n   * @param {Entry} entry The entry being verified\n   * @return {Promise} A promise that resolves to a boolean value indicating if the signature is valid\n   */\n\n\n  static async verify(identityProvider, entry) {\n    if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry');\n    if (!Entry.isEntry(entry)) throw new Error('Invalid Log entry');\n    if (!entry.key) throw new Error(\"Entry doesn't have a key\");\n    if (!entry.sig) throw new Error(\"Entry doesn't have a signature\");\n    const e = Entry.toEntry(entry, {\n      presigned: true\n    });\n    const verifier = entry.v < 1 ? 'v0' : 'v1';\n    return identityProvider.verify(entry.sig, entry.key, Entry.toBuffer(e), verifier);\n  }\n  /**\n   * Transforms an entry into a Buffer.\n   * @param {Entry} entry The entry\n   * @return {Buffer} The buffer\n   */\n\n\n  static toBuffer(entry) {\n    const stringifiedEntry = entry.v === 0 ? JSON.stringify(entry) : stringify(entry);\n    return Buffer.from(stringifiedEntry);\n  }\n  /**\n   * Get the multihash of an Entry.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Entry} entry Entry to get a multihash for\n   * @returns {Promise<string>}\n   * @example\n   * const multihash = await Entry.toMultihash(ipfs, entry)\n   * console.log(multihash)\n   * // \"Qm...Foo\"\n   * @deprecated\n   */\n\n\n  static async toMultihash(ipfs, entry) {\n    let pin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!ipfs) throw IpfsNotDefinedError();\n    if (!Entry.isEntry(entry)) throw new Error('Invalid object format, cannot generate entry hash'); // // Ensure `entry` follows the correct format\n\n    const e = Entry.toEntry(entry);\n    return io.write(ipfs, getWriteFormat(e.v), e, {\n      links: IPLD_LINKS,\n      pin\n    });\n  }\n\n  static toEntry(entry) {\n    let {\n      presigned = false,\n      includeHash = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const e = {\n      hash: includeHash ? entry.hash : null,\n      id: entry.id,\n      payload: entry.payload,\n      next: entry.next\n    };\n    const v = entry.v;\n\n    if (v > 1) {\n      e.refs = entry.refs; // added in v2\n    }\n\n    e.v = entry.v;\n    e.clock = new Clock(entry.clock.id, entry.clock.time);\n\n    if (presigned) {\n      return e; // don't include key/sig information\n    }\n\n    e.key = entry.key;\n\n    if (v > 0) {\n      e.identity = entry.identity; // added in v1\n    }\n\n    e.sig = entry.sig;\n    return e;\n  }\n  /**\n   * Create an Entry from a hash.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {string} hash The hash to create an Entry from\n   * @returns {Promise<Entry>}\n   * @example\n   * const entry = await Entry.fromMultihash(ipfs, \"zd...Foo\")\n   * console.log(entry)\n   * // { hash: \"Zd...Foo\", payload: \"hello\", next: [] }\n   */\n\n\n  static async fromMultihash(ipfs, hash) {\n    if (!ipfs) throw IpfsNotDefinedError();\n    if (!hash) throw new Error(`Invalid hash: ${hash}`);\n    const e = await io.read(ipfs, hash, {\n      links: IPLD_LINKS\n    });\n    const entry = Entry.toEntry(e);\n    entry.hash = hash;\n    return entry;\n  }\n  /**\n   * Check if an object is an Entry.\n   * @param {Entry} obj\n   * @returns {boolean}\n   */\n\n\n  static isEntry(obj) {\n    return obj && obj.id !== undefined && obj.next !== undefined && obj.payload !== undefined && obj.v !== undefined && obj.hash !== undefined && obj.clock !== undefined && (obj.refs !== undefined || obj.v < 2); // 'refs' added in v2\n  }\n  /**\n   * Compares two entries.\n   * @param {Entry} a\n   * @param {Entry} b\n   * @returns {number} 1 if a is greater, -1 is b is greater\n   */\n\n\n  static compare(a, b) {\n    const distance = Clock.compare(a.clock, b.clock);\n    if (distance === 0) return a.clock.id < b.clock.id ? -1 : 1;\n    return distance;\n  }\n  /**\n   * Check if an entry equals another entry.\n   * @param {Entry} a\n   * @param {Entry} b\n   * @returns {boolean}\n   */\n\n\n  static isEqual(a, b) {\n    return a.hash === b.hash;\n  }\n  /**\n   * Check if an entry is a parent to another entry.\n   * @param {Entry} entry1 Entry to check\n   * @param {Entry} entry2 The parent Entry\n   * @returns {boolean}\n   */\n\n\n  static isParent(entry1, entry2) {\n    return entry2.next.indexOf(entry1.hash) > -1;\n  }\n  /**\n   * Find entry's children from an Array of entries.\n   * Returns entry's children as an Array up to the last know child.\n   * @param {Entry} entry Entry for which to find the parents\n   * @param {Array<Entry>} values Entries to search parents from\n   * @returns {Array<Entry>}\n   */\n\n\n  static findChildren(entry, values) {\n    let stack = [];\n    let parent = values.find(e => Entry.isParent(entry, e));\n    let prev = entry;\n\n    while (parent) {\n      stack.push(parent);\n      prev = parent;\n      parent = values.find(e => Entry.isParent(prev, e));\n    }\n\n    stack = stack.sort((a, b) => a.clock.time > b.clock.time);\n    return stack;\n  }\n\n}\n\nmodule.exports = Entry;\nmodule.exports.IPLD_LINKS = IPLD_LINKS;\nmodule.exports.getWriteFormat = getWriteFormat;","map":{"version":3,"names":["Clock","require","isDefined","io","stringify","IpfsNotDefinedError","Error","IPLD_LINKS","getWriteFormatForVersion","v","getWriteFormat","e","Entry","isEntry","create","ipfs","identity","logId","data","next","clock","refs","pin","Array","isArray","toEntry","hash","nexts","filter","map","entry","id","payload","publicKey","signature","provider","sign","toBuffer","key","toJSON","sig","toMultihash","verify","identityProvider","presigned","verifier","stringifiedEntry","JSON","Buffer","from","write","links","includeHash","time","fromMultihash","read","obj","undefined","compare","a","b","distance","isEqual","isParent","entry1","entry2","indexOf","findChildren","values","stack","parent","find","prev","push","sort","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-log/src/entry.js"],"sourcesContent":["'use strict'\n\nconst Clock = require('./lamport-clock')\nconst { isDefined, io } = require('./utils')\nconst stringify = require('json-stringify-deterministic')\nconst IpfsNotDefinedError = () => new Error('Ipfs instance not defined')\nconst IPLD_LINKS = ['next', 'refs']\nconst getWriteFormatForVersion = v => v === 0 ? 'dag-pb' : 'dag-cbor'\nconst getWriteFormat = e => Entry.isEntry(e) ? getWriteFormatForVersion(e.v) : getWriteFormatForVersion(e)\n\n/*\n * @description\n * An ipfs-log entry\n */\nclass Entry {\n  /**\n   * Create an Entry\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {string} logId The unique identifier for this log\n   * @param {*} data Data of the entry to be added. Can be any JSON.stringifyable data\n   * @param {Array<string|Entry>} [next=[]] Parent hashes or entries\n   * @param {LamportClock} [clock] The lamport clock\n   * @returns {Promise<Entry>}\n   * @example\n   * const entry = await Entry.create(ipfs, identity, 'hello')\n   * console.log(entry)\n   * // { hash: null, payload: \"hello\", next: [] }\n   */\n  static async create (ipfs, identity, logId, data, next = [], clock, refs = [], pin) {\n    if (!isDefined(ipfs)) throw IpfsNotDefinedError()\n    if (!isDefined(identity)) throw new Error('Identity is required, cannot create entry')\n    if (!isDefined(logId)) throw new Error('Entry requires an id')\n    if (!isDefined(data)) throw new Error('Entry requires data')\n    if (!isDefined(next) || !Array.isArray(next)) throw new Error(\"'next' argument is not an array\")\n\n    // Clean the next objects and convert to hashes\n    const toEntry = (e) => e.hash ? e.hash : e\n    const nexts = next.filter(isDefined).map(toEntry)\n\n    const entry = {\n      hash: null, // \"zd...Foo\", we'll set the hash after persisting the entry\n      id: logId, // For determining a unique chain\n      payload: data, // Can be any JSON.stringifyable data\n      next: nexts, // Array of hashes\n      refs: refs,\n      v: 2, // To tag the version of this data structure\n      clock: clock || new Clock(identity.publicKey)\n    }\n\n    const signature = await identity.provider.sign(identity, Entry.toBuffer(entry))\n\n    entry.key = identity.publicKey\n    entry.identity = identity.toJSON()\n    entry.sig = signature\n    entry.hash = await Entry.toMultihash(ipfs, entry, pin)\n\n    return entry\n  }\n\n  /**\n   * Verifies an entry signature.\n   *\n   * @param {IdentityProvider} identityProvider The identity provider to use\n   * @param {Entry} entry The entry being verified\n   * @return {Promise} A promise that resolves to a boolean value indicating if the signature is valid\n   */\n  static async verify (identityProvider, entry) {\n    if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry')\n    if (!Entry.isEntry(entry)) throw new Error('Invalid Log entry')\n    if (!entry.key) throw new Error(\"Entry doesn't have a key\")\n    if (!entry.sig) throw new Error(\"Entry doesn't have a signature\")\n\n    const e = Entry.toEntry(entry, { presigned: true })\n    const verifier = entry.v < 1 ? 'v0' : 'v1'\n    return identityProvider.verify(entry.sig, entry.key, Entry.toBuffer(e), verifier)\n  }\n\n  /**\n   * Transforms an entry into a Buffer.\n   * @param {Entry} entry The entry\n   * @return {Buffer} The buffer\n   */\n  static toBuffer (entry) {\n    const stringifiedEntry = entry.v === 0 ? JSON.stringify(entry) : stringify(entry)\n    return Buffer.from(stringifiedEntry)\n  }\n\n  /**\n   * Get the multihash of an Entry.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Entry} entry Entry to get a multihash for\n   * @returns {Promise<string>}\n   * @example\n   * const multihash = await Entry.toMultihash(ipfs, entry)\n   * console.log(multihash)\n   * // \"Qm...Foo\"\n   * @deprecated\n   */\n  static async toMultihash (ipfs, entry, pin = false) {\n    if (!ipfs) throw IpfsNotDefinedError()\n    if (!Entry.isEntry(entry)) throw new Error('Invalid object format, cannot generate entry hash')\n\n    // // Ensure `entry` follows the correct format\n    const e = Entry.toEntry(entry)\n    return io.write(ipfs, getWriteFormat(e.v), e, { links: IPLD_LINKS, pin })\n  }\n\n  static toEntry (entry, { presigned = false, includeHash = false } = {}) {\n    const e = {\n      hash: includeHash ? entry.hash : null,\n      id: entry.id,\n      payload: entry.payload,\n      next: entry.next\n    }\n\n    const v = entry.v\n    if (v > 1) {\n      e.refs = entry.refs // added in v2\n    }\n    e.v = entry.v\n    e.clock = new Clock(entry.clock.id, entry.clock.time)\n\n    if (presigned) {\n      return e // don't include key/sig information\n    }\n\n    e.key = entry.key\n    if (v > 0) {\n      e.identity = entry.identity // added in v1\n    }\n    e.sig = entry.sig\n    return e\n  }\n\n  /**\n   * Create an Entry from a hash.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {string} hash The hash to create an Entry from\n   * @returns {Promise<Entry>}\n   * @example\n   * const entry = await Entry.fromMultihash(ipfs, \"zd...Foo\")\n   * console.log(entry)\n   * // { hash: \"Zd...Foo\", payload: \"hello\", next: [] }\n   */\n  static async fromMultihash (ipfs, hash) {\n    if (!ipfs) throw IpfsNotDefinedError()\n    if (!hash) throw new Error(`Invalid hash: ${hash}`)\n    const e = await io.read(ipfs, hash, { links: IPLD_LINKS })\n\n    const entry = Entry.toEntry(e)\n    entry.hash = hash\n\n    return entry\n  }\n\n  /**\n   * Check if an object is an Entry.\n   * @param {Entry} obj\n   * @returns {boolean}\n   */\n  static isEntry (obj) {\n    return obj && obj.id !== undefined &&\n      obj.next !== undefined &&\n      obj.payload !== undefined &&\n      obj.v !== undefined &&\n      obj.hash !== undefined &&\n      obj.clock !== undefined &&\n      (obj.refs !== undefined || obj.v < 2) // 'refs' added in v2\n  }\n\n  /**\n   * Compares two entries.\n   * @param {Entry} a\n   * @param {Entry} b\n   * @returns {number} 1 if a is greater, -1 is b is greater\n   */\n  static compare (a, b) {\n    const distance = Clock.compare(a.clock, b.clock)\n    if (distance === 0) return a.clock.id < b.clock.id ? -1 : 1\n    return distance\n  }\n\n  /**\n   * Check if an entry equals another entry.\n   * @param {Entry} a\n   * @param {Entry} b\n   * @returns {boolean}\n   */\n  static isEqual (a, b) {\n    return a.hash === b.hash\n  }\n\n  /**\n   * Check if an entry is a parent to another entry.\n   * @param {Entry} entry1 Entry to check\n   * @param {Entry} entry2 The parent Entry\n   * @returns {boolean}\n   */\n  static isParent (entry1, entry2) {\n    return entry2.next.indexOf(entry1.hash) > -1\n  }\n\n  /**\n   * Find entry's children from an Array of entries.\n   * Returns entry's children as an Array up to the last know child.\n   * @param {Entry} entry Entry for which to find the parents\n   * @param {Array<Entry>} values Entries to search parents from\n   * @returns {Array<Entry>}\n   */\n  static findChildren (entry, values) {\n    let stack = []\n    let parent = values.find((e) => Entry.isParent(entry, e))\n    let prev = entry\n    while (parent) {\n      stack.push(parent)\n      prev = parent\n      parent = values.find((e) => Entry.isParent(prev, e))\n    }\n    stack = stack.sort((a, b) => a.clock.time > b.clock.time)\n    return stack\n  }\n}\n\nmodule.exports = Entry\nmodule.exports.IPLD_LINKS = IPLD_LINKS\nmodule.exports.getWriteFormat = getWriteFormat\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}