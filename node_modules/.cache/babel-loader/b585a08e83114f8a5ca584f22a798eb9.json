{"ast":null,"code":"const getIterator = require('get-iterator');\n\nmodule.exports = writable => async source => {\n  source = getIterator(source);\n\n  const maybeEndSource = source => {\n    if (typeof source.return === 'function') source.return();\n  };\n\n  let error = null;\n  let errCb = null;\n\n  const errorHandler = err => {\n    error = err;\n    if (errCb) errCb(err); // When the writable errors, try to end the source to exit iteration early\n\n    maybeEndSource(source);\n  };\n\n  let closeCb = null;\n  let closed = false;\n\n  const closeHandler = () => {\n    closed = true;\n    if (closeCb) closeCb();\n  };\n\n  let finishCb = null;\n  let finished = false;\n\n  const finishHandler = () => {\n    finished = true;\n    if (finishCb) finishCb();\n  };\n\n  let drainCb = null;\n\n  const drainHandler = () => {\n    if (drainCb) drainCb();\n  };\n\n  const waitForDrainOrClose = () => {\n    return new Promise((resolve, reject) => {\n      closeCb = drainCb = resolve;\n      errCb = reject;\n      writable.once('drain', drainHandler);\n    });\n  };\n\n  const waitForDone = () => {\n    // Immediately try to end the source\n    maybeEndSource(source);\n    return new Promise((resolve, reject) => {\n      if (closed || finished || error) return resolve();\n      finishCb = closeCb = resolve;\n      errCb = reject;\n    });\n  };\n\n  const cleanup = () => {\n    writable.removeListener('error', errorHandler);\n    writable.removeListener('close', closeHandler);\n    writable.removeListener('finish', finishHandler);\n    writable.removeListener('drain', drainHandler);\n  };\n\n  writable.once('error', errorHandler);\n  writable.once('close', closeHandler);\n  writable.once('finish', finishHandler);\n\n  try {\n    for await (const value of source) {\n      if (!writable.writable || writable.destroyed || error) break;\n\n      if (writable.write(value) === false) {\n        await waitForDrainOrClose();\n      }\n    }\n  } catch (err) {\n    // error is set by stream error handler so only destroy stream if source threw\n    if (!error) {\n      writable.destroy();\n    } // could we be obscuring an error here?\n\n\n    error = err;\n  }\n\n  try {\n    // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)\n    if (writable.writable) {\n      writable.end();\n    } // Wait until we close or finish. This supports halfClosed streams\n\n\n    await waitForDone(); // Notify the user an error occurred\n\n    if (error) throw error;\n  } finally {\n    // Clean up listeners\n    cleanup();\n  }\n};","map":{"version":3,"names":["getIterator","require","module","exports","writable","source","maybeEndSource","return","error","errCb","errorHandler","err","closeCb","closed","closeHandler","finishCb","finished","finishHandler","drainCb","drainHandler","waitForDrainOrClose","Promise","resolve","reject","once","waitForDone","cleanup","removeListener","value","destroyed","write","destroy","end"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/stream-to-it/sink.js"],"sourcesContent":["const getIterator = require('get-iterator')\n\nmodule.exports = writable => async source => {\n  source = getIterator(source)\n\n  const maybeEndSource = (source) => {\n    if (typeof source.return === 'function') source.return()\n  }\n\n  let error = null\n  let errCb = null\n  const errorHandler = (err) => {\n    error = err\n    if (errCb) errCb(err)\n    // When the writable errors, try to end the source to exit iteration early\n    maybeEndSource(source)\n  }\n\n  let closeCb = null\n  let closed = false\n  const closeHandler = () => {\n    closed = true\n    if (closeCb) closeCb()\n  }\n\n  let finishCb = null\n  let finished = false\n  const finishHandler = () => {\n    finished = true\n    if (finishCb) finishCb()\n  }\n\n  let drainCb = null\n  const drainHandler = () => {\n    if (drainCb) drainCb()\n  }\n\n  const waitForDrainOrClose = () => {\n    return new Promise((resolve, reject) => {\n      closeCb = drainCb = resolve\n      errCb = reject\n      writable.once('drain', drainHandler)\n    })\n  }\n\n  const waitForDone = () => {\n    // Immediately try to end the source\n    maybeEndSource(source)\n    return new Promise((resolve, reject) => {\n      if (closed || finished || error) return resolve()\n      finishCb = closeCb = resolve\n      errCb = reject\n    })\n  }\n\n  const cleanup = () => {\n    writable.removeListener('error', errorHandler)\n    writable.removeListener('close', closeHandler)\n    writable.removeListener('finish', finishHandler)\n    writable.removeListener('drain', drainHandler)\n  }\n\n  writable.once('error', errorHandler)\n  writable.once('close', closeHandler)\n  writable.once('finish', finishHandler)\n\n  try {\n    for await (const value of source) {\n      if (!writable.writable || writable.destroyed || error) break\n\n      if (writable.write(value) === false) {\n        await waitForDrainOrClose()\n      }\n    }\n  } catch (err) {\n    // error is set by stream error handler so only destroy stream if source threw\n    if (!error) {\n      writable.destroy()\n    }\n\n    // could we be obscuring an error here?\n    error = err\n  }\n\n  try {\n    // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)\n    if (writable.writable) {\n      writable.end()\n    }\n\n    // Wait until we close or finish. This supports halfClosed streams\n    await waitForDone()\n\n    // Notify the user an error occurred\n    if (error) throw error\n  } finally {\n    // Clean up listeners\n    cleanup()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}