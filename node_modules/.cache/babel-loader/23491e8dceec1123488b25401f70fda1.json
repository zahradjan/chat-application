{"ast":null,"code":"'use strict';\n\nconst createLock = require('./utils/create-lock');\n\nconst isIpfs = require('is-ipfs');\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('ipfs-core-utils/src/multihashes')} Multihashes\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n *\n * @typedef {object} MfsContext\n * @property {IPFSRepo} repo\n * @property {Multihashes} hashers\n */\n\n/**\n * These operations are read-locked at the function level and will execute simultaneously\n *\n * @type {Record<string, any>}\n */\n\n\nconst readOperations = {\n  stat: require('./stat')\n};\n/**\n * These operations are locked at the function level and will execute in series\n *\n * @type {Record<string, any>}\n */\n\nconst writeOperations = {\n  chmod: require('./chmod'),\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm'),\n  touch: require('./touch')\n};\n/**\n * These operations are asynchronous and manage their own locking\n *\n * @type {Record<string, any>}\n */\n\nconst unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n};\n/**\n * @param {object} arg\n * @param {MfsContext} arg.options\n * @param {*} arg.mfs\n * @param {*} arg.operations\n * @param {*} arg.lock\n */\n\nconst wrap = _ref => {\n  let {\n    options,\n    mfs,\n    operations,\n    lock\n  } = _ref;\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options));\n  });\n};\n\nconst defaultOptions = {\n  repoOwner: true,\n  repo: null\n};\n/**\n * @param {object} options\n * @param {IPFSRepo} options.repo\n * @param {boolean} options.repoOwner\n * @param {Multihashes} options.hashers\n */\n\nfunction createMfs(options) {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options);\n  const lock = createLock(repoOwner);\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n\n  const readLock = operation => {\n    return lock.readLock(operation);\n  };\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n\n\n  const writeLock = operation => {\n    return lock.writeLock(operation);\n  };\n  /** @type {Record<string, any>} */\n\n\n  const mfs = {};\n  wrap({\n    options,\n    mfs,\n    operations: readOperations,\n    lock: readLock\n  });\n  wrap({\n    options,\n    mfs,\n    operations: writeOperations,\n    lock: writeLock\n  });\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options);\n  });\n  return mfs;\n}\n/**\n * @param {object} context\n * @param {IPFSRepo} context.repo\n * @param {import('../../types').Preload} context.preload\n * @param {import('..').Options} context.options\n * @param {Multihashes} context.hashers\n * @returns {import('ipfs-core-types/src/files').API}\n */\n\n\nmodule.exports = _ref2 => {\n  let {\n    repo,\n    preload,\n    hashers,\n    options: constructorOptions\n  } = _ref2;\n  const methods = createMfs({\n    repo,\n    repoOwner: Boolean(constructorOptions.repoOwner),\n    hashers\n  });\n  /**\n   * @param {any} fn\n   */\n\n  const withPreload = fn => {\n    /**\n     * @param  {...any} args\n     */\n    const wrapped = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // @ts-ignore cannot derive type of arg\n      const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg));\n\n      if (paths.length) {\n        const options = args[args.length - 1]; // @ts-ignore it's a PreloadOptions, honest\n\n        if (options && options.preload !== false) {\n          paths.forEach(path => preload(path));\n        }\n      }\n\n      return fn(...args);\n    };\n\n    return wrapped;\n  };\n\n  return { ...methods,\n    chmod: methods.chmod,\n    cp: withPreload(methods.cp),\n    mkdir: methods.mkdir,\n    stat: withPreload(methods.stat),\n    rm: methods.rm,\n    read: withPreload(methods.read),\n    touch: methods.touch,\n    write: methods.write,\n    mv: withPreload(methods.mv),\n    flush: methods.flush,\n    ls: withPreload(async function* () {\n      for await (const file of methods.ls(...arguments)) {\n        yield { ...file,\n          size: file.size || 0\n        };\n      }\n    })\n  };\n};","map":{"version":3,"names":["createLock","require","isIpfs","readOperations","stat","writeOperations","chmod","cp","flush","mkdir","mv","rm","touch","unwrappedOperations","write","read","ls","wrap","options","mfs","operations","lock","Object","keys","forEach","key","defaultOptions","repoOwner","repo","createMfs","assign","readLock","operation","writeLock","module","exports","preload","hashers","constructorOptions","methods","Boolean","withPreload","fn","wrapped","args","paths","filter","arg","ipfsPath","cid","length","path","file","size"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/index.js"],"sourcesContent":["'use strict'\n\nconst createLock = require('./utils/create-lock')\nconst isIpfs = require('is-ipfs')\n\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('ipfs-core-utils/src/multihashes')} Multihashes\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n *\n * @typedef {object} MfsContext\n * @property {IPFSRepo} repo\n * @property {Multihashes} hashers\n */\n\n/**\n * These operations are read-locked at the function level and will execute simultaneously\n *\n * @type {Record<string, any>}\n */\nconst readOperations = {\n  stat: require('./stat')\n}\n\n/**\n * These operations are locked at the function level and will execute in series\n *\n * @type {Record<string, any>}\n */\nconst writeOperations = {\n  chmod: require('./chmod'),\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm'),\n  touch: require('./touch')\n}\n\n/**\n * These operations are asynchronous and manage their own locking\n *\n * @type {Record<string, any>}\n */\nconst unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n}\n\n/**\n * @param {object} arg\n * @param {MfsContext} arg.options\n * @param {*} arg.mfs\n * @param {*} arg.operations\n * @param {*} arg.lock\n */\nconst wrap = ({\n  options, mfs, operations, lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options))\n  })\n}\n\nconst defaultOptions = {\n  repoOwner: true,\n  repo: null\n}\n\n/**\n * @param {object} options\n * @param {IPFSRepo} options.repo\n * @param {boolean} options.repoOwner\n * @param {Multihashes} options.hashers\n */\nfunction createMfs (options) {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options)\n\n  const lock = createLock(repoOwner)\n\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n  const readLock = (operation) => {\n    return lock.readLock(operation)\n  }\n\n  /**\n   * @param {(fn: (...args: any) => any) => (...args: any) => any} operation\n   */\n  const writeLock = (operation) => {\n    return lock.writeLock(operation)\n  }\n\n  /** @type {Record<string, any>} */\n  const mfs = {}\n\n  wrap({\n    options, mfs, operations: readOperations, lock: readLock\n  })\n  wrap({\n    options, mfs, operations: writeOperations, lock: writeLock\n  })\n\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options)\n  })\n\n  return mfs\n}\n\n/**\n * @param {object} context\n * @param {IPFSRepo} context.repo\n * @param {import('../../types').Preload} context.preload\n * @param {import('..').Options} context.options\n * @param {Multihashes} context.hashers\n * @returns {import('ipfs-core-types/src/files').API}\n */\nmodule.exports = ({ repo, preload, hashers, options: constructorOptions }) => {\n  const methods = createMfs({\n    repo,\n    repoOwner: Boolean(constructorOptions.repoOwner),\n    hashers\n  })\n\n  /**\n   * @param {any} fn\n   */\n  const withPreload = fn => {\n    /**\n     * @param  {...any} args\n     */\n    const wrapped = (...args) => {\n      // @ts-ignore cannot derive type of arg\n      const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg))\n\n      if (paths.length) {\n        const options = args[args.length - 1]\n        // @ts-ignore it's a PreloadOptions, honest\n        if (options && options.preload !== false) {\n          paths.forEach(path => preload(path))\n        }\n      }\n\n      return fn(...args)\n    }\n\n    return wrapped\n  }\n\n  return {\n    ...methods,\n    chmod: methods.chmod,\n    cp: withPreload(methods.cp),\n    mkdir: methods.mkdir,\n    stat: withPreload(methods.stat),\n    rm: methods.rm,\n    read: withPreload(methods.read),\n    touch: methods.touch,\n    write: methods.write,\n    mv: withPreload(methods.mv),\n    flush: methods.flush,\n    ls: withPreload(async function * (/** @type {...any} */ ...args) {\n      for await (const file of methods.ls(...args)) {\n        yield { ...file, size: file.size || 0 }\n      }\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}