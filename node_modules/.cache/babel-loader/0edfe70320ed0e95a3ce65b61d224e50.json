{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst {\n  nanoid\n} = require('nanoid');\n\nconst {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK\n} = require('./constants');\n\nlet cluster;\n\nconst handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {\n  return (worker, requestEvent) => {\n    if (requestEvent && requestEvent.type === requestType) {\n      emitter.emit(masterEvent, requestEvent.name, () => {\n        // grant lock to worker\n        worker.send({\n          type: grantType,\n          name: requestEvent.name,\n          identifier: requestEvent.identifier\n        }); // wait for worker to finish\n\n        return new Promise(resolve => {\n          const releaseEventListener = releaseEvent => {\n            if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n              worker.removeListener('message', releaseEventListener);\n              resolve();\n            }\n          };\n\n          worker.on('message', releaseEventListener);\n        });\n      });\n    }\n  };\n};\n\nconst makeWorkerLockRequest = (name, requestType, grantType, releaseType) => {\n  return () => {\n    const id = nanoid();\n    process.send({\n      type: requestType,\n      identifier: id,\n      name\n    });\n    return new Promise(resolve => {\n      const listener = event => {\n        if (event && event.type === grantType && event.identifier === id) {\n          process.removeListener('message', listener); // grant lock\n\n          resolve(() => {\n            // release lock\n            process.send({\n              type: releaseType,\n              identifier: id,\n              name\n            });\n          });\n        }\n      };\n\n      process.on('message', listener);\n    });\n  };\n};\n\nmodule.exports = options => {\n  try {\n    cluster = require('cluster');\n\n    if (!Object.keys(cluster).length) {\n      return;\n    }\n  } catch (_) {\n    return;\n  }\n\n  if (cluster.isMaster || options.singleProcess) {\n    const emitter = new EventEmitter();\n    cluster.on('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));\n    cluster.on('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));\n    return emitter;\n  }\n\n  return {\n    isWorker: true,\n    readLock: name => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),\n    writeLock: name => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)\n  };\n};","map":{"version":3,"names":["EventEmitter","require","nanoid","WORKER_REQUEST_READ_LOCK","WORKER_RELEASE_READ_LOCK","MASTER_GRANT_READ_LOCK","WORKER_REQUEST_WRITE_LOCK","WORKER_RELEASE_WRITE_LOCK","MASTER_GRANT_WRITE_LOCK","cluster","handleWorkerLockRequest","emitter","masterEvent","requestType","releaseType","grantType","worker","requestEvent","type","emit","name","send","identifier","Promise","resolve","releaseEventListener","releaseEvent","removeListener","on","makeWorkerLockRequest","id","process","listener","event","module","exports","options","Object","keys","length","_","isMaster","singleProcess","isWorker","readLock","writeLock"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/mortice/lib/node.js"],"sourcesContent":["const EventEmitter = require('events').EventEmitter\nconst { nanoid } = require('nanoid')\nconst {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK\n} = require('./constants')\nlet cluster\n\nconst handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {\n  return (worker, requestEvent) => {\n    if (requestEvent && requestEvent.type === requestType) {\n      emitter.emit(masterEvent, requestEvent.name, () => {\n        // grant lock to worker\n        worker.send({\n          type: grantType,\n          name: requestEvent.name,\n          identifier: requestEvent.identifier\n        })\n\n        // wait for worker to finish\n        return new Promise((resolve) => {\n          const releaseEventListener = (releaseEvent) => {\n            if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n              worker.removeListener('message', releaseEventListener)\n              resolve()\n            }\n          }\n\n          worker.on('message', releaseEventListener)\n        })\n      })\n    }\n  }\n}\n\nconst makeWorkerLockRequest = (name, requestType, grantType, releaseType) => {\n  return () => {\n    const id = nanoid()\n\n    process.send({\n      type: requestType,\n      identifier: id,\n      name\n    })\n\n    return new Promise((resolve) => {\n      const listener = (event) => {\n        if (event && event.type === grantType && event.identifier === id) {\n          process.removeListener('message', listener)\n\n          // grant lock\n          resolve(() => {\n            // release lock\n            process.send({\n              type: releaseType,\n              identifier: id,\n              name\n            })\n          })\n        }\n      }\n\n      process.on('message', listener)\n    })\n  }\n}\n\nmodule.exports = (options) => {\n  try {\n    cluster = require('cluster')\n\n    if (!Object.keys(cluster).length) {\n      return\n    }\n  } catch (_) {\n    return\n  }\n\n  if (cluster.isMaster || options.singleProcess) {\n    const emitter = new EventEmitter()\n\n    cluster.on('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK))\n    cluster.on('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK))\n\n    return emitter\n  }\n\n  return {\n    isWorker: true,\n    readLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),\n    writeLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}