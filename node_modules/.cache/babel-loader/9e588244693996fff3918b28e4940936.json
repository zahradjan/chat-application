{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar PeerId = require('peer-id');\n\nvar _require = require('multiaddr'),\n    Multiaddr = _require.Multiaddr;\n\nvar errCode = require('err-code');\n\nvar _require2 = require('./status'),\n    OPEN = _require2.OPEN,\n    CLOSING = _require2.CLOSING,\n    CLOSED = _require2.CLOSED;\n\nvar connectionSymbol = Symbol.for('@libp2p/interface-connection/connection');\n/**\n * @typedef {import('../stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('./status').Status} Status\n */\n\n/**\n * @typedef {Object} Timeline\n * @property {number} open - connection opening timestamp.\n * @property {number} [upgraded] - connection upgraded timestamp.\n * @property {number} [close]\n *\n * @typedef {Object} ConectionStat\n * @property {'inbound' | 'outbound'} direction - connection establishment direction\n * @property {Timeline} timeline - connection relevant events timestamp.\n * @property {string} [multiplexer] - connection multiplexing identifier.\n * @property {string} [encryption] - connection encryption method identifier.\n *\n * @typedef {(protocols: string|string[]) => Promise<{stream: MuxedStream, protocol: string}>} CreatedMuxedStream\n *\n * @typedef {Object} ConnectionOptions\n * @property {Multiaddr} [localAddr] - local multiaddr of the connection if known.\n * @property {Multiaddr} remoteAddr - remote multiaddr of the connection.\n * @property {PeerId} localPeer - local peer-id.\n * @property {PeerId} remotePeer - remote peer-id.\n * @property {CreatedMuxedStream} newStream - new stream muxer function.\n * @property {() => Promise<void>} close - close raw connection function.\n * @property {() => MuxedStream[]} getStreams - get streams from muxer function.\n * @property {ConectionStat} stat - metadata of the connection.\n *\n * @typedef {Object} StreamData\n * @property {string} protocol - the protocol used by the stream\n * @property {Object} [metadata] - metadata of the stream\n */\n\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\n\nvar Connection = /*#__PURE__*/function (_Symbol$toStringTag) {\n  /**\n   * An implementation of the js-libp2p connection.\n   * Any libp2p transport should use an upgrader to return this connection.\n   *\n   * @class\n   * @param {ConnectionOptions} options\n   */\n  function Connection(_ref) {\n    var localAddr = _ref.localAddr,\n        remoteAddr = _ref.remoteAddr,\n        localPeer = _ref.localPeer,\n        remotePeer = _ref.remotePeer,\n        newStream = _ref.newStream,\n        close = _ref.close,\n        getStreams = _ref.getStreams,\n        stat = _ref.stat;\n\n    _classCallCheck(this, Connection);\n\n    validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat);\n    /**\n     * Connection identifier.\n     */\n\n    this.id = parseInt(String(Math.random() * 1e9)).toString(36) + Date.now();\n    /**\n     * Observed multiaddr of the local peer\n     */\n\n    this.localAddr = localAddr;\n    /**\n     * Observed multiaddr of the remote peer\n     */\n\n    this.remoteAddr = remoteAddr;\n    /**\n     * Local peer id.\n     */\n\n    this.localPeer = localPeer;\n    /**\n     * Remote peer id.\n     */\n\n    this.remotePeer = remotePeer;\n    /**\n     * Connection metadata.\n     *\n     * @type {ConectionStat & {status: Status}}\n     */\n\n    this._stat = _objectSpread(_objectSpread({}, stat), {}, {\n      status: OPEN\n    });\n    /**\n     * Reference to the new stream function of the multiplexer\n     */\n\n    this._newStream = newStream;\n    /**\n     * Reference to the close function of the raw connection\n     */\n\n    this._close = close;\n    /**\n     * Reference to the getStreams function of the muxer\n     */\n\n    this._getStreams = getStreams;\n    /**\n     * Connection streams registry\n     */\n\n    this.registry = new Map();\n    /**\n     * User provided tags\n     *\n     * @type {string[]}\n     */\n\n    this.tags = [];\n  }\n\n  _createClass(Connection, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'Connection';\n    }\n  }, {\n    key: connectionSymbol,\n    get: function get() {\n      return true;\n    }\n    /**\n     * Checks if the given value is a `Connection` instance.\n     *\n     * @param {any} other\n     * @returns {other is Connection}\n     */\n\n  }, {\n    key: \"stat\",\n    get:\n    /**\n     * Get connection metadata\n     *\n     * @this {Connection}\n     */\n    function get() {\n      return this._stat;\n    }\n    /**\n     * Get all the streams of the muxer.\n     *\n     * @this {Connection}\n     */\n\n  }, {\n    key: \"streams\",\n    get: function get() {\n      return this._getStreams();\n    }\n    /**\n     * Create a new stream from this connection\n     *\n     * @param {string|string[]} protocols - intended protocol for the stream\n     * @returns {Promise<{stream: MuxedStream, protocol: string}>} with muxed+multistream-selected stream and selected protocol\n     */\n\n  }, {\n    key: \"newStream\",\n    value: function () {\n      var _newStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(protocols) {\n        var _yield$this$_newStrea, stream, protocol;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.stat.status === CLOSING)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED');\n\n              case 2:\n                if (!(this.stat.status === CLOSED)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw errCode(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED');\n\n              case 4:\n                if (!Array.isArray(protocols)) protocols = [protocols];\n                _context.next = 7;\n                return this._newStream(protocols);\n\n              case 7:\n                _yield$this$_newStrea = _context.sent;\n                stream = _yield$this$_newStrea.stream;\n                protocol = _yield$this$_newStrea.protocol;\n                this.addStream(stream, {\n                  protocol: protocol\n                });\n                return _context.abrupt(\"return\", {\n                  stream: stream,\n                  protocol: protocol\n                });\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function newStream(_x) {\n        return _newStream.apply(this, arguments);\n      }\n\n      return newStream;\n    }()\n    /**\n     * Add a stream when it is opened to the registry.\n     *\n     * @param {MuxedStream} muxedStream - a muxed stream\n     * @param {StreamData} data - the stream data to be registered\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addStream\",\n    value: function addStream(muxedStream, _ref2) {\n      var protocol = _ref2.protocol,\n          _ref2$metadata = _ref2.metadata,\n          metadata = _ref2$metadata === void 0 ? {} : _ref2$metadata;\n      // Add metadata for the stream\n      this.registry.set(muxedStream.id, _objectSpread({\n        protocol: protocol\n      }, metadata));\n    }\n    /**\n     * Remove stream registry after it is closed.\n     *\n     * @param {string} id - identifier of the stream\n     */\n\n  }, {\n    key: \"removeStream\",\n    value: function removeStream(id) {\n      this.registry.delete(id);\n    }\n    /**\n     * Close the connection.\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.stat.status === CLOSED)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                if (!this._closing) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this._closing);\n\n              case 4:\n                this.stat.status = CLOSING; // Close raw connection\n\n                _context2.next = 7;\n                return this._close();\n\n              case 7:\n                this._closing = _context2.sent;\n                this._stat.timeline.close = Date.now();\n                this.stat.status = CLOSED;\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }], [{\n    key: \"isConnection\",\n    value: function isConnection(other) {\n      return Boolean(other && other[connectionSymbol]);\n    }\n  }]);\n\n  return Connection;\n}(Symbol.toStringTag);\n\nmodule.exports = Connection;\n/**\n * @param {Multiaddr|undefined} localAddr\n * @param {PeerId} localPeer\n * @param {PeerId} remotePeer\n * @param {(protocols: string | string[]) => Promise<{ stream: import(\"../stream-muxer/types\").MuxedStream; protocol: string; }>} newStream\n * @param {() => Promise<void>} close\n * @param {() => import(\"../stream-muxer/types\").MuxedStream[]} getStreams\n * @param {{ direction: any; timeline: any; multiplexer?: string | undefined; encryption?: string | undefined; }} stat\n */\n\nfunction validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat) {\n  if (localAddr && !Multiaddr.isMultiaddr(localAddr)) {\n    throw errCode(new Error('localAddr must be an instance of multiaddr'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!PeerId.isPeerId(localPeer)) {\n    throw errCode(new Error('localPeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!PeerId.isPeerId(remotePeer)) {\n    throw errCode(new Error('remotePeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (typeof newStream !== 'function') {\n    throw errCode(new Error('new stream must be a function'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (typeof close !== 'function') {\n    throw errCode(new Error('close must be a function'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (typeof getStreams !== 'function') {\n    throw errCode(new Error('getStreams must be a function'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat) {\n    throw errCode(new Error('connection metadata object must be provided'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (stat.direction !== 'inbound' && stat.direction !== 'outbound') {\n    throw errCode(new Error('direction must be \"inbound\" or \"outbound\"'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat.timeline) {\n    throw errCode(new Error('connection timeline object must be provided in the stat object'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat.timeline.open) {\n    throw errCode(new Error('connection open timestamp must be provided'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat.timeline.upgraded) {\n    throw errCode(new Error('connection upgraded timestamp must be provided'), 'ERR_INVALID_PARAMETERS');\n  }\n}","map":{"version":3,"names":["PeerId","require","Multiaddr","errCode","OPEN","CLOSING","CLOSED","connectionSymbol","Symbol","for","Connection","localAddr","remoteAddr","localPeer","remotePeer","newStream","close","getStreams","stat","validateArgs","id","parseInt","String","Math","random","toString","Date","now","_stat","status","_newStream","_close","_getStreams","registry","Map","tags","protocols","Error","Array","isArray","stream","protocol","addStream","muxedStream","metadata","set","delete","_closing","timeline","other","Boolean","toStringTag","module","exports","isMultiaddr","isPeerId","direction","open","upgraded"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-interfaces/src/connection/connection.js"],"sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { Multiaddr } = require('multiaddr')\nconst errCode = require('err-code')\nconst { OPEN, CLOSING, CLOSED } = require('./status')\n\nconst connectionSymbol = Symbol.for('@libp2p/interface-connection/connection')\n\n/**\n * @typedef {import('../stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('./status').Status} Status\n */\n\n/**\n * @typedef {Object} Timeline\n * @property {number} open - connection opening timestamp.\n * @property {number} [upgraded] - connection upgraded timestamp.\n * @property {number} [close]\n *\n * @typedef {Object} ConectionStat\n * @property {'inbound' | 'outbound'} direction - connection establishment direction\n * @property {Timeline} timeline - connection relevant events timestamp.\n * @property {string} [multiplexer] - connection multiplexing identifier.\n * @property {string} [encryption] - connection encryption method identifier.\n *\n * @typedef {(protocols: string|string[]) => Promise<{stream: MuxedStream, protocol: string}>} CreatedMuxedStream\n *\n * @typedef {Object} ConnectionOptions\n * @property {Multiaddr} [localAddr] - local multiaddr of the connection if known.\n * @property {Multiaddr} remoteAddr - remote multiaddr of the connection.\n * @property {PeerId} localPeer - local peer-id.\n * @property {PeerId} remotePeer - remote peer-id.\n * @property {CreatedMuxedStream} newStream - new stream muxer function.\n * @property {() => Promise<void>} close - close raw connection function.\n * @property {() => MuxedStream[]} getStreams - get streams from muxer function.\n * @property {ConectionStat} stat - metadata of the connection.\n *\n * @typedef {Object} StreamData\n * @property {string} protocol - the protocol used by the stream\n * @property {Object} [metadata] - metadata of the stream\n */\n\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\nclass Connection {\n  /**\n   * An implementation of the js-libp2p connection.\n   * Any libp2p transport should use an upgrader to return this connection.\n   *\n   * @class\n   * @param {ConnectionOptions} options\n   */\n  constructor ({ localAddr, remoteAddr, localPeer, remotePeer, newStream, close, getStreams, stat }) {\n    validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat)\n\n    /**\n     * Connection identifier.\n     */\n    this.id = (parseInt(String(Math.random() * 1e9))).toString(36) + Date.now()\n\n    /**\n     * Observed multiaddr of the local peer\n     */\n    this.localAddr = localAddr\n\n    /**\n     * Observed multiaddr of the remote peer\n     */\n    this.remoteAddr = remoteAddr\n\n    /**\n     * Local peer id.\n     */\n    this.localPeer = localPeer\n\n    /**\n     * Remote peer id.\n     */\n    this.remotePeer = remotePeer\n\n    /**\n     * Connection metadata.\n     *\n     * @type {ConectionStat & {status: Status}}\n     */\n    this._stat = {\n      ...stat,\n      status: OPEN\n    }\n\n    /**\n     * Reference to the new stream function of the multiplexer\n     */\n    this._newStream = newStream\n\n    /**\n     * Reference to the close function of the raw connection\n     */\n    this._close = close\n\n    /**\n     * Reference to the getStreams function of the muxer\n     */\n    this._getStreams = getStreams\n\n    /**\n     * Connection streams registry\n     */\n    this.registry = new Map()\n\n    /**\n     * User provided tags\n     *\n     * @type {string[]}\n     */\n    this.tags = []\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Connection'\n  }\n\n  get [connectionSymbol] () {\n    return true\n  }\n\n  /**\n   * Checks if the given value is a `Connection` instance.\n   *\n   * @param {any} other\n   * @returns {other is Connection}\n   */\n  static isConnection (other) {\n    return Boolean(other && other[connectionSymbol])\n  }\n\n  /**\n   * Get connection metadata\n   *\n   * @this {Connection}\n   */\n  get stat () {\n    return this._stat\n  }\n\n  /**\n   * Get all the streams of the muxer.\n   *\n   * @this {Connection}\n   */\n  get streams () {\n    return this._getStreams()\n  }\n\n  /**\n   * Create a new stream from this connection\n   *\n   * @param {string|string[]} protocols - intended protocol for the stream\n   * @returns {Promise<{stream: MuxedStream, protocol: string}>} with muxed+multistream-selected stream and selected protocol\n   */\n  async newStream (protocols) {\n    if (this.stat.status === CLOSING) {\n      throw errCode(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED')\n    }\n\n    if (this.stat.status === CLOSED) {\n      throw errCode(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED')\n    }\n\n    if (!Array.isArray(protocols)) protocols = [protocols]\n\n    const { stream, protocol } = await this._newStream(protocols)\n\n    this.addStream(stream, { protocol })\n\n    return {\n      stream,\n      protocol\n    }\n  }\n\n  /**\n   * Add a stream when it is opened to the registry.\n   *\n   * @param {MuxedStream} muxedStream - a muxed stream\n   * @param {StreamData} data - the stream data to be registered\n   * @returns {void}\n   */\n  addStream (muxedStream, { protocol, metadata = {} }) {\n    // Add metadata for the stream\n    this.registry.set(muxedStream.id, {\n      protocol,\n      ...metadata\n    })\n  }\n\n  /**\n   * Remove stream registry after it is closed.\n   *\n   * @param {string} id - identifier of the stream\n   */\n  removeStream (id) {\n    this.registry.delete(id)\n  }\n\n  /**\n   * Close the connection.\n   *\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this.stat.status === CLOSED) {\n      return\n    }\n\n    if (this._closing) {\n      return this._closing\n    }\n\n    this.stat.status = CLOSING\n\n    // Close raw connection\n    this._closing = await this._close()\n\n    this._stat.timeline.close = Date.now()\n    this.stat.status = CLOSED\n  }\n}\n\nmodule.exports = Connection\n\n/**\n * @param {Multiaddr|undefined} localAddr\n * @param {PeerId} localPeer\n * @param {PeerId} remotePeer\n * @param {(protocols: string | string[]) => Promise<{ stream: import(\"../stream-muxer/types\").MuxedStream; protocol: string; }>} newStream\n * @param {() => Promise<void>} close\n * @param {() => import(\"../stream-muxer/types\").MuxedStream[]} getStreams\n * @param {{ direction: any; timeline: any; multiplexer?: string | undefined; encryption?: string | undefined; }} stat\n */\nfunction validateArgs (localAddr, localPeer, remotePeer, newStream, close, getStreams, stat) {\n  if (localAddr && !Multiaddr.isMultiaddr(localAddr)) {\n    throw errCode(new Error('localAddr must be an instance of multiaddr'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!PeerId.isPeerId(localPeer)) {\n    throw errCode(new Error('localPeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!PeerId.isPeerId(remotePeer)) {\n    throw errCode(new Error('remotePeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (typeof newStream !== 'function') {\n    throw errCode(new Error('new stream must be a function'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (typeof close !== 'function') {\n    throw errCode(new Error('close must be a function'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (typeof getStreams !== 'function') {\n    throw errCode(new Error('getStreams must be a function'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!stat) {\n    throw errCode(new Error('connection metadata object must be provided'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (stat.direction !== 'inbound' && stat.direction !== 'outbound') {\n    throw errCode(new Error('direction must be \"inbound\" or \"outbound\"'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!stat.timeline) {\n    throw errCode(new Error('connection timeline object must be provided in the stat object'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!stat.timeline.open) {\n    throw errCode(new Error('connection open timestamp must be provided'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!stat.timeline.upgraded) {\n    throw errCode(new Error('connection upgraded timestamp must be provided'), 'ERR_INVALID_PARAMETERS')\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}