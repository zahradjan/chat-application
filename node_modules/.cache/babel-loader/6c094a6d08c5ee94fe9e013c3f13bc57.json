{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport nodeCrypto from 'crypto';\n\nvar _0n = BigInt(0);\n\nvar _1n = BigInt(1);\n\nvar _2n = BigInt(2);\n\nvar _255n = BigInt(255);\n\nvar CURVE_ORDER = Math.pow(_2n, BigInt(252)) + BigInt('27742317777372353535851937790883648493');\nvar CURVE = {\n  a: BigInt(-1),\n  d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n  P: Math.pow(_2n, _255n) - BigInt(19),\n  l: CURVE_ORDER,\n  n: CURVE_ORDER,\n  h: BigInt(8),\n  Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n  Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960')\n};\nexport { CURVE };\nvar MAX_256B = Math.pow(_2n, BigInt(256));\nvar SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nvar SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nvar SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nvar INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nvar ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nvar D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n\nvar ExtendedPoint = /*#__PURE__*/function () {\n  function ExtendedPoint(x, y, z, t) {\n    _classCallCheck(this, ExtendedPoint);\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.t = t;\n  }\n\n  _createClass(ExtendedPoint, [{\n    key: \"equals\",\n    value: function equals(other) {\n      assertExtPoint(other);\n      var X1 = this.x,\n          Y1 = this.y,\n          Z1 = this.z;\n      var X2 = other.x,\n          Y2 = other.y,\n          Z2 = other.z;\n      var X1Z2 = mod(X1 * Z2);\n      var X2Z1 = mod(X2 * Z1);\n      var Y1Z2 = mod(Y1 * Z2);\n      var Y2Z1 = mod(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n  }, {\n    key: \"double\",\n    value: function double() {\n      var X1 = this.x,\n          Y1 = this.y,\n          Z1 = this.z;\n      var a = CURVE.a;\n      var A = mod(Math.pow(X1, _2n));\n      var B = mod(Math.pow(Y1, _2n));\n      var C = mod(_2n * mod(Math.pow(Z1, _2n)));\n      var D = mod(a * A);\n      var E = mod(mod(Math.pow(X1 + Y1, _2n)) - A - B);\n      var G = D + B;\n      var F = G - C;\n      var H = D - B;\n      var X3 = mod(E * F);\n      var Y3 = mod(G * H);\n      var T3 = mod(E * H);\n      var Z3 = mod(F * G);\n      return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      assertExtPoint(other);\n      var X1 = this.x,\n          Y1 = this.y,\n          Z1 = this.z,\n          T1 = this.t;\n      var X2 = other.x,\n          Y2 = other.y,\n          Z2 = other.z,\n          T2 = other.t;\n      var A = mod((Y1 - X1) * (Y2 + X2));\n      var B = mod((Y1 + X1) * (Y2 - X2));\n      var F = mod(B - A);\n      if (F === _0n) return this.double();\n      var C = mod(Z1 * _2n * T2);\n      var D = mod(T1 * _2n * Z2);\n      var E = D + C;\n      var G = B + A;\n      var H = D - C;\n      var X3 = mod(E * F);\n      var Y3 = mod(G * H);\n      var T3 = mod(E * H);\n      var Z3 = mod(F * G);\n      return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      return this.add(other.negate());\n    }\n  }, {\n    key: \"precomputeWindow\",\n    value: function precomputeWindow(W) {\n      var windows = 1 + 256 / W;\n      var points = [];\n      var p = this;\n      var base = p;\n\n      for (var window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n\n        for (var i = 1; i < Math.pow(2, W - 1); i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n\n        p = base.double();\n      }\n\n      return points;\n    }\n  }, {\n    key: \"wNAF\",\n    value: function wNAF(n, affinePoint) {\n      if (!affinePoint && this.equals(ExtendedPoint.BASE)) affinePoint = Point.BASE;\n      var W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n\n      if (256 % W) {\n        throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n      }\n\n      var precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n\n      if (!precomputes) {\n        precomputes = this.precomputeWindow(W);\n\n        if (affinePoint && W !== 1) {\n          precomputes = ExtendedPoint.normalizeZ(precomputes);\n          pointPrecomputes.set(affinePoint, precomputes);\n        }\n      }\n\n      var p = ExtendedPoint.ZERO;\n      var f = ExtendedPoint.ZERO;\n      var windows = 1 + 256 / W;\n      var windowSize = Math.pow(2, W - 1);\n      var mask = BigInt(Math.pow(2, W) - 1);\n      var maxNumber = Math.pow(2, W);\n      var shiftBy = BigInt(W);\n\n      for (var window = 0; window < windows; window++) {\n        var offset = window * windowSize;\n        var wbits = Number(n & mask);\n        n >>= shiftBy;\n\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n\n        if (wbits === 0) {\n          var pr = precomputes[offset];\n          if (window % 2) pr = pr.negate();\n          f = f.add(pr);\n        } else {\n          var cached = precomputes[offset + Math.abs(wbits) - 1];\n          if (wbits < 0) cached = cached.negate();\n          p = p.add(cached);\n        }\n      }\n\n      return ExtendedPoint.normalizeZ([p, f])[0];\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar, affinePoint) {\n      return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n  }, {\n    key: \"multiplyUnsafe\",\n    value: function multiplyUnsafe(scalar) {\n      var n = normalizeScalar(scalar, CURVE.l, false);\n      var G = ExtendedPoint.BASE;\n      var P0 = ExtendedPoint.ZERO;\n      if (n === _0n) return P0;\n      if (this.equals(P0) || n === _1n) return this;\n      if (this.equals(G)) return this.wNAF(n);\n      var p = P0;\n      var d = this;\n\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n\n      return p;\n    }\n  }, {\n    key: \"isSmallOrder\",\n    value: function isSmallOrder() {\n      return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n  }, {\n    key: \"isTorsionFree\",\n    value: function isTorsionFree() {\n      return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);\n    }\n  }, {\n    key: \"toAffine\",\n    value: function toAffine() {\n      var invZ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : invert(this.z);\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      var ax = mod(x * invZ);\n      var ay = mod(y * invZ);\n      var zz = mod(z * invZ);\n      if (zz !== _1n) throw new Error('invZ was invalid');\n      return new Point(ax, ay);\n    }\n  }, {\n    key: \"fromRistrettoBytes\",\n    value: function fromRistrettoBytes() {\n      legacyRist();\n    }\n  }, {\n    key: \"toRistrettoBytes\",\n    value: function toRistrettoBytes() {\n      legacyRist();\n    }\n  }, {\n    key: \"fromRistrettoHash\",\n    value: function fromRistrettoHash() {\n      legacyRist();\n    }\n  }], [{\n    key: \"fromAffine\",\n    value: function fromAffine(p) {\n      if (!(p instanceof Point)) {\n        throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n      }\n\n      if (p.equals(Point.ZERO)) return ExtendedPoint.ZERO;\n      return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n  }, {\n    key: \"toAffineBatch\",\n    value: function toAffineBatch(points) {\n      var toInv = invertBatch(points.map(function (p) {\n        return p.z;\n      }));\n      return points.map(function (p, i) {\n        return p.toAffine(toInv[i]);\n      });\n    }\n  }, {\n    key: \"normalizeZ\",\n    value: function normalizeZ(points) {\n      return this.toAffineBatch(points).map(this.fromAffine);\n    }\n  }]);\n\n  return ExtendedPoint;\n}();\n\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\n\nfunction assertExtPoint(other) {\n  if (!(other instanceof ExtendedPoint)) throw new TypeError('ExtendedPoint expected');\n}\n\nfunction assertRstPoint(other) {\n  if (!(other instanceof RistrettoPoint)) throw new TypeError('RistrettoPoint expected');\n}\n\nfunction legacyRist() {\n  throw new Error('Legacy method: switch to RistrettoPoint');\n}\n\nvar RistrettoPoint = /*#__PURE__*/function () {\n  function RistrettoPoint(ep) {\n    _classCallCheck(this, RistrettoPoint);\n\n    this.ep = ep;\n  }\n\n  _createClass(RistrettoPoint, [{\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      var _this$ep = this.ep,\n          x = _this$ep.x,\n          y = _this$ep.y,\n          z = _this$ep.z,\n          t = _this$ep.t;\n      var u1 = mod(mod(z + y) * mod(z - y));\n      var u2 = mod(x * y);\n\n      var _invertSqrt = invertSqrt(mod(u1 * Math.pow(u2, _2n))),\n          invsqrt = _invertSqrt.value;\n\n      var D1 = mod(invsqrt * u1);\n      var D2 = mod(invsqrt * u2);\n      var zInv = mod(D1 * D2 * t);\n      var D;\n\n      if (edIsNegative(t * zInv)) {\n        var _x = mod(y * SQRT_M1);\n\n        var _y = mod(x * SQRT_M1);\n\n        x = _x;\n        y = _y;\n        D = mod(D1 * INVSQRT_A_MINUS_D);\n      } else {\n        D = D2;\n      }\n\n      if (edIsNegative(x * zInv)) y = mod(-y);\n      var s = mod((z - y) * D);\n      if (edIsNegative(s)) s = mod(-s);\n      return numberTo32BytesLE(s);\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return bytesToHex(this.toRawBytes());\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toHex();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      assertRstPoint(other);\n      var a = this.ep;\n      var b = other.ep;\n      var one = mod(a.x * b.y) === mod(a.y * b.x);\n      var two = mod(a.y * b.y) === mod(a.x * b.x);\n      return one || two;\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      assertRstPoint(other);\n      return new RistrettoPoint(this.ep.add(other.ep));\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      assertRstPoint(other);\n      return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar) {\n      return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n  }, {\n    key: \"multiplyUnsafe\",\n    value: function multiplyUnsafe(scalar) {\n      return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n  }], [{\n    key: \"calcElligatorRistrettoMap\",\n    value: function calcElligatorRistrettoMap(r0) {\n      var d = CURVE.d;\n      var r = mod(SQRT_M1 * r0 * r0);\n      var Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n      var c = BigInt(-1);\n      var D = mod((c - d * r) * mod(r + d));\n\n      var _uvRatio = uvRatio(Ns, D),\n          Ns_D_is_sq = _uvRatio.isValid,\n          s = _uvRatio.value;\n\n      var s_ = mod(s * r0);\n      if (!edIsNegative(s_)) s_ = mod(-s_);\n      if (!Ns_D_is_sq) s = s_;\n      if (!Ns_D_is_sq) c = r;\n      var Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n      var s2 = s * s;\n      var W0 = mod((s + s) * D);\n      var W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n      var W2 = mod(_1n - s2);\n      var W3 = mod(_1n + s2);\n      return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n  }, {\n    key: \"hashToCurve\",\n    value: function hashToCurve(hex) {\n      hex = ensureBytes(hex, 64);\n      var r1 = bytes255ToNumberLE(hex.slice(0, 32));\n      var R1 = this.calcElligatorRistrettoMap(r1);\n      var r2 = bytes255ToNumberLE(hex.slice(32, 64));\n      var R2 = this.calcElligatorRistrettoMap(r2);\n      return new RistrettoPoint(R1.add(R2));\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      hex = ensureBytes(hex, 32);\n      var a = CURVE.a,\n          d = CURVE.d;\n      var emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n      var s = bytes255ToNumberLE(hex);\n      if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s)) throw new Error(emsg);\n      var s2 = mod(s * s);\n      var u1 = mod(_1n + a * s2);\n      var u2 = mod(_1n - a * s2);\n      var u1_2 = mod(u1 * u1);\n      var u2_2 = mod(u2 * u2);\n      var v = mod(a * d * u1_2 - u2_2);\n\n      var _invertSqrt2 = invertSqrt(mod(v * u2_2)),\n          isValid = _invertSqrt2.isValid,\n          I = _invertSqrt2.value;\n\n      var Dx = mod(I * u2);\n      var Dy = mod(I * Dx * v);\n      var x = mod((s + s) * Dx);\n      if (edIsNegative(x)) x = mod(-x);\n      var y = mod(u1 * Dy);\n      var t = mod(x * y);\n      if (!isValid || edIsNegative(t) || y === _0n) throw new Error(emsg);\n      return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n  }]);\n\n  return RistrettoPoint;\n}();\n\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nvar pointPrecomputes = new WeakMap();\n\nvar Point = /*#__PURE__*/function () {\n  function Point(x, y) {\n    _classCallCheck(this, Point);\n\n    this.x = x;\n    this.y = y;\n  }\n\n  _createClass(Point, [{\n    key: \"_setWindowSize\",\n    value: function _setWindowSize(windowSize) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      var bytes = numberTo32BytesLE(this.y);\n      bytes[31] |= this.x & _1n ? 0x80 : 0;\n      return bytes;\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return bytesToHex(this.toRawBytes());\n    }\n  }, {\n    key: \"toX25519\",\n    value: function toX25519() {\n      var y = this.y;\n      var u = mod((_1n + y) * invert(_1n - y));\n      return numberTo32BytesLE(u);\n    }\n  }, {\n    key: \"isTorsionFree\",\n    value: function isTorsionFree() {\n      return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.x === other.x && this.y === other.y;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return new Point(mod(-this.x), this.y);\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      return this.add(other.negate());\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar) {\n      return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n  }], [{\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var d = CURVE.d,\n          P = CURVE.P;\n      hex = ensureBytes(hex, 32);\n      var normed = hex.slice();\n      normed[31] = hex[31] & ~0x80;\n      var y = bytesToNumberLE(normed);\n      if (strict && y >= P) throw new Error('Expected 0 < hex < P');\n      if (!strict && y >= MAX_256B) throw new Error('Expected 0 < hex < 2**256');\n      var y2 = mod(y * y);\n      var u = mod(y2 - _1n);\n      var v = mod(d * y2 + _1n);\n\n      var _uvRatio2 = uvRatio(u, v),\n          isValid = _uvRatio2.isValid,\n          x = _uvRatio2.value;\n\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      var isXOdd = (x & _1n) === _1n;\n      var isLastByteOdd = (hex[31] & 0x80) !== 0;\n\n      if (isLastByteOdd !== isXOdd) {\n        x = mod(-x);\n      }\n\n      return new Point(x, y);\n    }\n  }, {\n    key: \"fromPrivateKey\",\n    value: function () {\n      var _fromPrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(privateKey) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return getExtendedPublicKey(privateKey);\n\n              case 2:\n                return _context.abrupt(\"return\", _context.sent.point);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function fromPrivateKey(_x2) {\n        return _fromPrivateKey.apply(this, arguments);\n      }\n\n      return fromPrivateKey;\n    }()\n  }]);\n\n  return Point;\n}();\n\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\n\nvar Signature = /*#__PURE__*/function () {\n  function Signature(r, s) {\n    _classCallCheck(this, Signature);\n\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n\n  _createClass(Signature, [{\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var r = this.r,\n          s = this.s;\n      if (!(r instanceof Point)) throw new Error('Expected Point instance');\n      normalizeScalar(s, CURVE.l, false);\n      return this;\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      var u8 = new Uint8Array(64);\n      u8.set(this.r.toRawBytes());\n      u8.set(numberTo32BytesLE(this.s), 32);\n      return u8;\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return bytesToHex(this.toRawBytes());\n    }\n  }], [{\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      var bytes = ensureBytes(hex, 64);\n      var r = Point.fromHex(bytes.slice(0, 32), false);\n      var s = bytesToNumberLE(bytes.slice(32, 64));\n      return new Signature(r, s);\n    }\n  }]);\n\n  return Signature;\n}();\n\nexport { ExtendedPoint, RistrettoPoint, Point, Signature };\n\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  if (!arrays.every(function (a) {\n    return a instanceof Uint8Array;\n  })) throw new Error('Expected Uint8Array list');\n  if (arrays.length === 1) return arrays[0];\n  var length = arrays.reduce(function (a, arr) {\n    return a + arr.length;\n  }, 0);\n  var result = new Uint8Array(length);\n\n  for (var i = 0, pad = 0; i < arrays.length; i++) {\n    var arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n\n  return result;\n}\n\nvar hexes = Array.from({\n  length: 256\n}, function (v, i) {\n  return i.toString(16).padStart(2, '0');\n});\n\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  var hex = '';\n\n  for (var i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n\n  return hex;\n}\n\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  var array = new Uint8Array(hex.length / 2);\n\n  for (var i = 0; i < array.length; i++) {\n    var j = i * 2;\n    var hexByte = hex.slice(j, j + 2);\n    var byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n\n  return array;\n}\n\nfunction numberTo32BytesBE(num) {\n  var length = 32;\n  var hex = num.toString(16).padStart(length * 2, '0');\n  return hexToBytes(hex);\n}\n\nfunction numberTo32BytesLE(num) {\n  return numberTo32BytesBE(num).reverse();\n}\n\nfunction edIsNegative(num) {\n  return (mod(num) & _1n) === _1n;\n}\n\nfunction bytesToNumberLE(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\n\nfunction bytes255ToNumberLE(bytes) {\n  return mod(bytesToNumberLE(bytes) & Math.pow(_2n, _255n) - _1n);\n}\n\nfunction mod(a) {\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  var res = a % b;\n  return res >= _0n ? res : b + res;\n}\n\nfunction invert(number) {\n  var modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(\"invert: expected positive integers, got n=\".concat(number, \" mod=\").concat(modulo));\n  }\n\n  var a = mod(number, modulo);\n  var b = modulo;\n  var x = _0n,\n      y = _1n,\n      u = _1n,\n      v = _0n;\n\n  while (a !== _0n) {\n    var q = b / a;\n    var r = b % a;\n    var m = x - u * q;\n    var n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n\n  var gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction invertBatch(nums) {\n  var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  var tmp = new Array(nums.length);\n  var lastMultiplied = nums.reduce(function (acc, num, i) {\n    if (num === _0n) return acc;\n    tmp[i] = acc;\n    return mod(acc * num, p);\n  }, _1n);\n  var inverted = invert(lastMultiplied, p);\n  nums.reduceRight(function (acc, num, i) {\n    if (num === _0n) return acc;\n    tmp[i] = mod(acc * tmp[i], p);\n    return mod(acc * num, p);\n  }, inverted);\n  return tmp;\n}\n\nfunction pow2(x, power) {\n  var P = CURVE.P;\n  var res = x;\n\n  while (power-- > _0n) {\n    res *= res;\n    res %= P;\n  }\n\n  return res;\n}\n\nfunction pow_2_252_3(x) {\n  var P = CURVE.P;\n\n  var _5n = BigInt(5);\n\n  var _10n = BigInt(10);\n\n  var _20n = BigInt(20);\n\n  var _40n = BigInt(40);\n\n  var _80n = BigInt(80);\n\n  var x2 = x * x % P;\n  var b2 = x2 * x % P;\n  var b4 = pow2(b2, _2n) * b2 % P;\n  var b5 = pow2(b4, _1n) * x % P;\n  var b10 = pow2(b5, _5n) * b5 % P;\n  var b20 = pow2(b10, _10n) * b10 % P;\n  var b40 = pow2(b20, _20n) * b20 % P;\n  var b80 = pow2(b40, _40n) * b40 % P;\n  var b160 = pow2(b80, _80n) * b80 % P;\n  var b240 = pow2(b160, _80n) * b80 % P;\n  var b250 = pow2(b240, _10n) * b10 % P;\n  var pow_p_5_8 = pow2(b250, _2n) * x % P;\n  return {\n    pow_p_5_8: pow_p_5_8,\n    b2: b2\n  };\n}\n\nfunction uvRatio(u, v) {\n  var v3 = mod(v * v * v);\n  var v7 = mod(v3 * v3 * v);\n  var pow = pow_2_252_3(u * v7).pow_p_5_8;\n  var x = mod(u * v3 * pow);\n  var vx2 = mod(v * x * x);\n  var root1 = x;\n  var root2 = mod(x * SQRT_M1);\n  var useRoot1 = vx2 === u;\n  var useRoot2 = vx2 === mod(-u);\n  var noRoot = vx2 === mod(-u * SQRT_M1);\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2;\n  if (edIsNegative(x)) x = mod(-x);\n  return {\n    isValid: useRoot1 || useRoot2,\n    value: x\n  };\n}\n\nfunction invertSqrt(number) {\n  return uvRatio(_1n, number);\n}\n\nfunction sha512ModqLE() {\n  return _sha512ModqLE.apply(this, arguments);\n}\n\nfunction _sha512ModqLE() {\n  _sha512ModqLE = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n    var hash,\n        value,\n        _args3 = arguments;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return utils.sha512(concatBytes.apply(void 0, _args3));\n\n          case 2:\n            hash = _context3.sent;\n            value = bytesToNumberLE(hash);\n            return _context3.abrupt(\"return\", mod(value, CURVE.l));\n\n          case 5:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _sha512ModqLE.apply(this, arguments);\n}\n\nfunction equalBytes(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  for (var i = 0; i < b1.length; i++) {\n    if (b1[i] !== b2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction ensureBytes(hex, expectedLength) {\n  var bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n  if (typeof expectedLength === 'number' && bytes.length !== expectedLength) throw new Error(\"Expected \".concat(expectedLength, \" bytes\"));\n  return bytes;\n}\n\nfunction normalizeScalar(num, max) {\n  var strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!max) throw new TypeError('Specify max value');\n  if (typeof num === 'number' && Number.isSafeInteger(num)) num = BigInt(num);\n\n  if (typeof num === 'bigint' && num < max) {\n    if (strict) {\n      if (_0n < num) return num;\n    } else {\n      if (_0n <= num) return num;\n    }\n  }\n\n  throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\n\nfunction adjustBytes25519(bytes) {\n  bytes[0] &= 248;\n  bytes[31] &= 127;\n  bytes[31] |= 64;\n  return bytes;\n}\n\nfunction decodeScalar25519(n) {\n  return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\n\nfunction getExtendedPublicKey(_x3) {\n  return _getExtendedPublicKey.apply(this, arguments);\n}\n\nfunction _getExtendedPublicKey() {\n  _getExtendedPublicKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(key) {\n    var hashed, head, prefix, scalar, point, pointBytes;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            key = typeof key === 'bigint' || typeof key === 'number' ? numberTo32BytesBE(normalizeScalar(key, MAX_256B)) : ensureBytes(key);\n\n            if (!(key.length !== 32)) {\n              _context4.next = 3;\n              break;\n            }\n\n            throw new Error(\"Expected 32 bytes\");\n\n          case 3:\n            _context4.next = 5;\n            return utils.sha512(key);\n\n          case 5:\n            hashed = _context4.sent;\n            head = adjustBytes25519(hashed.slice(0, 32));\n            prefix = hashed.slice(32, 64);\n            scalar = mod(bytesToNumberLE(head), CURVE.l);\n            point = Point.BASE.multiply(scalar);\n            pointBytes = point.toRawBytes();\n            return _context4.abrupt(\"return\", {\n              head: head,\n              prefix: prefix,\n              scalar: scalar,\n              point: point,\n              pointBytes: pointBytes\n            });\n\n          case 12:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getExtendedPublicKey.apply(this, arguments);\n}\n\nexport function getPublicKey(_x4) {\n  return _getPublicKey.apply(this, arguments);\n}\n\nfunction _getPublicKey() {\n  _getPublicKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(privateKey) {\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return getExtendedPublicKey(privateKey);\n\n          case 2:\n            return _context5.abrupt(\"return\", _context5.sent.pointBytes);\n\n          case 3:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _getPublicKey.apply(this, arguments);\n}\n\nexport function sign(_x5, _x6) {\n  return _sign.apply(this, arguments);\n}\n\nfunction _sign() {\n  _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(message, privateKey) {\n    var _yield$getExtendedPub, prefix, scalar, pointBytes, r, R, k, s;\n\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            message = ensureBytes(message);\n            _context6.next = 3;\n            return getExtendedPublicKey(privateKey);\n\n          case 3:\n            _yield$getExtendedPub = _context6.sent;\n            prefix = _yield$getExtendedPub.prefix;\n            scalar = _yield$getExtendedPub.scalar;\n            pointBytes = _yield$getExtendedPub.pointBytes;\n            _context6.next = 9;\n            return sha512ModqLE(prefix, message);\n\n          case 9:\n            r = _context6.sent;\n            R = Point.BASE.multiply(r);\n            _context6.next = 13;\n            return sha512ModqLE(R.toRawBytes(), pointBytes, message);\n\n          case 13:\n            k = _context6.sent;\n            s = mod(r + k * scalar, CURVE.l);\n            return _context6.abrupt(\"return\", new Signature(R, s).toRawBytes());\n\n          case 16:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _sign.apply(this, arguments);\n}\n\nexport function verify(_x7, _x8, _x9) {\n  return _verify.apply(this, arguments);\n}\n\nfunction _verify() {\n  _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(sig, message, publicKey) {\n    var _ref, r, s, SB, k, kA, RkA;\n\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            message = ensureBytes(message);\n            if (!(publicKey instanceof Point)) publicKey = Point.fromHex(publicKey, false);\n            _ref = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig), r = _ref.r, s = _ref.s;\n            SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n            _context7.next = 6;\n            return sha512ModqLE(r.toRawBytes(), publicKey.toRawBytes(), message);\n\n          case 6:\n            k = _context7.sent;\n            kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n            RkA = ExtendedPoint.fromAffine(r).add(kA);\n            return _context7.abrupt(\"return\", RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO));\n\n          case 10:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _verify.apply(this, arguments);\n}\n\nexport function getSharedSecret(_x10, _x11) {\n  return _getSharedSecret.apply(this, arguments);\n}\n\nfunction _getSharedSecret() {\n  _getSharedSecret = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(privateKey, publicKey) {\n    var _yield$getExtendedPub2, head, u;\n\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return getExtendedPublicKey(privateKey);\n\n          case 2:\n            _yield$getExtendedPub2 = _context8.sent;\n            head = _yield$getExtendedPub2.head;\n            u = Point.fromHex(publicKey).toX25519();\n            return _context8.abrupt(\"return\", curve25519.scalarMult(head, u));\n\n          case 6:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _getSharedSecret.apply(this, arguments);\n}\n\nPoint.BASE._setWindowSize(8);\n\nfunction cswap(swap, x_2, x_3) {\n  var dummy = mod(swap * (x_2 - x_3));\n  x_2 = mod(x_2 - dummy);\n  x_3 = mod(x_3 + dummy);\n  return [x_2, x_3];\n}\n\nfunction montgomeryLadder(pointU, scalar) {\n  var P = CURVE.P;\n  var u = normalizeScalar(pointU, P);\n  var k = normalizeScalar(scalar, P);\n  var a24 = BigInt(121665);\n  var x_1 = u;\n  var x_2 = _1n;\n  var z_2 = _0n;\n  var x_3 = u;\n  var z_3 = _1n;\n  var swap = _0n;\n  var sw;\n\n  for (var t = BigInt(255 - 1); t >= _0n; t--) {\n    var k_t = k >> t & _1n;\n    swap ^= k_t;\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    swap = k_t;\n    var A = x_2 + z_2;\n    var AA = mod(A * A);\n    var B = x_2 - z_2;\n    var BB = mod(B * B);\n    var E = AA - BB;\n    var C = x_3 + z_3;\n    var D = x_3 - z_3;\n    var DA = mod(D * A);\n    var CB = mod(C * B);\n    x_3 = mod(Math.pow(DA + CB, _2n));\n    z_3 = mod(x_1 * Math.pow(DA - CB, _2n));\n    x_2 = mod(AA * BB);\n    z_2 = mod(E * (AA + mod(a24 * E)));\n  }\n\n  sw = cswap(swap, x_2, x_3);\n  x_2 = sw[0];\n  x_3 = sw[1];\n  sw = cswap(swap, z_2, z_3);\n  z_2 = sw[0];\n  z_3 = sw[1];\n\n  var _pow_2_252_ = pow_2_252_3(z_2),\n      pow_p_5_8 = _pow_2_252_.pow_p_5_8,\n      b2 = _pow_2_252_.b2;\n\n  var xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n  return mod(x_2 * xp2);\n}\n\nfunction encodeUCoordinate(u) {\n  return numberTo32BytesLE(mod(u, CURVE.P));\n}\n\nfunction decodeUCoordinate(uEnc) {\n  var u = ensureBytes(uEnc, 32);\n  u[31] &= 127;\n  return bytesToNumberLE(u);\n}\n\nexport var curve25519 = {\n  BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n  scalarMult: function scalarMult(privateKey, publicKey) {\n    var u = decodeUCoordinate(publicKey);\n    var p = decodeScalar25519(privateKey);\n    var pu = montgomeryLadder(u, p);\n    if (pu === _0n) throw new Error('Invalid private or public key received');\n    return encodeUCoordinate(pu);\n  },\n  scalarMultBase: function scalarMultBase(privateKey) {\n    return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n  }\n};\nvar crypto = {\n  node: nodeCrypto,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\nexport var utils = {\n  TORSION_SUBGROUP: ['0100000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a', '0000000000000000000000000000000000000000000000000000000000000080', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05', 'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85', '0000000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa'],\n  bytesToHex: bytesToHex,\n  getExtendedPublicKey: getExtendedPublicKey,\n  mod: mod,\n  invert: invert,\n  hashToPrivateScalar: function hashToPrivateScalar(hash) {\n    hash = ensureBytes(hash);\n    if (hash.length < 40 || hash.length > 1024) throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n    var num = mod(bytesToNumberLE(hash), CURVE.l);\n    if (num === _0n || num === _1n) throw new Error('Invalid private key');\n    return num;\n  },\n  randomBytes: function randomBytes() {\n    var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      var randomBytes = crypto.node.randomBytes;\n      return new Uint8Array(randomBytes(bytesLength).buffer);\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: function randomPrivateKey() {\n    return utils.randomBytes(32);\n  },\n  sha512: function () {\n    var _sha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(message) {\n      var buffer;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!crypto.web) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 3;\n              return crypto.web.subtle.digest('SHA-512', message.buffer);\n\n            case 3:\n              buffer = _context2.sent;\n              return _context2.abrupt(\"return\", new Uint8Array(buffer));\n\n            case 7:\n              if (!crypto.node) {\n                _context2.next = 11;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", Uint8Array.from(crypto.node.createHash('sha512').update(message).digest()));\n\n            case 11:\n              throw new Error(\"The environment doesn't have sha512 function\");\n\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function sha512(_x12) {\n      return _sha.apply(this, arguments);\n    }\n\n    return sha512;\n  }(),\n  precompute: function precompute() {\n    var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n    var cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n\n    cached._setWindowSize(windowSize);\n\n    cached.multiply(_2n);\n    return cached;\n  }\n};","map":{"version":3,"names":["nodeCrypto","_0n","BigInt","_1n","_2n","_255n","CURVE_ORDER","CURVE","a","d","P","l","n","h","Gx","Gy","MAX_256B","SQRT_M1","SQRT_D","SQRT_AD_MINUS_ONE","INVSQRT_A_MINUS_D","ONE_MINUS_D_SQ","D_MINUS_ONE_SQ","ExtendedPoint","x","y","z","t","other","assertExtPoint","X1","Y1","Z1","X2","Y2","Z2","X1Z2","mod","X2Z1","Y1Z2","Y2Z1","A","B","C","D","E","G","F","H","X3","Y3","T3","Z3","T1","T2","double","add","negate","W","windows","points","p","base","window","push","i","affinePoint","equals","BASE","Point","_WINDOW_SIZE","Error","precomputes","pointPrecomputes","get","precomputeWindow","normalizeZ","set","ZERO","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","pr","cached","Math","abs","scalar","wNAF","normalizeScalar","P0","multiplyUnsafe","invZ","invert","ax","ay","zz","legacyRist","TypeError","toInv","invertBatch","map","toAffine","toAffineBatch","fromAffine","assertRstPoint","RistrettoPoint","ep","u1","u2","invertSqrt","invsqrt","value","D1","D2","zInv","edIsNegative","_x","_y","s","numberTo32BytesLE","bytesToHex","toRawBytes","toHex","b","one","two","subtract","multiply","r0","r","Ns","c","uvRatio","Ns_D_is_sq","isValid","s_","Nt","s2","W0","W1","W2","W3","hex","ensureBytes","r1","bytes255ToNumberLE","slice","R1","calcElligatorRistrettoMap","r2","R2","emsg","equalBytes","u1_2","u2_2","v","I","Dx","Dy","WeakMap","delete","bytes","u","isTorsionFree","strict","normed","bytesToNumberLE","y2","isXOdd","isLastByteOdd","privateKey","getExtendedPublicKey","point","Signature","assertValidity","u8","Uint8Array","fromHex","concatBytes","arrays","every","length","reduce","arr","result","pad","hexes","Array","from","toString","padStart","uint8a","hexToBytes","array","j","hexByte","byte","parseInt","isNaN","numberTo32BytesBE","num","reverse","res","number","modulo","q","m","gcd","nums","tmp","lastMultiplied","acc","inverted","reduceRight","pow2","power","pow_2_252_3","_5n","_10n","_20n","_40n","_80n","x2","b2","b4","b5","b10","b20","b40","b80","b160","b240","b250","pow_p_5_8","v3","v7","pow","vx2","root1","root2","useRoot1","useRoot2","noRoot","sha512ModqLE","utils","sha512","hash","b1","expectedLength","max","isSafeInteger","adjustBytes25519","decodeScalar25519","key","hashed","head","prefix","pointBytes","getPublicKey","sign","message","R","k","verify","sig","publicKey","SB","kA","RkA","getSharedSecret","toX25519","curve25519","scalarMult","_setWindowSize","cswap","swap","x_2","x_3","dummy","montgomeryLadder","pointU","a24","x_1","z_2","z_3","sw","k_t","AA","BB","DA","CB","xp2","encodeUCoordinate","decodeUCoordinate","uEnc","BASE_POINT_U","pu","scalarMultBase","crypto","node","web","self","undefined","TORSION_SUBGROUP","hashToPrivateScalar","randomBytes","bytesLength","getRandomValues","buffer","randomPrivateKey","subtle","digest","createHash","update","precompute"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/@noble/ed25519/lib/esm/index.js"],"sourcesContent":["/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _255n = BigInt(255);\nconst CURVE_ORDER = _2n ** BigInt(252) + BigInt('27742317777372353535851937790883648493');\nconst CURVE = {\n    a: BigInt(-1),\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    P: _2n ** _255n - BigInt(19),\n    l: CURVE_ORDER,\n    n: CURVE_ORDER,\n    h: BigInt(8),\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n};\nexport { CURVE };\nconst MAX_256B = _2n ** BigInt(256);\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\nclass ExtendedPoint {\n    constructor(x, y, z, t) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    equals(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const X1Z2 = mod(X1 * Z2);\n        const X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2);\n        const Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { a } = CURVE;\n        const A = mod(X1 ** _2n);\n        const B = mod(Y1 ** _2n);\n        const C = mod(_2n * mod(Z1 ** _2n));\n        const D = mod(a * A);\n        const E = mod(mod((X1 + Y1) ** _2n) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1, t: T1 } = this;\n        const { x: X2, y: Y2, z: Z2, t: T2 } = other;\n        const A = mod((Y1 - X1) * (Y2 + X2));\n        const B = mod((Y1 + X1) * (Y2 - X2));\n        const F = mod(B - A);\n        if (F === _0n)\n            return this.double();\n        const C = mod(Z1 * _2n * T2);\n        const D = mod(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    precomputeWindow(W) {\n        const windows = 1 + 256 / W;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.ZERO;\n        const windows = 1 + 256 / W;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return ExtendedPoint.normalizeZ([p, f])[0];\n    }\n    multiply(scalar, affinePoint) {\n        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar, CURVE.l, false);\n        const G = ExtendedPoint.BASE;\n        const P0 = ExtendedPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (this.equals(P0) || n === _1n)\n            return this;\n        if (this.equals(G))\n            return this.wNAF(n);\n        let p = P0;\n        let d = this;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    isSmallOrder() {\n        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n    isTorsionFree() {\n        return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const ax = mod(x * invZ);\n        const ay = mod(y * invZ);\n        const zz = mod(z * invZ);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n    fromRistrettoBytes() {\n        legacyRist();\n    }\n    toRistrettoBytes() {\n        legacyRist();\n    }\n    fromRistrettoHash() {\n        legacyRist();\n    }\n}\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nfunction assertExtPoint(other) {\n    if (!(other instanceof ExtendedPoint))\n        throw new TypeError('ExtendedPoint expected');\n}\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistrettoPoint))\n        throw new TypeError('RistrettoPoint expected');\n}\nfunction legacyRist() {\n    throw new Error('Legacy method: switch to RistrettoPoint');\n}\nclass RistrettoPoint {\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n        let c = BigInt(-1);\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_))\n            s_ = mod(-s_);\n        if (!Ns_D_is_sq)\n            s = s_;\n        if (!Ns_D_is_sq)\n            c = r;\n        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(_1n - s2);\n        const W3 = mod(_1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static hashToCurve(hex) {\n        hex = ensureBytes(hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return new RistrettoPoint(R1.add(R2));\n    }\n    static fromHex(hex) {\n        hex = ensureBytes(hex, 32);\n        const { a, d } = CURVE;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2);\n        const u2 = mod(_1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x))\n            x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === _0n)\n            throw new Error(emsg);\n        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n    toRawBytes() {\n        let { x, y, z, t } = this.ep;\n        const u1 = mod(mod(z + y) * mod(z - y));\n        const u2 = mod(x * y);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2 ** _2n));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv))\n            y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s))\n            s = mod(-s);\n        return numberTo32BytesLE(s);\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    equals(other) {\n        assertRstPoint(other);\n        const a = this.ep;\n        const b = other.ep;\n        const one = mod(a.x * b.y) === mod(a.y * b.x);\n        const two = mod(a.y * b.y) === mod(a.x * b.x);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n}\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hex, strict = true) {\n        const { d, P } = CURVE;\n        hex = ensureBytes(hex, 32);\n        const normed = hex.slice();\n        normed[31] = hex[31] & ~0x80;\n        const y = bytesToNumberLE(normed);\n        if (strict && y >= P)\n            throw new Error('Expected 0 < hex < P');\n        if (!strict && y >= MAX_256B)\n            throw new Error('Expected 0 < hex < 2**256');\n        const y2 = mod(y * y);\n        const u = mod(y2 - _1n);\n        const v = mod(d * y2 + _1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid)\n            throw new Error('Point.fromHex: invalid y coordinate');\n        const isXOdd = (x & _1n) === _1n;\n        const isLastByteOdd = (hex[31] & 0x80) !== 0;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n        const bytes = numberTo32BytesLE(this.y);\n        bytes[31] |= this.x & _1n ? 0x80 : 0;\n        return bytes;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        const { y } = this;\n        const u = mod((_1n + y) * invert(_1n - y));\n        return numberTo32BytesLE(u);\n    }\n    isTorsionFree() {\n        return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex, 64);\n        const r = Point.fromHex(bytes.slice(0, 32), false);\n        const s = bytesToNumberLE(bytes.slice(32, 64));\n        return new Signature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!(r instanceof Point))\n            throw new Error('Expected Point instance');\n        normalizeScalar(s, CURVE.l, false);\n        return this;\n    }\n    toRawBytes() {\n        const u8 = new Uint8Array(64);\n        u8.set(this.r.toRawBytes());\n        u8.set(numberTo32BytesLE(this.s), 32);\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\nexport { ExtendedPoint, RistrettoPoint, Point, Signature };\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array list');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction numberTo32BytesBE(num) {\n    const length = 32;\n    const hex = num.toString(16).padStart(length * 2, '0');\n    return hexToBytes(hex);\n}\nfunction numberTo32BytesLE(num) {\n    return numberTo32BytesBE(num).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & (_2n ** _255n - _1n));\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = mod(acc * tmp[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return tmp;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P;\n    const b4 = (pow2(b2, _2n) * b2) % P;\n    const b5 = (pow2(b4, _1n) * x) % P;\n    const b10 = (pow2(b5, _5n) * b5) % P;\n    const b20 = (pow2(b10, _10n) * b10) % P;\n    const b40 = (pow2(b20, _20n) * b20) % P;\n    const b80 = (pow2(b40, _40n) * b40) % P;\n    const b160 = (pow2(b80, _80n) * b80) % P;\n    const b240 = (pow2(b160, _80n) * b80) % P;\n    const b250 = (pow2(b240, _10n) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n) * x) % P;\n    return { pow_p_5_8, b2 };\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2;\n    if (edIsNegative(x))\n        x = mod(-x);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nfunction invertSqrt(number) {\n    return uvRatio(_1n, number);\n}\nasync function sha512ModqLE(...args) {\n    const hash = await utils.sha512(concatBytes(...args));\n    const value = bytesToNumberLE(hash);\n    return mod(value, CURVE.l);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === 'number' && bytes.length !== expectedLength)\n        throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n    if (!max)\n        throw new TypeError('Specify max value');\n    if (typeof num === 'number' && Number.isSafeInteger(num))\n        num = BigInt(num);\n    if (typeof num === 'bigint' && num < max) {\n        if (strict) {\n            if (_0n < num)\n                return num;\n        }\n        else {\n            if (_0n <= num)\n                return num;\n        }\n    }\n    throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\nfunction adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n}\nfunction decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nasync function getExtendedPublicKey(key) {\n    key =\n        typeof key === 'bigint' || typeof key === 'number'\n            ? numberTo32BytesBE(normalizeScalar(key, MAX_256B))\n            : ensureBytes(key);\n    if (key.length !== 32)\n        throw new Error(`Expected 32 bytes`);\n    const hashed = await utils.sha512(key);\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = mod(bytesToNumberLE(head), CURVE.l);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return { head, prefix, scalar, point, pointBytes };\n}\nexport async function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nexport async function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);\n    const r = await sha512ModqLE(prefix, message);\n    const R = Point.BASE.multiply(r);\n    const k = await sha512ModqLE(R.toRawBytes(), pointBytes, message);\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nexport async function verify(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point))\n        publicKey = Point.fromHex(publicKey, false);\n    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n    const k = await sha512ModqLE(r.toRawBytes(), publicKey.toRawBytes(), message);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nexport async function getSharedSecret(privateKey, publicKey) {\n    const { head } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return curve25519.scalarMult(head, u);\n}\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [x_2, x_3];\n}\nfunction montgomeryLadder(pointU, scalar) {\n    const { P } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(255 - 1); t >= _0n; t--) {\n        const k_t = (k >> t) & _1n;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = mod(A * A);\n        const B = x_2 - z_2;\n        const BB = mod(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = mod(D * A);\n        const CB = mod(C * B);\n        x_3 = mod((DA + CB) ** _2n);\n        z_3 = mod(x_1 * (DA - CB) ** _2n);\n        x_2 = mod(AA * BB);\n        z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n    return numberTo32BytesLE(mod(u, CURVE.P));\n}\nfunction decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n}\nexport const curve25519 = {\n    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n    scalarMult(privateKey, publicKey) {\n        const u = decodeUCoordinate(publicKey);\n        const p = decodeScalar25519(privateKey);\n        const pu = montgomeryLadder(u, p);\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    },\n    scalarMultBase(privateKey) {\n        return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n    },\n};\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nexport const utils = {\n    TORSION_SUBGROUP: [\n        '0100000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n        '0000000000000000000000000000000000000000000000000000000000000080',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n        '0000000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n    ],\n    bytesToHex,\n    getExtendedPublicKey,\n    mod,\n    invert,\n    hashToPrivateScalar: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        const num = mod(bytesToNumberLE(hash), CURVE.l);\n        if (num === _0n || num === _1n)\n            throw new Error('Invalid private key');\n        return num;\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.randomBytes(32);\n    },\n    sha512: async (message) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_2n);\n        return cached;\n    },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}