{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _require = require('abortable-iterator'),\n    abortable = _require.source;\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:stream:converter');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n *\n * @typedef {Object} Timeline\n * @property {number} open - connection opening timestamp.\n * @property {number} [upgraded] - connection upgraded timestamp.\n * @property {number} [close]\n */\n\n/**\n * Convert a duplex iterable into a MultiaddrConnection.\n * https://github.com/libp2p/interface-transport#multiaddrconnection\n *\n * @param {object} streamProperties\n * @param {MuxedStream} streamProperties.stream\n * @param {Multiaddr} streamProperties.remoteAddr\n * @param {Multiaddr} streamProperties.localAddr\n * @param {object} [options]\n * @param {AbortSignal} [options.signal]\n * @returns {import('libp2p-interfaces/src/transport/types').MultiaddrConnection}\n */\n\nfunction streamToMaConnection(_ref) {\n  var stream = _ref.stream,\n      remoteAddr = _ref.remoteAddr,\n      localAddr = _ref.localAddr;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _sink = stream.sink,\n      source = stream.source;\n  var maConn = {\n    /**\n     * @param {Uint8Array} source\n     */\n    sink: function sink(source) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (options.signal) {\n                  // @ts-ignore ts infers source template will be a number\n                  source = abortable(source, options.signal);\n                }\n\n                _context.prev = 1;\n                _context.next = 4;\n                return _sink(source);\n\n              case 4:\n                _context.next = 9;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](1);\n\n                // If aborted we can safely ignore\n                if (_context.t0.type !== 'aborted') {\n                  // If the source errored the socket will already have been destroyed by\n                  // toIterable.duplex(). If the socket errored it will already be\n                  // destroyed. There's nothing to do here except log the error & return.\n                  log(_context.t0);\n                }\n\n              case 9:\n                _close();\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[1, 6]]);\n      }))();\n    },\n    source: options.signal ? abortable(source, options.signal) : source,\n    conn: stream,\n    localAddr: localAddr,\n    remoteAddr: remoteAddr,\n\n    /** @type {Timeline} */\n    timeline: {\n      open: Date.now(),\n      close: undefined\n    },\n    close: function close() {\n      _sink(new Uint8Array(0));\n\n      return _close();\n    }\n  };\n\n  function _close() {\n    if (!maConn.timeline.close) {\n      maConn.timeline.close = Date.now();\n    }\n\n    return Promise.resolve();\n  }\n\n  return maConn;\n}\n\nmodule.exports = streamToMaConnection;","map":{"version":3,"names":["require","abortable","source","debug","log","streamToMaConnection","stream","remoteAddr","localAddr","options","sink","maConn","signal","type","close","conn","timeline","open","Date","now","undefined","Uint8Array","Promise","resolve","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-utils/src/stream-to-ma-conn.js"],"sourcesContent":["'use strict'\n\nconst { source: abortable } = require('abortable-iterator')\nconst debug = require('debug')\nconst log = debug('libp2p:stream:converter')\n\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n *\n * @typedef {Object} Timeline\n * @property {number} open - connection opening timestamp.\n * @property {number} [upgraded] - connection upgraded timestamp.\n * @property {number} [close]\n */\n\n/**\n * Convert a duplex iterable into a MultiaddrConnection.\n * https://github.com/libp2p/interface-transport#multiaddrconnection\n *\n * @param {object} streamProperties\n * @param {MuxedStream} streamProperties.stream\n * @param {Multiaddr} streamProperties.remoteAddr\n * @param {Multiaddr} streamProperties.localAddr\n * @param {object} [options]\n * @param {AbortSignal} [options.signal]\n * @returns {import('libp2p-interfaces/src/transport/types').MultiaddrConnection}\n */\nfunction streamToMaConnection ({ stream, remoteAddr, localAddr }, options = {}) {\n  const { sink, source } = stream\n  const maConn = {\n    /**\n     * @param {Uint8Array} source\n     */\n    async sink (source) {\n      if (options.signal) {\n        // @ts-ignore ts infers source template will be a number\n        source = abortable(source, options.signal)\n      }\n\n      try {\n        await sink(source)\n      } catch (err) {\n        // If aborted we can safely ignore\n        if (err.type !== 'aborted') {\n          // If the source errored the socket will already have been destroyed by\n          // toIterable.duplex(). If the socket errored it will already be\n          // destroyed. There's nothing to do here except log the error & return.\n          log(err)\n        }\n      }\n      close()\n    },\n    source: options.signal ? abortable(source, options.signal) : source,\n    conn: stream,\n    localAddr,\n    remoteAddr,\n    /** @type {Timeline} */\n    timeline: { open: Date.now(), close: undefined },\n    close () {\n      sink(new Uint8Array(0))\n      return close()\n    }\n  }\n\n  function close () {\n    if (!maConn.timeline.close) {\n      maConn.timeline.close = Date.now()\n    }\n    return Promise.resolve()\n  }\n\n  return maConn\n}\n\nmodule.exports = streamToMaConnection\n"],"mappings":"AAAA;;;;;;AAEA,eAA8BA,OAAO,CAAC,oBAAD,CAArC;AAAA,IAAgBC,SAAhB,YAAQC,MAAR;;AACA,IAAMC,KAAK,GAAGH,OAAO,CAAC,OAAD,CAArB;;AACA,IAAMI,GAAG,GAAGD,KAAK,CAAC,yBAAD,CAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASE,oBAAT,OAAgF;EAAA,IAA/CC,MAA+C,QAA/CA,MAA+C;EAAA,IAAvCC,UAAuC,QAAvCA,UAAuC;EAAA,IAA3BC,SAA2B,QAA3BA,SAA2B;EAAA,IAAdC,OAAc,uEAAJ,EAAI;EAC9E,IAAQC,KAAR,GAAyBJ,MAAzB,CAAQI,IAAR;EAAA,IAAcR,MAAd,GAAyBI,MAAzB,CAAcJ,MAAd;EACA,IAAMS,MAAM,GAAG;IACb;AACJ;AACA;IACUD,IAJO,gBAIDR,MAJC,EAIO;MAAA;QAAA;UAAA;YAAA;cAAA;gBAClB,IAAIO,OAAO,CAACG,MAAZ,EAAoB;kBAClB;kBACAV,MAAM,GAAGD,SAAS,CAACC,MAAD,EAASO,OAAO,CAACG,MAAjB,CAAlB;gBACD;;gBAJiB;gBAAA;gBAAA,OAOVF,KAAI,CAACR,MAAD,CAPM;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;gBAShB;gBACA,IAAI,YAAIW,IAAJ,KAAa,SAAjB,EAA4B;kBAC1B;kBACA;kBACA;kBACAT,GAAG,aAAH;gBACD;;cAfe;gBAiBlBU,MAAK;;cAjBa;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAkBnB,CAtBY;IAuBbZ,MAAM,EAAEO,OAAO,CAACG,MAAR,GAAiBX,SAAS,CAACC,MAAD,EAASO,OAAO,CAACG,MAAjB,CAA1B,GAAqDV,MAvBhD;IAwBba,IAAI,EAAET,MAxBO;IAyBbE,SAAS,EAATA,SAzBa;IA0BbD,UAAU,EAAVA,UA1Ba;;IA2Bb;IACAS,QAAQ,EAAE;MAAEC,IAAI,EAAEC,IAAI,CAACC,GAAL,EAAR;MAAoBL,KAAK,EAAEM;IAA3B,CA5BG;IA6BbN,KA7Ba,mBA6BJ;MACPJ,KAAI,CAAC,IAAIW,UAAJ,CAAe,CAAf,CAAD,CAAJ;;MACA,OAAOP,MAAK,EAAZ;IACD;EAhCY,CAAf;;EAmCA,SAASA,MAAT,GAAkB;IAChB,IAAI,CAACH,MAAM,CAACK,QAAP,CAAgBF,KAArB,EAA4B;MAC1BH,MAAM,CAACK,QAAP,CAAgBF,KAAhB,GAAwBI,IAAI,CAACC,GAAL,EAAxB;IACD;;IACD,OAAOG,OAAO,CAACC,OAAR,EAAP;EACD;;EAED,OAAOZ,MAAP;AACD;;AAEDa,MAAM,CAACC,OAAP,GAAiBpB,oBAAjB"},"metadata":{},"sourceType":"script"}