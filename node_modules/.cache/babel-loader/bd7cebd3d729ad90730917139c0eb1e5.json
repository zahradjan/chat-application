{"ast":null,"code":"'use strict';\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst errcode = require('err-code');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nrequire('node-forge/lib/sha512');\n\nrequire('node-forge/lib/ed25519');\n\nconst forge = require('node-forge/lib/forge');\n\nconst crypto = require('./rsa');\n\nconst pbm = require('./keys');\n\nconst exporter = require('./exporter');\n\nclass RsaPublicKey {\n  constructor(key) {\n    this._key = key;\n  }\n\n  async verify(data, sig) {\n    // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkix(this._key);\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish();\n  }\n\n  encrypt(bytes) {\n    return crypto.encrypt(this._key, bytes);\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    const {\n      bytes\n    } = await sha256.digest(this.bytes);\n    return bytes;\n  }\n\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Uint8Array of the spki format\n  constructor(key, publicKey) {\n    this._key = key;\n    this._publicKey = publicKey;\n  }\n\n  genSecret() {\n    return crypto.getRandomValues(16);\n  }\n\n  async sign(message) {\n    // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message);\n  }\n\n  get public() {\n    if (!this._publicKey) {\n      throw errcode(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED');\n    }\n\n    return new RsaPublicKey(this._publicKey);\n  }\n\n  decrypt(bytes) {\n    return crypto.decrypt(this._key, bytes);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkcs1(this._key);\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish();\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    const {\n      bytes\n    } = await sha256.digest(this.bytes);\n    return bytes;\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n\n\n  async id() {\n    const hash = await this.public.hash();\n    return uint8ArrayToString(hash, 'base58btc');\n  }\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {string} [format=pkcs-8] - The format in which to export as\n   */\n\n\n  async export(password) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'pkcs-8';\n\n    // eslint-disable-line require-await\n    if (format === 'pkcs-8') {\n      const buffer = new forge.util.ByteBuffer(this.marshal());\n      const asn1 = forge.asn1.fromDer(buffer);\n      const privateKey = forge.pki.privateKeyFromAsn1(asn1);\n      const options = {\n        algorithm: 'aes256',\n        count: 10000,\n        saltSize: 128 / 8,\n        prfAlgorithm: 'sha512'\n      };\n      return forge.pki.encryptRsaPrivateKey(privateKey, password, options);\n    } else if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password);\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT');\n    }\n  }\n\n}\n\nasync function unmarshalRsaPrivateKey(bytes) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes);\n  const keys = await crypto.unmarshalPrivateKey(jwk);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n\nfunction unmarshalRsaPublicKey(bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes);\n  return new RsaPublicKey(jwk);\n}\n\nasync function fromJwk(jwk) {\n  const keys = await crypto.unmarshalPrivateKey(jwk);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n\nasync function generateKeyPair(bits) {\n  const keys = await crypto.generateKey(bits);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n};","map":{"version":3,"names":["sha256","require","errcode","equals","uint8ArrayEquals","toString","uint8ArrayToString","forge","crypto","pbm","exporter","RsaPublicKey","constructor","key","_key","verify","data","sig","hashAndVerify","marshal","utils","jwkToPkix","bytes","PublicKey","encode","Type","KeyType","RSA","Data","finish","encrypt","hash","digest","RsaPrivateKey","publicKey","_publicKey","genSecret","getRandomValues","sign","message","hashAndSign","public","Error","decrypt","jwkToPkcs1","PrivateKey","id","export","password","format","buffer","util","ByteBuffer","asn1","fromDer","privateKey","pki","privateKeyFromAsn1","options","algorithm","count","saltSize","prfAlgorithm","encryptRsaPrivateKey","unmarshalRsaPrivateKey","jwk","pkcs1ToJwk","keys","unmarshalPrivateKey","unmarshalRsaPublicKey","pkixToJwk","fromJwk","generateKeyPair","bits","generateKey","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-crypto/src/keys/rsa-class.js"],"sourcesContent":["'use strict'\n\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst errcode = require('err-code')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nrequire('node-forge/lib/sha512')\nrequire('node-forge/lib/ed25519')\nconst forge = require('node-forge/lib/forge')\n\nconst crypto = require('./rsa')\nconst pbm = require('./keys')\nconst exporter = require('./exporter')\n\nclass RsaPublicKey {\n  constructor (key) {\n    this._key = key\n  }\n\n  async verify (data, sig) { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkix(this._key)\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish()\n  }\n\n  encrypt (bytes) {\n    return crypto.encrypt(this._key, bytes)\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Uint8Array of the spki format\n  constructor (key, publicKey) {\n    this._key = key\n    this._publicKey = publicKey\n  }\n\n  genSecret () {\n    return crypto.getRandomValues(16)\n  }\n\n  async sign (message) { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public () {\n    if (!this._publicKey) {\n      throw errcode(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED')\n    }\n\n    return new RsaPublicKey(this._publicKey)\n  }\n\n  decrypt (bytes) {\n    return crypto.decrypt(this._key, bytes)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkcs1(this._key)\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish()\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n  async id () {\n    const hash = await this.public.hash()\n    return uint8ArrayToString(hash, 'base58btc')\n  }\n\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {string} [format=pkcs-8] - The format in which to export as\n   */\n  async export (password, format = 'pkcs-8') { // eslint-disable-line require-await\n    if (format === 'pkcs-8') {\n      const buffer = new forge.util.ByteBuffer(this.marshal())\n      const asn1 = forge.asn1.fromDer(buffer)\n      const privateKey = forge.pki.privateKeyFromAsn1(asn1)\n\n      const options = {\n        algorithm: 'aes256',\n        count: 10000,\n        saltSize: 128 / 8,\n        prfAlgorithm: 'sha512'\n      }\n      return forge.pki.encryptRsaPrivateKey(privateKey, password, options)\n    } else if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password)\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nasync function unmarshalRsaPrivateKey (bytes) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes)\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nfunction unmarshalRsaPublicKey (bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes)\n  return new RsaPublicKey(jwk)\n}\n\nasync function fromJwk (jwk) {\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nasync function generateKeyPair (bits) {\n  const keys = await crypto.generateKey(bits)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}