{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar mergeOptions = require('merge-options');\n\nvar _require = require('it-pipe'),\n    pipe = _require.pipe;\n\nvar _require2 = require('streaming-iterables'),\n    tap = _require2.tap;\n\nvar oldPeerLRU = require('./old-peers');\n\nvar _require3 = require('../constants'),\n    defaultOptions = _require3.METRICS;\n\nvar Stats = require('./stats');\n\nvar initialCounters = ['dataReceived', 'dataSent'];\nvar directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n};\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n */\n\n/**\n * @typedef MetricsProperties\n * @property {import('../connection-manager')} connectionManager\n *\n * @typedef MetricsOptions\n * @property {number} [computeThrottleMaxQueueSize = defaultOptions.computeThrottleMaxQueueSize]\n * @property {number} [computeThrottleTimeout = defaultOptions.computeThrottleTimeout]\n * @property {number[]} [movingAverageIntervals = defaultOptions.movingAverageIntervals]\n * @property {number} [maxOldPeersRetention = defaultOptions.maxOldPeersRetention]\n */\n\nvar Metrics = /*#__PURE__*/function () {\n  /**\n   * @class\n   * @param {MetricsProperties & MetricsOptions} options\n   */\n  function Metrics(options) {\n    var _this = this;\n\n    _classCallCheck(this, Metrics);\n\n    this._options = mergeOptions(defaultOptions, options);\n    this._globalStats = new Stats(initialCounters, this._options);\n    this._peerStats = new Map();\n    this._protocolStats = new Map();\n    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention);\n    this._running = false;\n    this._onMessage = this._onMessage.bind(this);\n    this._connectionManager = options.connectionManager;\n\n    this._connectionManager.on('peer:disconnect', function (connection) {\n      _this.onPeerDisconnected(connection.remotePeer);\n    });\n  }\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n\n\n  _createClass(Metrics, [{\n    key: \"start\",\n    value: function start() {\n      this._running = true;\n    }\n    /**\n     * Stops all averages timers and prevents new data from being tracked.\n     * Once `stop` is called, `start` must be called to resume stats tracking.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._running = false;\n\n      this._globalStats.stop();\n\n      var _iterator = _createForOfIteratorHelper(this._peerStats.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var stats = _step.value;\n          stats.stop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this._protocolStats.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _stats = _step2.value;\n\n          _stats.stop();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * Gets the global `Stats` object\n     *\n     * @returns {Stats}\n     */\n\n  }, {\n    key: \"global\",\n    get: function get() {\n      return this._globalStats;\n    }\n    /**\n     * Returns a list of `PeerId` strings currently being tracked\n     *\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"peers\",\n    get: function get() {\n      return Array.from(this._peerStats.keys());\n    }\n    /**\n     * Returns the `Stats` object for the given `PeerId` whether it\n     * is a live peer, or in the disconnected peer LRU cache.\n     *\n     * @param {PeerId} peerId\n     * @returns {Stats}\n     */\n\n  }, {\n    key: \"forPeer\",\n    value: function forPeer(peerId) {\n      var idString = peerId.toB58String();\n      return this._peerStats.get(idString) || this._oldPeers.get(idString);\n    }\n    /**\n     * Returns a list of all protocol strings currently being tracked.\n     *\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"protocols\",\n    get: function get() {\n      return Array.from(this._protocolStats.keys());\n    }\n    /**\n     * Returns the `Stats` object for the given `protocol`.\n     *\n     * @param {string} protocol\n     * @returns {Stats}\n     */\n\n  }, {\n    key: \"forProtocol\",\n    value: function forProtocol(protocol) {\n      return this._protocolStats.get(protocol);\n    }\n    /**\n     * Should be called when all connections to a given peer\n     * have closed. The `Stats` collection for the peer will\n     * be stopped and moved to an LRU for temporary retention.\n     *\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"onPeerDisconnected\",\n    value: function onPeerDisconnected(peerId) {\n      var idString = peerId.toB58String();\n\n      var peerStats = this._peerStats.get(idString);\n\n      if (peerStats) {\n        peerStats.stop();\n\n        this._peerStats.delete(idString);\n\n        this._oldPeers.set(idString, peerStats);\n      }\n    }\n    /**\n     * Takes the metadata for a message and tracks it in the\n     * appropriate categories. If the protocol is present, protocol\n     * stats will also be tracked.\n     *\n     * @private\n     * @param {object} params\n     * @param {PeerId} params.remotePeer - Remote peer\n     * @param {string} [params.protocol] - Protocol string the stream is running\n     * @param {string} params.direction - One of ['in','out']\n     * @param {number} params.dataLength - Size of the message\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(_ref) {\n      var remotePeer = _ref.remotePeer,\n          protocol = _ref.protocol,\n          direction = _ref.direction,\n          dataLength = _ref.dataLength;\n      if (!this._running) return;\n      var key = directionToEvent[direction];\n      var peerStats = this.forPeer(remotePeer);\n\n      if (!peerStats) {\n        peerStats = new Stats(initialCounters, this._options);\n\n        this._peerStats.set(remotePeer.toB58String(), peerStats);\n      } // Peer and global stats\n\n\n      peerStats.push(key, dataLength);\n\n      this._globalStats.push(key, dataLength); // Protocol specific stats\n\n\n      if (protocol) {\n        var protocolStats = this.forProtocol(protocol);\n\n        if (!protocolStats) {\n          protocolStats = new Stats(initialCounters, this._options);\n\n          this._protocolStats.set(protocol, protocolStats);\n        }\n\n        protocolStats.push(key, dataLength);\n      }\n    }\n    /**\n     * Replaces the `PeerId` string with the given `peerId`.\n     * If stats are already being tracked for the given `peerId`, the\n     * placeholder stats will be merged with the existing stats.\n     *\n     * @param {PeerId} placeholder - A peerId string\n     * @param {PeerId} peerId\n     * @returns {void}\n     */\n\n  }, {\n    key: \"updatePlaceholder\",\n    value: function updatePlaceholder(placeholder, peerId) {\n      if (!this._running) return;\n      var placeholderStats = this.forPeer(placeholder);\n      var peerIdString = peerId.toB58String();\n      var existingStats = this.forPeer(peerId);\n      var mergedStats = placeholderStats; // If we already have stats, merge the two\n\n      if (existingStats) {\n        // If existing, merge\n        mergedStats = Metrics.mergeStats(existingStats, mergedStats); // Attempt to delete from the old peers list just in case it was tracked there\n\n        this._oldPeers.delete(peerIdString);\n      }\n\n      this._peerStats.delete(placeholder.toB58String());\n\n      this._peerStats.set(peerIdString, mergedStats);\n\n      mergedStats.start();\n    }\n    /**\n     * Tracks data running through a given Duplex Iterable `stream`. If\n     * the `peerId` is not provided, a placeholder string will be created and\n     * returned. This allows lazy tracking of a peer when the peer is not yet known.\n     * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n     * with the placeholder string returned from here, and the known `PeerId`.\n     *\n     * @param {Object} options\n     * @param {MultiaddrConnection} options.stream - A duplex iterable stream\n     * @param {PeerId} [options.remotePeer] - The id of the remote peer that's connected\n     * @param {string} [options.protocol] - The protocol the stream is running\n     * @returns {MultiaddrConnection} The peerId string or placeholder string\n     */\n\n  }, {\n    key: \"trackStream\",\n    value: function trackStream(_ref2) {\n      var stream = _ref2.stream,\n          remotePeer = _ref2.remotePeer,\n          protocol = _ref2.protocol;\n      var metrics = this;\n      var _source = stream.source;\n      stream.source = tap(function (chunk) {\n        return metrics._onMessage({\n          remotePeer: remotePeer,\n          protocol: protocol,\n          direction: 'in',\n          dataLength: chunk.length\n        });\n      })(_source);\n      var _sink = stream.sink;\n\n      stream.sink = function (source) {\n        return pipe(source, tap(function (chunk) {\n          return metrics._onMessage({\n            remotePeer: remotePeer,\n            protocol: protocol,\n            direction: 'out',\n            dataLength: chunk.length\n          });\n        }), _sink);\n      };\n\n      return stream;\n    }\n    /**\n     * Merges `other` into `target`. `target` will be modified\n     * and returned.\n     *\n     * @param {Stats} target\n     * @param {Stats} other\n     * @returns {Stats}\n     */\n\n  }], [{\n    key: \"mergeStats\",\n    value: function mergeStats(target, other) {\n      target.stop();\n      other.stop(); // Merge queues\n\n      target._queue = [].concat(_toConsumableArray(target._queue), _toConsumableArray(other._queue)); // TODO: how to merge moving averages?\n\n      return target;\n    }\n  }]);\n\n  return Metrics;\n}();\n\nmodule.exports = Metrics;","map":{"version":3,"names":["mergeOptions","require","pipe","tap","oldPeerLRU","defaultOptions","METRICS","Stats","initialCounters","directionToEvent","in","out","Metrics","options","_options","_globalStats","_peerStats","Map","_protocolStats","_oldPeers","maxOldPeersRetention","_running","_onMessage","bind","_connectionManager","connectionManager","on","connection","onPeerDisconnected","remotePeer","stop","values","stats","Array","from","keys","peerId","idString","toB58String","get","protocol","peerStats","delete","set","direction","dataLength","key","forPeer","push","protocolStats","forProtocol","placeholder","placeholderStats","peerIdString","existingStats","mergedStats","mergeStats","start","stream","metrics","_source","source","chunk","length","_sink","sink","target","other","_queue","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/metrics/index.js"],"sourcesContent":["// @ts-nocheck\n'use strict'\n\nconst mergeOptions = require('merge-options')\nconst { pipe } = require('it-pipe')\nconst { tap } = require('streaming-iterables')\nconst oldPeerLRU = require('./old-peers')\nconst { METRICS: defaultOptions } = require('../constants')\nconst Stats = require('./stats')\n\nconst initialCounters = [\n  'dataReceived',\n  'dataSent'\n]\n\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n}\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n */\n\n/**\n * @typedef MetricsProperties\n * @property {import('../connection-manager')} connectionManager\n *\n * @typedef MetricsOptions\n * @property {number} [computeThrottleMaxQueueSize = defaultOptions.computeThrottleMaxQueueSize]\n * @property {number} [computeThrottleTimeout = defaultOptions.computeThrottleTimeout]\n * @property {number[]} [movingAverageIntervals = defaultOptions.movingAverageIntervals]\n * @property {number} [maxOldPeersRetention = defaultOptions.maxOldPeersRetention]\n */\n\nclass Metrics {\n  /**\n   * @class\n   * @param {MetricsProperties & MetricsOptions} options\n   */\n  constructor (options) {\n    this._options = mergeOptions(defaultOptions, options)\n    this._globalStats = new Stats(initialCounters, this._options)\n    this._peerStats = new Map()\n    this._protocolStats = new Map()\n    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention)\n    this._running = false\n    this._onMessage = this._onMessage.bind(this)\n    this._connectionManager = options.connectionManager\n    this._connectionManager.on('peer:disconnect', (connection) => {\n      this.onPeerDisconnected(connection.remotePeer)\n    })\n  }\n\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n  start () {\n    this._running = true\n  }\n\n  /**\n   * Stops all averages timers and prevents new data from being tracked.\n   * Once `stop` is called, `start` must be called to resume stats tracking.\n   */\n  stop () {\n    this._running = false\n    this._globalStats.stop()\n    for (const stats of this._peerStats.values()) {\n      stats.stop()\n    }\n    for (const stats of this._protocolStats.values()) {\n      stats.stop()\n    }\n  }\n\n  /**\n   * Gets the global `Stats` object\n   *\n   * @returns {Stats}\n   */\n  get global () {\n    return this._globalStats\n  }\n\n  /**\n   * Returns a list of `PeerId` strings currently being tracked\n   *\n   * @returns {string[]}\n   */\n  get peers () {\n    return Array.from(this._peerStats.keys())\n  }\n\n  /**\n   * Returns the `Stats` object for the given `PeerId` whether it\n   * is a live peer, or in the disconnected peer LRU cache.\n   *\n   * @param {PeerId} peerId\n   * @returns {Stats}\n   */\n  forPeer (peerId) {\n    const idString = peerId.toB58String()\n    return this._peerStats.get(idString) || this._oldPeers.get(idString)\n  }\n\n  /**\n   * Returns a list of all protocol strings currently being tracked.\n   *\n   * @returns {string[]}\n   */\n  get protocols () {\n    return Array.from(this._protocolStats.keys())\n  }\n\n  /**\n   * Returns the `Stats` object for the given `protocol`.\n   *\n   * @param {string} protocol\n   * @returns {Stats}\n   */\n  forProtocol (protocol) {\n    return this._protocolStats.get(protocol)\n  }\n\n  /**\n   * Should be called when all connections to a given peer\n   * have closed. The `Stats` collection for the peer will\n   * be stopped and moved to an LRU for temporary retention.\n   *\n   * @param {PeerId} peerId\n   */\n  onPeerDisconnected (peerId) {\n    const idString = peerId.toB58String()\n    const peerStats = this._peerStats.get(idString)\n    if (peerStats) {\n      peerStats.stop()\n      this._peerStats.delete(idString)\n      this._oldPeers.set(idString, peerStats)\n    }\n  }\n\n  /**\n   * Takes the metadata for a message and tracks it in the\n   * appropriate categories. If the protocol is present, protocol\n   * stats will also be tracked.\n   *\n   * @private\n   * @param {object} params\n   * @param {PeerId} params.remotePeer - Remote peer\n   * @param {string} [params.protocol] - Protocol string the stream is running\n   * @param {string} params.direction - One of ['in','out']\n   * @param {number} params.dataLength - Size of the message\n   * @returns {void}\n   */\n  _onMessage ({ remotePeer, protocol, direction, dataLength }) {\n    if (!this._running) return\n\n    const key = directionToEvent[direction]\n\n    let peerStats = this.forPeer(remotePeer)\n    if (!peerStats) {\n      peerStats = new Stats(initialCounters, this._options)\n      this._peerStats.set(remotePeer.toB58String(), peerStats)\n    }\n\n    // Peer and global stats\n    peerStats.push(key, dataLength)\n    this._globalStats.push(key, dataLength)\n\n    // Protocol specific stats\n    if (protocol) {\n      let protocolStats = this.forProtocol(protocol)\n      if (!protocolStats) {\n        protocolStats = new Stats(initialCounters, this._options)\n        this._protocolStats.set(protocol, protocolStats)\n      }\n      protocolStats.push(key, dataLength)\n    }\n  }\n\n  /**\n   * Replaces the `PeerId` string with the given `peerId`.\n   * If stats are already being tracked for the given `peerId`, the\n   * placeholder stats will be merged with the existing stats.\n   *\n   * @param {PeerId} placeholder - A peerId string\n   * @param {PeerId} peerId\n   * @returns {void}\n   */\n  updatePlaceholder (placeholder, peerId) {\n    if (!this._running) return\n    const placeholderStats = this.forPeer(placeholder)\n    const peerIdString = peerId.toB58String()\n    const existingStats = this.forPeer(peerId)\n    let mergedStats = placeholderStats\n\n    // If we already have stats, merge the two\n    if (existingStats) {\n      // If existing, merge\n      mergedStats = Metrics.mergeStats(existingStats, mergedStats)\n      // Attempt to delete from the old peers list just in case it was tracked there\n      this._oldPeers.delete(peerIdString)\n    }\n\n    this._peerStats.delete(placeholder.toB58String())\n    this._peerStats.set(peerIdString, mergedStats)\n    mergedStats.start()\n  }\n\n  /**\n   * Tracks data running through a given Duplex Iterable `stream`. If\n   * the `peerId` is not provided, a placeholder string will be created and\n   * returned. This allows lazy tracking of a peer when the peer is not yet known.\n   * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n   * with the placeholder string returned from here, and the known `PeerId`.\n   *\n   * @param {Object} options\n   * @param {MultiaddrConnection} options.stream - A duplex iterable stream\n   * @param {PeerId} [options.remotePeer] - The id of the remote peer that's connected\n   * @param {string} [options.protocol] - The protocol the stream is running\n   * @returns {MultiaddrConnection} The peerId string or placeholder string\n   */\n  trackStream ({ stream, remotePeer, protocol }) {\n    const metrics = this\n    const _source = stream.source\n    stream.source = tap(chunk => metrics._onMessage({\n      remotePeer,\n      protocol,\n      direction: 'in',\n      dataLength: chunk.length\n    }))(_source)\n\n    const _sink = stream.sink\n    stream.sink = source => {\n      return pipe(\n        source,\n        tap(chunk => metrics._onMessage({\n          remotePeer,\n          protocol,\n          direction: 'out',\n          dataLength: chunk.length\n        })),\n        _sink\n      )\n    }\n\n    return stream\n  }\n\n  /**\n   * Merges `other` into `target`. `target` will be modified\n   * and returned.\n   *\n   * @param {Stats} target\n   * @param {Stats} other\n   * @returns {Stats}\n   */\n  static mergeStats (target, other) {\n    target.stop()\n    other.stop()\n\n    // Merge queues\n    target._queue = [...target._queue, ...other._queue]\n\n    // TODO: how to merge moving averages?\n    return target\n  }\n}\n\nmodule.exports = Metrics\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}