{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst EventEmitter = require(\"eventemitter3\");\n\nconst p_timeout_1 = require(\"p-timeout\");\n\nconst priority_queue_1 = require(\"./priority-queue\"); // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\nconst empty = () => {};\n\nconst timeoutError = new p_timeout_1.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\n\nclass PQueue extends EventEmitter {\n  constructor(options) {\n    var _a, _b, _c, _d;\n\n    super();\n    this._intervalCount = 0;\n    this._intervalEnd = 0;\n    this._pendingCount = 0;\n    this._resolveEmpty = empty;\n    this._resolveIdle = empty; // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\n    options = Object.assign({\n      carryoverConcurrencyCount: false,\n      intervalCap: Infinity,\n      interval: 0,\n      concurrency: Infinity,\n      autoStart: true,\n      queueClass: priority_queue_1.default\n    }, options);\n\n    if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n      throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n    }\n\n    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n      throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n    }\n\n    this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n    this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n    this._intervalCap = options.intervalCap;\n    this._interval = options.interval;\n    this._queue = new options.queueClass();\n    this._queueClass = options.queueClass;\n    this.concurrency = options.concurrency;\n    this._timeout = options.timeout;\n    this._throwOnTimeout = options.throwOnTimeout === true;\n    this._isPaused = options.autoStart === false;\n  }\n\n  get _doesIntervalAllowAnother() {\n    return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n  }\n\n  get _doesConcurrentAllowAnother() {\n    return this._pendingCount < this._concurrency;\n  }\n\n  _next() {\n    this._pendingCount--;\n\n    this._tryToStartAnother();\n\n    this.emit('next');\n  }\n\n  _resolvePromises() {\n    this._resolveEmpty();\n\n    this._resolveEmpty = empty;\n\n    if (this._pendingCount === 0) {\n      this._resolveIdle();\n\n      this._resolveIdle = empty;\n      this.emit('idle');\n    }\n  }\n\n  _onResumeInterval() {\n    this._onInterval();\n\n    this._initializeIntervalIfNeeded();\n\n    this._timeoutId = undefined;\n  }\n\n  _isIntervalPaused() {\n    const now = Date.now();\n\n    if (this._intervalId === undefined) {\n      const delay = this._intervalEnd - now;\n\n      if (delay < 0) {\n        // Act as the interval was done\n        // We don't need to resume it here because it will be resumed on line 160\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n      } else {\n        // Act as the interval is pending\n        if (this._timeoutId === undefined) {\n          this._timeoutId = setTimeout(() => {\n            this._onResumeInterval();\n          }, delay);\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _tryToStartAnother() {\n    if (this._queue.size === 0) {\n      // We can clear the interval (\"pause\")\n      // Because we can redo it later (\"resume\")\n      if (this._intervalId) {\n        clearInterval(this._intervalId);\n      }\n\n      this._intervalId = undefined;\n\n      this._resolvePromises();\n\n      return false;\n    }\n\n    if (!this._isPaused) {\n      const canInitializeInterval = !this._isIntervalPaused();\n\n      if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n        const job = this._queue.dequeue();\n\n        if (!job) {\n          return false;\n        }\n\n        this.emit('active');\n        job();\n\n        if (canInitializeInterval) {\n          this._initializeIntervalIfNeeded();\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _initializeIntervalIfNeeded() {\n    if (this._isIntervalIgnored || this._intervalId !== undefined) {\n      return;\n    }\n\n    this._intervalId = setInterval(() => {\n      this._onInterval();\n    }, this._interval);\n    this._intervalEnd = Date.now() + this._interval;\n  }\n\n  _onInterval() {\n    if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n      clearInterval(this._intervalId);\n      this._intervalId = undefined;\n    }\n\n    this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n\n    this._processQueue();\n  }\n  /**\n  Executes all queued functions until it reaches the limit.\n  */\n\n\n  _processQueue() {\n    // eslint-disable-next-line no-empty\n    while (this._tryToStartAnother()) {}\n  }\n\n  get concurrency() {\n    return this._concurrency;\n  }\n\n  set concurrency(newConcurrency) {\n    if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n      throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n    }\n\n    this._concurrency = newConcurrency;\n\n    this._processQueue();\n  }\n  /**\n  Adds a sync or async task to the queue. Always returns a promise.\n  */\n\n\n  async add(fn) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise((resolve, reject) => {\n      const run = async () => {\n        this._pendingCount++;\n        this._intervalCount++;\n\n        try {\n          const operation = this._timeout === undefined && options.timeout === undefined ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === undefined ? this._timeout : options.timeout, () => {\n            if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n              reject(timeoutError);\n            }\n\n            return undefined;\n          });\n          resolve(await operation);\n        } catch (error) {\n          reject(error);\n        }\n\n        this._next();\n      };\n\n      this._queue.enqueue(run, options);\n\n      this._tryToStartAnother();\n\n      this.emit('add');\n    });\n  }\n  /**\n  Same as `.add()`, but accepts an array of sync or async functions.\n   @returns A promise that resolves when all functions are resolved.\n  */\n\n\n  async addAll(functions, options) {\n    return Promise.all(functions.map(async function_ => this.add(function_, options)));\n  }\n  /**\n  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n  */\n\n\n  start() {\n    if (!this._isPaused) {\n      return this;\n    }\n\n    this._isPaused = false;\n\n    this._processQueue();\n\n    return this;\n  }\n  /**\n  Put queue execution on hold.\n  */\n\n\n  pause() {\n    this._isPaused = true;\n  }\n  /**\n  Clear the queue.\n  */\n\n\n  clear() {\n    this._queue = new this._queueClass();\n  }\n  /**\n  Can be called multiple times. Useful if you for example add additional items at a later time.\n   @returns A promise that settles when the queue becomes empty.\n  */\n\n\n  async onEmpty() {\n    // Instantly resolve if the queue is empty\n    if (this._queue.size === 0) {\n      return;\n    }\n\n    return new Promise(resolve => {\n      const existingResolve = this._resolveEmpty;\n\n      this._resolveEmpty = () => {\n        existingResolve();\n        resolve();\n      };\n    });\n  }\n  /**\n  The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n   @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n  */\n\n\n  async onIdle() {\n    // Instantly resolve if none pending and if nothing else is queued\n    if (this._pendingCount === 0 && this._queue.size === 0) {\n      return;\n    }\n\n    return new Promise(resolve => {\n      const existingResolve = this._resolveIdle;\n\n      this._resolveIdle = () => {\n        existingResolve();\n        resolve();\n      };\n    });\n  }\n  /**\n  Size of the queue.\n  */\n\n\n  get size() {\n    return this._queue.size;\n  }\n  /**\n  Size of the queue, filtered by the given options.\n   For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n  */\n\n\n  sizeBy(options) {\n    // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n    return this._queue.filter(options).length;\n  }\n  /**\n  Number of pending promises.\n  */\n\n\n  get pending() {\n    return this._pendingCount;\n  }\n  /**\n  Whether the queue is currently paused.\n  */\n\n\n  get isPaused() {\n    return this._isPaused;\n  }\n\n  get timeout() {\n    return this._timeout;\n  }\n  /**\n  Set the timeout for future operations.\n  */\n\n\n  set timeout(milliseconds) {\n    this._timeout = milliseconds;\n  }\n\n}\n\nexports.default = PQueue;","map":{"version":3,"names":["Object","defineProperty","exports","value","EventEmitter","require","p_timeout_1","priority_queue_1","empty","timeoutError","TimeoutError","PQueue","constructor","options","_a","_b","_c","_d","_intervalCount","_intervalEnd","_pendingCount","_resolveEmpty","_resolveIdle","assign","carryoverConcurrencyCount","intervalCap","Infinity","interval","concurrency","autoStart","queueClass","default","TypeError","toString","undefined","Number","isFinite","_carryoverConcurrencyCount","_isIntervalIgnored","_intervalCap","_interval","_queue","_queueClass","_timeout","timeout","_throwOnTimeout","throwOnTimeout","_isPaused","_doesIntervalAllowAnother","_doesConcurrentAllowAnother","_concurrency","_next","_tryToStartAnother","emit","_resolvePromises","_onResumeInterval","_onInterval","_initializeIntervalIfNeeded","_timeoutId","_isIntervalPaused","now","Date","_intervalId","delay","setTimeout","size","clearInterval","canInitializeInterval","job","dequeue","setInterval","_processQueue","newConcurrency","add","fn","Promise","resolve","reject","run","operation","error","enqueue","addAll","functions","all","map","function_","start","pause","clear","onEmpty","existingResolve","onIdle","sizeBy","filter","length","pending","isPaused","milliseconds"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/p-queue/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EventEmitter = require(\"eventemitter3\");\nconst p_timeout_1 = require(\"p-timeout\");\nconst priority_queue_1 = require(\"./priority-queue\");\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst empty = () => { };\nconst timeoutError = new p_timeout_1.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        this._intervalCount = 0;\n        this._intervalEnd = 0;\n        this._pendingCount = 0;\n        this._resolveEmpty = empty;\n        this._resolveIdle = empty;\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n        this._intervalCap = options.intervalCap;\n        this._interval = options.interval;\n        this._queue = new options.queueClass();\n        this._queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this._timeout = options.timeout;\n        this._throwOnTimeout = options.throwOnTimeout === true;\n        this._isPaused = options.autoStart === false;\n    }\n    get _doesIntervalAllowAnother() {\n        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n    get _doesConcurrentAllowAnother() {\n        return this._pendingCount < this._concurrency;\n    }\n    _next() {\n        this._pendingCount--;\n        this._tryToStartAnother();\n        this.emit('next');\n    }\n    _resolvePromises() {\n        this._resolveEmpty();\n        this._resolveEmpty = empty;\n        if (this._pendingCount === 0) {\n            this._resolveIdle();\n            this._resolveIdle = empty;\n            this.emit('idle');\n        }\n    }\n    _onResumeInterval() {\n        this._onInterval();\n        this._initializeIntervalIfNeeded();\n        this._timeoutId = undefined;\n    }\n    _isIntervalPaused() {\n        const now = Date.now();\n        if (this._intervalId === undefined) {\n            const delay = this._intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this._timeoutId === undefined) {\n                    this._timeoutId = setTimeout(() => {\n                        this._onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _tryToStartAnother() {\n        if (this._queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this._intervalId) {\n                clearInterval(this._intervalId);\n            }\n            this._intervalId = undefined;\n            this._resolvePromises();\n            return false;\n        }\n        if (!this._isPaused) {\n            const canInitializeInterval = !this._isIntervalPaused();\n            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n                const job = this._queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this._initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _initializeIntervalIfNeeded() {\n        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n            return;\n        }\n        this._intervalId = setInterval(() => {\n            this._onInterval();\n        }, this._interval);\n        this._intervalEnd = Date.now() + this._interval;\n    }\n    _onInterval() {\n        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n        }\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    _processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this._tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this._concurrency = newConcurrency;\n        this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n    async add(fn, options = {}) {\n        return new Promise((resolve, reject) => {\n            const run = async () => {\n                this._pendingCount++;\n                this._intervalCount++;\n                try {\n                    const operation = (this._timeout === undefined && options.timeout === undefined) ? fn() : p_timeout_1.default(Promise.resolve(fn()), (options.timeout === undefined ? this._timeout : options.timeout), () => {\n                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                            reject(timeoutError);\n                        }\n                        return undefined;\n                    });\n                    resolve(await operation);\n                }\n                catch (error) {\n                    reject(error);\n                }\n                this._next();\n            };\n            this._queue.enqueue(run, options);\n            this._tryToStartAnother();\n            this.emit('add');\n        });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n\n    @returns A promise that resolves when all functions are resolved.\n    */\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this._isPaused) {\n            return this;\n        }\n        this._isPaused = false;\n        this._processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveEmpty;\n            this._resolveEmpty = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this._pendingCount === 0 && this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveIdle;\n            this._resolveIdle = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    Size of the queue.\n    */\n    get size() {\n        return this._queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        return this._queue.filter(options).length;\n    }\n    /**\n    Number of pending promises.\n    */\n    get pending() {\n        return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this._isPaused;\n    }\n    get timeout() {\n        return this._timeout;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n    set timeout(milliseconds) {\n        this._timeout = milliseconds;\n    }\n}\nexports.default = PQueue;\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,YAAY,GAAGC,OAAO,CAAC,eAAD,CAA5B;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,WAAD,CAA3B;;AACA,MAAME,gBAAgB,GAAGF,OAAO,CAAC,kBAAD,CAAhC,C,CACA;;;AACA,MAAMG,KAAK,GAAG,MAAM,CAAG,CAAvB;;AACA,MAAMC,YAAY,GAAG,IAAIH,WAAW,CAACI,YAAhB,EAArB;AACA;AACA;AACA;;AACA,MAAMC,MAAN,SAAqBP,YAArB,CAAkC;EAC9BQ,WAAW,CAACC,OAAD,EAAU;IACjB,IAAIC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB;;IACA;IACA,KAAKC,cAAL,GAAsB,CAAtB;IACA,KAAKC,YAAL,GAAoB,CAApB;IACA,KAAKC,aAAL,GAAqB,CAArB;IACA,KAAKC,aAAL,GAAqBb,KAArB;IACA,KAAKc,YAAL,GAAoBd,KAApB,CAPiB,CAQjB;;IACAK,OAAO,GAAGb,MAAM,CAACuB,MAAP,CAAc;MAAEC,yBAAyB,EAAE,KAA7B;MAAoCC,WAAW,EAAEC,QAAjD;MAA2DC,QAAQ,EAAE,CAArE;MAAwEC,WAAW,EAAEF,QAArF;MAA+FG,SAAS,EAAE,IAA1G;MAAgHC,UAAU,EAAEvB,gBAAgB,CAACwB;IAA7I,CAAd,EAAsKlB,OAAtK,CAAV;;IACA,IAAI,EAAE,OAAOA,OAAO,CAACY,WAAf,KAA+B,QAA/B,IAA2CZ,OAAO,CAACY,WAAR,IAAuB,CAApE,CAAJ,EAA4E;MACxE,MAAM,IAAIO,SAAJ,CAAe,gEAA+D,CAACjB,EAAE,GAAG,CAACD,EAAE,GAAGD,OAAO,CAACY,WAAd,MAA+B,IAA/B,IAAuCX,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAACmB,QAAH,EAAtE,MAAyF,IAAzF,IAAiGlB,EAAE,KAAK,KAAK,CAA7G,GAAiHA,EAAjH,GAAsH,EAAG,OAAM,OAAOF,OAAO,CAACY,WAAY,GAAxO,CAAN;IACH;;IACD,IAAIZ,OAAO,CAACc,QAAR,KAAqBO,SAArB,IAAkC,EAAEC,MAAM,CAACC,QAAP,CAAgBvB,OAAO,CAACc,QAAxB,KAAqCd,OAAO,CAACc,QAAR,IAAoB,CAA3D,CAAtC,EAAqG;MACjG,MAAM,IAAIK,SAAJ,CAAe,2DAA0D,CAACf,EAAE,GAAG,CAACD,EAAE,GAAGH,OAAO,CAACc,QAAd,MAA4B,IAA5B,IAAoCX,EAAE,KAAK,KAAK,CAAhD,GAAoD,KAAK,CAAzD,GAA6DA,EAAE,CAACiB,QAAH,EAAnE,MAAsF,IAAtF,IAA8FhB,EAAE,KAAK,KAAK,CAA1G,GAA8GA,EAA9G,GAAmH,EAAG,OAAM,OAAOJ,OAAO,CAACc,QAAS,GAA7N,CAAN;IACH;;IACD,KAAKU,0BAAL,GAAkCxB,OAAO,CAACW,yBAA1C;IACA,KAAKc,kBAAL,GAA0BzB,OAAO,CAACY,WAAR,KAAwBC,QAAxB,IAAoCb,OAAO,CAACc,QAAR,KAAqB,CAAnF;IACA,KAAKY,YAAL,GAAoB1B,OAAO,CAACY,WAA5B;IACA,KAAKe,SAAL,GAAiB3B,OAAO,CAACc,QAAzB;IACA,KAAKc,MAAL,GAAc,IAAI5B,OAAO,CAACiB,UAAZ,EAAd;IACA,KAAKY,WAAL,GAAmB7B,OAAO,CAACiB,UAA3B;IACA,KAAKF,WAAL,GAAmBf,OAAO,CAACe,WAA3B;IACA,KAAKe,QAAL,GAAgB9B,OAAO,CAAC+B,OAAxB;IACA,KAAKC,eAAL,GAAuBhC,OAAO,CAACiC,cAAR,KAA2B,IAAlD;IACA,KAAKC,SAAL,GAAiBlC,OAAO,CAACgB,SAAR,KAAsB,KAAvC;EACH;;EAC4B,IAAzBmB,yBAAyB,GAAG;IAC5B,OAAO,KAAKV,kBAAL,IAA2B,KAAKpB,cAAL,GAAsB,KAAKqB,YAA7D;EACH;;EAC8B,IAA3BU,2BAA2B,GAAG;IAC9B,OAAO,KAAK7B,aAAL,GAAqB,KAAK8B,YAAjC;EACH;;EACDC,KAAK,GAAG;IACJ,KAAK/B,aAAL;;IACA,KAAKgC,kBAAL;;IACA,KAAKC,IAAL,CAAU,MAAV;EACH;;EACDC,gBAAgB,GAAG;IACf,KAAKjC,aAAL;;IACA,KAAKA,aAAL,GAAqBb,KAArB;;IACA,IAAI,KAAKY,aAAL,KAAuB,CAA3B,EAA8B;MAC1B,KAAKE,YAAL;;MACA,KAAKA,YAAL,GAAoBd,KAApB;MACA,KAAK6C,IAAL,CAAU,MAAV;IACH;EACJ;;EACDE,iBAAiB,GAAG;IAChB,KAAKC,WAAL;;IACA,KAAKC,2BAAL;;IACA,KAAKC,UAAL,GAAkBxB,SAAlB;EACH;;EACDyB,iBAAiB,GAAG;IAChB,MAAMC,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAZ;;IACA,IAAI,KAAKE,WAAL,KAAqB5B,SAAzB,EAAoC;MAChC,MAAM6B,KAAK,GAAG,KAAK5C,YAAL,GAAoByC,GAAlC;;MACA,IAAIG,KAAK,GAAG,CAAZ,EAAe;QACX;QACA;QACA,KAAK7C,cAAL,GAAuB,KAAKmB,0BAAN,GAAoC,KAAKjB,aAAzC,GAAyD,CAA/E;MACH,CAJD,MAKK;QACD;QACA,IAAI,KAAKsC,UAAL,KAAoBxB,SAAxB,EAAmC;UAC/B,KAAKwB,UAAL,GAAkBM,UAAU,CAAC,MAAM;YAC/B,KAAKT,iBAAL;UACH,CAF2B,EAEzBQ,KAFyB,CAA5B;QAGH;;QACD,OAAO,IAAP;MACH;IACJ;;IACD,OAAO,KAAP;EACH;;EACDX,kBAAkB,GAAG;IACjB,IAAI,KAAKX,MAAL,CAAYwB,IAAZ,KAAqB,CAAzB,EAA4B;MACxB;MACA;MACA,IAAI,KAAKH,WAAT,EAAsB;QAClBI,aAAa,CAAC,KAAKJ,WAAN,CAAb;MACH;;MACD,KAAKA,WAAL,GAAmB5B,SAAnB;;MACA,KAAKoB,gBAAL;;MACA,OAAO,KAAP;IACH;;IACD,IAAI,CAAC,KAAKP,SAAV,EAAqB;MACjB,MAAMoB,qBAAqB,GAAG,CAAC,KAAKR,iBAAL,EAA/B;;MACA,IAAI,KAAKX,yBAAL,IAAkC,KAAKC,2BAA3C,EAAwE;QACpE,MAAMmB,GAAG,GAAG,KAAK3B,MAAL,CAAY4B,OAAZ,EAAZ;;QACA,IAAI,CAACD,GAAL,EAAU;UACN,OAAO,KAAP;QACH;;QACD,KAAKf,IAAL,CAAU,QAAV;QACAe,GAAG;;QACH,IAAID,qBAAJ,EAA2B;UACvB,KAAKV,2BAAL;QACH;;QACD,OAAO,IAAP;MACH;IACJ;;IACD,OAAO,KAAP;EACH;;EACDA,2BAA2B,GAAG;IAC1B,IAAI,KAAKnB,kBAAL,IAA2B,KAAKwB,WAAL,KAAqB5B,SAApD,EAA+D;MAC3D;IACH;;IACD,KAAK4B,WAAL,GAAmBQ,WAAW,CAAC,MAAM;MACjC,KAAKd,WAAL;IACH,CAF6B,EAE3B,KAAKhB,SAFsB,CAA9B;IAGA,KAAKrB,YAAL,GAAoB0C,IAAI,CAACD,GAAL,KAAa,KAAKpB,SAAtC;EACH;;EACDgB,WAAW,GAAG;IACV,IAAI,KAAKtC,cAAL,KAAwB,CAAxB,IAA6B,KAAKE,aAAL,KAAuB,CAApD,IAAyD,KAAK0C,WAAlE,EAA+E;MAC3EI,aAAa,CAAC,KAAKJ,WAAN,CAAb;MACA,KAAKA,WAAL,GAAmB5B,SAAnB;IACH;;IACD,KAAKhB,cAAL,GAAsB,KAAKmB,0BAAL,GAAkC,KAAKjB,aAAvC,GAAuD,CAA7E;;IACA,KAAKmD,aAAL;EACH;EACD;AACJ;AACA;;;EACIA,aAAa,GAAG;IACZ;IACA,OAAO,KAAKnB,kBAAL,EAAP,EAAkC,CAAG;EACxC;;EACc,IAAXxB,WAAW,GAAG;IACd,OAAO,KAAKsB,YAAZ;EACH;;EACc,IAAXtB,WAAW,CAAC4C,cAAD,EAAiB;IAC5B,IAAI,EAAE,OAAOA,cAAP,KAA0B,QAA1B,IAAsCA,cAAc,IAAI,CAA1D,CAAJ,EAAkE;MAC9D,MAAM,IAAIxC,SAAJ,CAAe,gEAA+DwC,cAAe,OAAM,OAAOA,cAAe,GAAzH,CAAN;IACH;;IACD,KAAKtB,YAAL,GAAoBsB,cAApB;;IACA,KAAKD,aAAL;EACH;EACD;AACJ;AACA;;;EACa,MAAHE,GAAG,CAACC,EAAD,EAAmB;IAAA,IAAd7D,OAAc,uEAAJ,EAAI;IACxB,OAAO,IAAI8D,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;MACpC,MAAMC,GAAG,GAAG,YAAY;QACpB,KAAK1D,aAAL;QACA,KAAKF,cAAL;;QACA,IAAI;UACA,MAAM6D,SAAS,GAAI,KAAKpC,QAAL,KAAkBT,SAAlB,IAA+BrB,OAAO,CAAC+B,OAAR,KAAoBV,SAApD,GAAiEwC,EAAE,EAAnE,GAAwEpE,WAAW,CAACyB,OAAZ,CAAoB4C,OAAO,CAACC,OAAR,CAAgBF,EAAE,EAAlB,CAApB,EAA4C7D,OAAO,CAAC+B,OAAR,KAAoBV,SAApB,GAAgC,KAAKS,QAArC,GAAgD9B,OAAO,CAAC+B,OAApG,EAA8G,MAAM;YAC1M,IAAI/B,OAAO,CAACiC,cAAR,KAA2BZ,SAA3B,GAAuC,KAAKW,eAA5C,GAA8DhC,OAAO,CAACiC,cAA1E,EAA0F;cACtF+B,MAAM,CAACpE,YAAD,CAAN;YACH;;YACD,OAAOyB,SAAP;UACH,CALyF,CAA1F;UAMA0C,OAAO,CAAC,MAAMG,SAAP,CAAP;QACH,CARD,CASA,OAAOC,KAAP,EAAc;UACVH,MAAM,CAACG,KAAD,CAAN;QACH;;QACD,KAAK7B,KAAL;MACH,CAhBD;;MAiBA,KAAKV,MAAL,CAAYwC,OAAZ,CAAoBH,GAApB,EAAyBjE,OAAzB;;MACA,KAAKuC,kBAAL;;MACA,KAAKC,IAAL,CAAU,KAAV;IACH,CArBM,CAAP;EAsBH;EACD;AACJ;AACA;AACA;;;EAEgB,MAAN6B,MAAM,CAACC,SAAD,EAAYtE,OAAZ,EAAqB;IAC7B,OAAO8D,OAAO,CAACS,GAAR,CAAYD,SAAS,CAACE,GAAV,CAAc,MAAOC,SAAP,IAAqB,KAAKb,GAAL,CAASa,SAAT,EAAoBzE,OAApB,CAAnC,CAAZ,CAAP;EACH;EACD;AACJ;AACA;;;EACI0E,KAAK,GAAG;IACJ,IAAI,CAAC,KAAKxC,SAAV,EAAqB;MACjB,OAAO,IAAP;IACH;;IACD,KAAKA,SAAL,GAAiB,KAAjB;;IACA,KAAKwB,aAAL;;IACA,OAAO,IAAP;EACH;EACD;AACJ;AACA;;;EACIiB,KAAK,GAAG;IACJ,KAAKzC,SAAL,GAAiB,IAAjB;EACH;EACD;AACJ;AACA;;;EACI0C,KAAK,GAAG;IACJ,KAAKhD,MAAL,GAAc,IAAI,KAAKC,WAAT,EAAd;EACH;EACD;AACJ;AACA;AACA;;;EAEiB,MAAPgD,OAAO,GAAG;IACZ;IACA,IAAI,KAAKjD,MAAL,CAAYwB,IAAZ,KAAqB,CAAzB,EAA4B;MACxB;IACH;;IACD,OAAO,IAAIU,OAAJ,CAAYC,OAAO,IAAI;MAC1B,MAAMe,eAAe,GAAG,KAAKtE,aAA7B;;MACA,KAAKA,aAAL,GAAqB,MAAM;QACvBsE,eAAe;QACff,OAAO;MACV,CAHD;IAIH,CANM,CAAP;EAOH;EACD;AACJ;AACA;AACA;;;EAEgB,MAANgB,MAAM,GAAG;IACX;IACA,IAAI,KAAKxE,aAAL,KAAuB,CAAvB,IAA4B,KAAKqB,MAAL,CAAYwB,IAAZ,KAAqB,CAArD,EAAwD;MACpD;IACH;;IACD,OAAO,IAAIU,OAAJ,CAAYC,OAAO,IAAI;MAC1B,MAAMe,eAAe,GAAG,KAAKrE,YAA7B;;MACA,KAAKA,YAAL,GAAoB,MAAM;QACtBqE,eAAe;QACff,OAAO;MACV,CAHD;IAIH,CANM,CAAP;EAOH;EACD;AACJ;AACA;;;EACY,IAAJX,IAAI,GAAG;IACP,OAAO,KAAKxB,MAAL,CAAYwB,IAAnB;EACH;EACD;AACJ;AACA;AACA;;;EAEI4B,MAAM,CAAChF,OAAD,EAAU;IACZ;IACA,OAAO,KAAK4B,MAAL,CAAYqD,MAAZ,CAAmBjF,OAAnB,EAA4BkF,MAAnC;EACH;EACD;AACJ;AACA;;;EACe,IAAPC,OAAO,GAAG;IACV,OAAO,KAAK5E,aAAZ;EACH;EACD;AACJ;AACA;;;EACgB,IAAR6E,QAAQ,GAAG;IACX,OAAO,KAAKlD,SAAZ;EACH;;EACU,IAAPH,OAAO,GAAG;IACV,OAAO,KAAKD,QAAZ;EACH;EACD;AACJ;AACA;;;EACe,IAAPC,OAAO,CAACsD,YAAD,EAAe;IACtB,KAAKvD,QAAL,GAAgBuD,YAAhB;EACH;;AAzQ6B;;AA2QlChG,OAAO,CAAC6B,OAAR,GAAkBpB,MAAlB"},"metadata":{},"sourceType":"script"}