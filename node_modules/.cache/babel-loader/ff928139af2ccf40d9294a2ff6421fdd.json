{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('libp2p:identify'), {\n  error: debug('libp2p:identify:err')\n});\n\nvar errCode = require('err-code');\n\nvar lp = require('it-length-prefixed');\n\nvar _require = require('it-pipe'),\n    pipe = _require.pipe;\n\nvar _require2 = require('streaming-iterables'),\n    collect = _require2.collect,\n    take = _require2.take,\n    consume = _require2.consume;\n\nvar _require3 = require('uint8arrays/from-string'),\n    uint8ArrayFromString = _require3.fromString;\n\nvar PeerId = require('peer-id');\n\nvar _require4 = require('multiaddr'),\n    Multiaddr = _require4.Multiaddr; // @ts-ignore it-buffer does not have types\n\n\nvar _require5 = require('it-buffer'),\n    toBuffer = _require5.toBuffer;\n\nvar Message = require('./message');\n\nvar Envelope = require('../record/envelope');\n\nvar PeerRecord = require('../record/peer-record');\n\nvar _require6 = require('./consts'),\n    MULTICODEC_IDENTIFY = _require6.MULTICODEC_IDENTIFY,\n    MULTICODEC_IDENTIFY_PUSH = _require6.MULTICODEC_IDENTIFY_PUSH,\n    IDENTIFY_PROTOCOL_VERSION = _require6.IDENTIFY_PROTOCOL_VERSION,\n    MULTICODEC_IDENTIFY_PROTOCOL_NAME = _require6.MULTICODEC_IDENTIFY_PROTOCOL_NAME,\n    MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = _require6.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,\n    MULTICODEC_IDENTIFY_PROTOCOL_VERSION = _require6.MULTICODEC_IDENTIFY_PROTOCOL_VERSION,\n    MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = _require6.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION;\n\nvar _require7 = require('../errors'),\n    codes = _require7.codes;\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n */\n\n/**\n * @typedef {Object} HostProperties\n * @property {string} agentVersion\n */\n\n\nvar IdentifyService = /*#__PURE__*/function () {\n  /**\n   * @class\n   * @param {Object} options\n   * @param {import('../')} options.libp2p\n   */\n  function IdentifyService(_ref) {\n    var _this = this;\n\n    var libp2p = _ref.libp2p;\n\n    _classCallCheck(this, IdentifyService);\n\n    this._libp2p = libp2p;\n    this.peerStore = libp2p.peerStore;\n    this.addressManager = libp2p.addressManager;\n    this.connectionManager = libp2p.connectionManager;\n    this.peerId = libp2p.peerId;\n    this.handleMessage = this.handleMessage.bind(this);\n    var protocolStr = IdentifyService.getProtocolStr(libp2p);\n    this.identifyProtocolStr = protocolStr.identifyProtocolStr;\n    this.identifyPushProtocolStr = protocolStr.identifyPushProtocolStr; // Store self host metadata\n\n    this._host = _objectSpread({\n      protocolVersion: \"\".concat(libp2p._config.protocolPrefix, \"/\").concat(IDENTIFY_PROTOCOL_VERSION)\n    }, libp2p._options.host);\n    this.peerStore.metadataBook.set(this.peerId, 'AgentVersion', uint8ArrayFromString(this._host.agentVersion));\n    this.peerStore.metadataBook.set(this.peerId, 'ProtocolVersion', uint8ArrayFromString(this._host.protocolVersion)); // When a new connection happens, trigger identify\n\n    this.connectionManager.on('peer:connect', function (connection) {\n      _this.identify(connection).catch(log.error);\n    }); // When self multiaddrs change, trigger identify-push\n\n    this.peerStore.on('change:multiaddrs', function (_ref2) {\n      var peerId = _ref2.peerId;\n\n      if (peerId.toString() === _this.peerId.toString()) {\n        _this.pushToPeerStore();\n      }\n    }); // When self protocols change, trigger identify-push\n\n    this.peerStore.on('change:protocols', function (_ref3) {\n      var peerId = _ref3.peerId;\n\n      if (peerId.toString() === _this.peerId.toString()) {\n        _this.pushToPeerStore();\n      }\n    });\n  }\n  /**\n   * Send an Identify Push update to the list of connections\n   *\n   * @param {Connection[]} connections\n   * @returns {Promise<void[]>}\n   */\n\n\n  _createClass(IdentifyService, [{\n    key: \"push\",\n    value: function () {\n      var _push = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(connections) {\n        var _this2 = this;\n\n        var signedPeerRecord, listenAddrs, protocols, pushes;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.peerStore.addressBook.getRawEnvelope(this.peerId);\n\n              case 2:\n                signedPeerRecord = _context2.sent;\n                listenAddrs = this._libp2p.multiaddrs.map(function (ma) {\n                  return ma.bytes;\n                });\n                protocols = this.peerStore.protoBook.get(this.peerId) || [];\n                pushes = connections.map( /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(connection) {\n                    var _yield$connection$new, stream;\n\n                    return _regeneratorRuntime().wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.prev = 0;\n                            _context.next = 3;\n                            return connection.newStream(_this2.identifyPushProtocolStr);\n\n                          case 3:\n                            _yield$connection$new = _context.sent;\n                            stream = _yield$connection$new.stream;\n                            _context.next = 7;\n                            return pipe([Message.Identify.encode({\n                              listenAddrs: listenAddrs,\n                              signedPeerRecord: signedPeerRecord,\n                              protocols: protocols\n                            }).finish()], lp.encode(), stream, consume);\n\n                          case 7:\n                            _context.next = 12;\n                            break;\n\n                          case 9:\n                            _context.prev = 9;\n                            _context.t0 = _context[\"catch\"](0);\n                            // Just log errors\n                            log.error('could not push identify update to peer', _context.t0);\n\n                          case 12:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, null, [[0, 9]]);\n                  }));\n\n                  return function (_x2) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }());\n                return _context2.abrupt(\"return\", Promise.all(pushes));\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function push(_x) {\n        return _push.apply(this, arguments);\n      }\n\n      return push;\n    }()\n    /**\n     * Calls `push` for all peers in the `peerStore` that are connected\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"pushToPeerStore\",\n    value: function pushToPeerStore() {\n      // Do not try to push if libp2p node is not running\n      if (!this._libp2p.isStarted()) {\n        return;\n      }\n\n      var connections = [];\n      var connection;\n\n      var _iterator = _createForOfIteratorHelper(this.peerStore.peers.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var peer = _step.value;\n\n          if (peer.protocols.includes(this.identifyPushProtocolStr) && (connection = this.connectionManager.get(peer.id))) {\n            connections.push(connection);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.push(connections);\n    }\n    /**\n     * Requests the `Identify` message from peer associated with the given `connection`.\n     * If the identified peer does not match the `PeerId` associated with the connection,\n     * an error will be thrown.\n     *\n     * @async\n     * @param {Connection} connection\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"identify\",\n    value: function () {\n      var _identify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(connection) {\n        var _yield$connection$new2, stream, _yield$pipe, _yield$pipe2, data, message, _message, publicKey, listenAddrs, protocols, observedAddr, signedPeerRecord, id, cleanObservedAddr, envelope;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return connection.newStream(this.identifyProtocolStr);\n\n              case 2:\n                _yield$connection$new2 = _context3.sent;\n                stream = _yield$connection$new2.stream;\n                _context3.next = 6;\n                return pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n\n              case 6:\n                _yield$pipe = _context3.sent;\n                _yield$pipe2 = _slicedToArray(_yield$pipe, 1);\n                data = _yield$pipe2[0];\n\n                if (data) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED);\n\n              case 11:\n                _context3.prev = 11;\n                message = Message.Identify.decode(data);\n                _context3.next = 18;\n                break;\n\n              case 15:\n                _context3.prev = 15;\n                _context3.t0 = _context3[\"catch\"](11);\n                throw errCode(_context3.t0, codes.ERR_INVALID_MESSAGE);\n\n              case 18:\n                _message = message, publicKey = _message.publicKey, listenAddrs = _message.listenAddrs, protocols = _message.protocols, observedAddr = _message.observedAddr, signedPeerRecord = _message.signedPeerRecord;\n                _context3.next = 21;\n                return PeerId.createFromPubKey(publicKey);\n\n              case 21:\n                id = _context3.sent;\n\n                if (!(connection.remotePeer.toB58String() !== id.toB58String())) {\n                  _context3.next = 24;\n                  break;\n                }\n\n                throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n\n              case 24:\n                // Get the observedAddr if there is one\n                cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);\n                _context3.prev = 25;\n                _context3.next = 28;\n                return Envelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN);\n\n              case 28:\n                envelope = _context3.sent;\n\n                if (!this.peerStore.addressBook.consumePeerRecord(envelope)) {\n                  _context3.next = 34;\n                  break;\n                }\n\n                this.peerStore.protoBook.set(id, protocols);\n                this.peerStore.metadataBook.set(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion));\n                this.peerStore.metadataBook.set(id, 'ProtocolVersion', uint8ArrayFromString(message.protocolVersion));\n                return _context3.abrupt(\"return\");\n\n              case 34:\n                _context3.next = 39;\n                break;\n\n              case 36:\n                _context3.prev = 36;\n                _context3.t1 = _context3[\"catch\"](25);\n                log('received invalid envelope, discard it and fallback to listenAddrs is available', _context3.t1);\n\n              case 39:\n                // LEGACY: Update peers data in PeerStore\n                try {\n                  this.peerStore.addressBook.set(id, listenAddrs.map(function (addr) {\n                    return new Multiaddr(addr);\n                  }));\n                } catch (err) {\n                  log.error('received invalid addrs', err);\n                }\n\n                this.peerStore.protoBook.set(id, protocols);\n                this.peerStore.metadataBook.set(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion));\n                this.peerStore.metadataBook.set(id, 'ProtocolVersion', uint8ArrayFromString(message.protocolVersion)); // TODO: Add and score our observed addr\n\n                log('received observed address of %s', cleanObservedAddr); // this.addressManager.addObservedAddr(observedAddr)\n\n              case 44:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[11, 15], [25, 36]]);\n      }));\n\n      function identify(_x3) {\n        return _identify.apply(this, arguments);\n      }\n\n      return identify;\n    }()\n    /**\n     * A handler to register with Libp2p to process identify messages.\n     *\n     * @param {Object} options\n     * @param {Connection} options.connection\n     * @param {MuxedStream} options.stream\n     * @param {string} options.protocol\n     * @returns {Promise<void>|undefined}\n     */\n\n  }, {\n    key: \"handleMessage\",\n    value: function handleMessage(_ref5) {\n      var connection = _ref5.connection,\n          stream = _ref5.stream,\n          protocol = _ref5.protocol;\n\n      switch (protocol) {\n        case this.identifyProtocolStr:\n          return this._handleIdentify({\n            connection: connection,\n            stream: stream\n          });\n\n        case this.identifyPushProtocolStr:\n          return this._handlePush({\n            connection: connection,\n            stream: stream\n          });\n\n        default:\n          log.error('cannot handle unknown protocol %s', protocol);\n      }\n    }\n    /**\n     * Sends the `Identify` response with the Signed Peer Record\n     * to the requesting peer over the given `connection`\n     *\n     * @private\n     * @param {Object} options\n     * @param {MuxedStream} options.stream\n     * @param {Connection} options.connection\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_handleIdentify\",\n    value: function () {\n      var _handleIdentify2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref6) {\n        var connection, stream, publicKey, signedPeerRecord, protocols, message;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                connection = _ref6.connection, stream = _ref6.stream;\n                publicKey = new Uint8Array(0);\n\n                if (this.peerId.pubKey) {\n                  publicKey = this.peerId.pubKey.bytes;\n                }\n\n                _context4.next = 5;\n                return this.peerStore.addressBook.getRawEnvelope(this.peerId);\n\n              case 5:\n                signedPeerRecord = _context4.sent;\n                protocols = this.peerStore.protoBook.get(this.peerId) || [];\n                message = Message.Identify.encode({\n                  protocolVersion: this._host.protocolVersion,\n                  agentVersion: this._host.agentVersion,\n                  publicKey: publicKey,\n                  listenAddrs: this._libp2p.multiaddrs.map(function (ma) {\n                    return ma.bytes;\n                  }),\n                  signedPeerRecord: signedPeerRecord,\n                  observedAddr: connection.remoteAddr.bytes,\n                  protocols: protocols\n                }).finish();\n                _context4.prev = 8;\n                _context4.next = 11;\n                return pipe([message], lp.encode(), stream, consume);\n\n              case 11:\n                _context4.next = 16;\n                break;\n\n              case 13:\n                _context4.prev = 13;\n                _context4.t0 = _context4[\"catch\"](8);\n                log.error('could not respond to identify request', _context4.t0);\n\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[8, 13]]);\n      }));\n\n      function _handleIdentify(_x4) {\n        return _handleIdentify2.apply(this, arguments);\n      }\n\n      return _handleIdentify;\n    }()\n    /**\n     * Reads the Identify Push message from the given `connection`\n     *\n     * @private\n     * @param {object} options\n     * @param {MuxedStream} options.stream\n     * @param {Connection} options.connection\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_handlePush\",\n    value: function () {\n      var _handlePush2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref7) {\n        var connection, stream, message, _yield$pipe3, _yield$pipe4, data, id, envelope;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                connection = _ref7.connection, stream = _ref7.stream;\n                _context5.prev = 1;\n                _context5.next = 4;\n                return pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n\n              case 4:\n                _yield$pipe3 = _context5.sent;\n                _yield$pipe4 = _slicedToArray(_yield$pipe3, 1);\n                data = _yield$pipe4[0];\n                message = Message.Identify.decode(data);\n                _context5.next = 13;\n                break;\n\n              case 10:\n                _context5.prev = 10;\n                _context5.t0 = _context5[\"catch\"](1);\n                return _context5.abrupt(\"return\", log.error('received invalid message', _context5.t0));\n\n              case 13:\n                id = connection.remotePeer;\n                _context5.prev = 14;\n                _context5.next = 17;\n                return Envelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN);\n\n              case 17:\n                envelope = _context5.sent;\n\n                if (!this.peerStore.addressBook.consumePeerRecord(envelope)) {\n                  _context5.next = 21;\n                  break;\n                }\n\n                this.peerStore.protoBook.set(id, message.protocols);\n                return _context5.abrupt(\"return\");\n\n              case 21:\n                _context5.next = 26;\n                break;\n\n              case 23:\n                _context5.prev = 23;\n                _context5.t1 = _context5[\"catch\"](14);\n                log('received invalid envelope, discard it and fallback to listenAddrs is available', _context5.t1);\n\n              case 26:\n                // LEGACY: Update peers data in PeerStore\n                try {\n                  this.peerStore.addressBook.set(id, message.listenAddrs.map(function (addr) {\n                    return new Multiaddr(addr);\n                  }));\n                } catch (err) {\n                  log.error('received invalid addrs', err);\n                } // Update the protocols\n\n\n                this.peerStore.protoBook.set(id, message.protocols);\n\n              case 28:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[1, 10], [14, 23]]);\n      }));\n\n      function _handlePush(_x5) {\n        return _handlePush2.apply(this, arguments);\n      }\n\n      return _handlePush;\n    }()\n    /**\n     * Takes the `addr` and converts it to a Multiaddr if possible\n     *\n     * @param {Uint8Array | string} addr\n     * @returns {Multiaddr|null}\n     */\n\n  }], [{\n    key: \"getProtocolStr\",\n    value:\n    /**\n     * @param {import('../')} libp2p\n     */\n    function getProtocolStr(libp2p) {\n      return {\n        identifyProtocolStr: \"/\".concat(libp2p._config.protocolPrefix, \"/\").concat(MULTICODEC_IDENTIFY_PROTOCOL_NAME, \"/\").concat(MULTICODEC_IDENTIFY_PROTOCOL_VERSION),\n        identifyPushProtocolStr: \"/\".concat(libp2p._config.protocolPrefix, \"/\").concat(MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME, \"/\").concat(MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION)\n      };\n    }\n  }, {\n    key: \"getCleanMultiaddr\",\n    value: function getCleanMultiaddr(addr) {\n      if (addr && addr.length > 0) {\n        try {\n          return new Multiaddr(addr);\n        } catch (_) {\n          return null;\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return IdentifyService;\n}();\n/**\n * The protocols the IdentifyService supports\n *\n * @property multicodecs\n */\n\n\nvar multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n};\nIdentifyService.multicodecs = multicodecs;\nIdentifyService.Messsage = Message;\nmodule.exports = IdentifyService;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errCode","lp","pipe","collect","take","consume","uint8ArrayFromString","fromString","PeerId","Multiaddr","toBuffer","Message","Envelope","PeerRecord","MULTICODEC_IDENTIFY","MULTICODEC_IDENTIFY_PUSH","IDENTIFY_PROTOCOL_VERSION","MULTICODEC_IDENTIFY_PROTOCOL_NAME","MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME","MULTICODEC_IDENTIFY_PROTOCOL_VERSION","MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION","codes","IdentifyService","libp2p","_libp2p","peerStore","addressManager","connectionManager","peerId","handleMessage","bind","protocolStr","getProtocolStr","identifyProtocolStr","identifyPushProtocolStr","_host","protocolVersion","_config","protocolPrefix","_options","host","metadataBook","set","agentVersion","on","connection","identify","catch","toString","pushToPeerStore","connections","addressBook","getRawEnvelope","signedPeerRecord","listenAddrs","multiaddrs","map","ma","bytes","protocols","protoBook","get","pushes","newStream","stream","Identify","encode","finish","Promise","all","isStarted","peers","values","peer","includes","id","push","decode","data","Error","ERR_CONNECTION_ENDED","message","ERR_INVALID_MESSAGE","publicKey","observedAddr","createFromPubKey","remotePeer","toB58String","ERR_INVALID_PEER","cleanObservedAddr","getCleanMultiaddr","openAndCertify","DOMAIN","envelope","consumePeerRecord","addr","err","protocol","_handleIdentify","_handlePush","Uint8Array","pubKey","remoteAddr","length","_","multicodecs","IDENTIFY","IDENTIFY_PUSH","Messsage","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/identify/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:identify'), {\n  error: debug('libp2p:identify:err')\n})\nconst errCode = require('err-code')\nconst lp = require('it-length-prefixed')\nconst { pipe } = require('it-pipe')\nconst { collect, take, consume } = require('streaming-iterables')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\n\nconst PeerId = require('peer-id')\nconst { Multiaddr } = require('multiaddr')\n// @ts-ignore it-buffer does not have types\nconst { toBuffer } = require('it-buffer')\n\nconst Message = require('./message')\n\nconst Envelope = require('../record/envelope')\nconst PeerRecord = require('../record/peer-record')\n\nconst {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH,\n  IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION\n} = require('./consts')\n\nconst { codes } = require('../errors')\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n */\n\n/**\n * @typedef {Object} HostProperties\n * @property {string} agentVersion\n */\n\nclass IdentifyService {\n  /**\n   * @param {import('../')} libp2p\n   */\n  static getProtocolStr (libp2p) {\n    return {\n      identifyProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,\n      identifyPushProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`\n    }\n  }\n\n  /**\n   * @class\n   * @param {Object} options\n   * @param {import('../')} options.libp2p\n   */\n  constructor ({ libp2p }) {\n    this._libp2p = libp2p\n    this.peerStore = libp2p.peerStore\n    this.addressManager = libp2p.addressManager\n    this.connectionManager = libp2p.connectionManager\n    this.peerId = libp2p.peerId\n\n    this.handleMessage = this.handleMessage.bind(this)\n\n    const protocolStr = IdentifyService.getProtocolStr(libp2p)\n    this.identifyProtocolStr = protocolStr.identifyProtocolStr\n    this.identifyPushProtocolStr = protocolStr.identifyPushProtocolStr\n\n    // Store self host metadata\n    this._host = {\n      protocolVersion: `${libp2p._config.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n      ...libp2p._options.host\n    }\n\n    this.peerStore.metadataBook.set(this.peerId, 'AgentVersion', uint8ArrayFromString(this._host.agentVersion))\n    this.peerStore.metadataBook.set(this.peerId, 'ProtocolVersion', uint8ArrayFromString(this._host.protocolVersion))\n    // When a new connection happens, trigger identify\n    this.connectionManager.on('peer:connect', (connection) => {\n      this.identify(connection).catch(log.error)\n    })\n\n    // When self multiaddrs change, trigger identify-push\n    this.peerStore.on('change:multiaddrs', ({ peerId }) => {\n      if (peerId.toString() === this.peerId.toString()) {\n        this.pushToPeerStore()\n      }\n    })\n\n    // When self protocols change, trigger identify-push\n    this.peerStore.on('change:protocols', ({ peerId }) => {\n      if (peerId.toString() === this.peerId.toString()) {\n        this.pushToPeerStore()\n      }\n    })\n  }\n\n  /**\n   * Send an Identify Push update to the list of connections\n   *\n   * @param {Connection[]} connections\n   * @returns {Promise<void[]>}\n   */\n  async push (connections) {\n    const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId)\n    const listenAddrs = this._libp2p.multiaddrs.map((ma) => ma.bytes)\n    const protocols = this.peerStore.protoBook.get(this.peerId) || []\n\n    const pushes = connections.map(async connection => {\n      try {\n        const { stream } = await connection.newStream(this.identifyPushProtocolStr)\n\n        await pipe(\n          [Message.Identify.encode({\n            listenAddrs,\n            signedPeerRecord,\n            protocols\n          }).finish()],\n          lp.encode(),\n          stream,\n          consume\n        )\n      } catch (err) {\n        // Just log errors\n        log.error('could not push identify update to peer', err)\n      }\n    })\n\n    return Promise.all(pushes)\n  }\n\n  /**\n   * Calls `push` for all peers in the `peerStore` that are connected\n   *\n   * @returns {void}\n   */\n  pushToPeerStore () {\n    // Do not try to push if libp2p node is not running\n    if (!this._libp2p.isStarted()) {\n      return\n    }\n\n    const connections = []\n    let connection\n    for (const peer of this.peerStore.peers.values()) {\n      if (peer.protocols.includes(this.identifyPushProtocolStr) && (connection = this.connectionManager.get(peer.id))) {\n        connections.push(connection)\n      }\n    }\n\n    this.push(connections)\n  }\n\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   *\n   * @async\n   * @param {Connection} connection\n   * @returns {Promise<void>}\n   */\n  async identify (connection) {\n    const { stream } = await connection.newStream(this.identifyProtocolStr)\n    const [data] = await pipe(\n      [],\n      stream,\n      lp.decode(),\n      take(1),\n      toBuffer,\n      collect\n    )\n\n    if (!data) {\n      throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED)\n    }\n\n    let message\n    try {\n      message = Message.Identify.decode(data)\n    } catch (err) {\n      throw errCode(err, codes.ERR_INVALID_MESSAGE)\n    }\n\n    const {\n      publicKey,\n      listenAddrs,\n      protocols,\n      observedAddr,\n      signedPeerRecord\n    } = message\n\n    const id = await PeerId.createFromPubKey(publicKey)\n\n    if (connection.remotePeer.toB58String() !== id.toB58String()) {\n      throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER)\n    }\n\n    // Get the observedAddr if there is one\n    const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr)\n\n    try {\n      const envelope = await Envelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN)\n      if (this.peerStore.addressBook.consumePeerRecord(envelope)) {\n        this.peerStore.protoBook.set(id, protocols)\n        this.peerStore.metadataBook.set(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion))\n        this.peerStore.metadataBook.set(id, 'ProtocolVersion', uint8ArrayFromString(message.protocolVersion))\n        return\n      }\n    } catch (err) {\n      log('received invalid envelope, discard it and fallback to listenAddrs is available', err)\n    }\n\n    // LEGACY: Update peers data in PeerStore\n    try {\n      this.peerStore.addressBook.set(id, listenAddrs.map((addr) => new Multiaddr(addr)))\n    } catch (err) {\n      log.error('received invalid addrs', err)\n    }\n\n    this.peerStore.protoBook.set(id, protocols)\n    this.peerStore.metadataBook.set(id, 'AgentVersion', uint8ArrayFromString(message.agentVersion))\n    this.peerStore.metadataBook.set(id, 'ProtocolVersion', uint8ArrayFromString(message.protocolVersion))\n\n    // TODO: Add and score our observed addr\n    log('received observed address of %s', cleanObservedAddr)\n    // this.addressManager.addObservedAddr(observedAddr)\n  }\n\n  /**\n   * A handler to register with Libp2p to process identify messages.\n   *\n   * @param {Object} options\n   * @param {Connection} options.connection\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   * @returns {Promise<void>|undefined}\n   */\n  handleMessage ({ connection, stream, protocol }) {\n    switch (protocol) {\n      case this.identifyProtocolStr:\n        return this._handleIdentify({ connection, stream })\n      case this.identifyPushProtocolStr:\n        return this._handlePush({ connection, stream })\n      default:\n        log.error('cannot handle unknown protocol %s', protocol)\n    }\n  }\n\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   *\n   * @private\n   * @param {Object} options\n   * @param {MuxedStream} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n  async _handleIdentify ({ connection, stream }) {\n    let publicKey = new Uint8Array(0)\n    if (this.peerId.pubKey) {\n      publicKey = this.peerId.pubKey.bytes\n    }\n\n    const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId)\n    const protocols = this.peerStore.protoBook.get(this.peerId) || []\n\n    const message = Message.Identify.encode({\n      protocolVersion: this._host.protocolVersion,\n      agentVersion: this._host.agentVersion,\n      publicKey,\n      listenAddrs: this._libp2p.multiaddrs.map((ma) => ma.bytes),\n      signedPeerRecord,\n      observedAddr: connection.remoteAddr.bytes,\n      protocols\n    }).finish()\n\n    try {\n      await pipe(\n        [message],\n        lp.encode(),\n        stream,\n        consume\n      )\n    } catch (err) {\n      log.error('could not respond to identify request', err)\n    }\n  }\n\n  /**\n   * Reads the Identify Push message from the given `connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {MuxedStream} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n  async _handlePush ({ connection, stream }) {\n    let message\n    try {\n      const [data] = await pipe(\n        [],\n        stream,\n        lp.decode(),\n        take(1),\n        toBuffer,\n        collect\n      )\n      message = Message.Identify.decode(data)\n    } catch (err) {\n      return log.error('received invalid message', err)\n    }\n\n    const id = connection.remotePeer\n\n    try {\n      const envelope = await Envelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN)\n      if (this.peerStore.addressBook.consumePeerRecord(envelope)) {\n        this.peerStore.protoBook.set(id, message.protocols)\n        return\n      }\n    } catch (err) {\n      log('received invalid envelope, discard it and fallback to listenAddrs is available', err)\n    }\n\n    // LEGACY: Update peers data in PeerStore\n    try {\n      this.peerStore.addressBook.set(id,\n        message.listenAddrs.map((addr) => new Multiaddr(addr)))\n    } catch (err) {\n      log.error('received invalid addrs', err)\n    }\n\n    // Update the protocols\n    this.peerStore.protoBook.set(id, message.protocols)\n  }\n\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   *\n   * @param {Uint8Array | string} addr\n   * @returns {Multiaddr|null}\n   */\n  static getCleanMultiaddr (addr) {\n    if (addr && addr.length > 0) {\n      try {\n        return new Multiaddr(addr)\n      } catch (_) {\n        return null\n      }\n    }\n    return null\n  }\n}\n\n/**\n * The protocols the IdentifyService supports\n *\n * @property multicodecs\n */\nconst multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n}\n\nIdentifyService.multicodecs = multicodecs\nIdentifyService.Messsage = Message\n\nmodule.exports = IdentifyService\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}