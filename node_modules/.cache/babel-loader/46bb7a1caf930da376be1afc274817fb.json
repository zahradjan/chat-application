{"ast":null,"code":"'use strict';\n\nconst pSeries = require('p-series');\n\nconst PeerMonitor = require('ipfs-pubsub-peer-monitor');\n\nconst Logger = require('logplease');\n\nconst logger = Logger.create(\"pubsub\", {\n  color: Logger.Colors.Yellow\n});\nLogger.setLogLevel('ERROR');\nconst maxTopicsOpen = 256;\nlet topicsOpenCount = 0;\n\nclass IPFSPubsub {\n  constructor(ipfs, id) {\n    this._ipfs = ipfs;\n    this._id = id;\n    this._subscriptions = {};\n    if (this._ipfs.pubsub === null) logger.error(\"The provided version of ipfs doesn't have pubsub support. Messages will not be exchanged.\");\n    this._handleMessage = this._handleMessage.bind(this); // Bump up the number of listeners we can have open,\n    // ie. number of databases replicating\n\n    if (this._ipfs.setMaxListeners) this._ipfs.setMaxListeners(maxTopicsOpen);\n  }\n\n  async subscribe(topic, onMessageCallback, onNewPeerCallback) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    if (!this._subscriptions[topic] && this._ipfs.pubsub) {\n      await this._ipfs.pubsub.subscribe(topic, this._handleMessage, options);\n      const topicMonitor = new PeerMonitor(this._ipfs.pubsub, topic);\n      topicMonitor.on('join', peer => {\n        logger.debug(`Peer joined ${topic}:`);\n        logger.debug(peer);\n\n        if (this._subscriptions[topic]) {\n          onNewPeerCallback(topic, peer);\n        } else {\n          logger.warn('Peer joined a room we don\\'t have a subscription for');\n          logger.warn(topic, peer);\n        }\n      });\n      topicMonitor.on('leave', peer => logger.debug(`Peer ${peer} left ${topic}`));\n      topicMonitor.on('error', e => logger.error(e));\n      this._subscriptions[topic] = {\n        topicMonitor: topicMonitor,\n        onMessage: onMessageCallback,\n        onNewPeer: onNewPeerCallback\n      };\n      topicsOpenCount++;\n      logger.debug(\"Topics open:\", topicsOpenCount);\n    }\n  }\n\n  async unsubscribe(hash) {\n    if (this._subscriptions[hash]) {\n      await this._ipfs.pubsub.unsubscribe(hash, this._handleMessage);\n\n      this._subscriptions[hash].topicMonitor.stop();\n\n      delete this._subscriptions[hash];\n      logger.debug(`Unsubscribed from '${hash}'`);\n      topicsOpenCount--;\n      logger.debug(\"Topics open:\", topicsOpenCount);\n    }\n  }\n\n  publish(topic, message) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (this._subscriptions[topic] && this._ipfs.pubsub) {\n      let payload; //Buffer should be already serialized. Everything else will get serialized as json if not buffer, string.\n\n      if (Buffer.isBuffer(message) | typeof message === \"string\") {\n        payload = message;\n      } else {\n        payload = JSON.stringify(message);\n      }\n\n      this._ipfs.pubsub.publish(topic, Buffer.from(payload), options);\n    }\n  }\n\n  async disconnect() {\n    const topics = Object.keys(this._subscriptions);\n    await pSeries(topics.map(t => this.unsubscribe.bind(this, t)));\n    this._subscriptions = {};\n  }\n\n  async _handleMessage(message) {\n    // Don't process our own messages\n    if (message.from === this._id) return; // Get the message content and a subscription\n\n    let content, subscription, topicId; // Get the topic\n\n    topicId = message.topicIDs[0];\n\n    try {\n      content = JSON.parse(Buffer.from(message.data).toString());\n    } catch {\n      content = message.data; //Leave content alone. Meant for higher level code using custom serialization.\n    }\n\n    subscription = this._subscriptions[topicId];\n\n    if (subscription && subscription.onMessage && content) {\n      await subscription.onMessage(topicId, content, message.from);\n    }\n  }\n\n}\n\nmodule.exports = IPFSPubsub;","map":{"version":3,"names":["pSeries","require","PeerMonitor","Logger","logger","create","color","Colors","Yellow","setLogLevel","maxTopicsOpen","topicsOpenCount","IPFSPubsub","constructor","ipfs","id","_ipfs","_id","_subscriptions","pubsub","error","_handleMessage","bind","setMaxListeners","subscribe","topic","onMessageCallback","onNewPeerCallback","options","topicMonitor","on","peer","debug","warn","e","onMessage","onNewPeer","unsubscribe","hash","stop","publish","message","payload","Buffer","isBuffer","JSON","stringify","from","disconnect","topics","Object","keys","map","t","content","subscription","topicId","topicIDs","parse","data","toString","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-pubsub/src/ipfs-pubsub.js"],"sourcesContent":["'use strict'\n\nconst pSeries = require('p-series')\nconst PeerMonitor = require('ipfs-pubsub-peer-monitor')\n\nconst Logger = require('logplease')\nconst logger = Logger.create(\"pubsub\", { color: Logger.Colors.Yellow })\nLogger.setLogLevel('ERROR')\n\nconst maxTopicsOpen = 256\nlet topicsOpenCount = 0\n\nclass IPFSPubsub {\n  constructor(ipfs, id) {\n    this._ipfs = ipfs\n    this._id = id\n    this._subscriptions = {}\n\n    if (this._ipfs.pubsub === null)\n      logger.error(\"The provided version of ipfs doesn't have pubsub support. Messages will not be exchanged.\")\n\n    this._handleMessage = this._handleMessage.bind(this)\n\n    // Bump up the number of listeners we can have open,\n    // ie. number of databases replicating\n    if (this._ipfs.setMaxListeners)\n      this._ipfs.setMaxListeners(maxTopicsOpen)\n  }\n\n  async subscribe(topic, onMessageCallback, onNewPeerCallback, options = {}) {\n    if(!this._subscriptions[topic] && this._ipfs.pubsub) {\n      await this._ipfs.pubsub.subscribe(topic, this._handleMessage, options)\n\n      const topicMonitor = new PeerMonitor(this._ipfs.pubsub, topic)\n\n      topicMonitor.on('join', (peer) => {\n        logger.debug(`Peer joined ${topic}:`)\n        logger.debug(peer)\n        if (this._subscriptions[topic]) {\n          onNewPeerCallback(topic, peer)\n        } else {\n          logger.warn('Peer joined a room we don\\'t have a subscription for')\n          logger.warn(topic, peer)\n        }\n      })\n\n      topicMonitor.on('leave', (peer) => logger.debug(`Peer ${peer} left ${topic}`))\n      topicMonitor.on('error', (e) => logger.error(e))\n\n      this._subscriptions[topic] = {\n        topicMonitor: topicMonitor,\n        onMessage: onMessageCallback,\n        onNewPeer: onNewPeerCallback\n      }\n\n      topicsOpenCount ++\n      logger.debug(\"Topics open:\", topicsOpenCount)\n    }\n  }\n\n  async unsubscribe(hash) {\n    if(this._subscriptions[hash]) {\n      await this._ipfs.pubsub.unsubscribe(hash, this._handleMessage)\n      this._subscriptions[hash].topicMonitor.stop()\n      delete this._subscriptions[hash]\n      logger.debug(`Unsubscribed from '${hash}'`)\n      topicsOpenCount --\n      logger.debug(\"Topics open:\", topicsOpenCount)\n    }\n  }\n\n  publish(topic, message, options = {}) {\n    if (this._subscriptions[topic] && this._ipfs.pubsub) {\n      let payload;\n      //Buffer should be already serialized. Everything else will get serialized as json if not buffer, string.\n      if(Buffer.isBuffer(message) | typeof message === \"string\") {\n        payload = message;\n      } else {\n        payload = JSON.stringify(message);\n      }\n      this._ipfs.pubsub.publish(topic, Buffer.from(payload), options)\n    }\n  }\n\n  async disconnect() {\n    const topics = Object.keys(this._subscriptions)\n    await pSeries(topics.map((t) => this.unsubscribe.bind(this, t)))\n    this._subscriptions = {}\n  }\n\n  async _handleMessage(message) {\n    // Don't process our own messages\n    if (message.from === this._id)\n      return\n\n    // Get the message content and a subscription\n    let content, subscription, topicId\n\n    // Get the topic\n    topicId = message.topicIDs[0]\n    try {\n      content = JSON.parse(Buffer.from(message.data).toString())\n    } catch {\n      content = message.data; //Leave content alone. Meant for higher level code using custom serialization.\n    }\n    subscription = this._subscriptions[topicId]\n\n    if(subscription && subscription.onMessage && content) {\n      await subscription.onMessage(topicId, content, message.from)\n    }\n  }\n}\n\nmodule.exports = IPFSPubsub\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}