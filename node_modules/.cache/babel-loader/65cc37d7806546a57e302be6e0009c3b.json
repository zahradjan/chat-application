{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Heartbeat = void 0;\n\nvar constants = __importStar(require(\"./constants\"));\n\nvar get_gossip_peers_1 = require(\"./get-gossip-peers\");\n\nvar utils_1 = require(\"./utils\"); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\n\nvar Heartbeat = /*#__PURE__*/function () {\n  /**\n   * @param {Object} gossipsub\n   * @constructor\n   */\n  function Heartbeat(gossipsub) {\n    _classCallCheck(this, Heartbeat);\n\n    this.gossipsub = gossipsub;\n  }\n\n  _createClass(Heartbeat, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      if (this._heartbeatTimer) {\n        return;\n      }\n\n      var heartbeat = this._heartbeat.bind(this);\n\n      var timeout = setTimeout(function () {\n        heartbeat();\n\n        _this._heartbeatTimer.runPeriodically(heartbeat, _this.gossipsub._options.heartbeatInterval);\n      }, constants.GossipsubHeartbeatInitialDelay);\n      this._heartbeatTimer = {\n        _intervalId: undefined,\n        runPeriodically: function runPeriodically(fn, period) {\n          _this._heartbeatTimer._intervalId = setInterval(fn, period);\n        },\n        cancel: function cancel() {\n          clearTimeout(timeout);\n          clearInterval(_this._heartbeatTimer._intervalId);\n        }\n      };\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this._heartbeatTimer) {\n        return;\n      }\n\n      this._heartbeatTimer.cancel();\n\n      this._heartbeatTimer = null;\n    }\n    /**\n     * Maintains the mesh and fanout maps in gossipsub.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_heartbeat\",\n    value: function _heartbeat() {\n      var _this2 = this;\n\n      var _this$gossipsub$_opti = this.gossipsub._options,\n          D = _this$gossipsub$_opti.D,\n          Dlo = _this$gossipsub$_opti.Dlo,\n          Dhi = _this$gossipsub$_opti.Dhi,\n          Dscore = _this$gossipsub$_opti.Dscore,\n          Dout = _this$gossipsub$_opti.Dout,\n          fanoutTTL = _this$gossipsub$_opti.fanoutTTL;\n      this.gossipsub.heartbeatTicks++; // cache scores throught the heartbeat\n\n      var scores = new Map();\n\n      var getScore = function getScore(id) {\n        var s = scores.get(id);\n\n        if (s === undefined) {\n          s = _this2.gossipsub.score.score(id);\n          scores.set(id, s);\n        }\n\n        return s;\n      }; // peer id => topic[]\n\n\n      var tograft = new Map(); // peer id => topic[]\n\n      var toprune = new Map(); // peer id => don't px\n\n      var noPX = new Map(); // clean up expired backoffs\n\n      this.gossipsub._clearBackoff(); // clean up peerhave/iasked counters\n\n\n      this.gossipsub.peerhave.clear();\n      this.gossipsub.iasked.clear(); // apply IWANT request penalties\n\n      this.gossipsub._applyIwantPenalties(); // ensure direct peers are connected\n\n\n      this.gossipsub._directConnect(); // maintain the mesh for topics we have joined\n\n\n      this.gossipsub.mesh.forEach(function (peers, topic) {\n        // prune/graft helper functions (defined per topic)\n        var prunePeer = function prunePeer(id) {\n          _this2.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic); // update peer score\n\n\n          _this2.gossipsub.score.prune(id, topic); // add prune backoff record\n\n\n          _this2.gossipsub._addBackoff(id, topic); // remove peer from mesh\n\n\n          peers.delete(id); // add to toprune\n\n          var topics = toprune.get(id);\n\n          if (!topics) {\n            toprune.set(id, [topic]);\n          } else {\n            topics.push(topic);\n          }\n        };\n\n        var graftPeer = function graftPeer(id) {\n          _this2.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', id, topic); // update peer score\n\n\n          _this2.gossipsub.score.graft(id, topic); // add peer to mesh\n\n\n          peers.add(id); // add to tograft\n\n          var topics = tograft.get(id);\n\n          if (!topics) {\n            tograft.set(id, [topic]);\n          } else {\n            topics.push(topic);\n          }\n        }; // drop all peers with negative score, without PX\n\n\n        peers.forEach(function (id) {\n          var score = getScore(id);\n\n          if (score < 0) {\n            _this2.gossipsub.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);\n\n            prunePeer(id);\n            noPX.set(id, true);\n          }\n        }); // do we have enough peers?\n\n        if (peers.size < Dlo) {\n          var backoff = _this2.gossipsub.backoff.get(topic);\n\n          var ineed = D - peers.size;\n          var peersSet = get_gossip_peers_1.getGossipPeers(_this2.gossipsub, topic, ineed, function (id) {\n            // filter out mesh peers, direct peers, peers we are backing off, peers with negative score\n            return !peers.has(id) && !_this2.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;\n          });\n          peersSet.forEach(graftPeer);\n        } // do we have to many peers?\n\n\n        if (peers.size > Dhi) {\n          var peersArray = Array.from(peers); // sort by score\n\n          peersArray.sort(function (a, b) {\n            return getScore(b) - getScore(a);\n          }); // We keep the first D_score peers by score and the remaining up to D randomly\n          // under the constraint that we keep D_out peers in the mesh (if we have that many)\n\n          peersArray = peersArray.slice(0, Dscore).concat(utils_1.shuffle(peersArray.slice(Dscore))); // count the outbound peers we are keeping\n\n          var outbound = 0;\n          peersArray.slice(0, D).forEach(function (p) {\n            if (_this2.gossipsub.outbound.get(p)) {\n              outbound++;\n            }\n          }); // if it's less than D_out, bubble up some outbound peers from the random selection\n\n          if (outbound < Dout) {\n            var rotate = function rotate(i) {\n              // rotate the peersArray to the right and put the ith peer in the front\n              var p = peersArray[i];\n\n              for (var j = i; j > 0; j--) {\n                peersArray[j] = peersArray[j - 1];\n              }\n\n              peersArray[0] = p;\n            }; // first bubble up all outbound peers already in the selection to the front\n\n\n            if (outbound > 0) {\n              var ihave = outbound;\n\n              for (var i = 1; i < D && ihave > 0; i++) {\n                if (_this2.gossipsub.outbound.get(peersArray[i])) {\n                  rotate(i);\n                  ihave--;\n                }\n              }\n            } // now bubble up enough outbound peers outside the selection to the front\n\n\n            var _ineed = D - outbound;\n\n            for (var _i = D; _i < peersArray.length && _ineed > 0; _i++) {\n              if (_this2.gossipsub.outbound.get(peersArray[_i])) {\n                rotate(_i);\n                _ineed--;\n              }\n            }\n          } // prune the excess peers\n\n\n          peersArray.slice(D).forEach(prunePeer);\n        } // do we have enough outbound peers?\n\n\n        if (peers.size >= Dlo) {\n          // count the outbound peers we have\n          var _outbound = 0;\n          peers.forEach(function (p) {\n            if (_this2.gossipsub.outbound.get(p)) {\n              _outbound++;\n            }\n          }); // if it's less than D_out, select some peers with outbound connections and graft them\n\n          if (_outbound < Dout) {\n            var _ineed2 = Dout - _outbound;\n\n            var _backoff = _this2.gossipsub.backoff.get(topic);\n\n            get_gossip_peers_1.getGossipPeers(_this2.gossipsub, topic, _ineed2, function (id) {\n              // filter our current mesh peers, direct peers, peers we are backing off, peers with negative score\n              return !peers.has(id) && !_this2.gossipsub.direct.has(id) && (!_backoff || !_backoff.has(id)) && getScore(id) >= 0;\n            }).forEach(graftPeer);\n          }\n        } // should we try to improve the mesh with opportunistic grafting?\n\n\n        if (_this2.gossipsub.heartbeatTicks % constants.GossipsubOpportunisticGraftTicks === 0 && peers.size > 1) {\n          // Opportunistic grafting works as follows: we check the median score of peers in the\n          // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n          // random with score over the median.\n          // The intention is to (slowly) improve an underperforming mesh by introducing good\n          // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n          // situations where we are stuck with poor peers and also recover from churn of good peers.\n          // now compute the median peer score in the mesh\n          var peersList = Array.from(peers).sort(function (a, b) {\n            return getScore(a) - getScore(b);\n          });\n          var medianIndex = Math.floor(peers.size / 2);\n          var medianScore = getScore(peersList[medianIndex]); // if the median score is below the threshold, select a better peer (if any) and GRAFT\n\n          if (medianScore < _this2.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {\n            var _backoff2 = _this2.gossipsub.backoff.get(topic);\n\n            var peersToGraft = get_gossip_peers_1.getGossipPeers(_this2.gossipsub, topic, constants.GossipsubOpportunisticGraftPeers, function (id) {\n              // filter out current mesh peers, direct peers, peers we are backing off, peers below or at threshold\n              return peers.has(id) && !_this2.gossipsub.direct.has(id) && (!_backoff2 || !_backoff2.has(id)) && getScore(id) > medianScore;\n            });\n            peersToGraft.forEach(function (id) {\n              _this2.gossipsub.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);\n\n              graftPeer(id);\n            });\n          }\n        } // 2nd arg are mesh peers excluded from gossip. We have already pushed\n        // messages to them, so its redundant to gossip IHAVEs.\n\n\n        _this2.gossipsub._emitGossip(topic, peers);\n      }); // expire fanout for topics we haven't published to in a while\n\n      var now = this.gossipsub._now();\n\n      this.gossipsub.lastpub.forEach(function (lastpb, topic) {\n        if (lastpb + fanoutTTL < now) {\n          _this2.gossipsub.fanout.delete(topic);\n\n          _this2.gossipsub.lastpub.delete(topic);\n        }\n      }); // maintain our fanout for topics we are publishing but we have not joined\n\n      this.gossipsub.fanout.forEach(function (fanoutPeers, topic) {\n        // checks whether our peers are still in the topic and have a score above the publish threshold\n        var topicPeers = _this2.gossipsub.topics.get(topic);\n\n        fanoutPeers.forEach(function (id) {\n          if (!topicPeers.has(id) || getScore(id) < _this2.gossipsub._options.scoreThresholds.publishThreshold) {\n            fanoutPeers.delete(id);\n          }\n        }); // do we need more peers?\n\n        if (fanoutPeers.size < D) {\n          var ineed = D - fanoutPeers.size;\n          var peersSet = get_gossip_peers_1.getGossipPeers(_this2.gossipsub, topic, ineed, function (id) {\n            // filter out existing fanout peers, direct peers, and peers with score above the publish threshold\n            return !fanoutPeers.has(id) && !_this2.gossipsub.direct.has(id) && getScore(id) >= _this2.gossipsub._options.scoreThresholds.publishThreshold;\n          });\n          peersSet.forEach(function (id) {\n            fanoutPeers.add(id);\n          });\n        } // 2nd arg are fanout peers excluded from gossip.\n        // We have already pushed messages to them, so its redundant to gossip IHAVEs\n\n\n        _this2.gossipsub._emitGossip(topic, fanoutPeers);\n      }); // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n\n      this.gossipsub._sendGraftPrune(tograft, toprune, noPX); // flush pending gossip that wasn't piggybacked above\n\n\n      this.gossipsub._flush(); // advance the message history window\n\n\n      this.gossipsub.messageCache.shift();\n      this.gossipsub.emit('gossipsub:heartbeat');\n    }\n  }]);\n\n  return Heartbeat;\n}();\n\nexports.Heartbeat = Heartbeat;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","exports","Heartbeat","constants","require","get_gossip_peers_1","utils_1","gossipsub","_heartbeatTimer","heartbeat","_heartbeat","bind","timeout","setTimeout","runPeriodically","_options","heartbeatInterval","GossipsubHeartbeatInitialDelay","_intervalId","fn","period","setInterval","cancel","clearTimeout","clearInterval","D","Dlo","Dhi","Dscore","Dout","fanoutTTL","heartbeatTicks","scores","Map","getScore","id","s","score","set","tograft","toprune","noPX","_clearBackoff","peerhave","clear","iasked","_applyIwantPenalties","_directConnect","mesh","forEach","peers","topic","prunePeer","log","prune","_addBackoff","delete","topics","push","graftPeer","graft","add","size","backoff","ineed","peersSet","getGossipPeers","has","direct","peersArray","Array","from","sort","a","b","slice","concat","shuffle","outbound","p","rotate","i","j","ihave","length","GossipsubOpportunisticGraftTicks","peersList","medianIndex","Math","floor","medianScore","scoreThresholds","opportunisticGraftThreshold","peersToGraft","GossipsubOpportunisticGraftPeers","_emitGossip","now","_now","lastpub","lastpb","fanout","fanoutPeers","topicPeers","publishThreshold","_sendGraftPrune","_flush","messageCache","shift","emit"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-gossipsub/src/heartbeat.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Heartbeat = void 0;\nconst constants = __importStar(require(\"./constants\"));\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\nconst utils_1 = require(\"./utils\");\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\nclass Heartbeat {\n    /**\n     * @param {Object} gossipsub\n     * @constructor\n     */\n    constructor(gossipsub) {\n        this.gossipsub = gossipsub;\n    }\n    start() {\n        if (this._heartbeatTimer) {\n            return;\n        }\n        const heartbeat = this._heartbeat.bind(this);\n        const timeout = setTimeout(() => {\n            heartbeat();\n            this._heartbeatTimer.runPeriodically(heartbeat, this.gossipsub._options.heartbeatInterval);\n        }, constants.GossipsubHeartbeatInitialDelay);\n        this._heartbeatTimer = {\n            _intervalId: undefined,\n            runPeriodically: (fn, period) => {\n                this._heartbeatTimer._intervalId = setInterval(fn, period);\n            },\n            cancel: () => {\n                clearTimeout(timeout);\n                clearInterval(this._heartbeatTimer._intervalId);\n            }\n        };\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n    stop() {\n        if (!this._heartbeatTimer) {\n            return;\n        }\n        this._heartbeatTimer.cancel();\n        this._heartbeatTimer = null;\n    }\n    /**\n     * Maintains the mesh and fanout maps in gossipsub.\n     *\n     * @returns {void}\n     */\n    _heartbeat() {\n        const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.gossipsub._options;\n        this.gossipsub.heartbeatTicks++;\n        // cache scores throught the heartbeat\n        const scores = new Map();\n        const getScore = (id) => {\n            let s = scores.get(id);\n            if (s === undefined) {\n                s = this.gossipsub.score.score(id);\n                scores.set(id, s);\n            }\n            return s;\n        };\n        // peer id => topic[]\n        const tograft = new Map();\n        // peer id => topic[]\n        const toprune = new Map();\n        // peer id => don't px\n        const noPX = new Map();\n        // clean up expired backoffs\n        this.gossipsub._clearBackoff();\n        // clean up peerhave/iasked counters\n        this.gossipsub.peerhave.clear();\n        this.gossipsub.iasked.clear();\n        // apply IWANT request penalties\n        this.gossipsub._applyIwantPenalties();\n        // ensure direct peers are connected\n        this.gossipsub._directConnect();\n        // maintain the mesh for topics we have joined\n        this.gossipsub.mesh.forEach((peers, topic) => {\n            // prune/graft helper functions (defined per topic)\n            const prunePeer = (id) => {\n                this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic);\n                // update peer score\n                this.gossipsub.score.prune(id, topic);\n                // add prune backoff record\n                this.gossipsub._addBackoff(id, topic);\n                // remove peer from mesh\n                peers.delete(id);\n                // add to toprune\n                const topics = toprune.get(id);\n                if (!topics) {\n                    toprune.set(id, [topic]);\n                }\n                else {\n                    topics.push(topic);\n                }\n            };\n            const graftPeer = (id) => {\n                this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', id, topic);\n                // update peer score\n                this.gossipsub.score.graft(id, topic);\n                // add peer to mesh\n                peers.add(id);\n                // add to tograft\n                const topics = tograft.get(id);\n                if (!topics) {\n                    tograft.set(id, [topic]);\n                }\n                else {\n                    topics.push(topic);\n                }\n            };\n            // drop all peers with negative score, without PX\n            peers.forEach(id => {\n                const score = getScore(id);\n                if (score < 0) {\n                    this.gossipsub.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);\n                    prunePeer(id);\n                    noPX.set(id, true);\n                }\n            });\n            // do we have enough peers?\n            if (peers.size < Dlo) {\n                const backoff = this.gossipsub.backoff.get(topic);\n                const ineed = D - peers.size;\n                const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, id => {\n                    // filter out mesh peers, direct peers, peers we are backing off, peers with negative score\n                    return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;\n                });\n                peersSet.forEach(graftPeer);\n            }\n            // do we have to many peers?\n            if (peers.size > Dhi) {\n                let peersArray = Array.from(peers);\n                // sort by score\n                peersArray.sort((a, b) => getScore(b) - getScore(a));\n                // We keep the first D_score peers by score and the remaining up to D randomly\n                // under the constraint that we keep D_out peers in the mesh (if we have that many)\n                peersArray = peersArray.slice(0, Dscore).concat(utils_1.shuffle(peersArray.slice(Dscore)));\n                // count the outbound peers we are keeping\n                let outbound = 0;\n                peersArray.slice(0, D).forEach(p => {\n                    if (this.gossipsub.outbound.get(p)) {\n                        outbound++;\n                    }\n                });\n                // if it's less than D_out, bubble up some outbound peers from the random selection\n                if (outbound < Dout) {\n                    const rotate = (i) => {\n                        // rotate the peersArray to the right and put the ith peer in the front\n                        const p = peersArray[i];\n                        for (let j = i; j > 0; j--) {\n                            peersArray[j] = peersArray[j - 1];\n                        }\n                        peersArray[0] = p;\n                    };\n                    // first bubble up all outbound peers already in the selection to the front\n                    if (outbound > 0) {\n                        let ihave = outbound;\n                        for (let i = 1; i < D && ihave > 0; i++) {\n                            if (this.gossipsub.outbound.get(peersArray[i])) {\n                                rotate(i);\n                                ihave--;\n                            }\n                        }\n                    }\n                    // now bubble up enough outbound peers outside the selection to the front\n                    let ineed = D - outbound;\n                    for (let i = D; i < peersArray.length && ineed > 0; i++) {\n                        if (this.gossipsub.outbound.get(peersArray[i])) {\n                            rotate(i);\n                            ineed--;\n                        }\n                    }\n                }\n                // prune the excess peers\n                peersArray.slice(D).forEach(prunePeer);\n            }\n            // do we have enough outbound peers?\n            if (peers.size >= Dlo) {\n                // count the outbound peers we have\n                let outbound = 0;\n                peers.forEach(p => {\n                    if (this.gossipsub.outbound.get(p)) {\n                        outbound++;\n                    }\n                });\n                // if it's less than D_out, select some peers with outbound connections and graft them\n                if (outbound < Dout) {\n                    const ineed = Dout - outbound;\n                    const backoff = this.gossipsub.backoff.get(topic);\n                    get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {\n                        // filter our current mesh peers, direct peers, peers we are backing off, peers with negative score\n                        return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;\n                    }).forEach(graftPeer);\n                }\n            }\n            // should we try to improve the mesh with opportunistic grafting?\n            if (this.gossipsub.heartbeatTicks % constants.GossipsubOpportunisticGraftTicks === 0 && peers.size > 1) {\n                // Opportunistic grafting works as follows: we check the median score of peers in the\n                // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n                // random with score over the median.\n                // The intention is to (slowly) improve an underperforming mesh by introducing good\n                // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n                // situations where we are stuck with poor peers and also recover from churn of good peers.\n                // now compute the median peer score in the mesh\n                const peersList = Array.from(peers)\n                    .sort((a, b) => getScore(a) - getScore(b));\n                const medianIndex = Math.floor(peers.size / 2);\n                const medianScore = getScore(peersList[medianIndex]);\n                // if the median score is below the threshold, select a better peer (if any) and GRAFT\n                if (medianScore < this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {\n                    const backoff = this.gossipsub.backoff.get(topic);\n                    const peersToGraft = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, constants.GossipsubOpportunisticGraftPeers, (id) => {\n                        // filter out current mesh peers, direct peers, peers we are backing off, peers below or at threshold\n                        return peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) > medianScore;\n                    });\n                    peersToGraft.forEach(id => {\n                        this.gossipsub.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);\n                        graftPeer(id);\n                    });\n                }\n            }\n            // 2nd arg are mesh peers excluded from gossip. We have already pushed\n            // messages to them, so its redundant to gossip IHAVEs.\n            this.gossipsub._emitGossip(topic, peers);\n        });\n        // expire fanout for topics we haven't published to in a while\n        const now = this.gossipsub._now();\n        this.gossipsub.lastpub.forEach((lastpb, topic) => {\n            if ((lastpb + fanoutTTL) < now) {\n                this.gossipsub.fanout.delete(topic);\n                this.gossipsub.lastpub.delete(topic);\n            }\n        });\n        // maintain our fanout for topics we are publishing but we have not joined\n        this.gossipsub.fanout.forEach((fanoutPeers, topic) => {\n            // checks whether our peers are still in the topic and have a score above the publish threshold\n            const topicPeers = this.gossipsub.topics.get(topic);\n            fanoutPeers.forEach(id => {\n                if (!topicPeers.has(id) ||\n                    getScore(id) < this.gossipsub._options.scoreThresholds.publishThreshold) {\n                    fanoutPeers.delete(id);\n                }\n            });\n            // do we need more peers?\n            if (fanoutPeers.size < D) {\n                const ineed = D - fanoutPeers.size;\n                const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {\n                    // filter out existing fanout peers, direct peers, and peers with score above the publish threshold\n                    return !fanoutPeers.has(id) &&\n                        !this.gossipsub.direct.has(id) &&\n                        getScore(id) >= this.gossipsub._options.scoreThresholds.publishThreshold;\n                });\n                peersSet.forEach(id => {\n                    fanoutPeers.add(id);\n                });\n            }\n            // 2nd arg are fanout peers excluded from gossip.\n            // We have already pushed messages to them, so its redundant to gossip IHAVEs\n            this.gossipsub._emitGossip(topic, fanoutPeers);\n        });\n        // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n        this.gossipsub._sendGraftPrune(tograft, toprune, noPX);\n        // flush pending gossip that wasn't piggybacked above\n        this.gossipsub._flush();\n        // advance the message history window\n        this.gossipsub.messageCache.shift();\n        this.gossipsub.emit('gossipsub:heartbeat');\n    }\n}\nexports.Heartbeat = Heartbeat;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}