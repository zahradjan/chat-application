{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _assertThisInitialized = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar _require2 = require('bignumber.js'),\n    Big = _require2.BigNumber;\n\nvar MovingAverage = require('@vascosantos/moving-average');\n\nvar retimer = require('retimer');\n/**\n * @typedef {import('@vascosantos/moving-average').IMovingAverage} IMovingAverage\n */\n\n\nvar Stats = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Stats, _EventEmitter);\n\n  var _super = _createSuper(Stats);\n\n  /**\n   * A queue based manager for stat processing\n   *\n   * @class\n   * @param {string[]} initialCounters\n   * @param {any} options\n   */\n  function Stats(initialCounters, options) {\n    var _this;\n\n    _classCallCheck(this, Stats);\n\n    _this = _super.call(this);\n    _this._options = options;\n    _this._queue = [];\n    /** @type {{ dataReceived: Big, dataSent: Big }} */\n\n    _this._stats = {\n      dataReceived: Big(0),\n      dataSent: Big(0)\n    };\n    _this._frequencyLastTime = Date.now();\n    _this._frequencyAccumulators = {};\n    /** @type {{ dataReceived: IMovingAverage[], dataSent: IMovingAverage[] }} */\n\n    _this._movingAverages = {};\n    _this._update = _this._update.bind(_assertThisInitialized(_this));\n    var intervals = _this._options.movingAverageIntervals;\n\n    for (var i = 0; i < initialCounters.length; i++) {\n      var key = initialCounters[i];\n      _this._stats[key] = Big(0);\n      _this._movingAverages[key] = {};\n\n      for (var k = 0; k < intervals.length; k++) {\n        var interval = intervals[k];\n        var ma = _this._movingAverages[key][interval] = MovingAverage(interval);\n        ma.push(_this._frequencyLastTime, 0);\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * Initializes the internal timer if there are items in the queue. This\n   * should only need to be called if `Stats.stop` was previously called, as\n   * `Stats.push` will also start the processing.\n   *\n   * @returns {void}\n   */\n\n\n  _createClass(Stats, [{\n    key: \"start\",\n    value: function start() {\n      if (this._queue.length) {\n        this._resetComputeTimeout();\n      }\n    }\n    /**\n     * Stops processing and computing of stats by clearing the internal\n     * timer.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._timeout) {\n        this._timeout.clear();\n\n        this._timeout = null;\n      }\n    }\n    /**\n     * Returns a clone of the current stats.\n     */\n\n  }, {\n    key: \"snapshot\",\n    get: function get() {\n      return Object.assign({}, this._stats);\n    }\n    /**\n     * Returns a clone of the internal movingAverages\n     */\n\n  }, {\n    key: \"movingAverages\",\n    get: function get() {\n      return Object.assign({}, this._movingAverages);\n    }\n    /**\n     * Returns a plain JSON object of the stats\n     *\n     * @returns {*}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var snapshot = this.snapshot;\n      var movingAverages = this.movingAverages;\n      var data = {\n        dataReceived: snapshot.dataReceived.toString(),\n        dataSent: snapshot.dataSent.toString(),\n        movingAverages: {}\n      };\n      var counters = Object.keys(movingAverages);\n\n      for (var _i = 0, _counters = counters; _i < _counters.length; _i++) {\n        var key = _counters[_i];\n        data.movingAverages[key] = {};\n\n        for (var _i2 = 0, _Object$keys = Object.keys(movingAverages[key]); _i2 < _Object$keys.length; _i2++) {\n          var interval = _Object$keys[_i2];\n          data.movingAverages[key][interval] = movingAverages[key][interval].movingAverage();\n        }\n      }\n\n      return data;\n    }\n    /**\n     * Pushes the given operation data to the queue, along with the\n     * current Timestamp, then resets the update timer.\n     *\n     * @param {string} counter\n     * @param {number} inc\n     * @returns {void}\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(counter, inc) {\n      this._queue.push([counter, inc, Date.now()]);\n\n      this._resetComputeTimeout();\n    }\n    /**\n     * Resets the timeout for triggering updates.\n     *\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_resetComputeTimeout\",\n    value: function _resetComputeTimeout() {\n      this._timeout = retimer(this._update, this._nextTimeout());\n    }\n    /**\n     * Calculates and returns the timeout for the next update based on\n     * the urgency of the update.\n     *\n     * @private\n     * @returns {number}\n     */\n\n  }, {\n    key: \"_nextTimeout\",\n    value: function _nextTimeout() {\n      // calculate the need for an update, depending on the queue length\n      var urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;\n      var timeout = Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);\n      return timeout;\n    }\n    /**\n     * If there are items in the queue, they will will be processed and\n     * the frequency for all items will be updated based on the Timestamp\n     * of the last item in the queue. The `update` event will also be emitted\n     * with the latest stats.\n     *\n     * If there are no items in the queue, no action is taken.\n     *\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      this._timeout = null;\n\n      if (this._queue.length) {\n        var last;\n\n        var _iterator = _createForOfIteratorHelper(this._queue),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            last = _step.value;\n\n            this._applyOp(last);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this._queue = [];\n\n        this._updateFrequency(last[2]); // contains timestamp of last op\n\n\n        this.emit('update', this._stats);\n      }\n    }\n    /**\n     * For each key in the stats, the frequency and moving averages\n     * will be updated via Stats._updateFrequencyFor based on the time\n     * difference between calls to this method.\n     *\n     * @private\n     * @param {Timestamp} latestTime\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_updateFrequency\",\n    value: function _updateFrequency(latestTime) {\n      var _this2 = this;\n\n      var timeDiff = latestTime - this._frequencyLastTime;\n      Object.keys(this._stats).forEach(function (key) {\n        _this2._updateFrequencyFor(key, timeDiff, latestTime);\n      });\n      this._frequencyLastTime = latestTime;\n    }\n    /**\n     * Updates the `movingAverages` for the given `key` and also\n     * resets the `frequencyAccumulator` for the `key`.\n     *\n     * @private\n     * @param {string} key\n     * @param {number} timeDiffMS - Time in milliseconds\n     * @param {Timestamp} latestTime - Time in ticks\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_updateFrequencyFor\",\n    value: function _updateFrequencyFor(key, timeDiffMS, latestTime) {\n      var count = this._frequencyAccumulators[key] || 0;\n      this._frequencyAccumulators[key] = 0; // if `timeDiff` is zero, `hz` becomes Infinity, so we fallback to 1ms\n\n      var safeTimeDiff = timeDiffMS || 1;\n      var hz = count / safeTimeDiff * 1000;\n      var movingAverages = this._movingAverages[key];\n\n      if (!movingAverages) {\n        movingAverages = this._movingAverages[key] = {};\n      }\n\n      var intervals = this._options.movingAverageIntervals;\n\n      for (var i = 0; i < intervals.length; i++) {\n        var movingAverageInterval = intervals[i];\n        var movingAverage = movingAverages[movingAverageInterval];\n\n        if (!movingAverage) {\n          movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval);\n        }\n\n        movingAverage.push(latestTime, hz);\n      }\n    }\n    /**\n     * For the given operation, `op`, the stats and `frequencyAccumulator`\n     * will be updated or initialized if they don't already exist.\n     *\n     * @private\n     * @param {{string, number}[]} op\n     * @throws {InvalidNumber}\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_applyOp\",\n    value: function _applyOp(op) {\n      var key = op[0];\n      var inc = op[1];\n\n      if (typeof inc !== 'number') {\n        throw new Error(\"invalid increment number: \".concat(inc));\n      }\n\n      var n;\n\n      if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {\n        n = this._stats[key] = Big(0);\n      } else {\n        n = this._stats[key];\n      }\n\n      this._stats[key] = n.plus(inc);\n\n      if (!this._frequencyAccumulators[key]) {\n        this._frequencyAccumulators[key] = 0;\n      }\n\n      this._frequencyAccumulators[key] += inc;\n    }\n  }]);\n\n  return Stats;\n}(EventEmitter);\n\nmodule.exports = Stats;","map":{"version":3,"names":["require","EventEmitter","Big","BigNumber","MovingAverage","retimer","Stats","initialCounters","options","_options","_queue","_stats","dataReceived","dataSent","_frequencyLastTime","Date","now","_frequencyAccumulators","_movingAverages","_update","bind","intervals","movingAverageIntervals","i","length","key","k","interval","ma","push","_resetComputeTimeout","_timeout","clear","Object","assign","snapshot","movingAverages","data","toString","counters","keys","movingAverage","counter","inc","_nextTimeout","urgency","computeThrottleMaxQueueSize","timeout","Math","max","computeThrottleTimeout","last","_applyOp","_updateFrequency","emit","latestTime","timeDiff","forEach","_updateFrequencyFor","timeDiffMS","count","safeTimeDiff","hz","movingAverageInterval","op","Error","n","prototype","hasOwnProperty","call","plus","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/metrics/stats.js"],"sourcesContent":["// @ts-nocheck\n'use strict'\n\nconst { EventEmitter } = require('events')\nconst { BigNumber: Big } = require('bignumber.js')\nconst MovingAverage = require('@vascosantos/moving-average')\nconst retimer = require('retimer')\n\n/**\n * @typedef {import('@vascosantos/moving-average').IMovingAverage} IMovingAverage\n */\n\nclass Stats extends EventEmitter {\n  /**\n   * A queue based manager for stat processing\n   *\n   * @class\n   * @param {string[]} initialCounters\n   * @param {any} options\n   */\n  constructor (initialCounters, options) {\n    super()\n\n    this._options = options\n    this._queue = []\n\n    /** @type {{ dataReceived: Big, dataSent: Big }} */\n    this._stats = {\n      dataReceived: Big(0),\n      dataSent: Big(0)\n    }\n\n    this._frequencyLastTime = Date.now()\n    this._frequencyAccumulators = {}\n\n    /** @type {{ dataReceived: IMovingAverage[], dataSent: IMovingAverage[] }} */\n    this._movingAverages = {}\n\n    this._update = this._update.bind(this)\n\n    const intervals = this._options.movingAverageIntervals\n\n    for (let i = 0; i < initialCounters.length; i++) {\n      const key = initialCounters[i]\n      this._stats[key] = Big(0)\n      this._movingAverages[key] = {}\n      for (let k = 0; k < intervals.length; k++) {\n        const interval = intervals[k]\n        const ma = this._movingAverages[key][interval] = MovingAverage(interval)\n        ma.push(this._frequencyLastTime, 0)\n      }\n    }\n  }\n\n  /**\n   * Initializes the internal timer if there are items in the queue. This\n   * should only need to be called if `Stats.stop` was previously called, as\n   * `Stats.push` will also start the processing.\n   *\n   * @returns {void}\n   */\n  start () {\n    if (this._queue.length) {\n      this._resetComputeTimeout()\n    }\n  }\n\n  /**\n   * Stops processing and computing of stats by clearing the internal\n   * timer.\n   *\n   * @returns {void}\n   */\n  stop () {\n    if (this._timeout) {\n      this._timeout.clear()\n      this._timeout = null\n    }\n  }\n\n  /**\n   * Returns a clone of the current stats.\n   */\n  get snapshot () {\n    return Object.assign({}, this._stats)\n  }\n\n  /**\n   * Returns a clone of the internal movingAverages\n   */\n  get movingAverages () {\n    return Object.assign({}, this._movingAverages)\n  }\n\n  /**\n   * Returns a plain JSON object of the stats\n   *\n   * @returns {*}\n   */\n  toJSON () {\n    const snapshot = this.snapshot\n    const movingAverages = this.movingAverages\n    const data = {\n      dataReceived: snapshot.dataReceived.toString(),\n      dataSent: snapshot.dataSent.toString(),\n      movingAverages: {}\n    }\n\n    const counters = Object.keys(movingAverages)\n    for (const key of counters) {\n      data.movingAverages[key] = {}\n      for (const interval of Object.keys(movingAverages[key])) {\n        data.movingAverages[key][interval] = movingAverages[key][interval].movingAverage()\n      }\n    }\n\n    return data\n  }\n\n  /**\n   * Pushes the given operation data to the queue, along with the\n   * current Timestamp, then resets the update timer.\n   *\n   * @param {string} counter\n   * @param {number} inc\n   * @returns {void}\n   */\n  push (counter, inc) {\n    this._queue.push([counter, inc, Date.now()])\n    this._resetComputeTimeout()\n  }\n\n  /**\n   * Resets the timeout for triggering updates.\n   *\n   * @private\n   * @returns {void}\n   */\n  _resetComputeTimeout () {\n    this._timeout = retimer(this._update, this._nextTimeout())\n  }\n\n  /**\n   * Calculates and returns the timeout for the next update based on\n   * the urgency of the update.\n   *\n   * @private\n   * @returns {number}\n   */\n  _nextTimeout () {\n    // calculate the need for an update, depending on the queue length\n    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize\n    const timeout = Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0)\n    return timeout\n  }\n\n  /**\n   * If there are items in the queue, they will will be processed and\n   * the frequency for all items will be updated based on the Timestamp\n   * of the last item in the queue. The `update` event will also be emitted\n   * with the latest stats.\n   *\n   * If there are no items in the queue, no action is taken.\n   *\n   * @private\n   * @returns {void}\n   */\n  _update () {\n    this._timeout = null\n    if (this._queue.length) {\n      let last\n      for (last of this._queue) {\n        this._applyOp(last)\n      }\n      this._queue = []\n\n      this._updateFrequency(last[2]) // contains timestamp of last op\n\n      this.emit('update', this._stats)\n    }\n  }\n\n  /**\n   * For each key in the stats, the frequency and moving averages\n   * will be updated via Stats._updateFrequencyFor based on the time\n   * difference between calls to this method.\n   *\n   * @private\n   * @param {Timestamp} latestTime\n   * @returns {void}\n   */\n  _updateFrequency (latestTime) {\n    const timeDiff = latestTime - this._frequencyLastTime\n\n    Object.keys(this._stats).forEach((key) => {\n      this._updateFrequencyFor(key, timeDiff, latestTime)\n    })\n\n    this._frequencyLastTime = latestTime\n  }\n\n  /**\n   * Updates the `movingAverages` for the given `key` and also\n   * resets the `frequencyAccumulator` for the `key`.\n   *\n   * @private\n   * @param {string} key\n   * @param {number} timeDiffMS - Time in milliseconds\n   * @param {Timestamp} latestTime - Time in ticks\n   * @returns {void}\n   */\n  _updateFrequencyFor (key, timeDiffMS, latestTime) {\n    const count = this._frequencyAccumulators[key] || 0\n    this._frequencyAccumulators[key] = 0\n    // if `timeDiff` is zero, `hz` becomes Infinity, so we fallback to 1ms\n    const safeTimeDiff = timeDiffMS || 1\n    const hz = (count / safeTimeDiff) * 1000\n\n    let movingAverages = this._movingAverages[key]\n    if (!movingAverages) {\n      movingAverages = this._movingAverages[key] = {}\n    }\n\n    const intervals = this._options.movingAverageIntervals\n\n    for (let i = 0; i < intervals.length; i++) {\n      const movingAverageInterval = intervals[i]\n      let movingAverage = movingAverages[movingAverageInterval]\n      if (!movingAverage) {\n        movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval)\n      }\n      movingAverage.push(latestTime, hz)\n    }\n  }\n\n  /**\n   * For the given operation, `op`, the stats and `frequencyAccumulator`\n   * will be updated or initialized if they don't already exist.\n   *\n   * @private\n   * @param {{string, number}[]} op\n   * @throws {InvalidNumber}\n   * @returns {void}\n   */\n  _applyOp (op) {\n    const key = op[0]\n    const inc = op[1]\n\n    if (typeof inc !== 'number') {\n      throw new Error(`invalid increment number: ${inc}`)\n    }\n\n    let n\n\n    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {\n      n = this._stats[key] = Big(0)\n    } else {\n      n = this._stats[key]\n    }\n    this._stats[key] = n.plus(inc)\n\n    if (!this._frequencyAccumulators[key]) {\n      this._frequencyAccumulators[key] = 0\n    }\n    this._frequencyAccumulators[key] += inc\n  }\n}\n\nmodule.exports = Stats\n"],"mappings":"AAAA;AACA;;;;;;;;;;;;;;AAEA,eAAyBA,OAAO,CAAC,QAAD,CAAhC;AAAA,IAAQC,YAAR,YAAQA,YAAR;;AACA,gBAA2BD,OAAO,CAAC,cAAD,CAAlC;AAAA,IAAmBE,GAAnB,aAAQC,SAAR;;AACA,IAAMC,aAAa,GAAGJ,OAAO,CAAC,6BAAD,CAA7B;;AACA,IAAMK,OAAO,GAAGL,OAAO,CAAC,SAAD,CAAvB;AAEA;AACA;AACA;;;IAEMM,K;;;;;EACJ;AACF;AACA;AACA;AACA;AACA;AACA;EACE,eAAaC,eAAb,EAA8BC,OAA9B,EAAuC;IAAA;;IAAA;;IACrC;IAEA,MAAKC,QAAL,GAAgBD,OAAhB;IACA,MAAKE,MAAL,GAAc,EAAd;IAEA;;IACA,MAAKC,MAAL,GAAc;MACZC,YAAY,EAAEV,GAAG,CAAC,CAAD,CADL;MAEZW,QAAQ,EAAEX,GAAG,CAAC,CAAD;IAFD,CAAd;IAKA,MAAKY,kBAAL,GAA0BC,IAAI,CAACC,GAAL,EAA1B;IACA,MAAKC,sBAAL,GAA8B,EAA9B;IAEA;;IACA,MAAKC,eAAL,GAAuB,EAAvB;IAEA,MAAKC,OAAL,GAAe,MAAKA,OAAL,CAAaC,IAAb,+BAAf;IAEA,IAAMC,SAAS,GAAG,MAAKZ,QAAL,CAAca,sBAAhC;;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,eAAe,CAACiB,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;MAC/C,IAAME,GAAG,GAAGlB,eAAe,CAACgB,CAAD,CAA3B;MACA,MAAKZ,MAAL,CAAYc,GAAZ,IAAmBvB,GAAG,CAAC,CAAD,CAAtB;MACA,MAAKgB,eAAL,CAAqBO,GAArB,IAA4B,EAA5B;;MACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,SAAS,CAACG,MAA9B,EAAsCE,CAAC,EAAvC,EAA2C;QACzC,IAAMC,QAAQ,GAAGN,SAAS,CAACK,CAAD,CAA1B;QACA,IAAME,EAAE,GAAG,MAAKV,eAAL,CAAqBO,GAArB,EAA0BE,QAA1B,IAAsCvB,aAAa,CAACuB,QAAD,CAA9D;QACAC,EAAE,CAACC,IAAH,CAAQ,MAAKf,kBAAb,EAAiC,CAAjC;MACD;IACF;;IA/BoC;EAgCtC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;;WACE,iBAAS;MACP,IAAI,KAAKJ,MAAL,CAAYc,MAAhB,EAAwB;QACtB,KAAKM,oBAAL;MACD;IACF;IAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,gBAAQ;MACN,IAAI,KAAKC,QAAT,EAAmB;QACjB,KAAKA,QAAL,CAAcC,KAAd;;QACA,KAAKD,QAAL,GAAgB,IAAhB;MACD;IACF;IAED;AACF;AACA;;;;SACE,eAAgB;MACd,OAAOE,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKvB,MAAvB,CAAP;IACD;IAED;AACF;AACA;;;;SACE,eAAsB;MACpB,OAAOsB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKhB,eAAvB,CAAP;IACD;IAED;AACF;AACA;AACA;AACA;;;;WACE,kBAAU;MACR,IAAMiB,QAAQ,GAAG,KAAKA,QAAtB;MACA,IAAMC,cAAc,GAAG,KAAKA,cAA5B;MACA,IAAMC,IAAI,GAAG;QACXzB,YAAY,EAAEuB,QAAQ,CAACvB,YAAT,CAAsB0B,QAAtB,EADH;QAEXzB,QAAQ,EAAEsB,QAAQ,CAACtB,QAAT,CAAkByB,QAAlB,EAFC;QAGXF,cAAc,EAAE;MAHL,CAAb;MAMA,IAAMG,QAAQ,GAAGN,MAAM,CAACO,IAAP,CAAYJ,cAAZ,CAAjB;;MACA,6BAAkBG,QAAlB,+BAA4B;QAAvB,IAAMd,GAAG,gBAAT;QACHY,IAAI,CAACD,cAAL,CAAoBX,GAApB,IAA2B,EAA3B;;QACA,iCAAuBQ,MAAM,CAACO,IAAP,CAAYJ,cAAc,CAACX,GAAD,CAA1B,CAAvB,oCAAyD;UAApD,IAAME,QAAQ,oBAAd;UACHU,IAAI,CAACD,cAAL,CAAoBX,GAApB,EAAyBE,QAAzB,IAAqCS,cAAc,CAACX,GAAD,CAAd,CAAoBE,QAApB,EAA8Bc,aAA9B,EAArC;QACD;MACF;;MAED,OAAOJ,IAAP;IACD;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,cAAMK,OAAN,EAAeC,GAAf,EAAoB;MAClB,KAAKjC,MAAL,CAAYmB,IAAZ,CAAiB,CAACa,OAAD,EAAUC,GAAV,EAAe5B,IAAI,CAACC,GAAL,EAAf,CAAjB;;MACA,KAAKc,oBAAL;IACD;IAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,gCAAwB;MACtB,KAAKC,QAAL,GAAgB1B,OAAO,CAAC,KAAKc,OAAN,EAAe,KAAKyB,YAAL,EAAf,CAAvB;IACD;IAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,wBAAgB;MACd;MACA,IAAMC,OAAO,GAAG,KAAKnC,MAAL,CAAYc,MAAZ,GAAqB,KAAKf,QAAL,CAAcqC,2BAAnD;MACA,IAAMC,OAAO,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAKxC,QAAL,CAAcyC,sBAAd,IAAwC,IAAIL,OAA5C,CAAT,EAA+D,CAA/D,CAAhB;MACA,OAAOE,OAAP;IACD;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,mBAAW;MACT,KAAKhB,QAAL,GAAgB,IAAhB;;MACA,IAAI,KAAKrB,MAAL,CAAYc,MAAhB,EAAwB;QACtB,IAAI2B,IAAJ;;QADsB,2CAET,KAAKzC,MAFI;QAAA;;QAAA;UAEtB,oDAA0B;YAArByC,IAAqB;;YACxB,KAAKC,QAAL,CAAcD,IAAd;UACD;QAJqB;UAAA;QAAA;UAAA;QAAA;;QAKtB,KAAKzC,MAAL,GAAc,EAAd;;QAEA,KAAK2C,gBAAL,CAAsBF,IAAI,CAAC,CAAD,CAA1B,EAPsB,CAOS;;;QAE/B,KAAKG,IAAL,CAAU,QAAV,EAAoB,KAAK3C,MAAzB;MACD;IACF;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,0BAAkB4C,UAAlB,EAA8B;MAAA;;MAC5B,IAAMC,QAAQ,GAAGD,UAAU,GAAG,KAAKzC,kBAAnC;MAEAmB,MAAM,CAACO,IAAP,CAAY,KAAK7B,MAAjB,EAAyB8C,OAAzB,CAAiC,UAAChC,GAAD,EAAS;QACxC,MAAI,CAACiC,mBAAL,CAAyBjC,GAAzB,EAA8B+B,QAA9B,EAAwCD,UAAxC;MACD,CAFD;MAIA,KAAKzC,kBAAL,GAA0ByC,UAA1B;IACD;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,6BAAqB9B,GAArB,EAA0BkC,UAA1B,EAAsCJ,UAAtC,EAAkD;MAChD,IAAMK,KAAK,GAAG,KAAK3C,sBAAL,CAA4BQ,GAA5B,KAAoC,CAAlD;MACA,KAAKR,sBAAL,CAA4BQ,GAA5B,IAAmC,CAAnC,CAFgD,CAGhD;;MACA,IAAMoC,YAAY,GAAGF,UAAU,IAAI,CAAnC;MACA,IAAMG,EAAE,GAAIF,KAAK,GAAGC,YAAT,GAAyB,IAApC;MAEA,IAAIzB,cAAc,GAAG,KAAKlB,eAAL,CAAqBO,GAArB,CAArB;;MACA,IAAI,CAACW,cAAL,EAAqB;QACnBA,cAAc,GAAG,KAAKlB,eAAL,CAAqBO,GAArB,IAA4B,EAA7C;MACD;;MAED,IAAMJ,SAAS,GAAG,KAAKZ,QAAL,CAAca,sBAAhC;;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAAS,CAACG,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;QACzC,IAAMwC,qBAAqB,GAAG1C,SAAS,CAACE,CAAD,CAAvC;QACA,IAAIkB,aAAa,GAAGL,cAAc,CAAC2B,qBAAD,CAAlC;;QACA,IAAI,CAACtB,aAAL,EAAoB;UAClBA,aAAa,GAAGL,cAAc,CAAC2B,qBAAD,CAAd,GAAwC3D,aAAa,CAAC2D,qBAAD,CAArE;QACD;;QACDtB,aAAa,CAACZ,IAAd,CAAmB0B,UAAnB,EAA+BO,EAA/B;MACD;IACF;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,kBAAUE,EAAV,EAAc;MACZ,IAAMvC,GAAG,GAAGuC,EAAE,CAAC,CAAD,CAAd;MACA,IAAMrB,GAAG,GAAGqB,EAAE,CAAC,CAAD,CAAd;;MAEA,IAAI,OAAOrB,GAAP,KAAe,QAAnB,EAA6B;QAC3B,MAAM,IAAIsB,KAAJ,qCAAuCtB,GAAvC,EAAN;MACD;;MAED,IAAIuB,CAAJ;;MAEA,IAAI,CAACjC,MAAM,CAACkC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqC,KAAK1D,MAA1C,EAAkDc,GAAlD,CAAL,EAA6D;QAC3DyC,CAAC,GAAG,KAAKvD,MAAL,CAAYc,GAAZ,IAAmBvB,GAAG,CAAC,CAAD,CAA1B;MACD,CAFD,MAEO;QACLgE,CAAC,GAAG,KAAKvD,MAAL,CAAYc,GAAZ,CAAJ;MACD;;MACD,KAAKd,MAAL,CAAYc,GAAZ,IAAmByC,CAAC,CAACI,IAAF,CAAO3B,GAAP,CAAnB;;MAEA,IAAI,CAAC,KAAK1B,sBAAL,CAA4BQ,GAA5B,CAAL,EAAuC;QACrC,KAAKR,sBAAL,CAA4BQ,GAA5B,IAAmC,CAAnC;MACD;;MACD,KAAKR,sBAAL,CAA4BQ,GAA5B,KAAoCkB,GAApC;IACD;;;;EA7PiB1C,Y;;AAgQpBsE,MAAM,CAACC,OAAP,GAAiBlE,KAAjB"},"metadata":{},"sourceType":"script"}