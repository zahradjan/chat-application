{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst {\n  resolvePath\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  normaliseInput\n} = require('ipfs-core-utils/src/pins/normalise-input');\n\nconst {\n  PinTypes\n} = require('ipfs-repo');\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\n\nmodule.exports = _ref => {\n  let {\n    repo,\n    codecs\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"addAll\"]}\n   */\n  async function* addAll(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * @returns {AsyncIterable<CID>}\n     */\n    const pinAdd = async function* () {\n      for await (const {\n        path,\n        recursive,\n        metadata\n      } of normaliseInput(source)) {\n        const {\n          cid\n        } = await resolvePath(repo, codecs, path); // verify that each hash can be pinned\n\n        const {\n          reason\n        } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]);\n\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(`${cid} already pinned recursively`);\n        }\n\n        if (recursive) {\n          await repo.pins.pinRecursively(cid, {\n            metadata\n          });\n        } else {\n          await repo.pins.pinDirectly(cid, {\n            metadata\n          });\n        }\n\n        yield cid;\n      }\n    }; // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n\n\n    const lock = Boolean(options.lock);\n\n    if (!lock) {\n      yield* pinAdd();\n      return;\n    }\n\n    const release = await repo.gcLock.readLock();\n\n    try {\n      yield* pinAdd();\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption(addAll);\n};","map":{"version":3,"names":["resolvePath","require","withTimeoutOption","normaliseInput","PinTypes","module","exports","repo","codecs","addAll","source","options","pinAdd","path","recursive","metadata","cid","reason","pins","isPinnedWithType","direct","Error","pinRecursively","pinDirectly","lock","Boolean","release","gcLock","readLock"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/pin/add-all.js"],"sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { resolvePath } = require('../../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { normaliseInput } = require('ipfs-core-utils/src/pins/normalise-input')\nconst { PinTypes } = require('ipfs-repo')\n\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nmodule.exports = ({ repo, codecs }) => {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"addAll\"]}\n   */\n  async function * addAll (source, options = {}) {\n    /**\n     * @returns {AsyncIterable<CID>}\n     */\n    const pinAdd = async function * () {\n      for await (const { path, recursive, metadata } of normaliseInput(source)) {\n        const { cid } = await resolvePath(repo, codecs, path)\n\n        // verify that each hash can be pinned\n        const { reason } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct])\n\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(`${cid} already pinned recursively`)\n        }\n\n        if (recursive) {\n          await repo.pins.pinRecursively(cid, { metadata })\n        } else {\n          await repo.pins.pinDirectly(cid, { metadata })\n        }\n\n        yield cid\n      }\n    }\n\n    // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n    const lock = Boolean(options.lock)\n\n    if (!lock) {\n      yield * pinAdd()\n      return\n    }\n\n    const release = await repo.gcLock.readLock()\n\n    try {\n      yield * pinAdd()\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(addAll)\n}\n"],"mappings":"AAAA;AACA;;AAEA,MAAM;EAAEA;AAAF,IAAkBC,OAAO,CAAC,aAAD,CAA/B;;AACA,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,yCAAD,CAAjC;;AACA,MAAM;EAAEE;AAAF,IAAqBF,OAAO,CAAC,0CAAD,CAAlC;;AACA,MAAM;EAAEG;AAAF,IAAeH,OAAO,CAAC,WAAD,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACAI,MAAM,CAACC,OAAP,GAAiB,QAAsB;EAAA,IAArB;IAAEC,IAAF;IAAQC;EAAR,CAAqB;;EACrC;AACF;AACA;EACE,gBAAiBC,MAAjB,CAAyBC,MAAzB,EAA+C;IAAA,IAAdC,OAAc,uEAAJ,EAAI;;IAC7C;AACJ;AACA;IACI,MAAMC,MAAM,GAAG,mBAAoB;MACjC,WAAW,MAAM;QAAEC,IAAF;QAAQC,SAAR;QAAmBC;MAAnB,CAAjB,IAAkDZ,cAAc,CAACO,MAAD,CAAhE,EAA0E;QACxE,MAAM;UAAEM;QAAF,IAAU,MAAMhB,WAAW,CAACO,IAAD,EAAOC,MAAP,EAAeK,IAAf,CAAjC,CADwE,CAGxE;;QACA,MAAM;UAAEI;QAAF,IAAa,MAAMV,IAAI,CAACW,IAAL,CAAUC,gBAAV,CAA2BH,GAA3B,EAAgC,CAACZ,QAAQ,CAACU,SAAV,EAAqBV,QAAQ,CAACgB,MAA9B,CAAhC,CAAzB;;QAEA,IAAIH,MAAM,KAAK,WAAX,IAA0B,CAACH,SAA/B,EAA0C;UACxC;UACA,MAAM,IAAIO,KAAJ,CAAW,GAAEL,GAAI,6BAAjB,CAAN;QACD;;QAED,IAAIF,SAAJ,EAAe;UACb,MAAMP,IAAI,CAACW,IAAL,CAAUI,cAAV,CAAyBN,GAAzB,EAA8B;YAAED;UAAF,CAA9B,CAAN;QACD,CAFD,MAEO;UACL,MAAMR,IAAI,CAACW,IAAL,CAAUK,WAAV,CAAsBP,GAAtB,EAA2B;YAAED;UAAF,CAA3B,CAAN;QACD;;QAED,MAAMC,GAAN;MACD;IACF,CApBD,CAJ6C,CA0B7C;IACA;;;IACA,MAAMQ,IAAI,GAAGC,OAAO,CAACd,OAAO,CAACa,IAAT,CAApB;;IAEA,IAAI,CAACA,IAAL,EAAW;MACT,OAAQZ,MAAM,EAAd;MACA;IACD;;IAED,MAAMc,OAAO,GAAG,MAAMnB,IAAI,CAACoB,MAAL,CAAYC,QAAZ,EAAtB;;IAEA,IAAI;MACF,OAAQhB,MAAM,EAAd;IACD,CAFD,SAEU;MACRc,OAAO;IACR;EACF;;EAED,OAAOxB,iBAAiB,CAACO,MAAD,CAAxB;AACD,CAjDD"},"metadata":{},"sourceType":"script"}