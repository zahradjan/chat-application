{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar PeerId = require('peer-id');\n\nvar _require = require('./rpc'),\n    RPC = _require.RPC;\n\nvar _require2 = require('uint8arrays/concat'),\n    uint8ArrayConcat = _require2.concat;\n\nvar _require3 = require('uint8arrays/from-string'),\n    uint8ArrayFromString = _require3.fromString;\n\nvar SignPrefix = uint8ArrayFromString('libp2p-pubsub:');\n\nvar _require4 = require('../utils'),\n    normalizeOutRpcMessage = _require4.normalizeOutRpcMessage;\n/**\n * @typedef {import('..').InMessage}\n */\n\n/**\n * Signs the provided message with the given `peerId`\n *\n * @param {PeerId} peerId\n * @param {InMessage} message\n * @returns {Promise<InMessage>}\n */\n\n\nfunction signMessage(_x, _x2) {\n  return _signMessage.apply(this, arguments);\n}\n/**\n * Verifies the signature of the given message\n *\n * @param {InMessage} message\n * @returns {Promise<boolean>}\n */\n\n\nfunction _signMessage() {\n  _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(peerId, message) {\n    var bytes, signature;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // Get the message in bytes, and prepend with the pubsub prefix\n            bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(normalizeOutRpcMessage(message)).finish()]);\n            _context.next = 3;\n            return peerId.privKey.sign(bytes);\n\n          case 3:\n            signature = _context.sent;\n            return _context.abrupt(\"return\", _objectSpread(_objectSpread({}, message), {}, {\n              signature: signature,\n              key: peerId.pubKey.bytes\n            }));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _signMessage.apply(this, arguments);\n}\n\nfunction verifySignature(_x3) {\n  return _verifySignature.apply(this, arguments);\n}\n/**\n * Returns the PublicKey associated with the given message.\n * If no, valid PublicKey can be retrieved an error will be returned.\n *\n * @param {InMessage} message\n * @returns {Promise<PublicKey>}\n */\n\n\nfunction _verifySignature() {\n  _verifySignature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(message) {\n    var bytes, pubKey;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (message.signature) {\n              _context2.next = 2;\n              break;\n            }\n\n            throw new Error('Message must contain a signature to be verified');\n\n          case 2:\n            if (message.from) {\n              _context2.next = 4;\n              break;\n            }\n\n            throw new Error('Message must contain a from property to be verified');\n\n          case 4:\n            // Get message sans the signature\n            bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(_objectSpread(_objectSpread({}, message), {}, {\n              from: PeerId.createFromB58String(message.from).toBytes(),\n              signature: undefined,\n              key: undefined\n            })).finish()]); // Get the public key\n\n            _context2.next = 7;\n            return messagePublicKey(message);\n\n          case 7:\n            pubKey = _context2.sent;\n            return _context2.abrupt(\"return\", pubKey.verify(bytes, message.signature));\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _verifySignature.apply(this, arguments);\n}\n\nfunction messagePublicKey(_x4) {\n  return _messagePublicKey.apply(this, arguments);\n}\n/**\n * @typedef {import('..').InMessage} InMessage\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n */\n\n\nfunction _messagePublicKey() {\n  _messagePublicKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(message) {\n    var from, keyPeerId;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (message.from) {\n              _context3.next = 2;\n              break;\n            }\n\n            throw new Error('Could not get the public key from the originator id');\n\n          case 2:\n            from = PeerId.createFromB58String(message.from);\n\n            if (!message.key) {\n              _context3.next = 12;\n              break;\n            }\n\n            _context3.next = 6;\n            return PeerId.createFromPubKey(message.key);\n\n          case 6:\n            keyPeerId = _context3.sent;\n\n            if (!keyPeerId.equals(from)) {\n              _context3.next = 9;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", keyPeerId.pubKey);\n\n          case 9:\n            throw new Error('Public Key does not match the originator');\n\n          case 12:\n            if (!from.pubKey) {\n              _context3.next = 16;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", from.pubKey);\n\n          case 16:\n            throw new Error('Could not get the public key from the originator id');\n\n          case 17:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _messagePublicKey.apply(this, arguments);\n}\n\nmodule.exports = {\n  messagePublicKey: messagePublicKey,\n  signMessage: signMessage,\n  SignPrefix: SignPrefix,\n  verifySignature: verifySignature\n};","map":{"version":3,"names":["PeerId","require","RPC","uint8ArrayConcat","concat","uint8ArrayFromString","fromString","SignPrefix","normalizeOutRpcMessage","signMessage","peerId","message","bytes","Message","encode","finish","privKey","sign","signature","key","pubKey","verifySignature","Error","from","createFromB58String","toBytes","undefined","messagePublicKey","verify","createFromPubKey","keyPeerId","equals","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-interfaces/src/pubsub/message/sign.js"],"sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { RPC } = require('./rpc')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst SignPrefix = uint8ArrayFromString('libp2p-pubsub:')\nconst { normalizeOutRpcMessage } = require('../utils')\n\n/**\n * @typedef {import('..').InMessage}\n */\n\n/**\n * Signs the provided message with the given `peerId`\n *\n * @param {PeerId} peerId\n * @param {InMessage} message\n * @returns {Promise<InMessage>}\n */\nasync function signMessage (peerId, message) {\n  // Get the message in bytes, and prepend with the pubsub prefix\n  const bytes = uint8ArrayConcat([\n    SignPrefix,\n    RPC.Message.encode(normalizeOutRpcMessage(message)).finish()\n  ])\n\n  const signature = await peerId.privKey.sign(bytes)\n\n  return {\n    ...message,\n    signature: signature,\n    key: peerId.pubKey.bytes\n  }\n}\n\n/**\n * Verifies the signature of the given message\n *\n * @param {InMessage} message\n * @returns {Promise<boolean>}\n */\nasync function verifySignature (message) {\n  if (!message.signature) {\n    throw new Error('Message must contain a signature to be verified')\n  }\n\n  if (!message.from) {\n    throw new Error('Message must contain a from property to be verified')\n  }\n\n  // Get message sans the signature\n  const bytes = uint8ArrayConcat([\n    SignPrefix,\n    RPC.Message.encode({\n      ...message,\n      from: PeerId.createFromB58String(message.from).toBytes(),\n      signature: undefined,\n      key: undefined\n    }).finish()\n  ])\n\n  // Get the public key\n  const pubKey = await messagePublicKey(message)\n\n  // verify the base message\n  return pubKey.verify(bytes, message.signature)\n}\n\n/**\n * Returns the PublicKey associated with the given message.\n * If no, valid PublicKey can be retrieved an error will be returned.\n *\n * @param {InMessage} message\n * @returns {Promise<PublicKey>}\n */\nasync function messagePublicKey (message) {\n  // should be available in the from property of the message (peer id)\n  if (!message.from) {\n    throw new Error('Could not get the public key from the originator id')\n  }\n\n  const from = PeerId.createFromB58String(message.from)\n\n  if (message.key) {\n    const keyPeerId = await PeerId.createFromPubKey(message.key)\n\n    // the key belongs to the sender, return the key\n    if (keyPeerId.equals(from)) return keyPeerId.pubKey\n    // We couldn't validate pubkey is from the originator, error\n    throw new Error('Public Key does not match the originator')\n  } else if (from.pubKey) {\n    return from.pubKey\n  } else {\n    throw new Error('Could not get the public key from the originator id')\n  }\n}\n\n/**\n * @typedef {import('..').InMessage} InMessage\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n */\n\nmodule.exports = {\n  messagePublicKey,\n  signMessage,\n  SignPrefix,\n  verifySignature\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}