{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar _require2 = require('p-queue'),\n    Queue = _require2.default;\n\nvar _get = require('just-safe-get');\n\nvar _set = require('just-safe-set');\n\nvar errCode = require('err-code');\n\nvar errors = require('./errors');\n\nvar _require3 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require3.toString;\n\nvar _require4 = require('uint8arrays/from-string'),\n    uint8ArrayFromString = _require4.fromString;\n\nvar _require5 = require('ipfs-repo-migrations/src/utils'),\n    hasWithFallback = _require5.hasWithFallback,\n    getWithFallback = _require5.getWithFallback;\n\nvar configKey = new Key('config');\n/**\n * @typedef {import('./types').Config} Config\n */\n\n/**\n * @param {import('interface-datastore').Datastore} store\n */\n\nmodule.exports = function (store) {\n  var setQueue = new Queue({\n    concurrency: 1\n  });\n  var configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     * @returns {Promise<Config>}\n     */\n    getAll: function getAll() {\n      var _arguments = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var options, encodedValue;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {};\n                _context.next = 3;\n                return getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store, {\n                  signal: options.signal\n                });\n\n              case 3:\n                encodedValue = _context.sent;\n                return _context.abrupt(\"return\", JSON.parse(uint8ArrayToString(encodedValue)));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {string} key - the config key to get\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     */\n    get: function get(key) {\n      var _arguments2 = arguments,\n          _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var options, config, value;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};\n\n                if (!(key == null)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new errors.NotFoundError(\"Key \".concat(key, \" does not exist in config\"));\n\n              case 3:\n                _context2.next = 5;\n                return _this.getAll(options);\n\n              case 5:\n                config = _context2.sent;\n                value = _get(config, key);\n\n                if (!(value === undefined)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                throw new errors.NotFoundError(\"Key \".concat(key, \" does not exist in config\"));\n\n              case 9:\n                return _context2.abrupt(\"return\", value);\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {string} key - the config key to be written\n     * @param {any} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    set: function set(key, value) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      // @ts-ignore ts thinks key will only be a string, but it may not be\n      if (typeof key !== 'string' && !(key instanceof String)) {\n        throw errCode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY');\n      }\n\n      if (value === undefined || value instanceof Uint8Array) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(function () {\n        return _maybeDoSet({\n          key: key,\n          value: value\n        }, options.signal);\n      });\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Config} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    replace: function replace(value) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!value || value instanceof Uint8Array) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(function () {\n        return _maybeDoSet({\n          key: undefined,\n          value: value\n        }, options.signal);\n      });\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     */\n    exists: function exists() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", hasWithFallback(configKey, store.has.bind(store), store));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    }\n  };\n  return configStore;\n  /**\n   * @param {{ key: any; value: any; }} m\n   * @param {AbortSignal | undefined} signal\n   */\n\n  function _maybeDoSet(_x, _x2) {\n    return _maybeDoSet2.apply(this, arguments);\n  }\n  /**\n   * @param {unknown} config\n   */\n\n\n  function _maybeDoSet2() {\n    _maybeDoSet2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(m, signal) {\n      var key, value, config;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(signal && signal.aborted)) {\n                _context4.next = 2;\n                break;\n              }\n\n              return _context4.abrupt(\"return\");\n\n            case 2:\n              key = m.key;\n              value = m.value;\n\n              if (!key) {\n                _context4.next = 10;\n                break;\n              }\n\n              _context4.next = 7;\n              return configStore.getAll();\n\n            case 7:\n              config = _context4.sent;\n\n              if (typeof config === 'object' && config !== null) {\n                _set(config, key, value);\n              }\n\n              return _context4.abrupt(\"return\", _saveAll(config));\n\n            case 10:\n              return _context4.abrupt(\"return\", _saveAll(value));\n\n            case 11:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return _maybeDoSet2.apply(this, arguments);\n  }\n\n  function _saveAll(config) {\n    var buf = uint8ArrayFromString(JSON.stringify(config, null, 2));\n    return store.put(configKey, buf);\n  }\n};","map":{"version":3,"names":["require","Key","Queue","default","_get","_set","errCode","errors","uint8ArrayToString","toString","uint8ArrayFromString","fromString","hasWithFallback","getWithFallback","configKey","module","exports","store","setQueue","concurrency","configStore","getAll","options","get","bind","has","signal","encodedValue","JSON","parse","key","NotFoundError","config","value","undefined","set","String","Error","Uint8Array","add","_maybeDoSet","replace","exists","m","aborted","_saveAll","buf","stringify","put"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-repo/src/config.js"],"sourcesContent":["'use strict'\n\nconst { Key } = require('interface-datastore')\nconst { default: Queue } = require('p-queue')\nconst _get = require('just-safe-get')\nconst _set = require('just-safe-set')\nconst errCode = require('err-code')\nconst errors = require('./errors')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst {\n  hasWithFallback,\n  getWithFallback\n// @ts-ignore\n} = require('ipfs-repo-migrations/src/utils')\n\nconst configKey = new Key('config')\n\n/**\n * @typedef {import('./types').Config} Config\n */\n\n/**\n * @param {import('interface-datastore').Datastore} store\n */\nmodule.exports = (store) => {\n  const setQueue = new Queue({ concurrency: 1 })\n\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     * @returns {Promise<Config>}\n     */\n    async getAll (options = {}) { // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      const encodedValue = await getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store, {\n        signal: options.signal\n      })\n\n      return JSON.parse(uint8ArrayToString(encodedValue))\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {string} key - the config key to get\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     */\n    async get (key, options = {}) {\n      if (key == null) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`)\n      }\n\n      const config = await this.getAll(options)\n      const value = _get(config, key)\n\n      if (value === undefined) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`)\n      }\n\n      return value\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {string} key - the config key to be written\n     * @param {any} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    set (key, value, options = {}) {\n      // @ts-ignore ts thinks key will only be a string, but it may not be\n      if (typeof key !== 'string' && !(key instanceof String)) {\n        throw errCode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY')\n      }\n\n      if (value === undefined || (value instanceof Uint8Array)) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Config} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    replace (value, options = {}) {\n      if (!value || (value instanceof Uint8Array)) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     */\n    async exists () { // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      return hasWithFallback(configKey, store.has.bind(store), store)\n    }\n  }\n\n  return configStore\n\n  /**\n   * @param {{ key: any; value: any; }} m\n   * @param {AbortSignal | undefined} signal\n   */\n  async function _maybeDoSet (m, signal) {\n    if (signal && signal.aborted) {\n      return\n    }\n\n    const key = m.key\n    const value = m.value\n    if (key) {\n      const config = await configStore.getAll()\n      if (typeof config === 'object' && config !== null) {\n        _set(config, key, value)\n      }\n      return _saveAll(config)\n    }\n    return _saveAll(value)\n  }\n\n  /**\n   * @param {unknown} config\n   */\n  function _saveAll (config) {\n    const buf = uint8ArrayFromString(JSON.stringify(config, null, 2))\n    return store.put(configKey, buf)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}