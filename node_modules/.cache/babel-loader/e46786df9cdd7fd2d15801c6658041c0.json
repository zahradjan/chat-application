{"ast":null,"code":"/* eslint complexity: [\"error\", 27] */\n'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar defaultMigrations = require('../migrations');\n\nvar repoVersion = require('./repo/version');\n\nvar errors = require('./errors');\n\nvar _require = require('./utils'),\n    wrapBackends = _require.wrapBackends;\n\nvar log = require('debug')('ipfs:repo:migrator');\n/**\n * @typedef {import('./types').Migration} Migration\n * @typedef {import('./types').MigrationOptions} MigrationOptions\n * @typedef {import('./types').ProgressCallback} ProgressCallback\n * @typedef {import('./types').MigrationProgressCallback} MigrationProgressCallback\n */\n\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {Migration[]} [migrations] - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n */\n\n\nfunction getLatestMigrationVersion(migrations) {\n  migrations = migrations || defaultMigrations;\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0;\n  }\n\n  return migrations[migrations.length - 1].version;\n}\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo should be migrated.\n * @param {MigrationOptions} [options] - Options for migration\n */\n\n\nfunction migrate(_x, _x2, _x3, _x4, _x5) {\n  return _migrate.apply(this, arguments);\n}\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo will be reverted.\n * @param {MigrationOptions} [options] - Options for the reversion\n */\n\n\nfunction _migrate() {\n  _migrate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(path, backends, repoOptions, toVersion, _ref) {\n    var _ref$ignoreLock, ignoreLock, onProgress, _ref$isDryRun, isDryRun, migrations, currentVersion, lock, _iterator2, _step2, _loop, _ret;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref$ignoreLock = _ref.ignoreLock, ignoreLock = _ref$ignoreLock === void 0 ? false : _ref$ignoreLock, onProgress = _ref.onProgress, _ref$isDryRun = _ref.isDryRun, isDryRun = _ref$isDryRun === void 0 ? false : _ref$isDryRun, migrations = _ref.migrations;\n            migrations = migrations || defaultMigrations;\n\n            if (path) {\n              _context2.next = 4;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('Path argument is required!');\n\n          case 4:\n            if (repoOptions) {\n              _context2.next = 6;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('repoOptions argument is required!');\n\n          case 6:\n            if (toVersion) {\n              _context2.next = 8;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('toVersion argument is required!');\n\n          case 8:\n            if (!(!Number.isInteger(toVersion) || toVersion <= 0)) {\n              _context2.next = 10;\n              break;\n            }\n\n            throw new errors.InvalidValueError('Version has to be positive integer!');\n\n          case 10:\n            // make sure we can read pre-level@5 datastores\n            backends = wrapBackends(backends);\n            _context2.next = 13;\n            return repoVersion.getVersion(backends);\n\n          case 13:\n            currentVersion = _context2.sent;\n\n            if (!(currentVersion === toVersion)) {\n              _context2.next = 17;\n              break;\n            }\n\n            log('Nothing to migrate.');\n            return _context2.abrupt(\"return\");\n\n          case 17:\n            if (!(currentVersion > toVersion)) {\n              _context2.next = 19;\n              break;\n            }\n\n            throw new errors.InvalidValueError(\"Current repo's version (\".concat(currentVersion, \") is higher then toVersion (\").concat(toVersion, \"), you probably wanted to revert it?\"));\n\n          case 19:\n            verifyAvailableMigrations(migrations, currentVersion, toVersion);\n\n            if (!(!isDryRun && !ignoreLock)) {\n              _context2.next = 24;\n              break;\n            }\n\n            _context2.next = 23;\n            return repoOptions.repoLock.lock(path);\n\n          case 23:\n            lock = _context2.sent;\n\n          case 24:\n            _context2.prev = 24;\n            _iterator2 = _createForOfIteratorHelper(migrations);\n            _context2.prev = 26;\n            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n              var migration, progressCallback, lastSuccessfullyMigratedVersion;\n              return _regeneratorRuntime().wrap(function _loop$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      migration = _step2.value;\n\n                      if (!(toVersion !== undefined && migration.version > toVersion)) {\n                        _context.next = 3;\n                        break;\n                      }\n\n                      return _context.abrupt(\"return\", \"break\");\n\n                    case 3:\n                      if (!(migration.version <= currentVersion)) {\n                        _context.next = 5;\n                        break;\n                      }\n\n                      return _context.abrupt(\"return\", \"continue\");\n\n                    case 5:\n                      log(\"Migrating version \".concat(migration.version));\n                      _context.prev = 6;\n\n                      if (isDryRun) {\n                        _context.next = 12;\n                        break;\n                      }\n\n                      /** @type {MigrationProgressCallback} */\n                      progressCallback = function progressCallback() {};\n\n                      if (onProgress) {\n                        // eslint-disable-line max-depth\n                        progressCallback = function progressCallback(percent, message) {\n                          return onProgress(migration.version, percent.toFixed(2), message);\n                        };\n                      }\n\n                      _context.next = 12;\n                      return migration.migrate(backends, progressCallback);\n\n                    case 12:\n                      _context.next = 21;\n                      break;\n\n                    case 14:\n                      _context.prev = 14;\n                      _context.t0 = _context[\"catch\"](6);\n                      lastSuccessfullyMigratedVersion = migration.version - 1;\n                      log(\"An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: \".concat(lastSuccessfullyMigratedVersion));\n                      _context.next = 20;\n                      return repoVersion.setVersion(lastSuccessfullyMigratedVersion, backends);\n\n                    case 20:\n                      throw new Error(\"During migration to version \".concat(migration.version, \" exception was raised: \").concat(_context.t0.stack || _context.t0.message || _context.t0));\n\n                    case 21:\n                      log(\"Migrating to version \".concat(migration.version, \" finished\"));\n\n                    case 22:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _loop, null, [[6, 14]]);\n            });\n\n            _iterator2.s();\n\n          case 29:\n            if ((_step2 = _iterator2.n()).done) {\n              _context2.next = 38;\n              break;\n            }\n\n            return _context2.delegateYield(_loop(), \"t0\", 31);\n\n          case 31:\n            _ret = _context2.t0;\n\n            if (!(_ret === \"break\")) {\n              _context2.next = 34;\n              break;\n            }\n\n            return _context2.abrupt(\"break\", 38);\n\n          case 34:\n            if (!(_ret === \"continue\")) {\n              _context2.next = 36;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 36);\n\n          case 36:\n            _context2.next = 29;\n            break;\n\n          case 38:\n            _context2.next = 43;\n            break;\n\n          case 40:\n            _context2.prev = 40;\n            _context2.t1 = _context2[\"catch\"](26);\n\n            _iterator2.e(_context2.t1);\n\n          case 43:\n            _context2.prev = 43;\n\n            _iterator2.f();\n\n            return _context2.finish(43);\n\n          case 46:\n            if (isDryRun) {\n              _context2.next = 49;\n              break;\n            }\n\n            _context2.next = 49;\n            return repoVersion.setVersion(toVersion || getLatestMigrationVersion(migrations), backends);\n\n          case 49:\n            log('Repo successfully migrated', toVersion !== undefined ? \"to version \".concat(toVersion, \"!\") : 'to latest version!');\n\n          case 50:\n            _context2.prev = 50;\n\n            if (!(!isDryRun && !ignoreLock && lock)) {\n              _context2.next = 54;\n              break;\n            }\n\n            _context2.next = 54;\n            return lock.close();\n\n          case 54:\n            return _context2.finish(50);\n\n          case 55:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee, null, [[24,, 50, 55], [26, 40, 43, 46]]);\n  }));\n  return _migrate.apply(this, arguments);\n}\n\nfunction revert(_x6, _x7, _x8, _x9, _x10) {\n  return _revert.apply(this, arguments);\n}\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {Migration[]} migrations\n * @param {number} fromVersion\n * @param {number} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n */\n\n\nfunction _revert() {\n  _revert = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path, backends, repoOptions, toVersion, _ref2) {\n    var _ref2$ignoreLock, ignoreLock, onProgress, _ref2$isDryRun, isDryRun, migrations, currentVersion, lock, reversedMigrationArray, _iterator3, _step3, _loop2, _ret2;\n\n    return _regeneratorRuntime().wrap(function _callee2$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _ref2$ignoreLock = _ref2.ignoreLock, ignoreLock = _ref2$ignoreLock === void 0 ? false : _ref2$ignoreLock, onProgress = _ref2.onProgress, _ref2$isDryRun = _ref2.isDryRun, isDryRun = _ref2$isDryRun === void 0 ? false : _ref2$isDryRun, migrations = _ref2.migrations;\n            migrations = migrations || defaultMigrations;\n\n            if (path) {\n              _context4.next = 4;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('Path argument is required!');\n\n          case 4:\n            if (repoOptions) {\n              _context4.next = 6;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('repoOptions argument is required!');\n\n          case 6:\n            if (toVersion) {\n              _context4.next = 8;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!');\n\n          case 8:\n            if (!(!Number.isInteger(toVersion) || toVersion <= 0)) {\n              _context4.next = 10;\n              break;\n            }\n\n            throw new errors.InvalidValueError('Version has to be positive integer!');\n\n          case 10:\n            // make sure we can read pre-level@5 datastores\n            backends = wrapBackends(backends);\n            _context4.next = 13;\n            return repoVersion.getVersion(backends);\n\n          case 13:\n            currentVersion = _context4.sent;\n\n            if (!(currentVersion === toVersion)) {\n              _context4.next = 17;\n              break;\n            }\n\n            log('Nothing to revert.');\n            return _context4.abrupt(\"return\");\n\n          case 17:\n            if (!(currentVersion < toVersion)) {\n              _context4.next = 19;\n              break;\n            }\n\n            throw new errors.InvalidValueError(\"Current repo's version (\".concat(currentVersion, \") is lower then toVersion (\").concat(toVersion, \"), you probably wanted to migrate it?\"));\n\n          case 19:\n            verifyAvailableMigrations(migrations, toVersion, currentVersion, true);\n\n            if (!(!isDryRun && !ignoreLock)) {\n              _context4.next = 24;\n              break;\n            }\n\n            _context4.next = 23;\n            return repoOptions.repoLock.lock(path);\n\n          case 23:\n            lock = _context4.sent;\n\n          case 24:\n            log(\"Reverting from version \".concat(currentVersion, \" to \").concat(toVersion));\n            _context4.prev = 25;\n            reversedMigrationArray = migrations.slice().reverse();\n            _iterator3 = _createForOfIteratorHelper(reversedMigrationArray);\n            _context4.prev = 28;\n            _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {\n              var migration, progressCallback, lastSuccessfullyRevertedVersion;\n              return _regeneratorRuntime().wrap(function _loop2$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      migration = _step3.value;\n\n                      if (!(migration.version <= toVersion)) {\n                        _context3.next = 3;\n                        break;\n                      }\n\n                      return _context3.abrupt(\"return\", \"break\");\n\n                    case 3:\n                      if (!(migration.version > currentVersion)) {\n                        _context3.next = 5;\n                        break;\n                      }\n\n                      return _context3.abrupt(\"return\", \"continue\");\n\n                    case 5:\n                      log(\"Reverting migration version \".concat(migration.version));\n                      _context3.prev = 6;\n\n                      if (isDryRun) {\n                        _context3.next = 12;\n                        break;\n                      }\n\n                      /** @type {MigrationProgressCallback} */\n                      progressCallback = function progressCallback() {};\n\n                      if (onProgress) {\n                        // eslint-disable-line max-depth\n                        progressCallback = function progressCallback(percent, message) {\n                          return onProgress(migration.version, percent.toFixed(2), message);\n                        };\n                      }\n\n                      _context3.next = 12;\n                      return migration.revert(backends, progressCallback);\n\n                    case 12:\n                      _context3.next = 22;\n                      break;\n\n                    case 14:\n                      _context3.prev = 14;\n                      _context3.t0 = _context3[\"catch\"](6);\n                      lastSuccessfullyRevertedVersion = migration.version;\n                      log(\"An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: \".concat(lastSuccessfullyRevertedVersion));\n                      _context3.next = 20;\n                      return repoVersion.setVersion(lastSuccessfullyRevertedVersion, backends);\n\n                    case 20:\n                      _context3.t0.message = \"During reversion to version \".concat(migration.version, \" exception was raised: \").concat(_context3.t0.message);\n                      throw _context3.t0;\n\n                    case 22:\n                      log(\"Reverting to version \".concat(migration.version, \" finished\"));\n\n                    case 23:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _loop2, null, [[6, 14]]);\n            });\n\n            _iterator3.s();\n\n          case 31:\n            if ((_step3 = _iterator3.n()).done) {\n              _context4.next = 40;\n              break;\n            }\n\n            return _context4.delegateYield(_loop2(), \"t0\", 33);\n\n          case 33:\n            _ret2 = _context4.t0;\n\n            if (!(_ret2 === \"break\")) {\n              _context4.next = 36;\n              break;\n            }\n\n            return _context4.abrupt(\"break\", 40);\n\n          case 36:\n            if (!(_ret2 === \"continue\")) {\n              _context4.next = 38;\n              break;\n            }\n\n            return _context4.abrupt(\"continue\", 38);\n\n          case 38:\n            _context4.next = 31;\n            break;\n\n          case 40:\n            _context4.next = 45;\n            break;\n\n          case 42:\n            _context4.prev = 42;\n            _context4.t1 = _context4[\"catch\"](28);\n\n            _iterator3.e(_context4.t1);\n\n          case 45:\n            _context4.prev = 45;\n\n            _iterator3.f();\n\n            return _context4.finish(45);\n\n          case 48:\n            if (isDryRun) {\n              _context4.next = 51;\n              break;\n            }\n\n            _context4.next = 51;\n            return repoVersion.setVersion(toVersion, backends);\n\n          case 51:\n            log(\"All migrations successfully reverted to version \".concat(toVersion, \"!\"));\n\n          case 52:\n            _context4.prev = 52;\n\n            if (!(!isDryRun && !ignoreLock && lock)) {\n              _context4.next = 56;\n              break;\n            }\n\n            _context4.next = 56;\n            return lock.close();\n\n          case 56:\n            return _context4.finish(52);\n\n          case 57:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee2, null, [[25,, 52, 57], [28, 42, 45, 48]]);\n  }));\n  return _revert.apply(this, arguments);\n}\n\nfunction verifyAvailableMigrations(migrations, fromVersion, toVersion) {\n  var checkReversibility = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var migrationCounter = 0;\n\n  var _iterator = _createForOfIteratorHelper(migrations),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var migration = _step.value;\n\n      if (migration.version > toVersion) {\n        break;\n      }\n\n      if (migration.version > fromVersion) {\n        if (checkReversibility && !migration.revert) {\n          throw new errors.NonReversibleMigrationError(\"It is not possible to revert to version \".concat(fromVersion, \" because migration version \").concat(migration.version, \" is not reversible. Cancelling reversion.\"));\n        }\n\n        migrationCounter++;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (migrationCounter !== toVersion - fromVersion) {\n    throw new errors.InvalidValueError(\"The ipfs-repo-migrations package does not have all migration to migrate from version \".concat(fromVersion, \" to \").concat(toVersion));\n  }\n}\n\nmodule.exports = {\n  getCurrentRepoVersion: repoVersion.getVersion,\n  getLatestMigrationVersion: getLatestMigrationVersion,\n  errors: errors,\n  migrate: migrate,\n  revert: revert\n};","map":{"version":3,"names":["defaultMigrations","require","repoVersion","errors","wrapBackends","log","getLatestMigrationVersion","migrations","Array","isArray","length","version","migrate","path","backends","repoOptions","toVersion","ignoreLock","onProgress","isDryRun","RequiredParameterError","Number","isInteger","InvalidValueError","getVersion","currentVersion","verifyAvailableMigrations","repoLock","lock","migration","undefined","progressCallback","percent","message","toFixed","lastSuccessfullyMigratedVersion","setVersion","Error","stack","close","revert","reversedMigrationArray","slice","reverse","lastSuccessfullyRevertedVersion","fromVersion","checkReversibility","migrationCounter","NonReversibleMigrationError","module","exports","getCurrentRepoVersion"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-repo-migrations/src/index.js"],"sourcesContent":["/* eslint complexity: [\"error\", 27] */\n'use strict'\n\nconst defaultMigrations = require('../migrations')\nconst repoVersion = require('./repo/version')\nconst errors = require('./errors')\nconst { wrapBackends } = require('./utils')\nconst log = require('debug')('ipfs:repo:migrator')\n\n/**\n * @typedef {import('./types').Migration} Migration\n * @typedef {import('./types').MigrationOptions} MigrationOptions\n * @typedef {import('./types').ProgressCallback} ProgressCallback\n * @typedef {import('./types').MigrationProgressCallback} MigrationProgressCallback\n */\n\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {Migration[]} [migrations] - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n */\nfunction getLatestMigrationVersion (migrations) {\n  migrations = migrations || defaultMigrations\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0\n  }\n\n  return migrations[migrations.length - 1].version\n}\n\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo should be migrated.\n * @param {MigrationOptions} [options] - Options for migration\n */\nasync function migrate (path, backends, repoOptions, toVersion, { ignoreLock = false, onProgress, isDryRun = false, migrations }) {\n  migrations = migrations || defaultMigrations\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('toVersion argument is required!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  // make sure we can read pre-level@5 datastores\n  backends = wrapBackends(backends)\n\n  const currentVersion = await repoVersion.getVersion(backends)\n\n  if (currentVersion === toVersion) {\n    log('Nothing to migrate.')\n    return\n  }\n\n  if (currentVersion > toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`)\n  }\n\n  verifyAvailableMigrations(migrations, currentVersion, toVersion)\n\n  let lock\n\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path)\n  }\n\n  try {\n    for (const migration of migrations) {\n      if (toVersion !== undefined && migration.version > toVersion) {\n        break\n      }\n\n      if (migration.version <= currentVersion) {\n        continue\n      }\n\n      log(`Migrating version ${migration.version}`)\n\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {}\n\n          if (onProgress) { // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message)\n          }\n\n          await migration.migrate(backends, progressCallback)\n        }\n      } catch (e) {\n        const lastSuccessfullyMigratedVersion = migration.version - 1\n\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`)\n        await repoVersion.setVersion(lastSuccessfullyMigratedVersion, backends)\n\n        throw new Error(`During migration to version ${migration.version} exception was raised: ${e.stack || e.message || e}`)\n      }\n\n      log(`Migrating to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion || getLatestMigrationVersion(migrations), backends)\n    }\n\n    log('Repo successfully migrated', toVersion !== undefined ? `to version ${toVersion}!` : 'to latest version!')\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close()\n    }\n  }\n}\n\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {import('./types').Backends} backends\n * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {number} toVersion - Version to which the repo will be reverted.\n * @param {MigrationOptions} [options] - Options for the reversion\n */\nasync function revert (path, backends, repoOptions, toVersion, { ignoreLock = false, onProgress, isDryRun = false, migrations }) {\n  migrations = migrations || defaultMigrations\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  // make sure we can read pre-level@5 datastores\n  backends = wrapBackends(backends)\n\n  const currentVersion = await repoVersion.getVersion(backends)\n\n  if (currentVersion === toVersion) {\n    log('Nothing to revert.')\n    return\n  }\n\n  if (currentVersion < toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`)\n  }\n\n  verifyAvailableMigrations(migrations, toVersion, currentVersion, true)\n\n  let lock\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoOptions.repoLock.lock(path)\n  }\n\n  log(`Reverting from version ${currentVersion} to ${toVersion}`)\n\n  try {\n    const reversedMigrationArray = migrations.slice().reverse()\n\n    for (const migration of reversedMigrationArray) {\n      if (migration.version <= toVersion) {\n        break\n      }\n\n      if (migration.version > currentVersion) {\n        continue\n      }\n\n      log(`Reverting migration version ${migration.version}`)\n\n      try {\n        if (!isDryRun) {\n          /** @type {MigrationProgressCallback} */\n          let progressCallback = () => {}\n\n          if (onProgress) { // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message)\n          }\n\n          await migration.revert(backends, progressCallback)\n        }\n      } catch (e) {\n        const lastSuccessfullyRevertedVersion = migration.version\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`)\n        await repoVersion.setVersion(lastSuccessfullyRevertedVersion, backends)\n\n        e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`\n        throw e\n      }\n\n      log(`Reverting to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(toVersion, backends)\n    }\n\n    log(`All migrations successfully reverted to version ${toVersion}!`)\n  } finally {\n    if (!isDryRun && !ignoreLock && lock) {\n      await lock.close()\n    }\n  }\n}\n\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {Migration[]} migrations\n * @param {number} fromVersion\n * @param {number} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n */\nfunction verifyAvailableMigrations (migrations, fromVersion, toVersion, checkReversibility = false) {\n  let migrationCounter = 0\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break\n    }\n\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`)\n      }\n\n      migrationCounter++\n    }\n  }\n\n  if (migrationCounter !== (toVersion - fromVersion)) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`)\n  }\n}\n\nmodule.exports = {\n  getCurrentRepoVersion: repoVersion.getVersion,\n  getLatestMigrationVersion,\n  errors,\n  migrate,\n  revert\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}