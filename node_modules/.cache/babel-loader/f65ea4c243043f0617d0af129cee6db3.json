{"ast":null,"code":"'use strict';\n\nconst pMap = require('p-map');\n\nconst GSet = require('./g-set');\n\nconst Entry = require('./entry');\n\nconst LogIO = require('./log-io');\n\nconst LogError = require('./log-errors');\n\nconst Clock = require('./lamport-clock');\n\nconst Sorting = require('./log-sorting');\n\nconst {\n  LastWriteWins,\n  NoZeroes\n} = Sorting;\n\nconst AccessController = require('./default-access-controller');\n\nconst {\n  isDefined,\n  findUniques\n} = require('./utils');\n\nconst EntryIndex = require('./entry-index');\n\nconst randomId = () => new Date().getTime().toString();\n\nconst getHash = e => e.hash;\n\nconst flatMap = (res, acc) => res.concat(acc);\n\nconst getNextPointers = entry => entry.next;\n\nconst maxClockTimeReducer = (res, acc) => Math.max(res, acc.clock.time);\n\nconst uniqueEntriesReducer = (res, acc) => {\n  res[acc.hash] = acc;\n  return res;\n};\n/**\n * @description\n * Log implements a G-Set CRDT and adds ordering.\n *\n * From:\n * \"A comprehensive study of Convergent and Commutative Replicated Data Types\"\n * https://hal.inria.fr/inria-00555588\n */\n\n\nclass Log extends GSet {\n  /**\n   * Create a new Log instance\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Object} identity Identity (https://github.com/orbitdb/orbit-db-identity-provider/blob/master/src/identity.js)\n   * @param {Object} options\n   * @param {string} options.logId ID of the log\n   * @param {Object} options.access AccessController (./default-access-controller)\n   * @param {Array<Entry>} options.entries An Array of Entries from which to create the log\n   * @param {Array<Entry>} options.heads Set the heads of the log\n   * @param {Clock} options.clock Set the clock of the log\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Log} The log instance\n   */\n  constructor(ipfs, identity) {\n    let {\n      logId,\n      access,\n      entries,\n      heads,\n      clock,\n      sortFn,\n      concurrency\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!isDefined(ipfs)) {\n      throw LogError.IPFSNotDefinedError();\n    }\n\n    if (!isDefined(identity)) {\n      throw new Error('Identity is required');\n    }\n\n    if (!isDefined(access)) {\n      access = new AccessController();\n    }\n\n    if (isDefined(entries) && !Array.isArray(entries)) {\n      throw new Error('\\'entries\\' argument must be an array of Entry instances');\n    }\n\n    if (isDefined(heads) && !Array.isArray(heads)) {\n      throw new Error('\\'heads\\' argument must be an array');\n    }\n\n    if (!isDefined(sortFn)) {\n      sortFn = LastWriteWins;\n    }\n\n    super();\n    this._sortFn = NoZeroes(sortFn);\n    this._storage = ipfs;\n    this._id = logId || randomId(); // Access Controller\n\n    this._access = access; // Identity\n\n    this._identity = identity; // Add entries to the internal cache\n\n    const uniqueEntries = (entries || []).reduce(uniqueEntriesReducer, {});\n    this._entryIndex = new EntryIndex(uniqueEntries);\n    entries = Object.values(uniqueEntries) || []; // Set heads if not passed as an argument\n\n    heads = heads || Log.findHeads(entries);\n    this._headsIndex = heads.reduce(uniqueEntriesReducer, {}); // Index of all next pointers in this log\n\n    this._nextsIndex = {};\n\n    const addToNextsIndex = e => e.next.forEach(a => this._nextsIndex[a] = e.hash);\n\n    entries.forEach(addToNextsIndex); // Set the length, we calculate the length manually internally\n\n    this._length = entries.length; // Set the clock\n\n    const maxTime = Math.max(clock ? clock.time : 0, this.heads.reduce(maxClockTimeReducer, 0)); // Take the given key as the clock id is it's a Key instance,\n    // otherwise if key was given, take whatever it is,\n    // and if it was null, take the given id as the clock id\n\n    this._clock = new Clock(this._identity.publicKey, maxTime);\n    this.joinConcurrency = concurrency || 16;\n  }\n  /**\n   * Returns the ID of the log.\n   * @returns {string}\n   */\n\n\n  get id() {\n    return this._id;\n  }\n  /**\n   * Returns the clock of the log.\n   * @returns {string}\n   */\n\n\n  get clock() {\n    return this._clock;\n  }\n  /**\n   * Returns the length of the log.\n   * @return {number} Length\n   */\n\n\n  get length() {\n    return this._length;\n  }\n  /**\n   * Returns the values in the log.\n   * @returns {Array<Entry>}\n   */\n\n\n  get values() {\n    return Object.values(this.traverse(this.heads)).reverse();\n  }\n  /**\n   * Returns an array of heads as hashes.\n   * @returns {Array<string>}\n   */\n\n\n  get heads() {\n    return Object.values(this._headsIndex).sort(this._sortFn).reverse();\n  }\n  /**\n   * Returns an array of Entry objects that reference entries which\n   * are not in the log currently.\n   * @returns {Array<Entry>}\n   */\n\n\n  get tails() {\n    return Log.findTails(this.values);\n  }\n  /**\n   * Returns an array of hashes that are referenced by entries which\n   * are not in the log currently.\n   * @returns {Array<string>} Array of hashes\n   */\n\n\n  get tailHashes() {\n    return Log.findTailHashes(this.values);\n  }\n  /**\n   * Set the identity for the log\n   * @param {Identity} [identity] The identity to be set\n   */\n\n\n  setIdentity(identity) {\n    this._identity = identity; // Find the latest clock from the heads\n\n    const time = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0));\n    this._clock = new Clock(this._identity.publicKey, time);\n  }\n  /**\n   * Find an entry.\n   * @param {string} [hash] The hashes of the entry\n   * @returns {Entry|undefined}\n   */\n\n\n  get(hash) {\n    return this._entryIndex.get(hash);\n  }\n  /**\n   * Checks if a entry is part of the log\n   * @param {string} hash The hash of the entry\n   * @returns {boolean}\n   */\n\n\n  has(entry) {\n    return this._entryIndex.get(entry.hash || entry) !== undefined;\n  }\n\n  traverse(rootEntries) {\n    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    let endHash = arguments.length > 2 ? arguments[2] : undefined;\n    // Sort the given given root entries and use as the starting stack\n    let stack = rootEntries.sort(this._sortFn).reverse(); // Cache for checking if we've processed an entry already\n\n    let traversed = {}; // End result\n\n    const result = {};\n    let count = 0; // Named function for getting an entry from the log\n\n    const getEntry = e => this.get(e); // Add an entry to the stack and traversed nodes index\n\n\n    const addToStack = entry => {\n      // If we've already processed the entry, don't add it to the stack\n      if (!entry || traversed[entry.hash]) {\n        return;\n      } // Add the entry in front of the stack and sort\n\n\n      stack = [entry, ...stack].sort(this._sortFn).reverse(); // Add to the cache of processed entries\n\n      traversed[entry.hash] = true;\n    };\n\n    const addEntry = rootEntry => {\n      result[rootEntry.hash] = rootEntry;\n      traversed[rootEntry.hash] = true;\n      count++;\n    }; // Start traversal\n    // Process stack until it's empty (traversed the full log)\n    // or when we have the requested amount of entries\n    // If requested entry amount is -1, traverse all\n\n\n    while (stack.length > 0 && (count < amount || amount < 0)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      // Get the next element from the stack\n      const entry = stack.shift(); // Add to the result\n\n      addEntry(entry); // If it is the specified end hash, break out of the while loop\n\n      if (endHash && endHash === entry.hash) break; // Add entry's next references to the stack\n\n      const entries = entry.next.map(getEntry);\n      const defined = entries.filter(isDefined);\n      defined.forEach(addToStack);\n    }\n\n    stack = [];\n    traversed = {}; // End result\n\n    return result;\n  }\n  /**\n   * Append an entry to the log.\n   * @param {Entry} entry Entry to add\n   * @return {Log} New Log containing the appended value\n   */\n\n\n  async append(data) {\n    let pointerCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let pin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // Update the clock (find the latest clock)\n    const newTime = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0)) + 1;\n    this._clock = new Clock(this.clock.id, newTime);\n    const all = Object.values(this.traverse(this.heads, Math.max(pointerCount, this.heads.length))); // If pointer count is 4, returns 2\n    // If pointer count is 8, returns 3 references\n    // If pointer count is 512, returns 9 references\n    // If pointer count is 2048, returns 11 references\n\n    const getEveryPow2 = maxDistance => {\n      const entries = new Set();\n\n      for (let i = 1; i <= maxDistance; i *= 2) {\n        const index = Math.min(i - 1, all.length - 1);\n        entries.add(all[index]);\n      }\n\n      return entries;\n    };\n\n    const references = getEveryPow2(Math.min(pointerCount, all.length)); // Always include the last known reference\n\n    if (all.length < pointerCount && all[all.length - 1]) {\n      references.add(all[all.length - 1]);\n    } // Create the next pointers from heads\n\n\n    const nexts = Object.keys(this.heads.reverse().reduce(uniqueEntriesReducer, {}));\n\n    const isNext = e => !nexts.includes(e); // Delete the heads from the refs\n\n\n    const refs = Array.from(references).map(getHash).filter(isNext); // @TODO: Split Entry.create into creating object, checking permission, signing and then posting to IPFS\n    // Create the entry and add it to the internal cache\n\n    const entry = await Entry.create(this._storage, this._identity, this.id, data, nexts, this.clock, refs, pin);\n    const canAppend = await this._access.canAppend(entry, this._identity.provider);\n\n    if (!canAppend) {\n      throw new Error(`Could not append entry, key \"${this._identity.id}\" is not allowed to write to the log`);\n    }\n\n    this._entryIndex.set(entry.hash, entry);\n\n    nexts.forEach(e => this._nextsIndex[e] = entry.hash);\n    this._headsIndex = {};\n    this._headsIndex[entry.hash] = entry; // Update the length\n\n    this._length++;\n    return entry;\n  }\n  /*\n   * Creates a javscript iterator over log entries\n   *\n   * @param {Object} options\n   * @param {string|Array} options.gt Beginning hash of the iterator, non-inclusive\n   * @param {string|Array} options.gte Beginning hash of the iterator, inclusive\n   * @param {string|Array} options.lt Ending hash of the iterator, non-inclusive\n   * @param {string|Array} options.lte Ending hash of the iterator, inclusive\n   * @param {amount} options.amount Number of entried to return to / from the gte / lte hash\n   * @returns {Symbol.Iterator} Iterator object containing log entries\n   *\n   * @examples\n   *\n   * (async () => {\n   *   log1 = new Log(ipfs, testIdentity, { logId: 'X' })\n   *\n   *   for (let i = 0; i <= 100; i++) {\n   *     await log1.append('entry' + i)\n   *   }\n   *\n   *   let it = log1.iterator({\n   *     lte: 'zdpuApFd5XAPkCTmSx7qWQmQzvtdJPtx2K5p9to6ytCS79bfk',\n   *     amount: 10\n   *   })\n   *\n   *   [...it].length // 10\n   * })()\n   *\n   *\n   */\n\n\n  iterator() {\n    let {\n      gt = undefined,\n      gte = undefined,\n      lt = undefined,\n      lte = undefined,\n      amount = -1\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (amount === 0) return function* () {}();\n    if (typeof lte === 'string') lte = [this.get(lte)];\n    if (typeof lt === 'string') lt = [this.get(this.get(lt).next[0])];\n    if (lte && !Array.isArray(lte)) throw LogError.LtOrLteMustBeStringOrArray();\n    if (lt && !Array.isArray(lt)) throw LogError.LtOrLteMustBeStringOrArray();\n    const start = (lte || lt || this.heads).filter(isDefined);\n    const endHash = gte ? this.get(gte).hash : gt ? this.get(gt).hash : null;\n    const count = endHash ? -1 : amount || -1;\n    const entries = this.traverse(start, count, endHash);\n    let entryValues = Object.values(entries); // Strip off last entry if gt is non-inclusive\n\n    if (gt) entryValues.pop(); // Deal with the amount argument working backwards from gt/gte\n\n    if ((gt || gte) && amount > -1) {\n      entryValues = entryValues.slice(entryValues.length - amount, entryValues.length);\n    }\n\n    return function* () {\n      for (const i in entryValues) {\n        yield entryValues[i];\n      }\n    }();\n  }\n  /**\n   * Join two logs.\n   *\n   * Joins another log into this one.\n   *\n   * @param {Log} log Log to join with this Log\n   * @param {number} [size=-1] Max size of the joined log\n   * @returns {Promise<Log>} This Log instance\n   * @example\n   * await log1.join(log2)\n   */\n\n\n  async join(log) {\n    let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    if (!isDefined(log)) throw LogError.LogNotDefinedError();\n    if (!Log.isLog(log)) throw LogError.NotALogError();\n    if (this.id !== log.id) return; // Get the difference of the logs\n\n    const newItems = Log.difference(log, this);\n    const identityProvider = this._identity.provider; // Verify if entries are allowed to be added to the log and throws if\n    // there's an invalid entry\n\n    const permitted = async entry => {\n      const canAppend = await this._access.canAppend(entry, identityProvider);\n\n      if (!canAppend) {\n        throw new Error(`Could not append entry, key \"${entry.identity.id}\" is not allowed to write to the log`);\n      }\n    }; // Verify signature for each entry and throws if there's an invalid signature\n\n\n    const verify = async entry => {\n      const isValid = await Entry.verify(identityProvider, entry);\n      const publicKey = entry.identity ? entry.identity.publicKey : entry.key;\n      if (!isValid) throw new Error(`Could not validate signature \"${entry.sig}\" for entry \"${entry.hash}\" and key \"${publicKey}\"`);\n    };\n\n    const entriesToJoin = Object.values(newItems);\n    await pMap(entriesToJoin, async e => {\n      await permitted(e);\n      await verify(e);\n    }, {\n      concurrency: this.joinConcurrency\n    }); // Update the internal next pointers index\n\n    const addToNextsIndex = e => {\n      const entry = this.get(e.hash);\n      if (!entry) this._length++;\n      /* istanbul ignore else */\n\n      e.next.forEach(a => this._nextsIndex[a] = e.hash);\n    };\n\n    Object.values(newItems).forEach(addToNextsIndex); // Update the internal entry index\n\n    this._entryIndex.add(newItems); // Merge the heads\n\n\n    const notReferencedByNewItems = e => !nextsFromNewItems.find(a => a === e.hash);\n\n    const notInCurrentNexts = e => !this._nextsIndex[e.hash];\n\n    const nextsFromNewItems = Object.values(newItems).map(getNextPointers).reduce(flatMap, []);\n    const mergedHeads = Log.findHeads(Object.values(Object.assign({}, this._headsIndex, log._headsIndex))).filter(notReferencedByNewItems).filter(notInCurrentNexts).reduce(uniqueEntriesReducer, {});\n    this._headsIndex = mergedHeads; // Slice to the requested size\n\n    if (size > -1) {\n      let tmp = this.values;\n      tmp = tmp.slice(-size);\n      this._entryIndex = null;\n      this._entryIndex = new EntryIndex(tmp.reduce(uniqueEntriesReducer, {}));\n      this._headsIndex = Log.findHeads(tmp).reduce(uniqueEntriesReducer, {});\n      this._length = this._entryIndex.length;\n    } // Find the latest clock from the heads\n\n\n    const maxClock = Object.values(this._headsIndex).reduce(maxClockTimeReducer, 0);\n    this._clock = new Clock(this.clock.id, Math.max(this.clock.time, maxClock));\n    return this;\n  }\n  /**\n   * Get the log in JSON format.\n   * @returns {Object} An object with the id and heads properties\n   */\n\n\n  toJSON() {\n    return {\n      id: this.id,\n      heads: this.heads.sort(this._sortFn) // default sorting\n      .reverse() // we want the latest as the first element\n      .map(getHash) // return only the head hashes\n\n    };\n  }\n  /**\n   * Get the log in JSON format as a snapshot.\n   * @returns {Object} An object with the id, heads and value properties\n   */\n\n\n  toSnapshot() {\n    return {\n      id: this.id,\n      heads: this.heads,\n      values: this.values\n    };\n  }\n  /**\n   * Get the log as a Buffer.\n   * @returns {Buffer}\n   */\n\n\n  toBuffer() {\n    return Buffer.from(JSON.stringify(this.toJSON()));\n  }\n  /**\n   * Returns the log entries as a formatted string.\n   * @returns {string}\n   * @example\n   * two\n   * └─one\n   *   └─three\n   */\n\n\n  toString(payloadMapper) {\n    return this.values.slice().reverse().map((e, idx) => {\n      const parents = Entry.findChildren(e, this.values);\n      const len = parents.length;\n      let padding = new Array(Math.max(len - 1, 0));\n      padding = len > 1 ? padding.fill('  ') : padding;\n      padding = len > 0 ? padding.concat(['└─']) : padding;\n      /* istanbul ignore next */\n\n      return padding.join('') + (payloadMapper ? payloadMapper(e.payload) : e.payload);\n    }).join('\\n');\n  }\n  /**\n   * Check whether an object is a Log instance.\n   * @param {Object} log An object to check\n   * @returns {boolean}\n   */\n\n\n  static isLog(log) {\n    return log.id !== undefined && log.heads !== undefined && log._entryIndex !== undefined;\n  }\n  /**\n   * Get the log's multihash.\n   * @returns {Promise<string>} Multihash of the Log as Base58 encoded string.\n   */\n\n\n  toMultihash() {\n    let {\n      format\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return LogIO.toMultihash(this._storage, this, {\n      format\n    });\n  }\n  /**\n   * Create a log from a hashes.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {string} hash The log hash\n   * @param {Object} options\n   * @param {AccessController} options.access The access controller instance\n   * @param {number} options.length How many items to include in the log\n   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n   * @param {function(hash, entry, parent, depth)} options.onProgressCallback\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @returns {Promise<Log>}\n   */\n\n\n  static async fromMultihash(ipfs, identity, hash) {\n    let {\n      access,\n      length = -1,\n      exclude = [],\n      shouldExclude,\n      timeout,\n      concurrency,\n      sortFn,\n      onProgressCallback\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    // TODO: need to verify the entries with 'key'\n    const {\n      logId,\n      entries,\n      heads\n    } = await LogIO.fromMultihash(ipfs, hash, {\n      length,\n      exclude,\n      shouldExclude,\n      timeout,\n      onProgressCallback,\n      concurrency,\n      sortFn\n    });\n    return new Log(ipfs, identity, {\n      logId,\n      access,\n      entries,\n      heads,\n      sortFn\n    });\n  }\n  /**\n   * Create a log from a single entry's hash.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {string} hash The entry's hash\n   * @param {Object} options\n   * @param {string} options.logId The ID of the log\n   * @param {AccessController} options.access The access controller instance\n   * @param {number} options.length How many entries to include in the log\n   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n   * @param {function(hash, entry, parent, depth)} options.onProgressCallback\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Promise<Log>} New Log\n   */\n\n\n  static async fromEntryHash(ipfs, identity, hash) {\n    let {\n      logId,\n      access,\n      length = -1,\n      exclude = [],\n      shouldExclude,\n      timeout,\n      concurrency,\n      sortFn,\n      onProgressCallback\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    // TODO: need to verify the entries with 'key'\n    const {\n      entries\n    } = await LogIO.fromEntryHash(ipfs, hash, {\n      length,\n      exclude,\n      shouldExclude,\n      timeout,\n      concurrency,\n      onProgressCallback\n    });\n    return new Log(ipfs, identity, {\n      logId,\n      access,\n      entries,\n      sortFn\n    });\n  }\n  /**\n   * Create a log from a Log Snapshot JSON.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {Object} json Log snapshot as JSON object\n   * @param {Object} options\n   * @param {AccessController} options.access The access controller instance\n   * @param {number} options.length How many entries to include in the log\n   * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Promise<Log>} New Log\n   */\n\n\n  static async fromJSON(ipfs, identity, json) {\n    let {\n      access,\n      length = -1,\n      timeout,\n      sortFn,\n      onProgressCallback\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    // TODO: need to verify the entries with 'key'\n    const {\n      logId,\n      entries\n    } = await LogIO.fromJSON(ipfs, json, {\n      length,\n      timeout,\n      onProgressCallback\n    });\n    return new Log(ipfs, identity, {\n      logId,\n      access,\n      entries,\n      sortFn\n    });\n  }\n  /**\n   * Create a new log from an Entry instance.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {Entry|Array<Entry>} sourceEntries An Entry or an array of entries to fetch a log from\n   * @param {Object} options\n   * @param {AccessController} options.access The access controller instance\n   * @param {number} options.length How many entries to include. Default: infinite.\n   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n   * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Promise<Log>} New Log\n   */\n\n\n  static async fromEntry(ipfs, identity, sourceEntries) {\n    let {\n      access,\n      length = -1,\n      exclude = [],\n      timeout,\n      concurrency,\n      sortFn,\n      onProgressCallback\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    // TODO: need to verify the entries with 'key'\n    const {\n      logId,\n      entries\n    } = await LogIO.fromEntry(ipfs, sourceEntries, {\n      length,\n      exclude,\n      timeout,\n      concurrency,\n      onProgressCallback\n    });\n    return new Log(ipfs, identity, {\n      logId,\n      access,\n      entries,\n      sortFn\n    });\n  }\n  /**\n   * Find heads from a collection of entries.\n   *\n   * Finds entries that are the heads of this collection,\n   * ie. entries that are not referenced by other entries.\n   *\n   * @param {Array<Entry>} entries Entries to search heads from\n   * @returns {Array<Entry>}\n   */\n\n\n  static findHeads(entries) {\n    const indexReducer = (res, entry, idx, arr) => {\n      const addToResult = e => res[e] = entry.hash;\n\n      entry.next.forEach(addToResult);\n      return res;\n    };\n\n    const items = entries.reduce(indexReducer, {});\n\n    const exists = e => items[e.hash] === undefined;\n\n    const compareIds = (a, b) => a.clock.id > b.clock.id;\n\n    return entries.filter(exists).sort(compareIds);\n  } // Find entries that point to another entry that is not in the\n  // input array\n\n\n  static findTails(entries) {\n    // Reverse index { next -> entry }\n    const reverseIndex = {}; // Null index containing entries that have no parents (nexts)\n\n    const nullIndex = []; // Hashes for all entries for quick lookups\n\n    const hashes = {}; // Hashes of all next entries\n\n    let nexts = [];\n\n    const addToIndex = e => {\n      if (e.next.length === 0) {\n        nullIndex.push(e);\n      }\n\n      const addToReverseIndex = a => {\n        /* istanbul ignore else */\n        if (!reverseIndex[a]) reverseIndex[a] = [];\n        reverseIndex[a].push(e);\n      }; // Add all entries and their parents to the reverse index\n\n\n      e.next.forEach(addToReverseIndex); // Get all next references\n\n      nexts = nexts.concat(e.next); // Get the hashes of input entries\n\n      hashes[e.hash] = true;\n    }; // Create our indices\n\n\n    entries.forEach(addToIndex);\n\n    const addUniques = (res, entries, idx, arr) => res.concat(findUniques(entries, 'hash'));\n\n    const exists = e => hashes[e] === undefined;\n\n    const findFromReverseIndex = e => reverseIndex[e]; // Drop hashes that are not in the input entries\n\n\n    const tails = nexts // For every hash in nexts:\n    .filter(exists) // Remove undefineds and nulls\n    .map(findFromReverseIndex) // Get the Entry from the reverse index\n    .reduce(addUniques, []) // Flatten the result and take only uniques\n    .concat(nullIndex); // Combine with tails the have no next refs (ie. first-in-their-chain)\n\n    return findUniques(tails, 'hash').sort(Entry.compare);\n  } // Find the hashes to entries that are not in a collection\n  // but referenced by other entries\n\n\n  static findTailHashes(entries) {\n    const hashes = {};\n\n    const addToIndex = e => hashes[e.hash] = true;\n\n    const reduceTailHashes = (res, entry, idx, arr) => {\n      const addToResult = e => {\n        /* istanbul ignore else */\n        if (hashes[e] === undefined) {\n          res.splice(0, 0, e);\n        }\n      };\n\n      entry.next.reverse().forEach(addToResult);\n      return res;\n    };\n\n    entries.forEach(addToIndex);\n    return entries.reduce(reduceTailHashes, []);\n  }\n\n  static difference(a, b) {\n    const stack = Object.keys(a._headsIndex);\n    const traversed = {};\n    const res = {};\n\n    const pushToStack = hash => {\n      if (!traversed[hash] && !b.get(hash)) {\n        stack.push(hash);\n        traversed[hash] = true;\n      }\n    };\n\n    while (stack.length > 0) {\n      const hash = stack.shift();\n      const entry = a.get(hash);\n\n      if (entry && !b.get(hash) && entry.id === b.id) {\n        res[entry.hash] = entry;\n        traversed[entry.hash] = true;\n        entry.next.concat(entry.refs).forEach(pushToStack);\n      }\n    }\n\n    return res;\n  }\n\n}\n\nmodule.exports = Log;\nmodule.exports.Sorting = Sorting;\nmodule.exports.Entry = Entry;\nmodule.exports.AccessController = AccessController;","map":{"version":3,"names":["pMap","require","GSet","Entry","LogIO","LogError","Clock","Sorting","LastWriteWins","NoZeroes","AccessController","isDefined","findUniques","EntryIndex","randomId","Date","getTime","toString","getHash","e","hash","flatMap","res","acc","concat","getNextPointers","entry","next","maxClockTimeReducer","Math","max","clock","time","uniqueEntriesReducer","Log","constructor","ipfs","identity","logId","access","entries","heads","sortFn","concurrency","IPFSNotDefinedError","Error","Array","isArray","_sortFn","_storage","_id","_access","_identity","uniqueEntries","reduce","_entryIndex","Object","values","findHeads","_headsIndex","_nextsIndex","addToNextsIndex","forEach","a","_length","length","maxTime","_clock","publicKey","joinConcurrency","id","traverse","reverse","sort","tails","findTails","tailHashes","findTailHashes","setIdentity","get","has","undefined","rootEntries","amount","endHash","stack","traversed","result","count","getEntry","addToStack","addEntry","rootEntry","shift","map","defined","filter","append","data","pointerCount","pin","newTime","all","getEveryPow2","maxDistance","Set","i","index","min","add","references","nexts","keys","isNext","includes","refs","from","create","canAppend","provider","set","iterator","gt","gte","lt","lte","LtOrLteMustBeStringOrArray","start","entryValues","pop","slice","join","log","size","LogNotDefinedError","isLog","NotALogError","newItems","difference","identityProvider","permitted","verify","isValid","key","sig","entriesToJoin","notReferencedByNewItems","nextsFromNewItems","find","notInCurrentNexts","mergedHeads","assign","tmp","maxClock","toJSON","toSnapshot","toBuffer","Buffer","JSON","stringify","payloadMapper","idx","parents","findChildren","len","padding","fill","payload","toMultihash","format","fromMultihash","exclude","shouldExclude","timeout","onProgressCallback","fromEntryHash","fromJSON","json","fromEntry","sourceEntries","indexReducer","arr","addToResult","items","exists","compareIds","b","reverseIndex","nullIndex","hashes","addToIndex","push","addToReverseIndex","addUniques","findFromReverseIndex","compare","reduceTailHashes","splice","pushToStack","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-log/src/log.js"],"sourcesContent":["'use strict'\n\nconst pMap = require('p-map')\nconst GSet = require('./g-set')\nconst Entry = require('./entry')\nconst LogIO = require('./log-io')\nconst LogError = require('./log-errors')\nconst Clock = require('./lamport-clock')\nconst Sorting = require('./log-sorting')\nconst { LastWriteWins, NoZeroes } = Sorting\nconst AccessController = require('./default-access-controller')\nconst { isDefined, findUniques } = require('./utils')\nconst EntryIndex = require('./entry-index')\nconst randomId = () => new Date().getTime().toString()\nconst getHash = e => e.hash\nconst flatMap = (res, acc) => res.concat(acc)\nconst getNextPointers = entry => entry.next\nconst maxClockTimeReducer = (res, acc) => Math.max(res, acc.clock.time)\nconst uniqueEntriesReducer = (res, acc) => {\n  res[acc.hash] = acc\n  return res\n}\n\n/**\n * @description\n * Log implements a G-Set CRDT and adds ordering.\n *\n * From:\n * \"A comprehensive study of Convergent and Commutative Replicated Data Types\"\n * https://hal.inria.fr/inria-00555588\n */\nclass Log extends GSet {\n  /**\n   * Create a new Log instance\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Object} identity Identity (https://github.com/orbitdb/orbit-db-identity-provider/blob/master/src/identity.js)\n   * @param {Object} options\n   * @param {string} options.logId ID of the log\n   * @param {Object} options.access AccessController (./default-access-controller)\n   * @param {Array<Entry>} options.entries An Array of Entries from which to create the log\n   * @param {Array<Entry>} options.heads Set the heads of the log\n   * @param {Clock} options.clock Set the clock of the log\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Log} The log instance\n   */\n  constructor (ipfs, identity, { logId, access, entries, heads, clock, sortFn, concurrency } = {}) {\n    if (!isDefined(ipfs)) {\n      throw LogError.IPFSNotDefinedError()\n    }\n\n    if (!isDefined(identity)) {\n      throw new Error('Identity is required')\n    }\n\n    if (!isDefined(access)) {\n      access = new AccessController()\n    }\n\n    if (isDefined(entries) && !Array.isArray(entries)) {\n      throw new Error('\\'entries\\' argument must be an array of Entry instances')\n    }\n\n    if (isDefined(heads) && !Array.isArray(heads)) {\n      throw new Error('\\'heads\\' argument must be an array')\n    }\n\n    if (!isDefined(sortFn)) {\n      sortFn = LastWriteWins\n    }\n\n    super()\n\n    this._sortFn = NoZeroes(sortFn)\n\n    this._storage = ipfs\n    this._id = logId || randomId()\n\n    // Access Controller\n    this._access = access\n    // Identity\n    this._identity = identity\n\n    // Add entries to the internal cache\n    const uniqueEntries = (entries || []).reduce(uniqueEntriesReducer, {})\n    this._entryIndex = new EntryIndex(uniqueEntries)\n    entries = Object.values(uniqueEntries) || []\n\n    // Set heads if not passed as an argument\n    heads = heads || Log.findHeads(entries)\n    this._headsIndex = heads.reduce(uniqueEntriesReducer, {})\n\n    // Index of all next pointers in this log\n    this._nextsIndex = {}\n    const addToNextsIndex = e => e.next.forEach(a => (this._nextsIndex[a] = e.hash))\n    entries.forEach(addToNextsIndex)\n\n    // Set the length, we calculate the length manually internally\n    this._length = entries.length\n\n    // Set the clock\n    const maxTime = Math.max(clock ? clock.time : 0, this.heads.reduce(maxClockTimeReducer, 0))\n    // Take the given key as the clock id is it's a Key instance,\n    // otherwise if key was given, take whatever it is,\n    // and if it was null, take the given id as the clock id\n    this._clock = new Clock(this._identity.publicKey, maxTime)\n\n    this.joinConcurrency = concurrency || 16\n  }\n\n  /**\n   * Returns the ID of the log.\n   * @returns {string}\n   */\n  get id () {\n    return this._id\n  }\n\n  /**\n   * Returns the clock of the log.\n   * @returns {string}\n   */\n  get clock () {\n    return this._clock\n  }\n\n  /**\n   * Returns the length of the log.\n   * @return {number} Length\n   */\n  get length () {\n    return this._length\n  }\n\n  /**\n   * Returns the values in the log.\n   * @returns {Array<Entry>}\n   */\n  get values () {\n    return Object.values(this.traverse(this.heads)).reverse()\n  }\n\n  /**\n   * Returns an array of heads as hashes.\n   * @returns {Array<string>}\n   */\n  get heads () {\n    return Object.values(this._headsIndex).sort(this._sortFn).reverse()\n  }\n\n  /**\n   * Returns an array of Entry objects that reference entries which\n   * are not in the log currently.\n   * @returns {Array<Entry>}\n   */\n  get tails () {\n    return Log.findTails(this.values)\n  }\n\n  /**\n   * Returns an array of hashes that are referenced by entries which\n   * are not in the log currently.\n   * @returns {Array<string>} Array of hashes\n   */\n  get tailHashes () {\n    return Log.findTailHashes(this.values)\n  }\n\n  /**\n   * Set the identity for the log\n   * @param {Identity} [identity] The identity to be set\n   */\n  setIdentity (identity) {\n    this._identity = identity\n    // Find the latest clock from the heads\n    const time = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0))\n    this._clock = new Clock(this._identity.publicKey, time)\n  }\n\n  /**\n   * Find an entry.\n   * @param {string} [hash] The hashes of the entry\n   * @returns {Entry|undefined}\n   */\n  get (hash) {\n    return this._entryIndex.get(hash)\n  }\n\n  /**\n   * Checks if a entry is part of the log\n   * @param {string} hash The hash of the entry\n   * @returns {boolean}\n   */\n  has (entry) {\n    return this._entryIndex.get(entry.hash || entry) !== undefined\n  }\n\n  traverse (rootEntries, amount = -1, endHash) {\n    // Sort the given given root entries and use as the starting stack\n    let stack = rootEntries.sort(this._sortFn).reverse()\n\n    // Cache for checking if we've processed an entry already\n    let traversed = {}\n    // End result\n    const result = {}\n    let count = 0\n    // Named function for getting an entry from the log\n    const getEntry = e => this.get(e)\n\n    // Add an entry to the stack and traversed nodes index\n    const addToStack = entry => {\n      // If we've already processed the entry, don't add it to the stack\n      if (!entry || traversed[entry.hash]) {\n        return\n      }\n\n      // Add the entry in front of the stack and sort\n      stack = [entry, ...stack]\n        .sort(this._sortFn)\n        .reverse()\n      // Add to the cache of processed entries\n      traversed[entry.hash] = true\n    }\n\n    const addEntry = rootEntry => {\n      result[rootEntry.hash] = rootEntry\n      traversed[rootEntry.hash] = true\n      count++\n    }\n\n    // Start traversal\n    // Process stack until it's empty (traversed the full log)\n    // or when we have the requested amount of entries\n    // If requested entry amount is -1, traverse all\n    while (stack.length > 0 && (count < amount || amount < 0)) { // eslint-disable-line no-unmodified-loop-condition\n      // Get the next element from the stack\n      const entry = stack.shift()\n      // Add to the result\n      addEntry(entry)\n      // If it is the specified end hash, break out of the while loop\n      if (endHash && endHash === entry.hash) break\n\n      // Add entry's next references to the stack\n      const entries = entry.next.map(getEntry)\n      const defined = entries.filter(isDefined)\n      defined.forEach(addToStack)\n    }\n\n    stack = []\n    traversed = {}\n    // End result\n    return result\n  }\n\n  /**\n   * Append an entry to the log.\n   * @param {Entry} entry Entry to add\n   * @return {Log} New Log containing the appended value\n   */\n  async append (data, pointerCount = 1, pin = false) {\n    // Update the clock (find the latest clock)\n    const newTime = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0)) + 1\n    this._clock = new Clock(this.clock.id, newTime)\n\n    const all = Object.values(this.traverse(this.heads, Math.max(pointerCount, this.heads.length)))\n\n    // If pointer count is 4, returns 2\n    // If pointer count is 8, returns 3 references\n    // If pointer count is 512, returns 9 references\n    // If pointer count is 2048, returns 11 references\n    const getEveryPow2 = (maxDistance) => {\n      const entries = new Set()\n      for (let i = 1; i <= maxDistance; i *= 2) {\n        const index = Math.min(i - 1, all.length - 1)\n        entries.add(all[index])\n      }\n      return entries\n    }\n    const references = getEveryPow2(Math.min(pointerCount, all.length))\n\n    // Always include the last known reference\n    if (all.length < pointerCount && all[all.length - 1]) {\n      references.add(all[all.length - 1])\n    }\n\n    // Create the next pointers from heads\n    const nexts = Object.keys(this.heads.reverse().reduce(uniqueEntriesReducer, {}))\n    const isNext = e => !nexts.includes(e)\n    // Delete the heads from the refs\n    const refs = Array.from(references).map(getHash).filter(isNext)\n    // @TODO: Split Entry.create into creating object, checking permission, signing and then posting to IPFS\n    // Create the entry and add it to the internal cache\n    const entry = await Entry.create(\n      this._storage,\n      this._identity,\n      this.id,\n      data,\n      nexts,\n      this.clock,\n      refs,\n      pin\n    )\n\n    const canAppend = await this._access.canAppend(entry, this._identity.provider)\n    if (!canAppend) {\n      throw new Error(`Could not append entry, key \"${this._identity.id}\" is not allowed to write to the log`)\n    }\n\n    this._entryIndex.set(entry.hash, entry)\n    nexts.forEach(e => (this._nextsIndex[e] = entry.hash))\n    this._headsIndex = {}\n    this._headsIndex[entry.hash] = entry\n    // Update the length\n    this._length++\n    return entry\n  }\n\n  /*\n   * Creates a javscript iterator over log entries\n   *\n   * @param {Object} options\n   * @param {string|Array} options.gt Beginning hash of the iterator, non-inclusive\n   * @param {string|Array} options.gte Beginning hash of the iterator, inclusive\n   * @param {string|Array} options.lt Ending hash of the iterator, non-inclusive\n   * @param {string|Array} options.lte Ending hash of the iterator, inclusive\n   * @param {amount} options.amount Number of entried to return to / from the gte / lte hash\n   * @returns {Symbol.Iterator} Iterator object containing log entries\n   *\n   * @examples\n   *\n   * (async () => {\n   *   log1 = new Log(ipfs, testIdentity, { logId: 'X' })\n   *\n   *   for (let i = 0; i <= 100; i++) {\n   *     await log1.append('entry' + i)\n   *   }\n   *\n   *   let it = log1.iterator({\n   *     lte: 'zdpuApFd5XAPkCTmSx7qWQmQzvtdJPtx2K5p9to6ytCS79bfk',\n   *     amount: 10\n   *   })\n   *\n   *   [...it].length // 10\n   * })()\n   *\n   *\n   */\n  iterator ({ gt = undefined, gte = undefined, lt = undefined, lte = undefined, amount = -1 } =\n  {}) {\n    if (amount === 0) return (function * () {})()\n    if (typeof lte === 'string') lte = [this.get(lte)]\n    if (typeof lt === 'string') lt = [this.get(this.get(lt).next[0])]\n\n    if (lte && !Array.isArray(lte)) throw LogError.LtOrLteMustBeStringOrArray()\n    if (lt && !Array.isArray(lt)) throw LogError.LtOrLteMustBeStringOrArray()\n\n    const start = (lte || (lt || this.heads)).filter(isDefined)\n    const endHash = gte ? this.get(gte).hash : gt ? this.get(gt).hash : null\n    const count = endHash ? -1 : amount || -1\n\n    const entries = this.traverse(start, count, endHash)\n    let entryValues = Object.values(entries)\n\n    // Strip off last entry if gt is non-inclusive\n    if (gt) entryValues.pop()\n\n    // Deal with the amount argument working backwards from gt/gte\n    if ((gt || gte) && amount > -1) {\n      entryValues = entryValues.slice(entryValues.length - amount, entryValues.length)\n    }\n\n    return (function * () {\n      for (const i in entryValues) {\n        yield entryValues[i]\n      }\n    })()\n  }\n\n  /**\n   * Join two logs.\n   *\n   * Joins another log into this one.\n   *\n   * @param {Log} log Log to join with this Log\n   * @param {number} [size=-1] Max size of the joined log\n   * @returns {Promise<Log>} This Log instance\n   * @example\n   * await log1.join(log2)\n   */\n  async join (log, size = -1) {\n    if (!isDefined(log)) throw LogError.LogNotDefinedError()\n    if (!Log.isLog(log)) throw LogError.NotALogError()\n    if (this.id !== log.id) return\n\n    // Get the difference of the logs\n    const newItems = Log.difference(log, this)\n\n    const identityProvider = this._identity.provider\n    // Verify if entries are allowed to be added to the log and throws if\n    // there's an invalid entry\n    const permitted = async (entry) => {\n      const canAppend = await this._access.canAppend(entry, identityProvider)\n      if (!canAppend) {\n        throw new Error(`Could not append entry, key \"${entry.identity.id}\" is not allowed to write to the log`)\n      }\n    }\n\n    // Verify signature for each entry and throws if there's an invalid signature\n    const verify = async (entry) => {\n      const isValid = await Entry.verify(identityProvider, entry)\n      const publicKey = entry.identity ? entry.identity.publicKey : entry.key\n      if (!isValid) throw new Error(`Could not validate signature \"${entry.sig}\" for entry \"${entry.hash}\" and key \"${publicKey}\"`)\n    }\n\n    const entriesToJoin = Object.values(newItems)\n    await pMap(entriesToJoin, async e => {\n      await permitted(e)\n      await verify(e)\n    }, { concurrency: this.joinConcurrency })\n\n    // Update the internal next pointers index\n    const addToNextsIndex = e => {\n      const entry = this.get(e.hash)\n      if (!entry) this._length++ /* istanbul ignore else */\n      e.next.forEach(a => (this._nextsIndex[a] = e.hash))\n    }\n    Object.values(newItems).forEach(addToNextsIndex)\n\n    // Update the internal entry index\n    this._entryIndex.add(newItems)\n\n    // Merge the heads\n    const notReferencedByNewItems = e => !nextsFromNewItems.find(a => a === e.hash)\n    const notInCurrentNexts = e => !this._nextsIndex[e.hash]\n    const nextsFromNewItems = Object.values(newItems).map(getNextPointers).reduce(flatMap, [])\n    const mergedHeads = Log.findHeads(Object.values(Object.assign({}, this._headsIndex, log._headsIndex)))\n      .filter(notReferencedByNewItems)\n      .filter(notInCurrentNexts)\n      .reduce(uniqueEntriesReducer, {})\n\n    this._headsIndex = mergedHeads\n\n    // Slice to the requested size\n    if (size > -1) {\n      let tmp = this.values\n      tmp = tmp.slice(-size)\n      this._entryIndex = null\n      this._entryIndex = new EntryIndex(tmp.reduce(uniqueEntriesReducer, {}))\n      this._headsIndex = Log.findHeads(tmp).reduce(uniqueEntriesReducer, {})\n      this._length = this._entryIndex.length\n    }\n\n    // Find the latest clock from the heads\n    const maxClock = Object.values(this._headsIndex).reduce(maxClockTimeReducer, 0)\n    this._clock = new Clock(this.clock.id, Math.max(this.clock.time, maxClock))\n    return this\n  }\n\n  /**\n   * Get the log in JSON format.\n   * @returns {Object} An object with the id and heads properties\n   */\n  toJSON () {\n    return {\n      id: this.id,\n      heads: this.heads\n        .sort(this._sortFn) // default sorting\n        .reverse() // we want the latest as the first element\n        .map(getHash) // return only the head hashes\n    }\n  }\n\n  /**\n   * Get the log in JSON format as a snapshot.\n   * @returns {Object} An object with the id, heads and value properties\n   */\n  toSnapshot () {\n    return {\n      id: this.id,\n      heads: this.heads,\n      values: this.values\n    }\n  }\n\n  /**\n   * Get the log as a Buffer.\n   * @returns {Buffer}\n   */\n  toBuffer () {\n    return Buffer.from(JSON.stringify(this.toJSON()))\n  }\n\n  /**\n   * Returns the log entries as a formatted string.\n   * @returns {string}\n   * @example\n   * two\n   * └─one\n   *   └─three\n   */\n  toString (payloadMapper) {\n    return this.values\n      .slice()\n      .reverse()\n      .map((e, idx) => {\n        const parents = Entry.findChildren(e, this.values)\n        const len = parents.length\n        let padding = new Array(Math.max(len - 1, 0))\n        padding = len > 1 ? padding.fill('  ') : padding\n        padding = len > 0 ? padding.concat(['└─']) : padding\n        /* istanbul ignore next */\n        return padding.join('') + (payloadMapper ? payloadMapper(e.payload) : e.payload)\n      })\n      .join('\\n')\n  }\n\n  /**\n   * Check whether an object is a Log instance.\n   * @param {Object} log An object to check\n   * @returns {boolean}\n   */\n  static isLog (log) {\n    return log.id !== undefined &&\n      log.heads !== undefined &&\n      log._entryIndex !== undefined\n  }\n\n  /**\n   * Get the log's multihash.\n   * @returns {Promise<string>} Multihash of the Log as Base58 encoded string.\n   */\n  toMultihash ({ format } = {}) {\n    return LogIO.toMultihash(this._storage, this, { format })\n  }\n\n  /**\n   * Create a log from a hashes.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {string} hash The log hash\n   * @param {Object} options\n   * @param {AccessController} options.access The access controller instance\n   * @param {number} options.length How many items to include in the log\n   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n   * @param {function(hash, entry, parent, depth)} options.onProgressCallback\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @returns {Promise<Log>}\n   */\n  static async fromMultihash (ipfs, identity, hash,\n    { access, length = -1, exclude = [], shouldExclude, timeout, concurrency, sortFn, onProgressCallback } = {}) {\n    // TODO: need to verify the entries with 'key'\n    const { logId, entries, heads } = await LogIO.fromMultihash(ipfs, hash,\n      { length, exclude, shouldExclude, timeout, onProgressCallback, concurrency, sortFn })\n    return new Log(ipfs, identity, { logId, access, entries, heads, sortFn })\n  }\n\n  /**\n   * Create a log from a single entry's hash.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {string} hash The entry's hash\n   * @param {Object} options\n   * @param {string} options.logId The ID of the log\n   * @param {AccessController} options.access The access controller instance\n   * @param {number} options.length How many entries to include in the log\n   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n   * @param {function(hash, entry, parent, depth)} options.onProgressCallback\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Promise<Log>} New Log\n   */\n  static async fromEntryHash (ipfs, identity, hash,\n    { logId, access, length = -1, exclude = [], shouldExclude, timeout, concurrency, sortFn, onProgressCallback } = {}) {\n    // TODO: need to verify the entries with 'key'\n    const { entries } = await LogIO.fromEntryHash(ipfs, hash,\n      { length, exclude, shouldExclude, timeout, concurrency, onProgressCallback })\n    return new Log(ipfs, identity, { logId, access, entries, sortFn })\n  }\n\n  /**\n   * Create a log from a Log Snapshot JSON.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {Object} json Log snapshot as JSON object\n   * @param {Object} options\n   * @param {AccessController} options.access The access controller instance\n   * @param {number} options.length How many entries to include in the log\n   * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Promise<Log>} New Log\n   */\n  static async fromJSON (ipfs, identity, json,\n    { access, length = -1, timeout, sortFn, onProgressCallback } = {}) {\n    // TODO: need to verify the entries with 'key'\n    const { logId, entries } = await LogIO.fromJSON(ipfs, json,\n      { length, timeout, onProgressCallback })\n    return new Log(ipfs, identity, { logId, access, entries, sortFn })\n  }\n\n  /**\n   * Create a new log from an Entry instance.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {Entry|Array<Entry>} sourceEntries An Entry or an array of entries to fetch a log from\n   * @param {Object} options\n   * @param {AccessController} options.access The access controller instance\n   * @param {number} options.length How many entries to include. Default: infinite.\n   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n   * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Promise<Log>} New Log\n   */\n  static async fromEntry (ipfs, identity, sourceEntries,\n    { access, length = -1, exclude = [], timeout, concurrency, sortFn, onProgressCallback } = {}) {\n    // TODO: need to verify the entries with 'key'\n    const { logId, entries } = await LogIO.fromEntry(ipfs, sourceEntries,\n      { length, exclude, timeout, concurrency, onProgressCallback })\n    return new Log(ipfs, identity, { logId, access, entries, sortFn })\n  }\n\n  /**\n   * Find heads from a collection of entries.\n   *\n   * Finds entries that are the heads of this collection,\n   * ie. entries that are not referenced by other entries.\n   *\n   * @param {Array<Entry>} entries Entries to search heads from\n   * @returns {Array<Entry>}\n   */\n  static findHeads (entries) {\n    const indexReducer = (res, entry, idx, arr) => {\n      const addToResult = e => (res[e] = entry.hash)\n      entry.next.forEach(addToResult)\n      return res\n    }\n\n    const items = entries.reduce(indexReducer, {})\n\n    const exists = e => items[e.hash] === undefined\n    const compareIds = (a, b) => a.clock.id > b.clock.id\n\n    return entries.filter(exists).sort(compareIds)\n  }\n\n  // Find entries that point to another entry that is not in the\n  // input array\n  static findTails (entries) {\n    // Reverse index { next -> entry }\n    const reverseIndex = {}\n    // Null index containing entries that have no parents (nexts)\n    const nullIndex = []\n    // Hashes for all entries for quick lookups\n    const hashes = {}\n    // Hashes of all next entries\n    let nexts = []\n\n    const addToIndex = (e) => {\n      if (e.next.length === 0) {\n        nullIndex.push(e)\n      }\n      const addToReverseIndex = (a) => {\n        /* istanbul ignore else */\n        if (!reverseIndex[a]) reverseIndex[a] = []\n        reverseIndex[a].push(e)\n      }\n\n      // Add all entries and their parents to the reverse index\n      e.next.forEach(addToReverseIndex)\n      // Get all next references\n      nexts = nexts.concat(e.next)\n      // Get the hashes of input entries\n      hashes[e.hash] = true\n    }\n\n    // Create our indices\n    entries.forEach(addToIndex)\n\n    const addUniques = (res, entries, idx, arr) => res.concat(findUniques(entries, 'hash'))\n    const exists = e => hashes[e] === undefined\n    const findFromReverseIndex = e => reverseIndex[e]\n\n    // Drop hashes that are not in the input entries\n    const tails = nexts // For every hash in nexts:\n      .filter(exists) // Remove undefineds and nulls\n      .map(findFromReverseIndex) // Get the Entry from the reverse index\n      .reduce(addUniques, []) // Flatten the result and take only uniques\n      .concat(nullIndex) // Combine with tails the have no next refs (ie. first-in-their-chain)\n\n    return findUniques(tails, 'hash').sort(Entry.compare)\n  }\n\n  // Find the hashes to entries that are not in a collection\n  // but referenced by other entries\n  static findTailHashes (entries) {\n    const hashes = {}\n    const addToIndex = e => (hashes[e.hash] = true)\n    const reduceTailHashes = (res, entry, idx, arr) => {\n      const addToResult = (e) => {\n        /* istanbul ignore else */\n        if (hashes[e] === undefined) {\n          res.splice(0, 0, e)\n        }\n      }\n      entry.next.reverse().forEach(addToResult)\n      return res\n    }\n\n    entries.forEach(addToIndex)\n    return entries.reduce(reduceTailHashes, [])\n  }\n\n  static difference (a, b) {\n    const stack = Object.keys(a._headsIndex)\n    const traversed = {}\n    const res = {}\n\n    const pushToStack = hash => {\n      if (!traversed[hash] && !b.get(hash)) {\n        stack.push(hash)\n        traversed[hash] = true\n      }\n    }\n\n    while (stack.length > 0) {\n      const hash = stack.shift()\n      const entry = a.get(hash)\n      if (entry && !b.get(hash) && entry.id === b.id) {\n        res[entry.hash] = entry\n        traversed[entry.hash] = true\n        entry.next.concat(entry.refs).forEach(pushToStack)\n      }\n    }\n    return res\n  }\n}\n\nmodule.exports = Log\nmodule.exports.Sorting = Sorting\nmodule.exports.Entry = Entry\nmodule.exports.AccessController = AccessController\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}