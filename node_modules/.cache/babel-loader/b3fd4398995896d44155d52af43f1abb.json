{"ast":null,"code":"'use strict';\n\nconst multihash = require('multihashes');\n\nconst crypto = require('./crypto');\n\nmodule.exports = Multihashing;\n/**\n * Hash the given `buf` using the algorithm specified\n * by `func`.\n *\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} func - The algorithm to use.\n * @param {number} [length] - Optionally trim the result to this length.\n * @param {function(Error, Buffer)} callback\n * @returns {undefined}\n */\n\nfunction Multihashing(buf, func, length, callback) {\n  if (typeof length === 'function') {\n    callback = length;\n    length = undefined;\n  }\n\n  if (!callback) {\n    throw new Error('Missing callback');\n  }\n\n  Multihashing.digest(buf, func, length, (err, digest) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, multihash.encode(digest, func, length));\n  });\n}\n/**\n * The `buffer` module for easy use in the browser.\n *\n * @type {Buffer}\n */\n\n\nMultihashing.Buffer = Buffer; // for browser things\n\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\n\nMultihashing.multihash = multihash;\n/**\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} func - The algorithm to use.\n * @param {number} [length] - Optionally trim the result to this length.\n * @param {function(Error, Buffer)} callback\n * @returns {undefined}\n */\n\nMultihashing.digest = function (buf, func, length, callback) {\n  if (typeof length === 'function') {\n    callback = length;\n    length = undefined;\n  }\n\n  if (!callback) {\n    throw new Error('Missing callback');\n  }\n\n  let cb = callback;\n\n  if (length) {\n    cb = (err, digest) => {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, digest.slice(0, length));\n    };\n  }\n\n  let hash;\n\n  try {\n    hash = Multihashing.createHash(func);\n  } catch (err) {\n    return cb(err);\n  }\n\n  hash(buf, cb);\n};\n/**\n * @param {string|number} func\n *\n * @returns {function} - The to `func` corresponding hash function.\n */\n\n\nMultihashing.createHash = function (func) {\n  func = multihash.coerceCode(func);\n\n  if (!Multihashing.functions[func]) {\n    throw new Error('multihash function ' + func + ' not yet supported');\n  }\n\n  return Multihashing.functions[func];\n};\n/**\n * Mapping of multihash codes to their hashing functions.\n * @type {Object}\n */\n\n\nMultihashing.functions = {\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256\n}; // add blake functions\n\ncrypto.addBlake(Multihashing.functions);\n\nMultihashing.validate = (data, hash, callback) => {\n  let algo = multihash.decode(hash).name;\n  Multihashing(data, algo, (err, newHash) => {\n    if (err) return callback(err);\n    callback(err, Buffer.compare(hash, newHash) === 0);\n  });\n};","map":{"version":3,"names":["multihash","require","crypto","module","exports","Multihashing","buf","func","length","callback","undefined","Error","digest","err","encode","Buffer","cb","slice","hash","createHash","coerceCode","functions","sha1","sha2256","sha2512","sha3512","sha3384","sha3256","sha3224","shake128","shake256","keccak224","keccak256","keccak384","keccak512","murmur3128","murmur332","dblSha2256","addBlake","validate","data","algo","decode","name","newHash","compare"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/multihashing-async/src/index.js"],"sourcesContent":["'use strict'\n\nconst multihash = require('multihashes')\nconst crypto = require('./crypto')\n\nmodule.exports = Multihashing\n\n/**\n * Hash the given `buf` using the algorithm specified\n * by `func`.\n *\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} func - The algorithm to use.\n * @param {number} [length] - Optionally trim the result to this length.\n * @param {function(Error, Buffer)} callback\n * @returns {undefined}\n */\nfunction Multihashing (buf, func, length, callback) {\n  if (typeof length === 'function') {\n    callback = length\n    length = undefined\n  }\n\n  if (!callback) {\n    throw new Error('Missing callback')\n  }\n\n  Multihashing.digest(buf, func, length, (err, digest) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, multihash.encode(digest, func, length))\n  })\n}\n\n/**\n * The `buffer` module for easy use in the browser.\n *\n * @type {Buffer}\n */\nMultihashing.Buffer = Buffer // for browser things\n\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\nMultihashing.multihash = multihash\n\n/**\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} func - The algorithm to use.\n * @param {number} [length] - Optionally trim the result to this length.\n * @param {function(Error, Buffer)} callback\n * @returns {undefined}\n */\nMultihashing.digest = function (buf, func, length, callback) {\n  if (typeof length === 'function') {\n    callback = length\n    length = undefined\n  }\n\n  if (!callback) {\n    throw new Error('Missing callback')\n  }\n\n  let cb = callback\n  if (length) {\n    cb = (err, digest) => {\n      if (err) {\n        return callback(err)\n      }\n\n      callback(null, digest.slice(0, length))\n    }\n  }\n\n  let hash\n  try {\n    hash = Multihashing.createHash(func)\n  } catch (err) {\n    return cb(err)\n  }\n\n  hash(buf, cb)\n}\n\n/**\n * @param {string|number} func\n *\n * @returns {function} - The to `func` corresponding hash function.\n */\nMultihashing.createHash = function (func) {\n  func = multihash.coerceCode(func)\n  if (!Multihashing.functions[func]) {\n    throw new Error('multihash function ' + func + ' not yet supported')\n  }\n\n  return Multihashing.functions[func]\n}\n\n/**\n * Mapping of multihash codes to their hashing functions.\n * @type {Object}\n */\nMultihashing.functions = {\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256\n}\n\n// add blake functions\ncrypto.addBlake(Multihashing.functions)\n\nMultihashing.validate = (data, hash, callback) => {\n  let algo = multihash.decode(hash).name\n  Multihashing(data, algo, (err, newHash) => {\n    if (err) return callback(err)\n    callback(err, Buffer.compare(hash, newHash) === 0)\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}