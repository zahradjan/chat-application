{"ast":null,"code":"/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\n\nconst _0n = BigInt(0);\n\nconst _1n = BigInt(1);\n\nconst _2n = BigInt(2);\n\nconst _3n = BigInt(3);\n\nconst _8n = BigInt(8);\n\nconst POW_2_256 = _2n ** BigInt(256);\n\nconst CURVE = {\n  a: _0n,\n  b: BigInt(7),\n  P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),\n  n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),\n  h: _1n,\n  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')\n};\nexport { CURVE };\n\nfunction weistrass(x) {\n  const {\n    a,\n    b\n  } = CURVE;\n  const x2 = mod(x * x);\n  const x3 = mod(x2 * x);\n  return mod(x3 + a * x + b);\n}\n\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\n\nclass JacobianPoint {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  static fromAffine(p) {\n    if (!(p instanceof Point)) {\n      throw new TypeError('JacobianPoint#fromAffine: expected Point');\n    }\n\n    return new JacobianPoint(p.x, p.y, _1n);\n  }\n\n  static toAffineBatch(points) {\n    const toInv = invertBatch(points.map(p => p.z));\n    return points.map((p, i) => p.toAffine(toInv[i]));\n  }\n\n  static normalizeZ(points) {\n    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n  }\n\n  equals(other) {\n    if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2\n    } = other;\n    const Z1Z1 = mod(Z1 ** _2n);\n    const Z2Z2 = mod(Z2 ** _2n);\n    const U1 = mod(X1 * Z2Z2);\n    const U2 = mod(X2 * Z1Z1);\n    const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n    const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n    return U1 === U2 && S1 === S2;\n  }\n\n  negate() {\n    return new JacobianPoint(this.x, mod(-this.y), this.z);\n  }\n\n  double() {\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const A = mod(X1 ** _2n);\n    const B = mod(Y1 ** _2n);\n    const C = mod(B ** _2n);\n    const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));\n    const E = mod(_3n * A);\n    const F = mod(E ** _2n);\n    const X3 = mod(F - _2n * D);\n    const Y3 = mod(E * (D - X3) - _8n * C);\n    const Z3 = mod(_2n * Y1 * Z1);\n    return new JacobianPoint(X3, Y3, Z3);\n  }\n\n  add(other) {\n    if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2\n    } = other;\n    if (X2 === _0n || Y2 === _0n) return this;\n    if (X1 === _0n || Y1 === _0n) return other;\n    const Z1Z1 = mod(Z1 ** _2n);\n    const Z2Z2 = mod(Z2 ** _2n);\n    const U1 = mod(X1 * Z2Z2);\n    const U2 = mod(X2 * Z1Z1);\n    const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n    const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n    const H = mod(U2 - U1);\n    const r = mod(S2 - S1);\n\n    if (H === _0n) {\n      if (r === _0n) {\n        return this.double();\n      } else {\n        return JacobianPoint.ZERO;\n      }\n    }\n\n    const HH = mod(H ** _2n);\n    const HHH = mod(H * HH);\n    const V = mod(U1 * HH);\n    const X3 = mod(r ** _2n - HHH - _2n * V);\n    const Y3 = mod(r * (V - X3) - S1 * HHH);\n    const Z3 = mod(Z1 * Z2 * H);\n    return new JacobianPoint(X3, Y3, Z3);\n  }\n\n  subtract(other) {\n    return this.add(other.negate());\n  }\n\n  multiplyUnsafe(scalar) {\n    let n = normalizeScalar(scalar);\n    const G = JacobianPoint.BASE;\n    const P0 = JacobianPoint.ZERO;\n    if (n === _0n) return P0;\n    if (n === _1n) return this;\n\n    if (!USE_ENDOMORPHISM) {\n      let p = P0;\n      let d = this;\n\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n\n      return p;\n    }\n\n    let {\n      k1neg,\n      k1,\n      k2neg,\n      k2\n    } = splitScalarEndo(n);\n    let k1p = P0;\n    let k2p = P0;\n    let d = this;\n\n    while (k1 > _0n || k2 > _0n) {\n      if (k1 & _1n) k1p = k1p.add(d);\n      if (k2 & _1n) k2p = k2p.add(d);\n      d = d.double();\n      k1 >>= _1n;\n      k2 >>= _1n;\n    }\n\n    if (k1neg) k1p = k1p.negate();\n    if (k2neg) k2p = k2p.negate();\n    k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n    return k1p.add(k2p);\n  }\n\n  precomputeWindow(W) {\n    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n    const points = [];\n    let p = this;\n    let base = p;\n\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n\n      for (let i = 1; i < 2 ** (W - 1); i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n\n      p = base.double();\n    }\n\n    return points;\n  }\n\n  wNAF(n, affinePoint) {\n    if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n\n    if (256 % W) {\n      throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n    }\n\n    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n\n    if (!precomputes) {\n      precomputes = this.precomputeWindow(W);\n\n      if (affinePoint && W !== 1) {\n        precomputes = JacobianPoint.normalizeZ(precomputes);\n        pointPrecomputes.set(affinePoint, precomputes);\n      }\n    }\n\n    let p = JacobianPoint.ZERO;\n    let f = JacobianPoint.ZERO;\n    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n    const windowSize = 2 ** (W - 1);\n    const mask = BigInt(2 ** W - 1);\n    const maxNumber = 2 ** W;\n    const shiftBy = BigInt(W);\n\n    for (let window = 0; window < windows; window++) {\n      const offset = window * windowSize;\n      let wbits = Number(n & mask);\n      n >>= shiftBy;\n\n      if (wbits > windowSize) {\n        wbits -= maxNumber;\n        n += _1n;\n      }\n\n      if (wbits === 0) {\n        let pr = precomputes[offset];\n        if (window % 2) pr = pr.negate();\n        f = f.add(pr);\n      } else {\n        let cached = precomputes[offset + Math.abs(wbits) - 1];\n        if (wbits < 0) cached = cached.negate();\n        p = p.add(cached);\n      }\n    }\n\n    return {\n      p,\n      f\n    };\n  }\n\n  multiply(scalar, affinePoint) {\n    let n = normalizeScalar(scalar);\n    let point;\n    let fake;\n\n    if (USE_ENDOMORPHISM) {\n      const {\n        k1neg,\n        k1,\n        k2neg,\n        k2\n      } = splitScalarEndo(n);\n      let {\n        p: k1p,\n        f: f1p\n      } = this.wNAF(k1, affinePoint);\n      let {\n        p: k2p,\n        f: f2p\n      } = this.wNAF(k2, affinePoint);\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n      point = k1p.add(k2p);\n      fake = f1p.add(f2p);\n    } else {\n      const {\n        p,\n        f\n      } = this.wNAF(n, affinePoint);\n      point = p;\n      fake = f;\n    }\n\n    return JacobianPoint.normalizeZ([point, fake])[0];\n  }\n\n  toAffine() {\n    let invZ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : invert(this.z);\n    const {\n      x,\n      y,\n      z\n    } = this;\n    const iz1 = invZ;\n    const iz2 = mod(iz1 * iz1);\n    const iz3 = mod(iz2 * iz1);\n    const ax = mod(x * iz2);\n    const ay = mod(y * iz3);\n    const zz = mod(z * iz1);\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return new Point(ax, ay);\n  }\n\n}\n\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  _setWindowSize(windowSize) {\n    this._WINDOW_SIZE = windowSize;\n    pointPrecomputes.delete(this);\n  }\n\n  static fromCompressedHex(bytes) {\n    const isShort = bytes.length === 32;\n    const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n    if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n    const y2 = weistrass(x);\n    let y = sqrtMod(y2);\n    const isYOdd = (y & _1n) === _1n;\n\n    if (isShort) {\n      if (isYOdd) y = mod(-y);\n    } else {\n      const isFirstByteOdd = (bytes[0] & 1) === 1;\n      if (isFirstByteOdd !== isYOdd) y = mod(-y);\n    }\n\n    const point = new Point(x, y);\n    point.assertValidity();\n    return point;\n  }\n\n  static fromUncompressedHex(bytes) {\n    const x = bytesToNumber(bytes.subarray(1, 33));\n    const y = bytesToNumber(bytes.subarray(33, 65));\n    const point = new Point(x, y);\n    point.assertValidity();\n    return point;\n  }\n\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex);\n    const len = bytes.length;\n    const header = bytes[0];\n\n    if (len === 32 || len === 33 && (header === 0x02 || header === 0x03)) {\n      return this.fromCompressedHex(bytes);\n    }\n\n    if (len === 65 && header === 0x04) return this.fromUncompressedHex(bytes);\n    throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);\n  }\n\n  static fromPrivateKey(privateKey) {\n    return Point.BASE.multiply(normalizePrivateKey(privateKey));\n  }\n\n  static fromSignature(msgHash, signature, recovery) {\n    msgHash = ensureBytes(msgHash);\n    const h = truncateHash(msgHash);\n    const {\n      r,\n      s\n    } = normalizeSignature(signature);\n\n    if (recovery !== 0 && recovery !== 1) {\n      throw new Error('Cannot recover signature: invalid recovery bit');\n    }\n\n    if (h === _0n) throw new Error('Cannot recover signature: msgHash cannot be 0');\n    const prefix = recovery & 1 ? '03' : '02';\n    const R = Point.fromHex(prefix + numTo32bStr(r));\n    const {\n      n\n    } = CURVE;\n    const rinv = invert(r, n);\n    const u1 = mod(-h * rinv, n);\n    const u2 = mod(s * rinv, n);\n    const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n    if (!Q) throw new Error('Cannot recover signature: point at infinify');\n    Q.assertValidity();\n    return Q;\n  }\n\n  toRawBytes() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return hexToBytes(this.toHex(isCompressed));\n  }\n\n  toHex() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const x = numTo32bStr(this.x);\n\n    if (isCompressed) {\n      const prefix = this.y & _1n ? '03' : '02';\n      return `${prefix}${x}`;\n    } else {\n      return `04${x}${numTo32bStr(this.y)}`;\n    }\n  }\n\n  toHexX() {\n    return this.toHex(true).slice(2);\n  }\n\n  toRawX() {\n    return this.toRawBytes(true).slice(1);\n  }\n\n  assertValidity() {\n    const msg = 'Point is not on elliptic curve';\n    const {\n      x,\n      y\n    } = this;\n    if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);\n    const left = mod(y * y);\n    const right = weistrass(x);\n    if (mod(left - right) !== _0n) throw new Error(msg);\n  }\n\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n\n  negate() {\n    return new Point(this.x, mod(-this.y));\n  }\n\n  double() {\n    return JacobianPoint.fromAffine(this).double().toAffine();\n  }\n\n  add(other) {\n    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n  }\n\n  subtract(other) {\n    return this.add(other.negate());\n  }\n\n  multiply(scalar) {\n    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n  }\n\n  multiplyAndAddUnsafe(Q, a, b) {\n    const P = JacobianPoint.fromAffine(this);\n    const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n    const sum = aP.add(bQ);\n    return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n  }\n\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\n\nfunction sliceDER(s) {\n  return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\n\nfunction parseDERInt(data) {\n  if (data.length < 2 || data[0] !== 0x02) {\n    throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n  }\n\n  const len = data[1];\n  const res = data.subarray(2, len + 2);\n\n  if (!len || res.length !== len) {\n    throw new Error(`Invalid signature integer: wrong length`);\n  }\n\n  if (res[0] === 0x00 && res[1] <= 0x7f) {\n    throw new Error('Invalid signature integer: trailing length');\n  }\n\n  return {\n    data: bytesToNumber(res),\n    left: data.subarray(len + 2)\n  };\n}\n\nfunction parseDERSignature(data) {\n  if (data.length < 2 || data[0] != 0x30) {\n    throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n  }\n\n  if (data[1] !== data.length - 2) {\n    throw new Error('Invalid signature: incorrect length');\n  }\n\n  const {\n    data: r,\n    left: sBytes\n  } = parseDERInt(data.subarray(2));\n  const {\n    data: s,\n    left: rBytesLeft\n  } = parseDERInt(sBytes);\n\n  if (rBytesLeft.length) {\n    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n  }\n\n  return {\n    r,\n    s\n  };\n}\n\nexport class Signature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n\n  static fromCompact(hex) {\n    const arr = isUint8a(hex);\n    const name = 'Signature.fromCompact';\n    if (typeof hex !== 'string' && !arr) throw new TypeError(`${name}: Expected string or Uint8Array`);\n    const str = arr ? bytesToHex(hex) : hex;\n    if (str.length !== 128) throw new Error(`${name}: Expected 64-byte hex`);\n    return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n  }\n\n  static fromDER(hex) {\n    const arr = isUint8a(hex);\n    if (typeof hex !== 'string' && !arr) throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n    const {\n      r,\n      s\n    } = parseDERSignature(arr ? hex : hexToBytes(hex));\n    return new Signature(r, s);\n  }\n\n  static fromHex(hex) {\n    return this.fromDER(hex);\n  }\n\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');\n    if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');\n  }\n\n  hasHighS() {\n    const HALF = CURVE.n >> _1n;\n    return this.s > HALF;\n  }\n\n  normalizeS() {\n    return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;\n  }\n\n  toDERRawBytes() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return hexToBytes(this.toDERHex(isCompressed));\n  }\n\n  toDERHex() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const sHex = sliceDER(numberToHexUnpadded(this.s));\n    if (isCompressed) return sHex;\n    const rHex = sliceDER(numberToHexUnpadded(this.r));\n    const rLen = numberToHexUnpadded(rHex.length / 2);\n    const sLen = numberToHexUnpadded(sHex.length / 2);\n    const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);\n    return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n  }\n\n  toRawBytes() {\n    return this.toDERRawBytes();\n  }\n\n  toHex() {\n    return this.toDERHex();\n  }\n\n  toCompactRawBytes() {\n    return hexToBytes(this.toCompactHex());\n  }\n\n  toCompactHex() {\n    return numTo32bStr(this.r) + numTo32bStr(this.s);\n  }\n\n}\n\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  if (!arrays.every(isUint8a)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n\n  return result;\n}\n\nfunction isUint8a(bytes) {\n  return bytes instanceof Uint8Array;\n}\n\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  let hex = '';\n\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n\n  return hex;\n}\n\nfunction numTo32bStr(num) {\n  if (num > POW_2_256) throw new Error('Expected number < 2^256');\n  return num.toString(16).padStart(64, '0');\n}\n\nfunction numTo32b(num) {\n  return hexToBytes(numTo32bStr(num));\n}\n\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n  }\n\n  return BigInt(`0x${hex}`);\n}\n\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n  const array = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n\n  return array;\n}\n\nfunction bytesToNumber(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\n\nfunction ensureBytes(hex) {\n  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\n\nfunction normalizeScalar(num) {\n  if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0) return BigInt(num);\n  if (typeof num === 'bigint' && isWithinCurveOrder(num)) return num;\n  throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\n\nfunction mod(a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n\nfunction pow2(x, power) {\n  const {\n    P\n  } = CURVE;\n  let res = x;\n\n  while (power-- > _0n) {\n    res *= res;\n    res %= P;\n  }\n\n  return res;\n}\n\nfunction sqrtMod(x) {\n  const {\n    P\n  } = CURVE;\n\n  const _6n = BigInt(6);\n\n  const _11n = BigInt(11);\n\n  const _22n = BigInt(22);\n\n  const _23n = BigInt(23);\n\n  const _44n = BigInt(44);\n\n  const _88n = BigInt(88);\n\n  const b2 = x * x * x % P;\n  const b3 = b2 * b2 * x % P;\n  const b6 = pow2(b3, _3n) * b3 % P;\n  const b9 = pow2(b6, _3n) * b3 % P;\n  const b11 = pow2(b9, _2n) * b2 % P;\n  const b22 = pow2(b11, _11n) * b11 % P;\n  const b44 = pow2(b22, _22n) * b22 % P;\n  const b88 = pow2(b44, _44n) * b44 % P;\n  const b176 = pow2(b88, _88n) * b88 % P;\n  const b220 = pow2(b176, _44n) * b44 % P;\n  const b223 = pow2(b220, _3n) * b3 % P;\n  const t1 = pow2(b223, _23n) * b22 % P;\n  const t2 = pow2(t1, _6n) * b2 % P;\n  return pow2(t2, _2n);\n}\n\nfunction invert(number) {\n  let modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n\n  let a = mod(number, modulo);\n  let b = modulo;\n  let x = _0n,\n      y = _1n,\n      u = _1n,\n      v = _0n;\n\n  while (a !== _0n) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction invertBatch(nums) {\n  let p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const scratch = new Array(nums.length);\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (num === _0n) return acc;\n    scratch[i] = acc;\n    return mod(acc * num, p);\n  }, _1n);\n  const inverted = invert(lastMultiplied, p);\n  nums.reduceRight((acc, num, i) => {\n    if (num === _0n) return acc;\n    scratch[i] = mod(acc * scratch[i], p);\n    return mod(acc * num, p);\n  }, inverted);\n  return scratch;\n}\n\nconst divNearest = (a, b) => (a + b / _2n) / b;\n\nconst POW_2_128 = _2n ** BigInt(128);\n\nfunction splitScalarEndo(k) {\n  const {\n    n\n  } = CURVE;\n  const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n  const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n  const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n  const b2 = a1;\n  const c1 = divNearest(b2 * k, n);\n  const c2 = divNearest(-b1 * k, n);\n  let k1 = mod(k - c1 * a1 - c2 * a2, n);\n  let k2 = mod(-c1 * b1 - c2 * b2, n);\n  const k1neg = k1 > POW_2_128;\n  const k2neg = k2 > POW_2_128;\n  if (k1neg) k1 = n - k1;\n  if (k2neg) k2 = n - k2;\n\n  if (k1 > POW_2_128 || k2 > POW_2_128) {\n    throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n  }\n\n  return {\n    k1neg,\n    k1,\n    k2neg,\n    k2\n  };\n}\n\nfunction truncateHash(hash) {\n  const {\n    n\n  } = CURVE;\n  const byteLength = hash.length;\n  const delta = byteLength * 8 - 256;\n  let h = bytesToNumber(hash);\n  if (delta > 0) h = h >> BigInt(delta);\n  if (h >= n) h -= n;\n  return h;\n}\n\nclass HmacDrbg {\n  constructor() {\n    this.v = new Uint8Array(32).fill(1);\n    this.k = new Uint8Array(32).fill(0);\n    this.counter = 0;\n  }\n\n  hmac() {\n    for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      values[_key2] = arguments[_key2];\n    }\n\n    return utils.hmacSha256(this.k, ...values);\n  }\n\n  hmacSync() {\n    if (typeof utils.hmacSha256Sync !== 'function') throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\n\n    for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      values[_key3] = arguments[_key3];\n    }\n\n    const res = utils.hmacSha256Sync(this.k, ...values);\n    if (res instanceof Promise) throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\n    return res;\n  }\n\n  incr() {\n    if (this.counter >= 1000) {\n      throw new Error('Tried 1,000 k values for sign(), all were invalid');\n    }\n\n    this.counter += 1;\n  }\n\n  async reseed() {\n    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n    this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n    this.v = await this.hmac(this.v);\n    if (seed.length === 0) return;\n    this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n    this.v = await this.hmac(this.v);\n  }\n\n  reseedSync() {\n    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n    this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n    this.v = this.hmacSync(this.v);\n    if (seed.length === 0) return;\n    this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n    this.v = this.hmacSync(this.v);\n  }\n\n  async generate() {\n    this.incr();\n    this.v = await this.hmac(this.v);\n    return this.v;\n  }\n\n  generateSync() {\n    this.incr();\n    this.v = this.hmacSync(this.v);\n    return this.v;\n  }\n\n}\n\nfunction isWithinCurveOrder(num) {\n  return _0n < num && num < CURVE.n;\n}\n\nfunction isValidFieldElement(num) {\n  return _0n < num && num < CURVE.P;\n}\n\nfunction kmdToSig(kBytes, m, d) {\n  const k = bytesToNumber(kBytes);\n  if (!isWithinCurveOrder(k)) return;\n  const {\n    n\n  } = CURVE;\n  const q = Point.BASE.multiply(k);\n  const r = mod(q.x, n);\n  if (r === _0n) return;\n  const s = mod(invert(k, n) * mod(m + d * r, n), n);\n  if (s === _0n) return;\n  const sig = new Signature(r, s);\n  const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n  return {\n    sig,\n    recovery\n  };\n}\n\nfunction normalizePrivateKey(key) {\n  let num;\n\n  if (typeof key === 'bigint') {\n    num = key;\n  } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n    num = BigInt(key);\n  } else if (typeof key === 'string') {\n    if (key.length !== 64) throw new Error('Expected 32 bytes of private key');\n    num = hexToNumber(key);\n  } else if (isUint8a(key)) {\n    if (key.length !== 32) throw new Error('Expected 32 bytes of private key');\n    num = bytesToNumber(key);\n  } else {\n    throw new TypeError('Expected valid private key');\n  }\n\n  if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');\n  return num;\n}\n\nfunction normalizePublicKey(publicKey) {\n  if (publicKey instanceof Point) {\n    publicKey.assertValidity();\n    return publicKey;\n  } else {\n    return Point.fromHex(publicKey);\n  }\n}\n\nfunction normalizeSignature(signature) {\n  if (signature instanceof Signature) {\n    signature.assertValidity();\n    return signature;\n  }\n\n  try {\n    return Signature.fromDER(signature);\n  } catch (error) {\n    return Signature.fromCompact(signature);\n  }\n}\n\nexport function getPublicKey(privateKey) {\n  let isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery) {\n  let isCompressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\n\nfunction isPub(item) {\n  const arr = isUint8a(item);\n  const str = typeof item === 'string';\n  const len = (arr || str) && item.length;\n  if (arr) return len === 33 || len === 65;\n  if (str) return len === 66 || len === 130;\n  if (item instanceof Point) return true;\n  return false;\n}\n\nexport function getSharedSecret(privateA, publicB) {\n  let isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (isPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');\n  if (!isPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');\n  const b = normalizePublicKey(publicB);\n  b.assertValidity();\n  return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\n\nfunction bits2int(bytes) {\n  const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;\n  return bytesToNumber(slice);\n}\n\nfunction bits2octets(bytes) {\n  const z1 = bits2int(bytes);\n  const z2 = mod(z1, CURVE.n);\n  return int2octets(z2 < _0n ? z1 : z2);\n}\n\nfunction int2octets(num) {\n  if (typeof num !== 'bigint') throw new Error('Expected bigint');\n  const hex = numTo32bStr(num);\n  return hexToBytes(hex);\n}\n\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n  if (msgHash == null) throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n  const h1 = ensureBytes(msgHash);\n  const d = normalizePrivateKey(privateKey);\n  const seedArgs = [int2octets(d), bits2octets(h1)];\n\n  if (extraEntropy != null) {\n    if (extraEntropy === true) extraEntropy = utils.randomBytes(32);\n    const e = ensureBytes(extraEntropy);\n    if (e.length !== 32) throw new Error('sign: Expected 32 bytes of extra data');\n    seedArgs.push(e);\n  }\n\n  const seed = concatBytes(...seedArgs);\n  const m = bits2int(h1);\n  return {\n    seed,\n    m,\n    d\n  };\n}\n\nfunction finalizeSig(recSig, opts) {\n  let {\n    sig,\n    recovery\n  } = recSig;\n  const {\n    canonical,\n    der,\n    recovered\n  } = Object.assign({\n    canonical: true,\n    der: true\n  }, opts);\n\n  if (canonical && sig.hasHighS()) {\n    sig = sig.normalizeS();\n    recovery ^= 1;\n  }\n\n  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n  return recovered ? [hashed, recovery] : hashed;\n}\n\nasync function sign(msgHash, privKey) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    seed,\n    m,\n    d\n  } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n  let sig;\n  const drbg = new HmacDrbg();\n  await drbg.reseed(seed);\n\n  while (!(sig = kmdToSig(await drbg.generate(), m, d))) await drbg.reseed();\n\n  return finalizeSig(sig, opts);\n}\n\nfunction signSync(msgHash, privKey) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    seed,\n    m,\n    d\n  } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n  let sig;\n  const drbg = new HmacDrbg();\n  drbg.reseedSync(seed);\n\n  while (!(sig = kmdToSig(drbg.generateSync(), m, d))) drbg.reseedSync();\n\n  return finalizeSig(sig, opts);\n}\n\nexport { sign, signSync };\nconst vopts = {\n  strict: true\n};\nexport function verify(signature, msgHash, publicKey) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : vopts;\n  let sig;\n\n  try {\n    sig = normalizeSignature(signature);\n    msgHash = ensureBytes(msgHash);\n  } catch (error) {\n    return false;\n  }\n\n  const {\n    r,\n    s\n  } = sig;\n  if (opts.strict && sig.hasHighS()) return false;\n  const h = truncateHash(msgHash);\n  if (h === _0n) return false;\n  let P;\n\n  try {\n    P = normalizePublicKey(publicKey);\n  } catch (error) {\n    return false;\n  }\n\n  const {\n    n\n  } = CURVE;\n  const sinv = invert(s, n);\n  const u1 = mod(h * sinv, n);\n  const u2 = mod(r * sinv, n);\n  const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n  if (!R) return false;\n  const v = mod(R.x, n);\n  return v === r;\n}\n\nfunction finalizeSchnorrChallenge(ch) {\n  return mod(bytesToNumber(ch), CURVE.n);\n}\n\nfunction hasEvenY(point) {\n  return (point.y & _1n) === _0n;\n}\n\nclass SchnorrSignature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex);\n    if (bytes.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n    const r = bytesToNumber(bytes.subarray(0, 32));\n    const s = bytesToNumber(bytes.subarray(32, 64));\n    return new SchnorrSignature(r, s);\n  }\n\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error('Invalid signature');\n  }\n\n  toHex() {\n    return numTo32bStr(this.r) + numTo32bStr(this.s);\n  }\n\n  toRawBytes() {\n    return hexToBytes(this.toHex());\n  }\n\n}\n\nfunction schnorrGetPublicKey(privateKey) {\n  return Point.fromPrivateKey(privateKey).toRawX();\n}\n\nfunction initSchnorrSigArgs(message, privateKey, auxRand) {\n  if (message == null) throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n  const m = ensureBytes(message);\n  const d0 = normalizePrivateKey(privateKey);\n  const rand = ensureBytes(auxRand);\n  if (rand.length !== 32) throw new TypeError('sign: Expected 32 bytes of aux randomness');\n  const P = Point.fromPrivateKey(d0);\n  const px = P.toRawX();\n  const d = hasEvenY(P) ? d0 : CURVE.n - d0;\n  return {\n    m,\n    P,\n    px,\n    d,\n    rand\n  };\n}\n\nfunction initSchnorrNonce(d, t0h) {\n  return numTo32b(d ^ bytesToNumber(t0h));\n}\n\nfunction finalizeSchnorrNonce(k0h) {\n  const k0 = mod(bytesToNumber(k0h), CURVE.n);\n  if (k0 === _0n) throw new Error('sign: Creation of signature failed. k is zero');\n  const R = Point.fromPrivateKey(k0);\n  const rx = R.toRawX();\n  const k = hasEvenY(R) ? k0 : CURVE.n - k0;\n  return {\n    R,\n    rx,\n    k\n  };\n}\n\nfunction finalizeSchnorrSig(R, k, e, d) {\n  return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n}\n\nasync function schnorrSign(message, privateKey) {\n  let auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : utils.randomBytes();\n  const {\n    m,\n    px,\n    d,\n    rand\n  } = initSchnorrSigArgs(message, privateKey, auxRand);\n  const t = initSchnorrNonce(d, await utils.taggedHash(TAGS.aux, rand));\n  const {\n    R,\n    rx,\n    k\n  } = finalizeSchnorrNonce(await utils.taggedHash(TAGS.nonce, t, px, m));\n  const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, rx, px, m));\n  const sig = finalizeSchnorrSig(R, k, e, d);\n  const isValid = await schnorrVerify(sig, m, px);\n  if (!isValid) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\nfunction schnorrSignSync(message, privateKey) {\n  let auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : utils.randomBytes();\n  const {\n    m,\n    px,\n    d,\n    rand\n  } = initSchnorrSigArgs(message, privateKey, auxRand);\n  const t = initSchnorrNonce(d, utils.taggedHashSync(TAGS.aux, rand));\n  const {\n    R,\n    rx,\n    k\n  } = finalizeSchnorrNonce(utils.taggedHashSync(TAGS.nonce, t, px, m));\n  const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, rx, px, m));\n  const sig = finalizeSchnorrSig(R, k, e, d);\n  const isValid = schnorrVerifySync(sig, m, px);\n  if (!isValid) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\nfunction initSchnorrVerify(signature, message, publicKey) {\n  const raw = signature instanceof SchnorrSignature;\n  const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n  if (raw) sig.assertValidity();\n  return { ...sig,\n    m: ensureBytes(message),\n    P: normalizePublicKey(publicKey)\n  };\n}\n\nfunction finalizeSchnorrVerify(r, P, s, e) {\n  const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n  if (!R || !hasEvenY(R) || R.x !== r) return false;\n  return true;\n}\n\nasync function schnorrVerify(signature, message, publicKey) {\n  try {\n    const {\n      r,\n      s,\n      m,\n      P\n    } = initSchnorrVerify(signature, message, publicKey);\n    const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n    return finalizeSchnorrVerify(r, P, s, e);\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction schnorrVerifySync(signature, message, publicKey) {\n  try {\n    const {\n      r,\n      s,\n      m,\n      P\n    } = initSchnorrVerify(signature, message, publicKey);\n    const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n    return finalizeSchnorrVerify(r, P, s, e);\n  } catch (error) {\n    return false;\n  }\n}\n\nexport const schnorr = {\n  Signature: SchnorrSignature,\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  signSync: schnorrSignSync,\n  verifySync: schnorrVerifySync\n};\n\nPoint.BASE._setWindowSize(8);\n\nconst crypto = {\n  node: nodeCrypto,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\nconst TAGS = {\n  challenge: 'BIP0340/challenge',\n  aux: 'BIP0340/aux',\n  nonce: 'BIP0340/nonce'\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n  isValidPrivateKey(privateKey) {\n    try {\n      normalizePrivateKey(privateKey);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  },\n\n  privateAdd: (privateKey, tweak) => {\n    const p = normalizePrivateKey(privateKey);\n    const t = bytesToNumber(ensureBytes(tweak));\n    return numTo32b(mod(p + t, CURVE.n));\n  },\n  privateNegate: privateKey => {\n    const p = normalizePrivateKey(privateKey);\n    return numTo32b(CURVE.n - p);\n  },\n  pointAddScalar: (p, tweak, isCompressed) => {\n    const P = Point.fromHex(p);\n    const t = bytesToNumber(ensureBytes(tweak));\n    const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);\n    if (!Q) throw new Error('Tweaked point at infinity');\n    return Q.toRawBytes(isCompressed);\n  },\n  pointMultiply: (p, tweak, isCompressed) => {\n    const P = Point.fromHex(p);\n    const t = bytesToNumber(ensureBytes(tweak));\n    return P.multiply(t).toRawBytes(isCompressed);\n  },\n  hashToPrivateKey: hash => {\n    hash = ensureBytes(hash);\n    if (hash.length < 40 || hash.length > 1024) throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n\n    const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n\n    return numTo32b(num);\n  },\n  randomBytes: function () {\n    let bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      const {\n        randomBytes\n      } = crypto.node;\n      return Uint8Array.from(randomBytes(bytesLength));\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: () => {\n    return utils.hashToPrivateKey(utils.randomBytes(40));\n  },\n  bytesToHex,\n  hexToBytes,\n  concatBytes,\n  mod,\n  invert,\n  sha256: async function () {\n    for (var _len4 = arguments.length, messages = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      messages[_key4] = arguments[_key4];\n    }\n\n    if (crypto.web) {\n      const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n      return new Uint8Array(buffer);\n    } else if (crypto.node) {\n      const {\n        createHash\n      } = crypto.node;\n      const hash = createHash('sha256');\n      messages.forEach(m => hash.update(m));\n      return Uint8Array.from(hash.digest());\n    } else {\n      throw new Error(\"The environment doesn't have sha256 function\");\n    }\n  },\n  hmacSha256: async function (key) {\n    for (var _len5 = arguments.length, messages = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      messages[_key5 - 1] = arguments[_key5];\n    }\n\n    if (crypto.web) {\n      const ckey = await crypto.web.subtle.importKey('raw', key, {\n        name: 'HMAC',\n        hash: {\n          name: 'SHA-256'\n        }\n      }, false, ['sign']);\n      const message = concatBytes(...messages);\n      const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n      return new Uint8Array(buffer);\n    } else if (crypto.node) {\n      const {\n        createHmac\n      } = crypto.node;\n      const hash = createHmac('sha256', key);\n      messages.forEach(m => hash.update(m));\n      return Uint8Array.from(hash.digest());\n    } else {\n      throw new Error(\"The environment doesn't have hmac-sha256 function\");\n    }\n  },\n  sha256Sync: undefined,\n  hmacSha256Sync: undefined,\n  taggedHash: async function (tag) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n\n    if (tagP === undefined) {\n      const tagH = await utils.sha256(Uint8Array.from(tag, c => c.charCodeAt(0)));\n      tagP = concatBytes(tagH, tagH);\n      TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n\n    for (var _len6 = arguments.length, messages = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      messages[_key6 - 1] = arguments[_key6];\n    }\n\n    return utils.sha256(tagP, ...messages);\n  },\n  taggedHashSync: function (tag) {\n    if (typeof utils.sha256Sync !== 'function') throw new Error('utils.sha256Sync is undefined, you need to set it');\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n\n    if (tagP === undefined) {\n      const tagH = utils.sha256Sync(Uint8Array.from(tag, c => c.charCodeAt(0)));\n      tagP = concatBytes(tagH, tagH);\n      TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n\n    for (var _len7 = arguments.length, messages = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      messages[_key7 - 1] = arguments[_key7];\n    }\n\n    return utils.sha256Sync(tagP, ...messages);\n  },\n\n  precompute() {\n    let windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n    const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n\n    cached._setWindowSize(windowSize);\n\n    cached.multiply(_3n);\n    return cached;\n  }\n\n};","map":{"version":3,"names":["nodeCrypto","_0n","BigInt","_1n","_2n","_3n","_8n","POW_2_256","CURVE","a","b","P","n","h","Gx","Gy","beta","weistrass","x","x2","mod","x3","USE_ENDOMORPHISM","JacobianPoint","constructor","y","z","fromAffine","p","Point","TypeError","toAffineBatch","points","toInv","invertBatch","map","i","toAffine","normalizeZ","equals","other","X1","Y1","Z1","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","negate","double","A","B","C","D","E","F","X3","Y3","Z3","add","H","r","ZERO","HH","HHH","V","subtract","multiplyUnsafe","scalar","normalizeScalar","G","BASE","P0","d","k1neg","k1","k2neg","k2","splitScalarEndo","k1p","k2p","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","_WINDOW_SIZE","Error","precomputes","pointPrecomputes","get","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","pr","cached","Math","abs","multiply","point","fake","f1p","f2p","invZ","invert","iz1","iz2","iz3","ax","ay","zz","WeakMap","_setWindowSize","delete","fromCompressedHex","bytes","isShort","length","bytesToNumber","subarray","isValidFieldElement","y2","sqrtMod","isYOdd","isFirstByteOdd","assertValidity","fromUncompressedHex","fromHex","hex","ensureBytes","len","header","fromPrivateKey","privateKey","normalizePrivateKey","fromSignature","msgHash","signature","recovery","truncateHash","s","normalizeSignature","prefix","R","numTo32bStr","rinv","u1","u2","Q","multiplyAndAddUnsafe","toRawBytes","isCompressed","hexToBytes","toHex","toHexX","slice","toRawX","msg","left","right","aP","bQ","sum","undefined","sliceDER","parseInt","parseDERInt","data","bytesToHex","res","parseDERSignature","sBytes","rBytesLeft","Signature","fromCompact","arr","isUint8a","name","str","hexToNumber","fromDER","isWithinCurveOrder","hasHighS","HALF","normalizeS","toDERRawBytes","toDERHex","sHex","numberToHexUnpadded","rHex","rLen","sLen","toCompactRawBytes","toCompactHex","concatBytes","arrays","every","reduce","result","Uint8Array","pad","hexes","Array","from","v","toString","padStart","uint8a","num","numTo32b","array","j","hexByte","byte","isNaN","isSafeInteger","pow2","power","_6n","_11n","_22n","_23n","_44n","_88n","b2","b3","b6","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","number","modulo","u","q","m","gcd","nums","scratch","lastMultiplied","acc","inverted","reduceRight","divNearest","POW_2_128","k","a1","b1","a2","c1","c2","hash","byteLength","delta","HmacDrbg","fill","counter","hmac","values","utils","hmacSha256","hmacSync","hmacSha256Sync","Promise","incr","reseed","seed","reseedSync","generate","generateSync","kmdToSig","kBytes","sig","key","normalizePublicKey","publicKey","error","getPublicKey","recoverPublicKey","isPub","item","getSharedSecret","privateA","publicB","bits2int","bits2octets","z1","z2","int2octets","initSigArgs","extraEntropy","h1","seedArgs","randomBytes","e","finalizeSig","recSig","opts","canonical","der","recovered","Object","assign","hashed","sign","privKey","drbg","signSync","vopts","strict","verify","sinv","finalizeSchnorrChallenge","ch","hasEvenY","SchnorrSignature","schnorrGetPublicKey","initSchnorrSigArgs","message","auxRand","d0","rand","px","initSchnorrNonce","t0h","finalizeSchnorrNonce","k0h","k0","rx","finalizeSchnorrSig","schnorrSign","t","taggedHash","TAGS","aux","nonce","challenge","isValid","schnorrVerify","schnorrSignSync","taggedHashSync","schnorrVerifySync","initSchnorrVerify","raw","finalizeSchnorrVerify","schnorr","verifySync","crypto","node","web","self","TAGGED_HASH_PREFIXES","isValidPrivateKey","privateAdd","tweak","privateNegate","pointAddScalar","pointMultiply","hashToPrivateKey","bytesLength","getRandomValues","randomPrivateKey","sha256","messages","buffer","subtle","digest","createHash","forEach","update","ckey","importKey","createHmac","sha256Sync","tag","tagP","tagH","c","charCodeAt","precompute"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/@noble/secp256k1/lib/esm/index.js"],"sourcesContent":["/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst POW_2_256 = _2n ** BigInt(256);\nconst CURVE = {\n    a: _0n,\n    b: BigInt(7),\n    P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),\n    n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n};\nexport { CURVE };\nfunction weistrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 ** _2n);\n        const Z2Z2 = mod(Z2 ** _2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 ** _2n);\n        const B = mod(Y1 ** _2n);\n        const C = mod(B ** _2n);\n        const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E ** _2n);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 ** _2n);\n        const Z2Z2 = mod(Z2 ** _2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H ** _2n);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r ** _2n - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar);\n        const G = JacobianPoint.BASE;\n        const P0 = JacobianPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.ZERO;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weistrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, 33));\n        const y = bytesToNumber(bytes.subarray(33, 65));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === 65 && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        msgHash = ensureBytes(msgHash);\n        const h = truncateHash(msgHash);\n        const { r, s } = normalizeSignature(signature);\n        if (recovery !== 0 && recovery !== 1) {\n            throw new Error('Cannot recover signature: invalid recovery bit');\n        }\n        if (h === _0n)\n            throw new Error('Cannot recover signature: msgHash cannot be 0');\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(r));\n        const { n } = CURVE;\n        const rinv = invert(r, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.y & _1n ? '03' : '02';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weistrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nexport class Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = isUint8a(hex);\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = isUint8a(hex);\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;\n    }\n    toDERRawBytes(isCompressed = false) {\n        return hexToBytes(this.toDERHex(isCompressed));\n    }\n    toDERHex(isCompressed = false) {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        if (isCompressed)\n            return sHex;\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const rLen = numberToHexUnpadded(rHex.length / 2);\n        const sLen = numberToHexUnpadded(sHex.length / 2);\n        const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every(isUint8a))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction isUint8a(bytes) {\n    return bytes instanceof Uint8Array;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction numTo32bStr(num) {\n    if (num > POW_2_256)\n        throw new Error('Expected number < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    return hexToBytes(numTo32bStr(num));\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    return pow2(t2, _2n);\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst POW_2_128 = _2n ** BigInt(128);\nfunction splitScalarEndo(k) {\n    const { n } = CURVE;\n    const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n    const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n    const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n    const b2 = a1;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\n    const k1neg = k1 > POW_2_128;\n    const k2neg = k2 > POW_2_128;\n    if (k1neg)\n        k1 = n - k1;\n    if (k2neg)\n        k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\n        throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction truncateHash(hash) {\n    const { n } = CURVE;\n    const byteLength = hash.length;\n    const delta = byteLength * 8 - 256;\n    let h = bytesToNumber(hash);\n    if (delta > 0)\n        h = h >> BigInt(delta);\n    if (h >= n)\n        h -= n;\n    return h;\n}\nclass HmacDrbg {\n    constructor() {\n        this.v = new Uint8Array(32).fill(1);\n        this.k = new Uint8Array(32).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        if (typeof utils.hmacSha256Sync !== 'function')\n            throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\n        const res = utils.hmacSha256Sync(this.k, ...values);\n        if (res instanceof Promise)\n            throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\n        return res;\n    }\n    incr() {\n        if (this.counter >= 1000) {\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        }\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        this.v = await this.hmac(this.v);\n        return this.v;\n    }\n    generateSync() {\n        this.incr();\n        this.v = this.hmacSync(this.v);\n        return this.v;\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d) {\n    const k = bytesToNumber(kBytes);\n    if (!isWithinCurveOrder(k))\n        return;\n    const { n } = CURVE;\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(invert(k, n) * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    const sig = new Signature(r, s);\n    const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 64)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (isUint8a(key)) {\n        if (key.length !== 32)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nexport function getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isPub(item) {\n    const arr = isUint8a(item);\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === 33 || len === 65;\n    if (str)\n        return len === 66 || len === 130;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    const hex = numTo32bStr(num);\n    return hexToBytes(hex);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(32);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== 32)\n            throw new Error('sign: Expected 32 bytes of extra data');\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    let { sig, recovery } = recSig;\n    const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    if (canonical && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    await drbg.reseed(seed);\n    while (!(sig = kmdToSig(await drbg.generate(), m, d)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    drbg.reseedSync(seed);\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = { strict: true };\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    if (h === _0n)\n        return false;\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction finalizeSchnorrChallenge(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nfunction hasEvenY(point) {\n    return (point.y & _1n) === _0n;\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nfunction initSchnorrSigArgs(message, privateKey, auxRand) {\n    if (message == null)\n        throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n    const m = ensureBytes(message);\n    const d0 = normalizePrivateKey(privateKey);\n    const rand = ensureBytes(auxRand);\n    if (rand.length !== 32)\n        throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    const P = Point.fromPrivateKey(d0);\n    const px = P.toRawX();\n    const d = hasEvenY(P) ? d0 : CURVE.n - d0;\n    return { m, P, px, d, rand };\n}\nfunction initSchnorrNonce(d, t0h) {\n    return numTo32b(d ^ bytesToNumber(t0h));\n}\nfunction finalizeSchnorrNonce(k0h) {\n    const k0 = mod(bytesToNumber(k0h), CURVE.n);\n    if (k0 === _0n)\n        throw new Error('sign: Creation of signature failed. k is zero');\n    const R = Point.fromPrivateKey(k0);\n    const rx = R.toRawX();\n    const k = hasEvenY(R) ? k0 : CURVE.n - k0;\n    return { R, rx, k };\n}\nfunction finalizeSchnorrSig(R, k, e, d) {\n    return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n}\nasync function schnorrSign(message, privateKey, auxRand = utils.randomBytes()) {\n    const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);\n    const t = initSchnorrNonce(d, await utils.taggedHash(TAGS.aux, rand));\n    const { R, rx, k } = finalizeSchnorrNonce(await utils.taggedHash(TAGS.nonce, t, px, m));\n    const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, rx, px, m));\n    const sig = finalizeSchnorrSig(R, k, e, d);\n    const isValid = await schnorrVerify(sig, m, px);\n    if (!isValid)\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\nfunction schnorrSignSync(message, privateKey, auxRand = utils.randomBytes()) {\n    const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);\n    const t = initSchnorrNonce(d, utils.taggedHashSync(TAGS.aux, rand));\n    const { R, rx, k } = finalizeSchnorrNonce(utils.taggedHashSync(TAGS.nonce, t, px, m));\n    const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, rx, px, m));\n    const sig = finalizeSchnorrSig(R, k, e, d);\n    const isValid = schnorrVerifySync(sig, m, px);\n    if (!isValid)\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !hasEvenY(R) || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nexport const schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    privateAdd: (privateKey, tweak) => {\n        const p = normalizePrivateKey(privateKey);\n        const t = bytesToNumber(ensureBytes(tweak));\n        return numTo32b(mod(p + t, CURVE.n));\n    },\n    privateNegate: (privateKey) => {\n        const p = normalizePrivateKey(privateKey);\n        return numTo32b(CURVE.n - p);\n    },\n    pointAddScalar: (p, tweak, isCompressed) => {\n        const P = Point.fromHex(p);\n        const t = bytesToNumber(ensureBytes(tweak));\n        const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);\n        if (!Q)\n            throw new Error('Tweaked point at infinity');\n        return Q.toRawBytes(isCompressed);\n    },\n    pointMultiply: (p, tweak, isCompressed) => {\n        const P = Point.fromHex(p);\n        const t = bytesToNumber(ensureBytes(tweak));\n        return P.multiply(t).toRawBytes(isCompressed);\n    },\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.hashToPrivateKey(utils.randomBytes(40));\n    },\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof utils.sha256Sync !== 'function')\n            throw new Error('utils.sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = utils.sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256Sync(tagP, ...messages);\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n};\n"],"mappings":"AAAA;AACA,OAAO,KAAKA,UAAZ,MAA4B,QAA5B;;AACA,MAAMC,GAAG,GAAGC,MAAM,CAAC,CAAD,CAAlB;;AACA,MAAMC,GAAG,GAAGD,MAAM,CAAC,CAAD,CAAlB;;AACA,MAAME,GAAG,GAAGF,MAAM,CAAC,CAAD,CAAlB;;AACA,MAAMG,GAAG,GAAGH,MAAM,CAAC,CAAD,CAAlB;;AACA,MAAMI,GAAG,GAAGJ,MAAM,CAAC,CAAD,CAAlB;;AACA,MAAMK,SAAS,GAAGH,GAAG,IAAIF,MAAM,CAAC,GAAD,CAA/B;;AACA,MAAMM,KAAK,GAAG;EACVC,CAAC,EAAER,GADO;EAEVS,CAAC,EAAER,MAAM,CAAC,CAAD,CAFC;EAGVS,CAAC,EAAEJ,SAAS,GAAGH,GAAG,IAAIF,MAAM,CAAC,EAAD,CAAzB,GAAgCA,MAAM,CAAC,GAAD,CAH/B;EAIVU,CAAC,EAAEL,SAAS,GAAGL,MAAM,CAAC,yCAAD,CAJX;EAKVW,CAAC,EAAEV,GALO;EAMVW,EAAE,EAAEZ,MAAM,CAAC,+EAAD,CANA;EAOVa,EAAE,EAAEb,MAAM,CAAC,+EAAD,CAPA;EAQVc,IAAI,EAAEd,MAAM,CAAC,oEAAD;AARF,CAAd;AAUA,SAASM,KAAT;;AACA,SAASS,SAAT,CAAmBC,CAAnB,EAAsB;EAClB,MAAM;IAAET,CAAF;IAAKC;EAAL,IAAWF,KAAjB;EACA,MAAMW,EAAE,GAAGC,GAAG,CAACF,CAAC,GAAGA,CAAL,CAAd;EACA,MAAMG,EAAE,GAAGD,GAAG,CAACD,EAAE,GAAGD,CAAN,CAAd;EACA,OAAOE,GAAG,CAACC,EAAE,GAAGZ,CAAC,GAAGS,CAAT,GAAaR,CAAd,CAAV;AACH;;AACD,MAAMY,gBAAgB,GAAGd,KAAK,CAACC,CAAN,KAAYR,GAArC;;AACA,MAAMsB,aAAN,CAAoB;EAChBC,WAAW,CAACN,CAAD,EAAIO,CAAJ,EAAOC,CAAP,EAAU;IACjB,KAAKR,CAAL,GAASA,CAAT;IACA,KAAKO,CAAL,GAASA,CAAT;IACA,KAAKC,CAAL,GAASA,CAAT;EACH;;EACgB,OAAVC,UAAU,CAACC,CAAD,EAAI;IACjB,IAAI,EAAEA,CAAC,YAAYC,KAAf,CAAJ,EAA2B;MACvB,MAAM,IAAIC,SAAJ,CAAc,0CAAd,CAAN;IACH;;IACD,OAAO,IAAIP,aAAJ,CAAkBK,CAAC,CAACV,CAApB,EAAuBU,CAAC,CAACH,CAAzB,EAA4BtB,GAA5B,CAAP;EACH;;EACmB,OAAb4B,aAAa,CAACC,MAAD,EAAS;IACzB,MAAMC,KAAK,GAAGC,WAAW,CAACF,MAAM,CAACG,GAAP,CAAYP,CAAD,IAAOA,CAAC,CAACF,CAApB,CAAD,CAAzB;IACA,OAAOM,MAAM,CAACG,GAAP,CAAW,CAACP,CAAD,EAAIQ,CAAJ,KAAUR,CAAC,CAACS,QAAF,CAAWJ,KAAK,CAACG,CAAD,CAAhB,CAArB,CAAP;EACH;;EACgB,OAAVE,UAAU,CAACN,MAAD,EAAS;IACtB,OAAOT,aAAa,CAACQ,aAAd,CAA4BC,MAA5B,EAAoCG,GAApC,CAAwCZ,aAAa,CAACI,UAAtD,CAAP;EACH;;EACDY,MAAM,CAACC,KAAD,EAAQ;IACV,IAAI,EAAEA,KAAK,YAAYjB,aAAnB,CAAJ,EACI,MAAM,IAAIO,SAAJ,CAAc,wBAAd,CAAN;IACJ,MAAM;MAAEZ,CAAC,EAAEuB,EAAL;MAAShB,CAAC,EAAEiB,EAAZ;MAAgBhB,CAAC,EAAEiB;IAAnB,IAA0B,IAAhC;IACA,MAAM;MAAEzB,CAAC,EAAE0B,EAAL;MAASnB,CAAC,EAAEoB,EAAZ;MAAgBnB,CAAC,EAAEoB;IAAnB,IAA0BN,KAAhC;IACA,MAAMO,IAAI,GAAG3B,GAAG,CAACuB,EAAE,IAAIvC,GAAP,CAAhB;IACA,MAAM4C,IAAI,GAAG5B,GAAG,CAAC0B,EAAE,IAAI1C,GAAP,CAAhB;IACA,MAAM6C,EAAE,GAAG7B,GAAG,CAACqB,EAAE,GAAGO,IAAN,CAAd;IACA,MAAME,EAAE,GAAG9B,GAAG,CAACwB,EAAE,GAAGG,IAAN,CAAd;IACA,MAAMI,EAAE,GAAG/B,GAAG,CAACA,GAAG,CAACsB,EAAE,GAAGI,EAAN,CAAH,GAAeE,IAAhB,CAAd;IACA,MAAMI,EAAE,GAAGhC,GAAG,CAACA,GAAG,CAACyB,EAAE,GAAGF,EAAN,CAAH,GAAeI,IAAhB,CAAd;IACA,OAAOE,EAAE,KAAKC,EAAP,IAAaC,EAAE,KAAKC,EAA3B;EACH;;EACDC,MAAM,GAAG;IACL,OAAO,IAAI9B,aAAJ,CAAkB,KAAKL,CAAvB,EAA0BE,GAAG,CAAC,CAAC,KAAKK,CAAP,CAA7B,EAAwC,KAAKC,CAA7C,CAAP;EACH;;EACD4B,MAAM,GAAG;IACL,MAAM;MAAEpC,CAAC,EAAEuB,EAAL;MAAShB,CAAC,EAAEiB,EAAZ;MAAgBhB,CAAC,EAAEiB;IAAnB,IAA0B,IAAhC;IACA,MAAMY,CAAC,GAAGnC,GAAG,CAACqB,EAAE,IAAIrC,GAAP,CAAb;IACA,MAAMoD,CAAC,GAAGpC,GAAG,CAACsB,EAAE,IAAItC,GAAP,CAAb;IACA,MAAMqD,CAAC,GAAGrC,GAAG,CAACoC,CAAC,IAAIpD,GAAN,CAAb;IACA,MAAMsD,CAAC,GAAGtC,GAAG,CAAChB,GAAG,IAAIgB,GAAG,CAAC,CAACqB,EAAE,GAAGe,CAAN,KAAYpD,GAAb,CAAH,GAAuBmD,CAAvB,GAA2BE,CAA/B,CAAJ,CAAb;IACA,MAAME,CAAC,GAAGvC,GAAG,CAACf,GAAG,GAAGkD,CAAP,CAAb;IACA,MAAMK,CAAC,GAAGxC,GAAG,CAACuC,CAAC,IAAIvD,GAAN,CAAb;IACA,MAAMyD,EAAE,GAAGzC,GAAG,CAACwC,CAAC,GAAGxD,GAAG,GAAGsD,CAAX,CAAd;IACA,MAAMI,EAAE,GAAG1C,GAAG,CAACuC,CAAC,IAAID,CAAC,GAAGG,EAAR,CAAD,GAAevD,GAAG,GAAGmD,CAAtB,CAAd;IACA,MAAMM,EAAE,GAAG3C,GAAG,CAAChB,GAAG,GAAGsC,EAAN,GAAWC,EAAZ,CAAd;IACA,OAAO,IAAIpB,aAAJ,CAAkBsC,EAAlB,EAAsBC,EAAtB,EAA0BC,EAA1B,CAAP;EACH;;EACDC,GAAG,CAACxB,KAAD,EAAQ;IACP,IAAI,EAAEA,KAAK,YAAYjB,aAAnB,CAAJ,EACI,MAAM,IAAIO,SAAJ,CAAc,wBAAd,CAAN;IACJ,MAAM;MAAEZ,CAAC,EAAEuB,EAAL;MAAShB,CAAC,EAAEiB,EAAZ;MAAgBhB,CAAC,EAAEiB;IAAnB,IAA0B,IAAhC;IACA,MAAM;MAAEzB,CAAC,EAAE0B,EAAL;MAASnB,CAAC,EAAEoB,EAAZ;MAAgBnB,CAAC,EAAEoB;IAAnB,IAA0BN,KAAhC;IACA,IAAII,EAAE,KAAK3C,GAAP,IAAc4C,EAAE,KAAK5C,GAAzB,EACI,OAAO,IAAP;IACJ,IAAIwC,EAAE,KAAKxC,GAAP,IAAcyC,EAAE,KAAKzC,GAAzB,EACI,OAAOuC,KAAP;IACJ,MAAMO,IAAI,GAAG3B,GAAG,CAACuB,EAAE,IAAIvC,GAAP,CAAhB;IACA,MAAM4C,IAAI,GAAG5B,GAAG,CAAC0B,EAAE,IAAI1C,GAAP,CAAhB;IACA,MAAM6C,EAAE,GAAG7B,GAAG,CAACqB,EAAE,GAAGO,IAAN,CAAd;IACA,MAAME,EAAE,GAAG9B,GAAG,CAACwB,EAAE,GAAGG,IAAN,CAAd;IACA,MAAMI,EAAE,GAAG/B,GAAG,CAACA,GAAG,CAACsB,EAAE,GAAGI,EAAN,CAAH,GAAeE,IAAhB,CAAd;IACA,MAAMI,EAAE,GAAGhC,GAAG,CAACA,GAAG,CAACyB,EAAE,GAAGF,EAAN,CAAH,GAAeI,IAAhB,CAAd;IACA,MAAMkB,CAAC,GAAG7C,GAAG,CAAC8B,EAAE,GAAGD,EAAN,CAAb;IACA,MAAMiB,CAAC,GAAG9C,GAAG,CAACgC,EAAE,GAAGD,EAAN,CAAb;;IACA,IAAIc,CAAC,KAAKhE,GAAV,EAAe;MACX,IAAIiE,CAAC,KAAKjE,GAAV,EAAe;QACX,OAAO,KAAKqD,MAAL,EAAP;MACH,CAFD,MAGK;QACD,OAAO/B,aAAa,CAAC4C,IAArB;MACH;IACJ;;IACD,MAAMC,EAAE,GAAGhD,GAAG,CAAC6C,CAAC,IAAI7D,GAAN,CAAd;IACA,MAAMiE,GAAG,GAAGjD,GAAG,CAAC6C,CAAC,GAAGG,EAAL,CAAf;IACA,MAAME,CAAC,GAAGlD,GAAG,CAAC6B,EAAE,GAAGmB,EAAN,CAAb;IACA,MAAMP,EAAE,GAAGzC,GAAG,CAAC8C,CAAC,IAAI9D,GAAL,GAAWiE,GAAX,GAAiBjE,GAAG,GAAGkE,CAAxB,CAAd;IACA,MAAMR,EAAE,GAAG1C,GAAG,CAAC8C,CAAC,IAAII,CAAC,GAAGT,EAAR,CAAD,GAAeV,EAAE,GAAGkB,GAArB,CAAd;IACA,MAAMN,EAAE,GAAG3C,GAAG,CAACuB,EAAE,GAAGG,EAAL,GAAUmB,CAAX,CAAd;IACA,OAAO,IAAI1C,aAAJ,CAAkBsC,EAAlB,EAAsBC,EAAtB,EAA0BC,EAA1B,CAAP;EACH;;EACDQ,QAAQ,CAAC/B,KAAD,EAAQ;IACZ,OAAO,KAAKwB,GAAL,CAASxB,KAAK,CAACa,MAAN,EAAT,CAAP;EACH;;EACDmB,cAAc,CAACC,MAAD,EAAS;IACnB,IAAI7D,CAAC,GAAG8D,eAAe,CAACD,MAAD,CAAvB;IACA,MAAME,CAAC,GAAGpD,aAAa,CAACqD,IAAxB;IACA,MAAMC,EAAE,GAAGtD,aAAa,CAAC4C,IAAzB;IACA,IAAIvD,CAAC,KAAKX,GAAV,EACI,OAAO4E,EAAP;IACJ,IAAIjE,CAAC,KAAKT,GAAV,EACI,OAAO,IAAP;;IACJ,IAAI,CAACmB,gBAAL,EAAuB;MACnB,IAAIM,CAAC,GAAGiD,EAAR;MACA,IAAIC,CAAC,GAAG,IAAR;;MACA,OAAOlE,CAAC,GAAGX,GAAX,EAAgB;QACZ,IAAIW,CAAC,GAAGT,GAAR,EACIyB,CAAC,GAAGA,CAAC,CAACoC,GAAF,CAAMc,CAAN,CAAJ;QACJA,CAAC,GAAGA,CAAC,CAACxB,MAAF,EAAJ;QACA1C,CAAC,KAAKT,GAAN;MACH;;MACD,OAAOyB,CAAP;IACH;;IACD,IAAI;MAAEmD,KAAF;MAASC,EAAT;MAAaC,KAAb;MAAoBC;IAApB,IAA2BC,eAAe,CAACvE,CAAD,CAA9C;IACA,IAAIwE,GAAG,GAAGP,EAAV;IACA,IAAIQ,GAAG,GAAGR,EAAV;IACA,IAAIC,CAAC,GAAG,IAAR;;IACA,OAAOE,EAAE,GAAG/E,GAAL,IAAYiF,EAAE,GAAGjF,GAAxB,EAA6B;MACzB,IAAI+E,EAAE,GAAG7E,GAAT,EACIiF,GAAG,GAAGA,GAAG,CAACpB,GAAJ,CAAQc,CAAR,CAAN;MACJ,IAAII,EAAE,GAAG/E,GAAT,EACIkF,GAAG,GAAGA,GAAG,CAACrB,GAAJ,CAAQc,CAAR,CAAN;MACJA,CAAC,GAAGA,CAAC,CAACxB,MAAF,EAAJ;MACA0B,EAAE,KAAK7E,GAAP;MACA+E,EAAE,KAAK/E,GAAP;IACH;;IACD,IAAI4E,KAAJ,EACIK,GAAG,GAAGA,GAAG,CAAC/B,MAAJ,EAAN;IACJ,IAAI4B,KAAJ,EACII,GAAG,GAAGA,GAAG,CAAChC,MAAJ,EAAN;IACJgC,GAAG,GAAG,IAAI9D,aAAJ,CAAkBH,GAAG,CAACiE,GAAG,CAACnE,CAAJ,GAAQV,KAAK,CAACQ,IAAf,CAArB,EAA2CqE,GAAG,CAAC5D,CAA/C,EAAkD4D,GAAG,CAAC3D,CAAtD,CAAN;IACA,OAAO0D,GAAG,CAACpB,GAAJ,CAAQqB,GAAR,CAAP;EACH;;EACDC,gBAAgB,CAACC,CAAD,EAAI;IAChB,MAAMC,OAAO,GAAGlE,gBAAgB,GAAG,MAAMiE,CAAN,GAAU,CAAb,GAAiB,MAAMA,CAAN,GAAU,CAA3D;IACA,MAAMvD,MAAM,GAAG,EAAf;IACA,IAAIJ,CAAC,GAAG,IAAR;IACA,IAAI6D,IAAI,GAAG7D,CAAX;;IACA,KAAK,IAAI8D,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGF,OAA9B,EAAuCE,MAAM,EAA7C,EAAiD;MAC7CD,IAAI,GAAG7D,CAAP;MACAI,MAAM,CAAC2D,IAAP,CAAYF,IAAZ;;MACA,KAAK,IAAIrD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,MAAMmD,CAAC,GAAG,CAAV,CAApB,EAAkCnD,CAAC,EAAnC,EAAuC;QACnCqD,IAAI,GAAGA,IAAI,CAACzB,GAAL,CAASpC,CAAT,CAAP;QACAI,MAAM,CAAC2D,IAAP,CAAYF,IAAZ;MACH;;MACD7D,CAAC,GAAG6D,IAAI,CAACnC,MAAL,EAAJ;IACH;;IACD,OAAOtB,MAAP;EACH;;EACD4D,IAAI,CAAChF,CAAD,EAAIiF,WAAJ,EAAiB;IACjB,IAAI,CAACA,WAAD,IAAgB,KAAKtD,MAAL,CAAYhB,aAAa,CAACqD,IAA1B,CAApB,EACIiB,WAAW,GAAGhE,KAAK,CAAC+C,IAApB;IACJ,MAAMW,CAAC,GAAIM,WAAW,IAAIA,WAAW,CAACC,YAA5B,IAA6C,CAAvD;;IACA,IAAI,MAAMP,CAAV,EAAa;MACT,MAAM,IAAIQ,KAAJ,CAAU,+DAAV,CAAN;IACH;;IACD,IAAIC,WAAW,GAAGH,WAAW,IAAII,gBAAgB,CAACC,GAAjB,CAAqBL,WAArB,CAAjC;;IACA,IAAI,CAACG,WAAL,EAAkB;MACdA,WAAW,GAAG,KAAKV,gBAAL,CAAsBC,CAAtB,CAAd;;MACA,IAAIM,WAAW,IAAIN,CAAC,KAAK,CAAzB,EAA4B;QACxBS,WAAW,GAAGzE,aAAa,CAACe,UAAd,CAAyB0D,WAAzB,CAAd;QACAC,gBAAgB,CAACE,GAAjB,CAAqBN,WAArB,EAAkCG,WAAlC;MACH;IACJ;;IACD,IAAIpE,CAAC,GAAGL,aAAa,CAAC4C,IAAtB;IACA,IAAIiC,CAAC,GAAG7E,aAAa,CAAC4C,IAAtB;IACA,MAAMqB,OAAO,GAAG,KAAKlE,gBAAgB,GAAG,MAAMiE,CAAT,GAAa,MAAMA,CAAxC,CAAhB;IACA,MAAMc,UAAU,GAAG,MAAMd,CAAC,GAAG,CAAV,CAAnB;IACA,MAAMe,IAAI,GAAGpG,MAAM,CAAC,KAAKqF,CAAL,GAAS,CAAV,CAAnB;IACA,MAAMgB,SAAS,GAAG,KAAKhB,CAAvB;IACA,MAAMiB,OAAO,GAAGtG,MAAM,CAACqF,CAAD,CAAtB;;IACA,KAAK,IAAIG,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGF,OAA9B,EAAuCE,MAAM,EAA7C,EAAiD;MAC7C,MAAMe,MAAM,GAAGf,MAAM,GAAGW,UAAxB;MACA,IAAIK,KAAK,GAAGC,MAAM,CAAC/F,CAAC,GAAG0F,IAAL,CAAlB;MACA1F,CAAC,KAAK4F,OAAN;;MACA,IAAIE,KAAK,GAAGL,UAAZ,EAAwB;QACpBK,KAAK,IAAIH,SAAT;QACA3F,CAAC,IAAIT,GAAL;MACH;;MACD,IAAIuG,KAAK,KAAK,CAAd,EAAiB;QACb,IAAIE,EAAE,GAAGZ,WAAW,CAACS,MAAD,CAApB;QACA,IAAIf,MAAM,GAAG,CAAb,EACIkB,EAAE,GAAGA,EAAE,CAACvD,MAAH,EAAL;QACJ+C,CAAC,GAAGA,CAAC,CAACpC,GAAF,CAAM4C,EAAN,CAAJ;MACH,CALD,MAMK;QACD,IAAIC,MAAM,GAAGb,WAAW,CAACS,MAAM,GAAGK,IAAI,CAACC,GAAL,CAASL,KAAT,CAAT,GAA2B,CAA5B,CAAxB;QACA,IAAIA,KAAK,GAAG,CAAZ,EACIG,MAAM,GAAGA,MAAM,CAACxD,MAAP,EAAT;QACJzB,CAAC,GAAGA,CAAC,CAACoC,GAAF,CAAM6C,MAAN,CAAJ;MACH;IACJ;;IACD,OAAO;MAAEjF,CAAF;MAAKwE;IAAL,CAAP;EACH;;EACDY,QAAQ,CAACvC,MAAD,EAASoB,WAAT,EAAsB;IAC1B,IAAIjF,CAAC,GAAG8D,eAAe,CAACD,MAAD,CAAvB;IACA,IAAIwC,KAAJ;IACA,IAAIC,IAAJ;;IACA,IAAI5F,gBAAJ,EAAsB;MAClB,MAAM;QAAEyD,KAAF;QAASC,EAAT;QAAaC,KAAb;QAAoBC;MAApB,IAA2BC,eAAe,CAACvE,CAAD,CAAhD;MACA,IAAI;QAAEgB,CAAC,EAAEwD,GAAL;QAAUgB,CAAC,EAAEe;MAAb,IAAqB,KAAKvB,IAAL,CAAUZ,EAAV,EAAca,WAAd,CAAzB;MACA,IAAI;QAAEjE,CAAC,EAAEyD,GAAL;QAAUe,CAAC,EAAEgB;MAAb,IAAqB,KAAKxB,IAAL,CAAUV,EAAV,EAAcW,WAAd,CAAzB;MACA,IAAId,KAAJ,EACIK,GAAG,GAAGA,GAAG,CAAC/B,MAAJ,EAAN;MACJ,IAAI4B,KAAJ,EACII,GAAG,GAAGA,GAAG,CAAChC,MAAJ,EAAN;MACJgC,GAAG,GAAG,IAAI9D,aAAJ,CAAkBH,GAAG,CAACiE,GAAG,CAACnE,CAAJ,GAAQV,KAAK,CAACQ,IAAf,CAArB,EAA2CqE,GAAG,CAAC5D,CAA/C,EAAkD4D,GAAG,CAAC3D,CAAtD,CAAN;MACAuF,KAAK,GAAG7B,GAAG,CAACpB,GAAJ,CAAQqB,GAAR,CAAR;MACA6B,IAAI,GAAGC,GAAG,CAACnD,GAAJ,CAAQoD,GAAR,CAAP;IACH,CAXD,MAYK;MACD,MAAM;QAAExF,CAAF;QAAKwE;MAAL,IAAW,KAAKR,IAAL,CAAUhF,CAAV,EAAaiF,WAAb,CAAjB;MACAoB,KAAK,GAAGrF,CAAR;MACAsF,IAAI,GAAGd,CAAP;IACH;;IACD,OAAO7E,aAAa,CAACe,UAAd,CAAyB,CAAC2E,KAAD,EAAQC,IAAR,CAAzB,EAAwC,CAAxC,CAAP;EACH;;EACD7E,QAAQ,GAAwB;IAAA,IAAvBgF,IAAuB,uEAAhBC,MAAM,CAAC,KAAK5F,CAAN,CAAU;IAC5B,MAAM;MAAER,CAAF;MAAKO,CAAL;MAAQC;IAAR,IAAc,IAApB;IACA,MAAM6F,GAAG,GAAGF,IAAZ;IACA,MAAMG,GAAG,GAAGpG,GAAG,CAACmG,GAAG,GAAGA,GAAP,CAAf;IACA,MAAME,GAAG,GAAGrG,GAAG,CAACoG,GAAG,GAAGD,GAAP,CAAf;IACA,MAAMG,EAAE,GAAGtG,GAAG,CAACF,CAAC,GAAGsG,GAAL,CAAd;IACA,MAAMG,EAAE,GAAGvG,GAAG,CAACK,CAAC,GAAGgG,GAAL,CAAd;IACA,MAAMG,EAAE,GAAGxG,GAAG,CAACM,CAAC,GAAG6F,GAAL,CAAd;IACA,IAAIK,EAAE,KAAKzH,GAAX,EACI,MAAM,IAAI4F,KAAJ,CAAU,kBAAV,CAAN;IACJ,OAAO,IAAIlE,KAAJ,CAAU6F,EAAV,EAAcC,EAAd,CAAP;EACH;;AA1Ne;;AA4NpBpG,aAAa,CAACqD,IAAd,GAAqB,IAAIrD,aAAJ,CAAkBf,KAAK,CAACM,EAAxB,EAA4BN,KAAK,CAACO,EAAlC,EAAsCZ,GAAtC,CAArB;AACAoB,aAAa,CAAC4C,IAAd,GAAqB,IAAI5C,aAAJ,CAAkBtB,GAAlB,EAAuBE,GAAvB,EAA4BF,GAA5B,CAArB;AACA,MAAMgG,gBAAgB,GAAG,IAAI4B,OAAJ,EAAzB;AACA,OAAO,MAAMhG,KAAN,CAAY;EACfL,WAAW,CAACN,CAAD,EAAIO,CAAJ,EAAO;IACd,KAAKP,CAAL,GAASA,CAAT;IACA,KAAKO,CAAL,GAASA,CAAT;EACH;;EACDqG,cAAc,CAACzB,UAAD,EAAa;IACvB,KAAKP,YAAL,GAAoBO,UAApB;IACAJ,gBAAgB,CAAC8B,MAAjB,CAAwB,IAAxB;EACH;;EACuB,OAAjBC,iBAAiB,CAACC,KAAD,EAAQ;IAC5B,MAAMC,OAAO,GAAGD,KAAK,CAACE,MAAN,KAAiB,EAAjC;IACA,MAAMjH,CAAC,GAAGkH,aAAa,CAACF,OAAO,GAAGD,KAAH,GAAWA,KAAK,CAACI,QAAN,CAAe,CAAf,CAAnB,CAAvB;IACA,IAAI,CAACC,mBAAmB,CAACpH,CAAD,CAAxB,EACI,MAAM,IAAI6E,KAAJ,CAAU,uBAAV,CAAN;IACJ,MAAMwC,EAAE,GAAGtH,SAAS,CAACC,CAAD,CAApB;IACA,IAAIO,CAAC,GAAG+G,OAAO,CAACD,EAAD,CAAf;IACA,MAAME,MAAM,GAAG,CAAChH,CAAC,GAAGtB,GAAL,MAAcA,GAA7B;;IACA,IAAI+H,OAAJ,EAAa;MACT,IAAIO,MAAJ,EACIhH,CAAC,GAAGL,GAAG,CAAC,CAACK,CAAF,CAAP;IACP,CAHD,MAIK;MACD,MAAMiH,cAAc,GAAG,CAACT,KAAK,CAAC,CAAD,CAAL,GAAW,CAAZ,MAAmB,CAA1C;MACA,IAAIS,cAAc,KAAKD,MAAvB,EACIhH,CAAC,GAAGL,GAAG,CAAC,CAACK,CAAF,CAAP;IACP;;IACD,MAAMwF,KAAK,GAAG,IAAIpF,KAAJ,CAAUX,CAAV,EAAaO,CAAb,CAAd;IACAwF,KAAK,CAAC0B,cAAN;IACA,OAAO1B,KAAP;EACH;;EACyB,OAAnB2B,mBAAmB,CAACX,KAAD,EAAQ;IAC9B,MAAM/G,CAAC,GAAGkH,aAAa,CAACH,KAAK,CAACI,QAAN,CAAe,CAAf,EAAkB,EAAlB,CAAD,CAAvB;IACA,MAAM5G,CAAC,GAAG2G,aAAa,CAACH,KAAK,CAACI,QAAN,CAAe,EAAf,EAAmB,EAAnB,CAAD,CAAvB;IACA,MAAMpB,KAAK,GAAG,IAAIpF,KAAJ,CAAUX,CAAV,EAAaO,CAAb,CAAd;IACAwF,KAAK,CAAC0B,cAAN;IACA,OAAO1B,KAAP;EACH;;EACa,OAAP4B,OAAO,CAACC,GAAD,EAAM;IAChB,MAAMb,KAAK,GAAGc,WAAW,CAACD,GAAD,CAAzB;IACA,MAAME,GAAG,GAAGf,KAAK,CAACE,MAAlB;IACA,MAAMc,MAAM,GAAGhB,KAAK,CAAC,CAAD,CAApB;;IACA,IAAIe,GAAG,KAAK,EAAR,IAAeA,GAAG,KAAK,EAAR,KAAeC,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,IAA7C,CAAnB,EAAwE;MACpE,OAAO,KAAKjB,iBAAL,CAAuBC,KAAvB,CAAP;IACH;;IACD,IAAIe,GAAG,KAAK,EAAR,IAAcC,MAAM,KAAK,IAA7B,EACI,OAAO,KAAKL,mBAAL,CAAyBX,KAAzB,CAAP;IACJ,MAAM,IAAIlC,KAAJ,CAAW,wGAAuGiD,GAAI,EAAtH,CAAN;EACH;;EACoB,OAAdE,cAAc,CAACC,UAAD,EAAa;IAC9B,OAAOtH,KAAK,CAAC+C,IAAN,CAAWoC,QAAX,CAAoBoC,mBAAmB,CAACD,UAAD,CAAvC,CAAP;EACH;;EACmB,OAAbE,aAAa,CAACC,OAAD,EAAUC,SAAV,EAAqBC,QAArB,EAA+B;IAC/CF,OAAO,GAAGP,WAAW,CAACO,OAAD,CAArB;IACA,MAAMzI,CAAC,GAAG4I,YAAY,CAACH,OAAD,CAAtB;IACA,MAAM;MAAEpF,CAAF;MAAKwF;IAAL,IAAWC,kBAAkB,CAACJ,SAAD,CAAnC;;IACA,IAAIC,QAAQ,KAAK,CAAb,IAAkBA,QAAQ,KAAK,CAAnC,EAAsC;MAClC,MAAM,IAAIzD,KAAJ,CAAU,gDAAV,CAAN;IACH;;IACD,IAAIlF,CAAC,KAAKZ,GAAV,EACI,MAAM,IAAI8F,KAAJ,CAAU,+CAAV,CAAN;IACJ,MAAM6D,MAAM,GAAGJ,QAAQ,GAAG,CAAX,GAAe,IAAf,GAAsB,IAArC;IACA,MAAMK,CAAC,GAAGhI,KAAK,CAACgH,OAAN,CAAce,MAAM,GAAGE,WAAW,CAAC5F,CAAD,CAAlC,CAAV;IACA,MAAM;MAAEtD;IAAF,IAAQJ,KAAd;IACA,MAAMuJ,IAAI,GAAGzC,MAAM,CAACpD,CAAD,EAAItD,CAAJ,CAAnB;IACA,MAAMoJ,EAAE,GAAG5I,GAAG,CAAC,CAACP,CAAD,GAAKkJ,IAAN,EAAYnJ,CAAZ,CAAd;IACA,MAAMqJ,EAAE,GAAG7I,GAAG,CAACsI,CAAC,GAAGK,IAAL,EAAWnJ,CAAX,CAAd;IACA,MAAMsJ,CAAC,GAAGrI,KAAK,CAAC+C,IAAN,CAAWuF,oBAAX,CAAgCN,CAAhC,EAAmCG,EAAnC,EAAuCC,EAAvC,CAAV;IACA,IAAI,CAACC,CAAL,EACI,MAAM,IAAInE,KAAJ,CAAU,6CAAV,CAAN;IACJmE,CAAC,CAACvB,cAAF;IACA,OAAOuB,CAAP;EACH;;EACDE,UAAU,GAAuB;IAAA,IAAtBC,YAAsB,uEAAP,KAAO;IAC7B,OAAOC,UAAU,CAAC,KAAKC,KAAL,CAAWF,YAAX,CAAD,CAAjB;EACH;;EACDE,KAAK,GAAuB;IAAA,IAAtBF,YAAsB,uEAAP,KAAO;IACxB,MAAMnJ,CAAC,GAAG4I,WAAW,CAAC,KAAK5I,CAAN,CAArB;;IACA,IAAImJ,YAAJ,EAAkB;MACd,MAAMT,MAAM,GAAG,KAAKnI,CAAL,GAAStB,GAAT,GAAe,IAAf,GAAsB,IAArC;MACA,OAAQ,GAAEyJ,MAAO,GAAE1I,CAAE,EAArB;IACH,CAHD,MAIK;MACD,OAAQ,KAAIA,CAAE,GAAE4I,WAAW,CAAC,KAAKrI,CAAN,CAAS,EAApC;IACH;EACJ;;EACD+I,MAAM,GAAG;IACL,OAAO,KAAKD,KAAL,CAAW,IAAX,EAAiBE,KAAjB,CAAuB,CAAvB,CAAP;EACH;;EACDC,MAAM,GAAG;IACL,OAAO,KAAKN,UAAL,CAAgB,IAAhB,EAAsBK,KAAtB,CAA4B,CAA5B,CAAP;EACH;;EACD9B,cAAc,GAAG;IACb,MAAMgC,GAAG,GAAG,gCAAZ;IACA,MAAM;MAAEzJ,CAAF;MAAKO;IAAL,IAAW,IAAjB;IACA,IAAI,CAAC6G,mBAAmB,CAACpH,CAAD,CAApB,IAA2B,CAACoH,mBAAmB,CAAC7G,CAAD,CAAnD,EACI,MAAM,IAAIsE,KAAJ,CAAU4E,GAAV,CAAN;IACJ,MAAMC,IAAI,GAAGxJ,GAAG,CAACK,CAAC,GAAGA,CAAL,CAAhB;IACA,MAAMoJ,KAAK,GAAG5J,SAAS,CAACC,CAAD,CAAvB;IACA,IAAIE,GAAG,CAACwJ,IAAI,GAAGC,KAAR,CAAH,KAAsB5K,GAA1B,EACI,MAAM,IAAI8F,KAAJ,CAAU4E,GAAV,CAAN;EACP;;EACDpI,MAAM,CAACC,KAAD,EAAQ;IACV,OAAO,KAAKtB,CAAL,KAAWsB,KAAK,CAACtB,CAAjB,IAAsB,KAAKO,CAAL,KAAWe,KAAK,CAACf,CAA9C;EACH;;EACD4B,MAAM,GAAG;IACL,OAAO,IAAIxB,KAAJ,CAAU,KAAKX,CAAf,EAAkBE,GAAG,CAAC,CAAC,KAAKK,CAAP,CAArB,CAAP;EACH;;EACD6B,MAAM,GAAG;IACL,OAAO/B,aAAa,CAACI,UAAd,CAAyB,IAAzB,EAA+B2B,MAA/B,GAAwCjB,QAAxC,EAAP;EACH;;EACD2B,GAAG,CAACxB,KAAD,EAAQ;IACP,OAAOjB,aAAa,CAACI,UAAd,CAAyB,IAAzB,EAA+BqC,GAA/B,CAAmCzC,aAAa,CAACI,UAAd,CAAyBa,KAAzB,CAAnC,EAAoEH,QAApE,EAAP;EACH;;EACDkC,QAAQ,CAAC/B,KAAD,EAAQ;IACZ,OAAO,KAAKwB,GAAL,CAASxB,KAAK,CAACa,MAAN,EAAT,CAAP;EACH;;EACD2D,QAAQ,CAACvC,MAAD,EAAS;IACb,OAAOlD,aAAa,CAACI,UAAd,CAAyB,IAAzB,EAA+BqF,QAA/B,CAAwCvC,MAAxC,EAAgD,IAAhD,EAAsDpC,QAAtD,EAAP;EACH;;EACD8H,oBAAoB,CAACD,CAAD,EAAIzJ,CAAJ,EAAOC,CAAP,EAAU;IAC1B,MAAMC,CAAC,GAAGY,aAAa,CAACI,UAAd,CAAyB,IAAzB,CAAV;IACA,MAAMmJ,EAAE,GAAGrK,CAAC,KAAKR,GAAN,IAAaQ,CAAC,KAAKN,GAAnB,IAA0B,SAAS0B,KAAK,CAAC+C,IAAzC,GAAgDjE,CAAC,CAAC6D,cAAF,CAAiB/D,CAAjB,CAAhD,GAAsEE,CAAC,CAACqG,QAAF,CAAWvG,CAAX,CAAjF;IACA,MAAMsK,EAAE,GAAGxJ,aAAa,CAACI,UAAd,CAAyBuI,CAAzB,EAA4B1F,cAA5B,CAA2C9D,CAA3C,CAAX;IACA,MAAMsK,GAAG,GAAGF,EAAE,CAAC9G,GAAH,CAAO+G,EAAP,CAAZ;IACA,OAAOC,GAAG,CAACzI,MAAJ,CAAWhB,aAAa,CAAC4C,IAAzB,IAAiC8G,SAAjC,GAA6CD,GAAG,CAAC3I,QAAJ,EAApD;EACH;;AA7Hc;AA+HnBR,KAAK,CAAC+C,IAAN,GAAa,IAAI/C,KAAJ,CAAUrB,KAAK,CAACM,EAAhB,EAAoBN,KAAK,CAACO,EAA1B,CAAb;AACAc,KAAK,CAACsC,IAAN,GAAa,IAAItC,KAAJ,CAAU5B,GAAV,EAAeA,GAAf,CAAb;;AACA,SAASiL,QAAT,CAAkBxB,CAAlB,EAAqB;EACjB,OAAO/C,MAAM,CAACwE,QAAP,CAAgBzB,CAAC,CAAC,CAAD,CAAjB,EAAsB,EAAtB,KAA6B,CAA7B,GAAiC,OAAOA,CAAxC,GAA4CA,CAAnD;AACH;;AACD,SAAS0B,WAAT,CAAqBC,IAArB,EAA2B;EACvB,IAAIA,IAAI,CAAClD,MAAL,GAAc,CAAd,IAAmBkD,IAAI,CAAC,CAAD,CAAJ,KAAY,IAAnC,EAAyC;IACrC,MAAM,IAAItF,KAAJ,CAAW,kCAAiCuF,UAAU,CAACD,IAAD,CAAO,EAA7D,CAAN;EACH;;EACD,MAAMrC,GAAG,GAAGqC,IAAI,CAAC,CAAD,CAAhB;EACA,MAAME,GAAG,GAAGF,IAAI,CAAChD,QAAL,CAAc,CAAd,EAAiBW,GAAG,GAAG,CAAvB,CAAZ;;EACA,IAAI,CAACA,GAAD,IAAQuC,GAAG,CAACpD,MAAJ,KAAea,GAA3B,EAAgC;IAC5B,MAAM,IAAIjD,KAAJ,CAAW,yCAAX,CAAN;EACH;;EACD,IAAIwF,GAAG,CAAC,CAAD,CAAH,KAAW,IAAX,IAAmBA,GAAG,CAAC,CAAD,CAAH,IAAU,IAAjC,EAAuC;IACnC,MAAM,IAAIxF,KAAJ,CAAU,4CAAV,CAAN;EACH;;EACD,OAAO;IAAEsF,IAAI,EAAEjD,aAAa,CAACmD,GAAD,CAArB;IAA4BX,IAAI,EAAES,IAAI,CAAChD,QAAL,CAAcW,GAAG,GAAG,CAApB;EAAlC,CAAP;AACH;;AACD,SAASwC,iBAAT,CAA2BH,IAA3B,EAAiC;EAC7B,IAAIA,IAAI,CAAClD,MAAL,GAAc,CAAd,IAAmBkD,IAAI,CAAC,CAAD,CAAJ,IAAW,IAAlC,EAAwC;IACpC,MAAM,IAAItF,KAAJ,CAAW,0BAAyBuF,UAAU,CAACD,IAAD,CAAO,EAArD,CAAN;EACH;;EACD,IAAIA,IAAI,CAAC,CAAD,CAAJ,KAAYA,IAAI,CAAClD,MAAL,GAAc,CAA9B,EAAiC;IAC7B,MAAM,IAAIpC,KAAJ,CAAU,qCAAV,CAAN;EACH;;EACD,MAAM;IAAEsF,IAAI,EAAEnH,CAAR;IAAW0G,IAAI,EAAEa;EAAjB,IAA4BL,WAAW,CAACC,IAAI,CAAChD,QAAL,CAAc,CAAd,CAAD,CAA7C;EACA,MAAM;IAAEgD,IAAI,EAAE3B,CAAR;IAAWkB,IAAI,EAAEc;EAAjB,IAAgCN,WAAW,CAACK,MAAD,CAAjD;;EACA,IAAIC,UAAU,CAACvD,MAAf,EAAuB;IACnB,MAAM,IAAIpC,KAAJ,CAAW,gDAA+CuF,UAAU,CAACI,UAAD,CAAa,EAAjF,CAAN;EACH;;EACD,OAAO;IAAExH,CAAF;IAAKwF;EAAL,CAAP;AACH;;AACD,OAAO,MAAMiC,SAAN,CAAgB;EACnBnK,WAAW,CAAC0C,CAAD,EAAIwF,CAAJ,EAAO;IACd,KAAKxF,CAAL,GAASA,CAAT;IACA,KAAKwF,CAAL,GAASA,CAAT;IACA,KAAKf,cAAL;EACH;;EACiB,OAAXiD,WAAW,CAAC9C,GAAD,EAAM;IACpB,MAAM+C,GAAG,GAAGC,QAAQ,CAAChD,GAAD,CAApB;IACA,MAAMiD,IAAI,GAAG,uBAAb;IACA,IAAI,OAAOjD,GAAP,KAAe,QAAf,IAA2B,CAAC+C,GAAhC,EACI,MAAM,IAAI/J,SAAJ,CAAe,GAAEiK,IAAK,iCAAtB,CAAN;IACJ,MAAMC,GAAG,GAAGH,GAAG,GAAGP,UAAU,CAACxC,GAAD,CAAb,GAAqBA,GAApC;IACA,IAAIkD,GAAG,CAAC7D,MAAJ,KAAe,GAAnB,EACI,MAAM,IAAIpC,KAAJ,CAAW,GAAEgG,IAAK,wBAAlB,CAAN;IACJ,OAAO,IAAIJ,SAAJ,CAAcM,WAAW,CAACD,GAAG,CAACvB,KAAJ,CAAU,CAAV,EAAa,EAAb,CAAD,CAAzB,EAA6CwB,WAAW,CAACD,GAAG,CAACvB,KAAJ,CAAU,EAAV,EAAc,GAAd,CAAD,CAAxD,CAAP;EACH;;EACa,OAAPyB,OAAO,CAACpD,GAAD,EAAM;IAChB,MAAM+C,GAAG,GAAGC,QAAQ,CAAChD,GAAD,CAApB;IACA,IAAI,OAAOA,GAAP,KAAe,QAAf,IAA2B,CAAC+C,GAAhC,EACI,MAAM,IAAI/J,SAAJ,CAAe,kDAAf,CAAN;IACJ,MAAM;MAAEoC,CAAF;MAAKwF;IAAL,IAAW8B,iBAAiB,CAACK,GAAG,GAAG/C,GAAH,GAASwB,UAAU,CAACxB,GAAD,CAAvB,CAAlC;IACA,OAAO,IAAI6C,SAAJ,CAAczH,CAAd,EAAiBwF,CAAjB,CAAP;EACH;;EACa,OAAPb,OAAO,CAACC,GAAD,EAAM;IAChB,OAAO,KAAKoD,OAAL,CAAapD,GAAb,CAAP;EACH;;EACDH,cAAc,GAAG;IACb,MAAM;MAAEzE,CAAF;MAAKwF;IAAL,IAAW,IAAjB;IACA,IAAI,CAACyC,kBAAkB,CAACjI,CAAD,CAAvB,EACI,MAAM,IAAI6B,KAAJ,CAAU,wCAAV,CAAN;IACJ,IAAI,CAACoG,kBAAkB,CAACzC,CAAD,CAAvB,EACI,MAAM,IAAI3D,KAAJ,CAAU,wCAAV,CAAN;EACP;;EACDqG,QAAQ,GAAG;IACP,MAAMC,IAAI,GAAG7L,KAAK,CAACI,CAAN,IAAWT,GAAxB;IACA,OAAO,KAAKuJ,CAAL,GAAS2C,IAAhB;EACH;;EACDC,UAAU,GAAG;IACT,OAAO,KAAKF,QAAL,KAAkB,IAAIT,SAAJ,CAAc,KAAKzH,CAAnB,EAAsB1D,KAAK,CAACI,CAAN,GAAU,KAAK8I,CAArC,CAAlB,GAA4D,IAAnE;EACH;;EACD6C,aAAa,GAAuB;IAAA,IAAtBlC,YAAsB,uEAAP,KAAO;IAChC,OAAOC,UAAU,CAAC,KAAKkC,QAAL,CAAcnC,YAAd,CAAD,CAAjB;EACH;;EACDmC,QAAQ,GAAuB;IAAA,IAAtBnC,YAAsB,uEAAP,KAAO;IAC3B,MAAMoC,IAAI,GAAGvB,QAAQ,CAACwB,mBAAmB,CAAC,KAAKhD,CAAN,CAApB,CAArB;IACA,IAAIW,YAAJ,EACI,OAAOoC,IAAP;IACJ,MAAME,IAAI,GAAGzB,QAAQ,CAACwB,mBAAmB,CAAC,KAAKxI,CAAN,CAApB,CAArB;IACA,MAAM0I,IAAI,GAAGF,mBAAmB,CAACC,IAAI,CAACxE,MAAL,GAAc,CAAf,CAAhC;IACA,MAAM0E,IAAI,GAAGH,mBAAmB,CAACD,IAAI,CAACtE,MAAL,GAAc,CAAf,CAAhC;IACA,MAAMA,MAAM,GAAGuE,mBAAmB,CAACC,IAAI,CAACxE,MAAL,GAAc,CAAd,GAAkBsE,IAAI,CAACtE,MAAL,GAAc,CAAhC,GAAoC,CAArC,CAAlC;IACA,OAAQ,KAAIA,MAAO,KAAIyE,IAAK,GAAED,IAAK,KAAIE,IAAK,GAAEJ,IAAK,EAAnD;EACH;;EACDrC,UAAU,GAAG;IACT,OAAO,KAAKmC,aAAL,EAAP;EACH;;EACDhC,KAAK,GAAG;IACJ,OAAO,KAAKiC,QAAL,EAAP;EACH;;EACDM,iBAAiB,GAAG;IAChB,OAAOxC,UAAU,CAAC,KAAKyC,YAAL,EAAD,CAAjB;EACH;;EACDA,YAAY,GAAG;IACX,OAAOjD,WAAW,CAAC,KAAK5F,CAAN,CAAX,GAAsB4F,WAAW,CAAC,KAAKJ,CAAN,CAAxC;EACH;;AAhEkB;;AAkEvB,SAASsD,WAAT,GAAgC;EAAA,kCAARC,MAAQ;IAARA,MAAQ;EAAA;;EAC5B,IAAI,CAACA,MAAM,CAACC,KAAP,CAAapB,QAAb,CAAL,EACI,MAAM,IAAI/F,KAAJ,CAAU,0BAAV,CAAN;EACJ,IAAIkH,MAAM,CAAC9E,MAAP,KAAkB,CAAtB,EACI,OAAO8E,MAAM,CAAC,CAAD,CAAb;EACJ,MAAM9E,MAAM,GAAG8E,MAAM,CAACE,MAAP,CAAc,CAAC1M,CAAD,EAAIoL,GAAJ,KAAYpL,CAAC,GAAGoL,GAAG,CAAC1D,MAAlC,EAA0C,CAA1C,CAAf;EACA,MAAMiF,MAAM,GAAG,IAAIC,UAAJ,CAAelF,MAAf,CAAf;;EACA,KAAK,IAAI/F,CAAC,GAAG,CAAR,EAAWkL,GAAG,GAAG,CAAtB,EAAyBlL,CAAC,GAAG6K,MAAM,CAAC9E,MAApC,EAA4C/F,CAAC,EAA7C,EAAiD;IAC7C,MAAMyJ,GAAG,GAAGoB,MAAM,CAAC7K,CAAD,CAAlB;IACAgL,MAAM,CAACjH,GAAP,CAAW0F,GAAX,EAAgByB,GAAhB;IACAA,GAAG,IAAIzB,GAAG,CAAC1D,MAAX;EACH;;EACD,OAAOiF,MAAP;AACH;;AACD,SAAStB,QAAT,CAAkB7D,KAAlB,EAAyB;EACrB,OAAOA,KAAK,YAAYoF,UAAxB;AACH;;AACD,MAAME,KAAK,GAAGC,KAAK,CAACC,IAAN,CAAW;EAAEtF,MAAM,EAAE;AAAV,CAAX,EAA4B,CAACuF,CAAD,EAAItL,CAAJ,KAAUA,CAAC,CAACuL,QAAF,CAAW,EAAX,EAAeC,QAAf,CAAwB,CAAxB,EAA2B,GAA3B,CAAtC,CAAd;;AACA,SAAStC,UAAT,CAAoBuC,MAApB,EAA4B;EACxB,IAAI,EAAEA,MAAM,YAAYR,UAApB,CAAJ,EACI,MAAM,IAAItH,KAAJ,CAAU,qBAAV,CAAN;EACJ,IAAI+C,GAAG,GAAG,EAAV;;EACA,KAAK,IAAI1G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyL,MAAM,CAAC1F,MAA3B,EAAmC/F,CAAC,EAApC,EAAwC;IACpC0G,GAAG,IAAIyE,KAAK,CAACM,MAAM,CAACzL,CAAD,CAAP,CAAZ;EACH;;EACD,OAAO0G,GAAP;AACH;;AACD,SAASgB,WAAT,CAAqBgE,GAArB,EAA0B;EACtB,IAAIA,GAAG,GAAGvN,SAAV,EACI,MAAM,IAAIwF,KAAJ,CAAU,yBAAV,CAAN;EACJ,OAAO+H,GAAG,CAACH,QAAJ,CAAa,EAAb,EAAiBC,QAAjB,CAA0B,EAA1B,EAA8B,GAA9B,CAAP;AACH;;AACD,SAASG,QAAT,CAAkBD,GAAlB,EAAuB;EACnB,OAAOxD,UAAU,CAACR,WAAW,CAACgE,GAAD,CAAZ,CAAjB;AACH;;AACD,SAASpB,mBAAT,CAA6BoB,GAA7B,EAAkC;EAC9B,MAAMhF,GAAG,GAAGgF,GAAG,CAACH,QAAJ,CAAa,EAAb,CAAZ;EACA,OAAO7E,GAAG,CAACX,MAAJ,GAAa,CAAb,GAAkB,IAAGW,GAAI,EAAzB,GAA6BA,GAApC;AACH;;AACD,SAASmD,WAAT,CAAqBnD,GAArB,EAA0B;EACtB,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;IACzB,MAAM,IAAIhH,SAAJ,CAAc,uCAAuC,OAAOgH,GAA5D,CAAN;EACH;;EACD,OAAO5I,MAAM,CAAE,KAAI4I,GAAI,EAAV,CAAb;AACH;;AACD,SAASwB,UAAT,CAAoBxB,GAApB,EAAyB;EACrB,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;IACzB,MAAM,IAAIhH,SAAJ,CAAc,sCAAsC,OAAOgH,GAA3D,CAAN;EACH;;EACD,IAAIA,GAAG,CAACX,MAAJ,GAAa,CAAjB,EACI,MAAM,IAAIpC,KAAJ,CAAU,8CAA8C+C,GAAG,CAACX,MAA5D,CAAN;EACJ,MAAM6F,KAAK,GAAG,IAAIX,UAAJ,CAAevE,GAAG,CAACX,MAAJ,GAAa,CAA5B,CAAd;;EACA,KAAK,IAAI/F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4L,KAAK,CAAC7F,MAA1B,EAAkC/F,CAAC,EAAnC,EAAuC;IACnC,MAAM6L,CAAC,GAAG7L,CAAC,GAAG,CAAd;IACA,MAAM8L,OAAO,GAAGpF,GAAG,CAAC2B,KAAJ,CAAUwD,CAAV,EAAaA,CAAC,GAAG,CAAjB,CAAhB;IACA,MAAME,IAAI,GAAGxH,MAAM,CAACwE,QAAP,CAAgB+C,OAAhB,EAAyB,EAAzB,CAAb;IACA,IAAIvH,MAAM,CAACyH,KAAP,CAAaD,IAAb,KAAsBA,IAAI,GAAG,CAAjC,EACI,MAAM,IAAIpI,KAAJ,CAAU,uBAAV,CAAN;IACJiI,KAAK,CAAC5L,CAAD,CAAL,GAAW+L,IAAX;EACH;;EACD,OAAOH,KAAP;AACH;;AACD,SAAS5F,aAAT,CAAuBH,KAAvB,EAA8B;EAC1B,OAAOgE,WAAW,CAACX,UAAU,CAACrD,KAAD,CAAX,CAAlB;AACH;;AACD,SAASc,WAAT,CAAqBD,GAArB,EAA0B;EACtB,OAAOA,GAAG,YAAYuE,UAAf,GAA4BA,UAAU,CAACI,IAAX,CAAgB3E,GAAhB,CAA5B,GAAmDwB,UAAU,CAACxB,GAAD,CAApE;AACH;;AACD,SAASpE,eAAT,CAAyBoJ,GAAzB,EAA8B;EAC1B,IAAI,OAAOA,GAAP,KAAe,QAAf,IAA2BnH,MAAM,CAAC0H,aAAP,CAAqBP,GAArB,CAA3B,IAAwDA,GAAG,GAAG,CAAlE,EACI,OAAO5N,MAAM,CAAC4N,GAAD,CAAb;EACJ,IAAI,OAAOA,GAAP,KAAe,QAAf,IAA2B3B,kBAAkB,CAAC2B,GAAD,CAAjD,EACI,OAAOA,GAAP;EACJ,MAAM,IAAIhM,SAAJ,CAAc,qDAAd,CAAN;AACH;;AACD,SAASV,GAAT,CAAaX,CAAb,EAA6B;EAAA,IAAbC,CAAa,uEAATF,KAAK,CAACG,CAAG;EACzB,MAAMyM,MAAM,GAAG3M,CAAC,GAAGC,CAAnB;EACA,OAAO0M,MAAM,IAAInN,GAAV,GAAgBmN,MAAhB,GAAyB1M,CAAC,GAAG0M,MAApC;AACH;;AACD,SAASkB,IAAT,CAAcpN,CAAd,EAAiBqN,KAAjB,EAAwB;EACpB,MAAM;IAAE5N;EAAF,IAAQH,KAAd;EACA,IAAI+K,GAAG,GAAGrK,CAAV;;EACA,OAAOqN,KAAK,KAAKtO,GAAjB,EAAsB;IAClBsL,GAAG,IAAIA,GAAP;IACAA,GAAG,IAAI5K,CAAP;EACH;;EACD,OAAO4K,GAAP;AACH;;AACD,SAAS/C,OAAT,CAAiBtH,CAAjB,EAAoB;EAChB,MAAM;IAAEP;EAAF,IAAQH,KAAd;;EACA,MAAMgO,GAAG,GAAGtO,MAAM,CAAC,CAAD,CAAlB;;EACA,MAAMuO,IAAI,GAAGvO,MAAM,CAAC,EAAD,CAAnB;;EACA,MAAMwO,IAAI,GAAGxO,MAAM,CAAC,EAAD,CAAnB;;EACA,MAAMyO,IAAI,GAAGzO,MAAM,CAAC,EAAD,CAAnB;;EACA,MAAM0O,IAAI,GAAG1O,MAAM,CAAC,EAAD,CAAnB;;EACA,MAAM2O,IAAI,GAAG3O,MAAM,CAAC,EAAD,CAAnB;;EACA,MAAM4O,EAAE,GAAI5N,CAAC,GAAGA,CAAJ,GAAQA,CAAT,GAAcP,CAAzB;EACA,MAAMoO,EAAE,GAAID,EAAE,GAAGA,EAAL,GAAU5N,CAAX,GAAgBP,CAA3B;EACA,MAAMqO,EAAE,GAAIV,IAAI,CAACS,EAAD,EAAK1O,GAAL,CAAJ,GAAgB0O,EAAjB,GAAuBpO,CAAlC;EACA,MAAMsO,EAAE,GAAIX,IAAI,CAACU,EAAD,EAAK3O,GAAL,CAAJ,GAAgB0O,EAAjB,GAAuBpO,CAAlC;EACA,MAAMuO,GAAG,GAAIZ,IAAI,CAACW,EAAD,EAAK7O,GAAL,CAAJ,GAAgB0O,EAAjB,GAAuBnO,CAAnC;EACA,MAAMwO,GAAG,GAAIb,IAAI,CAACY,GAAD,EAAMT,IAAN,CAAJ,GAAkBS,GAAnB,GAA0BvO,CAAtC;EACA,MAAMyO,GAAG,GAAId,IAAI,CAACa,GAAD,EAAMT,IAAN,CAAJ,GAAkBS,GAAnB,GAA0BxO,CAAtC;EACA,MAAM0O,GAAG,GAAIf,IAAI,CAACc,GAAD,EAAMR,IAAN,CAAJ,GAAkBQ,GAAnB,GAA0BzO,CAAtC;EACA,MAAM2O,IAAI,GAAIhB,IAAI,CAACe,GAAD,EAAMR,IAAN,CAAJ,GAAkBQ,GAAnB,GAA0B1O,CAAvC;EACA,MAAM4O,IAAI,GAAIjB,IAAI,CAACgB,IAAD,EAAOV,IAAP,CAAJ,GAAmBQ,GAApB,GAA2BzO,CAAxC;EACA,MAAM6O,IAAI,GAAIlB,IAAI,CAACiB,IAAD,EAAOlP,GAAP,CAAJ,GAAkB0O,EAAnB,GAAyBpO,CAAtC;EACA,MAAM8O,EAAE,GAAInB,IAAI,CAACkB,IAAD,EAAOb,IAAP,CAAJ,GAAmBQ,GAApB,GAA2BxO,CAAtC;EACA,MAAM+O,EAAE,GAAIpB,IAAI,CAACmB,EAAD,EAAKjB,GAAL,CAAJ,GAAgBM,EAAjB,GAAuBnO,CAAlC;EACA,OAAO2N,IAAI,CAACoB,EAAD,EAAKtP,GAAL,CAAX;AACH;;AACD,SAASkH,MAAT,CAAgBqI,MAAhB,EAA0C;EAAA,IAAlBC,MAAkB,uEAATpP,KAAK,CAACG,CAAG;;EACtC,IAAIgP,MAAM,KAAK1P,GAAX,IAAkB2P,MAAM,IAAI3P,GAAhC,EAAqC;IACjC,MAAM,IAAI8F,KAAJ,CAAW,6CAA4C4J,MAAO,QAAOC,MAAO,EAA5E,CAAN;EACH;;EACD,IAAInP,CAAC,GAAGW,GAAG,CAACuO,MAAD,EAASC,MAAT,CAAX;EACA,IAAIlP,CAAC,GAAGkP,MAAR;EACA,IAAI1O,CAAC,GAAGjB,GAAR;EAAA,IAAawB,CAAC,GAAGtB,GAAjB;EAAA,IAAsB0P,CAAC,GAAG1P,GAA1B;EAAA,IAA+BuN,CAAC,GAAGzN,GAAnC;;EACA,OAAOQ,CAAC,KAAKR,GAAb,EAAkB;IACd,MAAM6P,CAAC,GAAGpP,CAAC,GAAGD,CAAd;IACA,MAAMyD,CAAC,GAAGxD,CAAC,GAAGD,CAAd;IACA,MAAMsP,CAAC,GAAG7O,CAAC,GAAG2O,CAAC,GAAGC,CAAlB;IACA,MAAMlP,CAAC,GAAGa,CAAC,GAAGiM,CAAC,GAAGoC,CAAlB;IACApP,CAAC,GAAGD,CAAJ,EAAOA,CAAC,GAAGyD,CAAX,EAAchD,CAAC,GAAG2O,CAAlB,EAAqBpO,CAAC,GAAGiM,CAAzB,EAA4BmC,CAAC,GAAGE,CAAhC,EAAmCrC,CAAC,GAAG9M,CAAvC;EACH;;EACD,MAAMoP,GAAG,GAAGtP,CAAZ;EACA,IAAIsP,GAAG,KAAK7P,GAAZ,EACI,MAAM,IAAI4F,KAAJ,CAAU,wBAAV,CAAN;EACJ,OAAO3E,GAAG,CAACF,CAAD,EAAI0O,MAAJ,CAAV;AACH;;AACD,SAAS1N,WAAT,CAAqB+N,IAArB,EAAwC;EAAA,IAAbrO,CAAa,uEAATpB,KAAK,CAACG,CAAG;EACpC,MAAMuP,OAAO,GAAG,IAAI1C,KAAJ,CAAUyC,IAAI,CAAC9H,MAAf,CAAhB;EACA,MAAMgI,cAAc,GAAGF,IAAI,CAAC9C,MAAL,CAAY,CAACiD,GAAD,EAAMtC,GAAN,EAAW1L,CAAX,KAAiB;IAChD,IAAI0L,GAAG,KAAK7N,GAAZ,EACI,OAAOmQ,GAAP;IACJF,OAAO,CAAC9N,CAAD,CAAP,GAAagO,GAAb;IACA,OAAOhP,GAAG,CAACgP,GAAG,GAAGtC,GAAP,EAAYlM,CAAZ,CAAV;EACH,CALsB,EAKpBzB,GALoB,CAAvB;EAMA,MAAMkQ,QAAQ,GAAG/I,MAAM,CAAC6I,cAAD,EAAiBvO,CAAjB,CAAvB;EACAqO,IAAI,CAACK,WAAL,CAAiB,CAACF,GAAD,EAAMtC,GAAN,EAAW1L,CAAX,KAAiB;IAC9B,IAAI0L,GAAG,KAAK7N,GAAZ,EACI,OAAOmQ,GAAP;IACJF,OAAO,CAAC9N,CAAD,CAAP,GAAahB,GAAG,CAACgP,GAAG,GAAGF,OAAO,CAAC9N,CAAD,CAAd,EAAmBR,CAAnB,CAAhB;IACA,OAAOR,GAAG,CAACgP,GAAG,GAAGtC,GAAP,EAAYlM,CAAZ,CAAV;EACH,CALD,EAKGyO,QALH;EAMA,OAAOH,OAAP;AACH;;AACD,MAAMK,UAAU,GAAG,CAAC9P,CAAD,EAAIC,CAAJ,KAAU,CAACD,CAAC,GAAGC,CAAC,GAAGN,GAAT,IAAgBM,CAA7C;;AACA,MAAM8P,SAAS,GAAGpQ,GAAG,IAAIF,MAAM,CAAC,GAAD,CAA/B;;AACA,SAASiF,eAAT,CAAyBsL,CAAzB,EAA4B;EACxB,MAAM;IAAE7P;EAAF,IAAQJ,KAAd;EACA,MAAMkQ,EAAE,GAAGxQ,MAAM,CAAC,oCAAD,CAAjB;EACA,MAAMyQ,EAAE,GAAG,CAACxQ,GAAD,GAAOD,MAAM,CAAC,oCAAD,CAAxB;EACA,MAAM0Q,EAAE,GAAG1Q,MAAM,CAAC,qCAAD,CAAjB;EACA,MAAM4O,EAAE,GAAG4B,EAAX;EACA,MAAMG,EAAE,GAAGN,UAAU,CAACzB,EAAE,GAAG2B,CAAN,EAAS7P,CAAT,CAArB;EACA,MAAMkQ,EAAE,GAAGP,UAAU,CAAC,CAACI,EAAD,GAAMF,CAAP,EAAU7P,CAAV,CAArB;EACA,IAAIoE,EAAE,GAAG5D,GAAG,CAACqP,CAAC,GAAGI,EAAE,GAAGH,EAAT,GAAcI,EAAE,GAAGF,EAApB,EAAwBhQ,CAAxB,CAAZ;EACA,IAAIsE,EAAE,GAAG9D,GAAG,CAAC,CAACyP,EAAD,GAAMF,EAAN,GAAWG,EAAE,GAAGhC,EAAjB,EAAqBlO,CAArB,CAAZ;EACA,MAAMmE,KAAK,GAAGC,EAAE,GAAGwL,SAAnB;EACA,MAAMvL,KAAK,GAAGC,EAAE,GAAGsL,SAAnB;EACA,IAAIzL,KAAJ,EACIC,EAAE,GAAGpE,CAAC,GAAGoE,EAAT;EACJ,IAAIC,KAAJ,EACIC,EAAE,GAAGtE,CAAC,GAAGsE,EAAT;;EACJ,IAAIF,EAAE,GAAGwL,SAAL,IAAkBtL,EAAE,GAAGsL,SAA3B,EAAsC;IAClC,MAAM,IAAIzK,KAAJ,CAAU,6CAA6C0K,CAAvD,CAAN;EACH;;EACD,OAAO;IAAE1L,KAAF;IAASC,EAAT;IAAaC,KAAb;IAAoBC;EAApB,CAAP;AACH;;AACD,SAASuE,YAAT,CAAsBsH,IAAtB,EAA4B;EACxB,MAAM;IAAEnQ;EAAF,IAAQJ,KAAd;EACA,MAAMwQ,UAAU,GAAGD,IAAI,CAAC5I,MAAxB;EACA,MAAM8I,KAAK,GAAGD,UAAU,GAAG,CAAb,GAAiB,GAA/B;EACA,IAAInQ,CAAC,GAAGuH,aAAa,CAAC2I,IAAD,CAArB;EACA,IAAIE,KAAK,GAAG,CAAZ,EACIpQ,CAAC,GAAGA,CAAC,IAAIX,MAAM,CAAC+Q,KAAD,CAAf;EACJ,IAAIpQ,CAAC,IAAID,CAAT,EACIC,CAAC,IAAID,CAAL;EACJ,OAAOC,CAAP;AACH;;AACD,MAAMqQ,QAAN,CAAe;EACX1P,WAAW,GAAG;IACV,KAAKkM,CAAL,GAAS,IAAIL,UAAJ,CAAe,EAAf,EAAmB8D,IAAnB,CAAwB,CAAxB,CAAT;IACA,KAAKV,CAAL,GAAS,IAAIpD,UAAJ,CAAe,EAAf,EAAmB8D,IAAnB,CAAwB,CAAxB,CAAT;IACA,KAAKC,OAAL,GAAe,CAAf;EACH;;EACDC,IAAI,GAAY;IAAA,mCAARC,MAAQ;MAARA,MAAQ;IAAA;;IACZ,OAAOC,KAAK,CAACC,UAAN,CAAiB,KAAKf,CAAtB,EAAyB,GAAGa,MAA5B,CAAP;EACH;;EACDG,QAAQ,GAAY;IAChB,IAAI,OAAOF,KAAK,CAACG,cAAb,KAAgC,UAApC,EACI,MAAM,IAAI3L,KAAJ,CAAU,uDAAV,CAAN;;IAFY,mCAARuL,MAAQ;MAARA,MAAQ;IAAA;;IAGhB,MAAM/F,GAAG,GAAGgG,KAAK,CAACG,cAAN,CAAqB,KAAKjB,CAA1B,EAA6B,GAAGa,MAAhC,CAAZ;IACA,IAAI/F,GAAG,YAAYoG,OAAnB,EACI,MAAM,IAAI5L,KAAJ,CAAU,qDAAV,CAAN;IACJ,OAAOwF,GAAP;EACH;;EACDqG,IAAI,GAAG;IACH,IAAI,KAAKR,OAAL,IAAgB,IAApB,EAA0B;MACtB,MAAM,IAAIrL,KAAJ,CAAU,mDAAV,CAAN;IACH;;IACD,KAAKqL,OAAL,IAAgB,CAAhB;EACH;;EACW,MAANS,MAAM,GAA0B;IAAA,IAAzBC,IAAyB,uEAAlB,IAAIzE,UAAJ,EAAkB;IAClC,KAAKoD,CAAL,GAAS,MAAM,KAAKY,IAAL,CAAU,KAAK3D,CAAf,EAAkBL,UAAU,CAACI,IAAX,CAAgB,CAAC,IAAD,CAAhB,CAAlB,EAA2CqE,IAA3C,CAAf;IACA,KAAKpE,CAAL,GAAS,MAAM,KAAK2D,IAAL,CAAU,KAAK3D,CAAf,CAAf;IACA,IAAIoE,IAAI,CAAC3J,MAAL,KAAgB,CAApB,EACI;IACJ,KAAKsI,CAAL,GAAS,MAAM,KAAKY,IAAL,CAAU,KAAK3D,CAAf,EAAkBL,UAAU,CAACI,IAAX,CAAgB,CAAC,IAAD,CAAhB,CAAlB,EAA2CqE,IAA3C,CAAf;IACA,KAAKpE,CAAL,GAAS,MAAM,KAAK2D,IAAL,CAAU,KAAK3D,CAAf,CAAf;EACH;;EACDqE,UAAU,GAA0B;IAAA,IAAzBD,IAAyB,uEAAlB,IAAIzE,UAAJ,EAAkB;IAChC,KAAKoD,CAAL,GAAS,KAAKgB,QAAL,CAAc,KAAK/D,CAAnB,EAAsBL,UAAU,CAACI,IAAX,CAAgB,CAAC,IAAD,CAAhB,CAAtB,EAA+CqE,IAA/C,CAAT;IACA,KAAKpE,CAAL,GAAS,KAAK+D,QAAL,CAAc,KAAK/D,CAAnB,CAAT;IACA,IAAIoE,IAAI,CAAC3J,MAAL,KAAgB,CAApB,EACI;IACJ,KAAKsI,CAAL,GAAS,KAAKgB,QAAL,CAAc,KAAK/D,CAAnB,EAAsBL,UAAU,CAACI,IAAX,CAAgB,CAAC,IAAD,CAAhB,CAAtB,EAA+CqE,IAA/C,CAAT;IACA,KAAKpE,CAAL,GAAS,KAAK+D,QAAL,CAAc,KAAK/D,CAAnB,CAAT;EACH;;EACa,MAARsE,QAAQ,GAAG;IACb,KAAKJ,IAAL;IACA,KAAKlE,CAAL,GAAS,MAAM,KAAK2D,IAAL,CAAU,KAAK3D,CAAf,CAAf;IACA,OAAO,KAAKA,CAAZ;EACH;;EACDuE,YAAY,GAAG;IACX,KAAKL,IAAL;IACA,KAAKlE,CAAL,GAAS,KAAK+D,QAAL,CAAc,KAAK/D,CAAnB,CAAT;IACA,OAAO,KAAKA,CAAZ;EACH;;AAhDU;;AAkDf,SAASvB,kBAAT,CAA4B2B,GAA5B,EAAiC;EAC7B,OAAO7N,GAAG,GAAG6N,GAAN,IAAaA,GAAG,GAAGtN,KAAK,CAACI,CAAhC;AACH;;AACD,SAAS0H,mBAAT,CAA6BwF,GAA7B,EAAkC;EAC9B,OAAO7N,GAAG,GAAG6N,GAAN,IAAaA,GAAG,GAAGtN,KAAK,CAACG,CAAhC;AACH;;AACD,SAASuR,QAAT,CAAkBC,MAAlB,EAA0BpC,CAA1B,EAA6BjL,CAA7B,EAAgC;EAC5B,MAAM2L,CAAC,GAAGrI,aAAa,CAAC+J,MAAD,CAAvB;EACA,IAAI,CAAChG,kBAAkB,CAACsE,CAAD,CAAvB,EACI;EACJ,MAAM;IAAE7P;EAAF,IAAQJ,KAAd;EACA,MAAMsP,CAAC,GAAGjO,KAAK,CAAC+C,IAAN,CAAWoC,QAAX,CAAoByJ,CAApB,CAAV;EACA,MAAMvM,CAAC,GAAG9C,GAAG,CAAC0O,CAAC,CAAC5O,CAAH,EAAMN,CAAN,CAAb;EACA,IAAIsD,CAAC,KAAKjE,GAAV,EACI;EACJ,MAAMyJ,CAAC,GAAGtI,GAAG,CAACkG,MAAM,CAACmJ,CAAD,EAAI7P,CAAJ,CAAN,GAAeQ,GAAG,CAAC2O,CAAC,GAAGjL,CAAC,GAAGZ,CAAT,EAAYtD,CAAZ,CAAnB,EAAmCA,CAAnC,CAAb;EACA,IAAI8I,CAAC,KAAKzJ,GAAV,EACI;EACJ,MAAMmS,GAAG,GAAG,IAAIzG,SAAJ,CAAczH,CAAd,EAAiBwF,CAAjB,CAAZ;EACA,MAAMF,QAAQ,GAAG,CAACsG,CAAC,CAAC5O,CAAF,KAAQkR,GAAG,CAAClO,CAAZ,GAAgB,CAAhB,GAAoB,CAArB,IAA0ByC,MAAM,CAACmJ,CAAC,CAACrO,CAAF,GAAMtB,GAAP,CAAjD;EACA,OAAO;IAAEiS,GAAF;IAAO5I;EAAP,CAAP;AACH;;AACD,SAASJ,mBAAT,CAA6BiJ,GAA7B,EAAkC;EAC9B,IAAIvE,GAAJ;;EACA,IAAI,OAAOuE,GAAP,KAAe,QAAnB,EAA6B;IACzBvE,GAAG,GAAGuE,GAAN;EACH,CAFD,MAGK,IAAI,OAAOA,GAAP,KAAe,QAAf,IAA2B1L,MAAM,CAAC0H,aAAP,CAAqBgE,GAArB,CAA3B,IAAwDA,GAAG,GAAG,CAAlE,EAAqE;IACtEvE,GAAG,GAAG5N,MAAM,CAACmS,GAAD,CAAZ;EACH,CAFI,MAGA,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;IAC9B,IAAIA,GAAG,CAAClK,MAAJ,KAAe,EAAnB,EACI,MAAM,IAAIpC,KAAJ,CAAU,kCAAV,CAAN;IACJ+H,GAAG,GAAG7B,WAAW,CAACoG,GAAD,CAAjB;EACH,CAJI,MAKA,IAAIvG,QAAQ,CAACuG,GAAD,CAAZ,EAAmB;IACpB,IAAIA,GAAG,CAAClK,MAAJ,KAAe,EAAnB,EACI,MAAM,IAAIpC,KAAJ,CAAU,kCAAV,CAAN;IACJ+H,GAAG,GAAG1F,aAAa,CAACiK,GAAD,CAAnB;EACH,CAJI,MAKA;IACD,MAAM,IAAIvQ,SAAJ,CAAc,4BAAd,CAAN;EACH;;EACD,IAAI,CAACqK,kBAAkB,CAAC2B,GAAD,CAAvB,EACI,MAAM,IAAI/H,KAAJ,CAAU,mCAAV,CAAN;EACJ,OAAO+H,GAAP;AACH;;AACD,SAASwE,kBAAT,CAA4BC,SAA5B,EAAuC;EACnC,IAAIA,SAAS,YAAY1Q,KAAzB,EAAgC;IAC5B0Q,SAAS,CAAC5J,cAAV;IACA,OAAO4J,SAAP;EACH,CAHD,MAIK;IACD,OAAO1Q,KAAK,CAACgH,OAAN,CAAc0J,SAAd,CAAP;EACH;AACJ;;AACD,SAAS5I,kBAAT,CAA4BJ,SAA5B,EAAuC;EACnC,IAAIA,SAAS,YAAYoC,SAAzB,EAAoC;IAChCpC,SAAS,CAACZ,cAAV;IACA,OAAOY,SAAP;EACH;;EACD,IAAI;IACA,OAAOoC,SAAS,CAACO,OAAV,CAAkB3C,SAAlB,CAAP;EACH,CAFD,CAGA,OAAOiJ,KAAP,EAAc;IACV,OAAO7G,SAAS,CAACC,WAAV,CAAsBrC,SAAtB,CAAP;EACH;AACJ;;AACD,OAAO,SAASkJ,YAAT,CAAsBtJ,UAAtB,EAAwD;EAAA,IAAtBkB,YAAsB,uEAAP,KAAO;EAC3D,OAAOxI,KAAK,CAACqH,cAAN,CAAqBC,UAArB,EAAiCiB,UAAjC,CAA4CC,YAA5C,CAAP;AACH;AACD,OAAO,SAASqI,gBAAT,CAA0BpJ,OAA1B,EAAmCC,SAAnC,EAA8CC,QAA9C,EAA8E;EAAA,IAAtBa,YAAsB,uEAAP,KAAO;EACjF,OAAOxI,KAAK,CAACwH,aAAN,CAAoBC,OAApB,EAA6BC,SAA7B,EAAwCC,QAAxC,EAAkDY,UAAlD,CAA6DC,YAA7D,CAAP;AACH;;AACD,SAASsI,KAAT,CAAeC,IAAf,EAAqB;EACjB,MAAM/G,GAAG,GAAGC,QAAQ,CAAC8G,IAAD,CAApB;EACA,MAAM5G,GAAG,GAAG,OAAO4G,IAAP,KAAgB,QAA5B;EACA,MAAM5J,GAAG,GAAG,CAAC6C,GAAG,IAAIG,GAAR,KAAgB4G,IAAI,CAACzK,MAAjC;EACA,IAAI0D,GAAJ,EACI,OAAO7C,GAAG,KAAK,EAAR,IAAcA,GAAG,KAAK,EAA7B;EACJ,IAAIgD,GAAJ,EACI,OAAOhD,GAAG,KAAK,EAAR,IAAcA,GAAG,KAAK,GAA7B;EACJ,IAAI4J,IAAI,YAAY/Q,KAApB,EACI,OAAO,IAAP;EACJ,OAAO,KAAP;AACH;;AACD,OAAO,SAASgR,eAAT,CAAyBC,QAAzB,EAAmCC,OAAnC,EAAkE;EAAA,IAAtB1I,YAAsB,uEAAP,KAAO;EACrE,IAAIsI,KAAK,CAACG,QAAD,CAAT,EACI,MAAM,IAAIhR,SAAJ,CAAc,gDAAd,CAAN;EACJ,IAAI,CAAC6Q,KAAK,CAACI,OAAD,CAAV,EACI,MAAM,IAAIjR,SAAJ,CAAc,gDAAd,CAAN;EACJ,MAAMpB,CAAC,GAAG4R,kBAAkB,CAACS,OAAD,CAA5B;EACArS,CAAC,CAACiI,cAAF;EACA,OAAOjI,CAAC,CAACsG,QAAF,CAAWoC,mBAAmB,CAAC0J,QAAD,CAA9B,EAA0C1I,UAA1C,CAAqDC,YAArD,CAAP;AACH;;AACD,SAAS2I,QAAT,CAAkB/K,KAAlB,EAAyB;EACrB,MAAMwC,KAAK,GAAGxC,KAAK,CAACE,MAAN,GAAe,EAAf,GAAoBF,KAAK,CAACwC,KAAN,CAAY,CAAZ,EAAe,EAAf,CAApB,GAAyCxC,KAAvD;EACA,OAAOG,aAAa,CAACqC,KAAD,CAApB;AACH;;AACD,SAASwI,WAAT,CAAqBhL,KAArB,EAA4B;EACxB,MAAMiL,EAAE,GAAGF,QAAQ,CAAC/K,KAAD,CAAnB;EACA,MAAMkL,EAAE,GAAG/R,GAAG,CAAC8R,EAAD,EAAK1S,KAAK,CAACI,CAAX,CAAd;EACA,OAAOwS,UAAU,CAACD,EAAE,GAAGlT,GAAL,GAAWiT,EAAX,GAAgBC,EAAjB,CAAjB;AACH;;AACD,SAASC,UAAT,CAAoBtF,GAApB,EAAyB;EACrB,IAAI,OAAOA,GAAP,KAAe,QAAnB,EACI,MAAM,IAAI/H,KAAJ,CAAU,iBAAV,CAAN;EACJ,MAAM+C,GAAG,GAAGgB,WAAW,CAACgE,GAAD,CAAvB;EACA,OAAOxD,UAAU,CAACxB,GAAD,CAAjB;AACH;;AACD,SAASuK,WAAT,CAAqB/J,OAArB,EAA8BH,UAA9B,EAA0CmK,YAA1C,EAAwD;EACpD,IAAIhK,OAAO,IAAI,IAAf,EACI,MAAM,IAAIvD,KAAJ,CAAW,2CAA0CuD,OAAQ,GAA7D,CAAN;EACJ,MAAMiK,EAAE,GAAGxK,WAAW,CAACO,OAAD,CAAtB;EACA,MAAMxE,CAAC,GAAGsE,mBAAmB,CAACD,UAAD,CAA7B;EACA,MAAMqK,QAAQ,GAAG,CAACJ,UAAU,CAACtO,CAAD,CAAX,EAAgBmO,WAAW,CAACM,EAAD,CAA3B,CAAjB;;EACA,IAAID,YAAY,IAAI,IAApB,EAA0B;IACtB,IAAIA,YAAY,KAAK,IAArB,EACIA,YAAY,GAAG/B,KAAK,CAACkC,WAAN,CAAkB,EAAlB,CAAf;IACJ,MAAMC,CAAC,GAAG3K,WAAW,CAACuK,YAAD,CAArB;IACA,IAAII,CAAC,CAACvL,MAAF,KAAa,EAAjB,EACI,MAAM,IAAIpC,KAAJ,CAAU,uCAAV,CAAN;IACJyN,QAAQ,CAAC7N,IAAT,CAAc+N,CAAd;EACH;;EACD,MAAM5B,IAAI,GAAG9E,WAAW,CAAC,GAAGwG,QAAJ,CAAxB;EACA,MAAMzD,CAAC,GAAGiD,QAAQ,CAACO,EAAD,CAAlB;EACA,OAAO;IAAEzB,IAAF;IAAQ/B,CAAR;IAAWjL;EAAX,CAAP;AACH;;AACD,SAAS6O,WAAT,CAAqBC,MAArB,EAA6BC,IAA7B,EAAmC;EAC/B,IAAI;IAAEzB,GAAF;IAAO5I;EAAP,IAAoBoK,MAAxB;EACA,MAAM;IAAEE,SAAF;IAAaC,GAAb;IAAkBC;EAAlB,IAAgCC,MAAM,CAACC,MAAP,CAAc;IAAEJ,SAAS,EAAE,IAAb;IAAmBC,GAAG,EAAE;EAAxB,CAAd,EAA8CF,IAA9C,CAAtC;;EACA,IAAIC,SAAS,IAAI1B,GAAG,CAAChG,QAAJ,EAAjB,EAAiC;IAC7BgG,GAAG,GAAGA,GAAG,CAAC9F,UAAJ,EAAN;IACA9C,QAAQ,IAAI,CAAZ;EACH;;EACD,MAAM2K,MAAM,GAAGJ,GAAG,GAAG3B,GAAG,CAAC7F,aAAJ,EAAH,GAAyB6F,GAAG,CAACtF,iBAAJ,EAA3C;EACA,OAAOkH,SAAS,GAAG,CAACG,MAAD,EAAS3K,QAAT,CAAH,GAAwB2K,MAAxC;AACH;;AACD,eAAeC,IAAf,CAAoB9K,OAApB,EAA6B+K,OAA7B,EAAiD;EAAA,IAAXR,IAAW,uEAAJ,EAAI;EAC7C,MAAM;IAAE/B,IAAF;IAAQ/B,CAAR;IAAWjL;EAAX,IAAiBuO,WAAW,CAAC/J,OAAD,EAAU+K,OAAV,EAAmBR,IAAI,CAACP,YAAxB,CAAlC;EACA,IAAIlB,GAAJ;EACA,MAAMkC,IAAI,GAAG,IAAIpD,QAAJ,EAAb;EACA,MAAMoD,IAAI,CAACzC,MAAL,CAAYC,IAAZ,CAAN;;EACA,OAAO,EAAEM,GAAG,GAAGF,QAAQ,CAAC,MAAMoC,IAAI,CAACtC,QAAL,EAAP,EAAwBjC,CAAxB,EAA2BjL,CAA3B,CAAhB,CAAP,EACI,MAAMwP,IAAI,CAACzC,MAAL,EAAN;;EACJ,OAAO8B,WAAW,CAACvB,GAAD,EAAMyB,IAAN,CAAlB;AACH;;AACD,SAASU,QAAT,CAAkBjL,OAAlB,EAA2B+K,OAA3B,EAA+C;EAAA,IAAXR,IAAW,uEAAJ,EAAI;EAC3C,MAAM;IAAE/B,IAAF;IAAQ/B,CAAR;IAAWjL;EAAX,IAAiBuO,WAAW,CAAC/J,OAAD,EAAU+K,OAAV,EAAmBR,IAAI,CAACP,YAAxB,CAAlC;EACA,IAAIlB,GAAJ;EACA,MAAMkC,IAAI,GAAG,IAAIpD,QAAJ,EAAb;EACAoD,IAAI,CAACvC,UAAL,CAAgBD,IAAhB;;EACA,OAAO,EAAEM,GAAG,GAAGF,QAAQ,CAACoC,IAAI,CAACrC,YAAL,EAAD,EAAsBlC,CAAtB,EAAyBjL,CAAzB,CAAhB,CAAP,EACIwP,IAAI,CAACvC,UAAL;;EACJ,OAAO4B,WAAW,CAACvB,GAAD,EAAMyB,IAAN,CAAlB;AACH;;AACD,SAASO,IAAT,EAAeG,QAAf;AACA,MAAMC,KAAK,GAAG;EAAEC,MAAM,EAAE;AAAV,CAAd;AACA,OAAO,SAASC,MAAT,CAAgBnL,SAAhB,EAA2BD,OAA3B,EAAoCiJ,SAApC,EAA6D;EAAA,IAAdsB,IAAc,uEAAPW,KAAO;EAChE,IAAIpC,GAAJ;;EACA,IAAI;IACAA,GAAG,GAAGzI,kBAAkB,CAACJ,SAAD,CAAxB;IACAD,OAAO,GAAGP,WAAW,CAACO,OAAD,CAArB;EACH,CAHD,CAIA,OAAOkJ,KAAP,EAAc;IACV,OAAO,KAAP;EACH;;EACD,MAAM;IAAEtO,CAAF;IAAKwF;EAAL,IAAW0I,GAAjB;EACA,IAAIyB,IAAI,CAACY,MAAL,IAAerC,GAAG,CAAChG,QAAJ,EAAnB,EACI,OAAO,KAAP;EACJ,MAAMvL,CAAC,GAAG4I,YAAY,CAACH,OAAD,CAAtB;EACA,IAAIzI,CAAC,KAAKZ,GAAV,EACI,OAAO,KAAP;EACJ,IAAIU,CAAJ;;EACA,IAAI;IACAA,CAAC,GAAG2R,kBAAkB,CAACC,SAAD,CAAtB;EACH,CAFD,CAGA,OAAOC,KAAP,EAAc;IACV,OAAO,KAAP;EACH;;EACD,MAAM;IAAE5R;EAAF,IAAQJ,KAAd;EACA,MAAMmU,IAAI,GAAGrN,MAAM,CAACoC,CAAD,EAAI9I,CAAJ,CAAnB;EACA,MAAMoJ,EAAE,GAAG5I,GAAG,CAACP,CAAC,GAAG8T,IAAL,EAAW/T,CAAX,CAAd;EACA,MAAMqJ,EAAE,GAAG7I,GAAG,CAAC8C,CAAC,GAAGyQ,IAAL,EAAW/T,CAAX,CAAd;EACA,MAAMiJ,CAAC,GAAGhI,KAAK,CAAC+C,IAAN,CAAWuF,oBAAX,CAAgCxJ,CAAhC,EAAmCqJ,EAAnC,EAAuCC,EAAvC,CAAV;EACA,IAAI,CAACJ,CAAL,EACI,OAAO,KAAP;EACJ,MAAM6D,CAAC,GAAGtM,GAAG,CAACyI,CAAC,CAAC3I,CAAH,EAAMN,CAAN,CAAb;EACA,OAAO8M,CAAC,KAAKxJ,CAAb;AACH;;AACD,SAAS0Q,wBAAT,CAAkCC,EAAlC,EAAsC;EAClC,OAAOzT,GAAG,CAACgH,aAAa,CAACyM,EAAD,CAAd,EAAoBrU,KAAK,CAACI,CAA1B,CAAV;AACH;;AACD,SAASkU,QAAT,CAAkB7N,KAAlB,EAAyB;EACrB,OAAO,CAACA,KAAK,CAACxF,CAAN,GAAUtB,GAAX,MAAoBF,GAA3B;AACH;;AACD,MAAM8U,gBAAN,CAAuB;EACnBvT,WAAW,CAAC0C,CAAD,EAAIwF,CAAJ,EAAO;IACd,KAAKxF,CAAL,GAASA,CAAT;IACA,KAAKwF,CAAL,GAASA,CAAT;IACA,KAAKf,cAAL;EACH;;EACa,OAAPE,OAAO,CAACC,GAAD,EAAM;IAChB,MAAMb,KAAK,GAAGc,WAAW,CAACD,GAAD,CAAzB;IACA,IAAIb,KAAK,CAACE,MAAN,KAAiB,EAArB,EACI,MAAM,IAAIrG,SAAJ,CAAe,oDAAmDmG,KAAK,CAACE,MAAO,EAA/E,CAAN;IACJ,MAAMjE,CAAC,GAAGkE,aAAa,CAACH,KAAK,CAACI,QAAN,CAAe,CAAf,EAAkB,EAAlB,CAAD,CAAvB;IACA,MAAMqB,CAAC,GAAGtB,aAAa,CAACH,KAAK,CAACI,QAAN,CAAe,EAAf,EAAmB,EAAnB,CAAD,CAAvB;IACA,OAAO,IAAI0M,gBAAJ,CAAqB7Q,CAArB,EAAwBwF,CAAxB,CAAP;EACH;;EACDf,cAAc,GAAG;IACb,MAAM;MAAEzE,CAAF;MAAKwF;IAAL,IAAW,IAAjB;IACA,IAAI,CAACpB,mBAAmB,CAACpE,CAAD,CAApB,IAA2B,CAACiI,kBAAkB,CAACzC,CAAD,CAAlD,EACI,MAAM,IAAI3D,KAAJ,CAAU,mBAAV,CAAN;EACP;;EACDwE,KAAK,GAAG;IACJ,OAAOT,WAAW,CAAC,KAAK5F,CAAN,CAAX,GAAsB4F,WAAW,CAAC,KAAKJ,CAAN,CAAxC;EACH;;EACDU,UAAU,GAAG;IACT,OAAOE,UAAU,CAAC,KAAKC,KAAL,EAAD,CAAjB;EACH;;AAxBkB;;AA0BvB,SAASyK,mBAAT,CAA6B7L,UAA7B,EAAyC;EACrC,OAAOtH,KAAK,CAACqH,cAAN,CAAqBC,UAArB,EAAiCuB,MAAjC,EAAP;AACH;;AACD,SAASuK,kBAAT,CAA4BC,OAA5B,EAAqC/L,UAArC,EAAiDgM,OAAjD,EAA0D;EACtD,IAAID,OAAO,IAAI,IAAf,EACI,MAAM,IAAIpT,SAAJ,CAAe,sCAAqCoT,OAAQ,GAA5D,CAAN;EACJ,MAAMnF,CAAC,GAAGhH,WAAW,CAACmM,OAAD,CAArB;EACA,MAAME,EAAE,GAAGhM,mBAAmB,CAACD,UAAD,CAA9B;EACA,MAAMkM,IAAI,GAAGtM,WAAW,CAACoM,OAAD,CAAxB;EACA,IAAIE,IAAI,CAAClN,MAAL,KAAgB,EAApB,EACI,MAAM,IAAIrG,SAAJ,CAAc,2CAAd,CAAN;EACJ,MAAMnB,CAAC,GAAGkB,KAAK,CAACqH,cAAN,CAAqBkM,EAArB,CAAV;EACA,MAAME,EAAE,GAAG3U,CAAC,CAAC+J,MAAF,EAAX;EACA,MAAM5F,CAAC,GAAGgQ,QAAQ,CAACnU,CAAD,CAAR,GAAcyU,EAAd,GAAmB5U,KAAK,CAACI,CAAN,GAAUwU,EAAvC;EACA,OAAO;IAAErF,CAAF;IAAKpP,CAAL;IAAQ2U,EAAR;IAAYxQ,CAAZ;IAAeuQ;EAAf,CAAP;AACH;;AACD,SAASE,gBAAT,CAA0BzQ,CAA1B,EAA6B0Q,GAA7B,EAAkC;EAC9B,OAAOzH,QAAQ,CAACjJ,CAAC,GAAGsD,aAAa,CAACoN,GAAD,CAAlB,CAAf;AACH;;AACD,SAASC,oBAAT,CAA8BC,GAA9B,EAAmC;EAC/B,MAAMC,EAAE,GAAGvU,GAAG,CAACgH,aAAa,CAACsN,GAAD,CAAd,EAAqBlV,KAAK,CAACI,CAA3B,CAAd;EACA,IAAI+U,EAAE,KAAK1V,GAAX,EACI,MAAM,IAAI8F,KAAJ,CAAU,+CAAV,CAAN;EACJ,MAAM8D,CAAC,GAAGhI,KAAK,CAACqH,cAAN,CAAqByM,EAArB,CAAV;EACA,MAAMC,EAAE,GAAG/L,CAAC,CAACa,MAAF,EAAX;EACA,MAAM+F,CAAC,GAAGqE,QAAQ,CAACjL,CAAD,CAAR,GAAc8L,EAAd,GAAmBnV,KAAK,CAACI,CAAN,GAAU+U,EAAvC;EACA,OAAO;IAAE9L,CAAF;IAAK+L,EAAL;IAASnF;EAAT,CAAP;AACH;;AACD,SAASoF,kBAAT,CAA4BhM,CAA5B,EAA+B4G,CAA/B,EAAkCiD,CAAlC,EAAqC5O,CAArC,EAAwC;EACpC,OAAO,IAAIiQ,gBAAJ,CAAqBlL,CAAC,CAAC3I,CAAvB,EAA0BE,GAAG,CAACqP,CAAC,GAAGiD,CAAC,GAAG5O,CAAT,EAAYtE,KAAK,CAACI,CAAlB,CAA7B,EAAmDwJ,UAAnD,EAAP;AACH;;AACD,eAAe0L,WAAf,CAA2BZ,OAA3B,EAAoC/L,UAApC,EAA+E;EAAA,IAA/BgM,OAA+B,uEAArB5D,KAAK,CAACkC,WAAN,EAAqB;EAC3E,MAAM;IAAE1D,CAAF;IAAKuF,EAAL;IAASxQ,CAAT;IAAYuQ;EAAZ,IAAqBJ,kBAAkB,CAACC,OAAD,EAAU/L,UAAV,EAAsBgM,OAAtB,CAA7C;EACA,MAAMY,CAAC,GAAGR,gBAAgB,CAACzQ,CAAD,EAAI,MAAMyM,KAAK,CAACyE,UAAN,CAAiBC,IAAI,CAACC,GAAtB,EAA2Bb,IAA3B,CAAV,CAA1B;EACA,MAAM;IAAExL,CAAF;IAAK+L,EAAL;IAASnF;EAAT,IAAegF,oBAAoB,CAAC,MAAMlE,KAAK,CAACyE,UAAN,CAAiBC,IAAI,CAACE,KAAtB,EAA6BJ,CAA7B,EAAgCT,EAAhC,EAAoCvF,CAApC,CAAP,CAAzC;EACA,MAAM2D,CAAC,GAAGkB,wBAAwB,CAAC,MAAMrD,KAAK,CAACyE,UAAN,CAAiBC,IAAI,CAACG,SAAtB,EAAiCR,EAAjC,EAAqCN,EAArC,EAAyCvF,CAAzC,CAAP,CAAlC;EACA,MAAMqC,GAAG,GAAGyD,kBAAkB,CAAChM,CAAD,EAAI4G,CAAJ,EAAOiD,CAAP,EAAU5O,CAAV,CAA9B;EACA,MAAMuR,OAAO,GAAG,MAAMC,aAAa,CAAClE,GAAD,EAAMrC,CAAN,EAASuF,EAAT,CAAnC;EACA,IAAI,CAACe,OAAL,EACI,MAAM,IAAItQ,KAAJ,CAAU,kCAAV,CAAN;EACJ,OAAOqM,GAAP;AACH;;AACD,SAASmE,eAAT,CAAyBrB,OAAzB,EAAkC/L,UAAlC,EAA6E;EAAA,IAA/BgM,OAA+B,uEAArB5D,KAAK,CAACkC,WAAN,EAAqB;EACzE,MAAM;IAAE1D,CAAF;IAAKuF,EAAL;IAASxQ,CAAT;IAAYuQ;EAAZ,IAAqBJ,kBAAkB,CAACC,OAAD,EAAU/L,UAAV,EAAsBgM,OAAtB,CAA7C;EACA,MAAMY,CAAC,GAAGR,gBAAgB,CAACzQ,CAAD,EAAIyM,KAAK,CAACiF,cAAN,CAAqBP,IAAI,CAACC,GAA1B,EAA+Bb,IAA/B,CAAJ,CAA1B;EACA,MAAM;IAAExL,CAAF;IAAK+L,EAAL;IAASnF;EAAT,IAAegF,oBAAoB,CAAClE,KAAK,CAACiF,cAAN,CAAqBP,IAAI,CAACE,KAA1B,EAAiCJ,CAAjC,EAAoCT,EAApC,EAAwCvF,CAAxC,CAAD,CAAzC;EACA,MAAM2D,CAAC,GAAGkB,wBAAwB,CAACrD,KAAK,CAACiF,cAAN,CAAqBP,IAAI,CAACG,SAA1B,EAAqCR,EAArC,EAAyCN,EAAzC,EAA6CvF,CAA7C,CAAD,CAAlC;EACA,MAAMqC,GAAG,GAAGyD,kBAAkB,CAAChM,CAAD,EAAI4G,CAAJ,EAAOiD,CAAP,EAAU5O,CAAV,CAA9B;EACA,MAAMuR,OAAO,GAAGI,iBAAiB,CAACrE,GAAD,EAAMrC,CAAN,EAASuF,EAAT,CAAjC;EACA,IAAI,CAACe,OAAL,EACI,MAAM,IAAItQ,KAAJ,CAAU,kCAAV,CAAN;EACJ,OAAOqM,GAAP;AACH;;AACD,SAASsE,iBAAT,CAA2BnN,SAA3B,EAAsC2L,OAAtC,EAA+C3C,SAA/C,EAA0D;EACtD,MAAMoE,GAAG,GAAGpN,SAAS,YAAYwL,gBAAjC;EACA,MAAM3C,GAAG,GAAGuE,GAAG,GAAGpN,SAAH,GAAewL,gBAAgB,CAAClM,OAAjB,CAAyBU,SAAzB,CAA9B;EACA,IAAIoN,GAAJ,EACIvE,GAAG,CAACzJ,cAAJ;EACJ,OAAO,EACH,GAAGyJ,GADA;IAEHrC,CAAC,EAAEhH,WAAW,CAACmM,OAAD,CAFX;IAGHvU,CAAC,EAAE2R,kBAAkB,CAACC,SAAD;EAHlB,CAAP;AAKH;;AACD,SAASqE,qBAAT,CAA+B1S,CAA/B,EAAkCvD,CAAlC,EAAqC+I,CAArC,EAAwCgK,CAAxC,EAA2C;EACvC,MAAM7J,CAAC,GAAGhI,KAAK,CAAC+C,IAAN,CAAWuF,oBAAX,CAAgCxJ,CAAhC,EAAmCyI,mBAAmB,CAACM,CAAD,CAAtD,EAA2DtI,GAAG,CAAC,CAACsS,CAAF,EAAKlT,KAAK,CAACI,CAAX,CAA9D,CAAV;EACA,IAAI,CAACiJ,CAAD,IAAM,CAACiL,QAAQ,CAACjL,CAAD,CAAf,IAAsBA,CAAC,CAAC3I,CAAF,KAAQgD,CAAlC,EACI,OAAO,KAAP;EACJ,OAAO,IAAP;AACH;;AACD,eAAeoS,aAAf,CAA6B/M,SAA7B,EAAwC2L,OAAxC,EAAiD3C,SAAjD,EAA4D;EACxD,IAAI;IACA,MAAM;MAAErO,CAAF;MAAKwF,CAAL;MAAQqG,CAAR;MAAWpP;IAAX,IAAiB+V,iBAAiB,CAACnN,SAAD,EAAY2L,OAAZ,EAAqB3C,SAArB,CAAxC;IACA,MAAMmB,CAAC,GAAGkB,wBAAwB,CAAC,MAAMrD,KAAK,CAACyE,UAAN,CAAiBC,IAAI,CAACG,SAAtB,EAAiCrI,QAAQ,CAAC7J,CAAD,CAAzC,EAA8CvD,CAAC,CAAC+J,MAAF,EAA9C,EAA0DqF,CAA1D,CAAP,CAAlC;IACA,OAAO6G,qBAAqB,CAAC1S,CAAD,EAAIvD,CAAJ,EAAO+I,CAAP,EAAUgK,CAAV,CAA5B;EACH,CAJD,CAKA,OAAOlB,KAAP,EAAc;IACV,OAAO,KAAP;EACH;AACJ;;AACD,SAASiE,iBAAT,CAA2BlN,SAA3B,EAAsC2L,OAAtC,EAA+C3C,SAA/C,EAA0D;EACtD,IAAI;IACA,MAAM;MAAErO,CAAF;MAAKwF,CAAL;MAAQqG,CAAR;MAAWpP;IAAX,IAAiB+V,iBAAiB,CAACnN,SAAD,EAAY2L,OAAZ,EAAqB3C,SAArB,CAAxC;IACA,MAAMmB,CAAC,GAAGkB,wBAAwB,CAACrD,KAAK,CAACiF,cAAN,CAAqBP,IAAI,CAACG,SAA1B,EAAqCrI,QAAQ,CAAC7J,CAAD,CAA7C,EAAkDvD,CAAC,CAAC+J,MAAF,EAAlD,EAA8DqF,CAA9D,CAAD,CAAlC;IACA,OAAO6G,qBAAqB,CAAC1S,CAAD,EAAIvD,CAAJ,EAAO+I,CAAP,EAAUgK,CAAV,CAA5B;EACH,CAJD,CAKA,OAAOlB,KAAP,EAAc;IACV,OAAO,KAAP;EACH;AACJ;;AACD,OAAO,MAAMqE,OAAO,GAAG;EACnBlL,SAAS,EAAEoJ,gBADQ;EAEnBtC,YAAY,EAAEuC,mBAFK;EAGnBZ,IAAI,EAAE0B,WAHa;EAInBpB,MAAM,EAAE4B,aAJW;EAKnB/B,QAAQ,EAAEgC,eALS;EAMnBO,UAAU,EAAEL;AANO,CAAhB;;AAQP5U,KAAK,CAAC+C,IAAN,CAAWkD,cAAX,CAA0B,CAA1B;;AACA,MAAMiP,MAAM,GAAG;EACXC,IAAI,EAAEhX,UADK;EAEXiX,GAAG,EAAE,OAAOC,IAAP,KAAgB,QAAhB,IAA4B,YAAYA,IAAxC,GAA+CA,IAAI,CAACH,MAApD,GAA6D9L;AAFvD,CAAf;AAIA,MAAMgL,IAAI,GAAG;EACTG,SAAS,EAAE,mBADF;EAETF,GAAG,EAAE,aAFI;EAGTC,KAAK,EAAE;AAHE,CAAb;AAKA,MAAMgB,oBAAoB,GAAG,EAA7B;AACA,OAAO,MAAM5F,KAAK,GAAG;EACjB6F,iBAAiB,CAACjO,UAAD,EAAa;IAC1B,IAAI;MACAC,mBAAmB,CAACD,UAAD,CAAnB;MACA,OAAO,IAAP;IACH,CAHD,CAIA,OAAOqJ,KAAP,EAAc;MACV,OAAO,KAAP;IACH;EACJ,CATgB;;EAUjB6E,UAAU,EAAE,CAAClO,UAAD,EAAamO,KAAb,KAAuB;IAC/B,MAAM1V,CAAC,GAAGwH,mBAAmB,CAACD,UAAD,CAA7B;IACA,MAAM4M,CAAC,GAAG3N,aAAa,CAACW,WAAW,CAACuO,KAAD,CAAZ,CAAvB;IACA,OAAOvJ,QAAQ,CAAC3M,GAAG,CAACQ,CAAC,GAAGmU,CAAL,EAAQvV,KAAK,CAACI,CAAd,CAAJ,CAAf;EACH,CAdgB;EAejB2W,aAAa,EAAGpO,UAAD,IAAgB;IAC3B,MAAMvH,CAAC,GAAGwH,mBAAmB,CAACD,UAAD,CAA7B;IACA,OAAO4E,QAAQ,CAACvN,KAAK,CAACI,CAAN,GAAUgB,CAAX,CAAf;EACH,CAlBgB;EAmBjB4V,cAAc,EAAE,CAAC5V,CAAD,EAAI0V,KAAJ,EAAWjN,YAAX,KAA4B;IACxC,MAAM1J,CAAC,GAAGkB,KAAK,CAACgH,OAAN,CAAcjH,CAAd,CAAV;IACA,MAAMmU,CAAC,GAAG3N,aAAa,CAACW,WAAW,CAACuO,KAAD,CAAZ,CAAvB;IACA,MAAMpN,CAAC,GAAGrI,KAAK,CAAC+C,IAAN,CAAWuF,oBAAX,CAAgCxJ,CAAhC,EAAmCoV,CAAnC,EAAsC5V,GAAtC,CAAV;IACA,IAAI,CAAC+J,CAAL,EACI,MAAM,IAAInE,KAAJ,CAAU,2BAAV,CAAN;IACJ,OAAOmE,CAAC,CAACE,UAAF,CAAaC,YAAb,CAAP;EACH,CA1BgB;EA2BjBoN,aAAa,EAAE,CAAC7V,CAAD,EAAI0V,KAAJ,EAAWjN,YAAX,KAA4B;IACvC,MAAM1J,CAAC,GAAGkB,KAAK,CAACgH,OAAN,CAAcjH,CAAd,CAAV;IACA,MAAMmU,CAAC,GAAG3N,aAAa,CAACW,WAAW,CAACuO,KAAD,CAAZ,CAAvB;IACA,OAAO3W,CAAC,CAACqG,QAAF,CAAW+O,CAAX,EAAc3L,UAAd,CAAyBC,YAAzB,CAAP;EACH,CA/BgB;EAgCjBqN,gBAAgB,EAAG3G,IAAD,IAAU;IACxBA,IAAI,GAAGhI,WAAW,CAACgI,IAAD,CAAlB;IACA,IAAIA,IAAI,CAAC5I,MAAL,GAAc,EAAd,IAAoB4I,IAAI,CAAC5I,MAAL,GAAc,IAAtC,EACI,MAAM,IAAIpC,KAAJ,CAAU,uDAAV,CAAN;;IACJ,MAAM+H,GAAG,GAAG1M,GAAG,CAACgH,aAAa,CAAC2I,IAAD,CAAd,EAAsBvQ,KAAK,CAACI,CAAN,GAAUT,GAAhC,CAAH,GAA0CA,GAAtD;;IACA,OAAO4N,QAAQ,CAACD,GAAD,CAAf;EACH,CAtCgB;EAuCjB2F,WAAW,EAAE,YAAsB;IAAA,IAArBkE,WAAqB,uEAAP,EAAO;;IAC/B,IAAIZ,MAAM,CAACE,GAAX,EAAgB;MACZ,OAAOF,MAAM,CAACE,GAAP,CAAWW,eAAX,CAA2B,IAAIvK,UAAJ,CAAesK,WAAf,CAA3B,CAAP;IACH,CAFD,MAGK,IAAIZ,MAAM,CAACC,IAAX,EAAiB;MAClB,MAAM;QAAEvD;MAAF,IAAkBsD,MAAM,CAACC,IAA/B;MACA,OAAO3J,UAAU,CAACI,IAAX,CAAgBgG,WAAW,CAACkE,WAAD,CAA3B,CAAP;IACH,CAHI,MAIA;MACD,MAAM,IAAI5R,KAAJ,CAAU,mDAAV,CAAN;IACH;EACJ,CAlDgB;EAmDjB8R,gBAAgB,EAAE,MAAM;IACpB,OAAOtG,KAAK,CAACmG,gBAAN,CAAuBnG,KAAK,CAACkC,WAAN,CAAkB,EAAlB,CAAvB,CAAP;EACH,CArDgB;EAsDjBnI,UAtDiB;EAuDjBhB,UAvDiB;EAwDjB0C,WAxDiB;EAyDjB5L,GAzDiB;EA0DjBkG,MA1DiB;EA2DjBwQ,MAAM,EAAE,kBAAuB;IAAA,mCAAbC,QAAa;MAAbA,QAAa;IAAA;;IAC3B,IAAIhB,MAAM,CAACE,GAAX,EAAgB;MACZ,MAAMe,MAAM,GAAG,MAAMjB,MAAM,CAACE,GAAP,CAAWgB,MAAX,CAAkBC,MAAlB,CAAyB,SAAzB,EAAoClL,WAAW,CAAC,GAAG+K,QAAJ,CAA/C,CAArB;MACA,OAAO,IAAI1K,UAAJ,CAAe2K,MAAf,CAAP;IACH,CAHD,MAIK,IAAIjB,MAAM,CAACC,IAAX,EAAiB;MAClB,MAAM;QAAEmB;MAAF,IAAiBpB,MAAM,CAACC,IAA9B;MACA,MAAMjG,IAAI,GAAGoH,UAAU,CAAC,QAAD,CAAvB;MACAJ,QAAQ,CAACK,OAAT,CAAkBrI,CAAD,IAAOgB,IAAI,CAACsH,MAAL,CAAYtI,CAAZ,CAAxB;MACA,OAAO1C,UAAU,CAACI,IAAX,CAAgBsD,IAAI,CAACmH,MAAL,EAAhB,CAAP;IACH,CALI,MAMA;MACD,MAAM,IAAInS,KAAJ,CAAU,8CAAV,CAAN;IACH;EACJ,CAzEgB;EA0EjByL,UAAU,EAAE,gBAAOa,GAAP,EAA4B;IAAA,mCAAb0F,QAAa;MAAbA,QAAa;IAAA;;IACpC,IAAIhB,MAAM,CAACE,GAAX,EAAgB;MACZ,MAAMqB,IAAI,GAAG,MAAMvB,MAAM,CAACE,GAAP,CAAWgB,MAAX,CAAkBM,SAAlB,CAA4B,KAA5B,EAAmClG,GAAnC,EAAwC;QAAEtG,IAAI,EAAE,MAAR;QAAgBgF,IAAI,EAAE;UAAEhF,IAAI,EAAE;QAAR;MAAtB,CAAxC,EAAqF,KAArF,EAA4F,CAAC,MAAD,CAA5F,CAAnB;MACA,MAAMmJ,OAAO,GAAGlI,WAAW,CAAC,GAAG+K,QAAJ,CAA3B;MACA,MAAMC,MAAM,GAAG,MAAMjB,MAAM,CAACE,GAAP,CAAWgB,MAAX,CAAkB7D,IAAlB,CAAuB,MAAvB,EAA+BkE,IAA/B,EAAqCpD,OAArC,CAArB;MACA,OAAO,IAAI7H,UAAJ,CAAe2K,MAAf,CAAP;IACH,CALD,MAMK,IAAIjB,MAAM,CAACC,IAAX,EAAiB;MAClB,MAAM;QAAEwB;MAAF,IAAiBzB,MAAM,CAACC,IAA9B;MACA,MAAMjG,IAAI,GAAGyH,UAAU,CAAC,QAAD,EAAWnG,GAAX,CAAvB;MACA0F,QAAQ,CAACK,OAAT,CAAkBrI,CAAD,IAAOgB,IAAI,CAACsH,MAAL,CAAYtI,CAAZ,CAAxB;MACA,OAAO1C,UAAU,CAACI,IAAX,CAAgBsD,IAAI,CAACmH,MAAL,EAAhB,CAAP;IACH,CALI,MAMA;MACD,MAAM,IAAInS,KAAJ,CAAU,mDAAV,CAAN;IACH;EACJ,CA1FgB;EA2FjB0S,UAAU,EAAExN,SA3FK;EA4FjByG,cAAc,EAAEzG,SA5FC;EA6FjB+K,UAAU,EAAE,gBAAO0C,GAAP,EAA4B;IACpC,IAAIC,IAAI,GAAGxB,oBAAoB,CAACuB,GAAD,CAA/B;;IACA,IAAIC,IAAI,KAAK1N,SAAb,EAAwB;MACpB,MAAM2N,IAAI,GAAG,MAAMrH,KAAK,CAACuG,MAAN,CAAazK,UAAU,CAACI,IAAX,CAAgBiL,GAAhB,EAAsBG,CAAD,IAAOA,CAAC,CAACC,UAAF,CAAa,CAAb,CAA5B,CAAb,CAAnB;MACAH,IAAI,GAAG3L,WAAW,CAAC4L,IAAD,EAAOA,IAAP,CAAlB;MACAzB,oBAAoB,CAACuB,GAAD,CAApB,GAA4BC,IAA5B;IACH;;IANmC,mCAAbZ,QAAa;MAAbA,QAAa;IAAA;;IAOpC,OAAOxG,KAAK,CAACuG,MAAN,CAAaa,IAAb,EAAmB,GAAGZ,QAAtB,CAAP;EACH,CArGgB;EAsGjBvB,cAAc,EAAE,UAACkC,GAAD,EAAsB;IAClC,IAAI,OAAOnH,KAAK,CAACkH,UAAb,KAA4B,UAAhC,EACI,MAAM,IAAI1S,KAAJ,CAAU,mDAAV,CAAN;IACJ,IAAI4S,IAAI,GAAGxB,oBAAoB,CAACuB,GAAD,CAA/B;;IACA,IAAIC,IAAI,KAAK1N,SAAb,EAAwB;MACpB,MAAM2N,IAAI,GAAGrH,KAAK,CAACkH,UAAN,CAAiBpL,UAAU,CAACI,IAAX,CAAgBiL,GAAhB,EAAsBG,CAAD,IAAOA,CAAC,CAACC,UAAF,CAAa,CAAb,CAA5B,CAAjB,CAAb;MACAH,IAAI,GAAG3L,WAAW,CAAC4L,IAAD,EAAOA,IAAP,CAAlB;MACAzB,oBAAoB,CAACuB,GAAD,CAApB,GAA4BC,IAA5B;IACH;;IARiC,mCAAbZ,QAAa;MAAbA,QAAa;IAAA;;IASlC,OAAOxG,KAAK,CAACkH,UAAN,CAAiBE,IAAjB,EAAuB,GAAGZ,QAA1B,CAAP;EACH,CAhHgB;;EAiHjBgB,UAAU,GAAqC;IAAA,IAApC1S,UAAoC,uEAAvB,CAAuB;IAAA,IAApBY,KAAoB,uEAAZpF,KAAK,CAAC+C,IAAM;IAC3C,MAAMiC,MAAM,GAAGI,KAAK,KAAKpF,KAAK,CAAC+C,IAAhB,GAAuBqC,KAAvB,GAA+B,IAAIpF,KAAJ,CAAUoF,KAAK,CAAC/F,CAAhB,EAAmB+F,KAAK,CAACxF,CAAzB,CAA9C;;IACAoF,MAAM,CAACiB,cAAP,CAAsBzB,UAAtB;;IACAQ,MAAM,CAACG,QAAP,CAAgB3G,GAAhB;IACA,OAAOwG,MAAP;EACH;;AAtHgB,CAAd"},"metadata":{},"sourceType":"module"}