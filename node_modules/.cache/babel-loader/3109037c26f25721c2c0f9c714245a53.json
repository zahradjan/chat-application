{"ast":null,"code":"// @ts-nocheck\n'use strict';\n/**\n * This code is based on `latency-monitor` (https://github.com/mlucool/latency-monitor) by `mlucool` (https://github.com/mlucool), available under Apache License 2.0 (https://github.com/mlucool/latency-monitor/blob/master/LICENSE)\n */\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _assertThisInitialized = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar VisibilityChangeEmitter = require('./visibility-change-emitter');\n\nvar debug = require('debug')('latency-monitor:LatencyMonitor');\n/**\n * @typedef {Object} SummaryObject\n * @property {number} events How many events were called\n * @property {number} minMS What was the min time for a cb to be called\n * @property {number} maxMS What was the max time for a cb to be called\n * @property {number} avgMs What was the average time for a cb to be called\n * @property {number} lengthMs How long this interval was in ms\n *\n * @typedef {Object} LatencyMonitorOptions\n * @property {number} [latencyCheckIntervalMs=500] - How often to add a latency check event (ms)\n * @property {number} [dataEmitIntervalMs=5000] - How often to summarize latency check events. null or 0 disables event firing\n * @property {Function} [asyncTestFn] - What cb-style async function to use\n * @property {number} [latencyRandomPercentage=5] - What percent (+/-) of latencyCheckIntervalMs should we randomly use? This helps avoid alignment to other events.\n */\n\n/**\n * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling\n * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.\n * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.\n *\n * @extends {EventEmitter}\n *\n * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop\n * and timing how long it takes to get back.\n *\n * @example\n * const monitor = new LatencyMonitor();\n * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));\n *\n * @example\n * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});\n * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));\n */\n\n\nvar LatencyMonitor = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(LatencyMonitor, _EventEmitter);\n\n  var _super = _createSuper(LatencyMonitor);\n\n  /**\n   * @class\n   * @param {LatencyMonitorOptions} [options]\n   */\n  function LatencyMonitor() {\n    var _this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        latencyCheckIntervalMs = _ref.latencyCheckIntervalMs,\n        dataEmitIntervalMs = _ref.dataEmitIntervalMs,\n        asyncTestFn = _ref.asyncTestFn,\n        latencyRandomPercentage = _ref.latencyRandomPercentage;\n\n    _classCallCheck(this, LatencyMonitor);\n\n    _this = _super.call(this);\n\n    var that = _assertThisInitialized(_this); // 0 isn't valid here, so its ok to use ||\n\n\n    that.latencyCheckIntervalMs = latencyCheckIntervalMs || 500; // 0.5s\n\n    that.latencyRandomPercentage = latencyRandomPercentage || 10;\n    that._latecyCheckMultiply = 2 * (that.latencyRandomPercentage / 100.0) * that.latencyCheckIntervalMs;\n    that._latecyCheckSubtract = that._latecyCheckMultiply / 2;\n    that.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? undefined : dataEmitIntervalMs || 5 * 1000; // 5s\n\n    debug('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s', that.latencyCheckIntervalMs, that.dataEmitIntervalMs);\n\n    if (that.dataEmitIntervalMs) {\n      debug('Expecting ~%s events per summary', that.latencyCheckIntervalMs / that.dataEmitIntervalMs);\n    } else {\n      debug('Not emitting summaries');\n    }\n\n    that.asyncTestFn = asyncTestFn; // If there is no asyncFn, we measure latency\n\n    return _this;\n  }\n\n  _createClass(LatencyMonitor, [{\n    key: \"start\",\n    value: function start() {\n      var _this2 = this;\n\n      // If process: use high resolution timer\n      if (globalThis.process && globalThis.process.hrtime) {\n        // eslint-disable-line no-undef\n        debug('Using process.hrtime for timing');\n        this.now = globalThis.process.hrtime; // eslint-disable-line no-undef\n\n        this.getDeltaMS = function (startTime) {\n          var hrtime = _this2.now(startTime);\n\n          return hrtime[0] * 1000 + hrtime[1] / 1000000;\n        }; // Let's try for a timer that only monotonically increases\n\n      } else if (typeof window !== 'undefined' && window.performance && window.performance.now) {\n        debug('Using performance.now for timing');\n        this.now = window.performance.now.bind(window.performance);\n\n        this.getDeltaMS = function (startTime) {\n          return Math.round(_this2.now() - startTime);\n        };\n      } else {\n        debug('Using Date.now for timing');\n        this.now = Date.now;\n\n        this.getDeltaMS = function (startTime) {\n          return _this2.now() - startTime;\n        };\n      }\n\n      this._latencyData = this._initLatencyData(); // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,\n      // so we fall back to another library\n      // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs\n\n      if (isBrowser()) {\n        this._visibilityChangeEmitter = new VisibilityChangeEmitter();\n\n        this._visibilityChangeEmitter.on('visibilityChange', function (pageInFocus) {\n          if (pageInFocus) {\n            _this2._startTimers();\n          } else {\n            _this2._emitSummary();\n\n            _this2._stopTimers();\n          }\n        });\n      }\n\n      if (!this._visibilityChangeEmitter || this._visibilityChangeEmitter.isVisible()) {\n        this._startTimers();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._stopTimers();\n    }\n    /**\n     * Start internal timers\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_startTimers\",\n    value: function _startTimers() {\n      var _this3 = this;\n\n      // Timer already started, ignore this\n      if (this._checkLatencyID) {\n        return;\n      }\n\n      this._checkLatency();\n\n      if (this.dataEmitIntervalMs) {\n        this._emitIntervalID = setInterval(function () {\n          return _this3._emitSummary();\n        }, this.dataEmitIntervalMs);\n\n        if (typeof this._emitIntervalID.unref === 'function') {\n          this._emitIntervalID.unref(); // Doesn't block exit\n\n        }\n      }\n    }\n    /**\n     * Stop internal timers\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_stopTimers\",\n    value: function _stopTimers() {\n      if (this._checkLatencyID) {\n        clearTimeout(this._checkLatencyID);\n        this._checkLatencyID = undefined;\n      }\n\n      if (this._emitIntervalID) {\n        clearInterval(this._emitIntervalID);\n        this._emitIntervalID = undefined;\n      }\n    }\n    /**\n     * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_emitSummary\",\n    value: function _emitSummary() {\n      var summary = this.getSummary();\n\n      if (summary.events > 0) {\n        this.emit('data', summary);\n      }\n    }\n    /**\n     * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,\n     * it will not count for this time period\n     *\n     * @returns {SummaryObject}\n     */\n\n  }, {\n    key: \"getSummary\",\n    value: function getSummary() {\n      // We might want to adjust for the number of expected events\n      // Example: first 1 event it comes back, then such a long blocker that the next emit check comes\n      // Then this fires - looks like no latency!!\n      var latency = {\n        events: this._latencyData.events,\n        minMs: this._latencyData.minMs,\n        maxMs: this._latencyData.maxMs,\n        avgMs: this._latencyData.events ? this._latencyData.totalMs / this._latencyData.events : Number.POSITIVE_INFINITY,\n        lengthMs: this.getDeltaMS(this._latencyData.startTime)\n      };\n      this._latencyData = this._initLatencyData(); // Clear\n\n      debug('Summary: %O', latency);\n      return latency;\n    }\n    /**\n     * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,\n     * it will simply report on event loop latency.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_checkLatency\",\n    value: function _checkLatency() {\n      var _this4 = this;\n\n      var that = this; // Randomness is needed to avoid alignment by accident to regular things in the event loop\n\n      var randomness = Math.random() * that._latecyCheckMultiply - that._latecyCheckSubtract; // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset\n\n\n      var localData = {\n        deltaOffset: Math.ceil(that.latencyCheckIntervalMs + randomness),\n        startTime: that.now()\n      };\n\n      var cb = function cb() {\n        // We are already stopped, ignore this datapoint\n        if (!_this4._checkLatencyID) {\n          return;\n        }\n\n        var deltaMS = that.getDeltaMS(localData.startTime) - localData.deltaOffset;\n\n        that._checkLatency(); // Start again ASAP\n        // Add the data point. If this gets complex, refactor it\n\n\n        that._latencyData.events++;\n        that._latencyData.minMs = Math.min(that._latencyData.minMs, deltaMS);\n        that._latencyData.maxMs = Math.max(that._latencyData.maxMs, deltaMS);\n        that._latencyData.totalMs += deltaMS;\n        debug('MS: %s Data: %O', deltaMS, that._latencyData);\n      };\n\n      debug('localData: %O', localData);\n      this._checkLatencyID = setTimeout(function () {\n        // This gets rid of including event loop\n        if (that.asyncTestFn) {\n          // Clear timing related things\n          localData.deltaOffset = 0;\n          localData.startTime = that.now();\n          that.asyncTestFn(cb);\n        } else {\n          // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.\n          // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.\n          localData.deltaOffset -= 1; // If there is no function to test, we mean check latency which is a special case that is really cb => cb()\n          // We avoid that for the few extra function all overheads. Also, we want to keep the timers different\n\n          cb();\n        }\n      }, localData.deltaOffset);\n\n      if (typeof this._checkLatencyID.unref === 'function') {\n        this._checkLatencyID.unref(); // Doesn't block exit\n\n      }\n    }\n  }, {\n    key: \"_initLatencyData\",\n    value: function _initLatencyData() {\n      return {\n        startTime: this.now(),\n        minMs: Number.POSITIVE_INFINITY,\n        maxMs: Number.NEGATIVE_INFINITY,\n        events: 0,\n        totalMs: 0\n      };\n    }\n  }]);\n\n  return LatencyMonitor;\n}(EventEmitter);\n\nfunction isBrowser() {\n  return typeof window !== 'undefined';\n}\n\nmodule.exports = LatencyMonitor;","map":{"version":3,"names":["require","EventEmitter","VisibilityChangeEmitter","debug","LatencyMonitor","latencyCheckIntervalMs","dataEmitIntervalMs","asyncTestFn","latencyRandomPercentage","that","_latecyCheckMultiply","_latecyCheckSubtract","undefined","globalThis","process","hrtime","now","getDeltaMS","startTime","window","performance","bind","Math","round","Date","_latencyData","_initLatencyData","isBrowser","_visibilityChangeEmitter","on","pageInFocus","_startTimers","_emitSummary","_stopTimers","isVisible","_checkLatencyID","_checkLatency","_emitIntervalID","setInterval","unref","clearTimeout","clearInterval","summary","getSummary","events","emit","latency","minMs","maxMs","avgMs","totalMs","Number","POSITIVE_INFINITY","lengthMs","randomness","random","localData","deltaOffset","ceil","cb","deltaMS","min","max","setTimeout","NEGATIVE_INFINITY","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/connection-manager/latency-monitor.js"],"sourcesContent":["// @ts-nocheck\n'use strict'\n\n/**\n * This code is based on `latency-monitor` (https://github.com/mlucool/latency-monitor) by `mlucool` (https://github.com/mlucool), available under Apache License 2.0 (https://github.com/mlucool/latency-monitor/blob/master/LICENSE)\n */\n\nconst { EventEmitter } = require('events')\nconst VisibilityChangeEmitter = require('./visibility-change-emitter')\nconst debug = require('debug')('latency-monitor:LatencyMonitor')\n\n/**\n * @typedef {Object} SummaryObject\n * @property {number} events How many events were called\n * @property {number} minMS What was the min time for a cb to be called\n * @property {number} maxMS What was the max time for a cb to be called\n * @property {number} avgMs What was the average time for a cb to be called\n * @property {number} lengthMs How long this interval was in ms\n *\n * @typedef {Object} LatencyMonitorOptions\n * @property {number} [latencyCheckIntervalMs=500] - How often to add a latency check event (ms)\n * @property {number} [dataEmitIntervalMs=5000] - How often to summarize latency check events. null or 0 disables event firing\n * @property {Function} [asyncTestFn] - What cb-style async function to use\n * @property {number} [latencyRandomPercentage=5] - What percent (+/-) of latencyCheckIntervalMs should we randomly use? This helps avoid alignment to other events.\n */\n\n/**\n * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling\n * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.\n * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.\n *\n * @extends {EventEmitter}\n *\n * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop\n * and timing how long it takes to get back.\n *\n * @example\n * const monitor = new LatencyMonitor();\n * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));\n *\n * @example\n * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});\n * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));\n */\nclass LatencyMonitor extends EventEmitter {\n  /**\n   * @class\n   * @param {LatencyMonitorOptions} [options]\n   */\n  constructor ({ latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage } = {}) {\n    super()\n    const that = this\n\n    // 0 isn't valid here, so its ok to use ||\n    that.latencyCheckIntervalMs = latencyCheckIntervalMs || 500 // 0.5s\n    that.latencyRandomPercentage = latencyRandomPercentage || 10\n    that._latecyCheckMultiply = 2 * (that.latencyRandomPercentage / 100.0) * that.latencyCheckIntervalMs\n    that._latecyCheckSubtract = that._latecyCheckMultiply / 2\n\n    that.dataEmitIntervalMs = (dataEmitIntervalMs === null || dataEmitIntervalMs === 0)\n      ? undefined\n      : dataEmitIntervalMs || 5 * 1000 // 5s\n    debug('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s',\n      that.latencyCheckIntervalMs, that.dataEmitIntervalMs)\n    if (that.dataEmitIntervalMs) {\n      debug('Expecting ~%s events per summary', that.latencyCheckIntervalMs / that.dataEmitIntervalMs)\n    } else {\n      debug('Not emitting summaries')\n    }\n\n    that.asyncTestFn = asyncTestFn // If there is no asyncFn, we measure latency\n  }\n\n  start () {\n    // If process: use high resolution timer\n    if (globalThis.process && globalThis.process.hrtime) { // eslint-disable-line no-undef\n      debug('Using process.hrtime for timing')\n      this.now = globalThis.process.hrtime // eslint-disable-line no-undef\n      this.getDeltaMS = (startTime) => {\n        const hrtime = this.now(startTime)\n        return (hrtime[0] * 1000) + (hrtime[1] / 1000000)\n      }\n      // Let's try for a timer that only monotonically increases\n    } else if (typeof window !== 'undefined' && window.performance && window.performance.now) {\n      debug('Using performance.now for timing')\n      this.now = window.performance.now.bind(window.performance)\n      this.getDeltaMS = (startTime) => Math.round(this.now() - startTime)\n    } else {\n      debug('Using Date.now for timing')\n      this.now = Date.now\n      this.getDeltaMS = (startTime) => this.now() - startTime\n    }\n\n    this._latencyData = this._initLatencyData()\n\n    // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,\n    // so we fall back to another library\n    // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs\n    if (isBrowser()) {\n      this._visibilityChangeEmitter = new VisibilityChangeEmitter()\n\n      this._visibilityChangeEmitter.on('visibilityChange', (pageInFocus) => {\n        if (pageInFocus) {\n          this._startTimers()\n        } else {\n          this._emitSummary()\n          this._stopTimers()\n        }\n      })\n    }\n\n    if (!this._visibilityChangeEmitter || this._visibilityChangeEmitter.isVisible()) {\n      this._startTimers()\n    }\n  }\n\n  stop () {\n    this._stopTimers()\n  }\n\n  /**\n   * Start internal timers\n   *\n   * @private\n   */\n  _startTimers () {\n    // Timer already started, ignore this\n    if (this._checkLatencyID) {\n      return\n    }\n    this._checkLatency()\n    if (this.dataEmitIntervalMs) {\n      this._emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs)\n      if (typeof this._emitIntervalID.unref === 'function') {\n        this._emitIntervalID.unref() // Doesn't block exit\n      }\n    }\n  }\n\n  /**\n   * Stop internal timers\n   *\n   * @private\n   */\n  _stopTimers () {\n    if (this._checkLatencyID) {\n      clearTimeout(this._checkLatencyID)\n      this._checkLatencyID = undefined\n    }\n    if (this._emitIntervalID) {\n      clearInterval(this._emitIntervalID)\n      this._emitIntervalID = undefined\n    }\n  }\n\n  /**\n   * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show\n   *\n   * @private\n   */\n  _emitSummary () {\n    const summary = this.getSummary()\n    if (summary.events > 0) {\n      this.emit('data', summary)\n    }\n  }\n\n  /**\n   * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,\n   * it will not count for this time period\n   *\n   * @returns {SummaryObject}\n   */\n  getSummary () {\n    // We might want to adjust for the number of expected events\n    // Example: first 1 event it comes back, then such a long blocker that the next emit check comes\n    // Then this fires - looks like no latency!!\n    const latency = {\n      events: this._latencyData.events,\n      minMs: this._latencyData.minMs,\n      maxMs: this._latencyData.maxMs,\n      avgMs: this._latencyData.events\n        ? this._latencyData.totalMs / this._latencyData.events\n        : Number.POSITIVE_INFINITY,\n      lengthMs: this.getDeltaMS(this._latencyData.startTime)\n    }\n    this._latencyData = this._initLatencyData() // Clear\n\n    debug('Summary: %O', latency)\n    return latency\n  }\n\n  /**\n   * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,\n   * it will simply report on event loop latency.\n   *\n   * @private\n   */\n  _checkLatency () {\n    const that = this\n    // Randomness is needed to avoid alignment by accident to regular things in the event loop\n    const randomness = (Math.random() * that._latecyCheckMultiply) - that._latecyCheckSubtract\n\n    // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset\n    const localData = {\n      deltaOffset: Math.ceil(that.latencyCheckIntervalMs + randomness),\n      startTime: that.now()\n    }\n\n    const cb = () => {\n      // We are already stopped, ignore this datapoint\n      if (!this._checkLatencyID) {\n        return\n      }\n      const deltaMS = that.getDeltaMS(localData.startTime) - localData.deltaOffset\n      that._checkLatency() // Start again ASAP\n\n      // Add the data point. If this gets complex, refactor it\n      that._latencyData.events++\n      that._latencyData.minMs = Math.min(that._latencyData.minMs, deltaMS)\n      that._latencyData.maxMs = Math.max(that._latencyData.maxMs, deltaMS)\n      that._latencyData.totalMs += deltaMS\n      debug('MS: %s Data: %O', deltaMS, that._latencyData)\n    }\n    debug('localData: %O', localData)\n\n    this._checkLatencyID = setTimeout(() => {\n      // This gets rid of including event loop\n      if (that.asyncTestFn) {\n        // Clear timing related things\n        localData.deltaOffset = 0\n        localData.startTime = that.now()\n        that.asyncTestFn(cb)\n      } else {\n        // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.\n        // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.\n        localData.deltaOffset -= 1\n        // If there is no function to test, we mean check latency which is a special case that is really cb => cb()\n        // We avoid that for the few extra function all overheads. Also, we want to keep the timers different\n        cb()\n      }\n    }, localData.deltaOffset)\n\n    if (typeof this._checkLatencyID.unref === 'function') {\n      this._checkLatencyID.unref() // Doesn't block exit\n    }\n  }\n\n  _initLatencyData () {\n    return {\n      startTime: this.now(),\n      minMs: Number.POSITIVE_INFINITY,\n      maxMs: Number.NEGATIVE_INFINITY,\n      events: 0,\n      totalMs: 0\n    }\n  }\n}\n\nfunction isBrowser () {\n  return typeof window !== 'undefined'\n}\n\nmodule.exports = LatencyMonitor\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}