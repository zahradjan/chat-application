{"ast":null,"code":"'use strict';\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst Digest = require('multiformats/hashes/digest');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst mafmt = require('mafmt');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst {\n  URL\n} = require('iso-url');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/;\nconst pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/;\nconst defaultProtocolMatch = 1;\nconst defaultHashMath = 2; // CID, libp2p-key or DNSLink\n\nconst subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/;\nconst subdomainIdMatch = 1;\nconst subdomainProtocolMatch = 2; // Fully qualified domain name (FQDN) that has an explicit .tld suffix\n\nconst fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;\n/**\n * @param {*} hash\n */\n\nfunction isMultihash(hash) {\n  const formatted = convertToString(hash);\n\n  try {\n    Digest.decode(base58btc.decode('z' + formatted));\n  } catch {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {*} hash\n */\n\n\nfunction isBase32EncodedMultibase(hash) {\n  try {\n    base32.decode(hash);\n  } catch {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {*} hash\n */\n\n\nfunction isCID(hash) {\n  try {\n    if (typeof hash === 'string') {\n      return Boolean(CID.parse(hash));\n    }\n\n    if (hash instanceof Uint8Array) {\n      return Boolean(CID.decode(hash));\n    }\n\n    return Boolean(CID.asCID(hash)); // eslint-disable-line no-new\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * @param {*} input\n */\n\n\nfunction isMultiaddr(input) {\n  if (!input) return false;\n  if (Multiaddr.isMultiaddr(input)) return true;\n\n  try {\n    new Multiaddr(input); // eslint-disable-line no-new\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * @param {string | Uint8Array | Multiaddr} input\n */\n\n\nfunction isPeerMultiaddr(input) {\n  return isMultiaddr(input) && mafmt.P2P.matches(input);\n}\n/**\n * @param {string | Uint8Array} input\n * @param {RegExp | string} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=2]\n */\n\n\nfunction isIpfs(input, pattern) {\n  let protocolMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultProtocolMatch;\n  let hashMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultHashMath;\n  const formatted = convertToString(input);\n\n  if (!formatted) {\n    return false;\n  }\n\n  const match = formatted.match(pattern);\n\n  if (!match) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false;\n  }\n\n  let hash = match[hashMatch];\n\n  if (hash && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority component anyway)\n    hash = hash.toLowerCase();\n  }\n\n  return isCID(hash);\n}\n/**\n *\n * @param {string | Uint8Array} input\n * @param {string | RegExp} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=1]\n */\n\n\nfunction isIpns(input, pattern) {\n  let protocolMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultProtocolMatch;\n  let hashMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultHashMath;\n  const formatted = convertToString(input);\n\n  if (!formatted) {\n    return false;\n  }\n\n  const match = formatted.match(pattern);\n\n  if (!match) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false;\n  }\n\n  let ipnsId = match[hashMatch];\n\n  if (ipnsId && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase(); // Check if it is cidv1\n\n    if (isCID(ipnsId)) return true; // Check if it looks like FQDN\n\n    try {\n      if (!ipnsId.includes('.') && ipnsId.includes('-')) {\n        // name without tld, assuming its inlined into a single DNS label\n        // (https://github.com/ipfs/in-web-browsers/issues/169)\n        // en-wikipedia--on--ipfs-org → en.wikipedia-on-ipfs.org\n        ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-');\n      } // URL implementation in web browsers forces lowercase of the hostname\n\n\n      const {\n        hostname\n      } = new URL(`http://${ipnsId}`); // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n\n      return fqdnWithTld.test(hostname);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @param {any} input\n */\n\n\nfunction isString(input) {\n  return typeof input === 'string';\n}\n/**\n * @param {Uint8Array | string} input\n */\n\n\nfunction convertToString(input) {\n  if (input instanceof Uint8Array) {\n    return uint8ArrayToString(input, 'base58btc');\n  }\n\n  if (isString(input)) {\n    return input;\n  }\n\n  return false;\n}\n/**\n * @param {string | Uint8Array} url\n */\n\n\nconst ipfsSubdomain = url => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\n/**\n * @param {string | Uint8Array} url\n */\n\n\nconst ipnsSubdomain = url => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\n/**\n * @param {string | Uint8Array} url\n */\n\n\nconst subdomain = url => ipfsSubdomain(url) || ipnsSubdomain(url);\n/**\n * @param {string | Uint8Array} url\n */\n\n\nconst ipfsUrl = url => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url);\n/**\n * @param {string | Uint8Array} url\n */\n\n\nconst ipnsUrl = url => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url);\n/**\n * @param {string | Uint8Array} url\n */\n\n\nconst url = url => ipfsUrl(url) || ipnsUrl(url) || subdomain(url);\n/**\n * @param {string | Uint8Array} path\n */\n\n\nconst path = path => isIpfs(path, pathPattern) || isIpns(path, pathPattern);\n\nmodule.exports = {\n  multihash: isMultihash,\n  multiaddr: isMultiaddr,\n  peerMultiaddr: isPeerMultiaddr,\n  cid: isCID,\n\n  /**\n   * @param {CID | string | Uint8Array} cid\n   */\n  base32cid: cid => isBase32EncodedMultibase(cid) && isCID(cid),\n  ipfsSubdomain,\n  ipnsSubdomain,\n  subdomain,\n  subdomainGatewayPattern,\n  ipfsUrl,\n  ipnsUrl,\n  url,\n  pathGatewayPattern: pathGatewayPattern,\n\n  /**\n   * @param {string | Uint8Array} path\n   */\n  ipfsPath: path => isIpfs(path, pathPattern),\n\n  /**\n   * @param {string | Uint8Array} path\n   */\n  ipnsPath: path => isIpns(path, pathPattern),\n  path,\n  pathPattern,\n\n  /**\n   * @param {string | Uint8Array} x\n   */\n  urlOrPath: x => url(x) || path(x),\n\n  /**\n   * @param {string | Uint8Array | CID} path\n   */\n  cidPath: path => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\n};","map":{"version":3,"names":["base58btc","require","base32","Digest","Multiaddr","mafmt","CID","URL","toString","uint8ArrayToString","pathGatewayPattern","pathPattern","defaultProtocolMatch","defaultHashMath","subdomainGatewayPattern","subdomainIdMatch","subdomainProtocolMatch","fqdnWithTld","isMultihash","hash","formatted","convertToString","decode","isBase32EncodedMultibase","isCID","Boolean","parse","Uint8Array","asCID","e","isMultiaddr","input","isPeerMultiaddr","P2P","matches","isIpfs","pattern","protocolMatch","hashMatch","match","toLowerCase","isIpns","ipnsId","includes","replace","hostname","test","isString","ipfsSubdomain","url","ipnsSubdomain","subdomain","ipfsUrl","ipnsUrl","path","module","exports","multihash","multiaddr","peerMultiaddr","cid","base32cid","ipfsPath","ipnsPath","urlOrPath","x","cidPath"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/is-ipfs/src/index.js"],"sourcesContent":["'use strict'\n\nconst { base58btc } = require('multiformats/bases/base58')\nconst { base32 } = require('multiformats/bases/base32')\nconst Digest = require('multiformats/hashes/digest')\nconst { Multiaddr } = require('multiaddr')\nconst mafmt = require('mafmt')\nconst { CID } = require('multiformats/cid')\nconst { URL } = require('iso-url')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/\nconst pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/\nconst defaultProtocolMatch = 1\nconst defaultHashMath = 2\n\n// CID, libp2p-key or DNSLink\nconst subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/\nconst subdomainIdMatch = 1\nconst subdomainProtocolMatch = 2\n\n// Fully qualified domain name (FQDN) that has an explicit .tld suffix\nconst fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/\n\n/**\n * @param {*} hash\n */\nfunction isMultihash (hash) {\n  const formatted = convertToString(hash)\n  try {\n    Digest.decode(base58btc.decode('z' + formatted))\n  } catch {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {*} hash\n */\nfunction isBase32EncodedMultibase (hash) {\n  try {\n    base32.decode(hash)\n  } catch {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {*} hash\n */\nfunction isCID (hash) {\n  try {\n    if (typeof hash === 'string') {\n      return Boolean(CID.parse(hash))\n    }\n\n    if (hash instanceof Uint8Array) {\n      return Boolean(CID.decode(hash))\n    }\n\n    return Boolean(CID.asCID(hash)) // eslint-disable-line no-new\n  } catch (e) {\n    return false\n  }\n}\n\n/**\n * @param {*} input\n */\nfunction isMultiaddr (input) {\n  if (!input) return false\n  if (Multiaddr.isMultiaddr(input)) return true\n  try {\n    new Multiaddr(input) // eslint-disable-line no-new\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\n/**\n * @param {string | Uint8Array | Multiaddr} input\n */\nfunction isPeerMultiaddr (input) {\n  return isMultiaddr(input) && mafmt.P2P.matches(input)\n}\n\n/**\n * @param {string | Uint8Array} input\n * @param {RegExp | string} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=2]\n */\nfunction isIpfs (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n  const formatted = convertToString(input)\n  if (!formatted) {\n    return false\n  }\n\n  const match = formatted.match(pattern)\n  if (!match) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false\n  }\n\n  let hash = match[hashMatch]\n\n  if (hash && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority component anyway)\n    hash = hash.toLowerCase()\n  }\n\n  return isCID(hash)\n}\n\n/**\n *\n * @param {string | Uint8Array} input\n * @param {string | RegExp} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=1]\n */\nfunction isIpns (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n  const formatted = convertToString(input)\n  if (!formatted) {\n    return false\n  }\n  const match = formatted.match(pattern)\n  if (!match) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false\n  }\n\n  let ipnsId = match[hashMatch]\n\n  if (ipnsId && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase()\n    // Check if it is cidv1\n    if (isCID(ipnsId)) return true\n    // Check if it looks like FQDN\n    try {\n      if (!ipnsId.includes('.') && ipnsId.includes('-')) {\n        // name without tld, assuming its inlined into a single DNS label\n        // (https://github.com/ipfs/in-web-browsers/issues/169)\n        // en-wikipedia--on--ipfs-org → en.wikipedia-on-ipfs.org\n        ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-')\n      }\n      // URL implementation in web browsers forces lowercase of the hostname\n      const { hostname } = new URL(`http://${ipnsId}`) // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n      return fqdnWithTld.test(hostname)\n    } catch (e) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {any} input\n */\nfunction isString (input) {\n  return typeof input === 'string'\n}\n\n/**\n * @param {Uint8Array | string} input\n */\nfunction convertToString (input) {\n  if (input instanceof Uint8Array) {\n    return uint8ArrayToString(input, 'base58btc')\n  }\n\n  if (isString(input)) {\n    return input\n  }\n\n  return false\n}\n\n/**\n * @param {string | Uint8Array} url\n */\nconst ipfsSubdomain = (url) => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\n/**\n * @param {string | Uint8Array} url\n */\nconst ipnsSubdomain = (url) => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\n/**\n * @param {string | Uint8Array} url\n */\nconst subdomain = (url) => ipfsSubdomain(url) || ipnsSubdomain(url)\n\n/**\n * @param {string | Uint8Array} url\n */\nconst ipfsUrl = (url) => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url)\n/**\n * @param {string | Uint8Array} url\n */\nconst ipnsUrl = (url) => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url)\n/**\n * @param {string | Uint8Array} url\n */\nconst url = (url) => ipfsUrl(url) || ipnsUrl(url) || subdomain(url)\n\n/**\n * @param {string | Uint8Array} path\n */\nconst path = (path) => isIpfs(path, pathPattern) || isIpns(path, pathPattern)\n\nmodule.exports = {\n  multihash: isMultihash,\n  multiaddr: isMultiaddr,\n  peerMultiaddr: isPeerMultiaddr,\n  cid: isCID,\n  /**\n   * @param {CID | string | Uint8Array} cid\n   */\n  base32cid: (cid) => (isBase32EncodedMultibase(cid) && isCID(cid)),\n  ipfsSubdomain,\n  ipnsSubdomain,\n  subdomain,\n  subdomainGatewayPattern,\n  ipfsUrl,\n  ipnsUrl,\n  url,\n  pathGatewayPattern: pathGatewayPattern,\n  /**\n   * @param {string | Uint8Array} path\n   */\n  ipfsPath: (path) => isIpfs(path, pathPattern),\n  /**\n   * @param {string | Uint8Array} path\n   */\n  ipnsPath: (path) => isIpns(path, pathPattern),\n  path,\n  pathPattern,\n  /**\n   * @param {string | Uint8Array} x\n   */\n  urlOrPath: (x) => url(x) || path(x),\n  /**\n   * @param {string | Uint8Array | CID} path\n   */\n  cidPath: path => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}