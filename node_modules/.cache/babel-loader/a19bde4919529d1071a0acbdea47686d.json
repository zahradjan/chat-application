{"ast":null,"code":"'use strict';\n\nconst {\n  Key,\n  Adapter\n} = require('interface-datastore');\n\nconst {\n  encodeBase32,\n  keyToTopic,\n  topicToKey\n} = require('./utils');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('datastore-pubsub:publisher'), {\n  error: debug('datastore-pubsub:publisher:error')\n});\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types').Validator} Validator\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('libp2p-interfaces/src/pubsub').InMessage} PubSubMessage\n */\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\n\nclass DatastorePubsub extends Adapter {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('libp2p-interfaces/src/pubsub')} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {Validator} validator - validator functions\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  constructor(pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    super();\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    this._pubsub = pubsub;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._validator = validator;\n    this._handleSubscriptionKeyFn = subscriptionKeyFn; // Bind _onMessage function, which is called by pubsub.\n\n    this._onMessage = this._onMessage.bind(this);\n  }\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n\n\n  async put(key, val) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    if (!(val instanceof Uint8Array)) {\n      const errMsg = 'received value is not a Uint8Array';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    log(`publish value for topic ${stringifiedTopic}`); // Publish record to pubsub\n\n    await this._pubsub.publish(stringifiedTopic, val);\n  }\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n\n\n  async get(key) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    const subscriptions = await this._pubsub.getTopics(); // If already subscribed, just try to get it\n\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key);\n    } // subscribe\n\n\n    try {\n      this._pubsub.on(stringifiedTopic, this._onMessage);\n\n      await this._pubsub.subscribe(stringifiedTopic);\n    } catch (err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC');\n    }\n\n    log(`subscribed values for key ${stringifiedTopic}`);\n    return this._getLocal(key);\n  }\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n\n\n  unsubscribe(key) {\n    const stringifiedTopic = keyToTopic(key);\n\n    this._pubsub.removeListener(stringifiedTopic, this._onMessage);\n\n    return this._pubsub.unsubscribe(stringifiedTopic);\n  }\n  /**\n   * Get record from local datastore\n   *\n   * @private\n   * @param {Uint8Array} key\n   */\n\n\n  async _getLocal(key) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    let dsVal;\n\n    try {\n      dsVal = await this._datastore.get(routingKey);\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n      }\n\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND');\n    }\n\n    if (!(dsVal instanceof Uint8Array)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED');\n    }\n\n    return dsVal;\n  }\n  /**\n   * handles pubsub subscription messages\n   *\n   * @param {PubSubMessage} msg\n   */\n\n\n  async _onMessage(msg) {\n    const {\n      data,\n      from,\n      topicIDs\n    } = msg;\n    let key;\n\n    try {\n      key = topicToKey(topicIDs[0]);\n    } catch (err) {\n      log.error(err);\n      return;\n    }\n\n    log(`message received for topic ${topicIDs[0]}`); // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n\n    if (from === this._peerId.toB58String()) {\n      log('message discarded as it is from the same peer');\n      return;\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res;\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key);\n      } catch (err) {\n        log.error('message discarded by the subscriptionKeyFn');\n        return;\n      }\n\n      key = res;\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Store the received record if it is better than the current stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n\n\n  async _storeIfSubscriptionIsBetter(key, data) {\n    let isBetter = false;\n\n    try {\n      isBetter = await this._isBetter(key, data);\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err;\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(key, data);\n    }\n  }\n  /**\n   * Validate record according to the received validation function\n   *\n   * @param {Uint8Array} value\n   * @param {Uint8Array} peerId\n   */\n\n\n  async _validateRecord(value, peerId) {\n    // eslint-disable-line require-await\n    return this._validator.validate(value, peerId);\n  }\n  /**\n   * Select the best record according to the received select function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array[]} records\n   */\n\n\n  async _selectRecord(key, records) {\n    const res = await this._validator.select(key, records); // If the selected was the first (0), it should be stored (true)\n\n    return res === 0;\n  }\n  /**\n   * Verify if the record received through pubsub is valid and better than the one currently stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} val\n   */\n\n\n  async _isBetter(key, val) {\n    try {\n      await this._validateRecord(val, key);\n    } catch (err) {\n      // If not valid, it is not better than the one currently available\n      const errMsg = 'record received through pubsub is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD');\n    } // Get Local record\n\n\n    const dsKey = new Key(key);\n    let currentRecord;\n\n    try {\n      currentRecord = await this._getLocal(dsKey.uint8Array());\n    } catch (err) {\n      // if the old one is invalid, the new one is *always* better\n      return true;\n    } // if the same record, do not need to store\n\n\n    if (uint8ArrayEquals(currentRecord, val)) {\n      return false;\n    } // verify if the received record should replace the current one\n\n\n    return this._selectRecord(key, [currentRecord, val]);\n  }\n  /**\n   * add record to datastore\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n\n\n  async _storeRecord(key, data) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    await this._datastore.put(routingKey, data);\n    log(`record for ${keyToTopic(key)} was stored in the datastore`);\n  }\n\n}\n\nexports = module.exports = DatastorePubsub;","map":{"version":3,"names":["Key","Adapter","require","encodeBase32","keyToTopic","topicToKey","equals","uint8ArrayEquals","errcode","debug","log","Object","assign","error","DatastorePubsub","constructor","pubsub","datastore","peerId","validator","subscriptionKeyFn","TypeError","validate","select","_pubsub","_datastore","_peerId","_validator","_handleSubscriptionKeyFn","_onMessage","bind","put","key","val","Uint8Array","errMsg","Error","stringifiedTopic","publish","get","subscriptions","getTopics","Array","isArray","indexOf","_getLocal","on","subscribe","err","unsubscribe","removeListener","routingKey","dsVal","code","toString","msg","data","from","topicIDs","toB58String","res","_storeIfSubscriptionIsBetter","isBetter","_isBetter","_storeRecord","_validateRecord","value","_selectRecord","records","dsKey","currentRecord","uint8Array","exports","module"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/datastore-pubsub/src/index.js"],"sourcesContent":["'use strict'\n\nconst { Key, Adapter } = require('interface-datastore')\nconst { encodeBase32, keyToTopic, topicToKey } = require('./utils')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('datastore-pubsub:publisher'), {\n  error: debug('datastore-pubsub:publisher:error')\n})\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types').Validator} Validator\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('libp2p-interfaces/src/pubsub').InMessage} PubSubMessage\n */\n\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\nclass DatastorePubsub extends Adapter {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('libp2p-interfaces/src/pubsub')} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {Validator} validator - validator functions\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  constructor (pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    super()\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    this._pubsub = pubsub\n    this._datastore = datastore\n    this._peerId = peerId\n    this._validator = validator\n    this._handleSubscriptionKeyFn = subscriptionKeyFn\n\n    // Bind _onMessage function, which is called by pubsub.\n    this._onMessage = this._onMessage.bind(this)\n  }\n\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async put (key, val) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!(val instanceof Uint8Array)) {\n      const errMsg = 'received value is not a Uint8Array'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n\n    log(`publish value for topic ${stringifiedTopic}`)\n\n    // Publish record to pubsub\n    await this._pubsub.publish(stringifiedTopic, val)\n  }\n\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async get (key) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n    const subscriptions = await this._pubsub.getTopics()\n\n    // If already subscribed, just try to get it\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key)\n    }\n\n    // subscribe\n    try {\n      this._pubsub.on(stringifiedTopic, this._onMessage)\n      await this._pubsub.subscribe(stringifiedTopic)\n    } catch (err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC')\n    }\n    log(`subscribed values for key ${stringifiedTopic}`)\n\n    return this._getLocal(key)\n  }\n\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n  unsubscribe (key) {\n    const stringifiedTopic = keyToTopic(key)\n\n    this._pubsub.removeListener(stringifiedTopic, this._onMessage)\n    return this._pubsub.unsubscribe(stringifiedTopic)\n  }\n\n  /**\n   * Get record from local datastore\n   *\n   * @private\n   * @param {Uint8Array} key\n   */\n  async _getLocal (key) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n    let dsVal\n\n    try {\n      dsVal = await this._datastore.get(routingKey)\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`\n\n        log.error(errMsg)\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n      }\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND')\n    }\n\n    if (!(dsVal instanceof Uint8Array)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    return dsVal\n  }\n\n  /**\n   * handles pubsub subscription messages\n   *\n   * @param {PubSubMessage} msg\n   */\n  async _onMessage (msg) {\n    const { data, from, topicIDs } = msg\n    let key\n    try {\n      key = topicToKey(topicIDs[0])\n    } catch (err) {\n      log.error(err)\n      return\n    }\n\n    log(`message received for topic ${topicIDs[0]}`)\n\n    // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n    if (from === this._peerId.toB58String()) {\n      log('message discarded as it is from the same peer')\n      return\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key)\n      } catch (err) {\n        log.error('message discarded by the subscriptionKeyFn')\n        return\n      }\n\n      key = res\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Store the received record if it is better than the current stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n  async _storeIfSubscriptionIsBetter (key, data) {\n    let isBetter = false\n\n    try {\n      isBetter = await this._isBetter(key, data)\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(key, data)\n    }\n  }\n\n  /**\n   * Validate record according to the received validation function\n   *\n   * @param {Uint8Array} value\n   * @param {Uint8Array} peerId\n   */\n  async _validateRecord (value, peerId) { // eslint-disable-line require-await\n    return this._validator.validate(value, peerId)\n  }\n\n  /**\n   * Select the best record according to the received select function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array[]} records\n   */\n  async _selectRecord (key, records) {\n    const res = await this._validator.select(key, records)\n\n    // If the selected was the first (0), it should be stored (true)\n    return res === 0\n  }\n\n  /**\n   * Verify if the record received through pubsub is valid and better than the one currently stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} val\n   */\n  async _isBetter (key, val) {\n    try {\n      await this._validateRecord(val, key)\n    } catch (err) {\n      // If not valid, it is not better than the one currently available\n      const errMsg = 'record received through pubsub is not valid'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD')\n    }\n\n    // Get Local record\n    const dsKey = new Key(key)\n    let currentRecord\n\n    try {\n      currentRecord = await this._getLocal(dsKey.uint8Array())\n    } catch (err) {\n      // if the old one is invalid, the new one is *always* better\n      return true\n    }\n\n    // if the same record, do not need to store\n    if (uint8ArrayEquals(currentRecord, val)) {\n      return false\n    }\n\n    // verify if the received record should replace the current one\n    return this._selectRecord(key, [currentRecord, val])\n  }\n\n  /**\n   * add record to datastore\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n  async _storeRecord (key, data) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n\n    await this._datastore.put(routingKey, data)\n    log(`record for ${keyToTopic(key)} was stored in the datastore`)\n  }\n}\n\nexports = module.exports = DatastorePubsub\n"],"mappings":"AAAA;;AAEA,MAAM;EAAEA,GAAF;EAAOC;AAAP,IAAmBC,OAAO,CAAC,qBAAD,CAAhC;;AACA,MAAM;EAAEC,YAAF;EAAgBC,UAAhB;EAA4BC;AAA5B,IAA2CH,OAAO,CAAC,SAAD,CAAxD;;AACA,MAAM;EAAEI,MAAM,EAAEC;AAAV,IAA+BL,OAAO,CAAC,oBAAD,CAA5C;;AAEA,MAAMM,OAAO,GAAGN,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMO,KAAK,GAAGP,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMQ,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcH,KAAK,CAAC,4BAAD,CAAnB,EAAmD;EAC7DI,KAAK,EAAEJ,KAAK,CAAC,kCAAD;AADiD,CAAnD,CAAZ;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA,MAAMK,eAAN,SAA8Bb,OAA9B,CAAsC;EACpC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEc,WAAW,CAAEC,MAAF,EAAUC,SAAV,EAAqBC,MAArB,EAA6BC,SAA7B,EAAwCC,iBAAxC,EAA2D;IACpE;;IAEA,IAAI,CAACD,SAAL,EAAgB;MACd,MAAMX,OAAO,CAAC,IAAIa,SAAJ,CAAc,mBAAd,CAAD,EAAqC,wBAArC,CAAb;IACD;;IAED,IAAI,OAAOF,SAAS,CAACG,QAAjB,KAA8B,UAAlC,EAA8C;MAC5C,MAAMd,OAAO,CAAC,IAAIa,SAAJ,CAAc,2BAAd,CAAD,EAA6C,wBAA7C,CAAb;IACD;;IAED,IAAI,OAAOF,SAAS,CAACI,MAAjB,KAA4B,UAAhC,EAA4C;MAC1C,MAAMf,OAAO,CAAC,IAAIa,SAAJ,CAAc,yBAAd,CAAD,EAA2C,wBAA3C,CAAb;IACD;;IAED,IAAID,iBAAiB,IAAI,OAAOA,iBAAP,KAA6B,UAAtD,EAAkE;MAChE,MAAMZ,OAAO,CAAC,IAAIa,SAAJ,CAAc,oCAAd,CAAD,EAAsD,wBAAtD,CAAb;IACD;;IAED,KAAKG,OAAL,GAAeR,MAAf;IACA,KAAKS,UAAL,GAAkBR,SAAlB;IACA,KAAKS,OAAL,GAAeR,MAAf;IACA,KAAKS,UAAL,GAAkBR,SAAlB;IACA,KAAKS,wBAAL,GAAgCR,iBAAhC,CAvBoE,CAyBpE;;IACA,KAAKS,UAAL,GAAkB,KAAKA,UAAL,CAAgBC,IAAhB,CAAqB,IAArB,CAAlB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;EACE;;;EACS,MAAHC,GAAG,CAAEC,GAAF,EAAOC,GAAP,EAAY;IACnB,IAAI,EAAED,GAAG,YAAYE,UAAjB,CAAJ,EAAkC;MAChC,MAAMC,MAAM,GAAG,4CAAf;MAEAzB,GAAG,CAACG,KAAJ,CAAUsB,MAAV;MACA,MAAM3B,OAAO,CAAC,IAAI4B,KAAJ,CAAUD,MAAV,CAAD,EAAoB,2BAApB,CAAb;IACD;;IAED,IAAI,EAAEF,GAAG,YAAYC,UAAjB,CAAJ,EAAkC;MAChC,MAAMC,MAAM,GAAG,oCAAf;MAEAzB,GAAG,CAACG,KAAJ,CAAUsB,MAAV;MACA,MAAM3B,OAAO,CAAC,IAAI4B,KAAJ,CAAUD,MAAV,CAAD,EAAoB,4BAApB,CAAb;IACD;;IAED,MAAME,gBAAgB,GAAGjC,UAAU,CAAC4B,GAAD,CAAnC;IAEAtB,GAAG,CAAE,2BAA0B2B,gBAAiB,EAA7C,CAAH,CAjBmB,CAmBnB;;IACA,MAAM,KAAKb,OAAL,CAAac,OAAb,CAAqBD,gBAArB,EAAuCJ,GAAvC,CAAN;EACD;EAED;AACF;AACA;AACA;AACA;EACE;;;EACS,MAAHM,GAAG,CAAEP,GAAF,EAAO;IACd,IAAI,EAAEA,GAAG,YAAYE,UAAjB,CAAJ,EAAkC;MAChC,MAAMC,MAAM,GAAG,4CAAf;MAEAzB,GAAG,CAACG,KAAJ,CAAUsB,MAAV;MACA,MAAM3B,OAAO,CAAC,IAAI4B,KAAJ,CAAUD,MAAV,CAAD,EAAoB,2BAApB,CAAb;IACD;;IAED,MAAME,gBAAgB,GAAGjC,UAAU,CAAC4B,GAAD,CAAnC;IACA,MAAMQ,aAAa,GAAG,MAAM,KAAKhB,OAAL,CAAaiB,SAAb,EAA5B,CATc,CAWd;;IACA,IAAID,aAAa,IAAIE,KAAK,CAACC,OAAN,CAAcH,aAAd,CAAjB,IAAiDA,aAAa,CAACI,OAAd,CAAsBP,gBAAtB,IAA0C,CAAC,CAAhG,EAAmG;MACjG,OAAO,KAAKQ,SAAL,CAAeb,GAAf,CAAP;IACD,CAda,CAgBd;;;IACA,IAAI;MACF,KAAKR,OAAL,CAAasB,EAAb,CAAgBT,gBAAhB,EAAkC,KAAKR,UAAvC;;MACA,MAAM,KAAKL,OAAL,CAAauB,SAAb,CAAuBV,gBAAvB,CAAN;IACD,CAHD,CAGE,OAAOW,GAAP,EAAY;MACZ,MAAMb,MAAM,GAAI,0BAAyBE,gBAAiB,EAA1D;MAEA3B,GAAG,CAACG,KAAJ,CAAUsB,MAAV;MACA,MAAM3B,OAAO,CAAC,IAAI4B,KAAJ,CAAUD,MAAV,CAAD,EAAoB,uBAApB,CAAb;IACD;;IACDzB,GAAG,CAAE,6BAA4B2B,gBAAiB,EAA/C,CAAH;IAEA,OAAO,KAAKQ,SAAL,CAAeb,GAAf,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEiB,WAAW,CAAEjB,GAAF,EAAO;IAChB,MAAMK,gBAAgB,GAAGjC,UAAU,CAAC4B,GAAD,CAAnC;;IAEA,KAAKR,OAAL,CAAa0B,cAAb,CAA4Bb,gBAA5B,EAA8C,KAAKR,UAAnD;;IACA,OAAO,KAAKL,OAAL,CAAayB,WAAb,CAAyBZ,gBAAzB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACiB,MAATQ,SAAS,CAAEb,GAAF,EAAO;IACpB;IACA,MAAMmB,UAAU,GAAG,IAAInD,GAAJ,CAAQ,MAAMG,YAAY,CAAC6B,GAAD,CAA1B,EAAiC,KAAjC,CAAnB;IACA,IAAIoB,KAAJ;;IAEA,IAAI;MACFA,KAAK,GAAG,MAAM,KAAK3B,UAAL,CAAgBc,GAAhB,CAAoBY,UAApB,CAAd;IACD,CAFD,CAEE,OAAOH,GAAP,EAAY;MACZ,IAAIA,GAAG,CAACK,IAAJ,KAAa,eAAjB,EAAkC;QAChC,MAAMlB,MAAM,GAAI,gDAA+CgB,UAAU,CAACG,QAAX,EAAsB,EAArF;QAEA5C,GAAG,CAACG,KAAJ,CAAUsB,MAAV;QACA,MAAM3B,OAAO,CAAC,IAAI4B,KAAJ,CAAUD,MAAV,CAAD,EAAoB,qCAApB,CAAb;MACD;;MACD,MAAMA,MAAM,GAAI,4CAA2CgB,UAAU,CAACG,QAAX,EAAsB,EAAjF;MAEA5C,GAAG,CAACG,KAAJ,CAAUsB,MAAV;MACA,MAAM3B,OAAO,CAAC,IAAI4B,KAAJ,CAAUD,MAAV,CAAD,EAAoB,eAApB,CAAb;IACD;;IAED,IAAI,EAAEiB,KAAK,YAAYlB,UAAnB,CAAJ,EAAoC;MAClC,MAAMC,MAAM,GAAG,mDAAf;MAEAzB,GAAG,CAACG,KAAJ,CAAUsB,MAAV;MACA,MAAM3B,OAAO,CAAC,IAAI4B,KAAJ,CAAUD,MAAV,CAAD,EAAoB,6BAApB,CAAb;IACD;;IAED,OAAOiB,KAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACkB,MAAVvB,UAAU,CAAE0B,GAAF,EAAO;IACrB,MAAM;MAAEC,IAAF;MAAQC,IAAR;MAAcC;IAAd,IAA2BH,GAAjC;IACA,IAAIvB,GAAJ;;IACA,IAAI;MACFA,GAAG,GAAG3B,UAAU,CAACqD,QAAQ,CAAC,CAAD,CAAT,CAAhB;IACD,CAFD,CAEE,OAAOV,GAAP,EAAY;MACZtC,GAAG,CAACG,KAAJ,CAAUmC,GAAV;MACA;IACD;;IAEDtC,GAAG,CAAE,8BAA6BgD,QAAQ,CAAC,CAAD,CAAI,EAA3C,CAAH,CAVqB,CAYrB;;IACA,IAAID,IAAI,KAAK,KAAK/B,OAAL,CAAaiC,WAAb,EAAb,EAAyC;MACvCjD,GAAG,CAAC,+CAAD,CAAH;MACA;IACD;;IAED,IAAI,KAAKkB,wBAAT,EAAmC;MACjC,IAAIgC,GAAJ;;MAEA,IAAI;QACFA,GAAG,GAAG,MAAM,KAAKhC,wBAAL,CAA8BI,GAA9B,CAAZ;MACD,CAFD,CAEE,OAAOgB,GAAP,EAAY;QACZtC,GAAG,CAACG,KAAJ,CAAU,4CAAV;QACA;MACD;;MAEDmB,GAAG,GAAG4B,GAAN;IACD;;IAED,IAAI;MACF,MAAM,KAAKC,4BAAL,CAAkC7B,GAAlC,EAAuCwB,IAAvC,CAAN;IACD,CAFD,CAEE,OAAOR,GAAP,EAAY;MACZtC,GAAG,CAACG,KAAJ,CAAUmC,GAAV;IACD;EACF;EAED;AACF;AACA;AACA;AACA;AACA;;;EACoC,MAA5Ba,4BAA4B,CAAE7B,GAAF,EAAOwB,IAAP,EAAa;IAC7C,IAAIM,QAAQ,GAAG,KAAf;;IAEA,IAAI;MACFA,QAAQ,GAAG,MAAM,KAAKC,SAAL,CAAe/B,GAAf,EAAoBwB,IAApB,CAAjB;IACD,CAFD,CAEE,OAAOR,GAAP,EAAY;MACZ,IAAIA,GAAG,CAACK,IAAJ,KAAa,sBAAjB,EAAyC;QACvC,MAAML,GAAN;MACD;IACF;;IAED,IAAIc,QAAJ,EAAc;MACZ,MAAM,KAAKE,YAAL,CAAkBhC,GAAlB,EAAuBwB,IAAvB,CAAN;IACD;EACF;EAED;AACF;AACA;AACA;AACA;AACA;;;EACuB,MAAfS,eAAe,CAAEC,KAAF,EAAShD,MAAT,EAAiB;IAAE;IACtC,OAAO,KAAKS,UAAL,CAAgBL,QAAhB,CAAyB4C,KAAzB,EAAgChD,MAAhC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACqB,MAAbiD,aAAa,CAAEnC,GAAF,EAAOoC,OAAP,EAAgB;IACjC,MAAMR,GAAG,GAAG,MAAM,KAAKjC,UAAL,CAAgBJ,MAAhB,CAAuBS,GAAvB,EAA4BoC,OAA5B,CAAlB,CADiC,CAGjC;;IACA,OAAOR,GAAG,KAAK,CAAf;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACiB,MAATG,SAAS,CAAE/B,GAAF,EAAOC,GAAP,EAAY;IACzB,IAAI;MACF,MAAM,KAAKgC,eAAL,CAAqBhC,GAArB,EAA0BD,GAA1B,CAAN;IACD,CAFD,CAEE,OAAOgB,GAAP,EAAY;MACZ;MACA,MAAMb,MAAM,GAAG,6CAAf;MAEAzB,GAAG,CAACG,KAAJ,CAAUsB,MAAV;MACA,MAAM3B,OAAO,CAAC,IAAI4B,KAAJ,CAAUD,MAAV,CAAD,EAAoB,sBAApB,CAAb;IACD,CATwB,CAWzB;;;IACA,MAAMkC,KAAK,GAAG,IAAIrE,GAAJ,CAAQgC,GAAR,CAAd;IACA,IAAIsC,aAAJ;;IAEA,IAAI;MACFA,aAAa,GAAG,MAAM,KAAKzB,SAAL,CAAewB,KAAK,CAACE,UAAN,EAAf,CAAtB;IACD,CAFD,CAEE,OAAOvB,GAAP,EAAY;MACZ;MACA,OAAO,IAAP;IACD,CApBwB,CAsBzB;;;IACA,IAAIzC,gBAAgB,CAAC+D,aAAD,EAAgBrC,GAAhB,CAApB,EAA0C;MACxC,OAAO,KAAP;IACD,CAzBwB,CA2BzB;;;IACA,OAAO,KAAKkC,aAAL,CAAmBnC,GAAnB,EAAwB,CAACsC,aAAD,EAAgBrC,GAAhB,CAAxB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACoB,MAAZ+B,YAAY,CAAEhC,GAAF,EAAOwB,IAAP,EAAa;IAC7B;IACA,MAAML,UAAU,GAAG,IAAInD,GAAJ,CAAQ,MAAMG,YAAY,CAAC6B,GAAD,CAA1B,EAAiC,KAAjC,CAAnB;IAEA,MAAM,KAAKP,UAAL,CAAgBM,GAAhB,CAAoBoB,UAApB,EAAgCK,IAAhC,CAAN;IACA9C,GAAG,CAAE,cAAaN,UAAU,CAAC4B,GAAD,CAAM,8BAA/B,CAAH;EACD;;AArSmC;;AAwStCwC,OAAO,GAAGC,MAAM,CAACD,OAAP,GAAiB1D,eAA3B"},"metadata":{},"sourceType":"script"}