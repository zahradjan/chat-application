{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar IPNS = require('../ipns');\n\nvar routingConfig = require('../ipns/routing/config');\n\nvar OfflineDatastore = require('../ipns/routing/offline-datastore');\n\nvar _require = require('../errors'),\n    NotInitializedError = _require.NotInitializedError,\n    AlreadyInitializedError = _require.AlreadyInitializedError;\n\nvar log = require('debug')('ipfs:components:ipns');\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n *\n * @typedef {Object} ExperimentalOptions\n * @property {boolean} [ipnsPubsub]\n *\n * @typedef {Object} LibP2POptions\n * @property {DHTConfig} [config]\n *\n * @typedef {Object} DHTConfig\n * @property {boolean} [enabled]\n */\n\n\nvar IPNSAPI = /*#__PURE__*/function () {\n  /**\n   * @param {Object} options\n   * @param {string} options.pass\n   * @param {boolean} [options.offline]\n   * @param {LibP2POptions} [options.libp2p]\n   * @param {ExperimentalOptions} [options.EXPERIMENTAL]\n   */\n  function IPNSAPI() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      pass: ''\n    };\n\n    _classCallCheck(this, IPNSAPI);\n\n    this.options = options;\n    /** @type {IPNS | null} */\n\n    this.offline = null;\n    /** @type {IPNS | null} */\n\n    this.online = null;\n  }\n\n  _createClass(IPNSAPI, [{\n    key: \"getIPNS\",\n    value: function getIPNS() {\n      var ipns = this.online || this.offline;\n\n      if (ipns) {\n        return ipns;\n      } else {\n        throw new NotInitializedError();\n      }\n    }\n  }, {\n    key: \"routing\",\n    get: function get() {\n      return this.getIPNS().routing;\n    }\n    /**\n     * Activates IPNS subsystem in an ofline mode. If it was started once already\n     * it will throw an exception.\n     *\n     * This is primarily used for offline ipns modifications, such as the\n     * initializeKeyspace feature.\n     *\n     * @param {Object} config\n     * @param {import('ipfs-repo').IPFSRepo} config.repo\n     * @param {import('peer-id')} config.peerId\n     * @param {import('libp2p/src/keychain')} config.keychain\n     */\n\n  }, {\n    key: \"startOffline\",\n    value: function startOffline(_ref) {\n      var repo = _ref.repo,\n          peerId = _ref.peerId,\n          keychain = _ref.keychain;\n\n      if (this.offline != null) {\n        throw new AlreadyInitializedError();\n      }\n\n      log('initializing IPNS keyspace');\n      var routing = new OfflineDatastore(repo);\n      var ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);\n      this.offline = ipns;\n    }\n    /**\n     * @param {Object} config\n     * @param {import('libp2p')} config.libp2p\n     * @param {import('ipfs-repo').IPFSRepo} config.repo\n     * @param {import('peer-id')} config.peerId\n     * @param {import('libp2p/src/keychain')} config.keychain\n     */\n\n  }, {\n    key: \"startOnline\",\n    value: function () {\n      var _startOnline = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2) {\n        var libp2p, repo, peerId, keychain, routing, ipns;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                libp2p = _ref2.libp2p, repo = _ref2.repo, peerId = _ref2.peerId, keychain = _ref2.keychain;\n\n                if (!(this.online != null)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new AlreadyInitializedError();\n\n              case 3:\n                routing = routingConfig({\n                  libp2p: libp2p,\n                  repo: repo,\n                  peerId: peerId,\n                  options: this.options\n                }); // @ts-ignore routing is a TieredDatastore which wants keys to be Keys, IPNS needs keys to be Uint8Arrays\n\n                ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);\n                _context.next = 7;\n                return ipns.republisher.start();\n\n              case 7:\n                this.online = ipns;\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function startOnline(_x) {\n        return _startOnline.apply(this, arguments);\n      }\n\n      return startOnline;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var ipns;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                ipns = this.online;\n\n                if (!ipns) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                _context2.next = 4;\n                return ipns.republisher.stop();\n\n              case 4:\n                this.online = null;\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * @param {PrivateKey} privKey\n     * @param {Uint8Array} value\n     * @param {number} lifetime\n     */\n\n  }, {\n    key: \"publish\",\n    value: function publish(privKey, value, lifetime) {\n      return this.getIPNS().publish(privKey, value, lifetime);\n    }\n    /**\n     *\n     * @param {string} name\n     * @param {*} [options]\n     */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(name, options) {\n      return this.getIPNS().resolve(name, options);\n    }\n    /**\n     * @param {PrivateKey} privKey\n     * @param {Uint8Array} value\n     */\n\n  }, {\n    key: \"initializeKeyspace\",\n    value: function initializeKeyspace(privKey, value) {\n      return this.getIPNS().initializeKeyspace(privKey, value);\n    }\n  }]);\n\n  return IPNSAPI;\n}();\n\nmodule.exports = IPNSAPI;","map":{"version":3,"names":["IPNS","require","routingConfig","OfflineDatastore","NotInitializedError","AlreadyInitializedError","log","IPNSAPI","options","pass","offline","online","ipns","getIPNS","routing","repo","peerId","keychain","datastore","libp2p","republisher","start","stop","privKey","value","lifetime","publish","name","resolve","initializeKeyspace","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/ipns.js"],"sourcesContent":["'use strict'\n\nconst IPNS = require('../ipns')\nconst routingConfig = require('../ipns/routing/config')\nconst OfflineDatastore = require('../ipns/routing/offline-datastore')\nconst { NotInitializedError, AlreadyInitializedError } = require('../errors')\nconst log = require('debug')('ipfs:components:ipns')\n\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n *\n * @typedef {Object} ExperimentalOptions\n * @property {boolean} [ipnsPubsub]\n *\n * @typedef {Object} LibP2POptions\n * @property {DHTConfig} [config]\n *\n * @typedef {Object} DHTConfig\n * @property {boolean} [enabled]\n */\n\nclass IPNSAPI {\n  /**\n   * @param {Object} options\n   * @param {string} options.pass\n   * @param {boolean} [options.offline]\n   * @param {LibP2POptions} [options.libp2p]\n   * @param {ExperimentalOptions} [options.EXPERIMENTAL]\n   */\n  constructor (options = { pass: '' }) {\n    this.options = options\n\n    /** @type {IPNS | null} */\n    this.offline = null\n\n    /** @type {IPNS | null} */\n    this.online = null\n  }\n\n  getIPNS () {\n    const ipns = this.online || this.offline\n    if (ipns) {\n      return ipns\n    } else {\n      throw new NotInitializedError()\n    }\n  }\n\n  get routing () {\n    return this.getIPNS().routing\n  }\n\n  /**\n   * Activates IPNS subsystem in an ofline mode. If it was started once already\n   * it will throw an exception.\n   *\n   * This is primarily used for offline ipns modifications, such as the\n   * initializeKeyspace feature.\n   *\n   * @param {Object} config\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('peer-id')} config.peerId\n   * @param {import('libp2p/src/keychain')} config.keychain\n   */\n  startOffline ({ repo, peerId, keychain }) {\n    if (this.offline != null) {\n      throw new AlreadyInitializedError()\n    }\n\n    log('initializing IPNS keyspace')\n\n    const routing = new OfflineDatastore(repo)\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options)\n\n    this.offline = ipns\n  }\n\n  /**\n   * @param {Object} config\n   * @param {import('libp2p')} config.libp2p\n   * @param {import('ipfs-repo').IPFSRepo} config.repo\n   * @param {import('peer-id')} config.peerId\n   * @param {import('libp2p/src/keychain')} config.keychain\n   */\n  async startOnline ({ libp2p, repo, peerId, keychain }) {\n    if (this.online != null) {\n      throw new AlreadyInitializedError()\n    }\n    const routing = routingConfig({ libp2p, repo, peerId, options: this.options })\n\n    // @ts-ignore routing is a TieredDatastore which wants keys to be Keys, IPNS needs keys to be Uint8Arrays\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options)\n    await ipns.republisher.start()\n    this.online = ipns\n  }\n\n  async stop () {\n    const ipns = this.online\n    if (ipns) {\n      await ipns.republisher.stop()\n      this.online = null\n    }\n  }\n\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n  publish (privKey, value, lifetime) {\n    return this.getIPNS().publish(privKey, value, lifetime)\n  }\n\n  /**\n   *\n   * @param {string} name\n   * @param {*} [options]\n   */\n  resolve (name, options) {\n    return this.getIPNS().resolve(name, options)\n  }\n\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n  initializeKeyspace (privKey, value) {\n    return this.getIPNS().initializeKeyspace(privKey, value)\n  }\n}\nmodule.exports = IPNSAPI\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}