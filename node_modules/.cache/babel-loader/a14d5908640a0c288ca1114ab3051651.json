{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar log = require('debug')('ipfs:components:peer:storage');\n\nvar createRepo = require('../runtime/repo-nodejs');\n\nvar getDefaultConfig = require('../runtime/config-nodejs');\n\nvar ERR_REPO_NOT_INITIALIZED = require('ipfs-repo').errors.ERR_REPO_NOT_INITIALIZED;\n\nvar _require = require('uint8arrays/from-string'),\n    uint8ArrayFromString = _require.fromString;\n\nvar _require2 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require2.toString;\n\nvar PeerId = require('peer-id');\n\nvar mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nvar configService = require('./config');\n\nvar _require3 = require('../errors'),\n    NotEnabledError = _require3.NotEnabledError,\n    NotInitializedError = _require3.NotInitializedError;\n\nvar createLibP2P = require('./libp2p');\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('libp2p-crypto').KeyType} KeyType\n * @typedef {import('libp2p/src/keychain')} Keychain\n */\n\n\nvar Storage = /*#__PURE__*/function () {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  function Storage(peerId, keychain, repo, print, isNew) {\n    _classCallCheck(this, Storage);\n\n    this.print = print;\n    this.peerId = peerId;\n    this.keychain = keychain;\n    this.repo = repo;\n    this.print = print;\n    this.isNew = isNew;\n  }\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n   * @param {IPFSOptions} options\n   */\n\n\n  _createClass(Storage, null, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(print, codecs, options) {\n        var repoAutoMigrate, inputRepo, onMigrationProgress, repo, _yield$loadRepo, peerId, keychain, isNew;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                repoAutoMigrate = options.repoAutoMigrate, inputRepo = options.repo, onMigrationProgress = options.onMigrationProgress;\n                repo = typeof inputRepo === 'string' || inputRepo == null ? createRepo(print, codecs, {\n                  path: inputRepo,\n                  autoMigrate: repoAutoMigrate,\n                  onMigrationProgress: onMigrationProgress\n                }) : inputRepo;\n                _context.next = 4;\n                return loadRepo(print, repo, options);\n\n              case 4:\n                _yield$loadRepo = _context.sent;\n                peerId = _yield$loadRepo.peerId;\n                keychain = _yield$loadRepo.keychain;\n                isNew = _yield$loadRepo.isNew;\n                return _context.abrupt(\"return\", new Storage(peerId, keychain, repo, print, isNew));\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function start(_x, _x2, _x3) {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n  }]);\n\n  return Storage;\n}();\n\nmodule.exports = Storage;\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\n\nvar loadRepo = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(print, repo, options) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (repo.closed) {\n              _context2.next = 11;\n              break;\n            }\n\n            _context2.t0 = _objectSpread;\n            _context2.t1 = _objectSpread;\n            _context2.t2 = {};\n            _context2.next = 6;\n            return configureRepo(repo, options);\n\n          case 6:\n            _context2.t3 = _context2.sent;\n            _context2.t4 = (0, _context2.t1)(_context2.t2, _context2.t3);\n            _context2.t5 = {};\n            _context2.t6 = {\n              isNew: false\n            };\n            return _context2.abrupt(\"return\", (0, _context2.t0)(_context2.t4, _context2.t5, _context2.t6));\n\n          case 11:\n            _context2.prev = 11;\n            _context2.next = 14;\n            return repo.open();\n\n          case 14:\n            _context2.t7 = _objectSpread;\n            _context2.t8 = _objectSpread;\n            _context2.t9 = {};\n            _context2.next = 19;\n            return configureRepo(repo, options);\n\n          case 19:\n            _context2.t10 = _context2.sent;\n            _context2.t11 = (0, _context2.t8)(_context2.t9, _context2.t10);\n            _context2.t12 = {};\n            _context2.t13 = {\n              isNew: false\n            };\n            return _context2.abrupt(\"return\", (0, _context2.t7)(_context2.t11, _context2.t12, _context2.t13));\n\n          case 26:\n            _context2.prev = 26;\n            _context2.t14 = _context2[\"catch\"](11);\n\n            if (!(_context2.t14.code !== ERR_REPO_NOT_INITIALIZED)) {\n              _context2.next = 30;\n              break;\n            }\n\n            throw _context2.t14;\n\n          case 30:\n            if (!(options.init && options.init.allowNew === false)) {\n              _context2.next = 32;\n              break;\n            }\n\n            throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it');\n\n          case 32:\n            _context2.t15 = _objectSpread;\n            _context2.t16 = _objectSpread;\n            _context2.t17 = {};\n            _context2.next = 37;\n            return initRepo(print, repo, options);\n\n          case 37:\n            _context2.t18 = _context2.sent;\n            _context2.t19 = (0, _context2.t16)(_context2.t17, _context2.t18);\n            _context2.t20 = {};\n            _context2.t21 = {\n              isNew: true\n            };\n            return _context2.abrupt(\"return\", (0, _context2.t15)(_context2.t19, _context2.t20, _context2.t21));\n\n          case 42:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[11, 26]]);\n  }));\n\n  return function loadRepo(_x4, _x5, _x6) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nvar initRepo = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(print, repo, options) {\n    var initOptions, exists, peerId, identity, config, keychainConfig, libp2p;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            initOptions = options.init || {}; // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n\n            _context3.next = 3;\n            return repo.exists();\n\n          case 3:\n            exists = _context3.sent;\n            log('repo exists?', exists);\n\n            if (!(exists === true)) {\n              _context3.next = 7;\n              break;\n            }\n\n            throw new Error('repo already exists');\n\n          case 7:\n            if (!initOptions.privateKey) {\n              _context3.next = 13;\n              break;\n            }\n\n            _context3.next = 10;\n            return decodePeerId(initOptions.privateKey);\n\n          case 10:\n            _context3.t0 = _context3.sent;\n            _context3.next = 16;\n            break;\n\n          case 13:\n            _context3.next = 15;\n            return initPeerId(print, initOptions);\n\n          case 15:\n            _context3.t0 = _context3.sent;\n\n          case 16:\n            peerId = _context3.t0;\n            identity = peerIdToIdentity(peerId);\n            log('peer identity: %s', identity.PeerID); // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n\n            config = _objectSpread(_objectSpread({}, mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config)), {}, {\n              Identity: identity\n            });\n            _context3.next = 22;\n            return repo.init(config);\n\n          case 22:\n            _context3.next = 24;\n            return repo.open();\n\n          case 24:\n            log('repo opened');\n            /** @type {import('./libp2p').KeychainConfig} */\n\n            keychainConfig = {\n              pass: options.pass\n            };\n            _context3.prev = 26;\n            _context3.next = 29;\n            return repo.config.get('Keychain.DEK');\n\n          case 29:\n            keychainConfig.dek = _context3.sent;\n            _context3.next = 36;\n            break;\n\n          case 32:\n            _context3.prev = 32;\n            _context3.t1 = _context3[\"catch\"](26);\n\n            if (!(_context3.t1.code !== 'ERR_NOT_FOUND')) {\n              _context3.next = 36;\n              break;\n            }\n\n            throw _context3.t1;\n\n          case 36:\n            _context3.next = 38;\n            return createLibP2P({\n              options: undefined,\n              multiaddrs: undefined,\n              peerId: peerId,\n              repo: repo,\n              config: config,\n              keychainConfig: keychainConfig\n            });\n\n          case 38:\n            libp2p = _context3.sent;\n\n            if (!(libp2p.keychain && libp2p.keychain.opts)) {\n              _context3.next = 44;\n              break;\n            }\n\n            _context3.next = 42;\n            return libp2p.loadKeychain();\n\n          case 42:\n            _context3.next = 44;\n            return repo.config.set('Keychain', {\n              DEK: libp2p.keychain.opts.dek\n            });\n\n          case 44:\n            return _context3.abrupt(\"return\", {\n              peerId: peerId,\n              keychain: libp2p.keychain\n            });\n\n          case 45:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[26, 32]]);\n  }));\n\n  return function initRepo(_x7, _x8, _x9) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>|PeerId}\n */\n\n\nvar decodePeerId = function decodePeerId(peerId) {\n  log('using user-supplied private-key');\n  return typeof peerId === 'object' ? peerId : PeerId.createFromPrivKey(uint8ArrayFromString(peerId, 'base64pad'));\n};\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {Object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\n\n\nvar initPeerId = function initPeerId(print, _ref3) {\n  var _ref3$algorithm = _ref3.algorithm,\n      algorithm = _ref3$algorithm === void 0 ? 'Ed25519' : _ref3$algorithm,\n      _ref3$bits = _ref3.bits,\n      bits = _ref3$bits === void 0 ? 2048 : _ref3$bits;\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm);\n  return PeerId.create({\n    keyType: algorithm,\n    bits: bits\n  });\n};\n/**\n * @param {PeerId} peerId\n */\n\n\nvar peerIdToIdentity = function peerIdToIdentity(peerId) {\n  return {\n    PeerID: peerId.toB58String(),\n\n    /** @type {string} */\n    PrivKey: uint8ArrayToString(peerId.privKey.bytes, 'base64pad')\n  };\n};\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nvar configureRepo = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(repo, options) {\n    var config, profiles, pass, original, changed, peerId, libp2p;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            config = options.config;\n            profiles = options.init && options.init.profiles || [];\n            pass = options.pass;\n            _context4.next = 5;\n            return repo.config.getAll();\n\n          case 5:\n            original = _context4.sent;\n            changed = mergeConfigs(applyProfiles(original, profiles), config);\n\n            if (!(original !== changed)) {\n              _context4.next = 10;\n              break;\n            }\n\n            _context4.next = 10;\n            return repo.config.replace(changed);\n\n          case 10:\n            if (!(!changed.Identity || !changed.Identity.PrivKey)) {\n              _context4.next = 12;\n              break;\n            }\n\n            throw new NotInitializedError('No private key was found in the config, please intialize the repo');\n\n          case 12:\n            _context4.next = 14;\n            return PeerId.createFromPrivKey(changed.Identity.PrivKey);\n\n          case 14:\n            peerId = _context4.sent;\n            _context4.next = 17;\n            return createLibP2P({\n              options: undefined,\n              multiaddrs: undefined,\n              peerId: peerId,\n              repo: repo,\n              config: changed,\n              keychainConfig: _objectSpread({\n                pass: pass\n              }, changed.Keychain)\n            });\n\n          case 17:\n            libp2p = _context4.sent;\n\n            if (!libp2p.keychain) {\n              _context4.next = 21;\n              break;\n            }\n\n            _context4.next = 21;\n            return libp2p.loadKeychain();\n\n          case 21:\n            return _context4.abrupt(\"return\", {\n              peerId: peerId,\n              keychain: libp2p.keychain\n            });\n\n          case 22:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function configureRepo(_x10, _x11) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\n\n\nvar mergeConfigs = function mergeConfigs(config, changes) {\n  return changes ? mergeOptions(config, changes) : config;\n};\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\n\n\nvar applyProfiles = function applyProfiles(config, profiles) {\n  return (profiles || []).reduce(function (config, name) {\n    var profile = configService.profiles[name];\n\n    if (!profile) {\n      throw new Error(\"Could not find profile with name '\".concat(name, \"'\"));\n    }\n\n    log('applying profile %s', name);\n    return profile.transform(config);\n  }, config);\n};","map":{"version":3,"names":["log","require","createRepo","getDefaultConfig","ERR_REPO_NOT_INITIALIZED","errors","uint8ArrayFromString","fromString","uint8ArrayToString","toString","PeerId","mergeOptions","bind","ignoreUndefined","configService","NotEnabledError","NotInitializedError","createLibP2P","Storage","peerId","keychain","repo","print","isNew","codecs","options","repoAutoMigrate","inputRepo","onMigrationProgress","path","autoMigrate","loadRepo","module","exports","closed","configureRepo","open","code","init","allowNew","initRepo","initOptions","exists","Error","privateKey","decodePeerId","initPeerId","identity","peerIdToIdentity","PeerID","config","applyProfiles","profiles","Identity","keychainConfig","pass","get","dek","undefined","multiaddrs","libp2p","opts","loadKeychain","set","DEK","createFromPrivKey","algorithm","bits","create","keyType","toB58String","PrivKey","privKey","bytes","getAll","original","changed","mergeConfigs","replace","Keychain","changes","reduce","name","profile","transform"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/storage.js"],"sourcesContent":["'use strict'\n\nconst log = require('debug')('ipfs:components:peer:storage')\nconst createRepo = require('../runtime/repo-nodejs')\nconst getDefaultConfig = require('../runtime/config-nodejs')\nconst { ERR_REPO_NOT_INITIALIZED } = require('ipfs-repo').errors\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst PeerId = require('peer-id')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst configService = require('./config')\nconst { NotEnabledError, NotInitializedError } = require('../errors')\nconst createLibP2P = require('./libp2p')\n\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('libp2p-crypto').KeyType} KeyType\n * @typedef {import('libp2p/src/keychain')} Keychain\n */\n\nclass Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor (peerId, keychain, repo, print, isNew) {\n    this.print = print\n    this.peerId = peerId\n    this.keychain = keychain\n    this.repo = repo\n    this.print = print\n    this.isNew = isNew\n  }\n\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n   * @param {IPFSOptions} options\n   */\n  static async start (print, codecs, options) {\n    const { repoAutoMigrate, repo: inputRepo, onMigrationProgress } = options\n\n    const repo = (typeof inputRepo === 'string' || inputRepo == null)\n      ? createRepo(print, codecs, {\n        path: inputRepo,\n        autoMigrate: repoAutoMigrate,\n        onMigrationProgress: onMigrationProgress\n      })\n      : inputRepo\n\n    const { peerId, keychain, isNew } = await loadRepo(print, repo, options)\n\n    // TODO: throw error?\n    // @ts-ignore On start, keychain will always be available\n    return new Storage(peerId, keychain, repo, print, isNew)\n  }\n}\nmodule.exports = Storage\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\nconst loadRepo = async (print, repo, options) => {\n  if (!repo.closed) {\n    return { ...await configureRepo(repo, options), isNew: false }\n  }\n\n  try {\n    await repo.open()\n\n    return { ...await configureRepo(repo, options), isNew: false }\n  } catch (err) {\n    if (err.code !== ERR_REPO_NOT_INITIALIZED) {\n      throw err\n    }\n\n    if (options.init && options.init.allowNew === false) {\n      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it')\n    }\n\n    return { ...await initRepo(print, repo, options), isNew: true }\n  }\n}\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst initRepo = async (print, repo, options) => {\n  const initOptions = options.init || {}\n\n  // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n  const exists = await repo.exists()\n  log('repo exists?', exists)\n\n  if (exists === true) {\n    throw new Error('repo already exists')\n  }\n\n  // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.\n  const peerId = initOptions.privateKey\n    ? await decodePeerId(initOptions.privateKey)\n    : await initPeerId(print, initOptions)\n\n  const identity = peerIdToIdentity(peerId)\n\n  log('peer identity: %s', identity.PeerID)\n\n  // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n  const config = {\n    ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),\n    Identity: identity\n  }\n  await repo.init(config)\n\n  // 4. Open initialized repo.\n  await repo.open()\n\n  log('repo opened')\n\n  /** @type {import('./libp2p').KeychainConfig} */\n  const keychainConfig = {\n    pass: options.pass\n  }\n\n  try {\n    keychainConfig.dek = await repo.config.get('Keychain.DEK')\n  } catch (err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err\n    }\n  }\n\n  // Create libp2p for Keychain creation\n  const libp2p = await createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig\n  })\n\n  if (libp2p.keychain && libp2p.keychain.opts) {\n    await libp2p.loadKeychain()\n\n    await repo.config.set('Keychain', {\n      DEK: libp2p.keychain.opts.dek\n    })\n  }\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>|PeerId}\n */\nconst decodePeerId = (peerId) => {\n  log('using user-supplied private-key')\n  return typeof peerId === 'object'\n    ? peerId\n    : PeerId.createFromPrivKey(uint8ArrayFromString(peerId, 'base64pad'))\n}\n\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {Object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\nconst initPeerId = (print, { algorithm = 'Ed25519', bits = 2048 }) => {\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm)\n  return PeerId.create({ keyType: algorithm, bits })\n}\n\n/**\n * @param {PeerId} peerId\n */\nconst peerIdToIdentity = (peerId) => ({\n  PeerID: peerId.toB58String(),\n  /** @type {string} */\n  PrivKey: uint8ArrayToString(peerId.privKey.bytes, 'base64pad')\n})\n\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst configureRepo = async (repo, options) => {\n  const config = options.config\n  const profiles = (options.init && options.init.profiles) || []\n  const pass = options.pass\n  const original = await repo.config.getAll()\n  const changed = mergeConfigs(applyProfiles(original, profiles), config)\n\n  if (original !== changed) {\n    await repo.config.replace(changed)\n  }\n\n  if (!changed.Identity || !changed.Identity.PrivKey) {\n    throw new NotInitializedError('No private key was found in the config, please intialize the repo')\n  }\n\n  const peerId = await PeerId.createFromPrivKey(changed.Identity.PrivKey)\n  const libp2p = await createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  })\n\n  if (libp2p.keychain) {\n    await libp2p.loadKeychain()\n  }\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\nconst mergeConfigs = (config, changes) =>\n  changes ? mergeOptions(config, changes) : config\n\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configService.profiles[name]\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`)\n    }\n    log('applying profile %s', name)\n    return profile.transform(config)\n  }, config)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}