{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar debug = require('debug');\n\nvar log = debug('dns-over-http-resolver');\nlog.error = debug('dns-over-http-resolver:error');\n\nvar Receptacle = require('receptacle');\n\nvar utils = require('./utils');\n/**\n * DNS over HTTP resolver.\n * Uses a list of servers to resolve DNS records with HTTP requests.\n */\n\n\nvar Resolver = /*#__PURE__*/function () {\n  /**\n   * @class\n   * @param {object} [properties]\n   * @param {number} [properties.maxCache = 100] - maximum number of cached dns records.\n   */\n  function Resolver() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$maxCache = _ref.maxCache,\n        maxCache = _ref$maxCache === void 0 ? 100 : _ref$maxCache;\n\n    _classCallCheck(this, Resolver);\n\n    this._cache = new Receptacle({\n      max: maxCache\n    });\n    this._servers = ['https://cloudflare-dns.com/dns-query', 'https://dns.google/resolve'];\n  }\n  /**\n   * Get an array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   *\n   * @returns {Array<string>}\n   */\n\n\n  _createClass(Resolver, [{\n    key: \"getServers\",\n    value: function getServers() {\n      return this._servers;\n    }\n    /**\n     * Get a shuffled array of the IP addresses currently configured for DNS resolution.\n     * These addresses are formatted according to RFC 5952. It can include a custom port.\n     *\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"_getShuffledServers\",\n    value: function _getShuffledServers() {\n      var newServers = [].concat(this._servers);\n\n      for (var i = newServers.length - 1; i > 0; i--) {\n        var j = Math.floor(Math.random() * i);\n        var temp = newServers[i];\n        newServers[i] = newServers[j];\n        newServers[j] = temp;\n      }\n\n      return newServers;\n    }\n    /**\n     * Sets the IP address and port of servers to be used when performing DNS resolution.\n     *\n     * @param {Array<string>} servers - array of RFC 5952 formatted addresses.\n     */\n\n  }, {\n    key: \"setServers\",\n    value: function setServers(servers) {\n      this._servers = servers;\n    }\n    /**\n     * Uses the DNS protocol to resolve the given host name into the appropriate DNS record.\n     *\n     * @param {string} hostname - host name to resolve.\n     * @param {string} [rrType = 'A'] - resource record type.\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(hostname) {\n      var rrType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'A';\n\n      switch (rrType) {\n        case 'A':\n          return this.resolve4(hostname);\n\n        case 'AAAA':\n          return this.resolve6(hostname);\n\n        case 'TXT':\n          return this.resolveTxt(hostname);\n\n        default:\n          throw new Error(\"\".concat(rrType, \" is not supported\"));\n      }\n    }\n    /**\n     * Uses the DNS protocol to resolve the given host name into IPv4 addresses.\n     *\n     * @param {string} hostname - host name to resolve.\n     * @returns {Promise<Array<string>>}\n     */\n\n  }, {\n    key: \"resolve4\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(hostname) {\n        var recordType, cached, _iterator, _step, server, response, d, data, ttl;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                recordType = 'A';\n                cached = this._cache.get(utils.getCacheKey(hostname, recordType));\n\n                if (!cached) {\n                  _context.next = 4;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", cached);\n\n              case 4:\n                _iterator = _createForOfIteratorHelper(this._getShuffledServers());\n                _context.prev = 5;\n\n                _iterator.s();\n\n              case 7:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 27;\n                  break;\n                }\n\n                server = _step.value;\n                _context.prev = 9;\n                _context.next = 12;\n                return utils.fetch(utils.buildResource({\n                  serverResolver: server,\n                  hostname: hostname,\n                  recordType: recordType\n                }));\n\n              case 12:\n                response = _context.sent;\n                _context.next = 15;\n                return response.json();\n\n              case 15:\n                d = _context.sent;\n                data = d.Answer.map(function (a) {\n                  return a.data;\n                });\n                ttl = Math.min(d.Answer.map(function (a) {\n                  return a.TTL;\n                }));\n\n                this._cache.set(utils.getCacheKey(hostname, recordType), data, {\n                  ttl: ttl\n                });\n\n                return _context.abrupt(\"return\", data);\n\n              case 22:\n                _context.prev = 22;\n                _context.t0 = _context[\"catch\"](9);\n                log.error(\"\".concat(server, \" could not resolve \").concat(hostname, \" record \").concat(recordType));\n\n              case 25:\n                _context.next = 7;\n                break;\n\n              case 27:\n                _context.next = 32;\n                break;\n\n              case 29:\n                _context.prev = 29;\n                _context.t1 = _context[\"catch\"](5);\n\n                _iterator.e(_context.t1);\n\n              case 32:\n                _context.prev = 32;\n\n                _iterator.f();\n\n                return _context.finish(32);\n\n              case 35:\n                throw new Error(\"Could not resolve \".concat(hostname, \" record \").concat(recordType));\n\n              case 36:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 29, 32, 35], [9, 22]]);\n      }));\n\n      function resolve4(_x) {\n        return _resolve.apply(this, arguments);\n      }\n\n      return resolve4;\n    }()\n    /**\n     * Uses the DNS protocol to resolve the given host name into IPv6 addresses.\n     *\n     * @param {string} hostname - host name to resolve.\n     * @returns {Promise<Array<string>>}\n     */\n\n  }, {\n    key: \"resolve6\",\n    value: function () {\n      var _resolve2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(hostname) {\n        var recordType, cached, _iterator2, _step2, server, response, d, data, ttl;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                recordType = 'AAAA';\n                cached = this._cache.get(utils.getCacheKey(hostname, recordType));\n\n                if (!cached) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", cached);\n\n              case 4:\n                _iterator2 = _createForOfIteratorHelper(this._getShuffledServers());\n                _context2.prev = 5;\n\n                _iterator2.s();\n\n              case 7:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context2.next = 27;\n                  break;\n                }\n\n                server = _step2.value;\n                _context2.prev = 9;\n                _context2.next = 12;\n                return utils.fetch(utils.buildResource({\n                  serverResolver: server,\n                  hostname: hostname,\n                  recordType: recordType\n                }));\n\n              case 12:\n                response = _context2.sent;\n                _context2.next = 15;\n                return response.json();\n\n              case 15:\n                d = _context2.sent;\n                data = d.Answer.map(function (a) {\n                  return a.data;\n                });\n                ttl = Math.min(d.Answer.map(function (a) {\n                  return a.TTL;\n                }));\n\n                this._cache.set(utils.getCacheKey(hostname, recordType), data, {\n                  ttl: ttl\n                });\n\n                return _context2.abrupt(\"return\", data);\n\n              case 22:\n                _context2.prev = 22;\n                _context2.t0 = _context2[\"catch\"](9);\n                log.error(\"\".concat(server, \" could not resolve \").concat(hostname, \" record \").concat(recordType));\n\n              case 25:\n                _context2.next = 7;\n                break;\n\n              case 27:\n                _context2.next = 32;\n                break;\n\n              case 29:\n                _context2.prev = 29;\n                _context2.t1 = _context2[\"catch\"](5);\n\n                _iterator2.e(_context2.t1);\n\n              case 32:\n                _context2.prev = 32;\n\n                _iterator2.f();\n\n                return _context2.finish(32);\n\n              case 35:\n                throw new Error(\"Could not resolve \".concat(hostname, \" record \").concat(recordType));\n\n              case 36:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[5, 29, 32, 35], [9, 22]]);\n      }));\n\n      function resolve6(_x2) {\n        return _resolve2.apply(this, arguments);\n      }\n\n      return resolve6;\n    }()\n    /**\n     * Uses the DNS protocol to resolve the given host name into a Text record.\n     *\n     * @param {string} hostname - host name to resolve.\n     * @returns {Promise<Array<Array<string>>>}\n     */\n\n  }, {\n    key: \"resolveTxt\",\n    value: function () {\n      var _resolveTxt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(hostname) {\n        var recordType, cached, _iterator3, _step3, server, response, d, data, ttl;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                recordType = 'TXT';\n                cached = this._cache.get(utils.getCacheKey(hostname, recordType));\n\n                if (!cached) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", cached);\n\n              case 4:\n                _iterator3 = _createForOfIteratorHelper(this._getShuffledServers());\n                _context3.prev = 5;\n\n                _iterator3.s();\n\n              case 7:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context3.next = 27;\n                  break;\n                }\n\n                server = _step3.value;\n                _context3.prev = 9;\n                _context3.next = 12;\n                return utils.fetch(utils.buildResource({\n                  serverResolver: server,\n                  hostname: hostname,\n                  recordType: recordType\n                }));\n\n              case 12:\n                response = _context3.sent;\n                _context3.next = 15;\n                return response.json();\n\n              case 15:\n                d = _context3.sent;\n                data = d.Answer.map(function (a) {\n                  return [a.data.replace(/['\"]+/g, '')];\n                });\n                ttl = Math.min(d.Answer.map(function (a) {\n                  return a.TTL;\n                }));\n\n                this._cache.set(utils.getCacheKey(hostname, recordType), data, {\n                  ttl: ttl\n                });\n\n                return _context3.abrupt(\"return\", data);\n\n              case 22:\n                _context3.prev = 22;\n                _context3.t0 = _context3[\"catch\"](9);\n                log.error(\"\".concat(server, \" could not resolve \").concat(hostname, \" record \").concat(recordType));\n\n              case 25:\n                _context3.next = 7;\n                break;\n\n              case 27:\n                _context3.next = 32;\n                break;\n\n              case 29:\n                _context3.prev = 29;\n                _context3.t1 = _context3[\"catch\"](5);\n\n                _iterator3.e(_context3.t1);\n\n              case 32:\n                _context3.prev = 32;\n\n                _iterator3.f();\n\n                return _context3.finish(32);\n\n              case 35:\n                throw new Error(\"Could not resolve \".concat(hostname, \" record \").concat(recordType));\n\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[5, 29, 32, 35], [9, 22]]);\n      }));\n\n      function resolveTxt(_x3) {\n        return _resolveTxt.apply(this, arguments);\n      }\n\n      return resolveTxt;\n    }()\n  }]);\n\n  return Resolver;\n}();\n\nResolver.Resolver = Resolver;\nmodule.exports = Resolver;","map":{"version":3,"names":["debug","require","log","error","Receptacle","utils","Resolver","maxCache","_cache","max","_servers","newServers","concat","i","length","j","Math","floor","random","temp","servers","hostname","rrType","resolve4","resolve6","resolveTxt","Error","recordType","cached","get","getCacheKey","_getShuffledServers","server","fetch","buildResource","serverResolver","response","json","d","data","Answer","map","a","ttl","min","TTL","set","replace","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/dns-over-http-resolver/src/index.js"],"sourcesContent":["'use strict'\nconst debug = require('debug')\nconst log = debug('dns-over-http-resolver')\nlog.error = debug('dns-over-http-resolver:error')\n\nconst Receptacle = require('receptacle')\n\nconst utils = require('./utils')\n\n/**\n * DNS over HTTP resolver.\n * Uses a list of servers to resolve DNS records with HTTP requests.\n */\nclass Resolver {\n  /**\n   * @class\n   * @param {object} [properties]\n   * @param {number} [properties.maxCache = 100] - maximum number of cached dns records.\n   */\n  constructor ({ maxCache = 100 } = {}) {\n    this._cache = new Receptacle({ max: maxCache })\n    this._servers = [\n      'https://cloudflare-dns.com/dns-query',\n      'https://dns.google/resolve'\n    ]\n  }\n\n  /**\n   * Get an array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   *\n   * @returns {Array<string>}\n   */\n  getServers () {\n    return this._servers\n  }\n\n  /**\n   * Get a shuffled array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   *\n   * @returns {Array<string>}\n   */\n  _getShuffledServers () {\n    const newServers = [].concat(this._servers)\n\n    for (let i = newServers.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * i)\n      const temp = newServers[i]\n      newServers[i] = newServers[j]\n      newServers[j] = temp\n    }\n\n    return newServers\n  }\n\n  /**\n   * Sets the IP address and port of servers to be used when performing DNS resolution.\n   *\n   * @param {Array<string>} servers - array of RFC 5952 formatted addresses.\n   */\n  setServers (servers) {\n    this._servers = servers\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into the appropriate DNS record.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @param {string} [rrType = 'A'] - resource record type.\n   * @returns {Promise<*>}\n   */\n  resolve (hostname, rrType = 'A') {\n    switch (rrType) {\n      case 'A':\n        return this.resolve4(hostname)\n      case 'AAAA':\n        return this.resolve6(hostname)\n      case 'TXT':\n        return this.resolveTxt(hostname)\n      default:\n        throw new Error(`${rrType} is not supported`)\n    }\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv4 addresses.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @returns {Promise<Array<string>>}\n   */\n  async resolve4 (hostname) {\n    const recordType = 'A'\n    const cached = this._cache.get(utils.getCacheKey(hostname, recordType))\n    if (cached) {\n      return cached\n    }\n\n    for (const server of this._getShuffledServers()) {\n      try {\n        const response = await utils.fetch(utils.buildResource({\n          serverResolver: server,\n          hostname,\n          recordType\n        }))\n\n        const d = await response.json()\n        const data = d.Answer.map(a => a.data)\n        const ttl = Math.min(d.Answer.map(a => a.TTL))\n\n        this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl })\n\n        return data\n      } catch (err) {\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`)\n      }\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`)\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv6 addresses.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @returns {Promise<Array<string>>}\n   */\n  async resolve6 (hostname) {\n    const recordType = 'AAAA'\n    const cached = this._cache.get(utils.getCacheKey(hostname, recordType))\n    if (cached) {\n      return cached\n    }\n\n    for (const server of this._getShuffledServers()) {\n      try {\n        const response = await utils.fetch(utils.buildResource({\n          serverResolver: server,\n          hostname,\n          recordType\n        }))\n\n        const d = await response.json()\n        const data = d.Answer.map(a => a.data)\n        const ttl = Math.min(d.Answer.map(a => a.TTL))\n\n        this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl })\n\n        return data\n      } catch (err) {\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`)\n      }\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`)\n  }\n\n  /**\n   * Uses the DNS protocol to resolve the given host name into a Text record.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @returns {Promise<Array<Array<string>>>}\n   */\n  async resolveTxt (hostname) {\n    const recordType = 'TXT'\n    const cached = this._cache.get(utils.getCacheKey(hostname, recordType))\n    if (cached) {\n      return cached\n    }\n\n    for (const server of this._getShuffledServers()) {\n      try {\n        const response = await utils.fetch(utils.buildResource({\n          serverResolver: server,\n          hostname,\n          recordType\n        }))\n\n        const d = await response.json()\n        const data = d.Answer.map(a => [a.data.replace(/['\"]+/g, '')])\n        const ttl = Math.min(d.Answer.map(a => a.TTL))\n\n        this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl })\n\n        return data\n      } catch (err) {\n        log.error(`${server} could not resolve ${hostname} record ${recordType}`)\n      }\n    }\n\n    throw new Error(`Could not resolve ${hostname} record ${recordType}`)\n  }\n}\n\nResolver.Resolver = Resolver\nmodule.exports = Resolver\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}