{"ast":null,"code":"'use strict';\n\nconst {\n  CID\n} = require('multiformats');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58'); // @ts-ignore\n\n\nconst vd = require('varint-decoder');\n\nconst {\n  isMapEqual\n} = require('../../utils');\n\nconst {\n  Message\n} = require('./message');\n\nconst Entry = require('./entry');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst errcode = require('err-code');\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n */\n\n\nclass BitswapMessage {\n  /**\n   * @param {boolean} full\n   */\n  constructor(full) {\n    this.full = full;\n    /** @type {Map<string, Entry>} */\n\n    this.wantlist = new Map();\n    /** @type {Map<string, Uint8Array>} */\n\n    this.blocks = new Map();\n    /** @type {Map<string, import('./message').Message.BlockPresenceType>} */\n\n    this.blockPresences = new Map();\n    this.pendingBytes = 0;\n  }\n\n  get empty() {\n    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;\n  }\n  /**\n   *\n   * @param {CID} cid\n   * @param {number} priority\n   * @param {import('./message').Message.Wantlist.WantType | null} [wantType]\n   * @param {boolean} [cancel]\n   * @param {boolean} [sendDontHave]\n   * @returns {void}\n   */\n\n\n  addEntry(cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block;\n    }\n\n    const cidStr = cid.toString(base58btc);\n    const entry = this.wantlist.get(cidStr);\n\n    if (entry) {\n      // Only change priority if want is of the same type\n      if (entry.wantType === wantType) {\n        entry.priority = priority;\n      } // Only change from \"dont cancel\" to \"do cancel\"\n\n\n      if (cancel) {\n        entry.cancel = Boolean(cancel);\n      } // Only change from \"dont send\" to \"do send\" DONT_HAVE\n\n\n      if (sendDontHave) {\n        entry.sendDontHave = Boolean(sendDontHave);\n      } // want-block overrides existing want-have\n\n\n      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n        entry.wantType = wantType;\n      }\n    } else {\n      this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave));\n    }\n  }\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @returns {void}\n   */\n\n\n  addBlock(cid, block) {\n    const cidStr = cid.toString(base58btc);\n    this.blocks.set(cidStr, block);\n  }\n  /**\n   * @param {CID} cid\n   */\n\n\n  addHave(cid) {\n    const cidStr = cid.toString(base58btc);\n\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n    }\n  }\n  /**\n   * @param {CID} cid\n   */\n\n\n  addDontHave(cid) {\n    const cidStr = cid.toString(base58btc);\n\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n    }\n  }\n  /**\n   * @param {CID} cid\n   */\n\n\n  cancel(cid) {\n    const cidStr = cid.toString(base58btc);\n    this.wantlist.delete(cidStr);\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n  }\n  /**\n   * @param {number} size\n   */\n\n\n  setPendingBytes(size) {\n    this.pendingBytes = size;\n  }\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.0.0\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  serializeToBitswap100() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.bytes,\n            // cid\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          };\n        }),\n        full: this.full ? true : undefined\n      },\n      blocks: Array.from(this.blocks.values())\n    };\n    return Message.encode(msg).finish();\n  }\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.1.0\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  serializeToBitswap110() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.bytes,\n            // cid\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          };\n        }),\n        full: this.full ? true : undefined\n      },\n\n      /** @type {import('./message').Message.BlockPresence[]} */\n      blockPresences: [],\n\n      /** @type {{ prefix: Uint8Array, data: Uint8Array }[]} */\n      payload: [],\n      pendingBytes: this.pendingBytes\n    };\n\n    for (const [cidStr, data] of this.blocks.entries()) {\n      const cid = CID.parse(cidStr);\n      const codec = Uint8Array.from([cid.code]);\n      const multihash = cid.multihash.bytes.subarray(0, 2);\n      const prefix = uint8ArrayConcat([[cid.version], codec, multihash], 1 + codec.byteLength + multihash.byteLength);\n      msg.payload.push(new Message.Block({\n        prefix,\n        data\n      }));\n    }\n\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push(new Message.BlockPresence({\n        cid: CID.parse(cidStr).bytes,\n        type: bpType\n      }));\n    }\n\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes;\n    }\n\n    return Message.encode(msg).finish();\n  }\n  /**\n   * @param {BitswapMessage} other\n   * @returns {boolean}\n   */\n\n\n  equals(other) {\n    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || // @TODO - Is this a bug ?\n    // @ts-expect-error - isMap equals map values to be objects not numbers\n    !isMapEqual(this.blockPresences, other.blockPresences)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get [Symbol.toStringTag]() {\n    const list = Array.from(this.wantlist.keys());\n    const blocks = Array.from(this.blocks.keys());\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;\n  }\n\n}\n/**\n * @param {Uint8Array} raw\n * @param {Record<number, MultihashHasher>} [hashers]\n */\n\n\nBitswapMessage.deserialize = async function (raw) {\n  let hashers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const decoded = Message.decode(raw);\n  const isFull = decoded.wantlist && decoded.wantlist.full || false;\n  const msg = new BitswapMessage(isFull);\n\n  if (decoded.wantlist && decoded.wantlist.entries) {\n    decoded.wantlist.entries.forEach(entry => {\n      if (!entry.block) {\n        return;\n      } // note: entry.block is the CID here\n\n\n      const cid = CID.decode(entry.block);\n      msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));\n    });\n  }\n\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach(blockPresence => {\n      if (!blockPresence.cid) {\n        return;\n      }\n\n      const cid = CID.decode(blockPresence.cid);\n\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid);\n      } else {\n        msg.addDontHave(cid);\n      }\n    });\n  } // Bitswap 1.0.0\n  // decoded.blocks are just the byte arrays\n\n\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async b => {\n      const hash = await sha256.digest(b);\n      const cid = CID.createV0(hash);\n      msg.addBlock(cid, b);\n    }));\n    return msg;\n  } // Bitswap 1.1.0\n\n\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async p => {\n      if (!p.prefix || !p.data) {\n        return;\n      }\n\n      const values = vd(p.prefix);\n      const cidVersion = values[0];\n      const multicodec = values[1];\n      const hashAlg = values[2];\n      const hasher = hashAlg === sha256.code ? sha256 : hashers[hashAlg];\n\n      if (!hasher) {\n        throw errcode(new Error('Unknown hash algorithm'), 'ERR_UNKNOWN_HASH_ALG');\n      } // const hashLen = values[3] // We haven't need to use this so far\n\n\n      const hash = await hasher.digest(p.data);\n      const cid = CID.create(cidVersion, multicodec, hash);\n      msg.addBlock(cid, p.data);\n    }));\n    msg.setPendingBytes(decoded.pendingBytes);\n    return msg;\n  }\n\n  return msg;\n};\n/**\n * @param {CID} cid\n */\n\n\nBitswapMessage.blockPresenceSize = cid => {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.bytes.length + 1;\n};\n\nBitswapMessage.Entry = Entry;\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n};\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n};\nmodule.exports = BitswapMessage;","map":{"version":3,"names":["CID","require","sha256","base58btc","vd","isMapEqual","Message","Entry","concat","uint8ArrayConcat","errcode","BitswapMessage","constructor","full","wantlist","Map","blocks","blockPresences","pendingBytes","empty","size","addEntry","cid","priority","wantType","cancel","sendDontHave","WantType","Block","cidStr","toString","entry","get","Boolean","Have","set","addBlock","block","addHave","has","BlockPresenceType","addDontHave","DontHave","delete","setPendingBytes","serializeToBitswap100","msg","entries","Array","from","values","map","bytes","Number","undefined","encode","finish","serializeToBitswap110","payload","data","parse","codec","Uint8Array","code","multihash","subarray","prefix","version","byteLength","push","bpType","BlockPresence","type","equals","other","Symbol","toStringTag","list","keys","deserialize","raw","hashers","decoded","decode","isFull","forEach","blockPresence","length","Promise","all","b","hash","digest","createV0","p","cidVersion","multicodec","hashAlg","hasher","Error","create","blockPresenceSize","Wantlist","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-bitswap/src/types/message/index.js"],"sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats')\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst { base58btc } = require('multiformats/bases/base58')\n// @ts-ignore\nconst vd = require('varint-decoder')\nconst { isMapEqual } = require('../../utils')\nconst { Message } = require('./message')\nconst Entry = require('./entry')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst errcode = require('err-code')\n\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n */\n\nclass BitswapMessage {\n  /**\n   * @param {boolean} full\n   */\n  constructor (full) {\n    this.full = full\n    /** @type {Map<string, Entry>} */\n    this.wantlist = new Map()\n\n    /** @type {Map<string, Uint8Array>} */\n    this.blocks = new Map()\n\n    /** @type {Map<string, import('./message').Message.BlockPresenceType>} */\n    this.blockPresences = new Map()\n    this.pendingBytes = 0\n  }\n\n  get empty () {\n    return this.blocks.size === 0 &&\n           this.wantlist.size === 0 &&\n           this.blockPresences.size === 0\n  }\n\n  /**\n   *\n   * @param {CID} cid\n   * @param {number} priority\n   * @param {import('./message').Message.Wantlist.WantType | null} [wantType]\n   * @param {boolean} [cancel]\n   * @param {boolean} [sendDontHave]\n   * @returns {void}\n   */\n  addEntry (cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block\n    }\n\n    const cidStr = cid.toString(base58btc)\n    const entry = this.wantlist.get(cidStr)\n    if (entry) {\n      // Only change priority if want is of the same type\n      if (entry.wantType === wantType) {\n        entry.priority = priority\n      }\n      // Only change from \"dont cancel\" to \"do cancel\"\n      if (cancel) {\n        entry.cancel = Boolean(cancel)\n      }\n      // Only change from \"dont send\" to \"do send\" DONT_HAVE\n      if (sendDontHave) {\n        entry.sendDontHave = Boolean(sendDontHave)\n      }\n      // want-block overrides existing want-have\n      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n        entry.wantType = wantType\n      }\n    } else {\n      this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave))\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @returns {void}\n   */\n  addBlock (cid, block) {\n    const cidStr = cid.toString(base58btc)\n    this.blocks.set(cidStr, block)\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  addHave (cid) {\n    const cidStr = cid.toString(base58btc)\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  addDontHave (cid) {\n    const cidStr = cid.toString(base58btc)\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  cancel (cid) {\n    const cidStr = cid.toString(base58btc)\n    this.wantlist.delete(cidStr)\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false)\n  }\n\n  /**\n   * @param {number} size\n   */\n  setPendingBytes (size) {\n    this.pendingBytes = size\n  }\n\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.0.0\n   *\n   * @returns {Uint8Array}\n   */\n  serializeToBitswap100 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.bytes, // cid\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          }\n        }),\n        full: this.full ? true : undefined\n      },\n      blocks: Array.from(this.blocks.values())\n    }\n\n    return Message.encode(msg).finish()\n  }\n\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.1.0\n   *\n   * @returns {Uint8Array}\n   */\n  serializeToBitswap110 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.bytes, // cid\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          }\n        }),\n        full: this.full ? true : undefined\n      },\n      /** @type {import('./message').Message.BlockPresence[]} */\n      blockPresences: [],\n\n      /** @type {{ prefix: Uint8Array, data: Uint8Array }[]} */\n      payload: [],\n      pendingBytes: this.pendingBytes\n    }\n\n    for (const [cidStr, data] of this.blocks.entries()) {\n      const cid = CID.parse(cidStr)\n      const codec = Uint8Array.from([cid.code])\n      const multihash = cid.multihash.bytes.subarray(0, 2)\n      const prefix = uint8ArrayConcat([\n        [cid.version], codec, multihash\n      ], 1 + codec.byteLength + multihash.byteLength)\n\n      msg.payload.push(\n        new Message.Block({\n          prefix,\n          data\n        })\n      )\n    }\n\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push(new Message.BlockPresence({\n        cid: CID.parse(cidStr).bytes,\n        type: bpType\n      }))\n    }\n\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes\n    }\n\n    return Message.encode(msg).finish()\n  }\n\n  /**\n   * @param {BitswapMessage} other\n   * @returns {boolean}\n   */\n  equals (other) {\n    if (this.full !== other.full ||\n        this.pendingBytes !== other.pendingBytes ||\n        !isMapEqual(this.wantlist, other.wantlist) ||\n        !isMapEqual(this.blocks, other.blocks) ||\n        // @TODO - Is this a bug ?\n        // @ts-expect-error - isMap equals map values to be objects not numbers\n        !isMapEqual(this.blockPresences, other.blockPresences)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  get [Symbol.toStringTag] () {\n    const list = Array.from(this.wantlist.keys())\n    const blocks = Array.from(this.blocks.keys())\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`\n  }\n}\n\n/**\n * @param {Uint8Array} raw\n * @param {Record<number, MultihashHasher>} [hashers]\n */\nBitswapMessage.deserialize = async (raw, hashers = {}) => {\n  const decoded = Message.decode(raw)\n\n  const isFull = (decoded.wantlist && decoded.wantlist.full) || false\n  const msg = new BitswapMessage(isFull)\n\n  if (decoded.wantlist && decoded.wantlist.entries) {\n    decoded.wantlist.entries.forEach((entry) => {\n      if (!entry.block) {\n        return\n      }\n      // note: entry.block is the CID here\n      const cid = CID.decode(entry.block)\n      msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave))\n    })\n  }\n\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach((blockPresence) => {\n      if (!blockPresence.cid) {\n        return\n      }\n\n      const cid = CID.decode(blockPresence.cid)\n\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid)\n      } else {\n        msg.addDontHave(cid)\n      }\n    })\n  }\n\n  // Bitswap 1.0.0\n  // decoded.blocks are just the byte arrays\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async (b) => {\n      const hash = await sha256.digest(b)\n      const cid = CID.createV0(hash)\n      msg.addBlock(cid, b)\n    }))\n    return msg\n  }\n\n  // Bitswap 1.1.0\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async (p) => {\n      if (!p.prefix || !p.data) {\n        return\n      }\n      const values = vd(p.prefix)\n      const cidVersion = values[0]\n      const multicodec = values[1]\n      const hashAlg = values[2]\n      const hasher = hashAlg === sha256.code ? sha256 : hashers[hashAlg]\n\n      if (!hasher) {\n        throw errcode(new Error('Unknown hash algorithm'), 'ERR_UNKNOWN_HASH_ALG')\n      }\n\n      // const hashLen = values[3] // We haven't need to use this so far\n      const hash = await hasher.digest(p.data)\n      const cid = CID.create(cidVersion, multicodec, hash)\n      msg.addBlock(cid, p.data)\n    }))\n    msg.setPendingBytes(decoded.pendingBytes)\n    return msg\n  }\n\n  return msg\n}\n\n/**\n * @param {CID} cid\n */\nBitswapMessage.blockPresenceSize = (cid) => {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.bytes.length + 1\n}\n\nBitswapMessage.Entry = Entry\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n}\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n}\nmodule.exports = BitswapMessage\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}