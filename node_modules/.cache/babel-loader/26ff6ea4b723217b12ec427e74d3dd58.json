{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst libp2pRecord = require('libp2p-record');\n\nconst c = require('../constants');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n\nconst Record = libp2pRecord.Record;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../query').DHTQueryResult} DHTQueryResult\n */\n\n/**\n * @param {import('../')} dht\n */\n\nmodule.exports = dht => {\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} rec\n   */\n  const putLocal = async (key, rec) => {\n    // eslint-disable-line require-await\n    return dht.datastore.put(utils.bufferToKey(key), rec);\n  };\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  const getLocal = async key => {\n    dht._log(`getLocal ${uint8ArrayToString(key, 'base32')}`);\n\n    const raw = await dht.datastore.get(utils.bufferToKey(key));\n\n    dht._log(`found ${uint8ArrayToString(key, 'base32')} in local datastore`);\n\n    const rec = Record.deserialize(raw);\n    await dht._verifyRecordLocally(rec);\n    return rec;\n  };\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Uint8Array} key\n   * @param {import('../query').DHTQueryValue[]} vals - values retrieved from the DHT\n   * @param {Uint8Array} best - the best record that was found\n   */\n\n\n  const sendCorrectionRecord = async (key, vals, best) => {\n    const fixupRec = await utils.createPutRecord(key, best);\n    return Promise.all(vals.map(async v => {\n      // no need to do anything\n      if (uint8ArrayEquals(v.val, best)) {\n        return;\n      } // correct ourself\n\n\n      if (dht._isSelf(v.from)) {\n        try {\n          await dht._putLocal(key, fixupRec);\n        } catch (err) {\n          dht._log.error('Failed error correcting self', err);\n        }\n\n        return;\n      } // send correction\n\n\n      try {\n        await dht._putValueToPeer(key, fixupRec, v.from);\n      } catch (err) {\n        dht._log.error('Failed error correcting entry', err);\n      }\n    }));\n  };\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} rec - encoded record\n     */\n    async _putLocal(key, rec) {\n      // eslint-disable-line require-await\n      return putLocal(key, rec);\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     * @param {object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     */\n    async put(key, value) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      dht._log('PutValue %b', key); // create record in the dht format\n\n\n      const record = await utils.createPutRecord(key, value); // store the record locally\n\n      await putLocal(key, record); // put record to the closest peers\n\n      let counterAll = 0;\n      let counterSuccess = 0;\n      await utils.mapParallel(dht.getClosestPeers(key, {\n        shallow: true\n      }), async peer => {\n        try {\n          counterAll += 1;\n          await dht._putValueToPeer(key, record, peer);\n          counterSuccess += 1;\n        } catch (err) {\n          dht._log.error('Failed to put to peer (%b): %s', peer.id, err);\n        }\n      }); // verify if we were able to put to enough peers\n\n      const minPeers = options.minPeers || counterAll; // Ensure we have a default `minPeers`\n\n      if (minPeers > counterSuccess) {\n        const error = errcode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS');\n\n        dht._log.error(error);\n\n        throw error;\n      }\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Uint8Array} key\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    async get(key) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      options.timeout = options.timeout || c.minute;\n\n      dht._log('_get %b', key);\n\n      const vals = await dht.getMany(key, c.GET_MANY_RECORD_COUNT, options);\n      const recs = vals.map(v => v.val);\n      let i = 0;\n\n      try {\n        i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);\n      } catch (err) {\n        // Assume the first record if no selector available\n        if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n          throw err;\n        }\n      }\n\n      const best = recs[i];\n\n      dht._log('GetValue %b %s', key, best);\n\n      if (!best) {\n        throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND');\n      }\n\n      await sendCorrectionRecord(key, vals, best);\n      return best;\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Uint8Array} key\n     * @param {number} nvals\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    async getMany(key, nvals) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      options.timeout = options.timeout || c.minute;\n\n      dht._log('getMany %b (%s)', key, nvals);\n\n      const vals = [];\n      let localRec;\n\n      try {\n        localRec = await getLocal(key);\n      } catch (err) {\n        if (nvals === 0) {\n          throw err;\n        }\n      }\n\n      if (localRec) {\n        vals.push({\n          val: localRec.value,\n          from: dht.peerId\n        });\n      }\n\n      if (vals.length >= nvals) {\n        return vals;\n      }\n\n      const id = await utils.convertBuffer(key);\n      const rtp = dht.routingTable.closestPeers(id, dht.kBucketSize);\n\n      dht._log('peers in rt: %d', rtp.length);\n\n      if (rtp.length === 0) {\n        const errMsg = 'Failed to lookup key! No peers from routing table!';\n\n        dht._log.error(errMsg);\n\n        if (vals.length === 0) {\n          throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE');\n        }\n\n        return vals;\n      }\n\n      const valsLength = vals.length;\n      /**\n       * @param {number} pathIndex\n       * @param {number} numPaths\n       */\n\n      function createQuery(pathIndex, numPaths) {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(nvals - valsLength, numPaths);\n        let queryResults = 0;\n        /**\n         * Here we return the query function to use on this particular disjoint path\n         *\n         * @param {PeerId} peer\n         */\n\n        async function disjointPathQuery(peer) {\n          let rec, peers, lookupErr;\n\n          try {\n            const results = await dht._getValueOrPeers(peer, key);\n            rec = results.record;\n            peers = results.peers;\n          } catch (err) {\n            // If we have an invalid record we just want to continue and fetch a new one.\n            if (err.code !== 'ERR_INVALID_RECORD') {\n              throw err;\n            }\n\n            lookupErr = err;\n          }\n          /** @type {import('../query').QueryResult} */\n\n\n          const res = {\n            closerPeers: peers\n          };\n\n          if (rec && rec.value) {\n            vals.push({\n              val: rec.value,\n              from: peer\n            });\n            queryResults++;\n          } else if (lookupErr) {\n            vals.push({\n              err: lookupErr,\n              from: peer\n            });\n            queryResults++;\n          } // enough is enough\n\n\n          if (queryResults >= pathSize) {\n            res.pathComplete = true;\n          }\n\n          return res;\n        }\n\n        return disjointPathQuery;\n      } // we have peers, lets send the actual query to them\n\n\n      const query = new Query(dht, key, createQuery);\n\n      try {\n        await pTimeout(query.run(rtp), options.timeout);\n      } catch (err) {\n        if (vals.length === 0) {\n          throw err;\n        }\n      } finally {\n        query.stop();\n      }\n\n      return vals;\n    }\n\n  };\n};","map":{"version":3,"names":["errcode","require","pTimeout","equals","uint8ArrayEquals","toString","uint8ArrayToString","libp2pRecord","c","Query","utils","Record","module","exports","dht","putLocal","key","rec","datastore","put","bufferToKey","getLocal","_log","raw","get","deserialize","_verifyRecordLocally","sendCorrectionRecord","vals","best","fixupRec","createPutRecord","Promise","all","map","v","val","_isSelf","from","_putLocal","err","error","_putValueToPeer","value","options","record","counterAll","counterSuccess","mapParallel","getClosestPeers","shallow","peer","id","minPeers","Error","timeout","minute","getMany","GET_MANY_RECORD_COUNT","recs","i","selection","bestRecord","selectors","code","nvals","localRec","push","peerId","length","convertBuffer","rtp","routingTable","closestPeers","kBucketSize","errMsg","valsLength","createQuery","pathIndex","numPaths","pathSize","queryResults","disjointPathQuery","peers","lookupErr","results","_getValueOrPeers","res","closerPeers","pathComplete","query","run","stop"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-kad-dht/src/content-fetching/index.js"],"sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst libp2pRecord = require('libp2p-record')\nconst c = require('../constants')\nconst Query = require('../query')\nconst utils = require('../utils')\nconst Record = libp2pRecord.Record\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../query').DHTQueryResult} DHTQueryResult\n */\n\n/**\n * @param {import('../')} dht\n */\nmodule.exports = (dht) => {\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} rec\n   */\n  const putLocal = async (key, rec) => { // eslint-disable-line require-await\n    return dht.datastore.put(utils.bufferToKey(key), rec)\n  }\n\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Uint8Array} key\n   */\n  const getLocal = async (key) => {\n    dht._log(`getLocal ${uint8ArrayToString(key, 'base32')}`)\n\n    const raw = await dht.datastore.get(utils.bufferToKey(key))\n    dht._log(`found ${uint8ArrayToString(key, 'base32')} in local datastore`)\n\n    const rec = Record.deserialize(raw)\n\n    await dht._verifyRecordLocally(rec)\n\n    return rec\n  }\n\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Uint8Array} key\n   * @param {import('../query').DHTQueryValue[]} vals - values retrieved from the DHT\n   * @param {Uint8Array} best - the best record that was found\n   */\n  const sendCorrectionRecord = async (key, vals, best) => {\n    const fixupRec = await utils.createPutRecord(key, best)\n\n    return Promise.all(vals.map(async (v) => {\n      // no need to do anything\n      if (uint8ArrayEquals(v.val, best)) {\n        return\n      }\n\n      // correct ourself\n      if (dht._isSelf(v.from)) {\n        try {\n          await dht._putLocal(key, fixupRec)\n        } catch (err) {\n          dht._log.error('Failed error correcting self', err)\n        }\n        return\n      }\n\n      // send correction\n      try {\n        await dht._putValueToPeer(key, fixupRec, v.from)\n      } catch (err) {\n        dht._log.error('Failed error correcting entry', err)\n      }\n    }))\n  }\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} rec - encoded record\n     */\n    async _putLocal (key, rec) { // eslint-disable-line require-await\n      return putLocal(key, rec)\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     * @param {object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     */\n    async put (key, value, options = {}) {\n      dht._log('PutValue %b', key)\n\n      // create record in the dht format\n      const record = await utils.createPutRecord(key, value)\n\n      // store the record locally\n      await putLocal(key, record)\n\n      // put record to the closest peers\n      let counterAll = 0\n      let counterSuccess = 0\n\n      await utils.mapParallel(dht.getClosestPeers(key, { shallow: true }), async (peer) => {\n        try {\n          counterAll += 1\n          await dht._putValueToPeer(key, record, peer)\n          counterSuccess += 1\n        } catch (err) {\n          dht._log.error('Failed to put to peer (%b): %s', peer.id, err)\n        }\n      })\n\n      // verify if we were able to put to enough peers\n      const minPeers = options.minPeers || counterAll // Ensure we have a default `minPeers`\n\n      if (minPeers > counterSuccess) {\n        const error = errcode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS')\n        dht._log.error(error)\n        throw error\n      }\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Uint8Array} key\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    async get (key, options = {}) {\n      options.timeout = options.timeout || c.minute\n\n      dht._log('_get %b', key)\n\n      const vals = await dht.getMany(key, c.GET_MANY_RECORD_COUNT, options)\n      const recs = vals.map((v) => v.val)\n      let i = 0\n\n      try {\n        i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs)\n      } catch (err) {\n        // Assume the first record if no selector available\n        if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n          throw err\n        }\n      }\n\n      const best = recs[i]\n      dht._log('GetValue %b %s', key, best)\n\n      if (!best) {\n        throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND')\n      }\n\n      await sendCorrectionRecord(key, vals, best)\n\n      return best\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Uint8Array} key\n     * @param {number} nvals\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    async getMany (key, nvals, options = {}) {\n      options.timeout = options.timeout || c.minute\n\n      dht._log('getMany %b (%s)', key, nvals)\n\n      const vals = []\n      let localRec\n\n      try {\n        localRec = await getLocal(key)\n      } catch (err) {\n        if (nvals === 0) {\n          throw err\n        }\n      }\n\n      if (localRec) {\n        vals.push({\n          val: localRec.value,\n          from: dht.peerId\n        })\n      }\n\n      if (vals.length >= nvals) {\n        return vals\n      }\n\n      const id = await utils.convertBuffer(key)\n      const rtp = dht.routingTable.closestPeers(id, dht.kBucketSize)\n\n      dht._log('peers in rt: %d', rtp.length)\n\n      if (rtp.length === 0) {\n        const errMsg = 'Failed to lookup key! No peers from routing table!'\n\n        dht._log.error(errMsg)\n        if (vals.length === 0) {\n          throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE')\n        }\n        return vals\n      }\n\n      const valsLength = vals.length\n\n      /**\n       * @param {number} pathIndex\n       * @param {number} numPaths\n       */\n      function createQuery (pathIndex, numPaths) {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(nvals - valsLength, numPaths)\n        let queryResults = 0\n\n        /**\n         * Here we return the query function to use on this particular disjoint path\n         *\n         * @param {PeerId} peer\n         */\n        async function disjointPathQuery (peer) {\n          let rec, peers, lookupErr\n          try {\n            const results = await dht._getValueOrPeers(peer, key)\n            rec = results.record\n            peers = results.peers\n          } catch (err) {\n            // If we have an invalid record we just want to continue and fetch a new one.\n            if (err.code !== 'ERR_INVALID_RECORD') {\n              throw err\n            }\n            lookupErr = err\n          }\n\n          /** @type {import('../query').QueryResult} */\n          const res = {\n            closerPeers: peers\n          }\n\n          if (rec && rec.value) {\n            vals.push({\n              val: rec.value,\n              from: peer\n            })\n\n            queryResults++\n          } else if (lookupErr) {\n            vals.push({\n              err: lookupErr,\n              from: peer\n            })\n\n            queryResults++\n          }\n\n          // enough is enough\n          if (queryResults >= pathSize) {\n            res.pathComplete = true\n          }\n\n          return res\n        }\n\n        return disjointPathQuery\n      }\n\n      // we have peers, lets send the actual query to them\n      const query = new Query(dht, key, createQuery)\n\n      try {\n        await pTimeout(query.run(rtp), options.timeout)\n      } catch (err) {\n        if (vals.length === 0) {\n          throw err\n        }\n      } finally {\n        query.stop()\n      }\n\n      return vals\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}