{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../types/message/entry')} BitswapMessageEntry\n * @typedef {import('peer-id')} PeerId\n */\n\nvar _toConsumableArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require('multiformats'),\n    CID = _require.CID;\n\nvar _require2 = require('multiformats/bases/base58'),\n    base58btc = _require2.base58btc;\n\nvar Message = require('../types/message');\n\nvar WantType = Message.WantType;\n\nvar Wantlist = require('../types/wantlist');\n\nvar Ledger = require('./ledger');\n\nvar RequestQueue = require('./req-queue');\n\nvar TaskMerger = require('./task-merger');\n\nvar _require3 = require('../utils'),\n    logger = _require3.logger; // The ideal size of the batched payload. We try to pop this much data off the\n// request queue, but\n// - if there isn't any more data in the queue we send whatever we have\n// - if there are several small items in the queue (eg HAVE response) followed\n//   by one big item (eg a block) that would exceed this target size, we\n//   include the big item in the message\n\n\nvar TARGET_MESSAGE_SIZE = 16 * 1024; // If the client sends a want-have, and the engine has the corresponding block,\n// we check the size of the block and if it's small enough we send the block\n// itself, rather than sending a HAVE.\n// This constant defines the maximum size up to which we replace a HAVE with\n// a block.\n\nvar MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;\n\nvar DecisionEngine = /*#__PURE__*/function () {\n  /**\n   * @param {PeerId} peerId\n   * @param {import('interface-blockstore').Blockstore} blockstore\n   * @param {import('../network')} network\n   * @param {import('../stats')} stats\n   * @param {Object} [opts]\n   * @param {number} [opts.targetMessageSize]\n   * @param {number} [opts.maxSizeReplaceHasWithBlock]\n   */\n  function DecisionEngine(peerId, blockstore, network, stats) {\n    var opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n    _classCallCheck(this, DecisionEngine);\n\n    this._log = logger(peerId, 'engine');\n    this.blockstore = blockstore;\n    this.network = network;\n    this._stats = stats;\n    this._opts = this._processOpts(opts); // A list of of ledgers by their partner id\n\n    /** @type {Map<string, Ledger>} */\n\n    this.ledgerMap = new Map();\n    this._running = false; // Queue of want-have / want-block per peer\n\n    this._requestQueue = new RequestQueue(TaskMerger);\n  }\n  /**\n   * @template {Object} Opts\n   * @param {Opts} opts\n   * @returns {Opts & {maxSizeReplaceHasWithBlock:number, targetMessageSize:number}}\n   * @private\n   */\n\n\n  _createClass(DecisionEngine, [{\n    key: \"_processOpts\",\n    value: function _processOpts(opts) {\n      return _objectSpread({\n        maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n        targetMessageSize: TARGET_MESSAGE_SIZE\n      }, opts);\n    }\n  }, {\n    key: \"_scheduleProcessTasks\",\n    value: function _scheduleProcessTasks() {\n      var _this = this;\n\n      setTimeout(function () {\n        _this._processTasks();\n      });\n    }\n    /**\n     * Pull tasks off the request queue and send a message to the corresponding\n     * peer\n     */\n\n  }, {\n    key: \"_processTasks\",\n    value: function () {\n      var _processTasks2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this$_requestQueue$p, peerId, tasks, pendingSize, msg, blockCids, blockTasks, _iterator, _step, task, cid, blocks, _iterator2, _step2, _step2$value, topic, taskData, _cid, blk, _iterator3, _step3, _step3$value, cidStr, block;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this._running) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                _this$_requestQueue$p = this._requestQueue.popTasks(this._opts.targetMessageSize), peerId = _this$_requestQueue$p.peerId, tasks = _this$_requestQueue$p.tasks, pendingSize = _this$_requestQueue$p.pendingSize;\n\n                if (!(tasks.length === 0)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 5:\n                // Create a new message\n                msg = new Message(false); // Amount of data in the request queue still waiting to be popped\n\n                msg.setPendingBytes(pendingSize); // Split out want-blocks, want-haves and DONT_HAVEs\n\n                blockCids = [];\n                blockTasks = new Map();\n                _iterator = _createForOfIteratorHelper(tasks);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    task = _step.value;\n                    cid = CID.parse(task.topic);\n\n                    if (task.data.haveBlock) {\n                      if (task.data.isWantBlock) {\n                        blockCids.push(cid);\n                        blockTasks.set(task.topic, task.data);\n                      } else {\n                        // Add HAVES to the message\n                        msg.addHave(cid);\n                      }\n                    } else {\n                      // Add DONT_HAVEs to the message\n                      msg.addDontHave(cid);\n                    }\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                _context.next = 13;\n                return this._getBlocks(blockCids);\n\n              case 13:\n                blocks = _context.sent;\n                _iterator2 = _createForOfIteratorHelper(blockTasks);\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    _step2$value = _slicedToArray(_step2.value, 2), topic = _step2$value[0], taskData = _step2$value[1];\n                    _cid = CID.parse(topic);\n                    blk = blocks.get(topic); // If the block was found (it has not been removed)\n\n                    if (blk) {\n                      // Add the block to the message\n                      msg.addBlock(_cid, blk);\n                    } else {\n                      // The block was not found. If the client requested DONT_HAVE,\n                      // add DONT_HAVE to the message.\n                      if (taskData.sendDontHave) {\n                        msg.addDontHave(_cid);\n                      }\n                    }\n                  } // If there's nothing in the message, bail out\n\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                if (!msg.empty) {\n                  _context.next = 20;\n                  break;\n                }\n\n                peerId && this._requestQueue.tasksDone(peerId, tasks); // Trigger the next round of task processing\n\n                this._scheduleProcessTasks();\n\n                return _context.abrupt(\"return\");\n\n              case 20:\n                _context.prev = 20;\n                _context.t0 = peerId;\n\n                if (!_context.t0) {\n                  _context.next = 25;\n                  break;\n                }\n\n                _context.next = 25;\n                return this.network.sendMessage(peerId, msg);\n\n              case 25:\n                // Peform sent message accounting\n                _iterator3 = _createForOfIteratorHelper(blocks.entries());\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    _step3$value = _slicedToArray(_step3.value, 2), cidStr = _step3$value[0], block = _step3$value[1];\n                    peerId && this.messageSent(peerId, CID.parse(cidStr), block);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                _context.next = 32;\n                break;\n\n              case 29:\n                _context.prev = 29;\n                _context.t1 = _context[\"catch\"](20);\n\n                this._log.error(_context.t1);\n\n              case 32:\n                // Free the tasks up from the request queue\n                peerId && this._requestQueue.tasksDone(peerId, tasks); // Trigger the next round of task processing\n\n                this._scheduleProcessTasks();\n\n              case 34:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[20, 29]]);\n      }));\n\n      function _processTasks() {\n        return _processTasks2.apply(this, arguments);\n      }\n\n      return _processTasks;\n    }()\n    /**\n     * @param {PeerId} peerId\n     * @returns {Map<string, import('../types/wantlist/entry')>}\n     */\n\n  }, {\n    key: \"wantlistForPeer\",\n    value: function wantlistForPeer(peerId) {\n      var peerIdStr = peerId.toB58String();\n      var ledger = this.ledgerMap.get(peerIdStr);\n      return ledger ? ledger.wantlist.sortedEntries() : new Map();\n    }\n    /**\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"ledgerForPeer\",\n    value: function ledgerForPeer(peerId) {\n      var peerIdStr = peerId.toB58String();\n      var ledger = this.ledgerMap.get(peerIdStr);\n\n      if (!ledger) {\n        return null;\n      }\n\n      return {\n        peer: ledger.partner,\n        value: ledger.debtRatio(),\n        sent: ledger.accounting.bytesSent,\n        recv: ledger.accounting.bytesRecv,\n        exchanged: ledger.exchangeCount\n      };\n    }\n    /**\n     * @returns {PeerId[]}\n     */\n\n  }, {\n    key: \"peers\",\n    value: function peers() {\n      return Array.from(this.ledgerMap.values()).map(function (l) {\n        return l.partner;\n      });\n    }\n    /**\n     * Receive blocks either from an incoming message from the network, or from\n     * blocks being added by the client on the localhost (eg IPFS add)\n     *\n     * @param {{ cid: CID, data: Uint8Array }[]} blocks\n     */\n\n  }, {\n    key: \"receivedBlocks\",\n    value: function receivedBlocks(blocks) {\n      if (!blocks.length) {\n        return;\n      } // For each connected peer, check if it wants the block we received\n\n\n      var _iterator4 = _createForOfIteratorHelper(this.ledgerMap.values()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var ledger = _step4.value;\n\n          var _iterator5 = _createForOfIteratorHelper(blocks),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var block = _step5.value;\n              // Filter out blocks that we don't want\n              var want = ledger.wantlistContains(block.cid);\n\n              if (!want) {\n                continue;\n              } // If the block is small enough, just send the block, even if the\n              // client asked for a HAVE\n\n\n              var blockSize = block.data.length;\n\n              var isWantBlock = this._sendAsBlock(want.wantType, blockSize);\n\n              var entrySize = blockSize;\n\n              if (!isWantBlock) {\n                entrySize = Message.blockPresenceSize(want.cid);\n              }\n\n              this._requestQueue.pushTasks(ledger.partner, [{\n                topic: want.cid.toString(base58btc),\n                priority: want.priority,\n                size: entrySize,\n                data: {\n                  blockSize: blockSize,\n                  isWantBlock: isWantBlock,\n                  haveBlock: true,\n                  sendDontHave: false\n                }\n              }]);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      this._scheduleProcessTasks();\n    }\n    /**\n     * Handle incoming messages\n     *\n     * @param {PeerId} peerId\n     * @param {Message} msg\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"messageReceived\",\n    value: function () {\n      var _messageReceived = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peerId, msg) {\n        var ledger, cancels, wants;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                ledger = this._findOrCreate(peerId);\n\n                if (!msg.empty) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                // If the message has a full wantlist, clear the current wantlist\n                if (msg.full) {\n                  ledger.wantlist = new Wantlist();\n                } // Record the amount of block data received\n\n\n                this._updateBlockAccounting(msg.blocks, ledger);\n\n                if (!(msg.wantlist.size === 0)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                this._scheduleProcessTasks();\n\n                return _context2.abrupt(\"return\");\n\n              case 8:\n                // Clear cancelled wants and add new wants to the ledger\n\n                /** @type {CID[]} */\n                cancels = [];\n                /** @type {BitswapMessageEntry[]} */\n\n                wants = [];\n                msg.wantlist.forEach(function (entry) {\n                  if (entry.cancel) {\n                    ledger.cancelWant(entry.cid);\n                    cancels.push(entry.cid);\n                  } else {\n                    ledger.wants(entry.cid, entry.priority, entry.wantType);\n                    wants.push(entry);\n                  }\n                });\n\n                this._cancelWants(peerId, cancels);\n\n                _context2.next = 14;\n                return this._addWants(peerId, wants);\n\n              case 14:\n                this._scheduleProcessTasks();\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function messageReceived(_x, _x2) {\n        return _messageReceived.apply(this, arguments);\n      }\n\n      return messageReceived;\n    }()\n    /**\n     * @private\n     * @param {PeerId} peerId\n     * @param {CID[]} cids\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_cancelWants\",\n    value: function _cancelWants(peerId, cids) {\n      var _iterator6 = _createForOfIteratorHelper(cids),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var c = _step6.value;\n\n          this._requestQueue.remove(c.toString(base58btc), peerId);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n    /**\n     * @private\n     * @param {PeerId} peerId\n     * @param {BitswapMessageEntry[]} wants\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_addWants\",\n    value: function () {\n      var _addWants2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(peerId, wants) {\n        var blockSizes, tasks, _iterator7, _step7, want, id, blockSize, isWantBlock, entrySize;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._getBlockSizes(wants.map(function (w) {\n                  return w.cid;\n                }));\n\n              case 2:\n                blockSizes = _context3.sent;\n                tasks = [];\n                _iterator7 = _createForOfIteratorHelper(wants);\n\n                try {\n                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                    want = _step7.value;\n                    id = want.cid.toString(base58btc);\n                    blockSize = blockSizes.get(id); // If the block was not found\n\n                    if (blockSize == null) {\n                      // Only add the task to the queue if the requester wants a DONT_HAVE\n                      if (want.sendDontHave) {\n                        tasks.push({\n                          topic: id,\n                          priority: want.priority,\n                          size: Message.blockPresenceSize(want.cid),\n                          data: {\n                            isWantBlock: want.wantType === WantType.Block,\n                            blockSize: 0,\n                            haveBlock: false,\n                            sendDontHave: want.sendDontHave\n                          }\n                        });\n                      }\n                    } else {\n                      // The block was found, add it to the queue\n                      // If the block is small enough, just send the block, even if the\n                      // client asked for a HAVE\n                      isWantBlock = this._sendAsBlock(want.wantType, blockSize); // entrySize is the amount of space the entry takes up in the\n                      // message we send to the recipient. If we're sending a block, the\n                      // entrySize is the size of the block. Otherwise it's the size of\n                      // a block presence entry.\n\n                      entrySize = blockSize;\n\n                      if (!isWantBlock) {\n                        entrySize = Message.blockPresenceSize(want.cid);\n                      }\n\n                      tasks.push({\n                        topic: id,\n                        priority: want.priority,\n                        size: entrySize,\n                        data: {\n                          isWantBlock: isWantBlock,\n                          blockSize: blockSize,\n                          haveBlock: true,\n                          sendDontHave: want.sendDontHave\n                        }\n                      });\n                    }\n\n                    this._requestQueue.pushTasks(peerId, tasks);\n                  }\n                } catch (err) {\n                  _iterator7.e(err);\n                } finally {\n                  _iterator7.f();\n                }\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _addWants(_x3, _x4) {\n        return _addWants2.apply(this, arguments);\n      }\n\n      return _addWants;\n    }()\n    /**\n     * @private\n     * @param {import('../types/message/message').Message.Wantlist.WantType} wantType\n     * @param {number} blockSize\n     */\n\n  }, {\n    key: \"_sendAsBlock\",\n    value: function _sendAsBlock(wantType, blockSize) {\n      return wantType === WantType.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;\n    }\n    /**\n     * @private\n     * @param {CID[]} cids\n     * @returns {Promise<Map<string, number>>}\n     */\n\n  }, {\n    key: \"_getBlockSizes\",\n    value: function () {\n      var _getBlockSizes2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(cids) {\n        var blocks;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._getBlocks(cids);\n\n              case 2:\n                blocks = _context4.sent;\n                return _context4.abrupt(\"return\", new Map(_toConsumableArray(blocks).map(function (_ref) {\n                  var _ref2 = _slicedToArray(_ref, 2),\n                      k = _ref2[0],\n                      v = _ref2[1];\n\n                  return [k, v.length];\n                })));\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _getBlockSizes(_x5) {\n        return _getBlockSizes2.apply(this, arguments);\n      }\n\n      return _getBlockSizes;\n    }()\n    /**\n     * @private\n     * @param {CID[]} cids\n     * @returns {Promise<Map<string, Uint8Array>>}\n     */\n\n  }, {\n    key: \"_getBlocks\",\n    value: function () {\n      var _getBlocks2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(cids) {\n        var _this2 = this;\n\n        var res;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                res = new Map();\n                _context6.next = 3;\n                return Promise.all(cids.map( /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(cid) {\n                    var block;\n                    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            _context5.prev = 0;\n                            _context5.next = 3;\n                            return _this2.blockstore.get(cid);\n\n                          case 3:\n                            block = _context5.sent;\n                            res.set(cid.toString(base58btc), block);\n                            _context5.next = 10;\n                            break;\n\n                          case 7:\n                            _context5.prev = 7;\n                            _context5.t0 = _context5[\"catch\"](0);\n\n                            if (_context5.t0.code !== 'ERR_NOT_FOUND') {\n                              _this2._log.error('failed to query blockstore for %s: %s', cid, _context5.t0);\n                            }\n\n                          case 10:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5, null, [[0, 7]]);\n                  }));\n\n                  return function (_x7) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()));\n\n              case 3:\n                return _context6.abrupt(\"return\", res);\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function _getBlocks(_x6) {\n        return _getBlocks2.apply(this, arguments);\n      }\n\n      return _getBlocks;\n    }()\n    /**\n     * @private\n     * @param {Map<string, Uint8Array>} blocksMap\n     * @param {Ledger} ledger\n     */\n\n  }, {\n    key: \"_updateBlockAccounting\",\n    value: function _updateBlockAccounting(blocksMap, ledger) {\n      var _iterator8 = _createForOfIteratorHelper(blocksMap.values()),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var block = _step8.value;\n\n          this._log('got block (%s bytes)', block.length);\n\n          ledger.receivedBytes(block.length);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n    /**\n     * Clear up all accounting things after message was sent\n     *\n     * @param {PeerId} peerId\n     * @param {CID} cid\n     * @param {Uint8Array} block\n     */\n\n  }, {\n    key: \"messageSent\",\n    value: function messageSent(peerId, cid, block) {\n      var ledger = this._findOrCreate(peerId);\n\n      ledger.sentBytes(block.length);\n      ledger.wantlist.remove(cid);\n    }\n    /**\n     * @param {PeerId} peerId\n     * @returns {number}\n     */\n\n  }, {\n    key: \"numBytesSentTo\",\n    value: function numBytesSentTo(peerId) {\n      return this._findOrCreate(peerId).accounting.bytesSent;\n    }\n    /**\n     * @param {PeerId} peerId\n     * @returns {number}\n     */\n\n  }, {\n    key: \"numBytesReceivedFrom\",\n    value: function numBytesReceivedFrom(peerId) {\n      return this._findOrCreate(peerId).accounting.bytesRecv;\n    }\n    /**\n     *\n     * @param {PeerId} _peerId\n     * @returns {void}\n     */\n\n  }, {\n    key: \"peerDisconnected\",\n    value: function peerDisconnected(_peerId) {// if (this.ledgerMap.has(peerId.toB58String())) {\n      //   this.ledgerMap.delete(peerId.toB58String())\n      // }\n      //\n      // TODO: figure out how to remove all other references\n      // in the peer request queue\n    }\n    /**\n     * @private\n     * @param {PeerId} peerId\n     * @returns {Ledger}\n     */\n\n  }, {\n    key: \"_findOrCreate\",\n    value: function _findOrCreate(peerId) {\n      var peerIdStr = peerId.toB58String();\n      var ledger = this.ledgerMap.get(peerIdStr);\n\n      if (ledger) {\n        return ledger;\n      }\n\n      var l = new Ledger(peerId);\n      this.ledgerMap.set(peerIdStr, l);\n\n      if (this._stats) {\n        this._stats.push(peerIdStr, 'peerCount', 1);\n      }\n\n      return l;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this._running = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._running = false;\n    }\n  }]);\n\n  return DecisionEngine;\n}();\n\nmodule.exports = DecisionEngine;","map":{"version":3,"names":["require","CID","base58btc","Message","WantType","Wantlist","Ledger","RequestQueue","TaskMerger","logger","TARGET_MESSAGE_SIZE","MAX_SIZE_REPLACE_HAS_WITH_BLOCK","DecisionEngine","peerId","blockstore","network","stats","opts","_log","_stats","_opts","_processOpts","ledgerMap","Map","_running","_requestQueue","maxSizeReplaceHasWithBlock","targetMessageSize","setTimeout","_processTasks","popTasks","tasks","pendingSize","length","msg","setPendingBytes","blockCids","blockTasks","task","cid","parse","topic","data","haveBlock","isWantBlock","push","set","addHave","addDontHave","_getBlocks","blocks","taskData","blk","get","addBlock","sendDontHave","empty","tasksDone","_scheduleProcessTasks","sendMessage","entries","cidStr","block","messageSent","error","peerIdStr","toB58String","ledger","wantlist","sortedEntries","peer","partner","value","debtRatio","sent","accounting","bytesSent","recv","bytesRecv","exchanged","exchangeCount","Array","from","values","map","l","want","wantlistContains","blockSize","_sendAsBlock","wantType","entrySize","blockPresenceSize","pushTasks","toString","priority","size","_findOrCreate","full","_updateBlockAccounting","cancels","wants","forEach","entry","cancel","cancelWant","_cancelWants","_addWants","cids","c","remove","_getBlockSizes","w","blockSizes","id","Block","k","v","res","Promise","all","code","blocksMap","receivedBytes","sentBytes","_peerId","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-bitswap/src/decision-engine/index.js"],"sourcesContent":["'use strict'\n\n/**\n * @typedef {import('../types/message/entry')} BitswapMessageEntry\n * @typedef {import('peer-id')} PeerId\n */\n\nconst { CID } = require('multiformats')\nconst { base58btc } = require('multiformats/bases/base58')\n\nconst Message = require('../types/message')\nconst WantType = Message.WantType\nconst Wantlist = require('../types/wantlist')\nconst Ledger = require('./ledger')\nconst RequestQueue = require('./req-queue')\nconst TaskMerger = require('./task-merger')\nconst { logger } = require('../utils')\n\n// The ideal size of the batched payload. We try to pop this much data off the\n// request queue, but\n// - if there isn't any more data in the queue we send whatever we have\n// - if there are several small items in the queue (eg HAVE response) followed\n//   by one big item (eg a block) that would exceed this target size, we\n//   include the big item in the message\nconst TARGET_MESSAGE_SIZE = 16 * 1024\n\n// If the client sends a want-have, and the engine has the corresponding block,\n// we check the size of the block and if it's small enough we send the block\n// itself, rather than sending a HAVE.\n// This constant defines the maximum size up to which we replace a HAVE with\n// a block.\nconst MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024\n\nclass DecisionEngine {\n  /**\n   * @param {PeerId} peerId\n   * @param {import('interface-blockstore').Blockstore} blockstore\n   * @param {import('../network')} network\n   * @param {import('../stats')} stats\n   * @param {Object} [opts]\n   * @param {number} [opts.targetMessageSize]\n   * @param {number} [opts.maxSizeReplaceHasWithBlock]\n   */\n  constructor (peerId, blockstore, network, stats, opts = {}) {\n    this._log = logger(peerId, 'engine')\n    this.blockstore = blockstore\n    this.network = network\n    this._stats = stats\n    this._opts = this._processOpts(opts)\n\n    // A list of of ledgers by their partner id\n    /** @type {Map<string, Ledger>} */\n    this.ledgerMap = new Map()\n    this._running = false\n\n    // Queue of want-have / want-block per peer\n    this._requestQueue = new RequestQueue(TaskMerger)\n  }\n\n  /**\n   * @template {Object} Opts\n   * @param {Opts} opts\n   * @returns {Opts & {maxSizeReplaceHasWithBlock:number, targetMessageSize:number}}\n   * @private\n   */\n  _processOpts (opts) {\n    return {\n      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n      targetMessageSize: TARGET_MESSAGE_SIZE,\n      ...opts\n    }\n  }\n\n  _scheduleProcessTasks () {\n    setTimeout(() => {\n      this._processTasks()\n    })\n  }\n\n  /**\n   * Pull tasks off the request queue and send a message to the corresponding\n   * peer\n   */\n  async _processTasks () {\n    if (!this._running) {\n      return\n    }\n\n    const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize)\n\n    if (tasks.length === 0) {\n      return\n    }\n\n    // Create a new message\n    const msg = new Message(false)\n\n    // Amount of data in the request queue still waiting to be popped\n    msg.setPendingBytes(pendingSize)\n\n    // Split out want-blocks, want-haves and DONT_HAVEs\n    const blockCids = []\n    const blockTasks = new Map()\n    for (const task of tasks) {\n      const cid = CID.parse(task.topic)\n      if (task.data.haveBlock) {\n        if (task.data.isWantBlock) {\n          blockCids.push(cid)\n          blockTasks.set(task.topic, task.data)\n        } else {\n          // Add HAVES to the message\n          msg.addHave(cid)\n        }\n      } else {\n        // Add DONT_HAVEs to the message\n        msg.addDontHave(cid)\n      }\n    }\n\n    const blocks = await this._getBlocks(blockCids)\n    for (const [topic, taskData] of blockTasks) {\n      const cid = CID.parse(topic)\n      const blk = blocks.get(topic)\n      // If the block was found (it has not been removed)\n      if (blk) {\n        // Add the block to the message\n        msg.addBlock(cid, blk)\n      } else {\n        // The block was not found. If the client requested DONT_HAVE,\n        // add DONT_HAVE to the message.\n        if (taskData.sendDontHave) {\n          msg.addDontHave(cid)\n        }\n      }\n    }\n\n    // If there's nothing in the message, bail out\n    if (msg.empty) {\n      peerId && this._requestQueue.tasksDone(peerId, tasks)\n\n      // Trigger the next round of task processing\n      this._scheduleProcessTasks()\n\n      return\n    }\n\n    try {\n      // Send the message\n      peerId && await this.network.sendMessage(peerId, msg)\n\n      // Peform sent message accounting\n      for (const [cidStr, block] of blocks.entries()) {\n        peerId && this.messageSent(peerId, CID.parse(cidStr), block)\n      }\n    } catch (err) {\n      this._log.error(err)\n    }\n\n    // Free the tasks up from the request queue\n    peerId && this._requestQueue.tasksDone(peerId, tasks)\n\n    // Trigger the next round of task processing\n    this._scheduleProcessTasks()\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @returns {Map<string, import('../types/wantlist/entry')>}\n   */\n  wantlistForPeer (peerId) {\n    const peerIdStr = peerId.toB58String()\n    const ledger = this.ledgerMap.get(peerIdStr)\n    return ledger ? ledger.wantlist.sortedEntries() : new Map()\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  ledgerForPeer (peerId) {\n    const peerIdStr = peerId.toB58String()\n\n    const ledger = this.ledgerMap.get(peerIdStr)\n\n    if (!ledger) {\n      return null\n    }\n\n    return {\n      peer: ledger.partner,\n      value: ledger.debtRatio(),\n      sent: ledger.accounting.bytesSent,\n      recv: ledger.accounting.bytesRecv,\n      exchanged: ledger.exchangeCount\n    }\n  }\n\n  /**\n   * @returns {PeerId[]}\n   */\n  peers () {\n    return Array.from(this.ledgerMap.values()).map((l) => l.partner)\n  }\n\n  /**\n   * Receive blocks either from an incoming message from the network, or from\n   * blocks being added by the client on the localhost (eg IPFS add)\n   *\n   * @param {{ cid: CID, data: Uint8Array }[]} blocks\n   */\n  receivedBlocks (blocks) {\n    if (!blocks.length) {\n      return\n    }\n\n    // For each connected peer, check if it wants the block we received\n    for (const ledger of this.ledgerMap.values()) {\n      for (const block of blocks) {\n        // Filter out blocks that we don't want\n        const want = ledger.wantlistContains(block.cid)\n\n        if (!want) {\n          continue\n        }\n\n        // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n        const blockSize = block.data.length\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize)\n\n        let entrySize = blockSize\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid)\n        }\n\n        this._requestQueue.pushTasks(ledger.partner, [{\n          topic: want.cid.toString(base58btc),\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            blockSize,\n            isWantBlock,\n            haveBlock: true,\n            sendDontHave: false\n          }\n        }])\n      }\n    }\n\n    this._scheduleProcessTasks()\n  }\n\n  /**\n   * Handle incoming messages\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   * @returns {Promise<void>}\n   */\n  async messageReceived (peerId, msg) {\n    const ledger = this._findOrCreate(peerId)\n\n    if (msg.empty) {\n      return\n    }\n\n    // If the message has a full wantlist, clear the current wantlist\n    if (msg.full) {\n      ledger.wantlist = new Wantlist()\n    }\n\n    // Record the amount of block data received\n    this._updateBlockAccounting(msg.blocks, ledger)\n\n    if (msg.wantlist.size === 0) {\n      this._scheduleProcessTasks()\n      return\n    }\n\n    // Clear cancelled wants and add new wants to the ledger\n    /** @type {CID[]} */\n    const cancels = []\n    /** @type {BitswapMessageEntry[]} */\n    const wants = []\n    msg.wantlist.forEach((entry) => {\n      if (entry.cancel) {\n        ledger.cancelWant(entry.cid)\n        cancels.push(entry.cid)\n      } else {\n        ledger.wants(entry.cid, entry.priority, entry.wantType)\n        wants.push(entry)\n      }\n    })\n\n    this._cancelWants(peerId, cancels)\n    await this._addWants(peerId, wants)\n\n    this._scheduleProcessTasks()\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID[]} cids\n   * @returns {void}\n   */\n  _cancelWants (peerId, cids) {\n    for (const c of cids) {\n      this._requestQueue.remove(c.toString(base58btc), peerId)\n    }\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {BitswapMessageEntry[]} wants\n   * @returns {Promise<void>}\n   */\n  async _addWants (peerId, wants) {\n    // Get the size of each wanted block\n    const blockSizes = await this._getBlockSizes(wants.map(w => w.cid))\n\n    const tasks = []\n    for (const want of wants) {\n      const id = want.cid.toString(base58btc)\n      const blockSize = blockSizes.get(id)\n\n      // If the block was not found\n      if (blockSize == null) {\n        // Only add the task to the queue if the requester wants a DONT_HAVE\n        if (want.sendDontHave) {\n          tasks.push({\n            topic: id,\n            priority: want.priority,\n            size: Message.blockPresenceSize(want.cid),\n            data: {\n              isWantBlock: want.wantType === WantType.Block,\n              blockSize: 0,\n              haveBlock: false,\n              sendDontHave: want.sendDontHave\n            }\n          })\n        }\n      } else {\n        // The block was found, add it to the queue\n\n        // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize)\n\n        // entrySize is the amount of space the entry takes up in the\n        // message we send to the recipient. If we're sending a block, the\n        // entrySize is the size of the block. Otherwise it's the size of\n        // a block presence entry.\n        let entrySize = blockSize\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid)\n        }\n\n        tasks.push({\n          topic: id,\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            isWantBlock,\n            blockSize,\n            haveBlock: true,\n            sendDontHave: want.sendDontHave\n          }\n        })\n      }\n\n      this._requestQueue.pushTasks(peerId, tasks)\n    }\n  }\n\n  /**\n   * @private\n   * @param {import('../types/message/message').Message.Wantlist.WantType} wantType\n   * @param {number} blockSize\n   */\n  _sendAsBlock (wantType, blockSize) {\n    return wantType === WantType.Block ||\n      blockSize <= this._opts.maxSizeReplaceHasWithBlock\n  }\n\n  /**\n   * @private\n   * @param {CID[]} cids\n   * @returns {Promise<Map<string, number>>}\n   */\n  async _getBlockSizes (cids) {\n    const blocks = await this._getBlocks(cids)\n    return new Map([...blocks].map(([k, v]) => [k, v.length]))\n  }\n\n  /**\n   * @private\n   * @param {CID[]} cids\n   * @returns {Promise<Map<string, Uint8Array>>}\n   */\n  async _getBlocks (cids) {\n    const res = new Map()\n    await Promise.all(cids.map(async (cid) => {\n      try {\n        const block = await this.blockstore.get(cid)\n        res.set(cid.toString(base58btc), block)\n      } catch (e) {\n        if (e.code !== 'ERR_NOT_FOUND') {\n          this._log.error('failed to query blockstore for %s: %s', cid, e)\n        }\n      }\n    }))\n    return res\n  }\n\n  /**\n   * @private\n   * @param {Map<string, Uint8Array>} blocksMap\n   * @param {Ledger} ledger\n   */\n  _updateBlockAccounting (blocksMap, ledger) {\n    for (const block of blocksMap.values()) {\n      this._log('got block (%s bytes)', block.length)\n      ledger.receivedBytes(block.length)\n    }\n  }\n\n  /**\n   * Clear up all accounting things after message was sent\n   *\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   */\n  messageSent (peerId, cid, block) {\n    const ledger = this._findOrCreate(peerId)\n    ledger.sentBytes(block.length)\n    ledger.wantlist.remove(cid)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @returns {number}\n   */\n  numBytesSentTo (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesSent\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @returns {number}\n   */\n\n  numBytesReceivedFrom (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesRecv\n  }\n\n  /**\n   *\n   * @param {PeerId} _peerId\n   * @returns {void}\n   */\n  peerDisconnected (_peerId) {\n    // if (this.ledgerMap.has(peerId.toB58String())) {\n    //   this.ledgerMap.delete(peerId.toB58String())\n    // }\n    //\n    // TODO: figure out how to remove all other references\n    // in the peer request queue\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @returns {Ledger}\n   */\n  _findOrCreate (peerId) {\n    const peerIdStr = peerId.toB58String()\n    const ledger = this.ledgerMap.get(peerIdStr)\n    if (ledger) {\n      return ledger\n    }\n\n    const l = new Ledger(peerId)\n\n    this.ledgerMap.set(peerIdStr, l)\n    if (this._stats) {\n      this._stats.push(peerIdStr, 'peerCount', 1)\n    }\n\n    return l\n  }\n\n  start () {\n    this._running = true\n  }\n\n  stop () {\n    this._running = false\n  }\n}\n\nmodule.exports = DecisionEngine\n"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AAEA,eAAgBA,OAAO,CAAC,cAAD,CAAvB;AAAA,IAAQC,GAAR,YAAQA,GAAR;;AACA,gBAAsBD,OAAO,CAAC,2BAAD,CAA7B;AAAA,IAAQE,SAAR,aAAQA,SAAR;;AAEA,IAAMC,OAAO,GAAGH,OAAO,CAAC,kBAAD,CAAvB;;AACA,IAAMI,QAAQ,GAAGD,OAAO,CAACC,QAAzB;;AACA,IAAMC,QAAQ,GAAGL,OAAO,CAAC,mBAAD,CAAxB;;AACA,IAAMM,MAAM,GAAGN,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAMO,YAAY,GAAGP,OAAO,CAAC,aAAD,CAA5B;;AACA,IAAMQ,UAAU,GAAGR,OAAO,CAAC,eAAD,CAA1B;;AACA,gBAAmBA,OAAO,CAAC,UAAD,CAA1B;AAAA,IAAQS,MAAR,aAAQA,MAAR,C,CAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,mBAAmB,GAAG,KAAK,IAAjC,C,CAEA;AACA;AACA;AACA;AACA;;AACA,IAAMC,+BAA+B,GAAG,IAAxC;;IAEMC,c;EACJ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,wBAAaC,MAAb,EAAqBC,UAArB,EAAiCC,OAAjC,EAA0CC,KAA1C,EAA4D;IAAA,IAAXC,IAAW,uEAAJ,EAAI;;IAAA;;IAC1D,KAAKC,IAAL,GAAYT,MAAM,CAACI,MAAD,EAAS,QAAT,CAAlB;IACA,KAAKC,UAAL,GAAkBA,UAAlB;IACA,KAAKC,OAAL,GAAeA,OAAf;IACA,KAAKI,MAAL,GAAcH,KAAd;IACA,KAAKI,KAAL,GAAa,KAAKC,YAAL,CAAkBJ,IAAlB,CAAb,CAL0D,CAO1D;;IACA;;IACA,KAAKK,SAAL,GAAiB,IAAIC,GAAJ,EAAjB;IACA,KAAKC,QAAL,GAAgB,KAAhB,CAV0D,CAY1D;;IACA,KAAKC,aAAL,GAAqB,IAAIlB,YAAJ,CAAiBC,UAAjB,CAArB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;;;WACE,sBAAcS,IAAd,EAAoB;MAClB;QACES,0BAA0B,EAAEf,+BAD9B;QAEEgB,iBAAiB,EAAEjB;MAFrB,GAGKO,IAHL;IAKD;;;WAED,iCAAyB;MAAA;;MACvBW,UAAU,CAAC,YAAM;QACf,KAAI,CAACC,aAAL;MACD,CAFS,CAAV;IAGD;IAED;AACF;AACA;AACA;;;;;sFACE;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAA,IACO,KAAKL,QADZ;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAAA,wBAKyC,KAAKC,aAAL,CAAmBK,QAAnB,CAA4B,KAAKV,KAAL,CAAWO,iBAAvC,CALzC,EAKUd,MALV,yBAKUA,MALV,EAKkBkB,KALlB,yBAKkBA,KALlB,EAKyBC,WALzB,yBAKyBA,WALzB;;gBAAA,MAOMD,KAAK,CAACE,MAAN,KAAiB,CAPvB;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAWE;gBACMC,GAZR,GAYc,IAAI/B,OAAJ,CAAY,KAAZ,CAZd,EAcE;;gBACA+B,GAAG,CAACC,eAAJ,CAAoBH,WAApB,EAfF,CAiBE;;gBACMI,SAlBR,GAkBoB,EAlBpB;gBAmBQC,UAnBR,GAmBqB,IAAId,GAAJ,EAnBrB;gBAAA,uCAoBqBQ,KApBrB;;gBAAA;kBAoBE,oDAA0B;oBAAfO,IAAe;oBAClBC,GADkB,GACZtC,GAAG,CAACuC,KAAJ,CAAUF,IAAI,CAACG,KAAf,CADY;;oBAExB,IAAIH,IAAI,CAACI,IAAL,CAAUC,SAAd,EAAyB;sBACvB,IAAIL,IAAI,CAACI,IAAL,CAAUE,WAAd,EAA2B;wBACzBR,SAAS,CAACS,IAAV,CAAeN,GAAf;wBACAF,UAAU,CAACS,GAAX,CAAeR,IAAI,CAACG,KAApB,EAA2BH,IAAI,CAACI,IAAhC;sBACD,CAHD,MAGO;wBACL;wBACAR,GAAG,CAACa,OAAJ,CAAYR,GAAZ;sBACD;oBACF,CARD,MAQO;sBACL;sBACAL,GAAG,CAACc,WAAJ,CAAgBT,GAAhB;oBACD;kBACF;gBAlCH;kBAAA;gBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAoCuB,KAAKU,UAAL,CAAgBb,SAAhB,CApCvB;;cAAA;gBAoCQc,MApCR;gBAAA,wCAqCkCb,UArClC;;gBAAA;kBAqCE,uDAA4C;oBAAA,gDAAhCI,KAAgC,oBAAzBU,QAAyB;oBACpCZ,IADoC,GAC9BtC,GAAG,CAACuC,KAAJ,CAAUC,KAAV,CAD8B;oBAEpCW,GAFoC,GAE9BF,MAAM,CAACG,GAAP,CAAWZ,KAAX,CAF8B,EAG1C;;oBACA,IAAIW,GAAJ,EAAS;sBACP;sBACAlB,GAAG,CAACoB,QAAJ,CAAaf,IAAb,EAAkBa,GAAlB;oBACD,CAHD,MAGO;sBACL;sBACA;sBACA,IAAID,QAAQ,CAACI,YAAb,EAA2B;wBACzBrB,GAAG,CAACc,WAAJ,CAAgBT,IAAhB;sBACD;oBACF;kBACF,CAnDH,CAqDE;;gBArDF;kBAAA;gBAAA;kBAAA;gBAAA;;gBAAA,KAsDML,GAAG,CAACsB,KAtDV;kBAAA;kBAAA;gBAAA;;gBAuDI3C,MAAM,IAAI,KAAKY,aAAL,CAAmBgC,SAAnB,CAA6B5C,MAA7B,EAAqCkB,KAArC,CAAV,CAvDJ,CAyDI;;gBACA,KAAK2B,qBAAL;;gBA1DJ;;cAAA;gBAAA;gBAAA,cAiEI7C,MAjEJ;;gBAAA;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAiEoB,KAAKE,OAAL,CAAa4C,WAAb,CAAyB9C,MAAzB,EAAiCqB,GAAjC,CAjEpB;;cAAA;gBAmEI;gBAnEJ,wCAoEkCgB,MAAM,CAACU,OAAP,EApElC;;gBAAA;kBAoEI,uDAAgD;oBAAA,gDAApCC,MAAoC,oBAA5BC,KAA4B;oBAC9CjD,MAAM,IAAI,KAAKkD,WAAL,CAAiBlD,MAAjB,EAAyBZ,GAAG,CAACuC,KAAJ,CAAUqB,MAAV,CAAzB,EAA4CC,KAA5C,CAAV;kBACD;gBAtEL;kBAAA;gBAAA;kBAAA;gBAAA;;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;gBAwEI,KAAK5C,IAAL,CAAU8C,KAAV;;cAxEJ;gBA2EE;gBACAnD,MAAM,IAAI,KAAKY,aAAL,CAAmBgC,SAAnB,CAA6B5C,MAA7B,EAAqCkB,KAArC,CAAV,CA5EF,CA8EE;;gBACA,KAAK2B,qBAAL;;cA/EF;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAkFA;AACF;AACA;AACA;;;;WACE,yBAAiB7C,MAAjB,EAAyB;MACvB,IAAMoD,SAAS,GAAGpD,MAAM,CAACqD,WAAP,EAAlB;MACA,IAAMC,MAAM,GAAG,KAAK7C,SAAL,CAAe+B,GAAf,CAAmBY,SAAnB,CAAf;MACA,OAAOE,MAAM,GAAGA,MAAM,CAACC,QAAP,CAAgBC,aAAhB,EAAH,GAAqC,IAAI9C,GAAJ,EAAlD;IACD;IAED;AACF;AACA;;;;WACE,uBAAeV,MAAf,EAAuB;MACrB,IAAMoD,SAAS,GAAGpD,MAAM,CAACqD,WAAP,EAAlB;MAEA,IAAMC,MAAM,GAAG,KAAK7C,SAAL,CAAe+B,GAAf,CAAmBY,SAAnB,CAAf;;MAEA,IAAI,CAACE,MAAL,EAAa;QACX,OAAO,IAAP;MACD;;MAED,OAAO;QACLG,IAAI,EAAEH,MAAM,CAACI,OADR;QAELC,KAAK,EAAEL,MAAM,CAACM,SAAP,EAFF;QAGLC,IAAI,EAAEP,MAAM,CAACQ,UAAP,CAAkBC,SAHnB;QAILC,IAAI,EAAEV,MAAM,CAACQ,UAAP,CAAkBG,SAJnB;QAKLC,SAAS,EAAEZ,MAAM,CAACa;MALb,CAAP;IAOD;IAED;AACF;AACA;;;;WACE,iBAAS;MACP,OAAOC,KAAK,CAACC,IAAN,CAAW,KAAK5D,SAAL,CAAe6D,MAAf,EAAX,EAAoCC,GAApC,CAAwC,UAACC,CAAD;QAAA,OAAOA,CAAC,CAACd,OAAT;MAAA,CAAxC,CAAP;IACD;IAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,wBAAgBrB,MAAhB,EAAwB;MACtB,IAAI,CAACA,MAAM,CAACjB,MAAZ,EAAoB;QAClB;MACD,CAHqB,CAKtB;;;MALsB,4CAMD,KAAKX,SAAL,CAAe6D,MAAf,EANC;MAAA;;MAAA;QAMtB,uDAA8C;UAAA,IAAnChB,MAAmC;;UAAA,4CACxBjB,MADwB;UAAA;;UAAA;YAC5C,uDAA4B;cAAA,IAAjBY,KAAiB;cAC1B;cACA,IAAMwB,IAAI,GAAGnB,MAAM,CAACoB,gBAAP,CAAwBzB,KAAK,CAACvB,GAA9B,CAAb;;cAEA,IAAI,CAAC+C,IAAL,EAAW;gBACT;cACD,CANyB,CAQ1B;cACA;;;cACA,IAAME,SAAS,GAAG1B,KAAK,CAACpB,IAAN,CAAWT,MAA7B;;cACA,IAAMW,WAAW,GAAG,KAAK6C,YAAL,CAAkBH,IAAI,CAACI,QAAvB,EAAiCF,SAAjC,CAApB;;cAEA,IAAIG,SAAS,GAAGH,SAAhB;;cACA,IAAI,CAAC5C,WAAL,EAAkB;gBAChB+C,SAAS,GAAGxF,OAAO,CAACyF,iBAAR,CAA0BN,IAAI,CAAC/C,GAA/B,CAAZ;cACD;;cAED,KAAKd,aAAL,CAAmBoE,SAAnB,CAA6B1B,MAAM,CAACI,OAApC,EAA6C,CAAC;gBAC5C9B,KAAK,EAAE6C,IAAI,CAAC/C,GAAL,CAASuD,QAAT,CAAkB5F,SAAlB,CADqC;gBAE5C6F,QAAQ,EAAET,IAAI,CAACS,QAF6B;gBAG5CC,IAAI,EAAEL,SAHsC;gBAI5CjD,IAAI,EAAE;kBACJ8C,SAAS,EAATA,SADI;kBAEJ5C,WAAW,EAAXA,WAFI;kBAGJD,SAAS,EAAE,IAHP;kBAIJY,YAAY,EAAE;gBAJV;cAJsC,CAAD,CAA7C;YAWD;UA9B2C;YAAA;UAAA;YAAA;UAAA;QA+B7C;MArCqB;QAAA;MAAA;QAAA;MAAA;;MAuCtB,KAAKG,qBAAL;IACD;IAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;;wFACE,kBAAuB7C,MAAvB,EAA+BqB,GAA/B;QAAA;QAAA;UAAA;YAAA;cAAA;gBACQiC,MADR,GACiB,KAAK8B,aAAL,CAAmBpF,MAAnB,CADjB;;gBAAA,KAGMqB,GAAG,CAACsB,KAHV;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAOE;gBACA,IAAItB,GAAG,CAACgE,IAAR,EAAc;kBACZ/B,MAAM,CAACC,QAAP,GAAkB,IAAI/D,QAAJ,EAAlB;gBACD,CAVH,CAYE;;;gBACA,KAAK8F,sBAAL,CAA4BjE,GAAG,CAACgB,MAAhC,EAAwCiB,MAAxC;;gBAbF,MAeMjC,GAAG,CAACkC,QAAJ,CAAa4B,IAAb,KAAsB,CAf5B;kBAAA;kBAAA;gBAAA;;gBAgBI,KAAKtC,qBAAL;;gBAhBJ;;cAAA;gBAoBE;;gBACA;gBACM0C,OAtBR,GAsBkB,EAtBlB;gBAuBE;;gBACMC,KAxBR,GAwBgB,EAxBhB;gBAyBEnE,GAAG,CAACkC,QAAJ,CAAakC,OAAb,CAAqB,UAACC,KAAD,EAAW;kBAC9B,IAAIA,KAAK,CAACC,MAAV,EAAkB;oBAChBrC,MAAM,CAACsC,UAAP,CAAkBF,KAAK,CAAChE,GAAxB;oBACA6D,OAAO,CAACvD,IAAR,CAAa0D,KAAK,CAAChE,GAAnB;kBACD,CAHD,MAGO;oBACL4B,MAAM,CAACkC,KAAP,CAAaE,KAAK,CAAChE,GAAnB,EAAwBgE,KAAK,CAACR,QAA9B,EAAwCQ,KAAK,CAACb,QAA9C;oBACAW,KAAK,CAACxD,IAAN,CAAW0D,KAAX;kBACD;gBACF,CARD;;gBAUA,KAAKG,YAAL,CAAkB7F,MAAlB,EAA0BuF,OAA1B;;gBAnCF;gBAAA,OAoCQ,KAAKO,SAAL,CAAe9F,MAAf,EAAuBwF,KAAvB,CApCR;;cAAA;gBAsCE,KAAK3C,qBAAL;;cAtCF;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAyCA;AACF;AACA;AACA;AACA;AACA;;;;WACE,sBAAc7C,MAAd,EAAsB+F,IAAtB,EAA4B;MAAA,4CACVA,IADU;MAAA;;MAAA;QAC1B,uDAAsB;UAAA,IAAXC,CAAW;;UACpB,KAAKpF,aAAL,CAAmBqF,MAAnB,CAA0BD,CAAC,CAACf,QAAF,CAAW5F,SAAX,CAA1B,EAAiDW,MAAjD;QACD;MAHyB;QAAA;MAAA;QAAA;MAAA;IAI3B;IAED;AACF;AACA;AACA;AACA;AACA;;;;;kFACE,kBAAiBA,MAAjB,EAAyBwF,KAAzB;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OAE2B,KAAKU,cAAL,CAAoBV,KAAK,CAACjB,GAAN,CAAU,UAAA4B,CAAC;kBAAA,OAAIA,CAAC,CAACzE,GAAN;gBAAA,CAAX,CAApB,CAF3B;;cAAA;gBAEQ0E,UAFR;gBAIQlF,KAJR,GAIgB,EAJhB;gBAAA,wCAKqBsE,KALrB;;gBAAA;kBAKE,uDAA0B;oBAAff,IAAe;oBAClB4B,EADkB,GACb5B,IAAI,CAAC/C,GAAL,CAASuD,QAAT,CAAkB5F,SAAlB,CADa;oBAElBsF,SAFkB,GAENyB,UAAU,CAAC5D,GAAX,CAAe6D,EAAf,CAFM,EAIxB;;oBACA,IAAI1B,SAAS,IAAI,IAAjB,EAAuB;sBACrB;sBACA,IAAIF,IAAI,CAAC/B,YAAT,EAAuB;wBACrBxB,KAAK,CAACc,IAAN,CAAW;0BACTJ,KAAK,EAAEyE,EADE;0BAETnB,QAAQ,EAAET,IAAI,CAACS,QAFN;0BAGTC,IAAI,EAAE7F,OAAO,CAACyF,iBAAR,CAA0BN,IAAI,CAAC/C,GAA/B,CAHG;0BAITG,IAAI,EAAE;4BACJE,WAAW,EAAE0C,IAAI,CAACI,QAAL,KAAkBtF,QAAQ,CAAC+G,KADpC;4BAEJ3B,SAAS,EAAE,CAFP;4BAGJ7C,SAAS,EAAE,KAHP;4BAIJY,YAAY,EAAE+B,IAAI,CAAC/B;0BAJf;wBAJG,CAAX;sBAWD;oBACF,CAfD,MAeO;sBACL;sBAEA;sBACA;sBACMX,WALD,GAKe,KAAK6C,YAAL,CAAkBH,IAAI,CAACI,QAAvB,EAAiCF,SAAjC,CALf,EAOL;sBACA;sBACA;sBACA;;sBACIG,SAXC,GAWWH,SAXX;;sBAYL,IAAI,CAAC5C,WAAL,EAAkB;wBAChB+C,SAAS,GAAGxF,OAAO,CAACyF,iBAAR,CAA0BN,IAAI,CAAC/C,GAA/B,CAAZ;sBACD;;sBAEDR,KAAK,CAACc,IAAN,CAAW;wBACTJ,KAAK,EAAEyE,EADE;wBAETnB,QAAQ,EAAET,IAAI,CAACS,QAFN;wBAGTC,IAAI,EAAEL,SAHG;wBAITjD,IAAI,EAAE;0BACJE,WAAW,EAAXA,WADI;0BAEJ4C,SAAS,EAATA,SAFI;0BAGJ7C,SAAS,EAAE,IAHP;0BAIJY,YAAY,EAAE+B,IAAI,CAAC/B;wBAJf;sBAJG,CAAX;oBAWD;;oBAED,KAAK9B,aAAL,CAAmBoE,SAAnB,CAA6BhF,MAA7B,EAAqCkB,KAArC;kBACD;gBAvDH;kBAAA;gBAAA;kBAAA;gBAAA;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IA0DA;AACF;AACA;AACA;AACA;;;;WACE,sBAAc2D,QAAd,EAAwBF,SAAxB,EAAmC;MACjC,OAAOE,QAAQ,KAAKtF,QAAQ,CAAC+G,KAAtB,IACL3B,SAAS,IAAI,KAAKpE,KAAL,CAAWM,0BAD1B;IAED;IAED;AACF;AACA;AACA;AACA;;;;;uFACE,kBAAsBkF,IAAtB;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACuB,KAAK3D,UAAL,CAAgB2D,IAAhB,CADvB;;cAAA;gBACQ1D,MADR;gBAAA,kCAES,IAAI3B,GAAJ,CAAQ,mBAAI2B,MAAJ,EAAYkC,GAAZ,CAAgB;kBAAA;kBAAA,IAAEgC,CAAF;kBAAA,IAAKC,CAAL;;kBAAA,OAAY,CAACD,CAAD,EAAIC,CAAC,CAACpF,MAAN,CAAZ;gBAAA,CAAhB,CAAR,CAFT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAKA;AACF;AACA;AACA;AACA;;;;;mFACE,kBAAkB2E,IAAlB;QAAA;;QAAA;QAAA;UAAA;YAAA;cAAA;gBACQU,GADR,GACc,IAAI/F,GAAJ,EADd;gBAAA;gBAAA,OAEQgG,OAAO,CAACC,GAAR,CAAYZ,IAAI,CAACxB,GAAL;kBAAA,uEAAS,kBAAO7C,GAAP;oBAAA;oBAAA;sBAAA;wBAAA;0BAAA;4BAAA;4BAAA;4BAAA,OAEH,MAAI,CAACzB,UAAL,CAAgBuC,GAAhB,CAAoBd,GAApB,CAFG;;0BAAA;4BAEjBuB,KAFiB;4BAGvBwD,GAAG,CAACxE,GAAJ,CAAQP,GAAG,CAACuD,QAAJ,CAAa5F,SAAb,CAAR,EAAiC4D,KAAjC;4BAHuB;4BAAA;;0BAAA;4BAAA;4BAAA;;4BAKvB,IAAI,aAAE2D,IAAF,KAAW,eAAf,EAAgC;8BAC9B,MAAI,CAACvG,IAAL,CAAU8C,KAAV,CAAgB,uCAAhB,EAAyDzB,GAAzD;4BACD;;0BAPsB;0BAAA;4BAAA;wBAAA;sBAAA;oBAAA;kBAAA,CAAT;;kBAAA;oBAAA;kBAAA;gBAAA,IAAZ,CAFR;;cAAA;gBAAA,kCAYS+E,GAZT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAeA;AACF;AACA;AACA;AACA;;;;WACE,gCAAwBI,SAAxB,EAAmCvD,MAAnC,EAA2C;MAAA,4CACrBuD,SAAS,CAACvC,MAAV,EADqB;MAAA;;MAAA;QACzC,uDAAwC;UAAA,IAA7BrB,KAA6B;;UACtC,KAAK5C,IAAL,CAAU,sBAAV,EAAkC4C,KAAK,CAAC7B,MAAxC;;UACAkC,MAAM,CAACwD,aAAP,CAAqB7D,KAAK,CAAC7B,MAA3B;QACD;MAJwC;QAAA;MAAA;QAAA;MAAA;IAK1C;IAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,qBAAapB,MAAb,EAAqB0B,GAArB,EAA0BuB,KAA1B,EAAiC;MAC/B,IAAMK,MAAM,GAAG,KAAK8B,aAAL,CAAmBpF,MAAnB,CAAf;;MACAsD,MAAM,CAACyD,SAAP,CAAiB9D,KAAK,CAAC7B,MAAvB;MACAkC,MAAM,CAACC,QAAP,CAAgB0C,MAAhB,CAAuBvE,GAAvB;IACD;IAED;AACF;AACA;AACA;;;;WACE,wBAAgB1B,MAAhB,EAAwB;MACtB,OAAO,KAAKoF,aAAL,CAAmBpF,MAAnB,EAA2B8D,UAA3B,CAAsCC,SAA7C;IACD;IAED;AACF;AACA;AACA;;;;WAEE,8BAAsB/D,MAAtB,EAA8B;MAC5B,OAAO,KAAKoF,aAAL,CAAmBpF,MAAnB,EAA2B8D,UAA3B,CAAsCG,SAA7C;IACD;IAED;AACF;AACA;AACA;AACA;;;;WACE,0BAAkB+C,OAAlB,EAA2B,CACzB;MACA;MACA;MACA;MACA;MACA;IACD;IAED;AACF;AACA;AACA;AACA;;;;WACE,uBAAehH,MAAf,EAAuB;MACrB,IAAMoD,SAAS,GAAGpD,MAAM,CAACqD,WAAP,EAAlB;MACA,IAAMC,MAAM,GAAG,KAAK7C,SAAL,CAAe+B,GAAf,CAAmBY,SAAnB,CAAf;;MACA,IAAIE,MAAJ,EAAY;QACV,OAAOA,MAAP;MACD;;MAED,IAAMkB,CAAC,GAAG,IAAI/E,MAAJ,CAAWO,MAAX,CAAV;MAEA,KAAKS,SAAL,CAAewB,GAAf,CAAmBmB,SAAnB,EAA8BoB,CAA9B;;MACA,IAAI,KAAKlE,MAAT,EAAiB;QACf,KAAKA,MAAL,CAAY0B,IAAZ,CAAiBoB,SAAjB,EAA4B,WAA5B,EAAyC,CAAzC;MACD;;MAED,OAAOoB,CAAP;IACD;;;WAED,iBAAS;MACP,KAAK7D,QAAL,GAAgB,IAAhB;IACD;;;WAED,gBAAQ;MACN,KAAKA,QAAL,GAAgB,KAAhB;IACD;;;;;;AAGHsG,MAAM,CAACC,OAAP,GAAiBnH,cAAjB"},"metadata":{},"sourceType":"script"}