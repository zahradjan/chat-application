{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('libp2p:ping'), {\n  error: debug('libp2p:ping:err')\n});\n\nvar errCode = require('err-code');\n\nvar crypto = require('libp2p-crypto');\n\nvar _require = require('it-pipe'),\n    pipe = _require.pipe; // @ts-ignore it-buffer has no types exported\n\n\nvar _require2 = require('it-buffer'),\n    toBuffer = _require2.toBuffer;\n\nvar _require3 = require('streaming-iterables'),\n    collect = _require3.collect,\n    take = _require3.take;\n\nvar _require4 = require('uint8arrays/equals'),\n    equals = _require4.equals;\n\nvar _require5 = require('./constants'),\n    PROTOCOL_NAME = _require5.PROTOCOL_NAME,\n    PING_LENGTH = _require5.PING_LENGTH,\n    PROTOCOL_VERSION = _require5.PROTOCOL_VERSION;\n/**\n * @typedef {import('../')} Libp2p\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n */\n\n/**\n * Ping a given peer and wait for its response, getting the operation latency.\n *\n * @param {Libp2p} node\n * @param {PeerId|Multiaddr} peer\n * @returns {Promise<number>}\n */\n\n\nfunction ping(_x, _x2) {\n  return _ping.apply(this, arguments);\n}\n/**\n * Subscribe ping protocol handler.\n *\n * @param {Libp2p} node\n */\n\n\nfunction _ping() {\n  _ping = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(node, peer) {\n    var protocol, connection, _yield$connection$new, stream, start, data, _yield$pipe, _yield$pipe2, result, end;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            protocol = \"/\".concat(node._config.protocolPrefix, \"/\").concat(PROTOCOL_NAME, \"/\").concat(PROTOCOL_VERSION); // @ts-ignore multiaddr might not have toB58String\n\n            log('dialing %s to %s', protocol, peer.toB58String ? peer.toB58String() : peer);\n            _context.next = 4;\n            return node.dial(peer);\n\n          case 4:\n            connection = _context.sent;\n            _context.next = 7;\n            return connection.newStream(protocol);\n\n          case 7:\n            _yield$connection$new = _context.sent;\n            stream = _yield$connection$new.stream;\n            start = Date.now();\n            data = crypto.randomBytes(PING_LENGTH);\n            _context.next = 13;\n            return pipe([data], stream, function (\n            /** @type {MuxedStream} */\n            stream) {\n              return take(1, stream);\n            }, toBuffer, collect);\n\n          case 13:\n            _yield$pipe = _context.sent;\n            _yield$pipe2 = _slicedToArray(_yield$pipe, 1);\n            result = _yield$pipe2[0];\n            end = Date.now();\n\n            if (equals(data, result)) {\n              _context.next = 19;\n              break;\n            }\n\n            throw errCode(new Error('Received wrong ping ack'), 'ERR_WRONG_PING_ACK');\n\n          case 19:\n            return _context.abrupt(\"return\", end - start);\n\n          case 20:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _ping.apply(this, arguments);\n}\n\nfunction mount(node) {\n  node.handle(\"/\".concat(node._config.protocolPrefix, \"/\").concat(PROTOCOL_NAME, \"/\").concat(PROTOCOL_VERSION), function (_ref) {\n    var stream = _ref.stream;\n    return pipe(stream, stream);\n  });\n}\n/**\n * Unsubscribe ping protocol handler.\n *\n * @param {Libp2p} node\n */\n\n\nfunction unmount(node) {\n  node.unhandle(\"/\".concat(node._config.protocolPrefix, \"/\").concat(PROTOCOL_NAME, \"/\").concat(PROTOCOL_VERSION));\n}\n\nexports = module.exports = ping;\nexports.mount = mount;\nexports.unmount = unmount;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errCode","crypto","pipe","toBuffer","collect","take","equals","PROTOCOL_NAME","PING_LENGTH","PROTOCOL_VERSION","ping","node","peer","protocol","_config","protocolPrefix","toB58String","dial","connection","newStream","stream","start","Date","now","data","randomBytes","result","end","Error","mount","handle","unmount","unhandle","exports","module"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/ping/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:ping'), {\n  error: debug('libp2p:ping:err')\n})\nconst errCode = require('err-code')\n\nconst crypto = require('libp2p-crypto')\nconst { pipe } = require('it-pipe')\n// @ts-ignore it-buffer has no types exported\nconst { toBuffer } = require('it-buffer')\nconst { collect, take } = require('streaming-iterables')\nconst { equals } = require('uint8arrays/equals')\n\nconst { PROTOCOL_NAME, PING_LENGTH, PROTOCOL_VERSION } = require('./constants')\n\n/**\n * @typedef {import('../')} Libp2p\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n */\n\n/**\n * Ping a given peer and wait for its response, getting the operation latency.\n *\n * @param {Libp2p} node\n * @param {PeerId|Multiaddr} peer\n * @returns {Promise<number>}\n */\nasync function ping (node, peer) {\n  const protocol = `/${node._config.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`\n  // @ts-ignore multiaddr might not have toB58String\n  log('dialing %s to %s', protocol, peer.toB58String ? peer.toB58String() : peer)\n\n  const connection = await node.dial(peer)\n  const { stream } = await connection.newStream(protocol)\n\n  const start = Date.now()\n  const data = crypto.randomBytes(PING_LENGTH)\n\n  const [result] = await pipe(\n    [data],\n    stream,\n    (/** @type {MuxedStream} */ stream) => take(1, stream),\n    toBuffer,\n    collect\n  )\n  const end = Date.now()\n\n  if (!equals(data, result)) {\n    throw errCode(new Error('Received wrong ping ack'), 'ERR_WRONG_PING_ACK')\n  }\n\n  return end - start\n}\n\n/**\n * Subscribe ping protocol handler.\n *\n * @param {Libp2p} node\n */\nfunction mount (node) {\n  node.handle(`/${node._config.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`, ({ stream }) => pipe(stream, stream))\n}\n\n/**\n * Unsubscribe ping protocol handler.\n *\n * @param {Libp2p} node\n */\nfunction unmount (node) {\n  node.unhandle(`/${node._config.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`)\n}\n\nexports = module.exports = ping\nexports.mount = mount\nexports.unmount = unmount\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}