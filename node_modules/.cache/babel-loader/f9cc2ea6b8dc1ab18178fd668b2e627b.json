{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar cid = require('multiformats/cid');\n\nvar encoder = require('./encoder.js');\n\nvar iteratorChannel = require('./iterator-channel.js');\n\nvar decoder = require('./decoder.js');\n\nvar CarWriter = /*#__PURE__*/function () {\n  function CarWriter(roots, encoder) {\n    _classCallCheck(this, CarWriter);\n\n    this._encoder = encoder;\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n\n  _createClass(CarWriter, [{\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(block) {\n        var _this = this;\n\n        var cid$1;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!(block.bytes instanceof Uint8Array) || !block.cid)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new TypeError('Can only write {cid, bytes} objects');\n\n              case 2:\n                if (!this._ended) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new Error('Already closed');\n\n              case 4:\n                cid$1 = cid.CID.asCID(block.cid);\n\n                if (cid$1) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new TypeError('Can only write {cid, bytes} objects');\n\n              case 7:\n                this._mutex = this._mutex.then(function () {\n                  return _this._encoder.writeBlock({\n                    cid: cid$1,\n                    bytes: block.bytes\n                  });\n                });\n                return _context.abrupt(\"return\", this._mutex);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function put(_x) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._ended) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error('Already closed');\n\n              case 2:\n                _context2.next = 4;\n                return this._mutex;\n\n              case 4:\n                this._ended = true;\n                return _context2.abrupt(\"return\", this._encoder.close());\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }], [{\n    key: \"create\",\n    value: function create(roots) {\n      roots = toRoots(roots);\n\n      var _encodeWriter = encodeWriter(),\n          encoder = _encodeWriter.encoder,\n          iterator = _encodeWriter.iterator;\n\n      var writer = new CarWriter(roots, encoder);\n      var out = new CarWriterOut(iterator);\n      return {\n        writer: writer,\n        out: out\n      };\n    }\n  }, {\n    key: \"createAppender\",\n    value: function createAppender() {\n      var _encodeWriter2 = encodeWriter(),\n          encoder = _encodeWriter2.encoder,\n          iterator = _encodeWriter2.iterator;\n\n      encoder.setRoots = function () {\n        return Promise.resolve();\n      };\n\n      var writer = new CarWriter([], encoder);\n      var out = new CarWriterOut(iterator);\n      return {\n        writer: writer,\n        out: out\n      };\n    }\n  }, {\n    key: \"updateRootsInBytes\",\n    value: function () {\n      var _updateRootsInBytes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(bytes, roots) {\n        var reader, newHeader;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                reader = decoder.bytesReader(bytes);\n                _context3.next = 3;\n                return decoder.readHeader(reader);\n\n              case 3:\n                newHeader = encoder.createHeader(roots);\n\n                if (!(reader.pos !== newHeader.length)) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                throw new Error(\"updateRoots() can only overwrite a header of the same length (old header is \".concat(reader.pos, \" bytes, new header is \").concat(newHeader.length, \" bytes)\"));\n\n              case 6:\n                bytes.set(newHeader, 0);\n                return _context3.abrupt(\"return\", bytes);\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function updateRootsInBytes(_x2, _x3) {\n        return _updateRootsInBytes.apply(this, arguments);\n      }\n\n      return updateRootsInBytes;\n    }()\n  }]);\n\n  return CarWriter;\n}();\n\nvar CarWriterOut = /*#__PURE__*/function (_Symbol$asyncIterator) {\n  function CarWriterOut(iterator) {\n    _classCallCheck(this, CarWriterOut);\n\n    this._iterator = iterator;\n  }\n\n  _createClass(CarWriterOut, [{\n    key: _Symbol$asyncIterator,\n    value: function value() {\n      if (this._iterating) {\n        throw new Error('Multiple iterator not supported');\n      }\n\n      this._iterating = true;\n      return this._iterator;\n    }\n  }]);\n\n  return CarWriterOut;\n}(Symbol.asyncIterator);\n\nfunction encodeWriter() {\n  var iw = iteratorChannel.create();\n  var writer = iw.writer,\n      iterator = iw.iterator;\n  var encoder$1 = encoder.createEncoder(writer);\n  return {\n    encoder: encoder$1,\n    iterator: iterator\n  };\n}\n\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n\n  if (!Array.isArray(roots)) {\n    var cid$1 = cid.CID.asCID(roots);\n\n    if (!cid$1) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n\n    return [cid$1];\n  }\n\n  var _roots = [];\n\n  var _iterator = _createForOfIteratorHelper(roots),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var root = _step.value;\n\n      var _root = cid.CID.asCID(root);\n\n      if (!_root) {\n        throw new TypeError('roots must be a single CID or an array of CIDs');\n      }\n\n      _roots.push(_root);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return _roots;\n}\n\nvar __browser = true;\nexports.CarWriter = CarWriter;\nexports.CarWriterOut = CarWriterOut;\nexports.__browser = __browser;","map":{"version":3,"names":["Object","defineProperty","exports","value","cid","require","encoder","iteratorChannel","decoder","CarWriter","roots","_encoder","_mutex","setRoots","_ended","block","bytes","Uint8Array","TypeError","Error","cid$1","CID","asCID","then","writeBlock","close","toRoots","encodeWriter","iterator","writer","out","CarWriterOut","Promise","resolve","reader","bytesReader","readHeader","newHeader","createHeader","pos","length","set","_iterator","_iterating","Symbol","asyncIterator","iw","create","encoder$1","createEncoder","undefined","Array","isArray","_roots","root","_root","push","__browser"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/@ipld/car/cjs/lib/writer-browser.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar cid = require('multiformats/cid');\nvar encoder = require('./encoder.js');\nvar iteratorChannel = require('./iterator-channel.js');\nvar decoder = require('./decoder.js');\n\nclass CarWriter {\n  constructor(roots, encoder) {\n    this._encoder = encoder;\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n  async put(block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    const cid$1 = cid.CID.asCID(block.cid);\n    if (!cid$1) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({\n      cid: cid$1,\n      bytes: block.bytes\n    }));\n    return this._mutex;\n  }\n  async close() {\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    await this._mutex;\n    this._ended = true;\n    return this._encoder.close();\n  }\n  static create(roots) {\n    roots = toRoots(roots);\n    const {encoder, iterator} = encodeWriter();\n    const writer = new CarWriter(roots, encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static createAppender() {\n    const {encoder, iterator} = encodeWriter();\n    encoder.setRoots = () => Promise.resolve();\n    const writer = new CarWriter([], encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static async updateRootsInBytes(bytes, roots) {\n    const reader = decoder.bytesReader(bytes);\n    await decoder.readHeader(reader);\n    const newHeader = encoder.createHeader(roots);\n    if (reader.pos !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${ reader.pos } bytes, new header is ${ newHeader.length } bytes)`);\n    }\n    bytes.set(newHeader, 0);\n    return bytes;\n  }\n}\nclass CarWriterOut {\n  constructor(iterator) {\n    this._iterator = iterator;\n  }\n  [Symbol.asyncIterator]() {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported');\n    }\n    this._iterating = true;\n    return this._iterator;\n  }\n}\nfunction encodeWriter() {\n  const iw = iteratorChannel.create();\n  const {writer, iterator} = iw;\n  const encoder$1 = encoder.createEncoder(writer);\n  return {\n    encoder: encoder$1,\n    iterator\n  };\n}\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n  if (!Array.isArray(roots)) {\n    const cid$1 = cid.CID.asCID(roots);\n    if (!cid$1) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    return [cid$1];\n  }\n  const _roots = [];\n  for (const root of roots) {\n    const _root = cid.CID.asCID(root);\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    _roots.push(_root);\n  }\n  return _roots;\n}\nconst __browser = true;\n\nexports.CarWriter = CarWriter;\nexports.CarWriterOut = CarWriterOut;\nexports.__browser = __browser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}