{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar log = require('debug')('ipfs:mfs:touch');\n\nvar errCode = require('err-code');\n\nvar _require = require('ipfs-unixfs'),\n    UnixFS = _require.UnixFS;\n\nvar toTrail = require('./utils/to-trail');\n\nvar addLink = require('./utils/add-link');\n\nvar updateTree = require('./utils/update-tree');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar dagPb = require('@ipld/dag-pb');\n\nvar _require2 = require('multiformats/cid'),\n    CID = _require2.CID;\n\nvar _require3 = require('it-pipe'),\n    pipe = _require3.pipe;\n\nvar _require4 = require('ipfs-unixfs-importer'),\n    importer = _require4.importer;\n\nvar _require5 = require('ipfs-unixfs-exporter'),\n    recursive = _require5.recursive;\n\nvar last = require('it-last');\n\nvar cp = require('./cp');\n\nvar rm = require('./rm');\n\nvar persist = require('./utils/persist');\n\nvar withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nvar defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n};\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\n\nfunction calculateModification(mode, originalMode, isDirectory) {\n  var modification = 0;\n\n  if (mode.includes('x') || mode.includes('X') && (isDirectory || originalMode & 1 || originalMode & 8 || originalMode & 64)) {\n    modification += 1;\n  }\n\n  if (mode.includes('w')) {\n    modification += 2;\n  }\n\n  if (mode.includes('r')) {\n    modification += 4;\n  }\n\n  return modification;\n}\n/**\n * @param {string} references\n * @param {number} modification\n */\n\n\nfunction calculateUGO(references, modification) {\n  var ugo = 0;\n\n  if (references.includes('u')) {\n    ugo += modification << 6;\n  }\n\n  if (references.includes('g')) {\n    ugo += modification << 3;\n  }\n\n  if (references.includes('o')) {\n    ugo += modification;\n  }\n\n  return ugo;\n}\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\n\n\nfunction calculateSpecial(references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8);\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8);\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8);\n    }\n  }\n\n  return modification;\n}\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\n\n\nfunction parseSymbolicMode(input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0;\n  }\n\n  var match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/);\n\n  if (!match) {\n    throw new Error(\"Invalid file mode: \".concat(input));\n  }\n\n  var _match = _slicedToArray(match, 4),\n      references = _match[1],\n      operator = _match[2],\n      mode = _match[3];\n\n  if (references === 'a' || !references) {\n    references = 'ugo';\n  }\n\n  var modification = calculateModification(mode, originalMode, isDirectory);\n  modification = calculateUGO(references, modification);\n  modification = calculateSpecial(references, mode, modification);\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    return originalMode;\n  }\n\n  if (operator === '+') {\n    return modification | originalMode;\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode;\n  }\n\n  return originalMode;\n}\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\n\n\nfunction calculateMode(mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    var strMode = \"\".concat(mode);\n\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8);\n    } else {\n      // @ts-ignore freaks out over the curr: number, acc: string thing\n      mode = 0 + strMode.split(',').reduce(function (curr, acc) {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory());\n      }, metadata.mode || 0);\n    }\n  }\n\n  return mode;\n}\n/**\n * @param {MfsContext} context\n */\n\n\nmodule.exports = function (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"chmod\"]}\n   */\n  function mfsChmod(_x4, _x5) {\n    return _mfsChmod.apply(this, arguments);\n  }\n\n  function _mfsChmod() {\n    _mfsChmod = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(path, mode) {\n      var options,\n          opts,\n          _yield$toMfsPath,\n          cid,\n          mfsDirectory,\n          name,\n          root,\n          block,\n          node,\n          metadata,\n          updatedBlock,\n          hashAlg,\n          hasher,\n          hash,\n          updatedCid,\n          trail,\n          parent,\n          parentCid,\n          parentBlock,\n          parentNode,\n          result,\n          newRootCid,\n          _args5 = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              options = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};\n\n              /** @type {DefaultOptions} */\n              opts = mergeOptions(defaultOptions, options);\n              log(\"Fetching stats for \".concat(path));\n              _context5.next = 5;\n              return toMfsPath(context, path, opts);\n\n            case 5:\n              _yield$toMfsPath = _context5.sent;\n              cid = _yield$toMfsPath.cid;\n              mfsDirectory = _yield$toMfsPath.mfsDirectory;\n              name = _yield$toMfsPath.name;\n\n              if (!(cid.code !== dagPb.code)) {\n                _context5.next = 11;\n                break;\n              }\n\n              throw errCode(new Error(\"\".concat(path, \" was not a UnixFS node\")), 'ERR_NOT_UNIXFS');\n\n            case 11:\n              if (!opts.recursive) {\n                _context5.next = 22;\n                break;\n              }\n\n              _context5.next = 14;\n              return pipe( /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry, _node;\n\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _iteratorAbruptCompletion = false;\n                        _didIteratorError = false;\n                        _context.prev = 2;\n                        _iterator = _asyncIterator(recursive(cid, context.repo.blocks));\n\n                      case 4:\n                        _context.next = 6;\n                        return _awaitAsyncGenerator(_iterator.next());\n\n                      case 6:\n                        if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                          _context.next = 17;\n                          break;\n                        }\n\n                        entry = _step.value;\n\n                        if (!(entry.type !== 'file' && entry.type !== 'directory')) {\n                          _context.next = 10;\n                          break;\n                        }\n\n                        throw errCode(new Error(\"\".concat(path, \" was not a UnixFS node\")), 'ERR_NOT_UNIXFS');\n\n                      case 10:\n                        entry.unixfs.mode = calculateMode(mode, entry.unixfs);\n                        _node = dagPb.prepare({\n                          Data: entry.unixfs.marshal(),\n                          Links: entry.node.Links\n                        });\n                        _context.next = 14;\n                        return {\n                          path: entry.path,\n                          content: _node\n                        };\n\n                      case 14:\n                        _iteratorAbruptCompletion = false;\n                        _context.next = 4;\n                        break;\n\n                      case 17:\n                        _context.next = 23;\n                        break;\n\n                      case 19:\n                        _context.prev = 19;\n                        _context.t0 = _context[\"catch\"](2);\n                        _didIteratorError = true;\n                        _iteratorError = _context.t0;\n\n                      case 23:\n                        _context.prev = 23;\n                        _context.prev = 24;\n\n                        if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                          _context.next = 28;\n                          break;\n                        }\n\n                        _context.next = 28;\n                        return _awaitAsyncGenerator(_iterator.return());\n\n                      case 28:\n                        _context.prev = 28;\n\n                        if (!_didIteratorError) {\n                          _context.next = 31;\n                          break;\n                        }\n\n                        throw _iteratorError;\n\n                      case 31:\n                        return _context.finish(28);\n\n                      case 32:\n                        return _context.finish(23);\n\n                      case 33:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[2, 19, 23, 33], [24,, 28, 32]]);\n              })), // @ts-ignore we account for the incompatible source type with our custom dag builder below\n              function (source) {\n                return importer(source, context.repo.blocks, _objectSpread(_objectSpread({}, opts), {}, {\n                  pin: false,\n                  dagBuilder: function () {\n                    var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(source, block, opts) {\n                      var _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _loop, _iterator2, _step2;\n\n                      return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n                        while (1) {\n                          switch (_context4.prev = _context4.next) {\n                            case 0:\n                              _iteratorAbruptCompletion2 = false;\n                              _didIteratorError2 = false;\n                              _context4.prev = 2;\n                              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                                var entry;\n                                return _regeneratorRuntime().wrap(function _loop$(_context3) {\n                                  while (1) {\n                                    switch (_context3.prev = _context3.next) {\n                                      case 0:\n                                        entry = _step2.value;\n                                        _context3.next = 3;\n                                        return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                                          var node, buf, cid, unixfs;\n                                          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                                            while (1) {\n                                              switch (_context2.prev = _context2.next) {\n                                                case 0:\n                                                  /** @type {PBNode} */\n                                                  // @ts-ignore - cannot derive type\n                                                  node = entry.content;\n                                                  buf = dagPb.encode(node);\n                                                  _context2.next = 4;\n                                                  return persist(buf, block, opts);\n\n                                                case 4:\n                                                  cid = _context2.sent;\n\n                                                  if (node.Data) {\n                                                    _context2.next = 7;\n                                                    break;\n                                                  }\n\n                                                  throw errCode(new Error(\"\".concat(cid, \" had no data\")), 'ERR_INVALID_NODE');\n\n                                                case 7:\n                                                  unixfs = UnixFS.unmarshal(node.Data);\n                                                  return _context2.abrupt(\"return\", {\n                                                    cid: cid,\n                                                    size: buf.length,\n                                                    path: entry.path,\n                                                    unixfs: unixfs\n                                                  });\n\n                                                case 9:\n                                                case \"end\":\n                                                  return _context2.stop();\n                                              }\n                                            }\n                                          }, _callee2);\n                                        }));\n\n                                      case 3:\n                                      case \"end\":\n                                        return _context3.stop();\n                                    }\n                                  }\n                                }, _loop);\n                              });\n                              _iterator2 = _asyncIterator(source);\n\n                            case 5:\n                              _context4.next = 7;\n                              return _awaitAsyncGenerator(_iterator2.next());\n\n                            case 7:\n                              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context4.sent).done)) {\n                                _context4.next = 12;\n                                break;\n                              }\n\n                              return _context4.delegateYield(_loop(), \"t0\", 9);\n\n                            case 9:\n                              _iteratorAbruptCompletion2 = false;\n                              _context4.next = 5;\n                              break;\n\n                            case 12:\n                              _context4.next = 18;\n                              break;\n\n                            case 14:\n                              _context4.prev = 14;\n                              _context4.t1 = _context4[\"catch\"](2);\n                              _didIteratorError2 = true;\n                              _iteratorError2 = _context4.t1;\n\n                            case 18:\n                              _context4.prev = 18;\n                              _context4.prev = 19;\n\n                              if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                                _context4.next = 23;\n                                break;\n                              }\n\n                              _context4.next = 23;\n                              return _awaitAsyncGenerator(_iterator2.return());\n\n                            case 23:\n                              _context4.prev = 23;\n\n                              if (!_didIteratorError2) {\n                                _context4.next = 26;\n                                break;\n                              }\n\n                              throw _iteratorError2;\n\n                            case 26:\n                              return _context4.finish(23);\n\n                            case 27:\n                              return _context4.finish(18);\n\n                            case 28:\n                            case \"end\":\n                              return _context4.stop();\n                          }\n                        }\n                      }, _callee3, null, [[2, 14, 18, 28], [19,, 23, 27]]);\n                    }));\n\n                    return function dagBuilder(_x, _x2, _x3) {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }()\n                }));\n              }, function (nodes) {\n                return last(nodes);\n              });\n\n            case 14:\n              root = _context5.sent;\n\n              if (root) {\n                _context5.next = 17;\n                break;\n              }\n\n              throw errCode(new Error(\"Could not chmod \".concat(path)), 'ERR_COULD_NOT_CHMOD');\n\n            case 17:\n              _context5.next = 19;\n              return rm(context)(path, opts);\n\n            case 19:\n              _context5.next = 21;\n              return cp(context)(\"/ipfs/\".concat(root.cid), path, opts);\n\n            case 21:\n              return _context5.abrupt(\"return\");\n\n            case 22:\n              _context5.next = 24;\n              return context.repo.blocks.get(cid);\n\n            case 24:\n              block = _context5.sent;\n              node = dagPb.decode(block);\n\n              if (node.Data) {\n                _context5.next = 28;\n                break;\n              }\n\n              throw errCode(new Error(\"\".concat(cid, \" had no data\")), 'ERR_INVALID_NODE');\n\n            case 28:\n              metadata = UnixFS.unmarshal(node.Data);\n              metadata.mode = calculateMode(mode, metadata);\n              updatedBlock = dagPb.encode({\n                Data: metadata.marshal(),\n                Links: node.Links\n              });\n              hashAlg = opts.hashAlg || defaultOptions.hashAlg;\n              _context5.next = 34;\n              return context.hashers.getHasher(hashAlg);\n\n            case 34:\n              hasher = _context5.sent;\n              _context5.next = 37;\n              return hasher.digest(updatedBlock);\n\n            case 37:\n              hash = _context5.sent;\n              updatedCid = CID.create(opts.cidVersion, dagPb.code, hash);\n\n              if (!opts.flush) {\n                _context5.next = 42;\n                break;\n              }\n\n              _context5.next = 42;\n              return context.repo.blocks.put(updatedCid, updatedBlock);\n\n            case 42:\n              _context5.next = 44;\n              return toTrail(context, mfsDirectory);\n\n            case 44:\n              trail = _context5.sent;\n              parent = trail[trail.length - 1];\n              parentCid = CID.decode(parent.cid.bytes);\n              _context5.next = 49;\n              return context.repo.blocks.get(parentCid);\n\n            case 49:\n              parentBlock = _context5.sent;\n              parentNode = dagPb.decode(parentBlock);\n              _context5.next = 53;\n              return addLink(context, {\n                parent: parentNode,\n                name: name,\n                cid: updatedCid,\n                size: updatedBlock.length,\n                flush: opts.flush,\n                // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n                hashAlg: hashAlg,\n                cidVersion: cid.version,\n                shardSplitThreshold: Infinity\n              });\n\n            case 53:\n              result = _context5.sent;\n              parent.cid = result.cid; // update the tree with the new child\n\n              _context5.next = 57;\n              return updateTree(context, trail, opts);\n\n            case 57:\n              newRootCid = _context5.sent;\n              _context5.next = 60;\n              return updateMfsRoot(context, newRootCid, opts);\n\n            case 60:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return _mfsChmod.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsChmod);\n};","map":{"version":3,"names":["mergeOptions","require","bind","ignoreUndefined","toMfsPath","log","errCode","UnixFS","toTrail","addLink","updateTree","updateMfsRoot","dagPb","CID","pipe","importer","recursive","last","cp","rm","persist","withTimeoutOption","defaultOptions","flush","shardSplitThreshold","hashAlg","cidVersion","calculateModification","mode","originalMode","isDirectory","modification","includes","calculateUGO","references","ugo","calculateSpecial","parseInt","parseSymbolicMode","input","match","Error","operator","calculateMode","metadata","String","strMode","split","reduce","curr","acc","module","exports","context","mfsChmod","path","options","opts","cid","mfsDirectory","name","code","repo","blocks","entry","type","unixfs","node","prepare","Data","marshal","Links","content","source","pin","dagBuilder","block","buf","encode","unmarshal","size","length","nodes","root","get","decode","updatedBlock","hashers","getHasher","hasher","digest","hash","updatedCid","create","put","trail","parent","parentCid","bytes","parentBlock","parentNode","version","Infinity","result","newRootCid"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/chmod.js"],"sourcesContent":["'use strict'\n\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst toMfsPath = require('./utils/to-mfs-path')\nconst log = require('debug')('ipfs:mfs:touch')\nconst errCode = require('err-code')\nconst { UnixFS } = require('ipfs-unixfs')\nconst toTrail = require('./utils/to-trail')\nconst addLink = require('./utils/add-link')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst dagPb = require('@ipld/dag-pb')\nconst { CID } = require('multiformats/cid')\nconst { pipe } = require('it-pipe')\nconst { importer } = require('ipfs-unixfs-importer')\nconst { recursive } = require('ipfs-unixfs-exporter')\nconst last = require('it-last')\nconst cp = require('./cp')\nconst rm = require('./rm')\nconst persist = require('./utils/persist')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n}\n\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction calculateModification (mode, originalMode, isDirectory) {\n  let modification = 0\n\n  if (mode.includes('x') || (mode.includes('X') && (isDirectory || (originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)))) {\n    modification += 1\n  }\n\n  if (mode.includes('w')) {\n    modification += 2\n  }\n\n  if (mode.includes('r')) {\n    modification += 4\n  }\n\n  return modification\n}\n\n/**\n * @param {string} references\n * @param {number} modification\n */\nfunction calculateUGO (references, modification) {\n  let ugo = 0\n\n  if (references.includes('u')) {\n    ugo += (modification << 6)\n  }\n\n  if (references.includes('g')) {\n    ugo += (modification << 3)\n  }\n\n  if (references.includes('o')) {\n    ugo += (modification)\n  }\n\n  return ugo\n}\n\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\nfunction calculateSpecial (references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8)\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8)\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8)\n    }\n  }\n\n  return modification\n}\n\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction parseSymbolicMode (input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/)\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`)\n  }\n\n  let [\n    ,\n    references,\n    operator,\n    mode\n  ] = match\n\n  if (references === 'a' || !references) {\n    references = 'ugo'\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory)\n  modification = calculateUGO(references, modification)\n  modification = calculateSpecial(references, mode, modification)\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    return originalMode\n  }\n\n  if (operator === '+') {\n    return modification | originalMode\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode\n  }\n\n  return originalMode\n}\n\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\nfunction calculateMode (mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${mode}`\n\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8)\n    } else {\n      // @ts-ignore freaks out over the curr: number, acc: string thing\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory())\n      }, metadata.mode || 0)\n    }\n  }\n\n  return mode\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"chmod\"]}\n   */\n  async function mfsChmod (path, mode, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options)\n\n    log(`Fetching stats for ${path}`)\n\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, opts)\n\n    if (cid.code !== dagPb.code) {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n    }\n\n    if (opts.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(\n        async function * () {\n          for await (const entry of recursive(cid, context.repo.blocks)) {\n            if (entry.type !== 'file' && entry.type !== 'directory') {\n              throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n            }\n\n            entry.unixfs.mode = calculateMode(mode, entry.unixfs)\n\n            const node = dagPb.prepare({\n              Data: entry.unixfs.marshal(),\n              Links: entry.node.Links\n            })\n\n            yield {\n              path: entry.path,\n              content: node\n            }\n          }\n        },\n        // @ts-ignore we account for the incompatible source type with our custom dag builder below\n        (source) => importer(source, context.repo.blocks, {\n          ...opts,\n          pin: false,\n          dagBuilder: async function * (source, block, opts) {\n            for await (const entry of source) {\n              yield async function () {\n                /** @type {PBNode} */\n                // @ts-ignore - cannot derive type\n                const node = entry.content\n\n                const buf = dagPb.encode(node)\n                const cid = await persist(buf, block, opts)\n\n                if (!node.Data) {\n                  throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n                }\n\n                const unixfs = UnixFS.unmarshal(node.Data)\n\n                return {\n                  cid,\n                  size: buf.length,\n                  path: entry.path,\n                  unixfs\n                }\n              }\n            }\n          }\n        }),\n        (nodes) => last(nodes)\n      )\n\n      if (!root) {\n        throw errCode(new Error(`Could not chmod ${path}`), 'ERR_COULD_NOT_CHMOD')\n      }\n\n      // remove old path from mfs\n      await rm(context)(path, opts)\n\n      // add newly created tree to mfs at path\n      await cp(context)(`/ipfs/${root.cid}`, path, opts)\n\n      return\n    }\n\n    const block = await context.repo.blocks.get(cid)\n    const node = dagPb.decode(block)\n\n    if (!node.Data) {\n      throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n    }\n\n    const metadata = UnixFS.unmarshal(node.Data)\n    metadata.mode = calculateMode(mode, metadata)\n    const updatedBlock = dagPb.encode({\n      Data: metadata.marshal(),\n      Links: node.Links\n    })\n\n    const hashAlg = opts.hashAlg || defaultOptions.hashAlg\n    const hasher = await context.hashers.getHasher(hashAlg)\n    const hash = await hasher.digest(updatedBlock)\n    const updatedCid = CID.create(opts.cidVersion, dagPb.code, hash)\n\n    if (opts.flush) {\n      await context.repo.blocks.put(updatedCid, updatedBlock)\n    }\n\n    const trail = await toTrail(context, mfsDirectory)\n    const parent = trail[trail.length - 1]\n    const parentCid = CID.decode(parent.cid.bytes)\n    const parentBlock = await context.repo.blocks.get(parentCid)\n    const parentNode = dagPb.decode(parentBlock)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: opts.flush,\n      // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n      hashAlg,\n      cidVersion: cid.version,\n      shardSplitThreshold: Infinity\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, opts)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts)\n  }\n\n  return withTimeoutOption(mfsChmod)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}