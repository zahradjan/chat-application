{"ast":null,"code":"const getIterator = require('get-iterator');\n\nconst AbortError = require('./AbortError'); // Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\n\n\nconst toAbortableSource = (source, signal, options) => toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{\n  signal,\n  options\n}]);\n\nconst toMultiAbortableSource = (source, signals) => {\n  source = getIterator(source);\n  signals = signals.map(_ref => {\n    let {\n      signal,\n      options\n    } = _ref;\n    return {\n      signal,\n      options: options || {}\n    };\n  });\n\n  async function* abortable() {\n    let nextAbortHandler;\n\n    const abortHandler = () => {\n      if (nextAbortHandler) nextAbortHandler();\n    };\n\n    for (const {\n      signal\n    } of signals) {\n      signal.addEventListener('abort', abortHandler);\n    }\n\n    while (true) {\n      let result;\n\n      try {\n        for (const {\n          signal,\n          options\n        } of signals) {\n          if (signal.aborted) {\n            const {\n              abortMessage,\n              abortCode\n            } = options;\n            throw new AbortError(abortMessage, abortCode);\n          }\n        }\n\n        const abort = new Promise((resolve, reject) => {\n          nextAbortHandler = () => {\n            const {\n              options\n            } = signals.find(_ref2 => {\n              let {\n                signal\n              } = _ref2;\n              return signal.aborted;\n            });\n            const {\n              abortMessage,\n              abortCode\n            } = options;\n            reject(new AbortError(abortMessage, abortCode));\n          };\n        }); // Race the iterator and the abort signals\n\n        result = await Promise.race([abort, source.next()]);\n        nextAbortHandler = null;\n      } catch (err) {\n        for (const {\n          signal\n        } of signals) {\n          signal.removeEventListener('abort', abortHandler);\n        } // Might not have been aborted by a known signal\n\n\n        const aborter = signals.find(_ref3 => {\n          let {\n            signal\n          } = _ref3;\n          return signal.aborted;\n        });\n        const isKnownAborter = err.type === 'aborted' && aborter;\n\n        if (isKnownAborter && aborter.options.onAbort) {\n          // Do any custom abort handling for the iterator\n          await aborter.options.onAbort(source);\n        } // End the iterator if it is a generator\n\n\n        if (typeof source.return === 'function') {\n          try {\n            const p = source.return();\n\n            if (p instanceof Promise) {\n              // eslint-disable-line max-depth\n              p.catch(err => {\n                if (aborter.options.onReturnError != null) {\n                  aborter.options.onReturnError(err);\n                }\n              });\n            }\n          } catch (err) {\n            if (aborter.options.onReturnError != null) {\n              // eslint-disable-line max-depth\n              aborter.options.onReturnError(err);\n            }\n          }\n        }\n\n        if (isKnownAborter && aborter.options.returnOnAbort) {\n          return;\n        }\n\n        throw err;\n      }\n\n      if (result.done) break;\n      yield result.value;\n    }\n\n    for (const {\n      signal\n    } of signals) {\n      signal.removeEventListener('abort', abortHandler);\n    }\n  }\n\n  return abortable();\n};\n\nconst toAbortableSink = (sink, signal, options) => toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{\n  signal,\n  options\n}]);\n\nconst toMultiAbortableSink = (sink, signals) => source => sink(toMultiAbortableSource(source, signals));\n\nconst toAbortableDuplex = (duplex, signal, options) => toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{\n  signal,\n  options\n}]);\n\nconst toMultiAbortableDuplex = (duplex, signals) => ({\n  sink: toMultiAbortableSink(duplex.sink, signals),\n  source: toMultiAbortableSource(duplex.source, signals)\n});\n\nmodule.exports = toAbortableSource;\nmodule.exports.AbortError = AbortError;\nmodule.exports.source = toAbortableSource;\nmodule.exports.sink = toAbortableSink;\nmodule.exports.transform = toAbortableSink;\nmodule.exports.duplex = toAbortableDuplex;","map":{"version":3,"names":["getIterator","require","AbortError","toAbortableSource","source","signal","options","toMultiAbortableSource","Array","isArray","signals","map","abortable","nextAbortHandler","abortHandler","addEventListener","result","aborted","abortMessage","abortCode","abort","Promise","resolve","reject","find","race","next","err","removeEventListener","aborter","isKnownAborter","type","onAbort","return","p","catch","onReturnError","returnOnAbort","done","value","toAbortableSink","sink","toMultiAbortableSink","toAbortableDuplex","duplex","toMultiAbortableDuplex","module","exports","transform"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/abortable-iterator/index.js"],"sourcesContent":["const getIterator = require('get-iterator')\nconst AbortError = require('./AbortError')\n\n// Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\nconst toAbortableSource = (source, signal, options) => (\n  toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableSource = (source, signals) => {\n  source = getIterator(source)\n  signals = signals.map(({ signal, options }) => ({ signal, options: options || {} }))\n\n  async function * abortable () {\n    let nextAbortHandler\n    const abortHandler = () => {\n      if (nextAbortHandler) nextAbortHandler()\n    }\n\n    for (const { signal } of signals) {\n      signal.addEventListener('abort', abortHandler)\n    }\n\n    while (true) {\n      let result\n      try {\n        for (const { signal, options } of signals) {\n          if (signal.aborted) {\n            const { abortMessage, abortCode } = options\n            throw new AbortError(abortMessage, abortCode)\n          }\n        }\n\n        const abort = new Promise((resolve, reject) => {\n          nextAbortHandler = () => {\n            const { options } = signals.find(({ signal }) => signal.aborted)\n            const { abortMessage, abortCode } = options\n            reject(new AbortError(abortMessage, abortCode))\n          }\n        })\n\n        // Race the iterator and the abort signals\n        result = await Promise.race([abort, source.next()])\n        nextAbortHandler = null\n      } catch (err) {\n        for (const { signal } of signals) {\n          signal.removeEventListener('abort', abortHandler)\n        }\n\n        // Might not have been aborted by a known signal\n        const aborter = signals.find(({ signal }) => signal.aborted)\n        const isKnownAborter = err.type === 'aborted' && aborter\n\n        if (isKnownAborter && aborter.options.onAbort) {\n          // Do any custom abort handling for the iterator\n          await aborter.options.onAbort(source)\n        }\n\n        // End the iterator if it is a generator\n        if (typeof source.return === 'function') {\n          try {\n            const p = source.return()\n\n            if (p instanceof Promise) { // eslint-disable-line max-depth\n              p.catch(err => {\n                if (aborter.options.onReturnError != null) {\n                  aborter.options.onReturnError(err)\n                }\n              })\n            }\n          } catch (err) {\n            if (aborter.options.onReturnError != null) { // eslint-disable-line max-depth\n              aborter.options.onReturnError(err)\n            }\n          }\n        }\n\n        if (isKnownAborter && aborter.options.returnOnAbort) {\n          return\n        }\n\n        throw err\n      }\n\n      if (result.done) break\n      yield result.value\n    }\n\n    for (const { signal } of signals) {\n      signal.removeEventListener('abort', abortHandler)\n    }\n  }\n\n  return abortable()\n}\n\nconst toAbortableSink = (sink, signal, options) => (\n  toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableSink = (sink, signals) => source => (\n  sink(toMultiAbortableSource(source, signals))\n)\n\nconst toAbortableDuplex = (duplex, signal, options) => (\n  toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableDuplex = (duplex, signals) => ({\n  sink: toMultiAbortableSink(duplex.sink, signals),\n  source: toMultiAbortableSource(duplex.source, signals)\n})\n\nmodule.exports = toAbortableSource\nmodule.exports.AbortError = AbortError\nmodule.exports.source = toAbortableSource\nmodule.exports.sink = toAbortableSink\nmodule.exports.transform = toAbortableSink\nmodule.exports.duplex = toAbortableDuplex\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}