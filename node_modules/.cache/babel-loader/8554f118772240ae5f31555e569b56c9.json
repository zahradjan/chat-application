{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decryptStream = exports.encryptStream = void 0;\n\nvar buffer_1 = require(\"buffer\");\n\nvar constants_1 = require(\"./constants\"); // Returns generator that encrypts payload from the user\n\n\nfunction encryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n      var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk, chunkBuffer, i, end, data;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context.prev = 2;\n              _iterator = _asyncIterator(source);\n\n            case 4:\n              _context.next = 6;\n              return _awaitAsyncGenerator(_iterator.next());\n\n            case 6:\n              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                _context.next = 22;\n                break;\n              }\n\n              chunk = _step.value;\n              chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n              i = 0;\n\n            case 10:\n              if (!(i < chunkBuffer.length)) {\n                _context.next = 19;\n                break;\n              }\n\n              end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n\n              if (end > chunkBuffer.length) {\n                end = chunkBuffer.length;\n              }\n\n              data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n              _context.next = 16;\n              return data;\n\n            case 16:\n              i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n              _context.next = 10;\n              break;\n\n            case 19:\n              _iteratorAbruptCompletion = false;\n              _context.next = 4;\n              break;\n\n            case 22:\n              _context.next = 28;\n              break;\n\n            case 24:\n              _context.prev = 24;\n              _context.t0 = _context[\"catch\"](2);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 28:\n              _context.prev = 28;\n              _context.prev = 29;\n\n              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                _context.next = 33;\n                break;\n              }\n\n              _context.next = 33;\n              return _awaitAsyncGenerator(_iterator.return());\n\n            case 33:\n              _context.prev = 33;\n\n              if (!_didIteratorError) {\n                _context.next = 36;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 36:\n              return _context.finish(33);\n\n            case 37:\n              return _context.finish(28);\n\n            case 38:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 24, 28, 38], [29,, 33, 37]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nexports.encryptStream = encryptStream; // Decrypt received payload to the user\n\nfunction decryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source) {\n      var _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, chunk, chunkBuffer, i, end, _chunk, _yield$_awaitAsyncGen, decrypted, valid;\n\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _iteratorAbruptCompletion2 = false;\n              _didIteratorError2 = false;\n              _context2.prev = 2;\n              _iterator2 = _asyncIterator(source);\n\n            case 4:\n              _context2.next = 6;\n              return _awaitAsyncGenerator(_iterator2.next());\n\n            case 6:\n              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context2.sent).done)) {\n                _context2.next = 29;\n                break;\n              }\n\n              chunk = _step2.value;\n              chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n              i = 0;\n\n            case 10:\n              if (!(i < chunkBuffer.length)) {\n                _context2.next = 26;\n                break;\n              }\n\n              end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;\n\n              if (end > chunkBuffer.length) {\n                end = chunkBuffer.length;\n              }\n\n              _chunk = chunkBuffer.slice(i, end);\n              _context2.next = 16;\n              return _awaitAsyncGenerator(handshake.decrypt(_chunk, handshake.session));\n\n            case 16:\n              _yield$_awaitAsyncGen = _context2.sent;\n              decrypted = _yield$_awaitAsyncGen.plaintext;\n              valid = _yield$_awaitAsyncGen.valid;\n\n              if (valid) {\n                _context2.next = 21;\n                break;\n              }\n\n              throw new Error('Failed to validate decrypted chunk');\n\n            case 21:\n              _context2.next = 23;\n              return decrypted;\n\n            case 23:\n              i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES;\n              _context2.next = 10;\n              break;\n\n            case 26:\n              _iteratorAbruptCompletion2 = false;\n              _context2.next = 4;\n              break;\n\n            case 29:\n              _context2.next = 35;\n              break;\n\n            case 31:\n              _context2.prev = 31;\n              _context2.t0 = _context2[\"catch\"](2);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context2.t0;\n\n            case 35:\n              _context2.prev = 35;\n              _context2.prev = 36;\n\n              if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                _context2.next = 40;\n                break;\n              }\n\n              _context2.next = 40;\n              return _awaitAsyncGenerator(_iterator2.return());\n\n            case 40:\n              _context2.prev = 40;\n\n              if (!_didIteratorError2) {\n                _context2.next = 43;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 43:\n              return _context2.finish(40);\n\n            case 44:\n              return _context2.finish(35);\n\n            case 45:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[2, 31, 35, 45], [36,, 40, 44]]);\n    }));\n\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}\n\nexports.decryptStream = decryptStream;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;AAAA;;AAEA,yC,CAMA;;;AACA,SAAgBA,aAAhB,CAA+BC,SAA/B,EAAoD;EAClD;IAAA,wEAAO,iBAAkBC,MAAlB;MAAA;;MAAA;QAAA;UAAA;YAAA;cAAA;cAAA;cAAA;cAAA,2BACqBA,MADrB;;YAAA;cAAA;cAAA;;YAAA;cAAA;gBAAA;gBAAA;cAAA;;cACYC,KADZ;cAEGC,WAFH,GAEiBC,gBAAOC,IAAP,CAAYH,KAAK,CAACI,MAAlB,EAA0BJ,KAAK,CAACK,UAAhC,EAA4CL,KAAK,CAACM,MAAlD,CAFjB;cAIMC,CAJN,GAIU,CAJV;;YAAA;cAAA,MAIaA,CAAC,GAAGN,WAAW,CAACK,MAJ7B;gBAAA;gBAAA;cAAA;;cAKGE,GALH,GAKSD,CAAC,GAAGE,kDALb;;cAMD,IAAID,GAAG,GAAGP,WAAW,CAACK,MAAtB,EAA8B;gBAC5BE,GAAG,GAAGP,WAAW,CAACK,MAAlB;cACD;;cAEKI,IAVL,GAUYZ,SAAS,CAACa,OAAV,CAAkBV,WAAW,CAACW,KAAZ,CAAkBL,CAAlB,EAAqBC,GAArB,CAAlB,EAA6CV,SAAS,CAACe,OAAvD,CAVZ;cAAA;cAWD,OAAMH,IAAN;;YAXC;cAIqCH,CAAC,IAAIE,kDAJ1C;cAAA;cAAA;;YAAA;cAAA;cAAA;cAAA;;YAAA;cAAA;cAAA;;YAAA;cAAA;cAAA;cAAA;cAAA;;YAAA;cAAA;cAAA;;cAAA;gBAAA;gBAAA;cAAA;;cAAA;cAAA;;YAAA;cAAA;;cAAA;gBAAA;gBAAA;cAAA;;cAAA;;YAAA;cAAA;;YAAA;cAAA;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAAP;;IAAA;MAAA;IAAA;EAAA;AAeD;;AAhBDK,sC,CAkBA;;AACA,SAAgBC,aAAhB,CAA+BjB,SAA/B,EAAoD;EAClD;IAAA,yEAAO,kBAAkBC,MAAlB;MAAA;;MAAA;QAAA;UAAA;YAAA;cAAA;cAAA;cAAA;cAAA,4BACqBA,MADrB;;YAAA;cAAA;cAAA;;YAAA;cAAA;gBAAA;gBAAA;cAAA;;cACYC,KADZ;cAEGC,WAFH,GAEiBC,gBAAOC,IAAP,CAAYH,KAAK,CAACI,MAAlB,EAA0BJ,KAAK,CAACK,UAAhC,EAA4CL,KAAK,CAACM,MAAlD,CAFjB;cAIMC,CAJN,GAIU,CAJV;;YAAA;cAAA,MAIaA,CAAC,GAAGN,WAAW,CAACK,MAJ7B;gBAAA;gBAAA;cAAA;;cAKGE,GALH,GAKSD,CAAC,GAAGE,sCALb;;cAMD,IAAID,GAAG,GAAGP,WAAW,CAACK,MAAtB,EAA8B;gBAC5BE,GAAG,GAAGP,WAAW,CAACK,MAAlB;cACD;;cAEKN,MAVL,GAUaC,WAAW,CAACW,KAAZ,CAAkBL,CAAlB,EAAqBC,GAArB,CAVb;cAAA;cAAA,4BAW6CV,SAAS,CAACkB,OAAV,CAAkBhB,MAAlB,EAAyBF,SAAS,CAACe,OAAnC,CAX7C;;YAAA;cAAA;cAWkBI,SAXlB,yBAWOC,SAXP;cAW6BC,KAX7B,yBAW6BA,KAX7B;;cAAA,IAYIA,KAZJ;gBAAA;gBAAA;cAAA;;cAAA,MAaO,IAAIC,KAAJ,CAAU,oCAAV,CAbP;;YAAA;cAAA;cAeD,OAAMH,SAAN;;YAfC;cAIqCV,CAAC,IAAIE,sCAJ1C;cAAA;cAAA;;YAAA;cAAA;cAAA;cAAA;;YAAA;cAAA;cAAA;;YAAA;cAAA;cAAA;cAAA;cAAA;;YAAA;cAAA;cAAA;;cAAA;gBAAA;gBAAA;cAAA;;cAAA;cAAA;;YAAA;cAAA;;cAAA;gBAAA;gBAAA;cAAA;;cAAA;;YAAA;cAAA;;YAAA;cAAA;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAAP;;IAAA;MAAA;IAAA;EAAA;AAmBD;;AApBDK","names":["encryptStream","handshake","source","chunk","chunkBuffer","buffer_1","from","buffer","byteOffset","length","i","end","constants_1","data","encrypt","slice","session","exports","decryptStream","decrypt","decrypted","plaintext","valid","Error"],"sourceRoot":"","sources":["../../src/crypto.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}