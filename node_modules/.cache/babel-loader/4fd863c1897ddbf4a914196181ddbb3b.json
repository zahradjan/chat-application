{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst errCode = require('err-code');\n\nconst debug = require('debug');\n\nconst first = require('it-first');\n\nconst Block = require('multiformats/block');\n\nconst cborg = require('cborg');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  cidToKey,\n  keyToMultihash\n} = require('./utils/blockstore');\n\nconst walkDag = require('./utils/walk-dag');\n/**\n * @typedef {object} PinInternal\n * @property {number} depth\n * @property {import('multiformats/cid').CIDVersion} [version]\n * @property {number} [codec]\n * @property {Record<string, any>} [metadata]\n */\n\n/**\n * @typedef {import('./types').PinType} PinType\n * @typedef {import('./types').PinQueryType} PinQueryType\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('./types').PinOptions} PinOptions\n * @typedef {import('./types').AbortOptions} AbortOptions\n * @typedef {import('./types').Pins} Pins\n */\n\n/**\n * @param {string} type\n */\n\n\nfunction invalidPinTypeErr(type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\nconst PinTypes = {\n  /** @type {'direct'} */\n  direct: 'direct',\n\n  /** @type {'recursive'} */\n  recursive: 'recursive',\n\n  /** @type {'indirect'} */\n  indirect: 'indirect',\n\n  /** @type {'all'} */\n  all: 'all'\n};\n/**\n * @implements {Pins}\n */\n\nclass PinManager {\n  /**\n   * @param {Object} config\n   * @param {import('interface-datastore').Datastore} config.pinstore\n   * @param {import('interface-blockstore').Blockstore} config.blockstore\n   * @param {import('./types').loadCodec} config.loadCodec\n   */\n  constructor(_ref) {\n    let {\n      pinstore,\n      blockstore,\n      loadCodec\n    } = _ref;\n    this.pinstore = pinstore;\n    this.blockstore = blockstore;\n    this.loadCodec = loadCodec;\n    this.log = debug('ipfs:repo:pin');\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n\n\n  async pinDirectly(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    await this.blockstore.get(cid, options);\n    /** @type {PinInternal} */\n\n    const pin = {\n      depth: 0\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n\n    return this.pinstore.put(cidToKey(cid), cborg.encode(pin));\n  }\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n\n\n  unpin(cid, options) {\n    return this.pinstore.delete(cidToKey(cid), options);\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n\n\n  async pinRecursively(cid) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    await this.fetchCompleteDag(cid, options);\n    /** @type {PinInternal} */\n\n    const pin = {\n      depth: Infinity\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n\n    await this.pinstore.put(cidToKey(cid), cborg.encode(pin));\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  async *directKeys(options) {\n    for await (const entry of this.pinstore.query({\n      filters: [entry => {\n        const pin = cborg.decode(entry.value);\n        return pin.depth === 0;\n      }]\n    })) {\n      const pin = cborg.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec != null ? pin.codec : dagPb.code;\n      const multihash = keyToMultihash(entry.key);\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  async *recursiveKeys(options) {\n    for await (const entry of this.pinstore.query({\n      filters: [entry => {\n        const pin = cborg.decode(entry.value);\n        return pin.depth === Infinity;\n      }]\n    })) {\n      const pin = cborg.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec != null ? pin.codec : dagPb.code;\n      const multihash = keyToMultihash(entry.key);\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  async *indirectKeys(options) {\n    for await (const {\n      cid\n    } of this.recursiveKeys()) {\n      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {\n        // recursive pins override indirect pins\n        const types = [PinTypes.recursive];\n        const result = await this.isPinnedWithType(childCid, types);\n\n        if (result.pinned) {\n          continue;\n        }\n\n        yield childCid;\n      }\n    }\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinQueryType|PinQueryType[]} types\n   * @param {AbortOptions} [options]\n   */\n\n\n  async isPinnedWithType(cid, types, options) {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n\n    const all = types.includes(PinTypes.all);\n    const direct = types.includes(PinTypes.direct);\n    const recursive = types.includes(PinTypes.recursive);\n    const indirect = types.includes(PinTypes.indirect);\n\n    if (recursive || direct || all) {\n      const result = await first(this.pinstore.query({\n        prefix: cidToKey(cid).toString(),\n        filters: [entry => {\n          if (all) {\n            return true;\n          }\n\n          const pin = cborg.decode(entry.value);\n          return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);\n        }],\n        limit: 1\n      }));\n\n      if (result) {\n        const pin = cborg.decode(result.value);\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n          metadata: pin.metadata\n        };\n      }\n    }\n\n    const self = this;\n    /**\n     * @param {CID} key\n     * @param {AsyncIterable<{ cid: CID, metadata: any }>} source\n     */\n\n    async function* findChild(key, source) {\n      for await (const {\n        cid: parentCid\n      } of source) {\n        for await (const childCid of walkDag(parentCid, self.blockstore, self.loadCodec)) {\n          if (childCid.equals(key)) {\n            yield parentCid;\n            return;\n          }\n        }\n      }\n    }\n\n    if (all || indirect) {\n      // indirect (default)\n      // check each recursive key to see if multihash is under it\n      const parentCid = await first(findChild(cid, this.recursiveKeys()));\n\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: PinTypes.indirect,\n          parent: parentCid\n        };\n      }\n    }\n\n    return {\n      cid,\n      pinned: false\n    };\n  }\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} options\n   */\n\n\n  async fetchCompleteDag(cid, options) {\n    const seen = new Set();\n    /**\n     * @param {CID} cid\n     * @param {AbortOptions} options\n     */\n\n    const walkDag = async (cid, options) => {\n      if (seen.has(cid.toString())) {\n        return;\n      }\n\n      seen.add(cid.toString());\n      const bytes = await this.blockstore.get(cid, options);\n      const codec = await this.loadCodec(cid.code);\n      const block = Block.createUnsafe({\n        bytes,\n        cid,\n        codec\n      });\n      await Promise.all([...block.links()].map(_ref2 => {\n        let [, childCid] = _ref2;\n        return walkDag(childCid, options);\n      }));\n    };\n\n    await walkDag(cid, options);\n  }\n  /**\n   * Throws an error if the pin type is invalid\n   *\n   * @param {any} type\n   * @returns {type is PinType}\n   */\n\n\n  static checkPinType(type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type);\n    }\n\n    return true;\n  }\n\n}\n\nmodule.exports = {\n  PinManager,\n  PinTypes\n};","map":{"version":3,"names":["CID","require","errCode","debug","first","Block","cborg","dagPb","cidToKey","keyToMultihash","walkDag","invalidPinTypeErr","type","errMsg","Error","PinTypes","direct","recursive","indirect","all","PinManager","constructor","pinstore","blockstore","loadCodec","log","directPins","Set","recursivePins","pinDirectly","cid","options","get","pin","depth","version","code","codec","metadata","put","encode","unpin","delete","pinRecursively","fetchCompleteDag","Infinity","directKeys","entry","query","filters","decode","value","multihash","key","create","recursiveKeys","indirectKeys","childCid","types","result","isPinnedWithType","pinned","Array","isArray","includes","prefix","toString","limit","reason","self","findChild","source","parentCid","equals","parent","seen","has","add","bytes","block","createUnsafe","Promise","links","map","checkPinType","Object","keys","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-repo/src/pins.js"],"sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst errCode = require('err-code')\nconst debug = require('debug')\nconst first = require('it-first')\nconst Block = require('multiformats/block')\nconst cborg = require('cborg')\nconst dagPb = require('@ipld/dag-pb')\nconst {\n  cidToKey,\n  keyToMultihash\n} = require('./utils/blockstore')\nconst walkDag = require('./utils/walk-dag')\n\n/**\n * @typedef {object} PinInternal\n * @property {number} depth\n * @property {import('multiformats/cid').CIDVersion} [version]\n * @property {number} [codec]\n * @property {Record<string, any>} [metadata]\n */\n\n/**\n * @typedef {import('./types').PinType} PinType\n * @typedef {import('./types').PinQueryType} PinQueryType\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('./types').PinOptions} PinOptions\n * @typedef {import('./types').AbortOptions} AbortOptions\n * @typedef {import('./types').Pins} Pins\n */\n\n/**\n * @param {string} type\n */\nfunction invalidPinTypeErr (type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE')\n}\n\nconst PinTypes = {\n  /** @type {'direct'} */\n  direct: ('direct'),\n  /** @type {'recursive'} */\n  recursive: ('recursive'),\n  /** @type {'indirect'} */\n  indirect: ('indirect'),\n  /** @type {'all'} */\n  all: ('all')\n}\n\n/**\n * @implements {Pins}\n */\nclass PinManager {\n  /**\n   * @param {Object} config\n   * @param {import('interface-datastore').Datastore} config.pinstore\n   * @param {import('interface-blockstore').Blockstore} config.blockstore\n   * @param {import('./types').loadCodec} config.loadCodec\n   */\n  constructor ({ pinstore, blockstore, loadCodec }) {\n    this.pinstore = pinstore\n    this.blockstore = blockstore\n    this.loadCodec = loadCodec\n    this.log = debug('ipfs:repo:pin')\n    this.directPins = new Set()\n    this.recursivePins = new Set()\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n  async pinDirectly (cid, options = {}) {\n    await this.blockstore.get(cid, options)\n\n    /** @type {PinInternal} */\n    const pin = {\n      depth: 0\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata\n    }\n\n    return this.pinstore.put(cidToKey(cid), cborg.encode(pin))\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n  unpin (cid, options) {\n    return this.pinstore.delete(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n  async pinRecursively (cid, options = {}) {\n    await this.fetchCompleteDag(cid, options)\n\n    /** @type {PinInternal} */\n    const pin = {\n      depth: Infinity\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata\n    }\n\n    await this.pinstore.put(cidToKey(cid), cborg.encode(pin))\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * directKeys (options) {\n    for await (const entry of this.pinstore.query({\n      filters: [(entry) => {\n        const pin = cborg.decode(entry.value)\n\n        return pin.depth === 0\n      }]\n    })) {\n      const pin = cborg.decode(entry.value)\n      const version = pin.version || 0\n      const codec = pin.codec != null ? pin.codec : dagPb.code\n      const multihash = keyToMultihash(entry.key)\n\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      }\n    }\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * recursiveKeys (options) {\n    for await (const entry of this.pinstore.query({\n      filters: [(entry) => {\n        const pin = cborg.decode(entry.value)\n\n        return pin.depth === Infinity\n      }]\n    })) {\n      const pin = cborg.decode(entry.value)\n      const version = pin.version || 0\n      const codec = pin.codec != null ? pin.codec : dagPb.code\n      const multihash = keyToMultihash(entry.key)\n\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      }\n    }\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * indirectKeys (options) {\n    for await (const { cid } of this.recursiveKeys()) {\n      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {\n        // recursive pins override indirect pins\n        const types = [\n          PinTypes.recursive\n        ]\n\n        const result = await this.isPinnedWithType(childCid, types)\n\n        if (result.pinned) {\n          continue\n        }\n\n        yield childCid\n      }\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinQueryType|PinQueryType[]} types\n   * @param {AbortOptions} [options]\n   */\n  async isPinnedWithType (cid, types, options) {\n    if (!Array.isArray(types)) {\n      types = [types]\n    }\n\n    const all = types.includes(PinTypes.all)\n    const direct = types.includes(PinTypes.direct)\n    const recursive = types.includes(PinTypes.recursive)\n    const indirect = types.includes(PinTypes.indirect)\n\n    if (recursive || direct || all) {\n      const result = await first(this.pinstore.query({\n        prefix: cidToKey(cid).toString(),\n        filters: [entry => {\n          if (all) {\n            return true\n          }\n\n          const pin = cborg.decode(entry.value)\n\n          return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive)\n        }],\n        limit: 1\n      }))\n\n      if (result) {\n        const pin = cborg.decode(result.value)\n\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n          metadata: pin.metadata\n        }\n      }\n    }\n\n    const self = this\n\n    /**\n     * @param {CID} key\n     * @param {AsyncIterable<{ cid: CID, metadata: any }>} source\n     */\n    async function * findChild (key, source) {\n      for await (const { cid: parentCid } of source) {\n        for await (const childCid of walkDag(parentCid, self.blockstore, self.loadCodec)) {\n          if (childCid.equals(key)) {\n            yield parentCid\n            return\n          }\n        }\n      }\n    }\n\n    if (all || indirect) {\n      // indirect (default)\n      // check each recursive key to see if multihash is under it\n\n      const parentCid = await first(findChild(cid, this.recursiveKeys()))\n\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: PinTypes.indirect,\n          parent: parentCid\n        }\n      }\n    }\n\n    return {\n      cid,\n      pinned: false\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} options\n   */\n  async fetchCompleteDag (cid, options) {\n    const seen = new Set()\n\n    /**\n     * @param {CID} cid\n     * @param {AbortOptions} options\n     */\n    const walkDag = async (cid, options) => {\n      if (seen.has(cid.toString())) {\n        return\n      }\n\n      seen.add(cid.toString())\n\n      const bytes = await this.blockstore.get(cid, options)\n      const codec = await this.loadCodec(cid.code)\n      const block = Block.createUnsafe({ bytes, cid, codec })\n\n      await Promise.all(\n        [...block.links()].map(([, childCid]) => walkDag(childCid, options))\n      )\n    }\n\n    await walkDag(cid, options)\n  }\n\n  /**\n   * Throws an error if the pin type is invalid\n   *\n   * @param {any} type\n   * @returns {type is PinType}\n   */\n  static checkPinType (type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type)\n    }\n    return true\n  }\n}\n\nmodule.exports = {\n  PinManager,\n  PinTypes\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}