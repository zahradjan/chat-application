{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require('multiformats/hashes/sha2'),\n    sha256 = _require.sha256;\n\nvar errcode = require('err-code');\n\nvar _require2 = require('uint8arrays/equals'),\n    uint8ArrayEquals = _require2.equals;\n\nvar _require3 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require3.toString;\n\nvar exporter = require('./exporter');\n\nmodule.exports = function (keysProtobuf, randomBytes, crypto) {\n  crypto = crypto || require('./secp256k1')();\n\n  var Secp256k1PublicKey = /*#__PURE__*/function () {\n    function Secp256k1PublicKey(key) {\n      _classCallCheck(this, Secp256k1PublicKey);\n\n      crypto.validatePublicKey(key);\n      this._key = key;\n    }\n\n    _createClass(Secp256k1PublicKey, [{\n      key: \"verify\",\n      value: function verify(data, sig) {\n        return crypto.hashAndVerify(this._key, sig, data);\n      }\n    }, {\n      key: \"marshal\",\n      value: function marshal() {\n        return crypto.compressPublicKey(this._key);\n      }\n    }, {\n      key: \"bytes\",\n      get: function get() {\n        return keysProtobuf.PublicKey.encode({\n          Type: keysProtobuf.KeyType.Secp256k1,\n          Data: this.marshal()\n        }).finish();\n      }\n    }, {\n      key: \"equals\",\n      value: function equals(key) {\n        return uint8ArrayEquals(this.bytes, key.bytes);\n      }\n    }, {\n      key: \"hash\",\n      value: function () {\n        var _hash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          var _yield$sha256$digest, bytes;\n\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return sha256.digest(this.bytes);\n\n                case 2:\n                  _yield$sha256$digest = _context.sent;\n                  bytes = _yield$sha256$digest.bytes;\n                  return _context.abrupt(\"return\", bytes);\n\n                case 5:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function hash() {\n          return _hash.apply(this, arguments);\n        }\n\n        return hash;\n      }()\n    }]);\n\n    return Secp256k1PublicKey;\n  }();\n\n  var Secp256k1PrivateKey = /*#__PURE__*/function () {\n    function Secp256k1PrivateKey(key, publicKey) {\n      _classCallCheck(this, Secp256k1PrivateKey);\n\n      this._key = key;\n      this._publicKey = publicKey || crypto.computePublicKey(key);\n      crypto.validatePrivateKey(this._key);\n      crypto.validatePublicKey(this._publicKey);\n    }\n\n    _createClass(Secp256k1PrivateKey, [{\n      key: \"sign\",\n      value: function sign(message) {\n        return crypto.hashAndSign(this._key, message);\n      }\n    }, {\n      key: \"public\",\n      get: function get() {\n        return new Secp256k1PublicKey(this._publicKey);\n      }\n    }, {\n      key: \"marshal\",\n      value: function marshal() {\n        return this._key;\n      }\n    }, {\n      key: \"bytes\",\n      get: function get() {\n        return keysProtobuf.PrivateKey.encode({\n          Type: keysProtobuf.KeyType.Secp256k1,\n          Data: this.marshal()\n        }).finish();\n      }\n    }, {\n      key: \"equals\",\n      value: function equals(key) {\n        return uint8ArrayEquals(this.bytes, key.bytes);\n      }\n    }, {\n      key: \"hash\",\n      value: function () {\n        var _hash2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var _yield$sha256$digest2, bytes;\n\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return sha256.digest(this.bytes);\n\n                case 2:\n                  _yield$sha256$digest2 = _context2.sent;\n                  bytes = _yield$sha256$digest2.bytes;\n                  return _context2.abrupt(\"return\", bytes);\n\n                case 5:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function hash() {\n          return _hash2.apply(this, arguments);\n        }\n\n        return hash;\n      }()\n      /**\n       * Gets the ID of the key.\n       *\n       * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n       * The public key is a protobuf encoding containing a type and the DER encoding\n       * of the PKCS SubjectPublicKeyInfo.\n       *\n       * @returns {Promise<string>}\n       */\n\n    }, {\n      key: \"id\",\n      value: function () {\n        var _id = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n          var hash;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.next = 2;\n                  return this.public.hash();\n\n                case 2:\n                  hash = _context3.sent;\n                  return _context3.abrupt(\"return\", uint8ArrayToString(hash, 'base58btc'));\n\n                case 4:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n\n        function id() {\n          return _id.apply(this, arguments);\n        }\n\n        return id;\n      }()\n      /**\n       * Exports the key into a password protected `format`\n       *\n       * @param {string} password - The password to encrypt the key\n       * @param {string} [format=libp2p-key] - The format in which to export as\n       * @returns {Promise<string>} The encrypted private key\n       */\n\n    }, {\n      key: \"export\",\n      value: function () {\n        var _export2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(password) {\n          var format,\n              _args4 = arguments;\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  format = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : 'libp2p-key';\n\n                  if (!(format === 'libp2p-key')) {\n                    _context4.next = 5;\n                    break;\n                  }\n\n                  return _context4.abrupt(\"return\", exporter.export(this.bytes, password));\n\n                case 5:\n                  throw errcode(new Error(\"export format '\".concat(format, \"' is not supported\")), 'ERR_INVALID_EXPORT_FORMAT');\n\n                case 6:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n\n        function _export(_x) {\n          return _export2.apply(this, arguments);\n        }\n\n        return _export;\n      }()\n    }]);\n\n    return Secp256k1PrivateKey;\n  }();\n\n  function unmarshalSecp256k1PrivateKey(bytes) {\n    return new Secp256k1PrivateKey(bytes);\n  }\n\n  function unmarshalSecp256k1PublicKey(bytes) {\n    return new Secp256k1PublicKey(bytes);\n  }\n\n  function generateKeyPair() {\n    return _generateKeyPair.apply(this, arguments);\n  }\n\n  function _generateKeyPair() {\n    _generateKeyPair = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n      var privateKeyBytes;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return crypto.generateKey();\n\n            case 2:\n              privateKeyBytes = _context5.sent;\n              return _context5.abrupt(\"return\", new Secp256k1PrivateKey(privateKeyBytes));\n\n            case 4:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n    return _generateKeyPair.apply(this, arguments);\n  }\n\n  return {\n    Secp256k1PublicKey: Secp256k1PublicKey,\n    Secp256k1PrivateKey: Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey: unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey: unmarshalSecp256k1PublicKey,\n    generateKeyPair: generateKeyPair\n  };\n};","map":{"version":3,"names":["require","sha256","errcode","uint8ArrayEquals","equals","uint8ArrayToString","toString","exporter","module","exports","keysProtobuf","randomBytes","crypto","Secp256k1PublicKey","key","validatePublicKey","_key","data","sig","hashAndVerify","compressPublicKey","PublicKey","encode","Type","KeyType","Secp256k1","Data","marshal","finish","bytes","digest","Secp256k1PrivateKey","publicKey","_publicKey","computePublicKey","validatePrivateKey","message","hashAndSign","PrivateKey","public","hash","password","format","export","Error","unmarshalSecp256k1PrivateKey","unmarshalSecp256k1PublicKey","generateKeyPair","generateKey","privateKeyBytes"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-delegated-content-routing/node_modules/libp2p-crypto/src/keys/secp256k1-class.js"],"sourcesContent":["'use strict'\n\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst errcode = require('err-code')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst exporter = require('./exporter')\n\nmodule.exports = (keysProtobuf, randomBytes, crypto) => {\n  crypto = crypto || require('./secp256k1')()\n\n  class Secp256k1PublicKey {\n    constructor (key) {\n      crypto.validatePublicKey(key)\n      this._key = key\n    }\n\n    verify (data, sig) {\n      return crypto.hashAndVerify(this._key, sig, data)\n    }\n\n    marshal () {\n      return crypto.compressPublicKey(this._key)\n    }\n\n    get bytes () {\n      return keysProtobuf.PublicKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      }).finish()\n    }\n\n    equals (key) {\n      return uint8ArrayEquals(this.bytes, key.bytes)\n    }\n\n    async hash () {\n      const { bytes } = await sha256.digest(this.bytes)\n\n      return bytes\n    }\n  }\n\n  class Secp256k1PrivateKey {\n    constructor (key, publicKey) {\n      this._key = key\n      this._publicKey = publicKey || crypto.computePublicKey(key)\n      crypto.validatePrivateKey(this._key)\n      crypto.validatePublicKey(this._publicKey)\n    }\n\n    sign (message) {\n      return crypto.hashAndSign(this._key, message)\n    }\n\n    get public () {\n      return new Secp256k1PublicKey(this._publicKey)\n    }\n\n    marshal () {\n      return this._key\n    }\n\n    get bytes () {\n      return keysProtobuf.PrivateKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      }).finish()\n    }\n\n    equals (key) {\n      return uint8ArrayEquals(this.bytes, key.bytes)\n    }\n\n    async hash () {\n      const { bytes } = await sha256.digest(this.bytes)\n\n      return bytes\n    }\n\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @returns {Promise<string>}\n     */\n    async id () {\n      const hash = await this.public.hash()\n      return uint8ArrayToString(hash, 'base58btc')\n    }\n\n    /**\n     * Exports the key into a password protected `format`\n     *\n     * @param {string} password - The password to encrypt the key\n     * @param {string} [format=libp2p-key] - The format in which to export as\n     * @returns {Promise<string>} The encrypted private key\n     */\n    async export (password, format = 'libp2p-key') { // eslint-disable-line require-await\n      if (format === 'libp2p-key') {\n        return exporter.export(this.bytes, password)\n      } else {\n        throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')\n      }\n    }\n  }\n\n  function unmarshalSecp256k1PrivateKey (bytes) {\n    return new Secp256k1PrivateKey(bytes)\n  }\n\n  function unmarshalSecp256k1PublicKey (bytes) {\n    return new Secp256k1PublicKey(bytes)\n  }\n\n  async function generateKeyPair () {\n    const privateKeyBytes = await crypto.generateKey()\n    return new Secp256k1PrivateKey(privateKeyBytes)\n  }\n\n  return {\n    Secp256k1PublicKey,\n    Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey,\n    generateKeyPair\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}