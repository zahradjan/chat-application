{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar varint = require('varint');\n\nvar cid = require('multiformats/cid');\n\nvar Digest = require('multiformats/hashes/digest');\n\nvar dagCbor = require('@ipld/dag-cbor');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar varint__default = /*#__PURE__*/_interopDefaultLegacy(varint);\n\nvar Digest__namespace = /*#__PURE__*/_interopNamespace(Digest);\n\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\n\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint__default[\"default\"].decode(bytes);\n  reader.seek(varint__default[\"default\"].decode.bytes);\n  return i;\n}\n\nasync function readHeader(reader) {\n  const length = await readVarint(reader);\n\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = dagCbor.decode(header);\n\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${block.version}\"`);\n    }\n\n    throw new Error(`Invalid CAR version: ${block.version}`);\n  }\n\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n\n  return block;\n}\n\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint__default[\"default\"].decode(bytes);\n  const codeLength = varint__default[\"default\"].decode.bytes;\n  const length = varint__default[\"default\"].decode(bytes.subarray(varint__default[\"default\"].decode.bytes));\n  const lengthLength = varint__default[\"default\"].decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\n\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest__namespace.decode(bytes);\n    return cid.CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n\n  const version = await readVarint(reader);\n\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`);\n  }\n\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest__namespace.decode(bytes);\n  return cid.CID.create(version, codec, multihash);\n}\n\nasync function readBlockHead(reader) {\n  const start = reader.pos;\n  let length = await readVarint(reader);\n\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\n\nasync function readBlock(reader) {\n  const {\n    cid,\n    blockLength\n  } = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\n\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {\n    cid,\n    length,\n    blockLength\n  } = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\n\nfunction createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n\n    async *blocks() {\n      await headerPromise;\n\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n\n    async *blocksIndex() {\n      await headerPromise;\n\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n\n  };\n}\n\nfunction bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n\n      return bytes.subarray(pos, pos + length);\n    },\n\n    seek(length) {\n      pos += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\n\nfunction chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n\n    while (have < length) {\n      const chunk = await readChunk();\n\n      if (chunk == null) {\n        break;\n      }\n\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n\n      have += chunk.length;\n    }\n\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n\n    offset = 0;\n  };\n\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n\n      return currentChunk.subarray(offset, offset + length);\n    },\n\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n\n    get pos() {\n      return pos;\n    }\n\n  };\n}\n\nfunction asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n\n  async function readChunk() {\n    const next = await iterator.next();\n\n    if (next.done) {\n      return null;\n    }\n\n    return next.value;\n  }\n\n  return chunkReader(readChunk);\n}\n\nexports.asyncIterableReader = asyncIterableReader;\nexports.bytesReader = bytesReader;\nexports.chunkReader = chunkReader;\nexports.createDecoder = createDecoder;\nexports.readBlockHead = readBlockHead;\nexports.readHeader = readHeader;","map":{"version":3,"names":["Object","defineProperty","exports","value","varint","require","cid","Digest","dagCbor","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","varint__default","Digest__namespace","CIDV0_BYTES","SHA2_256","LENGTH","DAG_PB","readVarint","reader","bytes","upTo","i","decode","seek","readHeader","length","Error","header","exactly","block","Array","isArray","version","roots","filter","p","readMultihash","codeLength","subarray","lengthLength","mhLength","multihash","readCid","first","CID","codec","readBlockHead","start","pos","blockLength","readBlock","readBlockIndex","offset","index","blockOffset","createDecoder","headerPromise","blocks","blocksIndex","bytesReader","Math","min","chunkReader","readChunk","have","currentChunk","Uint8Array","read","bufa","chunk","push","reduce","c","off","b","set","asyncIterableReader","asyncIterable","iterator","Symbol","asyncIterator","next","done"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/@ipld/car/cjs/lib/decoder.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar varint = require('varint');\nvar cid = require('multiformats/cid');\nvar Digest = require('multiformats/hashes/digest');\nvar dagCbor = require('@ipld/dag-cbor');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar varint__default = /*#__PURE__*/_interopDefaultLegacy(varint);\nvar Digest__namespace = /*#__PURE__*/_interopNamespace(Digest);\n\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint__default[\"default\"].decode(bytes);\n  reader.seek(varint__default[\"default\"].decode.bytes);\n  return i;\n}\nasync function readHeader(reader) {\n  const length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = dagCbor.decode(header);\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${ block.version }\"`);\n    }\n    throw new Error(`Invalid CAR version: ${ block.version }`);\n  }\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n  return block;\n}\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint__default[\"default\"].decode(bytes);\n  const codeLength = varint__default[\"default\"].decode.bytes;\n  const length = varint__default[\"default\"].decode(bytes.subarray(varint__default[\"default\"].decode.bytes));\n  const lengthLength = varint__default[\"default\"].decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest__namespace.decode(bytes);\n    return cid.CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n  const version = await readVarint(reader);\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${ version })`);\n  }\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest__namespace.decode(bytes);\n  return cid.CID.create(version, codec, multihash);\n}\nasync function readBlockHead(reader) {\n  const start = reader.pos;\n  let length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\nasync function readBlock(reader) {\n  const {cid, blockLength} = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {cid, length, blockLength} = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\nfunction createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n    async *blocks() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n    async *blocksIndex() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n  };\n}\nfunction bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n      return bytes.subarray(pos, pos + length);\n    },\n    seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nfunction chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n    while (have < length) {\n      const chunk = await readChunk();\n      if (chunk == null) {\n        break;\n      }\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n      have += chunk.length;\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n    offset = 0;\n  };\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n      return currentChunk.subarray(offset, offset + length);\n    },\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nfunction asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  async function readChunk() {\n    const next = await iterator.next();\n    if (next.done) {\n      return null;\n    }\n    return next.value;\n  }\n  return chunkReader(readChunk);\n}\n\nexports.asyncIterableReader = asyncIterableReader;\nexports.bytesReader = bytesReader;\nexports.chunkReader = chunkReader;\nexports.createDecoder = createDecoder;\nexports.readBlockHead = readBlockHead;\nexports.readHeader = readHeader;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}