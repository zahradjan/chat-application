{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Noise = void 0;\n\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\n\nconst buffer_1 = require(\"buffer\");\n\nconst it_pb_rpc_1 = __importDefault(require(\"it-pb-rpc\"));\n\nconst duplex_1 = __importDefault(require(\"it-pair/duplex\"));\n\nconst it_buffer_1 = __importDefault(require(\"it-buffer\"));\n\nconst it_pipe_1 = __importDefault(require(\"it-pipe\"));\n\nconst it_length_prefixed_1 = require(\"it-length-prefixed\");\n\nconst handshake_xx_1 = require(\"./handshake-xx\");\n\nconst handshake_ik_1 = require(\"./handshake-ik\");\n\nconst handshake_xx_fallback_1 = require(\"./handshake-xx-fallback\");\n\nconst utils_1 = require(\"./utils\");\n\nconst encoder_1 = require(\"./encoder\");\n\nconst crypto_1 = require(\"./crypto\");\n\nconst keycache_1 = require(\"./keycache\");\n\nconst logger_1 = require(\"./logger\");\n\nconst constants_1 = require(\"./constants\");\n\nclass Noise {\n  /**\n   *\n   * @param {bytes} staticNoiseKey - x25519 private key, reuse for faster handshakes\n   * @param {bytes} earlyData\n   */\n  constructor(staticNoiseKey, earlyData) {\n    this.protocol = '/noise';\n    this.prologue = buffer_1.Buffer.alloc(0);\n    this.earlyData = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0); // disabled until properly specked\n\n    this.useNoisePipes = false;\n\n    if (staticNoiseKey) {\n      // accepts x25519 private key of length 32\n      const keyPair = x25519.generateKeyPairFromSeed(staticNoiseKey);\n      this.staticKeys = {\n        privateKey: buffer_1.Buffer.from(keyPair.secretKey.buffer, keyPair.secretKey.byteOffset, keyPair.secretKey.length),\n        publicKey: buffer_1.Buffer.from(keyPair.publicKey.buffer, keyPair.publicKey.byteOffset, keyPair.publicKey.length)\n      };\n    } else {\n      this.staticKeys = utils_1.generateKeypair();\n    }\n  }\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param {any} connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  async secureOutbound(localPeer, connection, remotePeer) {\n    const wrappedConnection = it_pb_rpc_1.default(connection, {\n      lengthEncoder: encoder_1.uint16BEEncode,\n      lengthDecoder: encoder_1.uint16BEDecode,\n      maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n    });\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: true,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    };\n  }\n  /**\n   * Decrypt incoming data (handshake as responder).\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param {any} connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  async secureInbound(localPeer, connection, remotePeer) {\n    const wrappedConnection = it_pb_rpc_1.default(connection, {\n      lengthEncoder: encoder_1.uint16BEEncode,\n      lengthDecoder: encoder_1.uint16BEDecode,\n      maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n    });\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: false,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    };\n  }\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   *\n   * @param {HandshakeParams} params\n   */\n\n\n  async performHandshake(params) {\n    var _a;\n\n    const payload = await utils_1.getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n    let tryIK = this.useNoisePipes;\n\n    if (params.isInitiator && keycache_1.KeyCache.load(params.remotePeer) === null) {\n      // if we are initiator and remote static key is unknown, don't try IK\n      tryIK = false;\n    } // Try IK if acting as responder or initiator that has remote's static key.\n\n\n    if (tryIK) {\n      // Try IK first\n      const {\n        remotePeer,\n        connection,\n        isInitiator\n      } = params;\n      const ikHandshake = new handshake_ik_1.IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, // safe to cast as we did checks\n      (_a = keycache_1.KeyCache.load(params.remotePeer)) !== null && _a !== void 0 ? _a : buffer_1.Buffer.alloc(32), remotePeer);\n\n      try {\n        return await this.performIKHandshake(ikHandshake);\n      } catch (e) {\n        // IK failed, go to XX fallback\n        let ephemeralKeys;\n\n        if (params.isInitiator) {\n          ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n        }\n\n        return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);\n      }\n    } else {\n      // run XX handshake\n      return await this.performXXHandshake(params, payload);\n    }\n  }\n\n  async performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {\n    const {\n      isInitiator,\n      remotePeer,\n      connection\n    } = params;\n    const handshake = new handshake_xx_fallback_1.XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n    } catch (e) {\n      logger_1.logger(e);\n      const err = e;\n      throw new Error(`Error occurred during XX Fallback handshake: ${err.message}`);\n    }\n\n    return handshake;\n  }\n\n  async performXXHandshake(params, payload) {\n    const {\n      isInitiator,\n      remotePeer,\n      connection\n    } = params;\n    const handshake = new handshake_xx_1.XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n\n      if (this.useNoisePipes && handshake.remotePeer) {\n        keycache_1.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n      }\n    } catch (e) {\n      const err = e;\n      throw new Error(`Error occurred during XX handshake: ${err.message}`);\n    }\n\n    return handshake;\n  }\n\n  async performIKHandshake(handshake) {\n    await handshake.stage0();\n    await handshake.stage1();\n    return handshake;\n  }\n\n  async createSecureConnection(connection, handshake) {\n    // Create encryption box/unbox wrapper\n    const [secure, user] = duplex_1.default();\n    const network = connection.unwrap();\n    await it_pipe_1.default(secure, // write to wrapper\n    it_buffer_1.default, // ensure any type of data is converted to buffer\n    crypto_1.encryptStream(handshake), // data is encrypted\n    it_length_prefixed_1.encode({\n      lengthEncoder: encoder_1.uint16BEEncode\n    }), // prefix with message length\n    network, // send to the remote peer\n    it_length_prefixed_1.decode({\n      lengthDecoder: encoder_1.uint16BEDecode\n    }), // read message length prefix\n    it_buffer_1.default, // ensure any type of data is converted to buffer\n    crypto_1.decryptStream(handshake), // decrypt the incoming data\n    secure // pipe to the wrapper\n    );\n    return user;\n  }\n\n}\n\nexports.Noise = Noise;","map":{"version":3,"mappings":"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","names":["Noise","constructor","staticNoiseKey","earlyData","buffer_1","alloc","useNoisePipes","keyPair","x25519","generateKeyPairFromSeed","staticKeys","privateKey","from","secretKey","buffer","byteOffset","length","publicKey","utils_1","secureOutbound","localPeer","connection","remotePeer","wrappedConnection","it_pb_rpc_1","lengthEncoder","encoder_1","lengthDecoder","maxDataLength","constants_1","handshake","performHandshake","isInitiator","conn","createSecureConnection","remoteEarlyData","secureInbound","params","payload","tryIK","keycache_1","load","ikHandshake","handshake_ik_1","prologue","_a","performIKHandshake","e","ephemeralKeys","getLocalEphemeralKeys","performXXFallbackHandshake","initialMsg","performXXHandshake","handshake_xx_fallback_1","propose","exchange","finish","logger_1","err","Error","message","handshake_xx_1","store","getRemoteStaticKey","stage0","stage1","secure","user","duplex_1","network","unwrap","it_pipe_1","it_buffer_1","crypto_1","it_length_prefixed_1","exports"],"sourceRoot":"","sources":["../../src/noise.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}