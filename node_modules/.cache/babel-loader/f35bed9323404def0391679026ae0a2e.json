{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar _asyncGeneratorDelegate = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate.js\").default;\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('libp2p:peer-routing'), {\n  error: debug('libp2p:peer-routing:err')\n});\n\nvar errCode = require('err-code');\n\nvar _require = require('./content-routing/utils'),\n    storeAddresses = _require.storeAddresses,\n    uniquePeers = _require.uniquePeers,\n    requirePeers = _require.requirePeers;\n\nvar merge = require('it-merge');\n\nvar _require2 = require('it-pipe'),\n    pipe = _require2.pipe;\n\nvar first = require('it-first');\n\nvar drain = require('it-drain');\n\nvar filter = require('it-filter');\n\nvar _require3 = require('set-delayed-interval'),\n    setDelayedInterval = _require3.setDelayedInterval,\n    clearDelayedInterval = _require3.clearDelayedInterval;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n */\n\n/**\n * @typedef {Object} RefreshManagerOptions\n * @property {boolean} [enabled = true] - Whether to enable the Refresh manager\n * @property {number} [bootDelay = 6e5] - Boot delay to start the Refresh Manager (in ms)\n * @property {number} [interval = 10e3] - Interval between each Refresh Manager run (in ms)\n *\n * @typedef {Object} PeerRoutingOptions\n * @property {RefreshManagerOptions} [refreshManager]\n */\n\n\nvar PeerRouting = /*#__PURE__*/function () {\n  /**\n   * @class\n   * @param {import('./')} libp2p\n   */\n  function PeerRouting(libp2p) {\n    _classCallCheck(this, PeerRouting);\n\n    this._peerId = libp2p.peerId;\n    this._peerStore = libp2p.peerStore;\n    /** @type {PeerRoutingModule[]} */\n\n    this._routers = libp2p._modules.peerRouting || []; // If we have the dht, add it to the available peer routers\n\n    if (libp2p._dht && libp2p._config.dht.enabled) {\n      this._routers.push(libp2p._dht);\n    }\n\n    this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager;\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);\n  }\n  /**\n   * Start peer routing service.\n   */\n\n\n  _createClass(PeerRouting, [{\n    key: \"start\",\n    value: function start() {\n      if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {\n        return;\n      }\n\n      this._timeoutId = setDelayedInterval(this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay);\n    }\n    /**\n     * Recurrent task to find closest peers and add their addresses to the Address Book.\n     */\n\n  }, {\n    key: \"_findClosestPeersTask\",\n    value: function () {\n      var _findClosestPeersTask2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return drain(this.getClosestPeers(this._peerId.id));\n\n              case 3:\n                _context.next = 8;\n                break;\n\n              case 5:\n                _context.prev = 5;\n                _context.t0 = _context[\"catch\"](0);\n                log.error(_context.t0);\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 5]]);\n      }));\n\n      function _findClosestPeersTask() {\n        return _findClosestPeersTask2.apply(this, arguments);\n      }\n\n      return _findClosestPeersTask;\n    }()\n    /**\n     * Stop peer routing service.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      clearDelayedInterval(this._timeoutId);\n    }\n    /**\n     * Iterates over all peer routers in parallel to find the given peer.\n     *\n     * @param {PeerId} id - The id of the peer to find\n     * @param {object} [options]\n     * @param {number} [options.timeout] - How long the query should run\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n\n  }, {\n    key: \"findPeer\",\n    value: function () {\n      var _findPeer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(id, options) {\n        var _this2 = this;\n\n        var output;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this._routers.length) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE');\n\n              case 2:\n                if (!(id.toB58String() === this._peerId.toB58String())) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                throw errCode(new Error('Should not try to find self'), 'ERR_FIND_SELF');\n\n              case 4:\n                _context2.next = 6;\n                return pipe(merge.apply(void 0, _toConsumableArray(this._routers.map(function (router) {\n                  return [router.findPeer(id, options)];\n                }))), function (source) {\n                  return filter(source, Boolean);\n                }, // @ts-ignore findPeer resolves a Promise\n                function (source) {\n                  return storeAddresses(source, _this2._peerStore);\n                }, function (source) {\n                  return first(source);\n                });\n\n              case 6:\n                output = _context2.sent;\n\n                if (!output) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", output);\n\n              case 9:\n                throw errCode(new Error('not found'), 'NOT_FOUND');\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function findPeer(_x, _x2) {\n        return _findPeer.apply(this, arguments);\n      }\n\n      return findPeer;\n    }()\n    /**\n     * Attempt to find the closest peers on the network to the given key.\n     *\n     * @param {Uint8Array} key - A CID like key\n     * @param {Object} [options]\n     * @param {number} [options.timeout=30e3] - How long the query can take.\n     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n\n  }, {\n    key: \"getClosestPeers\",\n    value: function getClosestPeers(key) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        timeout: 30e3\n      };\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (_this._routers.length) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE');\n\n              case 2:\n                return _context3.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pipe(merge.apply(void 0, _toConsumableArray(_this._routers.map(function (router) {\n                  return router.getClosestPeers(key, options);\n                }))), function (source) {\n                  return storeAddresses(source, _this._peerStore);\n                }, function (source) {\n                  return uniquePeers(source);\n                }, function (source) {\n                  return requirePeers(source);\n                })), _awaitAsyncGenerator), \"t0\", 3);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    }\n  }]);\n\n  return PeerRouting;\n}();\n\nmodule.exports = PeerRouting;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errCode","storeAddresses","uniquePeers","requirePeers","merge","pipe","first","drain","filter","setDelayedInterval","clearDelayedInterval","PeerRouting","libp2p","_peerId","peerId","_peerStore","peerStore","_routers","_modules","peerRouting","_dht","_config","dht","enabled","push","_refreshManagerOptions","_options","refreshManager","_findClosestPeersTask","bind","length","_timeoutId","interval","bootDelay","getClosestPeers","id","options","Error","toB58String","map","router","findPeer","source","Boolean","output","key","timeout","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/peer-routing.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:peer-routing'), {\n  error: debug('libp2p:peer-routing:err')\n})\nconst errCode = require('err-code')\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers\n} = require('./content-routing/utils')\n\nconst merge = require('it-merge')\nconst { pipe } = require('it-pipe')\nconst first = require('it-first')\nconst drain = require('it-drain')\nconst filter = require('it-filter')\nconst {\n  setDelayedInterval,\n  clearDelayedInterval\n// @ts-ignore module with no types\n} = require('set-delayed-interval')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n */\n\n/**\n * @typedef {Object} RefreshManagerOptions\n * @property {boolean} [enabled = true] - Whether to enable the Refresh manager\n * @property {number} [bootDelay = 6e5] - Boot delay to start the Refresh Manager (in ms)\n * @property {number} [interval = 10e3] - Interval between each Refresh Manager run (in ms)\n *\n * @typedef {Object} PeerRoutingOptions\n * @property {RefreshManagerOptions} [refreshManager]\n */\n\nclass PeerRouting {\n  /**\n   * @class\n   * @param {import('./')} libp2p\n   */\n  constructor (libp2p) {\n    this._peerId = libp2p.peerId\n    this._peerStore = libp2p.peerStore\n    /** @type {PeerRoutingModule[]} */\n    this._routers = libp2p._modules.peerRouting || []\n\n    // If we have the dht, add it to the available peer routers\n    if (libp2p._dht && libp2p._config.dht.enabled) {\n      this._routers.push(libp2p._dht)\n    }\n\n    this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager\n\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this)\n  }\n\n  /**\n   * Start peer routing service.\n   */\n  start () {\n    if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {\n      return\n    }\n\n    this._timeoutId = setDelayedInterval(\n      this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay\n    )\n  }\n\n  /**\n   * Recurrent task to find closest peers and add their addresses to the Address Book.\n   */\n  async _findClosestPeersTask () {\n    try {\n      // nb getClosestPeers adds the addresses to the address book\n      await drain(this.getClosestPeers(this._peerId.id))\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Stop peer routing service.\n   */\n  stop () {\n    clearDelayedInterval(this._timeoutId)\n  }\n\n  /**\n   * Iterates over all peer routers in parallel to find the given peer.\n   *\n   * @param {PeerId} id - The id of the peer to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async findPeer (id, options) { // eslint-disable-line require-await\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE')\n    }\n\n    if (id.toB58String() === this._peerId.toB58String()) {\n      throw errCode(new Error('Should not try to find self'), 'ERR_FIND_SELF')\n    }\n\n    const output = await pipe(\n      merge(\n        ...this._routers.map(router => [router.findPeer(id, options)])\n      ),\n      (source) => filter(source, Boolean),\n      // @ts-ignore findPeer resolves a Promise\n      (source) => storeAddresses(source, this._peerStore),\n      (source) => first(source)\n    )\n\n    if (output) {\n      return output\n    }\n\n    throw errCode(new Error('not found'), 'NOT_FOUND')\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key.\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {Object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async * getClosestPeers (key, options = { timeout: 30e3 }) {\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE')\n    }\n\n    yield * pipe(\n      merge(\n        ...this._routers.map(router => router.getClosestPeers(key, options))\n      ),\n      (source) => storeAddresses(source, this._peerStore),\n      (source) => uniquePeers(source),\n      (source) => requirePeers(source)\n    )\n  }\n}\n\nmodule.exports = PeerRouting\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}