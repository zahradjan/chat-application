{"ast":null,"code":"import _objectSpread from \"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\n\nvar _0n = BigInt(0);\n\nvar _1n = BigInt(1);\n\nvar _2n = BigInt(2);\n\nvar _3n = BigInt(3);\n\nvar _8n = BigInt(8);\n\nvar POW_2_256 = Math.pow(_2n, BigInt(256));\nvar CURVE = {\n  a: _0n,\n  b: BigInt(7),\n  P: POW_2_256 - Math.pow(_2n, BigInt(32)) - BigInt(977),\n  n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),\n  h: _1n,\n  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')\n};\nexport { CURVE };\n\nfunction weistrass(x) {\n  var a = CURVE.a,\n      b = CURVE.b;\n  var x2 = mod(x * x);\n  var x3 = mod(x2 * x);\n  return mod(x3 + a * x + b);\n}\n\nvar USE_ENDOMORPHISM = CURVE.a === _0n;\n\nvar JacobianPoint = /*#__PURE__*/function () {\n  function JacobianPoint(x, y, z) {\n    _classCallCheck(this, JacobianPoint);\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  _createClass(JacobianPoint, [{\n    key: \"equals\",\n    value: function equals(other) {\n      if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');\n      var X1 = this.x,\n          Y1 = this.y,\n          Z1 = this.z;\n      var X2 = other.x,\n          Y2 = other.y,\n          Z2 = other.z;\n      var Z1Z1 = mod(Math.pow(Z1, _2n));\n      var Z2Z2 = mod(Math.pow(Z2, _2n));\n      var U1 = mod(X1 * Z2Z2);\n      var U2 = mod(X2 * Z1Z1);\n      var S1 = mod(mod(Y1 * Z2) * Z2Z2);\n      var S2 = mod(mod(Y2 * Z1) * Z1Z1);\n      return U1 === U2 && S1 === S2;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n  }, {\n    key: \"double\",\n    value: function double() {\n      var X1 = this.x,\n          Y1 = this.y,\n          Z1 = this.z;\n      var A = mod(Math.pow(X1, _2n));\n      var B = mod(Math.pow(Y1, _2n));\n      var C = mod(Math.pow(B, _2n));\n      var D = mod(_2n * (mod(Math.pow(X1 + B, _2n)) - A - C));\n      var E = mod(_3n * A);\n      var F = mod(Math.pow(E, _2n));\n      var X3 = mod(F - _2n * D);\n      var Y3 = mod(E * (D - X3) - _8n * C);\n      var Z3 = mod(_2n * Y1 * Z1);\n      return new JacobianPoint(X3, Y3, Z3);\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');\n      var X1 = this.x,\n          Y1 = this.y,\n          Z1 = this.z;\n      var X2 = other.x,\n          Y2 = other.y,\n          Z2 = other.z;\n      if (X2 === _0n || Y2 === _0n) return this;\n      if (X1 === _0n || Y1 === _0n) return other;\n      var Z1Z1 = mod(Math.pow(Z1, _2n));\n      var Z2Z2 = mod(Math.pow(Z2, _2n));\n      var U1 = mod(X1 * Z2Z2);\n      var U2 = mod(X2 * Z1Z1);\n      var S1 = mod(mod(Y1 * Z2) * Z2Z2);\n      var S2 = mod(mod(Y2 * Z1) * Z1Z1);\n      var H = mod(U2 - U1);\n      var r = mod(S2 - S1);\n\n      if (H === _0n) {\n        if (r === _0n) {\n          return this.double();\n        } else {\n          return JacobianPoint.ZERO;\n        }\n      }\n\n      var HH = mod(Math.pow(H, _2n));\n      var HHH = mod(H * HH);\n      var V = mod(U1 * HH);\n      var X3 = mod(Math.pow(r, _2n) - HHH - _2n * V);\n      var Y3 = mod(r * (V - X3) - S1 * HHH);\n      var Z3 = mod(Z1 * Z2 * H);\n      return new JacobianPoint(X3, Y3, Z3);\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      return this.add(other.negate());\n    }\n  }, {\n    key: \"multiplyUnsafe\",\n    value: function multiplyUnsafe(scalar) {\n      var n = normalizeScalar(scalar);\n      var G = JacobianPoint.BASE;\n      var P0 = JacobianPoint.ZERO;\n      if (n === _0n) return P0;\n      if (n === _1n) return this;\n\n      if (!USE_ENDOMORPHISM) {\n        var p = P0;\n\n        var _d = this;\n\n        while (n > _0n) {\n          if (n & _1n) p = p.add(_d);\n          _d = _d.double();\n          n >>= _1n;\n        }\n\n        return p;\n      }\n\n      var _splitScalarEndo = splitScalarEndo(n),\n          k1neg = _splitScalarEndo.k1neg,\n          k1 = _splitScalarEndo.k1,\n          k2neg = _splitScalarEndo.k2neg,\n          k2 = _splitScalarEndo.k2;\n\n      var k1p = P0;\n      var k2p = P0;\n      var d = this;\n\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n      return k1p.add(k2p);\n    }\n  }, {\n    key: \"precomputeWindow\",\n    value: function precomputeWindow(W) {\n      var windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n      var points = [];\n      var p = this;\n      var base = p;\n\n      for (var window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n\n        for (var i = 1; i < Math.pow(2, W - 1); i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n\n        p = base.double();\n      }\n\n      return points;\n    }\n  }, {\n    key: \"wNAF\",\n    value: function wNAF(n, affinePoint) {\n      if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n      var W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n\n      if (256 % W) {\n        throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n      }\n\n      var precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n\n      if (!precomputes) {\n        precomputes = this.precomputeWindow(W);\n\n        if (affinePoint && W !== 1) {\n          precomputes = JacobianPoint.normalizeZ(precomputes);\n          pointPrecomputes.set(affinePoint, precomputes);\n        }\n      }\n\n      var p = JacobianPoint.ZERO;\n      var f = JacobianPoint.ZERO;\n      var windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n      var windowSize = Math.pow(2, W - 1);\n      var mask = BigInt(Math.pow(2, W) - 1);\n      var maxNumber = Math.pow(2, W);\n      var shiftBy = BigInt(W);\n\n      for (var window = 0; window < windows; window++) {\n        var offset = window * windowSize;\n        var wbits = Number(n & mask);\n        n >>= shiftBy;\n\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n\n        if (wbits === 0) {\n          var pr = precomputes[offset];\n          if (window % 2) pr = pr.negate();\n          f = f.add(pr);\n        } else {\n          var cached = precomputes[offset + Math.abs(wbits) - 1];\n          if (wbits < 0) cached = cached.negate();\n          p = p.add(cached);\n        }\n      }\n\n      return {\n        p: p,\n        f: f\n      };\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar, affinePoint) {\n      var n = normalizeScalar(scalar);\n      var point;\n      var fake;\n\n      if (USE_ENDOMORPHISM) {\n        var _splitScalarEndo2 = splitScalarEndo(n),\n            k1neg = _splitScalarEndo2.k1neg,\n            k1 = _splitScalarEndo2.k1,\n            k2neg = _splitScalarEndo2.k2neg,\n            k2 = _splitScalarEndo2.k2;\n\n        var _this$wNAF = this.wNAF(k1, affinePoint),\n            k1p = _this$wNAF.p,\n            f1p = _this$wNAF.f;\n\n        var _this$wNAF2 = this.wNAF(k2, affinePoint),\n            k2p = _this$wNAF2.p,\n            f2p = _this$wNAF2.f;\n\n        if (k1neg) k1p = k1p.negate();\n        if (k2neg) k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        var _this$wNAF3 = this.wNAF(n, affinePoint),\n            p = _this$wNAF3.p,\n            f = _this$wNAF3.f;\n\n        point = p;\n        fake = f;\n      }\n\n      return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n  }, {\n    key: \"toAffine\",\n    value: function toAffine() {\n      var invZ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : invert(this.z);\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      var iz1 = invZ;\n      var iz2 = mod(iz1 * iz1);\n      var iz3 = mod(iz2 * iz1);\n      var ax = mod(x * iz2);\n      var ay = mod(y * iz3);\n      var zz = mod(z * iz1);\n      if (zz !== _1n) throw new Error('invZ was invalid');\n      return new Point(ax, ay);\n    }\n  }], [{\n    key: \"fromAffine\",\n    value: function fromAffine(p) {\n      if (!(p instanceof Point)) {\n        throw new TypeError('JacobianPoint#fromAffine: expected Point');\n      }\n\n      return new JacobianPoint(p.x, p.y, _1n);\n    }\n  }, {\n    key: \"toAffineBatch\",\n    value: function toAffineBatch(points) {\n      var toInv = invertBatch(points.map(function (p) {\n        return p.z;\n      }));\n      return points.map(function (p, i) {\n        return p.toAffine(toInv[i]);\n      });\n    }\n  }, {\n    key: \"normalizeZ\",\n    value: function normalizeZ(points) {\n      return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n  }]);\n\n  return JacobianPoint;\n}();\n\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nvar pointPrecomputes = new WeakMap();\nexport var Point = /*#__PURE__*/function () {\n  function Point(x, y) {\n    _classCallCheck(this, Point);\n\n    this.x = x;\n    this.y = y;\n  }\n\n  _createClass(Point, [{\n    key: \"_setWindowSize\",\n    value: function _setWindowSize(windowSize) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return hexToBytes(this.toHex(isCompressed));\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var x = numTo32bStr(this.x);\n\n      if (isCompressed) {\n        var prefix = this.y & _1n ? '03' : '02';\n        return \"\".concat(prefix).concat(x);\n      } else {\n        return \"04\".concat(x).concat(numTo32bStr(this.y));\n      }\n    }\n  }, {\n    key: \"toHexX\",\n    value: function toHexX() {\n      return this.toHex(true).slice(2);\n    }\n  }, {\n    key: \"toRawX\",\n    value: function toRawX() {\n      return this.toRawBytes(true).slice(1);\n    }\n  }, {\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var msg = 'Point is not on elliptic curve';\n      var x = this.x,\n          y = this.y;\n      if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);\n      var left = mod(y * y);\n      var right = weistrass(x);\n      if (mod(left - right) !== _0n) throw new Error(msg);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.x === other.x && this.y === other.y;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return new Point(this.x, mod(-this.y));\n    }\n  }, {\n    key: \"double\",\n    value: function double() {\n      return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      return this.add(other.negate());\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar) {\n      return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n  }, {\n    key: \"multiplyAndAddUnsafe\",\n    value: function multiplyAndAddUnsafe(Q, a, b) {\n      var P = JacobianPoint.fromAffine(this);\n      var aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n      var bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n      var sum = aP.add(bQ);\n      return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n  }], [{\n    key: \"fromCompressedHex\",\n    value: function fromCompressedHex(bytes) {\n      var isShort = bytes.length === 32;\n      var x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n      if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n      var y2 = weistrass(x);\n      var y = sqrtMod(y2);\n      var isYOdd = (y & _1n) === _1n;\n\n      if (isShort) {\n        if (isYOdd) y = mod(-y);\n      } else {\n        var isFirstByteOdd = (bytes[0] & 1) === 1;\n        if (isFirstByteOdd !== isYOdd) y = mod(-y);\n      }\n\n      var point = new Point(x, y);\n      point.assertValidity();\n      return point;\n    }\n  }, {\n    key: \"fromUncompressedHex\",\n    value: function fromUncompressedHex(bytes) {\n      var x = bytesToNumber(bytes.subarray(1, 33));\n      var y = bytesToNumber(bytes.subarray(33, 65));\n      var point = new Point(x, y);\n      point.assertValidity();\n      return point;\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      var bytes = ensureBytes(hex);\n      var len = bytes.length;\n      var header = bytes[0];\n\n      if (len === 32 || len === 33 && (header === 0x02 || header === 0x03)) {\n        return this.fromCompressedHex(bytes);\n      }\n\n      if (len === 65 && header === 0x04) return this.fromUncompressedHex(bytes);\n      throw new Error(\"Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not \".concat(len));\n    }\n  }, {\n    key: \"fromPrivateKey\",\n    value: function fromPrivateKey(privateKey) {\n      return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n  }, {\n    key: \"fromSignature\",\n    value: function fromSignature(msgHash, signature, recovery) {\n      msgHash = ensureBytes(msgHash);\n      var h = truncateHash(msgHash);\n\n      var _normalizeSignature = normalizeSignature(signature),\n          r = _normalizeSignature.r,\n          s = _normalizeSignature.s;\n\n      if (recovery !== 0 && recovery !== 1) {\n        throw new Error('Cannot recover signature: invalid recovery bit');\n      }\n\n      if (h === _0n) throw new Error('Cannot recover signature: msgHash cannot be 0');\n      var prefix = recovery & 1 ? '03' : '02';\n      var R = Point.fromHex(prefix + numTo32bStr(r));\n      var n = CURVE.n;\n      var rinv = invert(r, n);\n      var u1 = mod(-h * rinv, n);\n      var u2 = mod(s * rinv, n);\n      var Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n      if (!Q) throw new Error('Cannot recover signature: point at infinify');\n      Q.assertValidity();\n      return Q;\n    }\n  }]);\n\n  return Point;\n}();\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\n\nfunction sliceDER(s) {\n  return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\n\nfunction parseDERInt(data) {\n  if (data.length < 2 || data[0] !== 0x02) {\n    throw new Error(\"Invalid signature integer tag: \".concat(bytesToHex(data)));\n  }\n\n  var len = data[1];\n  var res = data.subarray(2, len + 2);\n\n  if (!len || res.length !== len) {\n    throw new Error(\"Invalid signature integer: wrong length\");\n  }\n\n  if (res[0] === 0x00 && res[1] <= 0x7f) {\n    throw new Error('Invalid signature integer: trailing length');\n  }\n\n  return {\n    data: bytesToNumber(res),\n    left: data.subarray(len + 2)\n  };\n}\n\nfunction parseDERSignature(data) {\n  if (data.length < 2 || data[0] != 0x30) {\n    throw new Error(\"Invalid signature tag: \".concat(bytesToHex(data)));\n  }\n\n  if (data[1] !== data.length - 2) {\n    throw new Error('Invalid signature: incorrect length');\n  }\n\n  var _parseDERInt = parseDERInt(data.subarray(2)),\n      r = _parseDERInt.data,\n      sBytes = _parseDERInt.left;\n\n  var _parseDERInt2 = parseDERInt(sBytes),\n      s = _parseDERInt2.data,\n      rBytesLeft = _parseDERInt2.left;\n\n  if (rBytesLeft.length) {\n    throw new Error(\"Invalid signature: left bytes after parsing: \".concat(bytesToHex(rBytesLeft)));\n  }\n\n  return {\n    r: r,\n    s: s\n  };\n}\n\nexport var Signature = /*#__PURE__*/function () {\n  function Signature(r, s) {\n    _classCallCheck(this, Signature);\n\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n\n  _createClass(Signature, [{\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var r = this.r,\n          s = this.s;\n      if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');\n      if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n  }, {\n    key: \"hasHighS\",\n    value: function hasHighS() {\n      var HALF = CURVE.n >> _1n;\n      return this.s > HALF;\n    }\n  }, {\n    key: \"normalizeS\",\n    value: function normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;\n    }\n  }, {\n    key: \"toDERRawBytes\",\n    value: function toDERRawBytes() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return hexToBytes(this.toDERHex(isCompressed));\n    }\n  }, {\n    key: \"toDERHex\",\n    value: function toDERHex() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var sHex = sliceDER(numberToHexUnpadded(this.s));\n      if (isCompressed) return sHex;\n      var rHex = sliceDER(numberToHexUnpadded(this.r));\n      var rLen = numberToHexUnpadded(rHex.length / 2);\n      var sLen = numberToHexUnpadded(sHex.length / 2);\n      var length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);\n      return \"30\".concat(length, \"02\").concat(rLen).concat(rHex, \"02\").concat(sLen).concat(sHex);\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      return this.toDERRawBytes();\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return this.toDERHex();\n    }\n  }, {\n    key: \"toCompactRawBytes\",\n    value: function toCompactRawBytes() {\n      return hexToBytes(this.toCompactHex());\n    }\n  }, {\n    key: \"toCompactHex\",\n    value: function toCompactHex() {\n      return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n  }], [{\n    key: \"fromCompact\",\n    value: function fromCompact(hex) {\n      var arr = isUint8a(hex);\n      var name = 'Signature.fromCompact';\n      if (typeof hex !== 'string' && !arr) throw new TypeError(\"\".concat(name, \": Expected string or Uint8Array\"));\n      var str = arr ? bytesToHex(hex) : hex;\n      if (str.length !== 128) throw new Error(\"\".concat(name, \": Expected 64-byte hex\"));\n      return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n  }, {\n    key: \"fromDER\",\n    value: function fromDER(hex) {\n      var arr = isUint8a(hex);\n      if (typeof hex !== 'string' && !arr) throw new TypeError(\"Signature.fromDER: Expected string or Uint8Array\");\n\n      var _parseDERSignature = parseDERSignature(arr ? hex : hexToBytes(hex)),\n          r = _parseDERSignature.r,\n          s = _parseDERSignature.s;\n\n      return new Signature(r, s);\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      return this.fromDER(hex);\n    }\n  }]);\n\n  return Signature;\n}();\n\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  if (!arrays.every(isUint8a)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  var length = arrays.reduce(function (a, arr) {\n    return a + arr.length;\n  }, 0);\n  var result = new Uint8Array(length);\n\n  for (var i = 0, pad = 0; i < arrays.length; i++) {\n    var arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n\n  return result;\n}\n\nfunction isUint8a(bytes) {\n  return bytes instanceof Uint8Array;\n}\n\nvar hexes = Array.from({\n  length: 256\n}, function (v, i) {\n  return i.toString(16).padStart(2, '0');\n});\n\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  var hex = '';\n\n  for (var i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n\n  return hex;\n}\n\nfunction numTo32bStr(num) {\n  if (num > POW_2_256) throw new Error('Expected number < 2^256');\n  return num.toString(16).padStart(64, '0');\n}\n\nfunction numTo32b(num) {\n  return hexToBytes(numTo32bStr(num));\n}\n\nfunction numberToHexUnpadded(num) {\n  var hex = num.toString(16);\n  return hex.length & 1 ? \"0\".concat(hex) : hex;\n}\n\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n  }\n\n  return BigInt(\"0x\".concat(hex));\n}\n\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n  var array = new Uint8Array(hex.length / 2);\n\n  for (var i = 0; i < array.length; i++) {\n    var j = i * 2;\n    var hexByte = hex.slice(j, j + 2);\n    var byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n\n  return array;\n}\n\nfunction bytesToNumber(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\n\nfunction ensureBytes(hex) {\n  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\n\nfunction normalizeScalar(num) {\n  if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0) return BigInt(num);\n  if (typeof num === 'bigint' && isWithinCurveOrder(num)) return num;\n  throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\n\nfunction mod(a) {\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  var result = a % b;\n  return result >= _0n ? result : b + result;\n}\n\nfunction pow2(x, power) {\n  var P = CURVE.P;\n  var res = x;\n\n  while (power-- > _0n) {\n    res *= res;\n    res %= P;\n  }\n\n  return res;\n}\n\nfunction sqrtMod(x) {\n  var P = CURVE.P;\n\n  var _6n = BigInt(6);\n\n  var _11n = BigInt(11);\n\n  var _22n = BigInt(22);\n\n  var _23n = BigInt(23);\n\n  var _44n = BigInt(44);\n\n  var _88n = BigInt(88);\n\n  var b2 = x * x * x % P;\n  var b3 = b2 * b2 * x % P;\n  var b6 = pow2(b3, _3n) * b3 % P;\n  var b9 = pow2(b6, _3n) * b3 % P;\n  var b11 = pow2(b9, _2n) * b2 % P;\n  var b22 = pow2(b11, _11n) * b11 % P;\n  var b44 = pow2(b22, _22n) * b22 % P;\n  var b88 = pow2(b44, _44n) * b44 % P;\n  var b176 = pow2(b88, _88n) * b88 % P;\n  var b220 = pow2(b176, _44n) * b44 % P;\n  var b223 = pow2(b220, _3n) * b3 % P;\n  var t1 = pow2(b223, _23n) * b22 % P;\n  var t2 = pow2(t1, _6n) * b2 % P;\n  return pow2(t2, _2n);\n}\n\nfunction invert(number) {\n  var modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(\"invert: expected positive integers, got n=\".concat(number, \" mod=\").concat(modulo));\n  }\n\n  var a = mod(number, modulo);\n  var b = modulo;\n  var x = _0n,\n      y = _1n,\n      u = _1n,\n      v = _0n;\n\n  while (a !== _0n) {\n    var q = b / a;\n    var r = b % a;\n    var m = x - u * q;\n    var n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n\n  var gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction invertBatch(nums) {\n  var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  var scratch = new Array(nums.length);\n  var lastMultiplied = nums.reduce(function (acc, num, i) {\n    if (num === _0n) return acc;\n    scratch[i] = acc;\n    return mod(acc * num, p);\n  }, _1n);\n  var inverted = invert(lastMultiplied, p);\n  nums.reduceRight(function (acc, num, i) {\n    if (num === _0n) return acc;\n    scratch[i] = mod(acc * scratch[i], p);\n    return mod(acc * num, p);\n  }, inverted);\n  return scratch;\n}\n\nvar divNearest = function divNearest(a, b) {\n  return (a + b / _2n) / b;\n};\n\nvar POW_2_128 = Math.pow(_2n, BigInt(128));\n\nfunction splitScalarEndo(k) {\n  var n = CURVE.n;\n  var a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n  var b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n  var a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n  var b2 = a1;\n  var c1 = divNearest(b2 * k, n);\n  var c2 = divNearest(-b1 * k, n);\n  var k1 = mod(k - c1 * a1 - c2 * a2, n);\n  var k2 = mod(-c1 * b1 - c2 * b2, n);\n  var k1neg = k1 > POW_2_128;\n  var k2neg = k2 > POW_2_128;\n  if (k1neg) k1 = n - k1;\n  if (k2neg) k2 = n - k2;\n\n  if (k1 > POW_2_128 || k2 > POW_2_128) {\n    throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n  }\n\n  return {\n    k1neg: k1neg,\n    k1: k1,\n    k2neg: k2neg,\n    k2: k2\n  };\n}\n\nfunction truncateHash(hash) {\n  var n = CURVE.n;\n  var byteLength = hash.length;\n  var delta = byteLength * 8 - 256;\n  var h = bytesToNumber(hash);\n  if (delta > 0) h = h >> BigInt(delta);\n  if (h >= n) h -= n;\n  return h;\n}\n\nvar HmacDrbg = /*#__PURE__*/function () {\n  function HmacDrbg() {\n    _classCallCheck(this, HmacDrbg);\n\n    this.v = new Uint8Array(32).fill(1);\n    this.k = new Uint8Array(32).fill(0);\n    this.counter = 0;\n  }\n\n  _createClass(HmacDrbg, [{\n    key: \"hmac\",\n    value: function hmac() {\n      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        values[_key2] = arguments[_key2];\n      }\n\n      return utils.hmacSha256.apply(utils, [this.k].concat(values));\n    }\n  }, {\n    key: \"hmacSync\",\n    value: function hmacSync() {\n      if (typeof utils.hmacSha256Sync !== 'function') throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\n\n      for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        values[_key3] = arguments[_key3];\n      }\n\n      var res = utils.hmacSha256Sync.apply(utils, [this.k].concat(values));\n      if (res instanceof Promise) throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\n      return res;\n    }\n  }, {\n    key: \"incr\",\n    value: function incr() {\n      if (this.counter >= 1000) {\n        throw new Error('Tried 1,000 k values for sign(), all were invalid');\n      }\n\n      this.counter += 1;\n    }\n  }, {\n    key: \"reseed\",\n    value: function () {\n      var _reseed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var seed,\n            _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                seed = _args.length > 0 && _args[0] !== undefined ? _args[0] : new Uint8Array();\n                _context.next = 3;\n                return this.hmac(this.v, Uint8Array.from([0x00]), seed);\n\n              case 3:\n                this.k = _context.sent;\n                _context.next = 6;\n                return this.hmac(this.v);\n\n              case 6:\n                this.v = _context.sent;\n\n                if (!(seed.length === 0)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 9:\n                _context.next = 11;\n                return this.hmac(this.v, Uint8Array.from([0x01]), seed);\n\n              case 11:\n                this.k = _context.sent;\n                _context.next = 14;\n                return this.hmac(this.v);\n\n              case 14:\n                this.v = _context.sent;\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function reseed() {\n        return _reseed.apply(this, arguments);\n      }\n\n      return reseed;\n    }()\n  }, {\n    key: \"reseedSync\",\n    value: function reseedSync() {\n      var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n      this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n      this.v = this.hmacSync(this.v);\n      if (seed.length === 0) return;\n      this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n      this.v = this.hmacSync(this.v);\n    }\n  }, {\n    key: \"generate\",\n    value: function () {\n      var _generate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.incr();\n                _context2.next = 3;\n                return this.hmac(this.v);\n\n              case 3:\n                this.v = _context2.sent;\n                return _context2.abrupt(\"return\", this.v);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function generate() {\n        return _generate.apply(this, arguments);\n      }\n\n      return generate;\n    }()\n  }, {\n    key: \"generateSync\",\n    value: function generateSync() {\n      this.incr();\n      this.v = this.hmacSync(this.v);\n      return this.v;\n    }\n  }]);\n\n  return HmacDrbg;\n}();\n\nfunction isWithinCurveOrder(num) {\n  return _0n < num && num < CURVE.n;\n}\n\nfunction isValidFieldElement(num) {\n  return _0n < num && num < CURVE.P;\n}\n\nfunction kmdToSig(kBytes, m, d) {\n  var k = bytesToNumber(kBytes);\n  if (!isWithinCurveOrder(k)) return;\n  var n = CURVE.n;\n  var q = Point.BASE.multiply(k);\n  var r = mod(q.x, n);\n  if (r === _0n) return;\n  var s = mod(invert(k, n) * mod(m + d * r, n), n);\n  if (s === _0n) return;\n  var sig = new Signature(r, s);\n  var recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n  return {\n    sig: sig,\n    recovery: recovery\n  };\n}\n\nfunction normalizePrivateKey(key) {\n  var num;\n\n  if (typeof key === 'bigint') {\n    num = key;\n  } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n    num = BigInt(key);\n  } else if (typeof key === 'string') {\n    if (key.length !== 64) throw new Error('Expected 32 bytes of private key');\n    num = hexToNumber(key);\n  } else if (isUint8a(key)) {\n    if (key.length !== 32) throw new Error('Expected 32 bytes of private key');\n    num = bytesToNumber(key);\n  } else {\n    throw new TypeError('Expected valid private key');\n  }\n\n  if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');\n  return num;\n}\n\nfunction normalizePublicKey(publicKey) {\n  if (publicKey instanceof Point) {\n    publicKey.assertValidity();\n    return publicKey;\n  } else {\n    return Point.fromHex(publicKey);\n  }\n}\n\nfunction normalizeSignature(signature) {\n  if (signature instanceof Signature) {\n    signature.assertValidity();\n    return signature;\n  }\n\n  try {\n    return Signature.fromDER(signature);\n  } catch (error) {\n    return Signature.fromCompact(signature);\n  }\n}\n\nexport function getPublicKey(privateKey) {\n  var isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery) {\n  var isCompressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\n\nfunction isPub(item) {\n  var arr = isUint8a(item);\n  var str = typeof item === 'string';\n  var len = (arr || str) && item.length;\n  if (arr) return len === 33 || len === 65;\n  if (str) return len === 66 || len === 130;\n  if (item instanceof Point) return true;\n  return false;\n}\n\nexport function getSharedSecret(privateA, publicB) {\n  var isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (isPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');\n  if (!isPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');\n  var b = normalizePublicKey(publicB);\n  b.assertValidity();\n  return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\n\nfunction bits2int(bytes) {\n  var slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;\n  return bytesToNumber(slice);\n}\n\nfunction bits2octets(bytes) {\n  var z1 = bits2int(bytes);\n  var z2 = mod(z1, CURVE.n);\n  return int2octets(z2 < _0n ? z1 : z2);\n}\n\nfunction int2octets(num) {\n  if (typeof num !== 'bigint') throw new Error('Expected bigint');\n  var hex = numTo32bStr(num);\n  return hexToBytes(hex);\n}\n\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n  if (msgHash == null) throw new Error(\"sign: expected valid message hash, not \\\"\".concat(msgHash, \"\\\"\"));\n  var h1 = ensureBytes(msgHash);\n  var d = normalizePrivateKey(privateKey);\n  var seedArgs = [int2octets(d), bits2octets(h1)];\n\n  if (extraEntropy != null) {\n    if (extraEntropy === true) extraEntropy = utils.randomBytes(32);\n    var e = ensureBytes(extraEntropy);\n    if (e.length !== 32) throw new Error('sign: Expected 32 bytes of extra data');\n    seedArgs.push(e);\n  }\n\n  var seed = concatBytes.apply(void 0, seedArgs);\n  var m = bits2int(h1);\n  return {\n    seed: seed,\n    m: m,\n    d: d\n  };\n}\n\nfunction finalizeSig(recSig, opts) {\n  var sig = recSig.sig,\n      recovery = recSig.recovery;\n\n  var _Object$assign = Object.assign({\n    canonical: true,\n    der: true\n  }, opts),\n      canonical = _Object$assign.canonical,\n      der = _Object$assign.der,\n      recovered = _Object$assign.recovered;\n\n  if (canonical && sig.hasHighS()) {\n    sig = sig.normalizeS();\n    recovery ^= 1;\n  }\n\n  var hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n  return recovered ? [hashed, recovery] : hashed;\n}\n\nfunction sign(_x, _x2) {\n  return _sign.apply(this, arguments);\n}\n\nfunction _sign() {\n  _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(msgHash, privKey) {\n    var opts,\n        _initSigArgs2,\n        seed,\n        m,\n        d,\n        sig,\n        drbg,\n        _args6 = arguments;\n\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            opts = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : {};\n            _initSigArgs2 = initSigArgs(msgHash, privKey, opts.extraEntropy), seed = _initSigArgs2.seed, m = _initSigArgs2.m, d = _initSigArgs2.d;\n            drbg = new HmacDrbg();\n            _context6.next = 5;\n            return drbg.reseed(seed);\n\n          case 5:\n            _context6.t0 = kmdToSig;\n            _context6.next = 8;\n            return drbg.generate();\n\n          case 8:\n            _context6.t1 = _context6.sent;\n            _context6.t2 = m;\n            _context6.t3 = d;\n\n            if (sig = (0, _context6.t0)(_context6.t1, _context6.t2, _context6.t3)) {\n              _context6.next = 16;\n              break;\n            }\n\n            _context6.next = 14;\n            return drbg.reseed();\n\n          case 14:\n            _context6.next = 5;\n            break;\n\n          case 16:\n            return _context6.abrupt(\"return\", finalizeSig(sig, opts));\n\n          case 17:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _sign.apply(this, arguments);\n}\n\nfunction signSync(msgHash, privKey) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _initSigArgs = initSigArgs(msgHash, privKey, opts.extraEntropy),\n      seed = _initSigArgs.seed,\n      m = _initSigArgs.m,\n      d = _initSigArgs.d;\n\n  var sig;\n  var drbg = new HmacDrbg();\n  drbg.reseedSync(seed);\n\n  while (!(sig = kmdToSig(drbg.generateSync(), m, d))) {\n    drbg.reseedSync();\n  }\n\n  return finalizeSig(sig, opts);\n}\n\nexport { sign, signSync };\nvar vopts = {\n  strict: true\n};\nexport function verify(signature, msgHash, publicKey) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : vopts;\n  var sig;\n\n  try {\n    sig = normalizeSignature(signature);\n    msgHash = ensureBytes(msgHash);\n  } catch (error) {\n    return false;\n  }\n\n  var _sig = sig,\n      r = _sig.r,\n      s = _sig.s;\n  if (opts.strict && sig.hasHighS()) return false;\n  var h = truncateHash(msgHash);\n  if (h === _0n) return false;\n  var P;\n\n  try {\n    P = normalizePublicKey(publicKey);\n  } catch (error) {\n    return false;\n  }\n\n  var n = CURVE.n;\n  var sinv = invert(s, n);\n  var u1 = mod(h * sinv, n);\n  var u2 = mod(r * sinv, n);\n  var R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n  if (!R) return false;\n  var v = mod(R.x, n);\n  return v === r;\n}\n\nfunction finalizeSchnorrChallenge(ch) {\n  return mod(bytesToNumber(ch), CURVE.n);\n}\n\nfunction hasEvenY(point) {\n  return (point.y & _1n) === _0n;\n}\n\nvar SchnorrSignature = /*#__PURE__*/function () {\n  function SchnorrSignature(r, s) {\n    _classCallCheck(this, SchnorrSignature);\n\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n\n  _createClass(SchnorrSignature, [{\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var r = this.r,\n          s = this.s;\n      if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error('Invalid signature');\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      return hexToBytes(this.toHex());\n    }\n  }], [{\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      var bytes = ensureBytes(hex);\n      if (bytes.length !== 64) throw new TypeError(\"SchnorrSignature.fromHex: expected 64 bytes, not \".concat(bytes.length));\n      var r = bytesToNumber(bytes.subarray(0, 32));\n      var s = bytesToNumber(bytes.subarray(32, 64));\n      return new SchnorrSignature(r, s);\n    }\n  }]);\n\n  return SchnorrSignature;\n}();\n\nfunction schnorrGetPublicKey(privateKey) {\n  return Point.fromPrivateKey(privateKey).toRawX();\n}\n\nfunction initSchnorrSigArgs(message, privateKey, auxRand) {\n  if (message == null) throw new TypeError(\"sign: Expected valid message, not \\\"\".concat(message, \"\\\"\"));\n  var m = ensureBytes(message);\n  var d0 = normalizePrivateKey(privateKey);\n  var rand = ensureBytes(auxRand);\n  if (rand.length !== 32) throw new TypeError('sign: Expected 32 bytes of aux randomness');\n  var P = Point.fromPrivateKey(d0);\n  var px = P.toRawX();\n  var d = hasEvenY(P) ? d0 : CURVE.n - d0;\n  return {\n    m: m,\n    P: P,\n    px: px,\n    d: d,\n    rand: rand\n  };\n}\n\nfunction initSchnorrNonce(d, t0h) {\n  return numTo32b(d ^ bytesToNumber(t0h));\n}\n\nfunction finalizeSchnorrNonce(k0h) {\n  var k0 = mod(bytesToNumber(k0h), CURVE.n);\n  if (k0 === _0n) throw new Error('sign: Creation of signature failed. k is zero');\n  var R = Point.fromPrivateKey(k0);\n  var rx = R.toRawX();\n  var k = hasEvenY(R) ? k0 : CURVE.n - k0;\n  return {\n    R: R,\n    rx: rx,\n    k: k\n  };\n}\n\nfunction finalizeSchnorrSig(R, k, e, d) {\n  return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n}\n\nfunction schnorrSign(_x3, _x4) {\n  return _schnorrSign.apply(this, arguments);\n}\n\nfunction _schnorrSign() {\n  _schnorrSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(message, privateKey) {\n    var auxRand,\n        _initSchnorrSigArgs2,\n        m,\n        px,\n        d,\n        rand,\n        t,\n        _finalizeSchnorrNonce2,\n        R,\n        rx,\n        k,\n        e,\n        sig,\n        isValid,\n        _args7 = arguments;\n\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            auxRand = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : utils.randomBytes();\n            _initSchnorrSigArgs2 = initSchnorrSigArgs(message, privateKey, auxRand), m = _initSchnorrSigArgs2.m, px = _initSchnorrSigArgs2.px, d = _initSchnorrSigArgs2.d, rand = _initSchnorrSigArgs2.rand;\n            _context7.t0 = initSchnorrNonce;\n            _context7.t1 = d;\n            _context7.next = 6;\n            return utils.taggedHash(TAGS.aux, rand);\n\n          case 6:\n            _context7.t2 = _context7.sent;\n            t = (0, _context7.t0)(_context7.t1, _context7.t2);\n            _context7.t3 = finalizeSchnorrNonce;\n            _context7.next = 11;\n            return utils.taggedHash(TAGS.nonce, t, px, m);\n\n          case 11:\n            _context7.t4 = _context7.sent;\n            _finalizeSchnorrNonce2 = (0, _context7.t3)(_context7.t4);\n            R = _finalizeSchnorrNonce2.R;\n            rx = _finalizeSchnorrNonce2.rx;\n            k = _finalizeSchnorrNonce2.k;\n            _context7.t5 = finalizeSchnorrChallenge;\n            _context7.next = 19;\n            return utils.taggedHash(TAGS.challenge, rx, px, m);\n\n          case 19:\n            _context7.t6 = _context7.sent;\n            e = (0, _context7.t5)(_context7.t6);\n            sig = finalizeSchnorrSig(R, k, e, d);\n            _context7.next = 24;\n            return schnorrVerify(sig, m, px);\n\n          case 24:\n            isValid = _context7.sent;\n\n            if (isValid) {\n              _context7.next = 27;\n              break;\n            }\n\n            throw new Error('sign: Invalid signature produced');\n\n          case 27:\n            return _context7.abrupt(\"return\", sig);\n\n          case 28:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _schnorrSign.apply(this, arguments);\n}\n\nfunction schnorrSignSync(message, privateKey) {\n  var auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : utils.randomBytes();\n\n  var _initSchnorrSigArgs = initSchnorrSigArgs(message, privateKey, auxRand),\n      m = _initSchnorrSigArgs.m,\n      px = _initSchnorrSigArgs.px,\n      d = _initSchnorrSigArgs.d,\n      rand = _initSchnorrSigArgs.rand;\n\n  var t = initSchnorrNonce(d, utils.taggedHashSync(TAGS.aux, rand));\n\n  var _finalizeSchnorrNonce = finalizeSchnorrNonce(utils.taggedHashSync(TAGS.nonce, t, px, m)),\n      R = _finalizeSchnorrNonce.R,\n      rx = _finalizeSchnorrNonce.rx,\n      k = _finalizeSchnorrNonce.k;\n\n  var e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, rx, px, m));\n  var sig = finalizeSchnorrSig(R, k, e, d);\n  var isValid = schnorrVerifySync(sig, m, px);\n  if (!isValid) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\nfunction initSchnorrVerify(signature, message, publicKey) {\n  var raw = signature instanceof SchnorrSignature;\n  var sig = raw ? signature : SchnorrSignature.fromHex(signature);\n  if (raw) sig.assertValidity();\n  return _objectSpread(_objectSpread({}, sig), {}, {\n    m: ensureBytes(message),\n    P: normalizePublicKey(publicKey)\n  });\n}\n\nfunction finalizeSchnorrVerify(r, P, s, e) {\n  var R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n  if (!R || !hasEvenY(R) || R.x !== r) return false;\n  return true;\n}\n\nfunction schnorrVerify(_x5, _x6, _x7) {\n  return _schnorrVerify.apply(this, arguments);\n}\n\nfunction _schnorrVerify() {\n  _schnorrVerify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(signature, message, publicKey) {\n    var _initSchnorrVerify2, r, s, m, P, e;\n\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.prev = 0;\n            _initSchnorrVerify2 = initSchnorrVerify(signature, message, publicKey), r = _initSchnorrVerify2.r, s = _initSchnorrVerify2.s, m = _initSchnorrVerify2.m, P = _initSchnorrVerify2.P;\n            _context8.t0 = finalizeSchnorrChallenge;\n            _context8.next = 5;\n            return utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m);\n\n          case 5:\n            _context8.t1 = _context8.sent;\n            e = (0, _context8.t0)(_context8.t1);\n            return _context8.abrupt(\"return\", finalizeSchnorrVerify(r, P, s, e));\n\n          case 10:\n            _context8.prev = 10;\n            _context8.t2 = _context8[\"catch\"](0);\n            return _context8.abrupt(\"return\", false);\n\n          case 13:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8, null, [[0, 10]]);\n  }));\n  return _schnorrVerify.apply(this, arguments);\n}\n\nfunction schnorrVerifySync(signature, message, publicKey) {\n  try {\n    var _initSchnorrVerify = initSchnorrVerify(signature, message, publicKey),\n        r = _initSchnorrVerify.r,\n        s = _initSchnorrVerify.s,\n        m = _initSchnorrVerify.m,\n        P = _initSchnorrVerify.P;\n\n    var e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n    return finalizeSchnorrVerify(r, P, s, e);\n  } catch (error) {\n    return false;\n  }\n}\n\nexport var schnorr = {\n  Signature: SchnorrSignature,\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  signSync: schnorrSignSync,\n  verifySync: schnorrVerifySync\n};\n\nPoint.BASE._setWindowSize(8);\n\nvar crypto = {\n  node: nodeCrypto,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\nvar TAGS = {\n  challenge: 'BIP0340/challenge',\n  aux: 'BIP0340/aux',\n  nonce: 'BIP0340/nonce'\n};\nvar TAGGED_HASH_PREFIXES = {};\nexport var utils = {\n  isValidPrivateKey: function isValidPrivateKey(privateKey) {\n    try {\n      normalizePrivateKey(privateKey);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  },\n  privateAdd: function privateAdd(privateKey, tweak) {\n    var p = normalizePrivateKey(privateKey);\n    var t = bytesToNumber(ensureBytes(tweak));\n    return numTo32b(mod(p + t, CURVE.n));\n  },\n  privateNegate: function privateNegate(privateKey) {\n    var p = normalizePrivateKey(privateKey);\n    return numTo32b(CURVE.n - p);\n  },\n  pointAddScalar: function pointAddScalar(p, tweak, isCompressed) {\n    var P = Point.fromHex(p);\n    var t = bytesToNumber(ensureBytes(tweak));\n    var Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);\n    if (!Q) throw new Error('Tweaked point at infinity');\n    return Q.toRawBytes(isCompressed);\n  },\n  pointMultiply: function pointMultiply(p, tweak, isCompressed) {\n    var P = Point.fromHex(p);\n    var t = bytesToNumber(ensureBytes(tweak));\n    return P.multiply(t).toRawBytes(isCompressed);\n  },\n  hashToPrivateKey: function hashToPrivateKey(hash) {\n    hash = ensureBytes(hash);\n    if (hash.length < 40 || hash.length > 1024) throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n\n    var num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n\n    return numTo32b(num);\n  },\n  randomBytes: function randomBytes() {\n    var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      var randomBytes = crypto.node.randomBytes;\n      return Uint8Array.from(randomBytes(bytesLength));\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: function randomPrivateKey() {\n    return utils.hashToPrivateKey(utils.randomBytes(40));\n  },\n  bytesToHex: bytesToHex,\n  hexToBytes: hexToBytes,\n  concatBytes: concatBytes,\n  mod: mod,\n  invert: invert,\n  sha256: function () {\n    var _sha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n      var _len4,\n          messages,\n          _key4,\n          buffer,\n          createHash,\n          hash,\n          _args3 = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              for (_len4 = _args3.length, messages = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                messages[_key4] = _args3[_key4];\n              }\n\n              if (!crypto.web) {\n                _context3.next = 8;\n                break;\n              }\n\n              _context3.next = 4;\n              return crypto.web.subtle.digest('SHA-256', concatBytes.apply(void 0, messages));\n\n            case 4:\n              buffer = _context3.sent;\n              return _context3.abrupt(\"return\", new Uint8Array(buffer));\n\n            case 8:\n              if (!crypto.node) {\n                _context3.next = 15;\n                break;\n              }\n\n              createHash = crypto.node.createHash;\n              hash = createHash('sha256');\n              messages.forEach(function (m) {\n                return hash.update(m);\n              });\n              return _context3.abrupt(\"return\", Uint8Array.from(hash.digest()));\n\n            case 15:\n              throw new Error(\"The environment doesn't have sha256 function\");\n\n            case 16:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    function sha256() {\n      return _sha.apply(this, arguments);\n    }\n\n    return sha256;\n  }(),\n  hmacSha256: function () {\n    var _hmacSha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(key) {\n      var _len5,\n          messages,\n          _key5,\n          ckey,\n          message,\n          buffer,\n          createHmac,\n          hash,\n          _args4 = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              for (_len5 = _args4.length, messages = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                messages[_key5 - 1] = _args4[_key5];\n              }\n\n              if (!crypto.web) {\n                _context4.next = 12;\n                break;\n              }\n\n              _context4.next = 4;\n              return crypto.web.subtle.importKey('raw', key, {\n                name: 'HMAC',\n                hash: {\n                  name: 'SHA-256'\n                }\n              }, false, ['sign']);\n\n            case 4:\n              ckey = _context4.sent;\n              message = concatBytes.apply(void 0, messages);\n              _context4.next = 8;\n              return crypto.web.subtle.sign('HMAC', ckey, message);\n\n            case 8:\n              buffer = _context4.sent;\n              return _context4.abrupt(\"return\", new Uint8Array(buffer));\n\n            case 12:\n              if (!crypto.node) {\n                _context4.next = 19;\n                break;\n              }\n\n              createHmac = crypto.node.createHmac;\n              hash = createHmac('sha256', key);\n              messages.forEach(function (m) {\n                return hash.update(m);\n              });\n              return _context4.abrupt(\"return\", Uint8Array.from(hash.digest()));\n\n            case 19:\n              throw new Error(\"The environment doesn't have hmac-sha256 function\");\n\n            case 20:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    function hmacSha256(_x8) {\n      return _hmacSha.apply(this, arguments);\n    }\n\n    return hmacSha256;\n  }(),\n  sha256Sync: undefined,\n  hmacSha256Sync: undefined,\n  taggedHash: function () {\n    var _taggedHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(tag) {\n      var tagP,\n          tagH,\n          _len6,\n          messages,\n          _key6,\n          _args5 = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              tagP = TAGGED_HASH_PREFIXES[tag];\n\n              if (!(tagP === undefined)) {\n                _context5.next = 7;\n                break;\n              }\n\n              _context5.next = 4;\n              return utils.sha256(Uint8Array.from(tag, function (c) {\n                return c.charCodeAt(0);\n              }));\n\n            case 4:\n              tagH = _context5.sent;\n              tagP = concatBytes(tagH, tagH);\n              TAGGED_HASH_PREFIXES[tag] = tagP;\n\n            case 7:\n              for (_len6 = _args5.length, messages = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n                messages[_key6 - 1] = _args5[_key6];\n              }\n\n              return _context5.abrupt(\"return\", utils.sha256.apply(utils, [tagP].concat(messages)));\n\n            case 9:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    function taggedHash(_x9) {\n      return _taggedHash.apply(this, arguments);\n    }\n\n    return taggedHash;\n  }(),\n  taggedHashSync: function taggedHashSync(tag) {\n    if (typeof utils.sha256Sync !== 'function') throw new Error('utils.sha256Sync is undefined, you need to set it');\n    var tagP = TAGGED_HASH_PREFIXES[tag];\n\n    if (tagP === undefined) {\n      var tagH = utils.sha256Sync(Uint8Array.from(tag, function (c) {\n        return c.charCodeAt(0);\n      }));\n      tagP = concatBytes(tagH, tagH);\n      TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n\n    for (var _len7 = arguments.length, messages = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      messages[_key7 - 1] = arguments[_key7];\n    }\n\n    return utils.sha256Sync.apply(utils, [tagP].concat(messages));\n  },\n  precompute: function precompute() {\n    var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n    var cached = point === Point.BASE ? point : new Point(point.x, point.y);\n\n    cached._setWindowSize(windowSize);\n\n    cached.multiply(_3n);\n    return cached;\n  }\n};","map":{"version":3,"names":["nodeCrypto","_0n","BigInt","_1n","_2n","_3n","_8n","POW_2_256","CURVE","a","b","P","n","h","Gx","Gy","beta","weistrass","x","x2","mod","x3","USE_ENDOMORPHISM","JacobianPoint","y","z","other","TypeError","X1","Y1","Z1","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","A","B","C","D","E","F","X3","Y3","Z3","H","r","double","ZERO","HH","HHH","V","add","negate","scalar","normalizeScalar","G","BASE","P0","p","d","splitScalarEndo","k1neg","k1","k2neg","k2","k1p","k2p","W","windows","points","base","window","push","i","affinePoint","equals","Point","_WINDOW_SIZE","Error","precomputes","pointPrecomputes","get","precomputeWindow","normalizeZ","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","pr","cached","Math","abs","point","fake","wNAF","f1p","f2p","invZ","invert","iz1","iz2","iz3","ax","ay","zz","toInv","invertBatch","map","toAffine","toAffineBatch","fromAffine","WeakMap","delete","isCompressed","hexToBytes","toHex","numTo32bStr","prefix","slice","toRawBytes","msg","isValidFieldElement","left","right","multiply","Q","aP","multiplyUnsafe","bQ","sum","undefined","bytes","isShort","length","bytesToNumber","subarray","y2","sqrtMod","isYOdd","isFirstByteOdd","assertValidity","hex","ensureBytes","len","header","fromCompressedHex","fromUncompressedHex","privateKey","normalizePrivateKey","msgHash","signature","recovery","truncateHash","normalizeSignature","s","R","fromHex","rinv","u1","u2","multiplyAndAddUnsafe","sliceDER","parseInt","parseDERInt","data","bytesToHex","res","parseDERSignature","sBytes","rBytesLeft","Signature","isWithinCurveOrder","HALF","hasHighS","toDERHex","sHex","numberToHexUnpadded","rHex","rLen","sLen","toDERRawBytes","toCompactHex","arr","isUint8a","name","str","hexToNumber","fromDER","concatBytes","arrays","every","reduce","result","Uint8Array","pad","hexes","Array","from","v","toString","padStart","uint8a","num","numTo32b","array","j","hexByte","byte","isNaN","isSafeInteger","pow2","power","_6n","_11n","_22n","_23n","_44n","_88n","b2","b3","b6","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","number","modulo","u","q","m","gcd","nums","scratch","lastMultiplied","acc","inverted","reduceRight","divNearest","POW_2_128","k","a1","b1","a2","c1","c2","hash","byteLength","delta","HmacDrbg","fill","counter","values","utils","hmacSha256","hmacSha256Sync","Promise","seed","hmac","hmacSync","incr","kmdToSig","kBytes","sig","key","normalizePublicKey","publicKey","error","fromCompact","getPublicKey","fromPrivateKey","recoverPublicKey","fromSignature","isPub","item","getSharedSecret","privateA","publicB","bits2int","bits2octets","z1","z2","int2octets","initSigArgs","extraEntropy","h1","seedArgs","randomBytes","e","finalizeSig","recSig","opts","Object","assign","canonical","der","recovered","normalizeS","hashed","toCompactRawBytes","sign","privKey","drbg","reseed","generate","signSync","reseedSync","generateSync","vopts","strict","verify","sinv","finalizeSchnorrChallenge","ch","hasEvenY","SchnorrSignature","schnorrGetPublicKey","toRawX","initSchnorrSigArgs","message","auxRand","d0","rand","px","initSchnorrNonce","t0h","finalizeSchnorrNonce","k0h","k0","rx","finalizeSchnorrSig","schnorrSign","taggedHash","TAGS","aux","t","nonce","challenge","schnorrVerify","isValid","schnorrSignSync","taggedHashSync","schnorrVerifySync","initSchnorrVerify","raw","finalizeSchnorrVerify","schnorr","verifySync","_setWindowSize","crypto","node","web","self","TAGGED_HASH_PREFIXES","isValidPrivateKey","privateAdd","tweak","privateNegate","pointAddScalar","pointMultiply","hashToPrivateKey","bytesLength","getRandomValues","randomPrivateKey","sha256","messages","subtle","digest","buffer","createHash","forEach","update","importKey","ckey","createHmac","sha256Sync","tag","tagP","c","charCodeAt","tagH","precompute"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/@noble/secp256k1/lib/esm/index.js"],"sourcesContent":["/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst POW_2_256 = _2n ** BigInt(256);\nconst CURVE = {\n    a: _0n,\n    b: BigInt(7),\n    P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),\n    n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n};\nexport { CURVE };\nfunction weistrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 ** _2n);\n        const Z2Z2 = mod(Z2 ** _2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 ** _2n);\n        const B = mod(Y1 ** _2n);\n        const C = mod(B ** _2n);\n        const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E ** _2n);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 ** _2n);\n        const Z2Z2 = mod(Z2 ** _2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H ** _2n);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r ** _2n - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar);\n        const G = JacobianPoint.BASE;\n        const P0 = JacobianPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.ZERO;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weistrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, 33));\n        const y = bytesToNumber(bytes.subarray(33, 65));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === 65 && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        msgHash = ensureBytes(msgHash);\n        const h = truncateHash(msgHash);\n        const { r, s } = normalizeSignature(signature);\n        if (recovery !== 0 && recovery !== 1) {\n            throw new Error('Cannot recover signature: invalid recovery bit');\n        }\n        if (h === _0n)\n            throw new Error('Cannot recover signature: msgHash cannot be 0');\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(r));\n        const { n } = CURVE;\n        const rinv = invert(r, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.y & _1n ? '03' : '02';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weistrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nexport class Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = isUint8a(hex);\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = isUint8a(hex);\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;\n    }\n    toDERRawBytes(isCompressed = false) {\n        return hexToBytes(this.toDERHex(isCompressed));\n    }\n    toDERHex(isCompressed = false) {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        if (isCompressed)\n            return sHex;\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const rLen = numberToHexUnpadded(rHex.length / 2);\n        const sLen = numberToHexUnpadded(sHex.length / 2);\n        const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every(isUint8a))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction isUint8a(bytes) {\n    return bytes instanceof Uint8Array;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction numTo32bStr(num) {\n    if (num > POW_2_256)\n        throw new Error('Expected number < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    return hexToBytes(numTo32bStr(num));\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    return pow2(t2, _2n);\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst POW_2_128 = _2n ** BigInt(128);\nfunction splitScalarEndo(k) {\n    const { n } = CURVE;\n    const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n    const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n    const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n    const b2 = a1;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\n    const k1neg = k1 > POW_2_128;\n    const k2neg = k2 > POW_2_128;\n    if (k1neg)\n        k1 = n - k1;\n    if (k2neg)\n        k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\n        throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction truncateHash(hash) {\n    const { n } = CURVE;\n    const byteLength = hash.length;\n    const delta = byteLength * 8 - 256;\n    let h = bytesToNumber(hash);\n    if (delta > 0)\n        h = h >> BigInt(delta);\n    if (h >= n)\n        h -= n;\n    return h;\n}\nclass HmacDrbg {\n    constructor() {\n        this.v = new Uint8Array(32).fill(1);\n        this.k = new Uint8Array(32).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        if (typeof utils.hmacSha256Sync !== 'function')\n            throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\n        const res = utils.hmacSha256Sync(this.k, ...values);\n        if (res instanceof Promise)\n            throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\n        return res;\n    }\n    incr() {\n        if (this.counter >= 1000) {\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        }\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        this.v = await this.hmac(this.v);\n        return this.v;\n    }\n    generateSync() {\n        this.incr();\n        this.v = this.hmacSync(this.v);\n        return this.v;\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d) {\n    const k = bytesToNumber(kBytes);\n    if (!isWithinCurveOrder(k))\n        return;\n    const { n } = CURVE;\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(invert(k, n) * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    const sig = new Signature(r, s);\n    const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 64)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (isUint8a(key)) {\n        if (key.length !== 32)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nexport function getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isPub(item) {\n    const arr = isUint8a(item);\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === 33 || len === 65;\n    if (str)\n        return len === 66 || len === 130;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    const hex = numTo32bStr(num);\n    return hexToBytes(hex);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(32);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== 32)\n            throw new Error('sign: Expected 32 bytes of extra data');\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    let { sig, recovery } = recSig;\n    const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    if (canonical && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    await drbg.reseed(seed);\n    while (!(sig = kmdToSig(await drbg.generate(), m, d)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    drbg.reseedSync(seed);\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = { strict: true };\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    if (h === _0n)\n        return false;\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction finalizeSchnorrChallenge(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nfunction hasEvenY(point) {\n    return (point.y & _1n) === _0n;\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nfunction initSchnorrSigArgs(message, privateKey, auxRand) {\n    if (message == null)\n        throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n    const m = ensureBytes(message);\n    const d0 = normalizePrivateKey(privateKey);\n    const rand = ensureBytes(auxRand);\n    if (rand.length !== 32)\n        throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    const P = Point.fromPrivateKey(d0);\n    const px = P.toRawX();\n    const d = hasEvenY(P) ? d0 : CURVE.n - d0;\n    return { m, P, px, d, rand };\n}\nfunction initSchnorrNonce(d, t0h) {\n    return numTo32b(d ^ bytesToNumber(t0h));\n}\nfunction finalizeSchnorrNonce(k0h) {\n    const k0 = mod(bytesToNumber(k0h), CURVE.n);\n    if (k0 === _0n)\n        throw new Error('sign: Creation of signature failed. k is zero');\n    const R = Point.fromPrivateKey(k0);\n    const rx = R.toRawX();\n    const k = hasEvenY(R) ? k0 : CURVE.n - k0;\n    return { R, rx, k };\n}\nfunction finalizeSchnorrSig(R, k, e, d) {\n    return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n}\nasync function schnorrSign(message, privateKey, auxRand = utils.randomBytes()) {\n    const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);\n    const t = initSchnorrNonce(d, await utils.taggedHash(TAGS.aux, rand));\n    const { R, rx, k } = finalizeSchnorrNonce(await utils.taggedHash(TAGS.nonce, t, px, m));\n    const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, rx, px, m));\n    const sig = finalizeSchnorrSig(R, k, e, d);\n    const isValid = await schnorrVerify(sig, m, px);\n    if (!isValid)\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\nfunction schnorrSignSync(message, privateKey, auxRand = utils.randomBytes()) {\n    const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);\n    const t = initSchnorrNonce(d, utils.taggedHashSync(TAGS.aux, rand));\n    const { R, rx, k } = finalizeSchnorrNonce(utils.taggedHashSync(TAGS.nonce, t, px, m));\n    const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, rx, px, m));\n    const sig = finalizeSchnorrSig(R, k, e, d);\n    const isValid = schnorrVerifySync(sig, m, px);\n    if (!isValid)\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !hasEvenY(R) || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nexport const schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    privateAdd: (privateKey, tweak) => {\n        const p = normalizePrivateKey(privateKey);\n        const t = bytesToNumber(ensureBytes(tweak));\n        return numTo32b(mod(p + t, CURVE.n));\n    },\n    privateNegate: (privateKey) => {\n        const p = normalizePrivateKey(privateKey);\n        return numTo32b(CURVE.n - p);\n    },\n    pointAddScalar: (p, tweak, isCompressed) => {\n        const P = Point.fromHex(p);\n        const t = bytesToNumber(ensureBytes(tweak));\n        const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);\n        if (!Q)\n            throw new Error('Tweaked point at infinity');\n        return Q.toRawBytes(isCompressed);\n    },\n    pointMultiply: (p, tweak, isCompressed) => {\n        const P = Point.fromHex(p);\n        const t = bytesToNumber(ensureBytes(tweak));\n        return P.multiply(t).toRawBytes(isCompressed);\n    },\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.hashToPrivateKey(utils.randomBytes(40));\n    },\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof utils.sha256Sync !== 'function')\n            throw new Error('utils.sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = utils.sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256Sync(tagP, ...messages);\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}