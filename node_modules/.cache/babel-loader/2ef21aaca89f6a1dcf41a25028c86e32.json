{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _assertThisInitialized = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _get = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/get.js\").default;\n\nvar _getPrototypeOf = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar pubsub_1 = __importStar(require(\"libp2p-interfaces/src/pubsub\"));\n\nvar message_cache_1 = require(\"./message-cache\");\n\nvar rpc_1 = require(\"./message/rpc\");\n\nvar constants = __importStar(require(\"./constants\"));\n\nvar heartbeat_1 = require(\"./heartbeat\");\n\nvar get_gossip_peers_1 = require(\"./get-gossip-peers\");\n\nvar utils_1 = require(\"./utils\");\n\nvar score_1 = require(\"./score\");\n\nvar tracer_1 = require(\"./tracer\"); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\n\nvar TimeCache = require(\"time-cache\");\n\nvar PeerId = require(\"peer-id\"); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\n\nvar Envelope = require(\"libp2p/src/record/envelope\");\n\nvar Gossipsub = /*#__PURE__*/function (_pubsub_1$default) {\n  _inherits(Gossipsub, _pubsub_1$default);\n\n  var _super2 = _createSuper(Gossipsub);\n\n  // TODO: add remaining props\n\n  /**\n   * @param {Libp2p} libp2p\n   * @param {Object} [options]\n   * @param {boolean} [options.emitSelf = false] if publish should emit to self, if subscribed\n   * @param {boolean} [options.canRelayMessage = false] - if can relay messages not subscribed\n   * @param {boolean} [options.gossipIncoming = true] if incoming messages on a subscribed topic should be automatically gossiped\n   * @param {boolean} [options.fallbackToFloodsub = true] if dial should fallback to floodsub\n   * @param {boolean} [options.floodPublish = true] if self-published messages should be sent to all peers\n   * @param {boolean} [options.doPX = false] whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes.\n   * @param {Object} [options.messageCache] override the default MessageCache\n   * @param {string} [options.globalSignaturePolicy = \"StrictSign\"] signing policy to apply across all messages\n   * @param {Object} [options.scoreParams] peer score parameters\n   * @param {Object} [options.scoreThresholds] peer score thresholds\n   * @param {AddrInfo[]} [options.directPeers] peers with which we will maintain direct connections\n   * @constructor\n   */\n  function Gossipsub(libp2p) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Gossipsub);\n\n    var multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];\n    var opts = Object.assign(Object.assign({\n      gossipIncoming: true,\n      fallbackToFloodsub: true,\n      floodPublish: true,\n      doPX: false,\n      directPeers: [],\n      D: constants.GossipsubD,\n      Dlo: constants.GossipsubDlo,\n      Dhi: constants.GossipsubDhi,\n      Dscore: constants.GossipsubDscore,\n      Dout: constants.GossipsubDout,\n      Dlazy: constants.GossipsubDlazy,\n      heartbeatInterval: constants.GossipsubHeartbeatInterval,\n      fanoutTTL: constants.GossipsubFanoutTTL,\n      mcacheLength: constants.GossipsubHistoryLength,\n      mcacheGossip: constants.GossipsubHistoryGossip,\n      seenTTL: constants.GossipsubSeenTTL\n    }, options), {\n      scoreParams: score_1.createPeerScoreParams(options.scoreParams),\n      scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds)\n    }); // Also wants to get notified of peers connected using floodsub\n\n    if (opts.fallbackToFloodsub) {\n      multicodecs.push(constants.FloodsubID);\n    }\n\n    _this = _super2.call(this, Object.assign({\n      debugName: 'libp2p:gossipsub',\n      multicodecs: multicodecs,\n      libp2p: libp2p\n    }, opts));\n    _this._options = opts;\n    /**\n     * Direct peers\n     * @type {Set<string>}\n     */\n\n    _this.direct = new Set(opts.directPeers.map(function (p) {\n      return p.id.toB58String();\n    })); // set direct peer addresses in the address book\n\n    opts.directPeers.forEach(function (p) {\n      libp2p.peerStore.addressBook.add(p.id, p.addrs);\n    });\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n\n    _this.seenCache = new TimeCache({\n      validity: opts.seenTTL / 1000\n    });\n    /**\n     * Map of topic meshes\n     * topic => peer id set\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    _this.mesh = new Map();\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     * topic => peer id set\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    _this.fanout = new Map();\n    /**\n     * Map of last publish time for fanout topics\n     * topic => last publish time\n     *\n     * @type {Map<string, number>}\n     */\n\n    _this.lastpub = new Map();\n    /**\n     * Map of pending messages to gossip\n     * peer id => control messages\n     *\n     * @type {Map<string, Array<RPC.IControlIHave object>> }\n     */\n\n    _this.gossip = new Map();\n    /**\n     * Map of control messages\n     * peer id => control message\n     *\n     * @type {Map<string, RPC.IControlMessage object>}\n     */\n\n    _this.control = new Map();\n    /**\n     * Number of IHAVEs received from peer in the last heartbeat\n     * @type {Map<string, number>}\n     */\n\n    _this.peerhave = new Map();\n    /**\n     * Number of messages we have asked from peer in the last heartbeat\n     * @type {Map<string, number>}\n     */\n\n    _this.iasked = new Map();\n    /**\n     * Prune backoff map\n     */\n\n    _this.backoff = new Map();\n    /**\n     * Connection direction cache, marks peers with outbound connections\n     * peer id => direction\n     *\n     * @type {Map<string, boolean>}\n     */\n\n    _this.outbound = new Map();\n    /**\n     * A message cache that contains the messages for last few hearbeat ticks\n     *\n     */\n\n    _this.messageCache = options.messageCache || new message_cache_1.MessageCache(opts.mcacheGossip, opts.mcacheLength, _this.getMsgId.bind(_assertThisInitialized(_this)));\n    /**\n     * A heartbeat timer that maintains the mesh\n     */\n\n    _this.heartbeat = new heartbeat_1.Heartbeat(_assertThisInitialized(_this));\n    /**\n     * Number of heartbeats since the beginning of time\n     * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n     */\n\n    _this.heartbeatTicks = 0;\n    /**\n     * Tracks IHAVE/IWANT promises broken by peers\n     */\n\n    _this.gossipTracer = new tracer_1.IWantTracer(_this.getMsgId.bind(_assertThisInitialized(_this)));\n    /**\n     * libp2p\n     */\n\n    _this._libp2p = libp2p;\n    /**\n     * Peer score tracking\n     */\n\n    _this.score = new score_1.PeerScore(_this._options.scoreParams, libp2p.connectionManager, _this.getMsgId.bind(_assertThisInitialized(_this)));\n    return _this;\n  }\n  /**\n   * Decode a Uint8Array into an RPC object\n   * Overrided to use an extended protocol-specific protobuf decoder\n   * @override\n   * @param {Uint8Array} bytes\n   * @returns {RPC}\n   */\n\n\n  _createClass(Gossipsub, [{\n    key: \"_decodeRpc\",\n    value: function _decodeRpc(bytes) {\n      return rpc_1.RPC.decode(bytes);\n    }\n    /**\n     * Encode an RPC object into a Uint8Array\n     * Overrided to use an extended protocol-specific protobuf encoder\n     * @override\n     * @param {RPC} rpc\n     * @returns {Uint8Array}\n     */\n\n  }, {\n    key: \"_encodeRpc\",\n    value: function _encodeRpc(rpc) {\n      return rpc_1.RPC.encode(rpc).finish();\n    }\n    /**\n     * Add a peer to the router\n     * @override\n     * @param {PeerId} peerId\n     * @param {string} protocol\n     * @returns {PeerStreams}\n     */\n\n  }, {\n    key: \"_addPeer\",\n    value: function _addPeer(peerId, protocol) {\n      var p = _get(_getPrototypeOf(Gossipsub.prototype), \"_addPeer\", this).call(this, peerId, protocol); // Add to peer scoring\n\n\n      this.score.addPeer(peerId.toB58String()); // track the connection direction\n\n      var outbound = false;\n\n      var _iterator = _createForOfIteratorHelper(this._libp2p.connectionManager.getAll(peerId)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var c = _step.value;\n\n          if (c.stat.direction === 'outbound') {\n            if (Array.from(c.registry.values()).some(function (rvalue) {\n              return protocol === rvalue.protocol;\n            })) {\n              outbound = true;\n              break;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.outbound.set(p.id.toB58String(), outbound);\n      return p;\n    }\n    /**\n     * Removes a peer from the router\n     * @override\n     * @param {PeerId} peer\n     * @returns {PeerStreams | undefined}\n     */\n\n  }, {\n    key: \"_removePeer\",\n    value: function _removePeer(peerId) {\n      var peerStreams = _get(_getPrototypeOf(Gossipsub.prototype), \"_removePeer\", this).call(this, peerId);\n\n      var id = peerId.toB58String(); // Remove this peer from the mesh\n      // eslint-disable-next-line no-unused-vars\n\n      var _iterator2 = _createForOfIteratorHelper(this.mesh.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var peers = _step2.value;\n          peers.delete(id);\n        } // Remove this peer from the fanout\n        // eslint-disable-next-line no-unused-vars\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(this.fanout.values()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _peers = _step3.value;\n\n          _peers.delete(id);\n        } // Remove from gossip mapping\n\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      this.gossip.delete(id); // Remove from control mapping\n\n      this.control.delete(id); // Remove from backoff mapping\n\n      this.outbound.delete(id); // Remove from peer scoring\n\n      this.score.removePeer(id);\n      return peerStreams;\n    }\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @override\n     * @param {String} idB58Str\n     * @param {PeerStreams} peerStreams\n     * @param {RPC} rpc\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: \"_processRpc\",\n    value: function _processRpc(id, peerStreams, rpc) {\n      var _this2 = this;\n\n      var _super = Object.create(null, {\n        _processRpc: {\n          get: function get() {\n            return _get(_getPrototypeOf(Gossipsub.prototype), \"_processRpc\", _this2);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _super._processRpc.call(this, id, peerStreams, rpc);\n\n              case 2:\n                if (!_context.sent) {\n                  _context.next = 5;\n                  break;\n                }\n\n                if (rpc.control) {\n                  this._processRpcControlMessage(id, rpc.control);\n                }\n\n                return _context.abrupt(\"return\", true);\n\n              case 5:\n                return _context.abrupt(\"return\", false);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Handles an rpc control message from a peer\n     * @param {string} id peer id\n     * @param {RPC.IControlMessage} controlMsg\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_processRpcControlMessage\",\n    value: function _processRpcControlMessage(id, controlMsg) {\n      if (!controlMsg) {\n        return;\n      }\n\n      var iwant = controlMsg.ihave ? this._handleIHave(id, controlMsg.ihave) : [];\n      var ihave = controlMsg.iwant ? this._handleIWant(id, controlMsg.iwant) : [];\n      var prune = controlMsg.graft ? this._handleGraft(id, controlMsg.graft) : [];\n      controlMsg.prune && this._handlePrune(id, controlMsg.prune);\n\n      if (!iwant.length && !ihave.length && !prune.length) {\n        return;\n      }\n\n      var outRpc = utils_1.createGossipRpc(ihave, {\n        iwant: iwant,\n        prune: prune\n      });\n\n      this._sendRpc(id, outRpc);\n    }\n    /**\n     * Process incoming message,\n     * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n     * @override\n     * @param {InMessage} msg\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_processRpcMessage\",\n    value: function _processRpcMessage(msg) {\n      var _this3 = this;\n\n      var _super = Object.create(null, {\n        _processRpcMessage: {\n          get: function get() {\n            return _get(_getPrototypeOf(Gossipsub.prototype), \"_processRpcMessage\", _this3);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var msgID, msgIdStr;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.getMsgId(msg);\n\n              case 2:\n                msgID = _context2.sent;\n                msgIdStr = utils_1.messageIdToString(msgID); // Ignore if we've already seen the message\n\n                if (!this.seenCache.has(msgIdStr)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                this.score.duplicateMessage(msg);\n                return _context2.abrupt(\"return\");\n\n              case 7:\n                this.seenCache.put(msgIdStr);\n                _context2.next = 10;\n                return this.score.validateMessage(msg);\n\n              case 10:\n                _context2.next = 12;\n                return _super._processRpcMessage.call(this, msg);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Whether to accept a message from a peer\n     * @override\n     * @param {string} id\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"_acceptFrom\",\n    value: function _acceptFrom(id) {\n      return this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.graylistThreshold;\n    }\n    /**\n     * Validate incoming message\n     * @override\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate(message) {\n      var _this4 = this;\n\n      var _super = Object.create(null, {\n        validate: {\n          get: function get() {\n            return _get(_getPrototypeOf(Gossipsub.prototype), \"validate\", _this4);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return _super.validate.call(this, message);\n\n              case 3:\n                _context3.next = 10;\n                break;\n\n              case 5:\n                _context3.prev = 5;\n                _context3.t0 = _context3[\"catch\"](0);\n                this.score.rejectMessage(message, _context3.t0.code);\n                this.gossipTracer.rejectMessage(message, _context3.t0.code);\n                throw _context3.t0;\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 5]]);\n      }));\n    }\n    /**\n     * Handles IHAVE messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlIHave>} ihave\n     * @returns {RPC.IControlIWant}\n     */\n\n  }, {\n    key: \"_handleIHave\",\n    value: function _handleIHave(id, ihave) {\n      var _this5 = this;\n\n      if (!ihave.length) {\n        return [];\n      } // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n\n\n      var score = this.score.score(id);\n\n      if (score < this._options.scoreThresholds.gossipThreshold) {\n        this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score);\n        return [];\n      } // IHAVE flood protection\n\n\n      var peerhave = (this.peerhave.get(id) || 0) + 1;\n      this.peerhave.set(id, peerhave);\n\n      if (peerhave > constants.GossipsubMaxIHaveMessages) {\n        this.log('IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring', id, peerhave);\n        return [];\n      }\n\n      var iasked = this.iasked.get(id) || 0;\n\n      if (iasked >= constants.GossipsubMaxIHaveLength) {\n        this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked);\n        return [];\n      } // string msgId => msgId\n\n\n      var iwant = new Map();\n      ihave.forEach(function (_ref) {\n        var topicID = _ref.topicID,\n            messageIDs = _ref.messageIDs;\n\n        if (!topicID || !messageIDs || !_this5.mesh.has(topicID)) {\n          return;\n        }\n\n        messageIDs.forEach(function (msgID) {\n          var msgIdStr = utils_1.messageIdToString(msgID);\n\n          if (_this5.seenCache.has(msgIdStr)) {\n            return;\n          }\n\n          iwant.set(msgIdStr, msgID);\n        });\n      });\n\n      if (!iwant.size) {\n        return [];\n      }\n\n      var iask = iwant.size;\n\n      if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n        iask = constants.GossipsubMaxIHaveLength - iasked;\n      }\n\n      this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id);\n      var iwantList = Array.from(iwant.values()); // ask in random order\n\n      utils_1.shuffle(iwantList); // truncate to the messages we are actually asking for and update the iasked counter\n\n      iwantList = iwantList.slice(0, iask);\n      this.iasked.set(id, iasked + iask);\n      this.gossipTracer.addPromise(id, iwantList);\n      return [{\n        messageIDs: iwantList\n      }];\n    }\n    /**\n     * Handles IWANT messages\n     * Returns messages to send back to peer\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlIWant>} iwant\n     * @returns {Array<RPC.IMessage>}\n     */\n\n  }, {\n    key: \"_handleIWant\",\n    value: function _handleIWant(id, iwant) {\n      var _this6 = this;\n\n      if (!iwant.length) {\n        return [];\n      } // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n\n\n      var score = this.score.score(id);\n\n      if (score < this._options.scoreThresholds.gossipThreshold) {\n        this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score);\n        return [];\n      } // @type {Map<string, Message>}\n\n\n      var ihave = new Map();\n      iwant.forEach(function (_ref2) {\n        var messageIDs = _ref2.messageIDs;\n        messageIDs && messageIDs.forEach(function (msgID) {\n          var _this6$messageCache$g = _this6.messageCache.getForPeer(msgID, id),\n              _this6$messageCache$g2 = _slicedToArray(_this6$messageCache$g, 2),\n              msg = _this6$messageCache$g2[0],\n              count = _this6$messageCache$g2[1];\n\n          if (!msg) {\n            return;\n          }\n\n          if (count > constants.GossipsubGossipRetransmission) {\n            _this6.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgID);\n\n            return;\n          }\n\n          ihave.set(utils_1.messageIdToString(msgID), msg);\n        });\n      });\n\n      if (!ihave.size) {\n        return [];\n      }\n\n      this.log('IWANT: Sending %d messages to %s', ihave.size, id);\n      return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);\n    }\n    /**\n     * Handles Graft messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlGraft>} graft\n     * @return {Array<RPC.IControlPrune>}\n     */\n\n  }, {\n    key: \"_handleGraft\",\n    value: function _handleGraft(id, graft) {\n      var _this7 = this;\n\n      var prune = [];\n      var score = this.score.score(id);\n\n      var now = this._now();\n\n      var doPX = this._options.doPX;\n      graft.forEach(function (_ref3) {\n        var topicID = _ref3.topicID;\n\n        var _a;\n\n        if (!topicID) {\n          return;\n        }\n\n        var peersInMesh = _this7.mesh.get(topicID);\n\n        if (!peersInMesh) {\n          // don't do PX when there is an unknown topic to avoid leaking our peers\n          doPX = false; // spam hardening: ignore GRAFTs for unknown topics\n\n          return;\n        } // check if peer is already in the mesh; if so do nothing\n\n\n        if (peersInMesh.has(id)) {\n          return;\n        } // we don't GRAFT to/from direct peers; complain loudly if this happens\n\n\n        if (_this7.direct.has(id)) {\n          _this7.log('GRAFT: ignoring request from direct peer %s', id); // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n\n\n          prune.push(topicID); // but don't px\n\n          doPX = false;\n          return;\n        } // make sure we are not backing off that peer\n\n\n        var expire = (_a = _this7.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);\n\n        if (typeof expire === 'number' && now < expire) {\n          _this7.log('GRAFT: ignoring backed off peer %s', id); // add behavioral penalty\n\n\n          _this7.score.addPenalty(id, 1); // no PX\n\n\n          doPX = false; // check the flood cutoff -- is the GRAFT coming too fast?\n\n          var floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;\n\n          if (now < floodCutoff) {\n            // extra penalty\n            _this7.score.addPenalty(id, 1);\n          } // refresh the backoff\n\n\n          _this7._addBackoff(id, topicID);\n\n          prune.push(topicID);\n          return;\n        } // check the score\n\n\n        if (score < 0) {\n          // we don't GRAFT peers with negative score\n          _this7.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID); // we do send them PRUNE however, because it's a matter of protocol correctness\n\n\n          prune.push(topicID); // but we won't PX to them\n\n          doPX = false; // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n\n          _this7._addBackoff(id, topicID);\n\n          return;\n        } // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n        // from peers with outbound connections; this is a defensive check to restrict potential\n        // mesh takeover attacks combined with love bombing\n\n\n        if (peersInMesh.size >= _this7._options.Dhi && !_this7.outbound.get(id)) {\n          prune.push(topicID);\n\n          _this7._addBackoff(id, topicID);\n\n          return;\n        }\n\n        _this7.log('GRAFT: Add mesh link from %s in %s', id, topicID);\n\n        _this7.score.graft(id, topicID);\n\n        peersInMesh.add(id);\n      });\n\n      if (!prune.length) {\n        return [];\n      }\n\n      return prune.map(function (topic) {\n        return _this7._makePrune(id, topic, doPX);\n      });\n    }\n    /**\n     * Handles Prune messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlPrune>} prune\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_handlePrune\",\n    value: function _handlePrune(id, prune) {\n      var _this8 = this;\n\n      var score = this.score.score(id);\n      prune.forEach(function (_ref4) {\n        var topicID = _ref4.topicID,\n            backoff = _ref4.backoff,\n            peers = _ref4.peers;\n\n        if (!topicID) {\n          return;\n        }\n\n        var peersInMesh = _this8.mesh.get(topicID);\n\n        if (!peersInMesh) {\n          return;\n        }\n\n        _this8.log('PRUNE: Remove mesh link to %s in %s', id, topicID);\n\n        _this8.score.prune(id, topicID);\n\n        peersInMesh.delete(id); // is there a backoff specified by the peer? if so obey it\n\n        if (typeof backoff === 'number' && backoff > 0) {\n          _this8._doAddBackoff(id, topicID, backoff * 1000);\n        } else {\n          _this8._addBackoff(id, topicID);\n        } // PX\n\n\n        if (peers && peers.length) {\n          // we ignore PX from peers with insufficient scores\n          if (score < _this8._options.scoreThresholds.acceptPXThreshold) {\n            _this8.log('PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]', id, score, topicID);\n\n            return;\n          }\n\n          _this8._pxConnect(peers);\n        }\n      });\n    }\n    /**\n     * Add standard backoff log for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_addBackoff\",\n    value: function _addBackoff(id, topic) {\n      this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);\n    }\n    /**\n     * Add backoff expiry interval for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @param {number} interval backoff duration in milliseconds\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_doAddBackoff\",\n    value: function _doAddBackoff(id, topic, interval) {\n      var backoff = this.backoff.get(topic);\n\n      if (!backoff) {\n        backoff = new Map();\n        this.backoff.set(topic, backoff);\n      }\n\n      var expire = this._now() + interval;\n      var existingExpire = backoff.get(id) || 0;\n\n      if (existingExpire < expire) {\n        backoff.set(id, expire);\n      }\n    }\n    /**\n     * Apply penalties from broken IHAVE/IWANT promises\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_applyIwantPenalties\",\n    value: function _applyIwantPenalties() {\n      var _this9 = this;\n\n      this.gossipTracer.getBrokenPromises().forEach(function (count, p) {\n        _this9.log('peer %s didn\\'t follow up in %d IWANT requests; adding penalty', p, count);\n\n        _this9.score.addPenalty(p, count);\n      });\n    }\n    /**\n     * Clear expired backoff expiries\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_clearBackoff\",\n    value: function _clearBackoff() {\n      var _this10 = this;\n\n      // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n      if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n        return;\n      }\n\n      var now = this._now();\n\n      this.backoff.forEach(function (backoff, topic) {\n        backoff.forEach(function (expire, id) {\n          if (expire < now) {\n            backoff.delete(id);\n          }\n        });\n\n        if (backoff.size === 0) {\n          _this10.backoff.delete(topic);\n        }\n      });\n    }\n    /**\n     * Maybe reconnect to direct peers\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_directConnect\",\n    value: function _directConnect() {\n      var _this11 = this;\n\n      // we only do this every few ticks to allow pending connections to complete and account for\n      // restarts/downtime\n      if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {\n        return;\n      }\n\n      var toconnect = [];\n      this.direct.forEach(function (id) {\n        var peer = _this11.peers.get(id);\n\n        if (!peer || !peer.isWritable) {\n          toconnect.push(id);\n        }\n      });\n\n      if (toconnect.length) {\n        toconnect.forEach(function (id) {\n          _this11._connect(id);\n        });\n      }\n    }\n    /**\n     * Maybe attempt connection given signed peer records\n     * @param {RPC.IPeerInfo[]} peers\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_pxConnect\",\n    value: function _pxConnect(peers) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _this12 = this;\n\n        var toconnect;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (peers.length > constants.GossipsubPrunePeers) {\n                  utils_1.shuffle(peers);\n                  peers = peers.slice(0, constants.GossipsubPrunePeers);\n                }\n\n                toconnect = [];\n                _context5.next = 4;\n                return Promise.all(peers.map(function (pi) {\n                  return __awaiter(_this12, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                    var p, id, envelope, eid;\n                    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            if (pi.peerID) {\n                              _context4.next = 2;\n                              break;\n                            }\n\n                            return _context4.abrupt(\"return\");\n\n                          case 2:\n                            p = PeerId.createFromBytes(pi.peerID);\n                            id = p.toB58String();\n\n                            if (!this.peers.has(id)) {\n                              _context4.next = 6;\n                              break;\n                            }\n\n                            return _context4.abrupt(\"return\");\n\n                          case 6:\n                            if (pi.signedPeerRecord) {\n                              _context4.next = 9;\n                              break;\n                            }\n\n                            toconnect.push(id);\n                            return _context4.abrupt(\"return\");\n\n                          case 9:\n                            _context4.prev = 9;\n                            _context4.next = 12;\n                            return Envelope.openAndCertify(pi.signedPeerRecord, 'libp2p-peer-record');\n\n                          case 12:\n                            envelope = _context4.sent;\n                            eid = envelope.peerId.toB58String();\n\n                            if (!(id !== eid)) {\n                              _context4.next = 17;\n                              break;\n                            }\n\n                            this.log('bogus peer record obtained through px: peer ID %s doesn\\'t match expected peer %s', eid, id);\n                            return _context4.abrupt(\"return\");\n\n                          case 17:\n                            if (this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {\n                              _context4.next = 20;\n                              break;\n                            }\n\n                            this.log('bogus peer record obtained through px: could not add peer record to address book');\n                            return _context4.abrupt(\"return\");\n\n                          case 20:\n                            toconnect.push(id);\n                            _context4.next = 26;\n                            break;\n\n                          case 23:\n                            _context4.prev = 23;\n                            _context4.t0 = _context4[\"catch\"](9);\n                            this.log('bogus peer record obtained through px: invalid signature or not a peer record');\n\n                          case 26:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4, this, [[9, 23]]);\n                  }));\n                }));\n\n              case 4:\n                if (toconnect.length) {\n                  _context5.next = 6;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 6:\n                toconnect.forEach(function (id) {\n                  return _this12._connect(id);\n                });\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n    }\n    /**\n     * Mounts the gossipsub protocol onto the libp2p node and sends our\n     * our subscriptions to every peer connected\n     * @override\n     * @returns {void}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this13 = this;\n\n      _get(_getPrototypeOf(Gossipsub.prototype), \"start\", this).call(this);\n\n      this.heartbeat.start();\n      this.score.start(); // connect to direct peers\n\n      this._directPeerInitial = setTimeout(function () {\n        _this13.direct.forEach(function (id) {\n          _this13._connect(id);\n        });\n      }, constants.GossipsubDirectConnectInitialDelay);\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      _get(_getPrototypeOf(Gossipsub.prototype), \"stop\", this).call(this);\n\n      this.heartbeat.stop();\n      this.score.stop();\n      this.mesh = new Map();\n      this.fanout = new Map();\n      this.lastpub = new Map();\n      this.gossip = new Map();\n      this.control = new Map();\n      this.peerhave = new Map();\n      this.iasked = new Map();\n      this.backoff = new Map();\n      this.outbound = new Map();\n      this.gossipTracer.clear();\n      clearTimeout(this._directPeerInitial);\n    }\n    /**\n     * Connect to a peer using the gossipsub protocol\n     * @param {string} id\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_connect\",\n    value: function _connect(id) {\n      this.log('Initiating connection with %s', id);\n\n      this._libp2p.dialProtocol(PeerId.createFromB58String(id), this.multicodecs);\n    }\n    /**\n     * Subscribes to a topic\n     * @override\n     * @param {string} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(topic) {\n      _get(_getPrototypeOf(Gossipsub.prototype), \"subscribe\", this).call(this, topic);\n\n      this.join(topic);\n    }\n    /**\n     * Unsubscribe to a topic\n     * @override\n     * @param {string} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(topic) {\n      _get(_getPrototypeOf(Gossipsub.prototype), \"unsubscribe\", this).call(this, topic);\n\n      this.leave(topic);\n    }\n    /**\n     * Join topic\n     * @param {string} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"join\",\n    value: function join(topic) {\n      var _this14 = this;\n\n      if (!this.started) {\n        throw new Error('Gossipsub has not started');\n      }\n\n      this.log('JOIN %s', topic);\n      var fanoutPeers = this.fanout.get(topic);\n\n      if (fanoutPeers) {\n        // these peers have a score above the publish threshold, which may be negative\n        // so drop the ones with a negative score\n        fanoutPeers.forEach(function (id) {\n          if (_this14.score.score(id) < 0) {\n            fanoutPeers.delete(id);\n          }\n        });\n\n        if (fanoutPeers.size < this._options.D) {\n          // we need more peers; eager, as this would get fixed in the next heartbeat\n          get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, function (id) {\n            // filter our current peers, direct peers, and peers with negative scores\n            return !fanoutPeers.has(id) && !_this14.direct.has(id) && _this14.score.score(id) >= 0;\n          }).forEach(function (id) {\n            return fanoutPeers.add(id);\n          });\n        }\n\n        this.mesh.set(topic, fanoutPeers);\n        this.fanout.delete(topic);\n        this.lastpub.delete(topic);\n      } else {\n        var peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, function (id) {\n          // filter direct peers and peers with negative score\n          return !_this14.direct.has(id) && _this14.score.score(id) >= 0;\n        });\n        this.mesh.set(topic, peers);\n      }\n\n      this.mesh.get(topic).forEach(function (id) {\n        _this14.log('JOIN: Add mesh link to %s in %s', id, topic);\n\n        _this14._sendGraft(id, topic);\n      });\n    }\n    /**\n     * Leave topic\n     * @param {string} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave(topic) {\n      var _this15 = this;\n\n      if (!this.started) {\n        throw new Error('Gossipsub has not started');\n      }\n\n      this.log('LEAVE %s', topic); // Send PRUNE to mesh peers\n\n      var meshPeers = this.mesh.get(topic);\n\n      if (meshPeers) {\n        meshPeers.forEach(function (id) {\n          _this15.log('LEAVE: Remove mesh link to %s in %s', id, topic);\n\n          _this15._sendPrune(id, topic);\n        });\n        this.mesh.delete(topic);\n      }\n    }\n    /**\n     * Publish messages\n     *\n     * @override\n     * @param {InMessage} msg\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_publish\",\n    value: function _publish(msg) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _this16 = this;\n\n        var msgID, msgIdStr, tosend, rpc;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (msg.receivedFrom !== this.peerId.toB58String()) {\n                  this.score.deliverMessage(msg);\n                  this.gossipTracer.deliverMessage(msg);\n                }\n\n                _context6.next = 3;\n                return this.getMsgId(msg);\n\n              case 3:\n                msgID = _context6.sent;\n                msgIdStr = utils_1.messageIdToString(msgID); // put in seen cache\n\n                this.seenCache.put(msgIdStr);\n                this.messageCache.put(msg);\n                tosend = new Set();\n                msg.topicIDs.forEach(function (topic) {\n                  var peersInTopic = _this16.topics.get(topic);\n\n                  if (!peersInTopic) {\n                    return;\n                  }\n\n                  if (_this16._options.floodPublish && msg.receivedFrom === _this16.peerId.toB58String()) {\n                    // flood-publish behavior\n                    // send to direct peers and _all_ peers meeting the publishThreshold\n                    peersInTopic.forEach(function (id) {\n                      if (_this16.direct.has(id) || _this16.score.score(id) >= _this16._options.scoreThresholds.publishThreshold) {\n                        tosend.add(id);\n                      }\n                    });\n                  } else {\n                    // non-flood-publish behavior\n                    // send to direct peers, subscribed floodsub peers\n                    // and some mesh peers above publishThreshold\n                    // direct peers\n                    _this16.direct.forEach(function (id) {\n                      tosend.add(id);\n                    }); // floodsub peers\n\n\n                    peersInTopic.forEach(function (id) {\n                      var score = _this16.score.score(id);\n\n                      var peerStreams = _this16.peers.get(id);\n\n                      if (!peerStreams) {\n                        return;\n                      }\n\n                      if (peerStreams.protocol === constants.FloodsubID && score >= _this16._options.scoreThresholds.publishThreshold) {\n                        tosend.add(id);\n                      }\n                    }); // Gossipsub peers handling\n\n                    var meshPeers = _this16.mesh.get(topic);\n\n                    if (!meshPeers || !meshPeers.size) {\n                      // We are not in the mesh for topic, use fanout peers\n                      meshPeers = _this16.fanout.get(topic);\n\n                      if (!meshPeers) {\n                        // If we are not in the fanout, then pick peers in topic above the publishThreshold\n                        var peers = get_gossip_peers_1.getGossipPeers(_this16, topic, _this16._options.D, function (id) {\n                          return _this16.score.score(id) >= _this16._options.scoreThresholds.publishThreshold;\n                        });\n\n                        if (peers.size > 0) {\n                          meshPeers = peers;\n\n                          _this16.fanout.set(topic, peers);\n                        } else {\n                          meshPeers = new Set();\n                        }\n                      } // Store the latest publishing time\n\n\n                      _this16.lastpub.set(topic, _this16._now());\n                    }\n\n                    meshPeers.forEach(function (peer) {\n                      tosend.add(peer);\n                    });\n                  }\n                }); // Publish messages to peers\n\n                rpc = utils_1.createGossipRpc([pubsub_1.utils.normalizeOutRpcMessage(msg)]);\n                tosend.forEach(function (id) {\n                  if (id === msg.receivedFrom || id === msg.from) {\n                    return;\n                  }\n\n                  _this16._sendRpc(id, rpc);\n                });\n\n              case 11:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n    /**\n     * Sends a GRAFT message to a peer\n     * @param {string} id peer id\n     * @param {string} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_sendGraft\",\n    value: function _sendGraft(id, topic) {\n      var graft = [{\n        topicID: topic\n      }];\n      var out = utils_1.createGossipRpc([], {\n        graft: graft\n      });\n\n      this._sendRpc(id, out);\n    }\n    /**\n     * Sends a PRUNE message to a peer\n     * @param {string} id peer id\n     * @param {string} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_sendPrune\",\n    value: function _sendPrune(id, topic) {\n      var prune = [this._makePrune(id, topic, this._options.doPX)];\n      var out = utils_1.createGossipRpc([], {\n        prune: prune\n      });\n\n      this._sendRpc(id, out);\n    }\n    /**\n     * @override\n     */\n\n  }, {\n    key: \"_sendRpc\",\n    value: function _sendRpc(id, outRpc) {\n      var peerStreams = this.peers.get(id);\n\n      if (!peerStreams || !peerStreams.isWritable) {\n        return;\n      } // piggyback control message retries\n\n\n      var ctrl = this.control.get(id);\n\n      if (ctrl) {\n        this._piggybackControl(id, outRpc, ctrl);\n\n        this.control.delete(id);\n      } // piggyback gossip\n\n\n      var ihave = this.gossip.get(id);\n\n      if (ihave) {\n        this._piggybackGossip(id, outRpc, ihave);\n\n        this.gossip.delete(id);\n      }\n\n      peerStreams.write(rpc_1.RPC.encode(outRpc).finish());\n    }\n  }, {\n    key: \"_piggybackControl\",\n    value: function _piggybackControl(id, outRpc, ctrl) {\n      var _this17 = this;\n\n      var tograft = (ctrl.graft || []).filter(function (_ref5) {\n        var topicID = _ref5.topicID;\n        return (topicID && _this17.mesh.get(topicID) || new Set()).has(id);\n      });\n      var toprune = (ctrl.prune || []).filter(function (_ref6) {\n        var topicID = _ref6.topicID;\n        return !(topicID && _this17.mesh.get(topicID) || new Set()).has(id);\n      });\n\n      if (!tograft.length && !toprune.length) {\n        return;\n      }\n\n      if (outRpc.control) {\n        outRpc.control.graft = outRpc.control.graft && outRpc.control.graft.concat(tograft);\n        outRpc.control.prune = outRpc.control.prune && outRpc.control.prune.concat(toprune);\n      } else {\n        outRpc.control = {\n          ihave: [],\n          iwant: [],\n          graft: tograft,\n          prune: toprune\n        };\n      }\n    }\n  }, {\n    key: \"_piggybackGossip\",\n    value: function _piggybackGossip(id, outRpc, ihave) {\n      if (!outRpc.control) {\n        outRpc.control = {\n          ihave: [],\n          iwant: [],\n          graft: [],\n          prune: []\n        };\n      }\n\n      outRpc.control.ihave = ihave;\n    }\n    /**\n     * Send graft and prune messages\n     * @param {Map<string, Array<string>>} tograft peer id => topic[]\n     * @param {Map<string, Array<string>>} toprune peer id => topic[]\n     */\n\n  }, {\n    key: \"_sendGraftPrune\",\n    value: function _sendGraftPrune(tograft, toprune, noPX) {\n      var _this18 = this;\n\n      var doPX = this._options.doPX;\n\n      var _iterator4 = _createForOfIteratorHelper(tograft),\n          _step4;\n\n      try {\n        var _loop = function _loop() {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              id = _step4$value[0],\n              topics = _step4$value[1];\n\n          var graft = topics.map(function (topicID) {\n            return {\n              topicID: topicID\n            };\n          });\n          var prune = []; // If a peer also has prunes, process them now\n\n          var pruning = toprune.get(id);\n\n          if (pruning) {\n            prune = pruning.map(function (topicID) {\n              return _this18._makePrune(id, topicID, doPX && !noPX.get(id));\n            });\n            toprune.delete(id);\n          }\n\n          var outRpc = utils_1.createGossipRpc([], {\n            graft: graft,\n            prune: prune\n          });\n\n          _this18._sendRpc(id, outRpc);\n        };\n\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(toprune),\n          _step5;\n\n      try {\n        var _loop2 = function _loop2() {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              id = _step5$value[0],\n              topics = _step5$value[1];\n\n          var prune = topics.map(function (topicID) {\n            return _this18._makePrune(id, topicID, doPX && !noPX.get(id));\n          });\n          var outRpc = utils_1.createGossipRpc([], {\n            prune: prune\n          });\n\n          _this18._sendRpc(id, outRpc);\n        };\n\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          _loop2();\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n    /**\n     * Emits gossip to peers in a particular topic\n     * @param {string} topic\n     * @param {Set<string>} exclude peers to exclude\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_emitGossip\",\n    value: function _emitGossip(topic, exclude) {\n      var _this19 = this;\n\n      var messageIDs = this.messageCache.getGossipIDs(topic);\n\n      if (!messageIDs.length) {\n        return;\n      } // shuffle to emit in random order\n\n\n      utils_1.shuffle(messageIDs); // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n\n      if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n        // we do the truncation (with shuffling) per peer below\n        this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n      } // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy\n      // First we collect the peers above gossipThreshold that are not in the exclude set\n      // and then randomly select from that set\n      // We also exclude direct peers, as there is no reason to emit gossip to them\n\n\n      var peersToGossip = [];\n      var topicPeers = this.topics.get(topic);\n\n      if (!topicPeers) {\n        // no topic peers, no gossip\n        return;\n      }\n\n      topicPeers.forEach(function (id) {\n        var peerStreams = _this19.peers.get(id);\n\n        if (!peerStreams) {\n          return;\n        }\n\n        if (!exclude.has(id) && !_this19.direct.has(id) && utils_1.hasGossipProtocol(peerStreams.protocol) && _this19.score.score(id) >= _this19._options.scoreThresholds.gossipThreshold) {\n          peersToGossip.push(id);\n        }\n      });\n      var target = this._options.Dlazy;\n      var factor = constants.GossipsubGossipFactor * peersToGossip.length;\n\n      if (factor > target) {\n        target = factor;\n      }\n\n      if (target > peersToGossip.length) {\n        target = peersToGossip.length;\n      } else {\n        utils_1.shuffle(peersToGossip);\n      } // Emit the IHAVE gossip to the selected peers up to the target\n\n\n      peersToGossip.slice(0, target).forEach(function (id) {\n        var peerMessageIDs = messageIDs;\n\n        if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n          // shuffle and slice message IDs per peer so that we emit a different set for each peer\n          // we have enough reduncancy in the system that this will significantly increase the message\n          // coverage when we do truncate\n          peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);\n        }\n\n        _this19._pushGossip(id, {\n          topicID: topic,\n          messageIDs: peerMessageIDs\n        });\n      });\n    }\n    /**\n     * Flush gossip and control messages\n     */\n\n  }, {\n    key: \"_flush\",\n    value: function _flush() {\n      // send gossip first, which will also piggyback control\n      var _iterator6 = _createForOfIteratorHelper(this.gossip.entries()),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n              peer = _step6$value[0],\n              ihave = _step6$value[1];\n\n          this.gossip.delete(peer);\n          var out = utils_1.createGossipRpc([], {\n            ihave: ihave\n          });\n\n          this._sendRpc(peer, out);\n        } // send the remaining control messages\n\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      var _iterator7 = _createForOfIteratorHelper(this.control.entries()),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _step7$value = _slicedToArray(_step7.value, 2),\n              _peer = _step7$value[0],\n              control = _step7$value[1];\n\n          this.control.delete(_peer);\n\n          var _out = utils_1.createGossipRpc([], {\n            graft: control.graft,\n            prune: control.prune\n          });\n\n          this._sendRpc(_peer, _out);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n    /**\n     * Adds new IHAVE messages to pending gossip\n     * @param {PeerStreams} peerStreams\n     * @param {Array<RPC.IControlIHave>} controlIHaveMsgs\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_pushGossip\",\n    value: function _pushGossip(id, controlIHaveMsgs) {\n      this.log('Add gossip to %s', id);\n      var gossip = this.gossip.get(id) || [];\n      this.gossip.set(id, gossip.concat(controlIHaveMsgs));\n    }\n    /**\n     * Returns the current time in milliseconds\n     * @returns {number}\n     */\n\n  }, {\n    key: \"_now\",\n    value: function _now() {\n      return Date.now();\n    }\n    /**\n     * Make a PRUNE control message for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @param {boolean} doPX\n     * @returns {RPC.IControlPrune}\n     */\n\n  }, {\n    key: \"_makePrune\",\n    value: function _makePrune(id, topic, doPX) {\n      var _this20 = this;\n\n      if (this.peers.get(id).protocol === constants.GossipsubIDv10) {\n        // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n        return {\n          topicID: topic,\n          peers: []\n        };\n      } // backoff is measured in seconds\n      // GossipsubPruneBackoff is measured in milliseconds\n\n\n      var backoff = constants.GossipsubPruneBackoff / 1000;\n      var px = [];\n\n      if (doPX) {\n        // select peers for Peer eXchange\n        var peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, function (xid) {\n          return xid !== id && _this20.score.score(xid) >= 0;\n        });\n        peers.forEach(function (p) {\n          // see if we have a signed record to send back; if we don't, just send\n          // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n          // unsigned address records through PX anyways\n          // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n          var peerId = PeerId.createFromB58String(p);\n          px.push({\n            peerID: peerId.toBytes(),\n            signedPeerRecord: _this20._libp2p.peerStore.addressBook.getRawEnvelope(peerId)\n          });\n        });\n      }\n\n      return {\n        topicID: topic,\n        peers: px,\n        backoff: backoff\n      };\n    }\n  }]);\n\n  return Gossipsub;\n}(pubsub_1.default);\n\nGossipsub.multicodec = constants.GossipsubIDv11;\nmodule.exports = Gossipsub;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","next","e","rejected","done","then","apply","pubsub_1","require","message_cache_1","rpc_1","constants","heartbeat_1","get_gossip_peers_1","utils_1","score_1","tracer_1","TimeCache","PeerId","Envelope","Gossipsub","libp2p","options","multicodecs","GossipsubIDv11","GossipsubIDv10","opts","assign","gossipIncoming","fallbackToFloodsub","floodPublish","doPX","directPeers","D","GossipsubD","Dlo","GossipsubDlo","Dhi","GossipsubDhi","Dscore","GossipsubDscore","Dout","GossipsubDout","Dlazy","GossipsubDlazy","heartbeatInterval","GossipsubHeartbeatInterval","fanoutTTL","GossipsubFanoutTTL","mcacheLength","GossipsubHistoryLength","mcacheGossip","GossipsubHistoryGossip","seenTTL","GossipsubSeenTTL","scoreParams","createPeerScoreParams","scoreThresholds","createPeerScoreThresholds","push","FloodsubID","debugName","_options","direct","Set","map","p","id","toB58String","forEach","peerStore","addressBook","add","addrs","seenCache","validity","mesh","Map","fanout","lastpub","gossip","control","peerhave","iasked","backoff","outbound","messageCache","MessageCache","getMsgId","bind","heartbeat","Heartbeat","heartbeatTicks","gossipTracer","IWantTracer","_libp2p","score","PeerScore","connectionManager","bytes","RPC","decode","rpc","encode","finish","peerId","protocol","addPeer","getAll","c","stat","direction","Array","from","registry","values","some","rvalue","set","peerStreams","peers","delete","removePeer","_super","_processRpc","_processRpcControlMessage","controlMsg","iwant","ihave","_handleIHave","_handleIWant","prune","graft","_handleGraft","_handlePrune","length","outRpc","createGossipRpc","_sendRpc","msg","_processRpcMessage","msgID","msgIdStr","messageIdToString","has","duplicateMessage","put","validateMessage","graylistThreshold","message","validate","rejectMessage","code","gossipThreshold","log","GossipsubMaxIHaveMessages","GossipsubMaxIHaveLength","topicID","messageIDs","size","iask","iwantList","shuffle","slice","addPromise","getForPeer","count","GossipsubGossipRetransmission","utils","normalizeOutRpcMessage","now","_now","_a","peersInMesh","expire","addPenalty","floodCutoff","GossipsubGraftFloodThreshold","GossipsubPruneBackoff","_addBackoff","topic","_makePrune","_doAddBackoff","acceptPXThreshold","_pxConnect","interval","existingExpire","getBrokenPromises","GossipsubPruneBackoffTicks","GossipsubDirectConnectTicks","toconnect","peer","isWritable","_connect","GossipsubPrunePeers","all","pi","peerID","createFromBytes","signedPeerRecord","openAndCertify","envelope","eid","consumePeerRecord","start","_directPeerInitial","setTimeout","GossipsubDirectConnectInitialDelay","stop","clear","clearTimeout","dialProtocol","createFromB58String","join","leave","started","Error","fanoutPeers","getGossipPeers","_sendGraft","meshPeers","_sendPrune","receivedFrom","deliverMessage","tosend","topicIDs","peersInTopic","topics","publishThreshold","out","ctrl","_piggybackControl","_piggybackGossip","write","tograft","filter","toprune","concat","noPX","pruning","exclude","getGossipIDs","peersToGossip","topicPeers","hasGossipProtocol","target","factor","GossipsubGossipFactor","peerMessageIDs","_pushGossip","entries","controlIHaveMsgs","Date","px","xid","toBytes","getRawEnvelope","default","multicodec","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-gossipsub/src/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst pubsub_1 = __importStar(require(\"libp2p-interfaces/src/pubsub\"));\nconst message_cache_1 = require(\"./message-cache\");\nconst rpc_1 = require(\"./message/rpc\");\nconst constants = __importStar(require(\"./constants\"));\nconst heartbeat_1 = require(\"./heartbeat\");\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\nconst utils_1 = require(\"./utils\");\nconst score_1 = require(\"./score\");\nconst tracer_1 = require(\"./tracer\");\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst TimeCache = require(\"time-cache\");\nconst PeerId = require(\"peer-id\");\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst Envelope = require(\"libp2p/src/record/envelope\");\nclass Gossipsub extends pubsub_1.default {\n    // TODO: add remaining props\n    /**\n     * @param {Libp2p} libp2p\n     * @param {Object} [options]\n     * @param {boolean} [options.emitSelf = false] if publish should emit to self, if subscribed\n     * @param {boolean} [options.canRelayMessage = false] - if can relay messages not subscribed\n     * @param {boolean} [options.gossipIncoming = true] if incoming messages on a subscribed topic should be automatically gossiped\n     * @param {boolean} [options.fallbackToFloodsub = true] if dial should fallback to floodsub\n     * @param {boolean} [options.floodPublish = true] if self-published messages should be sent to all peers\n     * @param {boolean} [options.doPX = false] whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes.\n     * @param {Object} [options.messageCache] override the default MessageCache\n     * @param {string} [options.globalSignaturePolicy = \"StrictSign\"] signing policy to apply across all messages\n     * @param {Object} [options.scoreParams] peer score parameters\n     * @param {Object} [options.scoreThresholds] peer score thresholds\n     * @param {AddrInfo[]} [options.directPeers] peers with which we will maintain direct connections\n     * @constructor\n     */\n    constructor(libp2p, options = {}) {\n        const multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];\n        const opts = Object.assign(Object.assign({ gossipIncoming: true, fallbackToFloodsub: true, floodPublish: true, doPX: false, directPeers: [], D: constants.GossipsubD, Dlo: constants.GossipsubDlo, Dhi: constants.GossipsubDhi, Dscore: constants.GossipsubDscore, Dout: constants.GossipsubDout, Dlazy: constants.GossipsubDlazy, heartbeatInterval: constants.GossipsubHeartbeatInterval, fanoutTTL: constants.GossipsubFanoutTTL, mcacheLength: constants.GossipsubHistoryLength, mcacheGossip: constants.GossipsubHistoryGossip, seenTTL: constants.GossipsubSeenTTL }, options), { scoreParams: score_1.createPeerScoreParams(options.scoreParams), scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds) });\n        // Also wants to get notified of peers connected using floodsub\n        if (opts.fallbackToFloodsub) {\n            multicodecs.push(constants.FloodsubID);\n        }\n        super(Object.assign({ debugName: 'libp2p:gossipsub', multicodecs,\n            libp2p }, opts));\n        this._options = opts;\n        /**\n         * Direct peers\n         * @type {Set<string>}\n         */\n        this.direct = new Set(opts.directPeers.map(p => p.id.toB58String()));\n        // set direct peer addresses in the address book\n        opts.directPeers.forEach(p => {\n            libp2p.peerStore.addressBook.add(p.id, p.addrs);\n        });\n        /**\n         * Cache of seen messages\n         *\n         * @type {TimeCache}\n         */\n        this.seenCache = new TimeCache({ validity: opts.seenTTL / 1000 });\n        /**\n         * Map of topic meshes\n         * topic => peer id set\n         *\n         * @type {Map<string, Set<string>>}\n         */\n        this.mesh = new Map();\n        /**\n         * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n         * topic => peer id set\n         *\n         * @type {Map<string, Set<string>>}\n         */\n        this.fanout = new Map();\n        /**\n         * Map of last publish time for fanout topics\n         * topic => last publish time\n         *\n         * @type {Map<string, number>}\n         */\n        this.lastpub = new Map();\n        /**\n         * Map of pending messages to gossip\n         * peer id => control messages\n         *\n         * @type {Map<string, Array<RPC.IControlIHave object>> }\n         */\n        this.gossip = new Map();\n        /**\n         * Map of control messages\n         * peer id => control message\n         *\n         * @type {Map<string, RPC.IControlMessage object>}\n         */\n        this.control = new Map();\n        /**\n         * Number of IHAVEs received from peer in the last heartbeat\n         * @type {Map<string, number>}\n         */\n        this.peerhave = new Map();\n        /**\n         * Number of messages we have asked from peer in the last heartbeat\n         * @type {Map<string, number>}\n         */\n        this.iasked = new Map();\n        /**\n         * Prune backoff map\n         */\n        this.backoff = new Map();\n        /**\n         * Connection direction cache, marks peers with outbound connections\n         * peer id => direction\n         *\n         * @type {Map<string, boolean>}\n         */\n        this.outbound = new Map();\n        /**\n         * A message cache that contains the messages for last few hearbeat ticks\n         *\n         */\n        this.messageCache = options.messageCache || new message_cache_1.MessageCache(opts.mcacheGossip, opts.mcacheLength, this.getMsgId.bind(this));\n        /**\n         * A heartbeat timer that maintains the mesh\n         */\n        this.heartbeat = new heartbeat_1.Heartbeat(this);\n        /**\n         * Number of heartbeats since the beginning of time\n         * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n         */\n        this.heartbeatTicks = 0;\n        /**\n         * Tracks IHAVE/IWANT promises broken by peers\n         */\n        this.gossipTracer = new tracer_1.IWantTracer(this.getMsgId.bind(this));\n        /**\n         * libp2p\n         */\n        this._libp2p = libp2p;\n        /**\n         * Peer score tracking\n         */\n        this.score = new score_1.PeerScore(this._options.scoreParams, libp2p.connectionManager, this.getMsgId.bind(this));\n    }\n    /**\n     * Decode a Uint8Array into an RPC object\n     * Overrided to use an extended protocol-specific protobuf decoder\n     * @override\n     * @param {Uint8Array} bytes\n     * @returns {RPC}\n     */\n    _decodeRpc(bytes) {\n        return rpc_1.RPC.decode(bytes);\n    }\n    /**\n     * Encode an RPC object into a Uint8Array\n     * Overrided to use an extended protocol-specific protobuf encoder\n     * @override\n     * @param {RPC} rpc\n     * @returns {Uint8Array}\n     */\n    _encodeRpc(rpc) {\n        return rpc_1.RPC.encode(rpc).finish();\n    }\n    /**\n     * Add a peer to the router\n     * @override\n     * @param {PeerId} peerId\n     * @param {string} protocol\n     * @returns {PeerStreams}\n     */\n    _addPeer(peerId, protocol) {\n        const p = super._addPeer(peerId, protocol);\n        // Add to peer scoring\n        this.score.addPeer(peerId.toB58String());\n        // track the connection direction\n        let outbound = false;\n        for (const c of this._libp2p.connectionManager.getAll(peerId)) {\n            if (c.stat.direction === 'outbound') {\n                if (Array.from(c.registry.values()).some(rvalue => protocol === rvalue.protocol)) {\n                    outbound = true;\n                    break;\n                }\n            }\n        }\n        this.outbound.set(p.id.toB58String(), outbound);\n        return p;\n    }\n    /**\n     * Removes a peer from the router\n     * @override\n     * @param {PeerId} peer\n     * @returns {PeerStreams | undefined}\n     */\n    _removePeer(peerId) {\n        const peerStreams = super._removePeer(peerId);\n        const id = peerId.toB58String();\n        // Remove this peer from the mesh\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.mesh.values()) {\n            peers.delete(id);\n        }\n        // Remove this peer from the fanout\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.fanout.values()) {\n            peers.delete(id);\n        }\n        // Remove from gossip mapping\n        this.gossip.delete(id);\n        // Remove from control mapping\n        this.control.delete(id);\n        // Remove from backoff mapping\n        this.outbound.delete(id);\n        // Remove from peer scoring\n        this.score.removePeer(id);\n        return peerStreams;\n    }\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @override\n     * @param {String} idB58Str\n     * @param {PeerStreams} peerStreams\n     * @param {RPC} rpc\n     * @returns {Promise<boolean>}\n     */\n    _processRpc(id, peerStreams, rpc) {\n        const _super = Object.create(null, {\n            _processRpc: { get: () => super._processRpc }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (yield _super._processRpc.call(this, id, peerStreams, rpc)) {\n                if (rpc.control) {\n                    this._processRpcControlMessage(id, rpc.control);\n                }\n                return true;\n            }\n            return false;\n        });\n    }\n    /**\n     * Handles an rpc control message from a peer\n     * @param {string} id peer id\n     * @param {RPC.IControlMessage} controlMsg\n     * @returns {void}\n     */\n    _processRpcControlMessage(id, controlMsg) {\n        if (!controlMsg) {\n            return;\n        }\n        const iwant = controlMsg.ihave ? this._handleIHave(id, controlMsg.ihave) : [];\n        const ihave = controlMsg.iwant ? this._handleIWant(id, controlMsg.iwant) : [];\n        const prune = controlMsg.graft ? this._handleGraft(id, controlMsg.graft) : [];\n        controlMsg.prune && this._handlePrune(id, controlMsg.prune);\n        if (!iwant.length && !ihave.length && !prune.length) {\n            return;\n        }\n        const outRpc = utils_1.createGossipRpc(ihave, { iwant, prune });\n        this._sendRpc(id, outRpc);\n    }\n    /**\n     * Process incoming message,\n     * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n     * @override\n     * @param {InMessage} msg\n     * @returns {Promise<void>}\n     */\n    _processRpcMessage(msg) {\n        const _super = Object.create(null, {\n            _processRpcMessage: { get: () => super._processRpcMessage }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const msgID = yield this.getMsgId(msg);\n            const msgIdStr = utils_1.messageIdToString(msgID);\n            // Ignore if we've already seen the message\n            if (this.seenCache.has(msgIdStr)) {\n                this.score.duplicateMessage(msg);\n                return;\n            }\n            this.seenCache.put(msgIdStr);\n            yield this.score.validateMessage(msg);\n            yield _super._processRpcMessage.call(this, msg);\n        });\n    }\n    /**\n     * Whether to accept a message from a peer\n     * @override\n     * @param {string} id\n     * @returns {boolean}\n     */\n    _acceptFrom(id) {\n        return this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.graylistThreshold;\n    }\n    /**\n     * Validate incoming message\n     * @override\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n    validate(message) {\n        const _super = Object.create(null, {\n            validate: { get: () => super.validate }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield _super.validate.call(this, message);\n            }\n            catch (e) {\n                this.score.rejectMessage(message, e.code);\n                this.gossipTracer.rejectMessage(message, e.code);\n                throw e;\n            }\n        });\n    }\n    /**\n     * Handles IHAVE messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlIHave>} ihave\n     * @returns {RPC.IControlIWant}\n     */\n    _handleIHave(id, ihave) {\n        if (!ihave.length) {\n            return [];\n        }\n        // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n        const score = this.score.score(id);\n        if (score < this._options.scoreThresholds.gossipThreshold) {\n            this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score);\n            return [];\n        }\n        // IHAVE flood protection\n        const peerhave = (this.peerhave.get(id) || 0) + 1;\n        this.peerhave.set(id, peerhave);\n        if (peerhave > constants.GossipsubMaxIHaveMessages) {\n            this.log('IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring', id, peerhave);\n            return [];\n        }\n        const iasked = this.iasked.get(id) || 0;\n        if (iasked >= constants.GossipsubMaxIHaveLength) {\n            this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked);\n            return [];\n        }\n        // string msgId => msgId\n        const iwant = new Map();\n        ihave.forEach(({ topicID, messageIDs }) => {\n            if (!topicID || !messageIDs || !this.mesh.has(topicID)) {\n                return;\n            }\n            messageIDs.forEach((msgID) => {\n                const msgIdStr = utils_1.messageIdToString(msgID);\n                if (this.seenCache.has(msgIdStr)) {\n                    return;\n                }\n                iwant.set(msgIdStr, msgID);\n            });\n        });\n        if (!iwant.size) {\n            return [];\n        }\n        let iask = iwant.size;\n        if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n            iask = constants.GossipsubMaxIHaveLength - iasked;\n        }\n        this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id);\n        let iwantList = Array.from(iwant.values());\n        // ask in random order\n        utils_1.shuffle(iwantList);\n        // truncate to the messages we are actually asking for and update the iasked counter\n        iwantList = iwantList.slice(0, iask);\n        this.iasked.set(id, iasked + iask);\n        this.gossipTracer.addPromise(id, iwantList);\n        return [{\n                messageIDs: iwantList\n            }];\n    }\n    /**\n     * Handles IWANT messages\n     * Returns messages to send back to peer\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlIWant>} iwant\n     * @returns {Array<RPC.IMessage>}\n     */\n    _handleIWant(id, iwant) {\n        if (!iwant.length) {\n            return [];\n        }\n        // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n        const score = this.score.score(id);\n        if (score < this._options.scoreThresholds.gossipThreshold) {\n            this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score);\n            return [];\n        }\n        // @type {Map<string, Message>}\n        const ihave = new Map();\n        iwant.forEach(({ messageIDs }) => {\n            messageIDs && messageIDs.forEach((msgID) => {\n                const [msg, count] = this.messageCache.getForPeer(msgID, id);\n                if (!msg) {\n                    return;\n                }\n                if (count > constants.GossipsubGossipRetransmission) {\n                    this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgID);\n                    return;\n                }\n                ihave.set(utils_1.messageIdToString(msgID), msg);\n            });\n        });\n        if (!ihave.size) {\n            return [];\n        }\n        this.log('IWANT: Sending %d messages to %s', ihave.size, id);\n        return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);\n    }\n    /**\n     * Handles Graft messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlGraft>} graft\n     * @return {Array<RPC.IControlPrune>}\n     */\n    _handleGraft(id, graft) {\n        const prune = [];\n        const score = this.score.score(id);\n        const now = this._now();\n        let doPX = this._options.doPX;\n        graft.forEach(({ topicID }) => {\n            var _a;\n            if (!topicID) {\n                return;\n            }\n            const peersInMesh = this.mesh.get(topicID);\n            if (!peersInMesh) {\n                // don't do PX when there is an unknown topic to avoid leaking our peers\n                doPX = false;\n                // spam hardening: ignore GRAFTs for unknown topics\n                return;\n            }\n            // check if peer is already in the mesh; if so do nothing\n            if (peersInMesh.has(id)) {\n                return;\n            }\n            // we don't GRAFT to/from direct peers; complain loudly if this happens\n            if (this.direct.has(id)) {\n                this.log('GRAFT: ignoring request from direct peer %s', id);\n                // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n                prune.push(topicID);\n                // but don't px\n                doPX = false;\n                return;\n            }\n            // make sure we are not backing off that peer\n            const expire = (_a = this.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);\n            if (typeof expire === 'number' && now < expire) {\n                this.log('GRAFT: ignoring backed off peer %s', id);\n                // add behavioral penalty\n                this.score.addPenalty(id, 1);\n                // no PX\n                doPX = false;\n                // check the flood cutoff -- is the GRAFT coming too fast?\n                const floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;\n                if (now < floodCutoff) {\n                    // extra penalty\n                    this.score.addPenalty(id, 1);\n                }\n                // refresh the backoff\n                this._addBackoff(id, topicID);\n                prune.push(topicID);\n                return;\n            }\n            // check the score\n            if (score < 0) {\n                // we don't GRAFT peers with negative score\n                this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID);\n                // we do send them PRUNE however, because it's a matter of protocol correctness\n                prune.push(topicID);\n                // but we won't PX to them\n                doPX = false;\n                // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n                this._addBackoff(id, topicID);\n                return;\n            }\n            // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n            // from peers with outbound connections; this is a defensive check to restrict potential\n            // mesh takeover attacks combined with love bombing\n            if (peersInMesh.size >= this._options.Dhi && !this.outbound.get(id)) {\n                prune.push(topicID);\n                this._addBackoff(id, topicID);\n                return;\n            }\n            this.log('GRAFT: Add mesh link from %s in %s', id, topicID);\n            this.score.graft(id, topicID);\n            peersInMesh.add(id);\n        });\n        if (!prune.length) {\n            return [];\n        }\n        return prune.map(topic => this._makePrune(id, topic, doPX));\n    }\n    /**\n     * Handles Prune messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlPrune>} prune\n     * @returns {void}\n     */\n    _handlePrune(id, prune) {\n        const score = this.score.score(id);\n        prune.forEach(({ topicID, backoff, peers }) => {\n            if (!topicID) {\n                return;\n            }\n            const peersInMesh = this.mesh.get(topicID);\n            if (!peersInMesh) {\n                return;\n            }\n            this.log('PRUNE: Remove mesh link to %s in %s', id, topicID);\n            this.score.prune(id, topicID);\n            peersInMesh.delete(id);\n            // is there a backoff specified by the peer? if so obey it\n            if (typeof backoff === 'number' && backoff > 0) {\n                this._doAddBackoff(id, topicID, backoff * 1000);\n            }\n            else {\n                this._addBackoff(id, topicID);\n            }\n            // PX\n            if (peers && peers.length) {\n                // we ignore PX from peers with insufficient scores\n                if (score < this._options.scoreThresholds.acceptPXThreshold) {\n                    this.log('PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]', id, score, topicID);\n                    return;\n                }\n                this._pxConnect(peers);\n            }\n        });\n    }\n    /**\n     * Add standard backoff log for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _addBackoff(id, topic) {\n        this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);\n    }\n    /**\n     * Add backoff expiry interval for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @param {number} interval backoff duration in milliseconds\n     * @returns {void}\n     */\n    _doAddBackoff(id, topic, interval) {\n        let backoff = this.backoff.get(topic);\n        if (!backoff) {\n            backoff = new Map();\n            this.backoff.set(topic, backoff);\n        }\n        const expire = this._now() + interval;\n        const existingExpire = backoff.get(id) || 0;\n        if (existingExpire < expire) {\n            backoff.set(id, expire);\n        }\n    }\n    /**\n     * Apply penalties from broken IHAVE/IWANT promises\n     * @returns {void}\n     */\n    _applyIwantPenalties() {\n        this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n            this.log('peer %s didn\\'t follow up in %d IWANT requests; adding penalty', p, count);\n            this.score.addPenalty(p, count);\n        });\n    }\n    /**\n     * Clear expired backoff expiries\n     * @returns {void}\n     */\n    _clearBackoff() {\n        // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n        if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n            return;\n        }\n        const now = this._now();\n        this.backoff.forEach((backoff, topic) => {\n            backoff.forEach((expire, id) => {\n                if (expire < now) {\n                    backoff.delete(id);\n                }\n            });\n            if (backoff.size === 0) {\n                this.backoff.delete(topic);\n            }\n        });\n    }\n    /**\n     * Maybe reconnect to direct peers\n     * @returns {void}\n     */\n    _directConnect() {\n        // we only do this every few ticks to allow pending connections to complete and account for\n        // restarts/downtime\n        if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {\n            return;\n        }\n        const toconnect = [];\n        this.direct.forEach(id => {\n            const peer = this.peers.get(id);\n            if (!peer || !peer.isWritable) {\n                toconnect.push(id);\n            }\n        });\n        if (toconnect.length) {\n            toconnect.forEach(id => {\n                this._connect(id);\n            });\n        }\n    }\n    /**\n     * Maybe attempt connection given signed peer records\n     * @param {RPC.IPeerInfo[]} peers\n     * @returns {Promise<void>}\n     */\n    _pxConnect(peers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (peers.length > constants.GossipsubPrunePeers) {\n                utils_1.shuffle(peers);\n                peers = peers.slice(0, constants.GossipsubPrunePeers);\n            }\n            const toconnect = [];\n            yield Promise.all(peers.map((pi) => __awaiter(this, void 0, void 0, function* () {\n                if (!pi.peerID) {\n                    return;\n                }\n                const p = PeerId.createFromBytes(pi.peerID);\n                const id = p.toB58String();\n                if (this.peers.has(id)) {\n                    return;\n                }\n                if (!pi.signedPeerRecord) {\n                    toconnect.push(id);\n                    return;\n                }\n                // The peer sent us a signed record\n                // This is not a record from the peer who sent the record, but another peer who is connected with it\n                // Ensure that it is valid\n                try {\n                    const envelope = yield Envelope.openAndCertify(pi.signedPeerRecord, 'libp2p-peer-record');\n                    const eid = envelope.peerId.toB58String();\n                    if (id !== eid) {\n                        this.log('bogus peer record obtained through px: peer ID %s doesn\\'t match expected peer %s', eid, id);\n                        return;\n                    }\n                    if (!this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {\n                        this.log('bogus peer record obtained through px: could not add peer record to address book');\n                        return;\n                    }\n                    toconnect.push(id);\n                }\n                catch (e) {\n                    this.log('bogus peer record obtained through px: invalid signature or not a peer record');\n                }\n            })));\n            if (!toconnect.length) {\n                return;\n            }\n            toconnect.forEach(id => this._connect(id));\n        });\n    }\n    /**\n     * Mounts the gossipsub protocol onto the libp2p node and sends our\n     * our subscriptions to every peer connected\n     * @override\n     * @returns {void}\n     */\n    start() {\n        super.start();\n        this.heartbeat.start();\n        this.score.start();\n        // connect to direct peers\n        this._directPeerInitial = setTimeout(() => {\n            this.direct.forEach(id => {\n                this._connect(id);\n            });\n        }, constants.GossipsubDirectConnectInitialDelay);\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n    stop() {\n        super.stop();\n        this.heartbeat.stop();\n        this.score.stop();\n        this.mesh = new Map();\n        this.fanout = new Map();\n        this.lastpub = new Map();\n        this.gossip = new Map();\n        this.control = new Map();\n        this.peerhave = new Map();\n        this.iasked = new Map();\n        this.backoff = new Map();\n        this.outbound = new Map();\n        this.gossipTracer.clear();\n        clearTimeout(this._directPeerInitial);\n    }\n    /**\n     * Connect to a peer using the gossipsub protocol\n     * @param {string} id\n     * @returns {void}\n     */\n    _connect(id) {\n        this.log('Initiating connection with %s', id);\n        this._libp2p.dialProtocol(PeerId.createFromB58String(id), this.multicodecs);\n    }\n    /**\n     * Subscribes to a topic\n     * @override\n     * @param {string} topic\n     * @returns {void}\n     */\n    subscribe(topic) {\n        super.subscribe(topic);\n        this.join(topic);\n    }\n    /**\n     * Unsubscribe to a topic\n     * @override\n     * @param {string} topic\n     * @returns {void}\n     */\n    unsubscribe(topic) {\n        super.unsubscribe(topic);\n        this.leave(topic);\n    }\n    /**\n     * Join topic\n     * @param {string} topic\n     * @returns {void}\n     */\n    join(topic) {\n        if (!this.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        this.log('JOIN %s', topic);\n        const fanoutPeers = this.fanout.get(topic);\n        if (fanoutPeers) {\n            // these peers have a score above the publish threshold, which may be negative\n            // so drop the ones with a negative score\n            fanoutPeers.forEach(id => {\n                if (this.score.score(id) < 0) {\n                    fanoutPeers.delete(id);\n                }\n            });\n            if (fanoutPeers.size < this._options.D) {\n                // we need more peers; eager, as this would get fixed in the next heartbeat\n                get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, (id) => {\n                    // filter our current peers, direct peers, and peers with negative scores\n                    return !fanoutPeers.has(id) && !this.direct.has(id) && this.score.score(id) >= 0;\n                }).forEach(id => fanoutPeers.add(id));\n            }\n            this.mesh.set(topic, fanoutPeers);\n            this.fanout.delete(topic);\n            this.lastpub.delete(topic);\n        }\n        else {\n            const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, (id) => {\n                // filter direct peers and peers with negative score\n                return !this.direct.has(id) && this.score.score(id) >= 0;\n            });\n            this.mesh.set(topic, peers);\n        }\n        this.mesh.get(topic).forEach((id) => {\n            this.log('JOIN: Add mesh link to %s in %s', id, topic);\n            this._sendGraft(id, topic);\n        });\n    }\n    /**\n     * Leave topic\n     * @param {string} topic\n     * @returns {void}\n     */\n    leave(topic) {\n        if (!this.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        this.log('LEAVE %s', topic);\n        // Send PRUNE to mesh peers\n        const meshPeers = this.mesh.get(topic);\n        if (meshPeers) {\n            meshPeers.forEach((id) => {\n                this.log('LEAVE: Remove mesh link to %s in %s', id, topic);\n                this._sendPrune(id, topic);\n            });\n            this.mesh.delete(topic);\n        }\n    }\n    /**\n     * Publish messages\n     *\n     * @override\n     * @param {InMessage} msg\n     * @returns {void}\n     */\n    _publish(msg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (msg.receivedFrom !== this.peerId.toB58String()) {\n                this.score.deliverMessage(msg);\n                this.gossipTracer.deliverMessage(msg);\n            }\n            const msgID = yield this.getMsgId(msg);\n            const msgIdStr = utils_1.messageIdToString(msgID);\n            // put in seen cache\n            this.seenCache.put(msgIdStr);\n            this.messageCache.put(msg);\n            const tosend = new Set();\n            msg.topicIDs.forEach((topic) => {\n                const peersInTopic = this.topics.get(topic);\n                if (!peersInTopic) {\n                    return;\n                }\n                if (this._options.floodPublish && msg.receivedFrom === this.peerId.toB58String()) {\n                    // flood-publish behavior\n                    // send to direct peers and _all_ peers meeting the publishThreshold\n                    peersInTopic.forEach(id => {\n                        if (this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.publishThreshold) {\n                            tosend.add(id);\n                        }\n                    });\n                }\n                else {\n                    // non-flood-publish behavior\n                    // send to direct peers, subscribed floodsub peers\n                    // and some mesh peers above publishThreshold\n                    // direct peers\n                    this.direct.forEach(id => {\n                        tosend.add(id);\n                    });\n                    // floodsub peers\n                    peersInTopic.forEach((id) => {\n                        const score = this.score.score(id);\n                        const peerStreams = this.peers.get(id);\n                        if (!peerStreams) {\n                            return;\n                        }\n                        if (peerStreams.protocol === constants.FloodsubID && score >= this._options.scoreThresholds.publishThreshold) {\n                            tosend.add(id);\n                        }\n                    });\n                    // Gossipsub peers handling\n                    let meshPeers = this.mesh.get(topic);\n                    if (!meshPeers || !meshPeers.size) {\n                        // We are not in the mesh for topic, use fanout peers\n                        meshPeers = this.fanout.get(topic);\n                        if (!meshPeers) {\n                            // If we are not in the fanout, then pick peers in topic above the publishThreshold\n                            const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n                                return this.score.score(id) >= this._options.scoreThresholds.publishThreshold;\n                            });\n                            if (peers.size > 0) {\n                                meshPeers = peers;\n                                this.fanout.set(topic, peers);\n                            }\n                            else {\n                                meshPeers = new Set();\n                            }\n                        }\n                        // Store the latest publishing time\n                        this.lastpub.set(topic, this._now());\n                    }\n                    meshPeers.forEach((peer) => {\n                        tosend.add(peer);\n                    });\n                }\n            });\n            // Publish messages to peers\n            const rpc = utils_1.createGossipRpc([\n                pubsub_1.utils.normalizeOutRpcMessage(msg)\n            ]);\n            tosend.forEach((id) => {\n                if (id === msg.receivedFrom || id === msg.from) {\n                    return;\n                }\n                this._sendRpc(id, rpc);\n            });\n        });\n    }\n    /**\n     * Sends a GRAFT message to a peer\n     * @param {string} id peer id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _sendGraft(id, topic) {\n        const graft = [{\n                topicID: topic\n            }];\n        const out = utils_1.createGossipRpc([], { graft });\n        this._sendRpc(id, out);\n    }\n    /**\n     * Sends a PRUNE message to a peer\n     * @param {string} id peer id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _sendPrune(id, topic) {\n        const prune = [\n            this._makePrune(id, topic, this._options.doPX)\n        ];\n        const out = utils_1.createGossipRpc([], { prune });\n        this._sendRpc(id, out);\n    }\n    /**\n     * @override\n     */\n    _sendRpc(id, outRpc) {\n        const peerStreams = this.peers.get(id);\n        if (!peerStreams || !peerStreams.isWritable) {\n            return;\n        }\n        // piggyback control message retries\n        const ctrl = this.control.get(id);\n        if (ctrl) {\n            this._piggybackControl(id, outRpc, ctrl);\n            this.control.delete(id);\n        }\n        // piggyback gossip\n        const ihave = this.gossip.get(id);\n        if (ihave) {\n            this._piggybackGossip(id, outRpc, ihave);\n            this.gossip.delete(id);\n        }\n        peerStreams.write(rpc_1.RPC.encode(outRpc).finish());\n    }\n    _piggybackControl(id, outRpc, ctrl) {\n        const tograft = (ctrl.graft || [])\n            .filter(({ topicID }) => (topicID && this.mesh.get(topicID) || new Set()).has(id));\n        const toprune = (ctrl.prune || [])\n            .filter(({ topicID }) => !(topicID && this.mesh.get(topicID) || new Set()).has(id));\n        if (!tograft.length && !toprune.length) {\n            return;\n        }\n        if (outRpc.control) {\n            outRpc.control.graft = outRpc.control.graft && outRpc.control.graft.concat(tograft);\n            outRpc.control.prune = outRpc.control.prune && outRpc.control.prune.concat(toprune);\n        }\n        else {\n            outRpc.control = { ihave: [], iwant: [], graft: tograft, prune: toprune };\n        }\n    }\n    _piggybackGossip(id, outRpc, ihave) {\n        if (!outRpc.control) {\n            outRpc.control = { ihave: [], iwant: [], graft: [], prune: [] };\n        }\n        outRpc.control.ihave = ihave;\n    }\n    /**\n     * Send graft and prune messages\n     * @param {Map<string, Array<string>>} tograft peer id => topic[]\n     * @param {Map<string, Array<string>>} toprune peer id => topic[]\n     */\n    _sendGraftPrune(tograft, toprune, noPX) {\n        const doPX = this._options.doPX;\n        for (const [id, topics] of tograft) {\n            const graft = topics.map((topicID) => ({ topicID }));\n            let prune = [];\n            // If a peer also has prunes, process them now\n            const pruning = toprune.get(id);\n            if (pruning) {\n                prune = pruning.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n                toprune.delete(id);\n            }\n            const outRpc = utils_1.createGossipRpc([], { graft, prune });\n            this._sendRpc(id, outRpc);\n        }\n        for (const [id, topics] of toprune) {\n            const prune = topics.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n            const outRpc = utils_1.createGossipRpc([], { prune });\n            this._sendRpc(id, outRpc);\n        }\n    }\n    /**\n     * Emits gossip to peers in a particular topic\n     * @param {string} topic\n     * @param {Set<string>} exclude peers to exclude\n     * @returns {void}\n     */\n    _emitGossip(topic, exclude) {\n        const messageIDs = this.messageCache.getGossipIDs(topic);\n        if (!messageIDs.length) {\n            return;\n        }\n        // shuffle to emit in random order\n        utils_1.shuffle(messageIDs);\n        // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n        if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n            // we do the truncation (with shuffling) per peer below\n            this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n        }\n        // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy\n        // First we collect the peers above gossipThreshold that are not in the exclude set\n        // and then randomly select from that set\n        // We also exclude direct peers, as there is no reason to emit gossip to them\n        const peersToGossip = [];\n        const topicPeers = this.topics.get(topic);\n        if (!topicPeers) {\n            // no topic peers, no gossip\n            return;\n        }\n        topicPeers.forEach(id => {\n            const peerStreams = this.peers.get(id);\n            if (!peerStreams) {\n                return;\n            }\n            if (!exclude.has(id) &&\n                !this.direct.has(id) &&\n                utils_1.hasGossipProtocol(peerStreams.protocol) &&\n                this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {\n                peersToGossip.push(id);\n            }\n        });\n        let target = this._options.Dlazy;\n        const factor = constants.GossipsubGossipFactor * peersToGossip.length;\n        if (factor > target) {\n            target = factor;\n        }\n        if (target > peersToGossip.length) {\n            target = peersToGossip.length;\n        }\n        else {\n            utils_1.shuffle(peersToGossip);\n        }\n        // Emit the IHAVE gossip to the selected peers up to the target\n        peersToGossip.slice(0, target).forEach(id => {\n            let peerMessageIDs = messageIDs;\n            if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n                // shuffle and slice message IDs per peer so that we emit a different set for each peer\n                // we have enough reduncancy in the system that this will significantly increase the message\n                // coverage when we do truncate\n                peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);\n            }\n            this._pushGossip(id, {\n                topicID: topic,\n                messageIDs: peerMessageIDs\n            });\n        });\n    }\n    /**\n     * Flush gossip and control messages\n     */\n    _flush() {\n        // send gossip first, which will also piggyback control\n        for (const [peer, ihave] of this.gossip.entries()) {\n            this.gossip.delete(peer);\n            const out = utils_1.createGossipRpc([], { ihave });\n            this._sendRpc(peer, out);\n        }\n        // send the remaining control messages\n        for (const [peer, control] of this.control.entries()) {\n            this.control.delete(peer);\n            const out = utils_1.createGossipRpc([], { graft: control.graft, prune: control.prune });\n            this._sendRpc(peer, out);\n        }\n    }\n    /**\n     * Adds new IHAVE messages to pending gossip\n     * @param {PeerStreams} peerStreams\n     * @param {Array<RPC.IControlIHave>} controlIHaveMsgs\n     * @returns {void}\n     */\n    _pushGossip(id, controlIHaveMsgs) {\n        this.log('Add gossip to %s', id);\n        const gossip = this.gossip.get(id) || [];\n        this.gossip.set(id, gossip.concat(controlIHaveMsgs));\n    }\n    /**\n     * Returns the current time in milliseconds\n     * @returns {number}\n     */\n    _now() {\n        return Date.now();\n    }\n    /**\n     * Make a PRUNE control message for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @param {boolean} doPX\n     * @returns {RPC.IControlPrune}\n     */\n    _makePrune(id, topic, doPX) {\n        if (this.peers.get(id).protocol === constants.GossipsubIDv10) {\n            // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n            return {\n                topicID: topic,\n                peers: []\n            };\n        }\n        // backoff is measured in seconds\n        // GossipsubPruneBackoff is measured in milliseconds\n        const backoff = constants.GossipsubPruneBackoff / 1000;\n        const px = [];\n        if (doPX) {\n            // select peers for Peer eXchange\n            const peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, (xid) => {\n                return xid !== id && this.score.score(xid) >= 0;\n            });\n            peers.forEach(p => {\n                // see if we have a signed record to send back; if we don't, just send\n                // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n                // unsigned address records through PX anyways\n                // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n                const peerId = PeerId.createFromB58String(p);\n                px.push({\n                    peerID: peerId.toBytes(),\n                    signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId)\n                });\n            });\n        }\n        return {\n            topicID: topic,\n            peers: px,\n            backoff: backoff\n        };\n    }\n}\nGossipsub.multicodec = constants.GossipsubIDv11;\nmodule.exports = Gossipsub;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}