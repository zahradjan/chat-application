{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar errCode = require('err-code');\n\nvar log = require('debug')('ipfs:mfs:mkdir');\n\nvar _require = require('ipfs-unixfs-exporter'),\n    exporter = _require.exporter;\n\nvar createNode = require('./utils/create-node');\n\nvar toPathComponents = require('./utils/to-path-components');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar updateTree = require('./utils/update-tree');\n\nvar addLink = require('./utils/add-link');\n\nvar withMfsRoot = require('./utils/with-mfs-root');\n\nvar mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nvar withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} flush\n * @property {number} [mode]\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nvar defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true\n};\n/**\n * @param {MfsContext} context\n */\n\nmodule.exports = function (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"mkdir\"]}\n   */\n  function mfsMkdir(_x) {\n    return _mfsMkdir.apply(this, arguments);\n  }\n\n  function _mfsMkdir() {\n    _mfsMkdir = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(path) {\n      var options,\n          opts,\n          pathComponents,\n          root,\n          parent,\n          trail,\n          emptyDir,\n          i,\n          subPathComponents,\n          subPath,\n          newRootCid,\n          _args = arguments;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n              /** @type {DefaultOptions} */\n              opts = mergeOptions(defaultOptions, options);\n\n              if (path) {\n                _context.next = 4;\n                break;\n              }\n\n              throw new Error('no path given to Mkdir');\n\n            case 4:\n              path = path.trim();\n\n              if (!(path === '/')) {\n                _context.next = 9;\n                break;\n              }\n\n              if (!opts.parents) {\n                _context.next = 8;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 8:\n              throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH');\n\n            case 9:\n              if (!(path.substring(0, 1) !== '/')) {\n                _context.next = 11;\n                break;\n              }\n\n              throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n\n            case 11:\n              log(\"Creating \".concat(path));\n              pathComponents = toPathComponents(path);\n\n              if (!(pathComponents[0] === 'ipfs')) {\n                _context.next = 15;\n                break;\n              }\n\n              throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH');\n\n            case 15:\n              _context.next = 17;\n              return withMfsRoot(context, opts);\n\n            case 17:\n              root = _context.sent;\n              trail = [];\n              _context.next = 21;\n              return createNode(context, 'directory', opts);\n\n            case 21:\n              emptyDir = _context.sent;\n              i = 0;\n\n            case 23:\n              if (!(i <= pathComponents.length)) {\n                _context.next = 52;\n                break;\n              }\n\n              subPathComponents = pathComponents.slice(0, i);\n              subPath = \"/ipfs/\".concat(root, \"/\").concat(subPathComponents.join('/'));\n              _context.prev = 26;\n              _context.next = 29;\n              return exporter(subPath, context.repo.blocks);\n\n            case 29:\n              parent = _context.sent;\n\n              if (!(parent.type !== 'file' && parent.type !== 'directory')) {\n                _context.next = 32;\n                break;\n              }\n\n              throw errCode(new Error(\"\".concat(path, \" was not a UnixFS node\")), 'ERR_NOT_UNIXFS');\n\n            case 32:\n              if (!(i === pathComponents.length)) {\n                _context.next = 36;\n                break;\n              }\n\n              if (!opts.parents) {\n                _context.next = 35;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 35:\n              throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n\n            case 36:\n              trail.push({\n                name: parent.name,\n                cid: parent.cid\n              });\n              _context.next = 49;\n              break;\n\n            case 39:\n              _context.prev = 39;\n              _context.t0 = _context[\"catch\"](26);\n\n              if (!(_context.t0.code === 'ERR_NOT_FOUND')) {\n                _context.next = 48;\n                break;\n              }\n\n              if (!(i < pathComponents.length && !opts.parents)) {\n                _context.next = 44;\n                break;\n              }\n\n              throw errCode(new Error(\"Intermediate directory path \".concat(subPath, \" does not exist, use the -p flag to create it\")), 'ERR_NOT_FOUND');\n\n            case 44:\n              _context.next = 46;\n              return addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);\n\n            case 46:\n              _context.next = 49;\n              break;\n\n            case 48:\n              throw _context.t0;\n\n            case 49:\n              i++;\n              _context.next = 23;\n              break;\n\n            case 52:\n              _context.next = 54;\n              return updateTree(context, trail, opts);\n\n            case 54:\n              newRootCid = _context.sent;\n              _context.next = 57;\n              return updateMfsRoot(context, newRootCid, opts);\n\n            case 57:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[26, 39]]);\n    }));\n    return _mfsMkdir.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsMkdir);\n};\n/**\n * @param {MfsContext} context\n * @param {string} childName\n * @param {{ cid: CID, node?: PBNode }} emptyDir\n * @param {{ cid?: CID, node?: PBNode }} parent\n * @param {{ name: string, cid: CID }[]} trail\n * @param {DefaultOptions} options\n */\n\n\nvar addEmptyDir = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(context, childName, emptyDir, parent, trail, options) {\n    var result;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            log(\"Adding empty dir called \".concat(childName, \" to \").concat(parent.cid));\n            _context2.next = 3;\n            return addLink(context, {\n              parent: parent.node,\n              parentCid: parent.cid,\n              // TODO vmx 2021-03-09: Remove the usage of size completely\n              size: 0,\n              cid: emptyDir.cid,\n              name: childName,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion,\n              flush: options.flush,\n              shardSplitThreshold: options.shardSplitThreshold\n            });\n\n          case 3:\n            result = _context2.sent;\n            trail[trail.length - 1].cid = result.cid;\n            trail.push({\n              name: childName,\n              cid: emptyDir.cid\n            });\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function addEmptyDir(_x2, _x3, _x4, _x5, _x6, _x7) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["errCode","require","log","exporter","createNode","toPathComponents","updateMfsRoot","updateTree","addLink","withMfsRoot","mergeOptions","bind","ignoreUndefined","withTimeoutOption","defaultOptions","parents","hashAlg","cidVersion","shardSplitThreshold","flush","module","exports","context","mfsMkdir","path","options","opts","Error","trim","substring","pathComponents","root","trail","emptyDir","i","length","subPathComponents","slice","subPath","join","repo","blocks","parent","type","push","name","cid","code","addEmptyDir","newRootCid","childName","node","parentCid","size","result"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/mkdir.js"],"sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst log = require('debug')('ipfs:mfs:mkdir')\nconst { exporter } = require('ipfs-unixfs-exporter')\nconst createNode = require('./utils/create-node')\nconst toPathComponents = require('./utils/to-path-components')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst updateTree = require('./utils/update-tree')\nconst addLink = require('./utils/add-link')\nconst withMfsRoot = require('./utils/with-mfs-root')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} flush\n * @property {number} [mode]\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"mkdir\"]}\n   */\n  async function mfsMkdir (path, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options)\n\n    if (!path) {\n      throw new Error('no path given to Mkdir')\n    }\n\n    path = path.trim()\n\n    if (path === '/') {\n      if (opts.parents) {\n        return\n      }\n\n      throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n    }\n\n    log(`Creating ${path}`)\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH')\n    }\n\n    const root = await withMfsRoot(context, opts)\n    let parent\n    const trail = []\n    const emptyDir = await createNode(context, 'directory', opts)\n\n    // make sure the containing folder exists, creating it if necessary\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i)\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`\n\n      try {\n        parent = await exporter(subPath, context.repo.blocks)\n\n        if (parent.type !== 'file' && parent.type !== 'directory') {\n          throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n        }\n\n        if (i === pathComponents.length) {\n          if (opts.parents) {\n            return\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS')\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        })\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !opts.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND')\n          }\n\n          // add the intermediate directory\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts)\n        } else {\n          throw err\n        }\n      }\n    }\n\n    // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n\n    // update the tree from the leaf to the root\n    const newRootCid = await updateTree(context, trail, opts)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts)\n  }\n\n  return withTimeoutOption(mfsMkdir)\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} childName\n * @param {{ cid: CID, node?: PBNode }} emptyDir\n * @param {{ cid?: CID, node?: PBNode }} parent\n * @param {{ name: string, cid: CID }[]} trail\n * @param {DefaultOptions} options\n */\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`)\n\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    // TODO vmx 2021-03-09: Remove the usage of size completely\n    size: 0,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  })\n\n  trail[trail.length - 1].cid = result.cid\n\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}