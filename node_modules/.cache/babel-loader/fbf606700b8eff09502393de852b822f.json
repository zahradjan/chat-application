{"ast":null,"code":"'use strict'; // @ts-ignore - TODO vmx 2021-03-31\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link');\n\nconst {\n  UnixFS\n} = require('ipfs-unixfs');\n\nconst {\n  generatePath,\n  updateHamtDirectory\n} = require('./hamt-utils');\n\nconst errCode = require('err-code');\n/**\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} RemoveLinkOptions\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {CID} [parentCid]\n * @property {PBNode} [parent]\n *\n * @typedef {object} RemoveLinkOptionsInternal\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {PBNode} parent\n */\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptions} options\n */\n\n\nconst removeLink = async (context, options) => {\n  let parent = options.parent;\n\n  if (options.parentCid) {\n    const parentCid = CID.asCID(options.parentCid);\n\n    if (parentCid === null) {\n      throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n    }\n\n    log(`Loading parent node ${parentCid}`);\n    const block = await context.repo.blocks.get(parentCid);\n    parent = dagPb.decode(block);\n  }\n\n  if (!parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n  }\n\n  if (!parent.Data) {\n    throw errCode(new Error('Parent node had no data'), 'ERR_INVALID_NODE');\n  }\n\n  const meta = UnixFS.unmarshal(parent.Data);\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`);\n    return removeFromShardedDirectory(context, { ...options,\n      parent\n    });\n  }\n\n  log(`Removing link ${options.name} regular directory`);\n  return removeFromDirectory(context, { ...options,\n    parent\n  });\n};\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nconst removeFromDirectory = async (context, options) => {\n  // Remove existing link if it exists\n  options.parent.Links = options.parent.Links.filter(link => {\n    return link.Name !== options.name;\n  });\n  const parentBlock = await dagPb.encode(options.parent);\n  const hasher = await context.hashers.getHasher(options.hashAlg);\n  const hash = await hasher.digest(parentBlock);\n  const parentCid = CID.create(options.cidVersion, dagPb.code, hash);\n  await context.repo.blocks.put(parentCid, parentBlock);\n  log(`Updated regular directory ${parentCid}`);\n  return {\n    node: options.parent,\n    cid: parentCid\n  };\n};\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket,\n    path\n  } = await generatePath(context, options.name, options.parent);\n  await rootBucket.del(options.name);\n  const {\n    node\n  } = await updateShard(context, path, options.name, options);\n  return updateHamtDirectory(context, node.Links, rootBucket, options);\n};\n/**\n * @param {MfsContext} context\n * @param {{ bucket: Bucket, prefix: string, node?: PBNode }[]} positions\n * @param {string} name\n * @param {RemoveLinkOptionsInternal} options\n * @returns {Promise<{ node: PBNode, cid: CID, size: number }>}\n */\n\n\nconst updateShard = async (context, positions, name, options) => {\n  const last = positions.pop();\n\n  if (!last) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n  }\n\n  const {\n    bucket,\n    prefix,\n    node\n  } = last;\n\n  if (!node) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT');\n  }\n\n  const link = node.Links.find(link => (link.Name || '').substring(0, 2) === prefix);\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${name}`), 'ERR_NOT_FOUND');\n  }\n\n  if (link.Name === `${prefix}${name}`) {\n    log(`Removing existing link ${link.Name}`);\n    const links = node.Links.filter(nodeLink => {\n      return nodeLink.Name !== link.Name;\n    });\n    await bucket.del(name);\n    return updateHamtDirectory(context, links, bucket, options);\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${name}`);\n  const result = await updateShard(context, positions, name, options);\n  let cid = result.cid;\n  let size = result.size;\n  let newName = prefix;\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`); // convert shard back to normal dir\n\n    const link = result.node.Links[0];\n    newName = `${prefix}${(link.Name || '').substring(2)}`;\n    cid = link.Hash;\n    size = link.Tsize || 0;\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`);\n  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options);\n};\n/**\n * @param {MfsContext} context\n * @param {Bucket} bucket\n * @param {PBNode} parent\n * @param {string} oldName\n * @param {string} newName\n * @param {number} size\n * @param {CID} cid\n * @param {RemoveLinkOptionsInternal} options\n */\n\n\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  // Remove existing link if it exists\n  const parentLinks = parent.Links.filter(link => {\n    return link.Name !== oldName;\n  });\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  });\n  return updateHamtDirectory(context, parentLinks, bucket, options);\n};\n\nmodule.exports = removeLink;","map":{"version":3,"names":["dagPb","require","CID","log","UnixFS","generatePath","updateHamtDirectory","errCode","removeLink","context","options","parent","parentCid","asCID","Error","block","repo","blocks","get","decode","name","Data","meta","unmarshal","type","removeFromShardedDirectory","removeFromDirectory","Links","filter","link","Name","parentBlock","encode","hasher","hashers","getHasher","hashAlg","hash","digest","create","cidVersion","code","put","node","cid","rootBucket","path","del","updateShard","positions","last","pop","bucket","prefix","find","substring","links","nodeLink","result","size","newName","length","Hash","Tsize","updateShardParent","oldName","parentLinks","push","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/utils/remove-link.js"],"sourcesContent":["'use strict'\n\n// @ts-ignore - TODO vmx 2021-03-31\nconst dagPb = require('@ipld/dag-pb')\nconst { CID } = require('multiformats/cid')\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link')\nconst { UnixFS } = require('ipfs-unixfs')\nconst {\n  generatePath,\n  updateHamtDirectory\n} = require('./hamt-utils')\nconst errCode = require('err-code')\n\n/**\n * @typedef {import('../').MfsContext} MfsContext\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('hamt-sharding').Bucket<any>} Bucket\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} RemoveLinkOptions\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {CID} [parentCid]\n * @property {PBNode} [parent]\n *\n * @typedef {object} RemoveLinkOptionsInternal\n * @property {string} name\n * @property {number} shardSplitThreshold\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {boolean} flush\n * @property {PBNode} parent\n */\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptions} options\n */\nconst removeLink = async (context, options) => {\n  let parent = options.parent\n\n  if (options.parentCid) {\n    const parentCid = CID.asCID(options.parentCid)\n    if (parentCid === null) {\n      throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID')\n    }\n\n    log(`Loading parent node ${parentCid}`)\n    const block = await context.repo.blocks.get(parentCid)\n    parent = dagPb.decode(block)\n  }\n\n  if (!parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT')\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME')\n  }\n\n  if (!parent.Data) {\n    throw errCode(new Error('Parent node had no data'), 'ERR_INVALID_NODE')\n  }\n\n  const meta = UnixFS.unmarshal(parent.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`)\n\n    return removeFromShardedDirectory(context, {\n      ...options,\n      parent\n    })\n  }\n\n  log(`Removing link ${options.name} regular directory`)\n\n  return removeFromDirectory(context, {\n    ...options,\n    parent\n  })\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromDirectory = async (context, options) => {\n  // Remove existing link if it exists\n  options.parent.Links = options.parent.Links.filter((link) => {\n    return link.Name !== options.name\n  })\n\n  const parentBlock = await dagPb.encode(options.parent)\n  const hasher = await context.hashers.getHasher(options.hashAlg)\n  const hash = await hasher.digest(parentBlock)\n  const parentCid = CID.create(options.cidVersion, dagPb.code, hash)\n\n  await context.repo.blocks.put(parentCid, parentBlock)\n\n  log(`Updated regular directory ${parentCid}`)\n\n  return {\n    node: options.parent,\n    cid: parentCid\n  }\n}\n\n/**\n * @param {MfsContext} context\n * @param {RemoveLinkOptionsInternal} options\n */\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket, path\n  } = await generatePath(context, options.name, options.parent)\n\n  await rootBucket.del(options.name)\n\n  const {\n    node\n  } = await updateShard(context, path, options.name, options)\n\n  return updateHamtDirectory(context, node.Links, rootBucket, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {{ bucket: Bucket, prefix: string, node?: PBNode }[]} positions\n * @param {string} name\n * @param {RemoveLinkOptionsInternal} options\n * @returns {Promise<{ node: PBNode, cid: CID, size: number }>}\n */\nconst updateShard = async (context, positions, name, options) => {\n  const last = positions.pop()\n\n  if (!last) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT')\n  }\n\n  const {\n    bucket,\n    prefix,\n    node\n  } = last\n\n  if (!node) {\n    throw errCode(new Error('Could not find parent'), 'EINVALIDPARENT')\n  }\n\n  const link = node.Links\n    .find(link => (link.Name || '').substring(0, 2) === prefix)\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${name}`), 'ERR_NOT_FOUND')\n  }\n\n  if (link.Name === `${prefix}${name}`) {\n    log(`Removing existing link ${link.Name}`)\n\n    const links = node.Links.filter((nodeLink) => {\n      return nodeLink.Name !== link.Name\n    })\n\n    await bucket.del(name)\n\n    return updateHamtDirectory(context, links, bucket, options)\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${name}`)\n\n  const result = await updateShard(context, positions, name, options)\n\n  let cid = result.cid\n  let size = result.size\n  let newName = prefix\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`)\n\n    // convert shard back to normal dir\n    const link = result.node.Links[0]\n\n    newName = `${prefix}${(link.Name || '').substring(2)}`\n    cid = link.Hash\n    size = link.Tsize || 0\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`)\n\n  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options)\n}\n\n/**\n * @param {MfsContext} context\n * @param {Bucket} bucket\n * @param {PBNode} parent\n * @param {string} oldName\n * @param {string} newName\n * @param {number} size\n * @param {CID} cid\n * @param {RemoveLinkOptionsInternal} options\n */\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  // Remove existing link if it exists\n  const parentLinks = parent.Links.filter((link) => {\n    return link.Name !== oldName\n  })\n  parentLinks.push({\n    Name: newName,\n    Tsize: size,\n    Hash: cid\n  })\n\n  return updateHamtDirectory(context, parentLinks, bucket, options)\n}\n\nmodule.exports = removeLink\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}