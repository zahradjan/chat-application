{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar errCode = require('err-code');\n\nvar updateTree = require('./utils/update-tree');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar removeLink = require('./utils/remove-link');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar toTrail = require('./utils/to-trail');\n\nvar withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nvar mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} recursive\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nvar defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  shardSplitThreshold: 1000\n};\n/**\n * @param {MfsContext} context\n */\n\nmodule.exports = function (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"rm\"]}\n   */\n  function mfsRm(_x) {\n    return _mfsRm.apply(this, arguments);\n  }\n\n  function _mfsRm() {\n    _mfsRm = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(paths) {\n      var opts,\n          options,\n          sources,\n          _iterator,\n          _step,\n          source,\n          _args = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n              /** @type {DefaultOptions} */\n              options = mergeOptions(defaultOptions, opts);\n\n              if (!Array.isArray(paths)) {\n                paths = [paths];\n              }\n\n              _context.next = 5;\n              return Promise.all(paths.map(function (path) {\n                return toMfsPath(context, path, options);\n              }));\n\n            case 5:\n              sources = _context.sent;\n\n              if (sources.length) {\n                _context.next = 8;\n                break;\n              }\n\n              throw errCode(new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS');\n\n            case 8:\n              sources.forEach(function (source) {\n                if (source.path === '/') {\n                  throw errCode(new Error('Cannot delete root'), 'ERR_INVALID_PARAMS');\n                }\n              });\n              _iterator = _createForOfIteratorHelper(sources);\n              _context.prev = 10;\n\n              _iterator.s();\n\n            case 12:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 18;\n                break;\n              }\n\n              source = _step.value;\n              _context.next = 16;\n              return removePath(context, source.path, options);\n\n            case 16:\n              _context.next = 12;\n              break;\n\n            case 18:\n              _context.next = 23;\n              break;\n\n            case 20:\n              _context.prev = 20;\n              _context.t0 = _context[\"catch\"](10);\n\n              _iterator.e(_context.t0);\n\n            case 23:\n              _context.prev = 23;\n\n              _iterator.f();\n\n              return _context.finish(23);\n\n            case 26:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[10, 20, 23, 26]]);\n    }));\n    return _mfsRm.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsRm);\n};\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {DefaultOptions} options\n */\n\n\nvar removePath = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(context, path, options) {\n    var mfsPath, trail, child, parent, _yield$removeLink, cid, newRootCid;\n\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return toMfsPath(context, path, options);\n\n          case 2:\n            mfsPath = _context2.sent;\n            _context2.next = 5;\n            return toTrail(context, mfsPath.mfsPath);\n\n          case 5:\n            trail = _context2.sent;\n            child = trail[trail.length - 1];\n            trail.pop();\n            parent = trail[trail.length - 1];\n\n            if (parent) {\n              _context2.next = 11;\n              break;\n            }\n\n            throw errCode(new Error(\"\".concat(path, \" does not exist\")), 'ERR_NOT_FOUND');\n\n          case 11:\n            if (!(child.type === 'directory' && !options.recursive)) {\n              _context2.next = 13;\n              break;\n            }\n\n            throw errCode(new Error(\"\".concat(path, \" is a directory, use -r to remove directories\")), 'ERR_WAS_DIR');\n\n          case 13:\n            _context2.next = 15;\n            return removeLink(context, {\n              parentCid: parent.cid,\n              name: child.name,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion,\n              flush: options.flush,\n              shardSplitThreshold: options.shardSplitThreshold\n            });\n\n          case 15:\n            _yield$removeLink = _context2.sent;\n            cid = _yield$removeLink.cid;\n            parent.cid = cid; // update the tree with the new child\n\n            _context2.next = 20;\n            return updateTree(context, trail, options);\n\n          case 20:\n            newRootCid = _context2.sent;\n            _context2.next = 23;\n            return updateMfsRoot(context, newRootCid, options);\n\n          case 23:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function removePath(_x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["errCode","require","updateTree","updateMfsRoot","removeLink","toMfsPath","toTrail","withTimeoutOption","mergeOptions","bind","ignoreUndefined","defaultOptions","recursive","cidVersion","hashAlg","flush","shardSplitThreshold","module","exports","context","mfsRm","paths","opts","options","Array","isArray","Promise","all","map","path","sources","length","Error","forEach","source","removePath","mfsPath","trail","child","pop","parent","type","parentCid","cid","name","newRootCid"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/rm.js"],"sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst removeLink = require('./utils/remove-link')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst toTrail = require('./utils/to-trail')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} recursive\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  shardSplitThreshold: 1000\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"rm\"]}\n   */\n  async function mfsRm (paths, opts = {}) {\n    /** @type {DefaultOptions} */\n    const options = mergeOptions(defaultOptions, opts)\n\n    if (!Array.isArray(paths)) {\n      paths = [paths]\n    }\n\n    const sources = await Promise.all(\n      paths.map(path => toMfsPath(context, path, options))\n    )\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS')\n    }\n\n    sources.forEach(source => {\n      if (source.path === '/') {\n        throw errCode(new Error('Cannot delete root'), 'ERR_INVALID_PARAMS')\n      }\n    })\n\n    for (const source of sources) {\n      await removePath(context, source.path, options)\n    }\n  }\n\n  return withTimeoutOption(mfsRm)\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {DefaultOptions} options\n */\nconst removePath = async (context, path, options) => {\n  const mfsPath = await toMfsPath(context, path, options)\n  const trail = await toTrail(context, mfsPath.mfsPath)\n  const child = trail[trail.length - 1]\n  trail.pop()\n  const parent = trail[trail.length - 1]\n\n  if (!parent) {\n    throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND')\n  }\n\n  if (child.type === 'directory' && !options.recursive) {\n    throw errCode(new Error(`${path} is a directory, use -r to remove directories`), 'ERR_WAS_DIR')\n  }\n\n  const {\n    cid\n  } = await removeLink(context, {\n    parentCid: parent.cid,\n    name: child.name,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  })\n\n  parent.cid = cid\n\n  // update the tree with the new child\n  const newRootCid = await updateTree(context, trail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}