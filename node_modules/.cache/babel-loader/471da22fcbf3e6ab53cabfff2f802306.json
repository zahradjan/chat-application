{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar _asyncGeneratorDelegate = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate.js\").default;\n\nvar _require = require('ipfs-unixfs-exporter'),\n    exporter = _require.exporter,\n    recursive = _require.recursive;\n\nvar errCode = require('err-code');\n\nvar _require2 = require('../utils'),\n    normalizeCidPath = _require2.normalizeCidPath;\n\nvar withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nvar _require3 = require('multiformats/cid'),\n    CID = _require3.CID;\n\nvar _require4 = require('it-tar'),\n    pack = _require4.pack;\n\nvar _require5 = require('it-pipe'),\n    pipe = _require5.pipe;\n\nvar _require6 = require('pako'),\n    gzip = _require6.gzip;\n\nvar map = require('it-map');\n\nvar toBuffer = require('it-to-buffer'); // https://www.gnu.org/software/gzip/manual/gzip.html\n\n\nvar DEFAULT_COMPRESSION_LEVEL = 6;\n/**\n * @typedef {Object} Context\n * @property {import('ipfs-repo').IPFSRepo} repo\n * @property {import('../types').Preload} preload\n *\n * @param {Context} context\n */\n\nmodule.exports = function (_ref4) {\n  var repo = _ref4.repo,\n      preload = _ref4.preload;\n\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"get\"]}\n   */\n  function get(_x) {\n    return _get.apply(this, arguments);\n  }\n\n  function _get() {\n    _get = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(ipfsPath) {\n      var options,\n          pathComponents,\n          ipfsPathOrCid,\n          file,\n          args,\n          _args2,\n          _args5 = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              options = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};\n\n              if (!(options.compressionLevel < 0 || options.compressionLevel > 9)) {\n                _context4.next = 3;\n                break;\n              }\n\n              throw errCode(new Error('Compression level must be between 1 and 9'), 'ERR_INVALID_PARAMS');\n\n            case 3:\n              if (!(options.preload !== false)) {\n                _context4.next = 12;\n                break;\n              }\n\n              _context4.prev = 4;\n              pathComponents = normalizeCidPath(ipfsPath).split('/');\n              _context4.next = 11;\n              break;\n\n            case 8:\n              _context4.prev = 8;\n              _context4.t0 = _context4[\"catch\"](4);\n              throw errCode(_context4.t0, 'ERR_INVALID_PATH');\n\n            case 11:\n              preload(CID.parse(pathComponents[0]));\n\n            case 12:\n              ipfsPathOrCid = CID.asCID(ipfsPath) || ipfsPath;\n              _context4.next = 15;\n              return _awaitAsyncGenerator(exporter(ipfsPathOrCid, repo.blocks, options));\n\n            case 15:\n              file = _context4.sent;\n\n              if (!(file.type === 'file' || file.type === 'raw')) {\n                _context4.next = 22;\n                break;\n              }\n\n              args = [];\n\n              if (!options.compress || options.archive === true) {\n                args.push([{\n                  header: {\n                    name: file.path,\n                    mode: file.type === 'file' && file.unixfs.mode,\n                    mtime: file.type === 'file' && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1000) : undefined,\n                    size: file.size,\n                    type: 'file'\n                  },\n                  body: file.content()\n                }], pack(),\n                /**\n                 * @param {AsyncIterable<Uint8Array>} source\n                 */\n                function (source) {\n                  return map(source, function (buf) {\n                    return buf.slice();\n                  });\n                });\n              } else {\n                args.push(file.content);\n              }\n\n              if (options.compress) {\n                args.push(\n                /*#__PURE__*/\n\n                /**\n                 * @param {AsyncIterable<Uint8Array>} source\n                 */\n                function () {\n                  var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n                    var buf;\n                    return _regeneratorRuntime().wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return _awaitAsyncGenerator(toBuffer(source));\n\n                          case 2:\n                            buf = _context.sent;\n                            _context.next = 5;\n                            return gzip(buf, {\n                              level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n                            });\n\n                          case 5:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x2) {\n                    return _ref.apply(this, arguments);\n                  };\n                }());\n              } // @ts-ignore cannot derive type\n\n\n              return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pipe.apply(void 0, args)), _awaitAsyncGenerator), \"t1\", 21);\n\n            case 21:\n              return _context4.abrupt(\"return\");\n\n            case 22:\n              if (!(file.type === 'directory')) {\n                _context4.next = 30;\n                break;\n              }\n\n              /** @type {any[]} */\n              _args2 = [recursive(ipfsPathOrCid, repo.blocks, options),\n              /*#__PURE__*/\n\n              /**\n               * @param {AsyncIterable<import('ipfs-unixfs-exporter').UnixFSEntry>} source\n               */\n              function () {\n                var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source) {\n                  var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry, output;\n\n                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          _iteratorAbruptCompletion = false;\n                          _didIteratorError = false;\n                          _context2.prev = 2;\n                          _iterator = _asyncIterator(source);\n\n                        case 4:\n                          _context2.next = 6;\n                          return _awaitAsyncGenerator(_iterator.next());\n\n                        case 6:\n                          if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n                            _context2.next = 33;\n                            break;\n                          }\n\n                          entry = _step.value;\n\n                          /** @type {import('it-tar').TarImportCandidate} */\n                          output = {\n                            header: {\n                              name: entry.path,\n                              size: entry.size\n                            }\n                          };\n\n                          if (!(entry.type === 'file')) {\n                            _context2.next = 16;\n                            break;\n                          }\n\n                          output.header.type = 'file';\n                          output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined;\n                          output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined;\n                          output.body = entry.content();\n                          _context2.next = 28;\n                          break;\n\n                        case 16:\n                          if (!(entry.type === 'raw')) {\n                            _context2.next = 21;\n                            break;\n                          }\n\n                          output.header.type = 'file';\n                          output.body = entry.content();\n                          _context2.next = 28;\n                          break;\n\n                        case 21:\n                          if (!(entry.type === 'directory')) {\n                            _context2.next = 27;\n                            break;\n                          }\n\n                          output.header.type = 'directory';\n                          output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined;\n                          output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined;\n                          _context2.next = 28;\n                          break;\n\n                        case 27:\n                          throw errCode(new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS');\n\n                        case 28:\n                          _context2.next = 30;\n                          return output;\n\n                        case 30:\n                          _iteratorAbruptCompletion = false;\n                          _context2.next = 4;\n                          break;\n\n                        case 33:\n                          _context2.next = 39;\n                          break;\n\n                        case 35:\n                          _context2.prev = 35;\n                          _context2.t0 = _context2[\"catch\"](2);\n                          _didIteratorError = true;\n                          _iteratorError = _context2.t0;\n\n                        case 39:\n                          _context2.prev = 39;\n                          _context2.prev = 40;\n\n                          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                            _context2.next = 44;\n                            break;\n                          }\n\n                          _context2.next = 44;\n                          return _awaitAsyncGenerator(_iterator.return());\n\n                        case 44:\n                          _context2.prev = 44;\n\n                          if (!_didIteratorError) {\n                            _context2.next = 47;\n                            break;\n                          }\n\n                          throw _iteratorError;\n\n                        case 47:\n                          return _context2.finish(44);\n\n                        case 48:\n                          return _context2.finish(39);\n\n                        case 49:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2, null, [[2, 35, 39, 49], [40,, 44, 48]]);\n                }));\n\n                return function (_x3) {\n                  return _ref2.apply(this, arguments);\n                };\n              }(), pack(),\n              /**\n               * @param {AsyncIterable<Uint8Array>} source\n               */\n              function (source) {\n                return map(source, function (buf) {\n                  return buf.slice();\n                });\n              }];\n\n              if (!options.compress) {\n                _context4.next = 28;\n                break;\n              }\n\n              if (options.archive) {\n                _context4.next = 27;\n                break;\n              }\n\n              throw errCode(new Error('file is not regular'), 'ERR_INVALID_PATH');\n\n            case 27:\n              if (options.compress) {\n                _args2.push(\n                /*#__PURE__*/\n\n                /**\n                 * @param {AsyncIterable<Uint8Array>} source\n                 */\n                function () {\n                  var _ref3 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(source) {\n                    var buf;\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            _context3.next = 2;\n                            return _awaitAsyncGenerator(toBuffer(source));\n\n                          case 2:\n                            buf = _context3.sent;\n                            _context3.next = 5;\n                            return gzip(buf, {\n                              level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n                            });\n\n                          case 5:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }));\n\n                  return function (_x4) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }());\n              }\n\n            case 28:\n              return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pipe.apply(void 0, _args2)), _awaitAsyncGenerator), \"t2\", 29);\n\n            case 29:\n              return _context4.abrupt(\"return\");\n\n            case 30:\n              throw errCode(new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS');\n\n            case 31:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, null, [[4, 8]]);\n    }));\n    return _get.apply(this, arguments);\n  }\n\n  return withTimeoutOption(get);\n};","map":{"version":3,"names":["require","exporter","recursive","errCode","normalizeCidPath","withTimeoutOption","CID","pack","pipe","gzip","map","toBuffer","DEFAULT_COMPRESSION_LEVEL","module","exports","repo","preload","get","ipfsPath","options","compressionLevel","Error","pathComponents","split","parse","ipfsPathOrCid","asCID","blocks","file","type","args","compress","archive","push","header","name","path","mode","unixfs","mtime","Date","secs","undefined","size","body","content","source","buf","slice","level","entry","output"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/get.js"],"sourcesContent":["'use strict'\n\nconst { exporter, recursive } = require('ipfs-unixfs-exporter')\nconst errCode = require('err-code')\nconst { normalizeCidPath } = require('../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { CID } = require('multiformats/cid')\nconst { pack } = require('it-tar')\nconst { pipe } = require('it-pipe')\nconst { gzip } = require('pako')\nconst map = require('it-map')\nconst toBuffer = require('it-to-buffer')\n\n// https://www.gnu.org/software/gzip/manual/gzip.html\nconst DEFAULT_COMPRESSION_LEVEL = 6\n\n/**\n * @typedef {Object} Context\n * @property {import('ipfs-repo').IPFSRepo} repo\n * @property {import('../types').Preload} preload\n *\n * @param {Context} context\n */\nmodule.exports = function ({ repo, preload }) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"get\"]}\n   */\n  async function * get (ipfsPath, options = {}) {\n    if (options.compressionLevel < 0 || options.compressionLevel > 9) {\n      throw errCode(new Error('Compression level must be between 1 and 9'), 'ERR_INVALID_PARAMS')\n    }\n\n    if (options.preload !== false) {\n      let pathComponents\n\n      try {\n        pathComponents = normalizeCidPath(ipfsPath).split('/')\n      } catch (err) {\n        throw errCode(err, 'ERR_INVALID_PATH')\n      }\n\n      preload(CID.parse(pathComponents[0]))\n    }\n\n    const ipfsPathOrCid = CID.asCID(ipfsPath) || ipfsPath\n    const file = await exporter(ipfsPathOrCid, repo.blocks, options)\n\n    if (file.type === 'file' || file.type === 'raw') {\n      const args = []\n\n      if (!options.compress || options.archive === true) {\n        args.push([{\n          header: {\n            name: file.path,\n            mode: file.type === 'file' && file.unixfs.mode,\n            mtime: file.type === 'file' && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1000) : undefined,\n            size: file.size,\n            type: 'file'\n          },\n          body: file.content()\n        }],\n        pack(),\n        /**\n         * @param {AsyncIterable<Uint8Array>} source\n         */\n        (source) => map(source, buf => buf.slice())\n        )\n      } else {\n        args.push(\n          file.content\n        )\n      }\n\n      if (options.compress) {\n        args.push(\n          /**\n           * @param {AsyncIterable<Uint8Array>} source\n           */\n          async function * (source) {\n            const buf = await toBuffer(source)\n\n            yield gzip(buf, {\n              level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n            })\n          }\n        )\n      }\n\n      // @ts-ignore cannot derive type\n      yield * pipe(...args)\n\n      return\n    }\n\n    if (file.type === 'directory') {\n      /** @type {any[]} */\n      const args = [\n        recursive(ipfsPathOrCid, repo.blocks, options),\n        /**\n         * @param {AsyncIterable<import('ipfs-unixfs-exporter').UnixFSEntry>} source\n         */\n        async function * (source) {\n          for await (const entry of source) {\n            /** @type {import('it-tar').TarImportCandidate} */\n            const output = {\n              header: {\n                name: entry.path,\n                size: entry.size\n              }\n            }\n\n            if (entry.type === 'file') {\n              output.header.type = 'file'\n              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined\n              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined\n              output.body = entry.content()\n            } else if (entry.type === 'raw') {\n              output.header.type = 'file'\n              output.body = entry.content()\n            } else if (entry.type === 'directory') {\n              output.header.type = 'directory'\n              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined\n              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined\n            } else {\n              throw errCode(new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS')\n            }\n\n            yield output\n          }\n        },\n        pack(),\n        /**\n         * @param {AsyncIterable<Uint8Array>} source\n         */\n        (source) => map(source, buf => buf.slice())\n      ]\n\n      if (options.compress) {\n        if (!options.archive) {\n          throw errCode(new Error('file is not regular'), 'ERR_INVALID_PATH')\n        }\n\n        if (options.compress) {\n          args.push(\n            /**\n             * @param {AsyncIterable<Uint8Array>} source\n             */\n            async function * (source) {\n              const buf = await toBuffer(source)\n\n              yield gzip(buf, {\n                level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n              })\n            }\n          )\n        }\n      }\n\n      // @ts-ignore cannot derive type\n      yield * pipe(...args)\n\n      return\n    }\n\n    throw errCode(new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS')\n  }\n\n  return withTimeoutOption(get)\n}\n"],"mappings":"AAAA;;;;;;;;;;;;AAEA,eAAgCA,OAAO,CAAC,sBAAD,CAAvC;AAAA,IAAQC,QAAR,YAAQA,QAAR;AAAA,IAAkBC,SAAlB,YAAkBA,SAAlB;;AACA,IAAMC,OAAO,GAAGH,OAAO,CAAC,UAAD,CAAvB;;AACA,gBAA6BA,OAAO,CAAC,UAAD,CAApC;AAAA,IAAQI,gBAAR,aAAQA,gBAAR;;AACA,IAAMC,iBAAiB,GAAGL,OAAO,CAAC,yCAAD,CAAjC;;AACA,gBAAgBA,OAAO,CAAC,kBAAD,CAAvB;AAAA,IAAQM,GAAR,aAAQA,GAAR;;AACA,gBAAiBN,OAAO,CAAC,QAAD,CAAxB;AAAA,IAAQO,IAAR,aAAQA,IAAR;;AACA,gBAAiBP,OAAO,CAAC,SAAD,CAAxB;AAAA,IAAQQ,IAAR,aAAQA,IAAR;;AACA,gBAAiBR,OAAO,CAAC,MAAD,CAAxB;AAAA,IAAQS,IAAR,aAAQA,IAAR;;AACA,IAAMC,GAAG,GAAGV,OAAO,CAAC,QAAD,CAAnB;;AACA,IAAMW,QAAQ,GAAGX,OAAO,CAAC,cAAD,CAAxB,C,CAEA;;;AACA,IAAMY,yBAAyB,GAAG,CAAlC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAC,MAAM,CAACC,OAAP,GAAiB,iBAA6B;EAAA,IAAjBC,IAAiB,SAAjBA,IAAiB;EAAA,IAAXC,OAAW,SAAXA,OAAW;;EAC5C;AACF;AACA;EAH8C,SAI3BC,GAJ2B;IAAA;EAAA;;EAAA;IAAA,oEAI5C,kBAAsBC,QAAtB;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;;MAAA;QAAA;UAAA;YAAA;cAAgCC,OAAhC,8DAA0C,EAA1C;;cAAA,MACMA,OAAO,CAACC,gBAAR,GAA2B,CAA3B,IAAgCD,OAAO,CAACC,gBAAR,GAA2B,CADjE;gBAAA;gBAAA;cAAA;;cAAA,MAEUjB,OAAO,CAAC,IAAIkB,KAAJ,CAAU,2CAAV,CAAD,EAAyD,oBAAzD,CAFjB;;YAAA;cAAA,MAKMF,OAAO,CAACH,OAAR,KAAoB,KAL1B;gBAAA;gBAAA;cAAA;;cAAA;cASMM,cAAc,GAAGlB,gBAAgB,CAACc,QAAD,CAAhB,CAA2BK,KAA3B,CAAiC,GAAjC,CAAjB;cATN;cAAA;;YAAA;cAAA;cAAA;cAAA,MAWYpB,OAAO,eAAM,kBAAN,CAXnB;;YAAA;cAcIa,OAAO,CAACV,GAAG,CAACkB,KAAJ,CAAUF,cAAc,CAAC,CAAD,CAAxB,CAAD,CAAP;;YAdJ;cAiBQG,aAjBR,GAiBwBnB,GAAG,CAACoB,KAAJ,CAAUR,QAAV,KAAuBA,QAjB/C;cAAA;cAAA,4BAkBqBjB,QAAQ,CAACwB,aAAD,EAAgBV,IAAI,CAACY,MAArB,EAA6BR,OAA7B,CAlB7B;;YAAA;cAkBQS,IAlBR;;cAAA,MAoBMA,IAAI,CAACC,IAAL,KAAc,MAAd,IAAwBD,IAAI,CAACC,IAAL,KAAc,KApB5C;gBAAA;gBAAA;cAAA;;cAqBUC,IArBV,GAqBiB,EArBjB;;cAuBI,IAAI,CAACX,OAAO,CAACY,QAAT,IAAqBZ,OAAO,CAACa,OAAR,KAAoB,IAA7C,EAAmD;gBACjDF,IAAI,CAACG,IAAL,CAAU,CAAC;kBACTC,MAAM,EAAE;oBACNC,IAAI,EAAEP,IAAI,CAACQ,IADL;oBAENC,IAAI,EAAET,IAAI,CAACC,IAAL,KAAc,MAAd,IAAwBD,IAAI,CAACU,MAAL,CAAYD,IAFpC;oBAGNE,KAAK,EAAEX,IAAI,CAACC,IAAL,KAAc,MAAd,IAAwBD,IAAI,CAACU,MAAL,CAAYC,KAApC,GAA4C,IAAIC,IAAJ,CAASZ,IAAI,CAACU,MAAL,CAAYC,KAAZ,CAAkBE,IAAlB,GAAyB,IAAlC,CAA5C,GAAsFC,SAHvF;oBAINC,IAAI,EAAEf,IAAI,CAACe,IAJL;oBAKNd,IAAI,EAAE;kBALA,CADC;kBAQTe,IAAI,EAAEhB,IAAI,CAACiB,OAAL;gBARG,CAAD,CAAV,EAUAtC,IAAI,EAVJ;gBAWA;AACR;AACA;gBACQ,UAACuC,MAAD;kBAAA,OAAYpC,GAAG,CAACoC,MAAD,EAAS,UAAAC,GAAG;oBAAA,OAAIA,GAAG,CAACC,KAAJ,EAAJ;kBAAA,CAAZ,CAAf;gBAAA,CAdA;cAgBD,CAjBD,MAiBO;gBACLlB,IAAI,CAACG,IAAL,CACEL,IAAI,CAACiB,OADP;cAGD;;cAED,IAAI1B,OAAO,CAACY,QAAZ,EAAsB;gBACpBD,IAAI,CAACG,IAAL;gBAAA;;gBACE;AACV;AACA;gBAHQ;kBAAA,wEAIE,iBAAkBa,MAAlB;oBAAA;oBAAA;sBAAA;wBAAA;0BAAA;4BAAA;4BAAA,4BACoBnC,QAAQ,CAACmC,MAAD,CAD5B;;0BAAA;4BACQC,GADR;4BAAA;4BAGE,OAAMtC,IAAI,CAACsC,GAAD,EAAM;8BACdE,KAAK,EAAE9B,OAAO,CAACC,gBAAR,IAA4BR;4BADrB,CAAN,CAAV;;0BAHF;0BAAA;4BAAA;wBAAA;sBAAA;oBAAA;kBAAA,CAJF;;kBAAA;oBAAA;kBAAA;gBAAA;cAYD,CA3DL,CA6DI;;;cACA,sEAAQJ,IAAI,MAAJ,SAAQsB,IAAR,CAAR;;YA9DJ;cAAA;;YAAA;cAAA,MAmEMF,IAAI,CAACC,IAAL,KAAc,WAnEpB;gBAAA;gBAAA;cAAA;;cAoEI;cACMC,MArEV,GAqEiB,CACX5B,SAAS,CAACuB,aAAD,EAAgBV,IAAI,CAACY,MAArB,EAA6BR,OAA7B,CADE;cAAA;;cAEX;AACR;AACA;cAJmB;gBAAA,yEAKX,kBAAkB2B,MAAlB;kBAAA;;kBAAA;oBAAA;sBAAA;wBAAA;0BAAA;0BAAA;0BAAA;0BAAA,2BAC4BA,MAD5B;;wBAAA;0BAAA;0BAAA;;wBAAA;0BAAA;4BAAA;4BAAA;0BAAA;;0BACmBI,KADnB;;0BAEI;0BACMC,MAHV,GAGmB;4BACbjB,MAAM,EAAE;8BACNC,IAAI,EAAEe,KAAK,CAACd,IADN;8BAENO,IAAI,EAAEO,KAAK,CAACP;4BAFN;0BADK,CAHnB;;0BAAA,MAUQO,KAAK,CAACrB,IAAN,KAAe,MAVvB;4BAAA;4BAAA;0BAAA;;0BAWMsB,MAAM,CAACjB,MAAP,CAAcL,IAAd,GAAqB,MAArB;0BACAsB,MAAM,CAACjB,MAAP,CAAcG,IAAd,GAAqBa,KAAK,CAACZ,MAAN,CAAaD,IAAb,IAAqB,IAArB,GAA4Ba,KAAK,CAACZ,MAAN,CAAaD,IAAzC,GAAgDK,SAArE;0BACAS,MAAM,CAACjB,MAAP,CAAcK,KAAd,GAAsBW,KAAK,CAACZ,MAAN,CAAaC,KAAb,GAAqB,IAAIC,IAAJ,CAASU,KAAK,CAACZ,MAAN,CAAaC,KAAb,CAAmBE,IAAnB,GAA0B,IAAnC,CAArB,GAAgEC,SAAtF;0BACAS,MAAM,CAACP,IAAP,GAAcM,KAAK,CAACL,OAAN,EAAd;0BAdN;0BAAA;;wBAAA;0BAAA,MAeeK,KAAK,CAACrB,IAAN,KAAe,KAf9B;4BAAA;4BAAA;0BAAA;;0BAgBMsB,MAAM,CAACjB,MAAP,CAAcL,IAAd,GAAqB,MAArB;0BACAsB,MAAM,CAACP,IAAP,GAAcM,KAAK,CAACL,OAAN,EAAd;0BAjBN;0BAAA;;wBAAA;0BAAA,MAkBeK,KAAK,CAACrB,IAAN,KAAe,WAlB9B;4BAAA;4BAAA;0BAAA;;0BAmBMsB,MAAM,CAACjB,MAAP,CAAcL,IAAd,GAAqB,WAArB;0BACAsB,MAAM,CAACjB,MAAP,CAAcG,IAAd,GAAqBa,KAAK,CAACZ,MAAN,CAAaD,IAAb,IAAqB,IAArB,GAA4Ba,KAAK,CAACZ,MAAN,CAAaD,IAAzC,GAAgDK,SAArE;0BACAS,MAAM,CAACjB,MAAP,CAAcK,KAAd,GAAsBW,KAAK,CAACZ,MAAN,CAAaC,KAAb,GAAqB,IAAIC,IAAJ,CAASU,KAAK,CAACZ,MAAN,CAAaC,KAAb,CAAmBE,IAAnB,GAA0B,IAAnC,CAArB,GAAgEC,SAAtF;0BArBN;0BAAA;;wBAAA;0BAAA,MAuBYvC,OAAO,CAAC,IAAIkB,KAAJ,CAAU,mBAAV,CAAD,EAAiC,gBAAjC,CAvBnB;;wBAAA;0BAAA;0BA0BI,OAAM8B,MAAN;;wBA1BJ;0BAAA;0BAAA;0BAAA;;wBAAA;0BAAA;0BAAA;;wBAAA;0BAAA;0BAAA;0BAAA;0BAAA;;wBAAA;0BAAA;0BAAA;;0BAAA;4BAAA;4BAAA;0BAAA;;0BAAA;0BAAA;;wBAAA;0BAAA;;0BAAA;4BAAA;4BAAA;0BAAA;;0BAAA;;wBAAA;0BAAA;;wBAAA;0BAAA;;wBAAA;wBAAA;0BAAA;sBAAA;oBAAA;kBAAA;gBAAA,CALW;;gBAAA;kBAAA;gBAAA;cAAA,KAkCX5C,IAAI,EAlCO;cAmCX;AACR;AACA;cACQ,UAACuC,MAAD;gBAAA,OAAYpC,GAAG,CAACoC,MAAD,EAAS,UAAAC,GAAG;kBAAA,OAAIA,GAAG,CAACC,KAAJ,EAAJ;gBAAA,CAAZ,CAAf;cAAA,CAtCW,CArEjB;;cAAA,KA8GQ7B,OAAO,CAACY,QA9GhB;gBAAA;gBAAA;cAAA;;cAAA,IA+GWZ,OAAO,CAACa,OA/GnB;gBAAA;gBAAA;cAAA;;cAAA,MAgHc7B,OAAO,CAAC,IAAIkB,KAAJ,CAAU,qBAAV,CAAD,EAAmC,kBAAnC,CAhHrB;;YAAA;cAmHM,IAAIF,OAAO,CAACY,QAAZ,EAAsB;gBACpBD,MAAI,CAACG,IAAL;gBAAA;;gBACE;AACZ;AACA;gBAHU;kBAAA,yEAIE,kBAAkBa,MAAlB;oBAAA;oBAAA;sBAAA;wBAAA;0BAAA;4BAAA;4BAAA,4BACoBnC,QAAQ,CAACmC,MAAD,CAD5B;;0BAAA;4BACQC,GADR;4BAAA;4BAGE,OAAMtC,IAAI,CAACsC,GAAD,EAAM;8BACdE,KAAK,EAAE9B,OAAO,CAACC,gBAAR,IAA4BR;4BADrB,CAAN,CAAV;;0BAHF;0BAAA;4BAAA;wBAAA;sBAAA;oBAAA;kBAAA,CAJF;;kBAAA;oBAAA;kBAAA;gBAAA;cAYD;;YAhIP;cAoII,sEAAQJ,IAAI,MAAJ,SAAQsB,MAAR,CAAR;;YApIJ;cAAA;;YAAA;cAAA,MAyIQ3B,OAAO,CAAC,IAAIkB,KAAJ,CAAU,mBAAV,CAAD,EAAiC,gBAAjC,CAzIf;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAJ4C;IAAA;EAAA;;EAgJ5C,OAAOhB,iBAAiB,CAACY,GAAD,CAAxB;AACD,CAjJD"},"metadata":{},"sourceType":"script"}