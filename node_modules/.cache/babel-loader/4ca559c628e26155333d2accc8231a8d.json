{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:peer-routing'), {\n  error: debug('libp2p:peer-routing:err')\n});\n\nconst errCode = require('err-code');\n\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers\n} = require('./content-routing/utils');\n\nconst merge = require('it-merge');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst first = require('it-first');\n\nconst drain = require('it-drain');\n\nconst filter = require('it-filter');\n\nconst {\n  setDelayedInterval,\n  clearDelayedInterval // @ts-ignore module with no types\n\n} = require('set-delayed-interval');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n */\n\n/**\n * @typedef {Object} RefreshManagerOptions\n * @property {boolean} [enabled = true] - Whether to enable the Refresh manager\n * @property {number} [bootDelay = 6e5] - Boot delay to start the Refresh Manager (in ms)\n * @property {number} [interval = 10e3] - Interval between each Refresh Manager run (in ms)\n *\n * @typedef {Object} PeerRoutingOptions\n * @property {RefreshManagerOptions} [refreshManager]\n */\n\n\nclass PeerRouting {\n  /**\n   * @class\n   * @param {import('./')} libp2p\n   */\n  constructor(libp2p) {\n    this._peerId = libp2p.peerId;\n    this._peerStore = libp2p.peerStore;\n    /** @type {PeerRoutingModule[]} */\n\n    this._routers = libp2p._modules.peerRouting || []; // If we have the dht, add it to the available peer routers\n\n    if (libp2p._dht && libp2p._config.dht.enabled) {\n      this._routers.push(libp2p._dht);\n    }\n\n    this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager;\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);\n  }\n  /**\n   * Start peer routing service.\n   */\n\n\n  start() {\n    if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {\n      return;\n    }\n\n    this._timeoutId = setDelayedInterval(this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay);\n  }\n  /**\n   * Recurrent task to find closest peers and add their addresses to the Address Book.\n   */\n\n\n  async _findClosestPeersTask() {\n    try {\n      // nb getClosestPeers adds the addresses to the address book\n      await drain(this.getClosestPeers(this._peerId.id));\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Stop peer routing service.\n   */\n\n\n  stop() {\n    clearDelayedInterval(this._timeoutId);\n  }\n  /**\n   * Iterates over all peer routers in parallel to find the given peer.\n   *\n   * @param {PeerId} id - The id of the peer to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  async findPeer(id, options) {\n    // eslint-disable-line require-await\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE');\n    }\n\n    if (id.toB58String() === this._peerId.toB58String()) {\n      throw errCode(new Error('Should not try to find self'), 'ERR_FIND_SELF');\n    }\n\n    const output = await pipe(merge(...this._routers.map(router => [router.findPeer(id, options)])), source => filter(source, Boolean), // @ts-ignore findPeer resolves a Promise\n    source => storeAddresses(source, this._peerStore), source => first(source));\n\n    if (output) {\n      return output;\n    }\n\n    throw errCode(new Error('not found'), 'NOT_FOUND');\n  }\n  /**\n   * Attempt to find the closest peers on the network to the given key.\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {Object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  async *getClosestPeers(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      timeout: 30e3\n    };\n\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE');\n    }\n\n    yield* pipe(merge(...this._routers.map(router => router.getClosestPeers(key, options))), source => storeAddresses(source, this._peerStore), source => uniquePeers(source), source => requirePeers(source));\n  }\n\n}\n\nmodule.exports = PeerRouting;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errCode","storeAddresses","uniquePeers","requirePeers","merge","pipe","first","drain","filter","setDelayedInterval","clearDelayedInterval","PeerRouting","constructor","libp2p","_peerId","peerId","_peerStore","peerStore","_routers","_modules","peerRouting","_dht","_config","dht","enabled","push","_refreshManagerOptions","_options","refreshManager","_findClosestPeersTask","bind","start","length","_timeoutId","interval","bootDelay","getClosestPeers","id","err","stop","findPeer","options","Error","toB58String","output","map","router","source","Boolean","key","timeout","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/peer-routing.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:peer-routing'), {\n  error: debug('libp2p:peer-routing:err')\n})\nconst errCode = require('err-code')\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers\n} = require('./content-routing/utils')\n\nconst merge = require('it-merge')\nconst { pipe } = require('it-pipe')\nconst first = require('it-first')\nconst drain = require('it-drain')\nconst filter = require('it-filter')\nconst {\n  setDelayedInterval,\n  clearDelayedInterval\n// @ts-ignore module with no types\n} = require('set-delayed-interval')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n */\n\n/**\n * @typedef {Object} RefreshManagerOptions\n * @property {boolean} [enabled = true] - Whether to enable the Refresh manager\n * @property {number} [bootDelay = 6e5] - Boot delay to start the Refresh Manager (in ms)\n * @property {number} [interval = 10e3] - Interval between each Refresh Manager run (in ms)\n *\n * @typedef {Object} PeerRoutingOptions\n * @property {RefreshManagerOptions} [refreshManager]\n */\n\nclass PeerRouting {\n  /**\n   * @class\n   * @param {import('./')} libp2p\n   */\n  constructor (libp2p) {\n    this._peerId = libp2p.peerId\n    this._peerStore = libp2p.peerStore\n    /** @type {PeerRoutingModule[]} */\n    this._routers = libp2p._modules.peerRouting || []\n\n    // If we have the dht, add it to the available peer routers\n    if (libp2p._dht && libp2p._config.dht.enabled) {\n      this._routers.push(libp2p._dht)\n    }\n\n    this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager\n\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this)\n  }\n\n  /**\n   * Start peer routing service.\n   */\n  start () {\n    if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {\n      return\n    }\n\n    this._timeoutId = setDelayedInterval(\n      this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay\n    )\n  }\n\n  /**\n   * Recurrent task to find closest peers and add their addresses to the Address Book.\n   */\n  async _findClosestPeersTask () {\n    try {\n      // nb getClosestPeers adds the addresses to the address book\n      await drain(this.getClosestPeers(this._peerId.id))\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Stop peer routing service.\n   */\n  stop () {\n    clearDelayedInterval(this._timeoutId)\n  }\n\n  /**\n   * Iterates over all peer routers in parallel to find the given peer.\n   *\n   * @param {PeerId} id - The id of the peer to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async findPeer (id, options) { // eslint-disable-line require-await\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE')\n    }\n\n    if (id.toB58String() === this._peerId.toB58String()) {\n      throw errCode(new Error('Should not try to find self'), 'ERR_FIND_SELF')\n    }\n\n    const output = await pipe(\n      merge(\n        ...this._routers.map(router => [router.findPeer(id, options)])\n      ),\n      (source) => filter(source, Boolean),\n      // @ts-ignore findPeer resolves a Promise\n      (source) => storeAddresses(source, this._peerStore),\n      (source) => first(source)\n    )\n\n    if (output) {\n      return output\n    }\n\n    throw errCode(new Error('not found'), 'NOT_FOUND')\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key.\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {Object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async * getClosestPeers (key, options = { timeout: 30e3 }) {\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE')\n    }\n\n    yield * pipe(\n      merge(\n        ...this._routers.map(router => router.getClosestPeers(key, options))\n      ),\n      (source) => storeAddresses(source, this._peerStore),\n      (source) => uniquePeers(source),\n      (source) => requirePeers(source)\n    )\n  }\n}\n\nmodule.exports = PeerRouting\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}