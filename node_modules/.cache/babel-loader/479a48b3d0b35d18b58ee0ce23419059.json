{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar errcode = require('err-code');\n\nvar pTimeout = require('p-timeout');\n\nvar PeerId = require('peer-id');\n\nvar crypto = require('libp2p-crypto');\n\nvar _require = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require.toString;\n\nvar c = require('../constants');\n\nvar Message = require('../message');\n\nvar Query = require('../query');\n\nvar utils = require('../utils');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {import('../index')} dht\n */\n\n\nmodule.exports = function (dht) {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   */\n  var findPeerLocal = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(peer) {\n      var p, peerData;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              dht._log(\"findPeerLocal \".concat(peer.toB58String()));\n\n              _context.next = 3;\n              return dht.routingTable.find(peer);\n\n            case 3:\n              p = _context.sent;\n\n              /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n              peerData = p && dht.peerStore.get(p);\n\n              if (!peerData) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt(\"return\", {\n                id: peerData.id,\n                multiaddrs: peerData.addresses.map(function (address) {\n                  return address.multiaddr;\n                })\n              });\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function findPeerLocal(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n\n\n  var getValueSingle = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peer, key) {\n      var msg;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              // eslint-disable-line require-await\n              msg = new Message(Message.TYPES.GET_VALUE, key, 0);\n              return _context2.abrupt(\"return\", dht.network.sendRequest(peer, msg));\n\n            case 2:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function getValueSingle(_x2, _x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * Find close peers for a given peer\n   *\n   * @param {Uint8Array} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}\n   * @private\n   */\n\n\n  var closerPeersSingle = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key, peer) {\n      var msg;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              dht._log(\"closerPeersSingle \".concat(uint8ArrayToString(key, 'base32'), \" from \").concat(peer.toB58String()));\n\n              _context3.next = 3;\n              return dht.peerRouting._findPeerSingle(peer, new PeerId(key));\n\n            case 3:\n              msg = _context3.sent;\n              return _context3.abrupt(\"return\", msg.closerPeers.filter(function (peerData) {\n                return !dht._isSelf(peerData.id);\n              }).map(function (peerData) {\n                dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs);\n                return peerData;\n              }));\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function closerPeersSingle(_x4, _x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  var getPublicKeyFromNode = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(peer) {\n      var pkKey, msg, recPeer;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              pkKey = utils.keyForPublicKey(peer);\n              _context4.next = 3;\n              return getValueSingle(peer, pkKey);\n\n            case 3:\n              msg = _context4.sent;\n\n              if (!(!msg.record || !msg.record.value)) {\n                _context4.next = 6;\n                break;\n              }\n\n              throw errcode(new Error(\"Node not responding with its public key: \".concat(peer.toB58String())), 'ERR_INVALID_RECORD');\n\n            case 6:\n              _context4.next = 8;\n              return PeerId.createFromPubKey(msg.record.value);\n\n            case 8:\n              recPeer = _context4.sent;\n\n              if (recPeer.equals(peer)) {\n                _context4.next = 11;\n                break;\n              }\n\n              throw errcode(new Error('public key does not match id'), 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n\n            case 11:\n              return _context4.abrupt(\"return\", recPeer.pubKey);\n\n            case 12:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function getPublicKeyFromNode(_x6) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  return {\n    /**\n     * Ask peer `peer` if they know where the peer with id `target` is.\n     *\n     * @param {PeerId} peer\n     * @param {PeerId} target\n     * @returns {Promise<Message>}\n     * @private\n     */\n    _findPeerSingle: function _findPeerSingle(peer, target) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var msg;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                // eslint-disable-line require-await\n                dht._log('findPeerSingle %s', peer.toB58String());\n\n                msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);\n                return _context5.abrupt(\"return\", dht.network.sendRequest(peer, msg));\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     *\n     * @param {PeerId} id\n     * @param {Object} [options] - findPeer options\n     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    findPeer: function findPeer(id) {\n      var _arguments = arguments,\n          _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var options, pi, key, peers, match, peer, query, result, success, peerData;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {\n                  timeout: 60000\n                };\n                options.timeout = options.timeout || c.minute;\n\n                dht._log('findPeer %s', id.toB58String()); // Try to find locally\n\n\n                _context7.next = 5;\n                return findPeerLocal(id);\n\n              case 5:\n                pi = _context7.sent;\n\n                if (!(pi != null)) {\n                  _context7.next = 9;\n                  break;\n                }\n\n                dht._log('found local');\n\n                return _context7.abrupt(\"return\", pi);\n\n              case 9:\n                _context7.next = 11;\n                return utils.convertPeerId(id);\n\n              case 11:\n                key = _context7.sent;\n                peers = dht.routingTable.closestPeers(key, dht.kBucketSize);\n\n                if (!(peers.length === 0)) {\n                  _context7.next = 15;\n                  break;\n                }\n\n                throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED');\n\n              case 15:\n                // sanity check\n                match = peers.find(function (p) {\n                  return p.isEqual(id);\n                });\n\n                if (!match) {\n                  _context7.next = 21;\n                  break;\n                }\n\n                /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n                peer = dht.peerStore.get(id);\n\n                if (!peer) {\n                  _context7.next = 21;\n                  break;\n                }\n\n                dht._log('found in peerStore');\n\n                return _context7.abrupt(\"return\", {\n                  id: peer.id,\n                  multiaddrs: peer.addresses.map(function (address) {\n                    return address.multiaddr;\n                  })\n                });\n\n              case 21:\n                // query the network\n                query = new Query(dht, id.id, function () {\n                  /**\n                   * There is no distinction between the disjoint paths, so there are no per-path\n                   * variables in dht scope. Just return the actual query function.\n                   *\n                   * @param {PeerId} peer\n                   */\n                  var queryFn = /*#__PURE__*/function () {\n                    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(peer) {\n                      var msg, match;\n                      return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                        while (1) {\n                          switch (_context6.prev = _context6.next) {\n                            case 0:\n                              _context6.next = 2;\n                              return _this._findPeerSingle(peer, id);\n\n                            case 2:\n                              msg = _context6.sent;\n                              match = msg.closerPeers.find(function (p) {\n                                return p.id.isEqual(id);\n                              }); // found it\n\n                              if (!match) {\n                                _context6.next = 6;\n                                break;\n                              }\n\n                              return _context6.abrupt(\"return\", {\n                                peer: match,\n                                queryComplete: true\n                              });\n\n                            case 6:\n                              return _context6.abrupt(\"return\", {\n                                closerPeers: msg.closerPeers\n                              });\n\n                            case 7:\n                            case \"end\":\n                              return _context6.stop();\n                          }\n                        }\n                      }, _callee6);\n                    }));\n\n                    return function queryFn(_x7) {\n                      return _ref5.apply(this, arguments);\n                    };\n                  }();\n\n                  return queryFn;\n                });\n                _context7.prev = 22;\n                _context7.next = 25;\n                return pTimeout(query.run(peers), options.timeout);\n\n              case 25:\n                result = _context7.sent;\n\n              case 26:\n                _context7.prev = 26;\n                query.stop();\n                return _context7.finish(26);\n\n              case 29:\n                success = false;\n                result.paths.forEach(function (result) {\n                  if (result.success && result.peer) {\n                    success = true;\n                    dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs);\n                  }\n                });\n\n                dht._log('findPeer %s: %s', id.toB58String(), success);\n\n                if (success) {\n                  _context7.next = 34;\n                  break;\n                }\n\n                throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND');\n\n              case 34:\n                /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n                peerData = dht.peerStore.get(id);\n\n                if (peerData) {\n                  _context7.next = 37;\n                  break;\n                }\n\n                throw errcode(new Error('No peer found in peer store'), 'ERR_NOT_FOUND');\n\n              case 37:\n                return _context7.abrupt(\"return\", {\n                  id: peerData.id,\n                  multiaddrs: peerData.addresses.map(function (address) {\n                    return address.multiaddr;\n                  })\n                });\n\n              case 38:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, null, [[22,, 26, 29]]);\n      }))();\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     *\n     * @param {Uint8Array} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow=false] - shallow query\n     * @returns {AsyncIterable<PeerId>}\n     */\n    getClosestPeers: function getClosestPeers(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shallow: false\n      };\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var id, tablePeers, q, res, sorted, _iterator, _step, pId;\n\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                dht._log('getClosestPeers to %b', key);\n\n                _context9.next = 3;\n                return _awaitAsyncGenerator(utils.convertBuffer(key));\n\n              case 3:\n                id = _context9.sent;\n                tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize);\n                q = new Query(dht, key, function () {\n                  // There is no distinction between the disjoint paths,\n                  // so there are no per-path variables in dht scope.\n                  // Just return the actual query function.\n                  return /*#__PURE__*/function () {\n                    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(peer) {\n                      var closer;\n                      return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n                        while (1) {\n                          switch (_context8.prev = _context8.next) {\n                            case 0:\n                              _context8.next = 2;\n                              return closerPeersSingle(key, peer);\n\n                            case 2:\n                              closer = _context8.sent;\n                              return _context8.abrupt(\"return\", {\n                                closerPeers: closer,\n                                pathComplete: options.shallow ? true : undefined\n                              });\n\n                            case 4:\n                            case \"end\":\n                              return _context8.stop();\n                          }\n                        }\n                      }, _callee8);\n                    }));\n\n                    return function (_x8) {\n                      return _ref6.apply(this, arguments);\n                    };\n                  }();\n                });\n                _context9.next = 8;\n                return _awaitAsyncGenerator(q.run(tablePeers));\n\n              case 8:\n                res = _context9.sent;\n\n                if (!(!res || !res.finalSet)) {\n                  _context9.next = 11;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", []);\n\n              case 11:\n                _context9.next = 13;\n                return _awaitAsyncGenerator(utils.sortClosestPeers(Array.from(res.finalSet), id));\n\n              case 13:\n                sorted = _context9.sent;\n                _iterator = _createForOfIteratorHelper(sorted.slice(0, dht.kBucketSize));\n                _context9.prev = 15;\n\n                _iterator.s();\n\n              case 17:\n                if ((_step = _iterator.n()).done) {\n                  _context9.next = 23;\n                  break;\n                }\n\n                pId = _step.value;\n                _context9.next = 21;\n                return pId;\n\n              case 21:\n                _context9.next = 17;\n                break;\n\n              case 23:\n                _context9.next = 28;\n                break;\n\n              case 25:\n                _context9.prev = 25;\n                _context9.t0 = _context9[\"catch\"](15);\n\n                _iterator.e(_context9.t0);\n\n              case 28:\n                _context9.prev = 28;\n\n                _iterator.f();\n\n                return _context9.finish(28);\n\n              case 31:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, null, [[15, 25, 28, 31]]);\n      }))();\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     *\n     * @param {PeerId} peer\n     */\n    getPublicKey: function getPublicKey(peer) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var peerData, pk, pkKey, value, peerId, addrs;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                dht._log('getPublicKey %s', peer.toB58String()); // local check\n\n                /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n\n\n                peerData = dht.peerStore.get(peer);\n\n                if (!(peerData && peerData.id.pubKey)) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                dht._log('getPublicKey: found local copy');\n\n                return _context10.abrupt(\"return\", peerData.id.pubKey);\n\n              case 5:\n                _context10.prev = 5;\n                _context10.next = 8;\n                return getPublicKeyFromNode(peer);\n\n              case 8:\n                pk = _context10.sent;\n                _context10.next = 18;\n                break;\n\n              case 11:\n                _context10.prev = 11;\n                _context10.t0 = _context10[\"catch\"](5);\n                // try dht directly\n                pkKey = utils.keyForPublicKey(peer);\n                _context10.next = 16;\n                return dht.get(pkKey);\n\n              case 16:\n                value = _context10.sent;\n                pk = crypto.keys.unmarshalPublicKey(value);\n\n              case 18:\n                peerId = new PeerId(peer.id, undefined, pk);\n                addrs = (peerData && peerData.addresses || []).map(function (address) {\n                  return address.multiaddr;\n                });\n                dht.peerStore.addressBook.add(peerId, addrs);\n                dht.peerStore.keyBook.set(peerId, pk);\n                return _context10.abrupt(\"return\", pk);\n\n              case 23:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, null, [[5, 11]]);\n      }))();\n    }\n  };\n};","map":{"version":3,"names":["errcode","require","pTimeout","PeerId","crypto","uint8ArrayToString","toString","c","Message","Query","utils","module","exports","dht","findPeerLocal","peer","_log","toB58String","routingTable","find","p","peerData","peerStore","get","id","multiaddrs","addresses","map","address","multiaddr","getValueSingle","key","msg","TYPES","GET_VALUE","network","sendRequest","closerPeersSingle","peerRouting","_findPeerSingle","closerPeers","filter","_isSelf","addressBook","add","getPublicKeyFromNode","pkKey","keyForPublicKey","record","value","Error","createFromPubKey","recPeer","equals","pubKey","target","FIND_NODE","findPeer","options","timeout","minute","pi","convertPeerId","peers","closestPeers","kBucketSize","length","match","isEqual","query","queryFn","queryComplete","run","result","stop","success","paths","forEach","getClosestPeers","shallow","convertBuffer","tablePeers","q","closer","pathComplete","undefined","res","finalSet","sortClosestPeers","Array","from","sorted","slice","pId","getPublicKey","pk","keys","unmarshalPublicKey","peerId","addrs","keyBook","set"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-kad-dht/src/peer-routing/index.js"],"sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\n\nconst PeerId = require('peer-id')\nconst crypto = require('libp2p-crypto')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst c = require('../constants')\nconst Message = require('../message')\nconst Query = require('../query')\n\nconst utils = require('../utils')\n\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {import('../index')} dht\n */\nmodule.exports = (dht) => {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   */\n  const findPeerLocal = async (peer) => {\n    dht._log(`findPeerLocal ${peer.toB58String()}`)\n    const p = await dht.routingTable.find(peer)\n\n    /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n    const peerData = p && dht.peerStore.get(p)\n\n    if (peerData) {\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n      }\n    }\n  }\n\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n  const getValueSingle = async (peer, key) => { // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0)\n    return dht.network.sendRequest(peer, msg)\n  }\n\n  /**\n   * Find close peers for a given peer\n   *\n   * @param {Uint8Array} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}\n   * @private\n   */\n\n  const closerPeersSingle = async (key, peer) => {\n    dht._log(`closerPeersSingle ${uint8ArrayToString(key, 'base32')} from ${peer.toB58String()}`)\n    const msg = await dht.peerRouting._findPeerSingle(peer, new PeerId(key))\n\n    return msg.closerPeers\n      .filter((peerData) => !dht._isSelf(peerData.id))\n      .map((peerData) => {\n        dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs)\n\n        return peerData\n      })\n  }\n\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   */\n  const getPublicKeyFromNode = async (peer) => {\n    const pkKey = utils.keyForPublicKey(peer)\n    const msg = await getValueSingle(peer, pkKey)\n\n    if (!msg.record || !msg.record.value) {\n      throw errcode(new Error(`Node not responding with its public key: ${peer.toB58String()}`), 'ERR_INVALID_RECORD')\n    }\n\n    const recPeer = await PeerId.createFromPubKey(msg.record.value)\n\n    // compare hashes of the pub key\n    if (!recPeer.equals(peer)) {\n      throw errcode(new Error('public key does not match id'), 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID')\n    }\n\n    return recPeer.pubKey\n  }\n\n  return {\n  /**\n   * Ask peer `peer` if they know where the peer with id `target` is.\n   *\n   * @param {PeerId} peer\n   * @param {PeerId} target\n   * @returns {Promise<Message>}\n   * @private\n   */\n    async _findPeerSingle (peer, target) { // eslint-disable-line require-await\n      dht._log('findPeerSingle %s', peer.toB58String())\n      const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0)\n\n      return dht.network.sendRequest(peer, msg)\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     *\n     * @param {PeerId} id\n     * @param {Object} [options] - findPeer options\n     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async findPeer (id, options = { timeout: 60000 }) {\n      options.timeout = options.timeout || c.minute\n      dht._log('findPeer %s', id.toB58String())\n\n      // Try to find locally\n      const pi = await findPeerLocal(id)\n\n      // already got it\n      if (pi != null) {\n        dht._log('found local')\n        return pi\n      }\n\n      const key = await utils.convertPeerId(id)\n      const peers = dht.routingTable.closestPeers(key, dht.kBucketSize)\n\n      if (peers.length === 0) {\n        throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED')\n      }\n\n      // sanity check\n      const match = peers.find((p) => p.isEqual(id))\n      if (match) {\n        /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n        const peer = dht.peerStore.get(id)\n\n        if (peer) {\n          dht._log('found in peerStore')\n          return {\n            id: peer.id,\n            multiaddrs: peer.addresses.map((address) => address.multiaddr)\n          }\n        }\n      }\n\n      // query the network\n      const query = new Query(dht, id.id, () => {\n        /**\n         * There is no distinction between the disjoint paths, so there are no per-path\n         * variables in dht scope. Just return the actual query function.\n         *\n         * @param {PeerId} peer\n         */\n        const queryFn = async (peer) => {\n          const msg = await this._findPeerSingle(peer, id)\n          const match = msg.closerPeers.find((p) => p.id.isEqual(id))\n\n          // found it\n          if (match) {\n            return {\n              peer: match,\n              queryComplete: true\n            }\n          }\n\n          return {\n            closerPeers: msg.closerPeers\n          }\n        }\n\n        return queryFn\n      })\n\n      let result\n      try {\n        result = await pTimeout(query.run(peers), options.timeout)\n      } finally {\n        query.stop()\n      }\n\n      let success = false\n      result.paths.forEach((result) => {\n        if (result.success && result.peer) {\n          success = true\n          dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs)\n        }\n      })\n      dht._log('findPeer %s: %s', id.toB58String(), success)\n\n      if (!success) {\n        throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND')\n      }\n\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n      const peerData = dht.peerStore.get(id)\n\n      if (!peerData) {\n        throw errcode(new Error('No peer found in peer store'), 'ERR_NOT_FOUND')\n      }\n\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n      }\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     *\n     * @param {Uint8Array} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow=false] - shallow query\n     * @returns {AsyncIterable<PeerId>}\n     */\n    async * getClosestPeers (key, options = { shallow: false }) {\n      dht._log('getClosestPeers to %b', key)\n\n      const id = await utils.convertBuffer(key)\n      const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize)\n\n      const q = new Query(dht, key, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async (peer) => {\n          const closer = await closerPeersSingle(key, peer)\n\n          return {\n            closerPeers: closer,\n            pathComplete: options.shallow ? true : undefined\n          }\n        }\n      })\n\n      const res = await q.run(tablePeers)\n      if (!res || !res.finalSet) {\n        return []\n      }\n\n      const sorted = await utils.sortClosestPeers(Array.from(res.finalSet), id)\n\n      for (const pId of sorted.slice(0, dht.kBucketSize)) {\n        yield pId\n      }\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     *\n     * @param {PeerId} peer\n     */\n    async getPublicKey (peer) {\n      dht._log('getPublicKey %s', peer.toB58String())\n\n      // local check\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n      const peerData = dht.peerStore.get(peer)\n\n      if (peerData && peerData.id.pubKey) {\n        dht._log('getPublicKey: found local copy')\n        return peerData.id.pubKey\n      }\n\n      // try the node directly\n      let pk\n\n      try {\n        pk = await getPublicKeyFromNode(peer)\n      } catch (err) {\n        // try dht directly\n        const pkKey = utils.keyForPublicKey(peer)\n        const value = await dht.get(pkKey)\n        pk = crypto.keys.unmarshalPublicKey(value)\n      }\n\n      const peerId = new PeerId(peer.id, undefined, pk)\n      const addrs = ((peerData && peerData.addresses) || []).map((address) => address.multiaddr)\n      dht.peerStore.addressBook.add(peerId, addrs)\n      dht.peerStore.keyBook.set(peerId, pk)\n\n      return pk\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}