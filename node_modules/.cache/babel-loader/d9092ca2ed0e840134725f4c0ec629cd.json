{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst PeerId = require('peer-id'); // @ts-ignore no types\n\n\nconst isDomain = require('is-domain-name');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst log = Object.assign(debug('ipfs:name:resolve'), {\n  error: debug('ipfs:name:resolve:error')\n});\n\nconst {\n  OFFLINE_ERROR\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\n\n\nconst appendRemainder = (result, remainder) => remainder.length > 0 ? result + '/' + remainder.join('/') : result;\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('ipfs-core-types/src/root').API[\"dns\"]} config.dns\n * @param {import('../ipns')} config.ipns\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('../../types').Options} config.options\n */\n\n\nmodule.exports = _ref => {\n  let {\n    dns,\n    ipns,\n    peerId,\n    isOnline,\n    options: {\n      offline\n    }\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"resolve\"]}\n   */\n  async function* resolve(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options); // TODO: params related logic should be in the core implementation\n\n    if (offline && options && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');\n    } // Set node id as name for being resolved, if it is not received\n\n\n    if (!name) {\n      name = peerId.toB58String();\n    }\n\n    if (!name.startsWith('/ipns/')) {\n      name = `/ipns/${name}`;\n    }\n\n    const [namespace, hash, ...remainder] = name.slice(1).split('/');\n\n    try {\n      if (hash.substring(0, 1) === '1') {\n        PeerId.parse(hash);\n      } else {\n        CID.parse(hash);\n      }\n    } catch (err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder(await dns(hash, options), remainder);\n        return;\n      }\n\n      log.error(err);\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');\n    } // multihash is valid lets resolve with IPNS\n    // IPNS resolve needs a online daemon\n\n\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n    } // TODO: convert ipns.resolve to return an iterator\n\n\n    const value = await ipns.resolve(`/${namespace}/${hash}`, options);\n    yield appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder);\n  }\n\n  return withTimeoutOption(resolve);\n};","map":{"version":3,"names":["debug","require","errcode","mergeOptions","bind","ignoreUndefined","CID","PeerId","isDomain","toString","uint8ArrayToString","log","Object","assign","error","OFFLINE_ERROR","withTimeoutOption","appendRemainder","result","remainder","length","join","module","exports","dns","ipns","peerId","isOnline","options","offline","resolve","name","nocache","recursive","Error","toB58String","startsWith","namespace","hash","slice","split","substring","parse","err","value","Uint8Array"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/name/resolve.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst errcode = require('err-code')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst { CID } = require('multiformats/cid')\nconst PeerId = require('peer-id')\n// @ts-ignore no types\nconst isDomain = require('is-domain-name')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst log = Object.assign(debug('ipfs:name:resolve'), {\n  error: debug('ipfs:name:resolve:error')\n})\n\nconst { OFFLINE_ERROR } = require('../../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\nconst appendRemainder = (result, remainder) =>\n  remainder.length > 0\n    ? result + '/' + remainder.join('/')\n    : result\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('ipfs-core-types/src/root').API[\"dns\"]} config.dns\n * @param {import('../ipns')} config.ipns\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('../../types').Options} config.options\n */\nmodule.exports = ({ dns, ipns, peerId, isOnline, options: { offline } }) => {\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"resolve\"]}\n   */\n  async function * resolve (name, options = {}) { // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options)\n\n    // TODO: params related logic should be in the core implementation\n    if (offline && options && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE')\n    }\n\n    // Set node id as name for being resolved, if it is not received\n    if (!name) {\n      name = peerId.toB58String()\n    }\n\n    if (!name.startsWith('/ipns/')) {\n      name = `/ipns/${name}`\n    }\n\n    const [namespace, hash, ...remainder] = name.slice(1).split('/')\n    try {\n      if (hash.substring(0, 1) === '1') {\n        PeerId.parse(hash)\n      } else {\n        CID.parse(hash)\n      }\n    } catch (err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder(await dns(hash, options), remainder)\n        return\n      }\n\n      log.error(err)\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME')\n    }\n\n    // multihash is valid lets resolve with IPNS\n    // IPNS resolve needs a online daemon\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    // TODO: convert ipns.resolve to return an iterator\n    const value = await ipns.resolve(`/${namespace}/${hash}`, options)\n    yield appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder)\n  }\n\n  return withTimeoutOption(resolve)\n}\n"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,eAAD,CAAP,CAAyBG,IAAzB,CAA8B;EAAEC,eAAe,EAAE;AAAnB,CAA9B,CAArB;;AACA,MAAM;EAAEC;AAAF,IAAUL,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAMM,MAAM,GAAGN,OAAO,CAAC,SAAD,CAAtB,C,CACA;;;AACA,MAAMO,QAAQ,GAAGP,OAAO,CAAC,gBAAD,CAAxB;;AACA,MAAM;EAAEQ,QAAQ,EAAEC;AAAZ,IAAmCT,OAAO,CAAC,uBAAD,CAAhD;;AAEA,MAAMU,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcb,KAAK,CAAC,mBAAD,CAAnB,EAA0C;EACpDc,KAAK,EAAEd,KAAK,CAAC,yBAAD;AADwC,CAA1C,CAAZ;;AAIA,MAAM;EAAEe;AAAF,IAAoBd,OAAO,CAAC,aAAD,CAAjC;;AACA,MAAMe,iBAAiB,GAAGf,OAAO,CAAC,yCAAD,CAAjC;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMgB,eAAe,GAAG,CAACC,MAAD,EAASC,SAAT,KACtBA,SAAS,CAACC,MAAV,GAAmB,CAAnB,GACIF,MAAM,GAAG,GAAT,GAAeC,SAAS,CAACE,IAAV,CAAe,GAAf,CADnB,GAEIH,MAHN;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAI,MAAM,CAACC,OAAP,GAAiB,QAA2D;EAAA,IAA1D;IAAEC,GAAF;IAAOC,IAAP;IAAaC,MAAb;IAAqBC,QAArB;IAA+BC,OAAO,EAAE;MAAEC;IAAF;EAAxC,CAA0D;;EAC1E;AACF;AACA;EACE,gBAAiBC,OAAjB,CAA0BC,IAA1B,EAA8C;IAAA,IAAdH,OAAc,uEAAJ,EAAI;IAAE;IAC9CA,OAAO,GAAGzB,YAAY,CAAC;MACrB6B,OAAO,EAAE,KADY;MAErBC,SAAS,EAAE;IAFU,CAAD,EAGnBL,OAHmB,CAAtB,CAD4C,CAM5C;;IACA,IAAIC,OAAO,IAAID,OAAX,IAAsBA,OAAO,CAACI,OAAlC,EAA2C;MACzC,MAAM9B,OAAO,CAAC,IAAIgC,KAAJ,CAAU,yCAAV,CAAD,EAAuD,yBAAvD,CAAb;IACD,CAT2C,CAW5C;;;IACA,IAAI,CAACH,IAAL,EAAW;MACTA,IAAI,GAAGL,MAAM,CAACS,WAAP,EAAP;IACD;;IAED,IAAI,CAACJ,IAAI,CAACK,UAAL,CAAgB,QAAhB,CAAL,EAAgC;MAC9BL,IAAI,GAAI,SAAQA,IAAK,EAArB;IACD;;IAED,MAAM,CAACM,SAAD,EAAYC,IAAZ,EAAkB,GAAGnB,SAArB,IAAkCY,IAAI,CAACQ,KAAL,CAAW,CAAX,EAAcC,KAAd,CAAoB,GAApB,CAAxC;;IACA,IAAI;MACF,IAAIF,IAAI,CAACG,SAAL,CAAe,CAAf,EAAkB,CAAlB,MAAyB,GAA7B,EAAkC;QAChClC,MAAM,CAACmC,KAAP,CAAaJ,IAAb;MACD,CAFD,MAEO;QACLhC,GAAG,CAACoC,KAAJ,CAAUJ,IAAV;MACD;IACF,CAND,CAME,OAAOK,GAAP,EAAY;MACZ;MACA,IAAInC,QAAQ,CAAC8B,IAAD,CAAZ,EAAoB;QAClB,MAAMrB,eAAe,CAAC,MAAMO,GAAG,CAACc,IAAD,EAAOV,OAAP,CAAV,EAA2BT,SAA3B,CAArB;QACA;MACD;;MAEDR,GAAG,CAACG,KAAJ,CAAU6B,GAAV;MACA,MAAMzC,OAAO,CAAC,IAAIgC,KAAJ,CAAU,mBAAV,CAAD,EAAiC,uBAAjC,CAAb;IACD,CApC2C,CAsC5C;IACA;;;IACA,IAAI,CAACP,QAAQ,EAAT,IAAe,CAACE,OAApB,EAA6B;MAC3B,MAAM3B,OAAO,CAAC,IAAIgC,KAAJ,CAAUnB,aAAV,CAAD,EAA2B,eAA3B,CAAb;IACD,CA1C2C,CA4C5C;;;IACA,MAAM6B,KAAK,GAAG,MAAMnB,IAAI,CAACK,OAAL,CAAc,IAAGO,SAAU,IAAGC,IAAK,EAAnC,EAAsCV,OAAtC,CAApB;IACA,MAAMX,eAAe,CAAC2B,KAAK,YAAYC,UAAjB,GAA8BnC,kBAAkB,CAACkC,KAAD,CAAhD,GAA0DA,KAA3D,EAAkEzB,SAAlE,CAArB;EACD;;EAED,OAAOH,iBAAiB,CAACc,OAAD,CAAxB;AACD,CAtDD"},"metadata":{},"sourceType":"script"}