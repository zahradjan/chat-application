{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar errcode = require('err-code');\n\nvar _require = require('uint8arrays/equals'),\n    uint8ArrayEquals = _require.equals;\n\nvar _require2 = require('multiformats/hashes/sha2'),\n    sha256 = _require2.sha256;\n\nvar _require3 = require('multiformats/bases/base58'),\n    base58btc = _require3.base58btc;\n\nvar _require4 = require('multiformats/hashes/identity'),\n    identity = _require4.identity;\n\nvar crypto = require('./ed25519');\n\nvar pbm = require('./keys');\n\nvar exporter = require('./exporter');\n\nvar Ed25519PublicKey = /*#__PURE__*/function () {\n  function Ed25519PublicKey(key) {\n    _classCallCheck(this, Ed25519PublicKey);\n\n    this._key = ensureKey(key, crypto.publicKeyLength);\n  }\n\n  _createClass(Ed25519PublicKey, [{\n    key: \"verify\",\n    value: function () {\n      var _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data, sig) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", crypto.hashAndVerify(this._key, sig, data));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function verify(_x, _x2) {\n        return _verify.apply(this, arguments);\n      }\n\n      return verify;\n    }()\n  }, {\n    key: \"marshal\",\n    value: function marshal() {\n      return this._key;\n    }\n  }, {\n    key: \"bytes\",\n    get: function get() {\n      return pbm.PublicKey.encode({\n        Type: pbm.KeyType.Ed25519,\n        Data: this.marshal()\n      }).finish();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(key) {\n      return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n  }, {\n    key: \"hash\",\n    value: function () {\n      var _hash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _yield$sha256$digest, bytes;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return sha256.digest(this.bytes);\n\n              case 2:\n                _yield$sha256$digest = _context2.sent;\n                bytes = _yield$sha256$digest.bytes;\n                return _context2.abrupt(\"return\", bytes);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function hash() {\n        return _hash.apply(this, arguments);\n      }\n\n      return hash;\n    }()\n  }]);\n\n  return Ed25519PublicKey;\n}();\n\nvar Ed25519PrivateKey = /*#__PURE__*/function () {\n  // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n  function Ed25519PrivateKey(key, publicKey) {\n    _classCallCheck(this, Ed25519PrivateKey);\n\n    this._key = ensureKey(key, crypto.privateKeyLength);\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength);\n  }\n\n  _createClass(Ed25519PrivateKey, [{\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(message) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", crypto.hashAndSign(this._key, message));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function sign(_x3) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n  }, {\n    key: \"public\",\n    get: function get() {\n      return new Ed25519PublicKey(this._publicKey);\n    }\n  }, {\n    key: \"marshal\",\n    value: function marshal() {\n      return this._key;\n    }\n  }, {\n    key: \"bytes\",\n    get: function get() {\n      return pbm.PrivateKey.encode({\n        Type: pbm.KeyType.Ed25519,\n        Data: this.marshal()\n      }).finish();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(key) {\n      return uint8ArrayEquals(this.bytes, key.bytes);\n    }\n  }, {\n    key: \"hash\",\n    value: function () {\n      var _hash2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _yield$sha256$digest2, bytes;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return sha256.digest(this.bytes);\n\n              case 2:\n                _yield$sha256$digest2 = _context4.sent;\n                bytes = _yield$sha256$digest2.bytes;\n                return _context4.abrupt(\"return\", bytes);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function hash() {\n        return _hash2.apply(this, arguments);\n      }\n\n      return hash;\n    }()\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the identity multihash containing its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @returns {Promise<string>}\n     */\n\n  }, {\n    key: \"id\",\n    value: function () {\n      var _id = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var encoding;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return identity.digest(this.public.bytes);\n\n              case 2:\n                encoding = _context5.sent;\n                return _context5.abrupt(\"return\", base58btc.encode(encoding.bytes).substring(1));\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function id() {\n        return _id.apply(this, arguments);\n      }\n\n      return id;\n    }()\n    /**\n     * Exports the key into a password protected `format`\n     *\n     * @param {string} password - The password to encrypt the key\n     * @param {string} [format=libp2p-key] - The format in which to export as\n     * @returns {Promise<Uint8Array>} The encrypted private key\n     */\n\n  }, {\n    key: \"export\",\n    value: function () {\n      var _export2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(password) {\n        var format,\n            _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                format = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : 'libp2p-key';\n\n                if (!(format === 'libp2p-key')) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", exporter.export(this.bytes, password));\n\n              case 5:\n                throw errcode(new Error(\"export format '\".concat(format, \"' is not supported\")), 'ERR_INVALID_EXPORT_FORMAT');\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _export(_x4) {\n        return _export2.apply(this, arguments);\n      }\n\n      return _export;\n    }()\n  }]);\n\n  return Ed25519PrivateKey;\n}();\n\nfunction unmarshalEd25519PrivateKey(bytes) {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength);\n\n    var _privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);\n\n    var _publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length);\n\n    return new Ed25519PrivateKey(_privateKeyBytes, _publicKeyBytes);\n  }\n\n  bytes = ensureKey(bytes, crypto.privateKeyLength);\n  var privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);\n  var publicKeyBytes = bytes.slice(crypto.publicKeyLength);\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n}\n\nfunction unmarshalEd25519PublicKey(bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength);\n  return new Ed25519PublicKey(bytes);\n}\n\nfunction generateKeyPair() {\n  return _generateKeyPair.apply(this, arguments);\n}\n\nfunction _generateKeyPair() {\n  _generateKeyPair = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n    var _yield$crypto$generat, privateKey, publicKey;\n\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return crypto.generateKey();\n\n          case 2:\n            _yield$crypto$generat = _context7.sent;\n            privateKey = _yield$crypto$generat.privateKey;\n            publicKey = _yield$crypto$generat.publicKey;\n            return _context7.abrupt(\"return\", new Ed25519PrivateKey(privateKey, publicKey));\n\n          case 6:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _generateKeyPair.apply(this, arguments);\n}\n\nfunction generateKeyPairFromSeed(_x5) {\n  return _generateKeyPairFromSeed.apply(this, arguments);\n}\n\nfunction _generateKeyPairFromSeed() {\n  _generateKeyPairFromSeed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(seed) {\n    var _yield$crypto$generat2, privateKey, publicKey;\n\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return crypto.generateKeyFromSeed(seed);\n\n          case 2:\n            _yield$crypto$generat2 = _context8.sent;\n            privateKey = _yield$crypto$generat2.privateKey;\n            publicKey = _yield$crypto$generat2.publicKey;\n            return _context8.abrupt(\"return\", new Ed25519PrivateKey(privateKey, publicKey));\n\n          case 6:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _generateKeyPairFromSeed.apply(this, arguments);\n}\n\nfunction ensureKey(key, length) {\n  key = Uint8Array.from(key || []);\n\n  if (key.length !== length) {\n    throw errcode(new Error(\"Key must be a Uint8Array of length \".concat(length, \", got \").concat(key.length)), 'ERR_INVALID_KEY_TYPE');\n  }\n\n  return key;\n}\n\nmodule.exports = {\n  Ed25519PublicKey: Ed25519PublicKey,\n  Ed25519PrivateKey: Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey: unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey: unmarshalEd25519PublicKey,\n  generateKeyPair: generateKeyPair,\n  generateKeyPairFromSeed: generateKeyPairFromSeed\n};","map":{"version":3,"names":["errcode","require","uint8ArrayEquals","equals","sha256","base58btc","identity","crypto","pbm","exporter","Ed25519PublicKey","key","_key","ensureKey","publicKeyLength","data","sig","hashAndVerify","PublicKey","encode","Type","KeyType","Ed25519","Data","marshal","finish","bytes","digest","Ed25519PrivateKey","publicKey","privateKeyLength","_publicKey","message","hashAndSign","PrivateKey","public","encoding","substring","password","format","export","Error","unmarshalEd25519PrivateKey","length","privateKeyBytes","slice","publicKeyBytes","unmarshalEd25519PublicKey","generateKeyPair","generateKey","privateKey","generateKeyPairFromSeed","seed","generateKeyFromSeed","Uint8Array","from","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-crypto/src/keys/ed25519-class.js"],"sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst { base58btc } = require('multiformats/bases/base58')\nconst { identity } = require('multiformats/hashes/identity')\nconst crypto = require('./ed25519')\nconst pbm = require('./keys')\nconst exporter = require('./exporter')\n\nclass Ed25519PublicKey {\n  constructor (key) {\n    this._key = ensureKey(key, crypto.publicKeyLength)\n  }\n\n  async verify (data, sig) { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal () {\n    return this._key\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).finish()\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n}\n\nclass Ed25519PrivateKey {\n  // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n  constructor (key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength)\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength)\n  }\n\n  async sign (message) { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public () {\n    return new Ed25519PublicKey(this._publicKey)\n  }\n\n  marshal () {\n    return this._key\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).finish()\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the identity multihash containing its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n  async id () {\n    const encoding = await identity.digest(this.public.bytes)\n    return base58btc.encode(encoding.bytes).substring(1)\n  }\n\n  /**\n   * Exports the key into a password protected `format`\n   *\n   * @param {string} password - The password to encrypt the key\n   * @param {string} [format=libp2p-key] - The format in which to export as\n   * @returns {Promise<Uint8Array>} The encrypted private key\n   */\n  async export (password, format = 'libp2p-key') { // eslint-disable-line require-await\n    if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password)\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nfunction unmarshalEd25519PrivateKey (bytes) {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength)\n    const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength)\n    const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length)\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n  }\n\n  bytes = ensureKey(bytes, crypto.privateKeyLength)\n  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength)\n  const publicKeyBytes = bytes.slice(crypto.publicKeyLength)\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n}\n\nfunction unmarshalEd25519PublicKey (bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength)\n  return new Ed25519PublicKey(bytes)\n}\n\nasync function generateKeyPair () {\n  const { privateKey, publicKey } = await crypto.generateKey()\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nasync function generateKeyPairFromSeed (seed) {\n  const { privateKey, publicKey } = await crypto.generateKeyFromSeed(seed)\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nfunction ensureKey (key, length) {\n  key = Uint8Array.from(key || [])\n  if (key.length !== length) {\n    throw errcode(new Error(`Key must be a Uint8Array of length ${length}, got ${key.length}`), 'ERR_INVALID_KEY_TYPE')\n  }\n  return key\n}\n\nmodule.exports = {\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey,\n  generateKeyPair,\n  generateKeyPairFromSeed\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}