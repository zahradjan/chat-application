{"ast":null,"code":"'use strict';\n\nconst crypto = require('libp2p-crypto');\n\nconst Buffer = require('safe-buffer/').Buffer;\n\nmodule.exports = {\n  verify: async (signature, publicKey, data) => {\n    if (!signature) {\n      throw new Error('No signature given');\n    }\n\n    if (!publicKey) {\n      throw new Error('Given publicKey was undefined');\n    }\n\n    if (!data) {\n      throw new Error('Given input data was undefined');\n    }\n\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data);\n    }\n\n    const isValid = (key, msg, sig) => new Promise((resolve, reject) => {\n      key.verify(msg, sig, (err, valid) => {\n        if (!err) {\n          resolve(valid);\n        }\n\n        reject(valid);\n      });\n    });\n\n    let res = false;\n\n    try {\n      const pubKey = crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(Buffer.from(publicKey, 'hex'));\n      res = await isValid(pubKey, data, Buffer.from(signature, 'hex'));\n    } catch (e) {// Catch error: sig length wrong\n    }\n\n    return Promise.resolve(res);\n  }\n};","map":{"version":3,"names":["crypto","require","Buffer","module","exports","verify","signature","publicKey","data","Error","isBuffer","from","isValid","key","msg","sig","Promise","resolve","reject","err","valid","res","pubKey","keys","supportedKeys","secp256k1","unmarshalSecp256k1PublicKey","e"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-keystore/src/verifiers/verifierv1.js"],"sourcesContent":["'use strict'\nconst crypto = require('libp2p-crypto')\nconst Buffer = require('safe-buffer/').Buffer\n\nmodule.exports = {\n  verify: async (signature, publicKey, data) => {\n    if (!signature) {\n      throw new Error('No signature given')\n    }\n    if (!publicKey) {\n      throw new Error('Given publicKey was undefined')\n    }\n    if (!data) {\n      throw new Error('Given input data was undefined')\n    }\n\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data)\n    }\n\n    const isValid = (key, msg, sig) => new Promise((resolve, reject) => {\n      key.verify(msg, sig, (err, valid) => {\n        if (!err) {\n          resolve(valid)\n        }\n        reject(valid)\n      })\n    })\n\n    let res = false\n    try {\n      const pubKey = crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(Buffer.from(publicKey, 'hex'))\n      res = await isValid(pubKey, data, Buffer.from(signature, 'hex'))\n    } catch (e) {\n      // Catch error: sig length wrong\n    }\n    return Promise.resolve(res)\n  }\n}\n"],"mappings":"AAAA;;AACA,MAAMA,MAAM,GAAGC,OAAO,CAAC,eAAD,CAAtB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,cAAD,CAAP,CAAwBC,MAAvC;;AAEAC,MAAM,CAACC,OAAP,GAAiB;EACfC,MAAM,EAAE,OAAOC,SAAP,EAAkBC,SAAlB,EAA6BC,IAA7B,KAAsC;IAC5C,IAAI,CAACF,SAAL,EAAgB;MACd,MAAM,IAAIG,KAAJ,CAAU,oBAAV,CAAN;IACD;;IACD,IAAI,CAACF,SAAL,EAAgB;MACd,MAAM,IAAIE,KAAJ,CAAU,+BAAV,CAAN;IACD;;IACD,IAAI,CAACD,IAAL,EAAW;MACT,MAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;IACD;;IAED,IAAI,CAACP,MAAM,CAACQ,QAAP,CAAgBF,IAAhB,CAAL,EAA4B;MAC1BA,IAAI,GAAGN,MAAM,CAACS,IAAP,CAAYH,IAAZ,CAAP;IACD;;IAED,MAAMI,OAAO,GAAG,CAACC,GAAD,EAAMC,GAAN,EAAWC,GAAX,KAAmB,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;MAClEL,GAAG,CAACR,MAAJ,CAAWS,GAAX,EAAgBC,GAAhB,EAAqB,CAACI,GAAD,EAAMC,KAAN,KAAgB;QACnC,IAAI,CAACD,GAAL,EAAU;UACRF,OAAO,CAACG,KAAD,CAAP;QACD;;QACDF,MAAM,CAACE,KAAD,CAAN;MACD,CALD;IAMD,CAPkC,CAAnC;;IASA,IAAIC,GAAG,GAAG,KAAV;;IACA,IAAI;MACF,MAAMC,MAAM,GAAGtB,MAAM,CAACuB,IAAP,CAAYC,aAAZ,CAA0BC,SAA1B,CAAoCC,2BAApC,CAAgExB,MAAM,CAACS,IAAP,CAAYJ,SAAZ,EAAuB,KAAvB,CAAhE,CAAf;MACAc,GAAG,GAAG,MAAMT,OAAO,CAACU,MAAD,EAASd,IAAT,EAAeN,MAAM,CAACS,IAAP,CAAYL,SAAZ,EAAuB,KAAvB,CAAf,CAAnB;IACD,CAHD,CAGE,OAAOqB,CAAP,EAAU,CACV;IACD;;IACD,OAAOX,OAAO,CAACC,OAAR,CAAgBI,GAAhB,CAAP;EACD;AAjCc,CAAjB"},"metadata":{},"sourceType":"script"}