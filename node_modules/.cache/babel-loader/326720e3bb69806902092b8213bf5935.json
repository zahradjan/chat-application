{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar _require2 = require('libp2p-record'),\n    Record = _require2.Record;\n\nvar _require3 = require('./utils'),\n    encodeBase32 = _require3.encodeBase32;\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('ipfs:ipns:offline-datastore'), {\n  error: debug('ipfs:ipns:offline-datastore:error')\n}); // Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\n\nvar OfflineDatastore = /*#__PURE__*/function () {\n  /**\n   * @param {import('ipfs-repo').IPFSRepo} repo\n   */\n  function OfflineDatastore(repo) {\n    _classCallCheck(this, OfflineDatastore);\n\n    this._repo = repo;\n    /** @type {any[]} */\n\n    this.stores = [];\n  }\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   */\n\n\n  _createClass(OfflineDatastore, [{\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, value) {\n        var routingKey, record;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (key instanceof Uint8Array) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');\n\n              case 2:\n                if (value instanceof Uint8Array) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw errcode(new Error('Offline datastore value must be a Uint8Array'), 'ERR_INVALID_VALUE');\n\n              case 4:\n                _context.prev = 4;\n                routingKey = this._routingKey(key);\n                _context.next = 12;\n                break;\n\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context[\"catch\"](4);\n                log.error(_context.t0);\n                throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n\n              case 12:\n                // Marshal to libp2p record as the DHT does\n                record = new Record(key, value);\n                return _context.abrupt(\"return\", this._repo.datastore.put(routingKey, record.serialize()));\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 8]]);\n      }));\n\n      function put(_x, _x2) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n    /**\n     * Get a value from the local datastore indexed by the received key properly encoded.\n     *\n     * @param {Uint8Array} key - identifier of the value to be obtained.\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key) {\n        var routingKey, res, record;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (key instanceof Uint8Array) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');\n\n              case 2:\n                _context2.prev = 2;\n                routingKey = this._routingKey(key);\n                _context2.next = 10;\n                break;\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](2);\n                log.error(_context2.t0);\n                throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n\n              case 10:\n                _context2.next = 12;\n                return this._repo.datastore.get(routingKey);\n\n              case 12:\n                res = _context2.sent;\n                _context2.prev = 13;\n                record = Record.deserialize(res);\n                _context2.next = 21;\n                break;\n\n              case 17:\n                _context2.prev = 17;\n                _context2.t1 = _context2[\"catch\"](13);\n                log.error(_context2.t1);\n                throw _context2.t1;\n\n              case 21:\n                return _context2.abrupt(\"return\", record.value);\n\n              case 22:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2, 6], [13, 17]]);\n      }));\n\n      function get(_x3) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * encode key properly - base32(/ipns/{cid})\n     *\n     * @param {Uint8Array} key\n     */\n\n  }, {\n    key: \"_routingKey\",\n    value: function _routingKey(key) {\n      return new Key('/' + encodeBase32(key), false);\n    }\n  }]);\n\n  return OfflineDatastore;\n}();\n\nexports = module.exports = OfflineDatastore;","map":{"version":3,"names":["require","Key","Record","encodeBase32","errcode","debug","log","Object","assign","error","OfflineDatastore","repo","_repo","stores","key","value","Uint8Array","Error","routingKey","_routingKey","record","datastore","put","serialize","get","res","deserialize","exports","module"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/ipns/routing/offline-datastore.js"],"sourcesContent":["'use strict'\n\nconst { Key } = require('interface-datastore')\nconst { Record } = require('libp2p-record')\nconst { encodeBase32 } = require('./utils')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns:offline-datastore'), {\n  error: debug('ipfs:ipns:offline-datastore:error')\n})\n\n// Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\nclass OfflineDatastore {\n  /**\n   * @param {import('ipfs-repo').IPFSRepo} repo\n   */\n  constructor (repo) {\n    this._repo = repo\n    /** @type {any[]} */\n    this.stores = []\n  }\n\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value.\n   * @param {Uint8Array} value - value to be stored.\n   */\n  async put (key, value) { // eslint-disable-line require-await\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY')\n    }\n\n    if (!(value instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore value must be a Uint8Array'), 'ERR_INVALID_VALUE')\n    }\n\n    let routingKey\n\n    try {\n      routingKey = this._routingKey(key)\n    } catch (err) {\n      log.error(err)\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY')\n    }\n\n    // Marshal to libp2p record as the DHT does\n    const record = new Record(key, value)\n\n    return this._repo.datastore.put(routingKey, record.serialize())\n  }\n\n  /**\n   * Get a value from the local datastore indexed by the received key properly encoded.\n   *\n   * @param {Uint8Array} key - identifier of the value to be obtained.\n   */\n  async get (key) {\n    if (!(key instanceof Uint8Array)) {\n      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY')\n    }\n\n    let routingKey\n\n    try {\n      routingKey = this._routingKey(key)\n    } catch (err) {\n      log.error(err)\n      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY')\n    }\n\n    const res = await this._repo.datastore.get(routingKey)\n\n    // Unmarshal libp2p record as the DHT does\n    let record\n    try {\n      record = Record.deserialize(res)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    return record.value\n  }\n\n  /**\n   * encode key properly - base32(/ipns/{cid})\n   *\n   * @param {Uint8Array} key\n   */\n  _routingKey (key) {\n    return new Key('/' + encodeBase32(key), false)\n  }\n}\n\nexports = module.exports = OfflineDatastore\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}