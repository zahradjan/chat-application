{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar pSeries = require('p-series');\n\nvar PeerMonitor = require('ipfs-pubsub-peer-monitor');\n\nvar Logger = require('logplease');\n\nvar logger = Logger.create(\"pubsub\", {\n  color: Logger.Colors.Yellow\n});\nLogger.setLogLevel('ERROR');\nvar maxTopicsOpen = 256;\nvar topicsOpenCount = 0;\n\nvar IPFSPubsub = /*#__PURE__*/function () {\n  function IPFSPubsub(ipfs, id) {\n    _classCallCheck(this, IPFSPubsub);\n\n    this._ipfs = ipfs;\n    this._id = id;\n    this._subscriptions = {};\n    if (this._ipfs.pubsub === null) logger.error(\"The provided version of ipfs doesn't have pubsub support. Messages will not be exchanged.\");\n    this._handleMessage = this._handleMessage.bind(this); // Bump up the number of listeners we can have open,\n    // ie. number of databases replicating\n\n    if (this._ipfs.setMaxListeners) this._ipfs.setMaxListeners(maxTopicsOpen);\n  }\n\n  _createClass(IPFSPubsub, [{\n    key: \"subscribe\",\n    value: function () {\n      var _subscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(topic, onMessageCallback, onNewPeerCallback) {\n        var _this = this;\n\n        var options,\n            topicMonitor,\n            _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n\n                if (!(!this._subscriptions[topic] && this._ipfs.pubsub)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 4;\n                return this._ipfs.pubsub.subscribe(topic, this._handleMessage, options);\n\n              case 4:\n                topicMonitor = new PeerMonitor(this._ipfs.pubsub, topic);\n                topicMonitor.on('join', function (peer) {\n                  logger.debug(\"Peer joined \".concat(topic, \":\"));\n                  logger.debug(peer);\n\n                  if (_this._subscriptions[topic]) {\n                    onNewPeerCallback(topic, peer);\n                  } else {\n                    logger.warn('Peer joined a room we don\\'t have a subscription for');\n                    logger.warn(topic, peer);\n                  }\n                });\n                topicMonitor.on('leave', function (peer) {\n                  return logger.debug(\"Peer \".concat(peer, \" left \").concat(topic));\n                });\n                topicMonitor.on('error', function (e) {\n                  return logger.error(e);\n                });\n                this._subscriptions[topic] = {\n                  topicMonitor: topicMonitor,\n                  onMessage: onMessageCallback,\n                  onNewPeer: onNewPeerCallback\n                };\n                topicsOpenCount++;\n                logger.debug(\"Topics open:\", topicsOpenCount);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function subscribe(_x, _x2, _x3) {\n        return _subscribe.apply(this, arguments);\n      }\n\n      return subscribe;\n    }()\n  }, {\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(hash) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._subscriptions[hash]) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this._ipfs.pubsub.unsubscribe(hash, this._handleMessage);\n\n              case 3:\n                this._subscriptions[hash].topicMonitor.stop();\n\n                delete this._subscriptions[hash];\n                logger.debug(\"Unsubscribed from '\".concat(hash, \"'\"));\n                topicsOpenCount--;\n                logger.debug(\"Topics open:\", topicsOpenCount);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function unsubscribe(_x4) {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n  }, {\n    key: \"publish\",\n    value: function publish(topic, message) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (this._subscriptions[topic] && this._ipfs.pubsub) {\n        var payload; //Buffer should be already serialized. Everything else will get serialized as json if not buffer, string.\n\n        if (Buffer.isBuffer(message) | typeof message === \"string\") {\n          payload = message;\n        } else {\n          payload = JSON.stringify(message);\n        }\n\n        this._ipfs.pubsub.publish(topic, Buffer.from(payload), options);\n      }\n    }\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _this2 = this;\n\n        var topics;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                topics = Object.keys(this._subscriptions);\n                _context3.next = 3;\n                return pSeries(topics.map(function (t) {\n                  return _this2.unsubscribe.bind(_this2, t);\n                }));\n\n              case 3:\n                this._subscriptions = {};\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n\n      return disconnect;\n    }()\n  }, {\n    key: \"_handleMessage\",\n    value: function () {\n      var _handleMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(message) {\n        var content, subscription, topicId;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(message.from === this._id)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                // Get the topic\n                topicId = message.topicIDs[0];\n\n                try {\n                  content = JSON.parse(Buffer.from(message.data).toString());\n                } catch (_unused) {\n                  content = message.data; //Leave content alone. Meant for higher level code using custom serialization.\n                }\n\n                subscription = this._subscriptions[topicId];\n\n                if (!(subscription && subscription.onMessage && content)) {\n                  _context4.next = 8;\n                  break;\n                }\n\n                _context4.next = 8;\n                return subscription.onMessage(topicId, content, message.from);\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _handleMessage(_x5) {\n        return _handleMessage2.apply(this, arguments);\n      }\n\n      return _handleMessage;\n    }()\n  }]);\n\n  return IPFSPubsub;\n}();\n\nmodule.exports = IPFSPubsub;","map":{"version":3,"names":["pSeries","require","PeerMonitor","Logger","logger","create","color","Colors","Yellow","setLogLevel","maxTopicsOpen","topicsOpenCount","IPFSPubsub","ipfs","id","_ipfs","_id","_subscriptions","pubsub","error","_handleMessage","bind","setMaxListeners","topic","onMessageCallback","onNewPeerCallback","options","subscribe","topicMonitor","on","peer","debug","warn","e","onMessage","onNewPeer","hash","unsubscribe","stop","message","payload","Buffer","isBuffer","JSON","stringify","publish","from","topics","Object","keys","map","t","topicId","topicIDs","content","parse","data","toString","subscription","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-pubsub/src/ipfs-pubsub.js"],"sourcesContent":["'use strict'\n\nconst pSeries = require('p-series')\nconst PeerMonitor = require('ipfs-pubsub-peer-monitor')\n\nconst Logger = require('logplease')\nconst logger = Logger.create(\"pubsub\", { color: Logger.Colors.Yellow })\nLogger.setLogLevel('ERROR')\n\nconst maxTopicsOpen = 256\nlet topicsOpenCount = 0\n\nclass IPFSPubsub {\n  constructor(ipfs, id) {\n    this._ipfs = ipfs\n    this._id = id\n    this._subscriptions = {}\n\n    if (this._ipfs.pubsub === null)\n      logger.error(\"The provided version of ipfs doesn't have pubsub support. Messages will not be exchanged.\")\n\n    this._handleMessage = this._handleMessage.bind(this)\n\n    // Bump up the number of listeners we can have open,\n    // ie. number of databases replicating\n    if (this._ipfs.setMaxListeners)\n      this._ipfs.setMaxListeners(maxTopicsOpen)\n  }\n\n  async subscribe(topic, onMessageCallback, onNewPeerCallback, options = {}) {\n    if(!this._subscriptions[topic] && this._ipfs.pubsub) {\n      await this._ipfs.pubsub.subscribe(topic, this._handleMessage, options)\n\n      const topicMonitor = new PeerMonitor(this._ipfs.pubsub, topic)\n\n      topicMonitor.on('join', (peer) => {\n        logger.debug(`Peer joined ${topic}:`)\n        logger.debug(peer)\n        if (this._subscriptions[topic]) {\n          onNewPeerCallback(topic, peer)\n        } else {\n          logger.warn('Peer joined a room we don\\'t have a subscription for')\n          logger.warn(topic, peer)\n        }\n      })\n\n      topicMonitor.on('leave', (peer) => logger.debug(`Peer ${peer} left ${topic}`))\n      topicMonitor.on('error', (e) => logger.error(e))\n\n      this._subscriptions[topic] = {\n        topicMonitor: topicMonitor,\n        onMessage: onMessageCallback,\n        onNewPeer: onNewPeerCallback\n      }\n\n      topicsOpenCount ++\n      logger.debug(\"Topics open:\", topicsOpenCount)\n    }\n  }\n\n  async unsubscribe(hash) {\n    if(this._subscriptions[hash]) {\n      await this._ipfs.pubsub.unsubscribe(hash, this._handleMessage)\n      this._subscriptions[hash].topicMonitor.stop()\n      delete this._subscriptions[hash]\n      logger.debug(`Unsubscribed from '${hash}'`)\n      topicsOpenCount --\n      logger.debug(\"Topics open:\", topicsOpenCount)\n    }\n  }\n\n  publish(topic, message, options = {}) {\n    if (this._subscriptions[topic] && this._ipfs.pubsub) {\n      let payload;\n      //Buffer should be already serialized. Everything else will get serialized as json if not buffer, string.\n      if(Buffer.isBuffer(message) | typeof message === \"string\") {\n        payload = message;\n      } else {\n        payload = JSON.stringify(message);\n      }\n      this._ipfs.pubsub.publish(topic, Buffer.from(payload), options)\n    }\n  }\n\n  async disconnect() {\n    const topics = Object.keys(this._subscriptions)\n    await pSeries(topics.map((t) => this.unsubscribe.bind(this, t)))\n    this._subscriptions = {}\n  }\n\n  async _handleMessage(message) {\n    // Don't process our own messages\n    if (message.from === this._id)\n      return\n\n    // Get the message content and a subscription\n    let content, subscription, topicId\n\n    // Get the topic\n    topicId = message.topicIDs[0]\n    try {\n      content = JSON.parse(Buffer.from(message.data).toString())\n    } catch {\n      content = message.data; //Leave content alone. Meant for higher level code using custom serialization.\n    }\n    subscription = this._subscriptions[topicId]\n\n    if(subscription && subscription.onMessage && content) {\n      await subscription.onMessage(topicId, content, message.from)\n    }\n  }\n}\n\nmodule.exports = IPFSPubsub\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}