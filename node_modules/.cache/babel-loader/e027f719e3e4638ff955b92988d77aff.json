{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar waitForPeers = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(ipfs, peersToWait, topic, isClosed) {\n    var checkPeers;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            checkPeers = /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var peers, hasAllPeers;\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return ipfs.pubsub.peers(topic);\n\n                      case 2:\n                        peers = _context.sent;\n                        hasAllPeers = peersToWait.map(function (e) {\n                          return peers.includes(e);\n                        }).filter(function (e) {\n                          return e === false;\n                        }).length === 0;\n                        return _context.abrupt(\"return\", hasAllPeers);\n\n                      case 5:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }));\n\n              return function checkPeers() {\n                return _ref2.apply(this, arguments);\n              };\n            }();\n\n            _context4.next = 3;\n            return checkPeers();\n\n          case 3:\n            if (!_context4.sent) {\n              _context4.next = 5;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", Promise.resolve());\n\n          case 5:\n            return _context4.abrupt(\"return\", new Promise( /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(resolve, reject) {\n                var interval;\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        interval = setInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                            while (1) {\n                              switch (_context2.prev = _context2.next) {\n                                case 0:\n                                  _context2.prev = 0;\n\n                                  if (!isClosed()) {\n                                    _context2.next = 5;\n                                    break;\n                                  }\n\n                                  clearInterval(interval);\n                                  _context2.next = 10;\n                                  break;\n\n                                case 5:\n                                  _context2.next = 7;\n                                  return checkPeers();\n\n                                case 7:\n                                  if (!_context2.sent) {\n                                    _context2.next = 10;\n                                    break;\n                                  }\n\n                                  clearInterval(interval);\n                                  resolve();\n\n                                case 10:\n                                  _context2.next = 15;\n                                  break;\n\n                                case 12:\n                                  _context2.prev = 12;\n                                  _context2.t0 = _context2[\"catch\"](0);\n                                  reject(_context2.t0);\n\n                                case 15:\n                                case \"end\":\n                                  return _context2.stop();\n                              }\n                            }\n                          }, _callee2, null, [[0, 12]]);\n                        })), 100);\n\n                      case 1:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3);\n              }));\n\n              return function (_x5, _x6) {\n                return _ref3.apply(this, arguments);\n              };\n            }()));\n\n          case 6:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function waitForPeers(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = waitForPeers;","map":{"version":3,"names":["waitForPeers","ipfs","peersToWait","topic","isClosed","checkPeers","pubsub","peers","hasAllPeers","map","e","includes","filter","length","Promise","resolve","reject","interval","setInterval","clearInterval","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-pubsub-1on1/src/wait-for-peers.js"],"sourcesContent":["'use strict'\n\nconst waitForPeers = async (ipfs, peersToWait, topic, isClosed) => {\n  const checkPeers = async () => {\n    const peers = await ipfs.pubsub.peers(topic)\n    const hasAllPeers = peersToWait.map((e) => peers.includes(e)).filter((e) => e === false).length === 0\n    return hasAllPeers\n  }\n\n  if (await checkPeers()) {\n    return Promise.resolve()\n  }\n\n  return new Promise(async (resolve, reject) => {\n    const interval = setInterval(async () => {\n      try {\n        if (isClosed()) {\n          clearInterval(interval)\n        } else if (await checkPeers()) {\n          clearInterval(interval)\n          resolve()\n        }\n      } catch (e) {\n        reject(e)\n      }\n    }, 100)\n  })\n}\n\nmodule.exports = waitForPeers\n"],"mappings":"AAAA;;;;;;AAEA,IAAMA,YAAY;EAAA,sEAAG,kBAAOC,IAAP,EAAaC,WAAb,EAA0BC,KAA1B,EAAiCC,QAAjC;IAAA;IAAA;MAAA;QAAA;UAAA;YACbC,UADa;cAAA,uEACA;gBAAA;gBAAA;kBAAA;oBAAA;sBAAA;wBAAA;wBAAA,OACGJ,IAAI,CAACK,MAAL,CAAYC,KAAZ,CAAkBJ,KAAlB,CADH;;sBAAA;wBACXI,KADW;wBAEXC,WAFW,GAEGN,WAAW,CAACO,GAAZ,CAAgB,UAACC,CAAD;0BAAA,OAAOH,KAAK,CAACI,QAAN,CAAeD,CAAf,CAAP;wBAAA,CAAhB,EAA0CE,MAA1C,CAAiD,UAACF,CAAD;0BAAA,OAAOA,CAAC,KAAK,KAAb;wBAAA,CAAjD,EAAqEG,MAArE,KAAgF,CAFnF;wBAAA,iCAGVL,WAHU;;sBAAA;sBAAA;wBAAA;oBAAA;kBAAA;gBAAA;cAAA,CADA;;cAAA,gBACbH,UADa;gBAAA;cAAA;YAAA;;YAAA;YAAA,OAOTA,UAAU,EAPD;;UAAA;YAAA;cAAA;cAAA;YAAA;;YAAA,kCAQVS,OAAO,CAACC,OAAR,EARU;;UAAA;YAAA,kCAWZ,IAAID,OAAJ;cAAA,uEAAY,kBAAOC,OAAP,EAAgBC,MAAhB;gBAAA;gBAAA;kBAAA;oBAAA;sBAAA;wBACXC,QADW,GACAC,WAAW,0EAAC;0BAAA;4BAAA;8BAAA;gCAAA;kCAAA;;kCAAA,KAErBd,QAAQ,EAFa;oCAAA;oCAAA;kCAAA;;kCAGvBe,aAAa,CAACF,QAAD,CAAb;kCAHuB;kCAAA;;gCAAA;kCAAA;kCAAA,OAIRZ,UAAU,EAJF;;gCAAA;kCAAA;oCAAA;oCAAA;kCAAA;;kCAKvBc,aAAa,CAACF,QAAD,CAAb;kCACAF,OAAO;;gCANgB;kCAAA;kCAAA;;gCAAA;kCAAA;kCAAA;kCASzBC,MAAM,cAAN;;gCATyB;gCAAA;kCAAA;8BAAA;4BAAA;0BAAA;wBAAA,CAAD,IAWzB,GAXyB,CADX;;sBAAA;sBAAA;wBAAA;oBAAA;kBAAA;gBAAA;cAAA,CAAZ;;cAAA;gBAAA;cAAA;YAAA,IAXY;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAAH;;EAAA,gBAAZhB,YAAY;IAAA;EAAA;AAAA,GAAlB;;AA2BAoB,MAAM,CAACC,OAAP,GAAiBrB,YAAjB"},"metadata":{},"sourceType":"script"}