{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require('multiformats'),\n    CID = _require.CID;\n\nvar _require2 = require('multiformats/hashes/sha2'),\n    sha256 = _require2.sha256;\n\nvar _require3 = require('multiformats/bases/base58'),\n    base58btc = _require3.base58btc; // @ts-ignore\n\n\nvar vd = require('varint-decoder');\n\nvar _require4 = require('../../utils'),\n    isMapEqual = _require4.isMapEqual;\n\nvar _require5 = require('./message'),\n    Message = _require5.Message;\n\nvar Entry = require('./entry');\n\nvar _require6 = require('uint8arrays/concat'),\n    uint8ArrayConcat = _require6.concat;\n\nvar errcode = require('err-code');\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n */\n\n\nvar BitswapMessage = /*#__PURE__*/function (_Symbol$toStringTag) {\n  /**\n   * @param {boolean} full\n   */\n  function BitswapMessage(full) {\n    _classCallCheck(this, BitswapMessage);\n\n    this.full = full;\n    /** @type {Map<string, Entry>} */\n\n    this.wantlist = new Map();\n    /** @type {Map<string, Uint8Array>} */\n\n    this.blocks = new Map();\n    /** @type {Map<string, import('./message').Message.BlockPresenceType>} */\n\n    this.blockPresences = new Map();\n    this.pendingBytes = 0;\n  }\n\n  _createClass(BitswapMessage, [{\n    key: \"empty\",\n    get: function get() {\n      return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;\n    }\n    /**\n     *\n     * @param {CID} cid\n     * @param {number} priority\n     * @param {import('./message').Message.Wantlist.WantType | null} [wantType]\n     * @param {boolean} [cancel]\n     * @param {boolean} [sendDontHave]\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addEntry\",\n    value: function addEntry(cid, priority, wantType, cancel, sendDontHave) {\n      if (wantType == null) {\n        wantType = BitswapMessage.WantType.Block;\n      }\n\n      var cidStr = cid.toString(base58btc);\n      var entry = this.wantlist.get(cidStr);\n\n      if (entry) {\n        // Only change priority if want is of the same type\n        if (entry.wantType === wantType) {\n          entry.priority = priority;\n        } // Only change from \"dont cancel\" to \"do cancel\"\n\n\n        if (cancel) {\n          entry.cancel = Boolean(cancel);\n        } // Only change from \"dont send\" to \"do send\" DONT_HAVE\n\n\n        if (sendDontHave) {\n          entry.sendDontHave = Boolean(sendDontHave);\n        } // want-block overrides existing want-have\n\n\n        if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n          entry.wantType = wantType;\n        }\n      } else {\n        this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave));\n      }\n    }\n    /**\n     * @param {CID} cid\n     * @param {Uint8Array} block\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addBlock\",\n    value: function addBlock(cid, block) {\n      var cidStr = cid.toString(base58btc);\n      this.blocks.set(cidStr, block);\n    }\n    /**\n     * @param {CID} cid\n     */\n\n  }, {\n    key: \"addHave\",\n    value: function addHave(cid) {\n      var cidStr = cid.toString(base58btc);\n\n      if (!this.blockPresences.has(cidStr)) {\n        this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n      }\n    }\n    /**\n     * @param {CID} cid\n     */\n\n  }, {\n    key: \"addDontHave\",\n    value: function addDontHave(cid) {\n      var cidStr = cid.toString(base58btc);\n\n      if (!this.blockPresences.has(cidStr)) {\n        this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n      }\n    }\n    /**\n     * @param {CID} cid\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel(cid) {\n      var cidStr = cid.toString(base58btc);\n      this.wantlist.delete(cidStr);\n      this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n    }\n    /**\n     * @param {number} size\n     */\n\n  }, {\n    key: \"setPendingBytes\",\n    value: function setPendingBytes(size) {\n      this.pendingBytes = size;\n    }\n    /**\n     * Serializes to Bitswap Message protobuf of\n     * version 1.0.0\n     *\n     * @returns {Uint8Array}\n     */\n\n  }, {\n    key: \"serializeToBitswap100\",\n    value: function serializeToBitswap100() {\n      var msg = {\n        wantlist: {\n          entries: Array.from(this.wantlist.values()).map(function (entry) {\n            return {\n              block: entry.cid.bytes,\n              // cid\n              priority: Number(entry.priority),\n              cancel: Boolean(entry.cancel)\n            };\n          }),\n          full: this.full ? true : undefined\n        },\n        blocks: Array.from(this.blocks.values())\n      };\n      return Message.encode(msg).finish();\n    }\n    /**\n     * Serializes to Bitswap Message protobuf of\n     * version 1.1.0\n     *\n     * @returns {Uint8Array}\n     */\n\n  }, {\n    key: \"serializeToBitswap110\",\n    value: function serializeToBitswap110() {\n      var msg = {\n        wantlist: {\n          entries: Array.from(this.wantlist.values()).map(function (entry) {\n            return {\n              block: entry.cid.bytes,\n              // cid\n              priority: Number(entry.priority),\n              wantType: entry.wantType,\n              cancel: Boolean(entry.cancel),\n              sendDontHave: Boolean(entry.sendDontHave)\n            };\n          }),\n          full: this.full ? true : undefined\n        },\n\n        /** @type {import('./message').Message.BlockPresence[]} */\n        blockPresences: [],\n\n        /** @type {{ prefix: Uint8Array, data: Uint8Array }[]} */\n        payload: [],\n        pendingBytes: this.pendingBytes\n      };\n\n      var _iterator = _createForOfIteratorHelper(this.blocks.entries()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              cidStr = _step$value[0],\n              data = _step$value[1];\n\n          var cid = CID.parse(cidStr);\n          var codec = Uint8Array.from([cid.code]);\n          var multihash = cid.multihash.bytes.subarray(0, 2);\n          var prefix = uint8ArrayConcat([[cid.version], codec, multihash], 1 + codec.byteLength + multihash.byteLength);\n          msg.payload.push(new Message.Block({\n            prefix: prefix,\n            data: data\n          }));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this.blockPresences),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              _cidStr = _step2$value[0],\n              bpType = _step2$value[1];\n\n          msg.blockPresences.push(new Message.BlockPresence({\n            cid: CID.parse(_cidStr).bytes,\n            type: bpType\n          }));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (this.pendingBytes > 0) {\n        msg.pendingBytes = this.pendingBytes;\n      }\n\n      return Message.encode(msg).finish();\n    }\n    /**\n     * @param {BitswapMessage} other\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || // @TODO - Is this a bug ?\n      // @ts-expect-error - isMap equals map values to be objects not numbers\n      !isMapEqual(this.blockPresences, other.blockPresences)) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      var list = Array.from(this.wantlist.keys());\n      var blocks = Array.from(this.blocks.keys());\n      return \"BitswapMessage <full: \".concat(this.full, \", list: \").concat(list, \", blocks: \").concat(blocks, \">\");\n    }\n  }]);\n\n  return BitswapMessage;\n}(Symbol.toStringTag);\n/**\n * @param {Uint8Array} raw\n * @param {Record<number, MultihashHasher>} [hashers]\n */\n\n\nBitswapMessage.deserialize = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(raw) {\n    var hashers,\n        decoded,\n        isFull,\n        msg,\n        _args3 = arguments;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            hashers = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n            decoded = Message.decode(raw);\n            isFull = decoded.wantlist && decoded.wantlist.full || false;\n            msg = new BitswapMessage(isFull);\n\n            if (decoded.wantlist && decoded.wantlist.entries) {\n              decoded.wantlist.entries.forEach(function (entry) {\n                if (!entry.block) {\n                  return;\n                } // note: entry.block is the CID here\n\n\n                var cid = CID.decode(entry.block);\n                msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));\n              });\n            }\n\n            if (decoded.blockPresences) {\n              decoded.blockPresences.forEach(function (blockPresence) {\n                if (!blockPresence.cid) {\n                  return;\n                }\n\n                var cid = CID.decode(blockPresence.cid);\n\n                if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n                  msg.addHave(cid);\n                } else {\n                  msg.addDontHave(cid);\n                }\n              });\n            } // Bitswap 1.0.0\n            // decoded.blocks are just the byte arrays\n\n\n            if (!(decoded.blocks.length > 0)) {\n              _context3.next = 10;\n              break;\n            }\n\n            _context3.next = 9;\n            return Promise.all(decoded.blocks.map( /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(b) {\n                var hash, cid;\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return sha256.digest(b);\n\n                      case 2:\n                        hash = _context.sent;\n                        cid = CID.createV0(hash);\n                        msg.addBlock(cid, b);\n\n                      case 5:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }));\n\n              return function (_x2) {\n                return _ref2.apply(this, arguments);\n              };\n            }()));\n\n          case 9:\n            return _context3.abrupt(\"return\", msg);\n\n          case 10:\n            if (!(decoded.payload.length > 0)) {\n              _context3.next = 15;\n              break;\n            }\n\n            _context3.next = 13;\n            return Promise.all(decoded.payload.map( /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(p) {\n                var values, cidVersion, multicodec, hashAlg, hasher, hash, cid;\n                return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        if (!(!p.prefix || !p.data)) {\n                          _context2.next = 2;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\");\n\n                      case 2:\n                        values = vd(p.prefix);\n                        cidVersion = values[0];\n                        multicodec = values[1];\n                        hashAlg = values[2];\n                        hasher = hashAlg === sha256.code ? sha256 : hashers[hashAlg];\n\n                        if (hasher) {\n                          _context2.next = 9;\n                          break;\n                        }\n\n                        throw errcode(new Error('Unknown hash algorithm'), 'ERR_UNKNOWN_HASH_ALG');\n\n                      case 9:\n                        _context2.next = 11;\n                        return hasher.digest(p.data);\n\n                      case 11:\n                        hash = _context2.sent;\n                        cid = CID.create(cidVersion, multicodec, hash);\n                        msg.addBlock(cid, p.data);\n\n                      case 14:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n\n              return function (_x3) {\n                return _ref3.apply(this, arguments);\n              };\n            }()));\n\n          case 13:\n            msg.setPendingBytes(decoded.pendingBytes);\n            return _context3.abrupt(\"return\", msg);\n\n          case 15:\n            return _context3.abrupt(\"return\", msg);\n\n          case 16:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {CID} cid\n */\n\n\nBitswapMessage.blockPresenceSize = function (cid) {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.bytes.length + 1;\n};\n\nBitswapMessage.Entry = Entry;\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n};\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n};\nmodule.exports = BitswapMessage;","map":{"version":3,"names":["require","CID","sha256","base58btc","vd","isMapEqual","Message","Entry","uint8ArrayConcat","concat","errcode","BitswapMessage","full","wantlist","Map","blocks","blockPresences","pendingBytes","size","cid","priority","wantType","cancel","sendDontHave","WantType","Block","cidStr","toString","entry","get","Boolean","Have","set","block","has","BlockPresenceType","DontHave","delete","addEntry","msg","entries","Array","from","values","map","bytes","Number","undefined","encode","finish","payload","data","parse","codec","Uint8Array","code","multihash","subarray","prefix","version","byteLength","push","bpType","BlockPresence","type","other","list","keys","Symbol","toStringTag","deserialize","raw","hashers","decoded","decode","isFull","forEach","blockPresence","addHave","addDontHave","length","Promise","all","b","digest","hash","createV0","addBlock","p","cidVersion","multicodec","hashAlg","hasher","Error","create","setPendingBytes","blockPresenceSize","Wantlist","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-bitswap/src/types/message/index.js"],"sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats')\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst { base58btc } = require('multiformats/bases/base58')\n// @ts-ignore\nconst vd = require('varint-decoder')\nconst { isMapEqual } = require('../../utils')\nconst { Message } = require('./message')\nconst Entry = require('./entry')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst errcode = require('err-code')\n\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n */\n\nclass BitswapMessage {\n  /**\n   * @param {boolean} full\n   */\n  constructor (full) {\n    this.full = full\n    /** @type {Map<string, Entry>} */\n    this.wantlist = new Map()\n\n    /** @type {Map<string, Uint8Array>} */\n    this.blocks = new Map()\n\n    /** @type {Map<string, import('./message').Message.BlockPresenceType>} */\n    this.blockPresences = new Map()\n    this.pendingBytes = 0\n  }\n\n  get empty () {\n    return this.blocks.size === 0 &&\n           this.wantlist.size === 0 &&\n           this.blockPresences.size === 0\n  }\n\n  /**\n   *\n   * @param {CID} cid\n   * @param {number} priority\n   * @param {import('./message').Message.Wantlist.WantType | null} [wantType]\n   * @param {boolean} [cancel]\n   * @param {boolean} [sendDontHave]\n   * @returns {void}\n   */\n  addEntry (cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block\n    }\n\n    const cidStr = cid.toString(base58btc)\n    const entry = this.wantlist.get(cidStr)\n    if (entry) {\n      // Only change priority if want is of the same type\n      if (entry.wantType === wantType) {\n        entry.priority = priority\n      }\n      // Only change from \"dont cancel\" to \"do cancel\"\n      if (cancel) {\n        entry.cancel = Boolean(cancel)\n      }\n      // Only change from \"dont send\" to \"do send\" DONT_HAVE\n      if (sendDontHave) {\n        entry.sendDontHave = Boolean(sendDontHave)\n      }\n      // want-block overrides existing want-have\n      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n        entry.wantType = wantType\n      }\n    } else {\n      this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave))\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   * @returns {void}\n   */\n  addBlock (cid, block) {\n    const cidStr = cid.toString(base58btc)\n    this.blocks.set(cidStr, block)\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  addHave (cid) {\n    const cidStr = cid.toString(base58btc)\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  addDontHave (cid) {\n    const cidStr = cid.toString(base58btc)\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  cancel (cid) {\n    const cidStr = cid.toString(base58btc)\n    this.wantlist.delete(cidStr)\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false)\n  }\n\n  /**\n   * @param {number} size\n   */\n  setPendingBytes (size) {\n    this.pendingBytes = size\n  }\n\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.0.0\n   *\n   * @returns {Uint8Array}\n   */\n  serializeToBitswap100 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.bytes, // cid\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          }\n        }),\n        full: this.full ? true : undefined\n      },\n      blocks: Array.from(this.blocks.values())\n    }\n\n    return Message.encode(msg).finish()\n  }\n\n  /**\n   * Serializes to Bitswap Message protobuf of\n   * version 1.1.0\n   *\n   * @returns {Uint8Array}\n   */\n  serializeToBitswap110 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.bytes, // cid\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          }\n        }),\n        full: this.full ? true : undefined\n      },\n      /** @type {import('./message').Message.BlockPresence[]} */\n      blockPresences: [],\n\n      /** @type {{ prefix: Uint8Array, data: Uint8Array }[]} */\n      payload: [],\n      pendingBytes: this.pendingBytes\n    }\n\n    for (const [cidStr, data] of this.blocks.entries()) {\n      const cid = CID.parse(cidStr)\n      const codec = Uint8Array.from([cid.code])\n      const multihash = cid.multihash.bytes.subarray(0, 2)\n      const prefix = uint8ArrayConcat([\n        [cid.version], codec, multihash\n      ], 1 + codec.byteLength + multihash.byteLength)\n\n      msg.payload.push(\n        new Message.Block({\n          prefix,\n          data\n        })\n      )\n    }\n\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push(new Message.BlockPresence({\n        cid: CID.parse(cidStr).bytes,\n        type: bpType\n      }))\n    }\n\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes\n    }\n\n    return Message.encode(msg).finish()\n  }\n\n  /**\n   * @param {BitswapMessage} other\n   * @returns {boolean}\n   */\n  equals (other) {\n    if (this.full !== other.full ||\n        this.pendingBytes !== other.pendingBytes ||\n        !isMapEqual(this.wantlist, other.wantlist) ||\n        !isMapEqual(this.blocks, other.blocks) ||\n        // @TODO - Is this a bug ?\n        // @ts-expect-error - isMap equals map values to be objects not numbers\n        !isMapEqual(this.blockPresences, other.blockPresences)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  get [Symbol.toStringTag] () {\n    const list = Array.from(this.wantlist.keys())\n    const blocks = Array.from(this.blocks.keys())\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`\n  }\n}\n\n/**\n * @param {Uint8Array} raw\n * @param {Record<number, MultihashHasher>} [hashers]\n */\nBitswapMessage.deserialize = async (raw, hashers = {}) => {\n  const decoded = Message.decode(raw)\n\n  const isFull = (decoded.wantlist && decoded.wantlist.full) || false\n  const msg = new BitswapMessage(isFull)\n\n  if (decoded.wantlist && decoded.wantlist.entries) {\n    decoded.wantlist.entries.forEach((entry) => {\n      if (!entry.block) {\n        return\n      }\n      // note: entry.block is the CID here\n      const cid = CID.decode(entry.block)\n      msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave))\n    })\n  }\n\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach((blockPresence) => {\n      if (!blockPresence.cid) {\n        return\n      }\n\n      const cid = CID.decode(blockPresence.cid)\n\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid)\n      } else {\n        msg.addDontHave(cid)\n      }\n    })\n  }\n\n  // Bitswap 1.0.0\n  // decoded.blocks are just the byte arrays\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async (b) => {\n      const hash = await sha256.digest(b)\n      const cid = CID.createV0(hash)\n      msg.addBlock(cid, b)\n    }))\n    return msg\n  }\n\n  // Bitswap 1.1.0\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async (p) => {\n      if (!p.prefix || !p.data) {\n        return\n      }\n      const values = vd(p.prefix)\n      const cidVersion = values[0]\n      const multicodec = values[1]\n      const hashAlg = values[2]\n      const hasher = hashAlg === sha256.code ? sha256 : hashers[hashAlg]\n\n      if (!hasher) {\n        throw errcode(new Error('Unknown hash algorithm'), 'ERR_UNKNOWN_HASH_ALG')\n      }\n\n      // const hashLen = values[3] // We haven't need to use this so far\n      const hash = await hasher.digest(p.data)\n      const cid = CID.create(cidVersion, multicodec, hash)\n      msg.addBlock(cid, p.data)\n    }))\n    msg.setPendingBytes(decoded.pendingBytes)\n    return msg\n  }\n\n  return msg\n}\n\n/**\n * @param {CID} cid\n */\nBitswapMessage.blockPresenceSize = (cid) => {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.bytes.length + 1\n}\n\nBitswapMessage.Entry = Entry\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n}\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n}\nmodule.exports = BitswapMessage\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}