{"ast":null,"code":"'use strict';\n\nconst whilst = require('async/whilst');\n\nconst hmac = require('../hmac');\n\nconst cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  }\n}; // Generates a set of keys for each party by stretching the shared key.\n// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n\nmodule.exports = (cipherType, hash, secret, callback) => {\n  const cipher = cipherMap[cipherType];\n\n  if (!cipher) {\n    return callback(new Error('unkown cipherType passed'));\n  }\n\n  if (!hash) {\n    return callback(new Error('unkown hashType passed'));\n  }\n\n  const cipherKeySize = cipher.keySize;\n  const ivSize = cipher.ivSize;\n  const hmacKeySize = 20;\n  const seed = Buffer.from('key expansion');\n  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n  hmac.create(hash, secret, (err, m) => {\n    if (err) {\n      return callback(err);\n    }\n\n    m.digest(seed, (err, a) => {\n      if (err) {\n        return callback(err);\n      }\n\n      const result = [];\n      let j = 0;\n      whilst(() => j < resultLength, stretch, finish);\n\n      function stretch(cb) {\n        m.digest(Buffer.concat([a, seed]), (err, b) => {\n          if (err) {\n            return cb(err);\n          }\n\n          let todo = b.length;\n\n          if (j + todo > resultLength) {\n            todo = resultLength - j;\n          }\n\n          result.push(b);\n          j += todo;\n          m.digest(a, (err, _a) => {\n            if (err) {\n              return cb(err);\n            }\n\n            a = _a;\n            cb();\n          });\n        });\n      }\n\n      function finish(err) {\n        if (err) {\n          return callback(err);\n        }\n\n        const half = resultLength / 2;\n        const resultBuffer = Buffer.concat(result);\n        const r1 = resultBuffer.slice(0, half);\n        const r2 = resultBuffer.slice(half, resultLength);\n\n        const createKey = res => ({\n          iv: res.slice(0, ivSize),\n          cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n          macKey: res.slice(ivSize + cipherKeySize)\n        });\n\n        callback(null, {\n          k1: createKey(r1),\n          k2: createKey(r2)\n        });\n      }\n    });\n  });\n};","map":{"version":3,"names":["whilst","require","hmac","cipherMap","ivSize","keySize","Blowfish","cipherKeySize","module","exports","cipherType","hash","secret","callback","cipher","Error","hmacKeySize","seed","Buffer","from","resultLength","create","err","m","digest","a","result","j","stretch","finish","cb","concat","b","todo","length","push","_a","half","resultBuffer","r1","slice","r2","createKey","res","iv","cipherKey","macKey","k1","k2"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-keystore/node_modules/libp2p-crypto/src/keys/key-stretcher.js"],"sourcesContent":["'use strict'\n\nconst whilst = require('async/whilst')\nconst hmac = require('../hmac')\n\nconst cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  }\n}\n\n// Generates a set of keys for each party by stretching the shared key.\n// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\nmodule.exports = (cipherType, hash, secret, callback) => {\n  const cipher = cipherMap[cipherType]\n\n  if (!cipher) {\n    return callback(new Error('unkown cipherType passed'))\n  }\n\n  if (!hash) {\n    return callback(new Error('unkown hashType passed'))\n  }\n\n  const cipherKeySize = cipher.keySize\n  const ivSize = cipher.ivSize\n  const hmacKeySize = 20\n  const seed = Buffer.from('key expansion')\n  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize)\n\n  hmac.create(hash, secret, (err, m) => {\n    if (err) {\n      return callback(err)\n    }\n\n    m.digest(seed, (err, a) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const result = []\n      let j = 0\n\n      whilst(\n        () => j < resultLength,\n        stretch,\n        finish\n      )\n\n      function stretch (cb) {\n        m.digest(Buffer.concat([a, seed]), (err, b) => {\n          if (err) {\n            return cb(err)\n          }\n\n          let todo = b.length\n\n          if (j + todo > resultLength) {\n            todo = resultLength - j\n          }\n\n          result.push(b)\n\n          j += todo\n\n          m.digest(a, (err, _a) => {\n            if (err) {\n              return cb(err)\n            }\n            a = _a\n            cb()\n          })\n        })\n      }\n\n      function finish (err) {\n        if (err) {\n          return callback(err)\n        }\n\n        const half = resultLength / 2\n        const resultBuffer = Buffer.concat(result)\n        const r1 = resultBuffer.slice(0, half)\n        const r2 = resultBuffer.slice(half, resultLength)\n\n        const createKey = (res) => ({\n          iv: res.slice(0, ivSize),\n          cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n          macKey: res.slice(ivSize + cipherKeySize)\n        })\n\n        callback(null, {\n          k1: createKey(r1),\n          k2: createKey(r2)\n        })\n      }\n    })\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}