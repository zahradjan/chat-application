{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar errCode = require('err-code');\n\nvar cid = require('multiformats/cid');\n\nvar index = require('./resolvers/index.js');\n\nvar last = require('it-last');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar last__default = /*#__PURE__*/_interopDefaultLegacy(last);\n\nconst toPathComponents = function () {\n  let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\n\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: cid.CID.decode(path),\n      toResolve: []\n    };\n  }\n\n  const cid$1 = cid.CID.asCID(path);\n\n  if (cid$1) {\n    return {\n      cid: cid$1,\n      toResolve: []\n    };\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n\n    const output = toPathComponents(path);\n    return {\n      cid: cid.CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n\n  throw errCode__default[\"default\"](new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH');\n};\n\nasync function* walkPath(path, blockstore) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path);\n  let name = cid.toString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n\n  while (true) {\n    const result = await index(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n\n    if (!result.entry && !result.next) {\n      throw errCode__default[\"default\"](new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n    }\n\n    if (result.entry) {\n      yield result.entry;\n    }\n\n    if (!result.next) {\n      return;\n    }\n\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n}\n\nasync function exporter(path, blockstore) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const result = await last__default[\"default\"](walkPath(path, blockstore, options));\n\n  if (!result) {\n    throw errCode__default[\"default\"](new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n  }\n\n  return result;\n}\n\nasync function* recursive(path, blockstore) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const node = await exporter(path, blockstore, options);\n\n  if (!node) {\n    return;\n  }\n\n  yield node;\n\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n\n      if (file instanceof Uint8Array) {\n        continue;\n      }\n\n      if (file.type === 'directory') {\n        yield* recurse(file, options);\n      }\n    }\n  }\n}\n\nexports.exporter = exporter;\nexports.recursive = recursive;\nexports.walkPath = walkPath;","map":{"version":3,"names":["Object","defineProperty","exports","value","errCode","require","cid","index","last","_interopDefaultLegacy","e","errCode__default","last__default","toPathComponents","path","trim","match","filter","Boolean","cidAndRest","Uint8Array","CID","decode","toResolve","cid$1","asCID","indexOf","substring","output","parse","slice","Error","walkPath","blockstore","options","name","toString","entryPath","startingDepth","length","result","entry","next","exporter","recursive","node","type","child","recurse","file","content"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-unixfs-exporter/cjs/src/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar errCode = require('err-code');\nvar cid = require('multiformats/cid');\nvar index = require('./resolvers/index.js');\nvar last = require('it-last');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar last__default = /*#__PURE__*/_interopDefaultLegacy(last);\n\nconst toPathComponents = (path = '') => {\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: cid.CID.decode(path),\n      toResolve: []\n    };\n  }\n  const cid$1 = cid.CID.asCID(path);\n  if (cid$1) {\n    return {\n      cid: cid$1,\n      toResolve: []\n    };\n  }\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n    const output = toPathComponents(path);\n    return {\n      cid: cid.CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n  throw errCode__default[\"default\"](new Error(`Unknown path type ${ path }`), 'ERR_BAD_PATH');\n};\nasync function* walkPath(path, blockstore, options = {}) {\n  let {cid, toResolve} = cidAndRest(path);\n  let name = cid.toString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n  while (true) {\n    const result = await index(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n    if (!result.entry && !result.next) {\n      throw errCode__default[\"default\"](new Error(`Could not resolve ${ path }`), 'ERR_NOT_FOUND');\n    }\n    if (result.entry) {\n      yield result.entry;\n    }\n    if (!result.next) {\n      return;\n    }\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n}\nasync function exporter(path, blockstore, options = {}) {\n  const result = await last__default[\"default\"](walkPath(path, blockstore, options));\n  if (!result) {\n    throw errCode__default[\"default\"](new Error(`Could not resolve ${ path }`), 'ERR_NOT_FOUND');\n  }\n  return result;\n}\nasync function* recursive(path, blockstore, options = {}) {\n  const node = await exporter(path, blockstore, options);\n  if (!node) {\n    return;\n  }\n  yield node;\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n      if (file instanceof Uint8Array) {\n        continue;\n      }\n      if (file.type === 'directory') {\n        yield* recurse(file, options);\n      }\n    }\n  }\n}\n\nexports.exporter = exporter;\nexports.recursive = recursive;\nexports.walkPath = walkPath;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}