{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidPublicKey = exports.getHkdf = exports.verifySignedPayload = exports.getHandshakePayload = exports.decodePayload = exports.getPeerIdFromPayload = exports.signPayload = exports.createHandshakePayload = exports.getPayload = exports.generateKeypair = void 0;\n\nvar hkdf_1 = require(\"@stablelib/hkdf\");\n\nvar sha256_1 = require(\"@stablelib/sha256\");\n\nvar x25519 = __importStar(require(\"@stablelib/x25519\"));\n\nvar buffer_1 = require(\"buffer\");\n\nvar peer_id_1 = __importDefault(require(\"peer-id\"));\n\nvar libp2p_crypto_1 = require(\"libp2p-crypto\");\n\nvar payload_1 = require(\"./proto/payload\");\n\nvar equals_1 = require(\"uint8arrays/equals\");\n\nvar NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;\n\nfunction generateKeypair() {\n  var keypair = x25519.generateKeyPair();\n  return {\n    publicKey: buffer_1.Buffer.from(keypair.publicKey.buffer, keypair.publicKey.byteOffset, keypair.publicKey.length),\n    privateKey: buffer_1.Buffer.from(keypair.secretKey.buffer, keypair.secretKey.byteOffset, keypair.secretKey.length)\n  };\n}\n\nexports.generateKeypair = generateKeypair;\n\nfunction getPayload(_x, _x2, _x3) {\n  return _getPayload.apply(this, arguments);\n}\n\nfunction _getPayload() {\n  _getPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(localPeer, staticPublicKey, earlyData) {\n    var signedPayload, earlyDataPayload;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return signPayload(localPeer, getHandshakePayload(staticPublicKey));\n\n          case 2:\n            signedPayload = _context.sent;\n            earlyDataPayload = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);\n            return _context.abrupt(\"return\", createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getPayload.apply(this, arguments);\n}\n\nexports.getPayload = getPayload;\n\nfunction createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {\n  var payloadInit = NoiseHandshakePayloadProto.create({\n    identityKey: buffer_1.Buffer.from(libp2pPublicKey),\n    identitySig: signedPayload,\n    data: earlyData !== null && earlyData !== void 0 ? earlyData : null\n  });\n  return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());\n}\n\nexports.createHandshakePayload = createHandshakePayload;\n\nfunction signPayload(_x4, _x5) {\n  return _signPayload.apply(this, arguments);\n}\n\nfunction _signPayload() {\n  _signPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peerId, payload) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.t0 = buffer_1.Buffer;\n            _context2.next = 3;\n            return peerId.privKey.sign(payload);\n\n          case 3:\n            _context2.t1 = _context2.sent;\n            return _context2.abrupt(\"return\", _context2.t0.from.call(_context2.t0, _context2.t1));\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _signPayload.apply(this, arguments);\n}\n\nexports.signPayload = signPayload;\n\nfunction getPeerIdFromPayload(_x6) {\n  return _getPeerIdFromPayload.apply(this, arguments);\n}\n\nfunction _getPeerIdFromPayload() {\n  _getPeerIdFromPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(payload) {\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));\n\n          case 2:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getPeerIdFromPayload.apply(this, arguments);\n}\n\nexports.getPeerIdFromPayload = getPeerIdFromPayload;\n\nfunction decodePayload(payload) {\n  return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));\n}\n\nexports.decodePayload = decodePayload;\n\nfunction getHandshakePayload(publicKey) {\n  return buffer_1.Buffer.concat([buffer_1.Buffer.from('noise-libp2p-static-key:'), publicKey]);\n}\n\nexports.getHandshakePayload = getHandshakePayload;\n\nfunction isValidPeerId(_x7, _x8) {\n  return _isValidPeerId.apply(this, arguments);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\n\n\nfunction _isValidPeerId() {\n  _isValidPeerId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(peerId, publicKeyProtobuf) {\n    var generatedPeerId;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return peer_id_1.default.createFromPubKey(publicKeyProtobuf);\n\n          case 2:\n            generatedPeerId = _context4.sent;\n            return _context4.abrupt(\"return\", equals_1.equals(generatedPeerId.id, peerId));\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _isValidPeerId.apply(this, arguments);\n}\n\nfunction verifySignedPayload(_x9, _x10, _x11) {\n  return _verifySignedPayload.apply(this, arguments);\n}\n\nfunction _verifySignedPayload() {\n  _verifySignedPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(noiseStaticKey, payload, remotePeer) {\n    var identityKey, generatedPayload, publicKey;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            identityKey = buffer_1.Buffer.from(payload.identityKey);\n            _context5.next = 3;\n            return isValidPeerId(remotePeer.id, identityKey);\n\n          case 3:\n            if (_context5.sent) {\n              _context5.next = 5;\n              break;\n            }\n\n            throw new Error(\"Peer ID doesn't match libp2p public key.\");\n\n          case 5:\n            generatedPayload = getHandshakePayload(noiseStaticKey); // Unmarshaling from PublicKey protobuf\n\n            publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey);\n            _context5.t0 = !payload.identitySig;\n\n            if (_context5.t0) {\n              _context5.next = 12;\n              break;\n            }\n\n            _context5.next = 11;\n            return publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig));\n\n          case 11:\n            _context5.t0 = !_context5.sent;\n\n          case 12:\n            if (!_context5.t0) {\n              _context5.next = 14;\n              break;\n            }\n\n            throw new Error(\"Static key doesn't match to peer that signed payload!\");\n\n          case 14:\n            _context5.next = 16;\n            return peer_id_1.default.createFromPubKey(identityKey);\n\n          case 16:\n            return _context5.abrupt(\"return\", _context5.sent);\n\n          case 17:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _verifySignedPayload.apply(this, arguments);\n}\n\nexports.verifySignedPayload = verifySignedPayload;\n\nfunction getHkdf(ck, ikm) {\n  var hkdf = new hkdf_1.HKDF(sha256_1.SHA256, ikm, ck);\n  var okmU8Array = hkdf.expand(96);\n  var okm = buffer_1.Buffer.from(okmU8Array.buffer, okmU8Array.byteOffset, okmU8Array.length);\n  var k1 = okm.slice(0, 32);\n  var k2 = okm.slice(32, 64);\n  var k3 = okm.slice(64, 96);\n  return [k1, k2, k3];\n}\n\nexports.getHkdf = getHkdf;\n\nfunction isValidPublicKey(pk) {\n  if (!buffer_1.Buffer.isBuffer(pk)) {\n    return false;\n  }\n\n  if (pk.length !== 32) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isValidPublicKey = isValidPublicKey;","map":{"version":3,"mappings":"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","names":["NoiseHandshakePayloadProto","payload_1","NoiseHandshakePayload","generateKeypair","keypair","x25519","generateKeyPair","publicKey","buffer_1","from","buffer","byteOffset","length","privateKey","secretKey","exports","getPayload","localPeer","staticPublicKey","earlyData","signPayload","getHandshakePayload","signedPayload","earlyDataPayload","alloc","createHandshakePayload","marshalPubKey","libp2pPublicKey","payloadInit","create","identityKey","identitySig","data","encode","finish","peerId","payload","privKey","sign","getPeerIdFromPayload","peer_id_1","createFromPubKey","decodePayload","toObject","decode","concat","isValidPeerId","publicKeyProtobuf","generatedPeerId","equals_1","id","verifySignedPayload","noiseStaticKey","remotePeer","Error","generatedPayload","libp2p_crypto_1","unmarshalPublicKey","verify","getHkdf","ck","ikm","hkdf","hkdf_1","sha256_1","okmU8Array","expand","okm","k1","slice","k2","k3","isValidPublicKey","pk","isBuffer"],"sourceRoot":"","sources":["../../src/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}