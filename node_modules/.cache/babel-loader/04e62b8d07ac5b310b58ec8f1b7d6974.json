{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _toConsumableArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar _asyncGeneratorDelegate = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate.js\").default;\n\nvar errCode = require('err-code');\n\nvar _require = require('../errors'),\n    messages = _require.messages,\n    codes = _require.codes;\n\nvar _require2 = require('./utils'),\n    storeAddresses = _require2.storeAddresses,\n    uniquePeers = _require2.uniquePeers,\n    requirePeers = _require2.requirePeers,\n    maybeLimitSource = _require2.maybeLimitSource;\n\nvar merge = require('it-merge');\n\nvar _require3 = require('it-pipe'),\n    pipe = _require3.pipe;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n */\n\n/**\n * @typedef {Object} GetData\n * @property {PeerId} from\n * @property {Uint8Array} val\n */\n\n\nvar ContentRouting = /*#__PURE__*/function () {\n  /**\n   * @class\n   * @param {import('..')} libp2p\n   */\n  function ContentRouting(libp2p) {\n    _classCallCheck(this, ContentRouting);\n\n    this.libp2p = libp2p;\n    /** @type {ContentRoutingModule[]} */\n\n    this.routers = libp2p._modules.contentRouting || [];\n    this.dht = libp2p._dht; // If we have the dht, add it to the available content routers\n\n    if (this.dht && libp2p._config.dht.enabled) {\n      this.routers.push(this.dht);\n    }\n  }\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @param {number} [options.maxNumProviders] - maximum number of providers to find\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  _createClass(ContentRouting, [{\n    key: \"findProviders\",\n    value: function findProviders(key) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (_this.routers.length) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('No content this.routers available'), 'NO_ROUTERS_AVAILABLE');\n\n              case 2:\n                return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pipe(merge.apply(void 0, _toConsumableArray(_this.routers.map(function (router) {\n                  return router.findProviders(key, options);\n                }))), function (source) {\n                  return storeAddresses(source, _this.libp2p.peerStore);\n                }, function (source) {\n                  return uniquePeers(source);\n                }, function (source) {\n                  return maybeLimitSource(source, options.maxNumProviders);\n                }, function (source) {\n                  return requirePeers(source);\n                })), _awaitAsyncGenerator), \"t0\", 3);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    }\n    /**\n     * Iterates over all content routers in parallel to notify it is\n     * a provider of the given key.\n     *\n     * @param {CID} key - The CID key of the content to find\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"provide\",\n    value: function () {\n      var _provide = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.routers.length) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE');\n\n              case 2:\n                _context2.next = 4;\n                return Promise.all(this.routers.map(function (router) {\n                  return router.provide(key);\n                }));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function provide(_x) {\n        return _provide.apply(this, arguments);\n      }\n\n      return provide;\n    }()\n    /**\n     * Store the given key/value pair in the DHT.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     * @param {Object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(key, value, options) {\n      if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n      }\n\n      return this.dht.put(key, value, options);\n    }\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Uint8Array} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<GetData>}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, options) {\n      if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n      }\n\n      return this.dht.get(key, options);\n    }\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Uint8Array} key\n     * @param {number} nVals\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<GetData[]>}\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function () {\n      var _getMany = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key, nVals, options) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(!this.libp2p.isStarted() || !this.dht.isStarted)) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n\n              case 2:\n                return _context3.abrupt(\"return\", this.dht.getMany(key, nVals, options));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getMany(_x2, _x3, _x4) {\n        return _getMany.apply(this, arguments);\n      }\n\n      return getMany;\n    }()\n  }]);\n\n  return ContentRouting;\n}();\n\nmodule.exports = ContentRouting;","map":{"version":3,"names":["errCode","require","messages","codes","storeAddresses","uniquePeers","requirePeers","maybeLimitSource","merge","pipe","ContentRouting","libp2p","routers","_modules","contentRouting","dht","_dht","_config","enabled","push","key","options","length","Error","map","router","findProviders","source","peerStore","maxNumProviders","Promise","all","provide","value","isStarted","NOT_STARTED_YET","DHT_NOT_STARTED","put","get","nVals","getMany","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/content-routing/index.js"],"sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst { messages, codes } = require('../errors')\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n} = require('./utils')\n\nconst merge = require('it-merge')\nconst { pipe } = require('it-pipe')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n */\n\n/**\n * @typedef {Object} GetData\n * @property {PeerId} from\n * @property {Uint8Array} val\n */\n\nclass ContentRouting {\n  /**\n   * @class\n   * @param {import('..')} libp2p\n   */\n  constructor (libp2p) {\n    this.libp2p = libp2p\n    /** @type {ContentRoutingModule[]} */\n    this.routers = libp2p._modules.contentRouting || []\n    this.dht = libp2p._dht\n\n    // If we have the dht, add it to the available content routers\n    if (this.dht && libp2p._config.dht.enabled) {\n      this.routers.push(this.dht)\n    }\n  }\n\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @param {number} [options.maxNumProviders] - maximum number of providers to find\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async * findProviders (key, options = {}) {\n    if (!this.routers.length) {\n      throw errCode(new Error('No content this.routers available'), 'NO_ROUTERS_AVAILABLE')\n    }\n\n    yield * pipe(\n      merge(\n        ...this.routers.map(router => router.findProviders(key, options))\n      ),\n      (source) => storeAddresses(source, this.libp2p.peerStore),\n      (source) => uniquePeers(source),\n      (source) => maybeLimitSource(source, options.maxNumProviders),\n      (source) => requirePeers(source)\n    )\n  }\n\n  /**\n   * Iterates over all content routers in parallel to notify it is\n   * a provider of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @returns {Promise<void>}\n   */\n  async provide (key) {\n    if (!this.routers.length) {\n      throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE')\n    }\n\n    await Promise.all(this.routers.map((router) => router.provide(key)))\n  }\n\n  /**\n   * Store the given key/value pair in the DHT.\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {Object} [options] - put options\n   * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n   * @returns {Promise<void>}\n   */\n  put (key, value, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n    }\n\n    return this.dht.put(key, value, options)\n  }\n\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute by default.\n   *\n   * @param {Uint8Array} key\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData>}\n   */\n  get (key, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n    }\n\n    return this.dht.get(key, options)\n  }\n\n  /**\n   * Get the `n` values to the given key without sorting.\n   *\n   * @param {Uint8Array} key\n   * @param {number} nVals\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData[]>}\n   */\n  async getMany (key, nVals, options) { // eslint-disable-line require-await\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n    }\n\n    return this.dht.getMany(key, nVals, options)\n  }\n}\n\nmodule.exports = ContentRouting\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}