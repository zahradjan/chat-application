{"ast":null,"code":"var _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar getIterator = require('get-iterator');\n\nmodule.exports = function (writable) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n      var maybeEndSource, error, errCb, errorHandler, closeCb, closed, closeHandler, finishCb, finished, finishHandler, drainCb, drainHandler, waitForDrainOrClose, waitForDone, cleanup, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, value;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              source = getIterator(source);\n\n              maybeEndSource = function maybeEndSource(source) {\n                if (typeof source.return === 'function') source.return();\n              };\n\n              error = null;\n              errCb = null;\n\n              errorHandler = function errorHandler(err) {\n                error = err;\n                if (errCb) errCb(err); // When the writable errors, try to end the source to exit iteration early\n\n                maybeEndSource(source);\n              };\n\n              closeCb = null;\n              closed = false;\n\n              closeHandler = function closeHandler() {\n                closed = true;\n                if (closeCb) closeCb();\n              };\n\n              finishCb = null;\n              finished = false;\n\n              finishHandler = function finishHandler() {\n                finished = true;\n                if (finishCb) finishCb();\n              };\n\n              drainCb = null;\n\n              drainHandler = function drainHandler() {\n                if (drainCb) drainCb();\n              };\n\n              waitForDrainOrClose = function waitForDrainOrClose() {\n                return new Promise(function (resolve, reject) {\n                  closeCb = drainCb = resolve;\n                  errCb = reject;\n                  writable.once('drain', drainHandler);\n                });\n              };\n\n              waitForDone = function waitForDone() {\n                // Immediately try to end the source\n                maybeEndSource(source);\n                return new Promise(function (resolve, reject) {\n                  if (closed || finished || error) return resolve();\n                  finishCb = closeCb = resolve;\n                  errCb = reject;\n                });\n              };\n\n              cleanup = function cleanup() {\n                writable.removeListener('error', errorHandler);\n                writable.removeListener('close', closeHandler);\n                writable.removeListener('finish', finishHandler);\n                writable.removeListener('drain', drainHandler);\n              };\n\n              writable.once('error', errorHandler);\n              writable.once('close', closeHandler);\n              writable.once('finish', finishHandler);\n              _context.prev = 19;\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context.prev = 22;\n              _iterator = _asyncIterator(source);\n\n            case 24:\n              _context.next = 26;\n              return _iterator.next();\n\n            case 26:\n              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                _context.next = 36;\n                break;\n              }\n\n              value = _step.value;\n\n              if (!(!writable.writable || writable.destroyed || error)) {\n                _context.next = 30;\n                break;\n              }\n\n              return _context.abrupt(\"break\", 36);\n\n            case 30:\n              if (!(writable.write(value) === false)) {\n                _context.next = 33;\n                break;\n              }\n\n              _context.next = 33;\n              return waitForDrainOrClose();\n\n            case 33:\n              _iteratorAbruptCompletion = false;\n              _context.next = 24;\n              break;\n\n            case 36:\n              _context.next = 42;\n              break;\n\n            case 38:\n              _context.prev = 38;\n              _context.t0 = _context[\"catch\"](22);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 42:\n              _context.prev = 42;\n              _context.prev = 43;\n\n              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                _context.next = 47;\n                break;\n              }\n\n              _context.next = 47;\n              return _iterator.return();\n\n            case 47:\n              _context.prev = 47;\n\n              if (!_didIteratorError) {\n                _context.next = 50;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 50:\n              return _context.finish(47);\n\n            case 51:\n              return _context.finish(42);\n\n            case 52:\n              _context.next = 58;\n              break;\n\n            case 54:\n              _context.prev = 54;\n              _context.t1 = _context[\"catch\"](19);\n\n              // error is set by stream error handler so only destroy stream if source threw\n              if (!error) {\n                writable.destroy();\n              } // could we be obscuring an error here?\n\n\n              error = _context.t1;\n\n            case 58:\n              _context.prev = 58;\n\n              // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)\n              if (writable.writable) {\n                writable.end();\n              } // Wait until we close or finish. This supports halfClosed streams\n\n\n              _context.next = 62;\n              return waitForDone();\n\n            case 62:\n              if (!error) {\n                _context.next = 64;\n                break;\n              }\n\n              throw error;\n\n            case 64:\n              _context.prev = 64;\n              // Clean up listeners\n              cleanup();\n              return _context.finish(64);\n\n            case 67:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[19, 54], [22, 38, 42, 52], [43,, 47, 51], [58,, 64, 67]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};","map":{"version":3,"names":["getIterator","require","module","exports","writable","source","maybeEndSource","return","error","errCb","errorHandler","err","closeCb","closed","closeHandler","finishCb","finished","finishHandler","drainCb","drainHandler","waitForDrainOrClose","Promise","resolve","reject","once","waitForDone","cleanup","removeListener","value","destroyed","write","destroy","end"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/stream-to-it/sink.js"],"sourcesContent":["const getIterator = require('get-iterator')\n\nmodule.exports = writable => async source => {\n  source = getIterator(source)\n\n  const maybeEndSource = (source) => {\n    if (typeof source.return === 'function') source.return()\n  }\n\n  let error = null\n  let errCb = null\n  const errorHandler = (err) => {\n    error = err\n    if (errCb) errCb(err)\n    // When the writable errors, try to end the source to exit iteration early\n    maybeEndSource(source)\n  }\n\n  let closeCb = null\n  let closed = false\n  const closeHandler = () => {\n    closed = true\n    if (closeCb) closeCb()\n  }\n\n  let finishCb = null\n  let finished = false\n  const finishHandler = () => {\n    finished = true\n    if (finishCb) finishCb()\n  }\n\n  let drainCb = null\n  const drainHandler = () => {\n    if (drainCb) drainCb()\n  }\n\n  const waitForDrainOrClose = () => {\n    return new Promise((resolve, reject) => {\n      closeCb = drainCb = resolve\n      errCb = reject\n      writable.once('drain', drainHandler)\n    })\n  }\n\n  const waitForDone = () => {\n    // Immediately try to end the source\n    maybeEndSource(source)\n    return new Promise((resolve, reject) => {\n      if (closed || finished || error) return resolve()\n      finishCb = closeCb = resolve\n      errCb = reject\n    })\n  }\n\n  const cleanup = () => {\n    writable.removeListener('error', errorHandler)\n    writable.removeListener('close', closeHandler)\n    writable.removeListener('finish', finishHandler)\n    writable.removeListener('drain', drainHandler)\n  }\n\n  writable.once('error', errorHandler)\n  writable.once('close', closeHandler)\n  writable.once('finish', finishHandler)\n\n  try {\n    for await (const value of source) {\n      if (!writable.writable || writable.destroyed || error) break\n\n      if (writable.write(value) === false) {\n        await waitForDrainOrClose()\n      }\n    }\n  } catch (err) {\n    // error is set by stream error handler so only destroy stream if source threw\n    if (!error) {\n      writable.destroy()\n    }\n\n    // could we be obscuring an error here?\n    error = err\n  }\n\n  try {\n    // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)\n    if (writable.writable) {\n      writable.end()\n    }\n\n    // Wait until we close or finish. This supports halfClosed streams\n    await waitForDone()\n\n    // Notify the user an error occurred\n    if (error) throw error\n  } finally {\n    // Clean up listeners\n    cleanup()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}