{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar hmac_1 = require(\"@stablelib/hmac\");\n\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n * HMAC-based Extract-and-Expand Key Derivation Function.\n *\n * Implements HKDF from RFC5869.\n *\n * Expands the given master key with salt and info into\n * a limited stream of key material.\n */\n\n\nvar HKDF =\n/** @class */\nfunction () {\n  /**\n   * Create a new HKDF instance for the given hash function\n   * with the master key, optional salt, and info.\n   *\n   * - Master key is a high-entropy secret key (not a password).\n   * - Salt is a non-secret random value.\n   * - Info is application- and/or context-specific information.\n   */\n  function HKDF(hash, key, salt, info) {\n    if (salt === void 0) {\n      salt = new Uint8Array(0);\n    }\n\n    this._counter = new Uint8Array(1); // starts with zero\n\n    this._hash = hash;\n    this._info = info; // HKDF-Extract uses salt as HMAC key, and key as data.\n\n    var okm = hmac_1.hmac(this._hash, salt, key); // Initialize HMAC for expanding with extracted key.\n\n    this._hmac = new hmac_1.HMAC(hash, okm); // Allocate buffer.\n\n    this._buffer = new Uint8Array(this._hmac.digestLength);\n    this._bufpos = this._buffer.length;\n  } // Fill buffer with new block of HKDF-Extract output.\n\n\n  HKDF.prototype._fillBuffer = function () {\n    // Increment counter.\n    this._counter[0]++;\n    var ctr = this._counter[0]; // Check if counter overflowed.\n\n    if (ctr === 0) {\n      throw new Error(\"hkdf: cannot expand more\");\n    } // Prepare HMAC instance for new data with old key.\n\n\n    this._hmac.reset(); // Hash in previous output if it was generated\n    // (i.e. counter is greater than 1).\n\n\n    if (ctr > 1) {\n      this._hmac.update(this._buffer);\n    } // Hash in info if it exists.\n\n\n    if (this._info) {\n      this._hmac.update(this._info);\n    } // Hash in the counter.\n\n\n    this._hmac.update(this._counter); // Output result to buffer and clean HMAC instance.\n\n\n    this._hmac.finish(this._buffer); // Reset buffer position.\n\n\n    this._bufpos = 0;\n  };\n  /**\n   * Expand returns next key material of the given length.\n   *\n   * It throws if expansion limit is reached (which is\n   * 254 digests of the underlying HMAC function).\n   */\n\n\n  HKDF.prototype.expand = function (length) {\n    var out = new Uint8Array(length);\n\n    for (var i = 0; i < out.length; i++) {\n      if (this._bufpos === this._buffer.length) {\n        this._fillBuffer();\n      }\n\n      out[i] = this._buffer[this._bufpos++];\n    }\n\n    return out;\n  };\n\n  HKDF.prototype.clean = function () {\n    this._hmac.clean();\n\n    wipe_1.wipe(this._buffer);\n    wipe_1.wipe(this._counter);\n    this._bufpos = 0;\n  };\n\n  return HKDF;\n}();\n\nexports.HKDF = HKDF; // TODO(dchest): maybe implement deriveKey?","map":{"version":3,"mappings":"cAAA;AACA;;;;;;AAOA;;AACA;AAEA;;;;;;;;;;AAQA;AAAA;AAAA;EAQI;;;;;;;;EAQA,cAAYA,IAAZ,EACIC,GADJ,EAEIC,IAFJ,EAGIC,IAHJ,EAGqB;IADjB;MAAAD,WAAWE,UAAX,CAAsB,CAAtB;IAAwB;;IAdpB,gBAAW,IAAIA,UAAJ,CAAe,CAAf,CAAX,CAea,CAfiB;;IAiBlC,KAAKC,KAAL,GAAaL,IAAb;IACA,KAAKM,KAAL,GAAaH,IAAb,CAHiB,CAKjB;;IACA,IAAMI,GAAG,GAAGC,YAAK,KAAKH,KAAV,EAAiBH,IAAjB,EAAuBD,GAAvB,CAAZ,CANiB,CAQjB;;IACA,KAAKQ,KAAL,GAAa,IAAID,WAAJ,CAASR,IAAT,EAAeO,GAAf,CAAb,CATiB,CAWjB;;IACA,KAAKG,OAAL,GAAe,IAAIN,UAAJ,CAAe,KAAKK,KAAL,CAAWE,YAA1B,CAAf;IACA,KAAKC,OAAL,GAAe,KAAKF,OAAL,CAAaG,MAA5B;EACH,CAjCL,CAmCI;;;EACQC,6BAAR;IACI;IACA,KAAKC,QAAL,CAAc,CAAd;IAEA,IAAMC,GAAG,GAAG,KAAKD,QAAL,CAAc,CAAd,CAAZ,CAJJ,CAMI;;IACA,IAAIC,GAAG,KAAK,CAAZ,EAAe;MACX,MAAM,IAAIC,KAAJ,CAAU,0BAAV,CAAN;IACH,CATL,CAWI;;;IACA,KAAKR,KAAL,CAAWS,KAAX,GAZJ,CAcI;IACA;;;IACA,IAAIF,GAAG,GAAG,CAAV,EAAa;MACT,KAAKP,KAAL,CAAWU,MAAX,CAAkB,KAAKT,OAAvB;IACH,CAlBL,CAoBI;;;IACA,IAAI,KAAKJ,KAAT,EAAgB;MACZ,KAAKG,KAAL,CAAWU,MAAX,CAAkB,KAAKb,KAAvB;IACH,CAvBL,CAyBI;;;IACA,KAAKG,KAAL,CAAWU,MAAX,CAAkB,KAAKJ,QAAvB,EA1BJ,CA4BI;;;IACA,KAAKN,KAAL,CAAWW,MAAX,CAAkB,KAAKV,OAAvB,EA7BJ,CA+BI;;;IACA,KAAKE,OAAL,GAAe,CAAf;EACH,CAjCO;EAmCR;;;;;;;;EAMAE,kCAAOD,MAAP,EAAqB;IACjB,IAAMQ,GAAG,GAAG,IAAIjB,UAAJ,CAAeS,MAAf,CAAZ;;IACA,KAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,GAAG,CAACR,MAAxB,EAAgCS,CAAC,EAAjC,EAAqC;MACjC,IAAI,KAAKV,OAAL,KAAiB,KAAKF,OAAL,CAAaG,MAAlC,EAA0C;QACtC,KAAKU,WAAL;MACH;;MACDF,GAAG,CAACC,CAAD,CAAH,GAAS,KAAKZ,OAAL,CAAa,KAAKE,OAAL,EAAb,CAAT;IACH;;IACD,OAAOS,GAAP;EACH,CATD;;EAWAP;IACI,KAAKL,KAAL,CAAWe,KAAX;;IACAC,YAAK,KAAKf,OAAV;IACAe,YAAK,KAAKV,QAAV;IACA,KAAKH,OAAL,GAAe,CAAf;EACH,CALD;;EAMJ;AAAC,CA9FD;;AAAac,oB,CAgGb","names":["hash","key","salt","info","Uint8Array","_hash","_info","okm","hmac_1","_hmac","_buffer","digestLength","_bufpos","length","HKDF","_counter","ctr","Error","reset","update","finish","out","i","_fillBuffer","clean","wipe_1","exports"],"sourceRoot":"","sources":["../hkdf.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}