{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _assertThisInitialized = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('libp2p:connection-manager'), {\n  error: debug('libp2p:connection-manager:err')\n});\n\nvar errcode = require('err-code');\n\nvar mergeOptions = require('merge-options');\n\nvar LatencyMonitor = require('./latency-monitor'); // @ts-ignore retimer does not have types\n\n\nvar retimer = require('retimer');\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar PeerId = require('peer-id');\n\nvar _require2 = require('../errors'),\n    ERR_INVALID_PARAMETERS = _require2.codes.ERR_INVALID_PARAMETERS;\n\nvar defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  autoDialInterval: 10000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n};\n/**\n * @typedef {import('../')} Libp2p\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n */\n\n/**\n * @typedef {Object} ConnectionManagerOptions\n * @property {number} [maxConnections = Infinity] - The maximum number of connections allowed.\n * @property {number} [minConnections = 0] - The minimum number of connections to avoid pruning.\n * @property {number} [maxData = Infinity] - The max data (in and out), per average interval to allow.\n * @property {number} [maxSentData = Infinity] - The max outgoing data, per average interval to allow.\n * @property {number} [maxReceivedData = Infinity] - The max incoming data, per average interval to allow.\n * @property {number} [maxEventLoopDelay = Infinity] - The upper limit the event loop can take to run.\n * @property {number} [pollInterval = 2000] - How often, in milliseconds, metrics and latency should be checked.\n * @property {number} [movingAverageInterval = 60000] - How often, in milliseconds, to compute averages.\n * @property {number} [defaultPeerValue = 1] - The value of the peer.\n * @property {boolean} [autoDial = true] - Should preemptively guarantee connections are above the low watermark.\n * @property {number} [autoDialInterval = 10000] - How often, in milliseconds, it should preemptively guarantee connections are above the low watermark.\n */\n\n/**\n *\n * @fires ConnectionManager#peer:connect Emitted when a new peer is connected.\n * @fires ConnectionManager#peer:disconnect Emitted when a peer is disconnected.\n */\n\nvar ConnectionManager = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(ConnectionManager, _EventEmitter);\n\n  var _super = _createSuper(ConnectionManager);\n\n  /**\n   * Responsible for managing known connections.\n   *\n   * @class\n   * @param {Libp2p} libp2p\n   * @param {ConnectionManagerOptions} options\n   */\n  function ConnectionManager(libp2p) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, ConnectionManager);\n\n    _this = _super.call(this);\n    _this._libp2p = libp2p;\n    _this._peerId = libp2p.peerId.toB58String();\n    _this._options = mergeOptions.call({\n      ignoreUndefined: true\n    }, defaultOptions, options);\n\n    if (_this._options.maxConnections < _this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS);\n    }\n\n    log('options: %j', _this._options);\n    /**\n     * Map of peer identifiers to their peer value for pruning connections.\n     *\n     * @type {Map<string, number>}\n     */\n\n    _this._peerValues = new Map();\n    /**\n     * Map of connections per peer\n     *\n     * @type {Map<string, Connection[]>}\n     */\n\n    _this.connections = new Map();\n    _this._started = false;\n    _this._timer = null;\n    _this._autoDialTimeout = null;\n    _this._checkMetrics = _this._checkMetrics.bind(_assertThisInitialized(_this));\n    _this._autoDial = _this._autoDial.bind(_assertThisInitialized(_this));\n    _this._latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: _this._options.pollInterval,\n      dataEmitIntervalMs: _this._options.pollInterval\n    });\n    return _this;\n  }\n  /**\n   * Get current number of open connections.\n   */\n\n\n  _createClass(ConnectionManager, [{\n    key: \"size\",\n    get: function get() {\n      return Array.from(this.connections.values()).reduce(function (accumulator, value) {\n        return accumulator + value.length;\n      }, 0);\n    }\n    /**\n     * Starts the Connection Manager. If Metrics are not enabled on libp2p\n     * only event loop and connection limits will be monitored.\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this._libp2p.metrics) {\n        this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval);\n      } // latency monitor\n\n\n      this._latencyMonitor.start();\n\n      this._onLatencyMeasure = this._onLatencyMeasure.bind(this);\n\n      this._latencyMonitor.on('data', this._onLatencyMeasure);\n\n      this._started = true;\n      log('started');\n      this._options.autoDial && this._autoDial();\n    }\n    /**\n     * Stops the Connection Manager\n     *\n     * @async\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this._autoDialTimeout && this._autoDialTimeout.clear();\n                this._timer && this._timer.clear();\n\n                this._latencyMonitor.removeListener('data', this._onLatencyMeasure);\n\n                this._latencyMonitor.stop();\n\n                this._started = false;\n                _context.next = 7;\n                return this._close();\n\n              case 7:\n                log('stopped');\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * Cleans up the connections\n     *\n     * @async\n     */\n\n  }, {\n    key: \"_close\",\n    value: function () {\n      var _close2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var tasks, _iterator, _step, connectionList, _iterator2, _step2, connection;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // Close all connections we're tracking\n                tasks = [];\n                _iterator = _createForOfIteratorHelper(this.connections.values());\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    connectionList = _step.value;\n                    _iterator2 = _createForOfIteratorHelper(connectionList);\n\n                    try {\n                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                        connection = _step2.value;\n                        tasks.push(connection.close());\n                      }\n                    } catch (err) {\n                      _iterator2.e(err);\n                    } finally {\n                      _iterator2.f();\n                    }\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                _context2.next = 5;\n                return Promise.all(tasks);\n\n              case 5:\n                this.connections.clear();\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _close() {\n        return _close2.apply(this, arguments);\n      }\n\n      return _close;\n    }()\n    /**\n     * Sets the value of the given peer. Peers with lower values\n     * will be disconnected first.\n     *\n     * @param {PeerId} peerId\n     * @param {number} value - A number between 0 and 1\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setPeerValue\",\n    value: function setPeerValue(peerId, value) {\n      if (value < 0 || value > 1) {\n        throw new Error('value should be a number between 0 and 1');\n      }\n\n      this._peerValues.set(peerId.toB58String(), value);\n    }\n    /**\n     * Checks the libp2p metrics to determine if any values have exceeded\n     * the configured maximums.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_checkMetrics\",\n    value: function _checkMetrics() {\n      if (this._libp2p.metrics) {\n        var movingAverages = this._libp2p.metrics.global.movingAverages; // @ts-ignore moving averages object types\n\n        var received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage();\n\n        this._checkMaxLimit('maxReceivedData', received); // @ts-ignore moving averages object types\n\n\n        var sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage();\n\n        this._checkMaxLimit('maxSentData', sent);\n\n        var total = received + sent;\n\n        this._checkMaxLimit('maxData', total);\n\n        log('metrics update', total);\n        this._timer = retimer(this._checkMetrics, this._options.pollInterval);\n      }\n    }\n    /**\n     * Tracks the incoming connection and check the connection limit\n     *\n     * @param {Connection} connection\n     * @returns {void}\n     */\n\n  }, {\n    key: \"onConnect\",\n    value: function onConnect(connection) {\n      var peerId = connection.remotePeer;\n      var peerIdStr = peerId.toB58String();\n      var storedConn = this.connections.get(peerIdStr);\n      this.emit('peer:connect', connection);\n\n      if (storedConn) {\n        storedConn.push(connection);\n      } else {\n        this.connections.set(peerIdStr, [connection]);\n      }\n\n      this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey);\n\n      if (!this._peerValues.has(peerIdStr)) {\n        this._peerValues.set(peerIdStr, this._options.defaultPeerValue);\n      }\n\n      this._checkMaxLimit('maxConnections', this.size);\n    }\n    /**\n     * Removes the connection from tracking\n     *\n     * @param {Connection} connection\n     * @returns {void}\n     */\n\n  }, {\n    key: \"onDisconnect\",\n    value: function onDisconnect(connection) {\n      var peerId = connection.remotePeer.toB58String();\n      var storedConn = this.connections.get(peerId);\n\n      if (storedConn && storedConn.length > 1) {\n        storedConn = storedConn.filter(function (conn) {\n          return conn.id !== connection.id;\n        });\n        this.connections.set(peerId, storedConn);\n      } else if (storedConn) {\n        this.connections.delete(peerId);\n\n        this._peerValues.delete(connection.remotePeer.toB58String());\n\n        this.emit('peer:disconnect', connection);\n      }\n    }\n    /**\n     * Get a connection with a peer.\n     *\n     * @param {PeerId} peerId\n     * @returns {Connection|null}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(peerId) {\n      var connections = this.getAll(peerId);\n\n      if (connections.length) {\n        return connections[0];\n      }\n\n      return null;\n    }\n    /**\n     * Get all open connections with a peer.\n     *\n     * @param {PeerId} peerId\n     * @returns {Connection[]}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll(peerId) {\n      if (!PeerId.isPeerId(peerId)) {\n        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n      }\n\n      var id = peerId.toB58String();\n      var connections = this.connections.get(id); // Return all open connections\n\n      if (connections) {\n        return connections.filter(function (connection) {\n          return connection.stat.status === 'open';\n        });\n      }\n\n      return [];\n    }\n    /**\n     * If the event loop is slow, maybe close a connection\n     *\n     * @private\n     * @param {*} summary - The LatencyMonitor summary\n     */\n\n  }, {\n    key: \"_onLatencyMeasure\",\n    value: function _onLatencyMeasure(summary) {\n      this._checkMaxLimit('maxEventLoopDelay', summary.avgMs);\n    }\n    /**\n     * If the `value` of `name` has exceeded its limit, maybe close a connection\n     *\n     * @private\n     * @param {string} name - The name of the field to check limits for\n     * @param {number} value - The current value of the field\n     */\n\n  }, {\n    key: \"_checkMaxLimit\",\n    value: function _checkMaxLimit(name, value) {\n      var limit = this._options[name];\n      log('checking limit of %s. current value: %d of %d', name, value, limit);\n\n      if (value > limit) {\n        log('%s: limit exceeded: %s, %d', this._peerId, name, value);\n\n        this._maybeDisconnectOne();\n      }\n    }\n    /**\n     * Proactively tries to connect to known peers stored in the PeerStore.\n     * It will keep the number of connections below the upper limit and sort\n     * the peers to connect based on wether we know their keys and protocols.\n     *\n     * @async\n     * @private\n     */\n\n  }, {\n    key: \"_autoDial\",\n    value: function () {\n      var _autoDial2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var minConnections, peers, i;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                minConnections = this._options.minConnections; // Already has enough connections\n\n                if (!(this.size >= minConnections)) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);\n                return _context3.abrupt(\"return\");\n\n              case 4:\n                // Sort peers on wether we know protocols of public keys for them\n                peers = Array.from(this._libp2p.peerStore.peers.values()).sort(function (a, b) {\n                  if (b.protocols && b.protocols.length && (!a.protocols || !a.protocols.length)) {\n                    return 1;\n                  } else if (b.id.pubKey && !a.id.pubKey) {\n                    return 1;\n                  }\n\n                  return -1;\n                });\n                i = 0;\n\n              case 6:\n                if (!(i < peers.length && this.size < minConnections)) {\n                  _context3.next = 22;\n                  break;\n                }\n\n                if (this.get(peers[i].id)) {\n                  _context3.next = 19;\n                  break;\n                }\n\n                log('connecting to a peerStore stored peer %s', peers[i].id.toB58String());\n                _context3.prev = 9;\n                _context3.next = 12;\n                return this._libp2p.dialer.connectToPeer(peers[i].id);\n\n              case 12:\n                if (this._started) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 14:\n                _context3.next = 19;\n                break;\n\n              case 16:\n                _context3.prev = 16;\n                _context3.t0 = _context3[\"catch\"](9);\n                log.error('could not connect to peerStore stored peer', _context3.t0);\n\n              case 19:\n                i++;\n                _context3.next = 6;\n                break;\n\n              case 22:\n                this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);\n\n              case 23:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[9, 16]]);\n      }));\n\n      function _autoDial() {\n        return _autoDial2.apply(this, arguments);\n      }\n\n      return _autoDial;\n    }()\n    /**\n     * If we have more connections than our maximum, close a connection\n     * to the lowest valued peer.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_maybeDisconnectOne\",\n    value: function _maybeDisconnectOne() {\n      if (this._options.minConnections < this.connections.size) {\n        var peerValues = Array.from(new Map(_toConsumableArray(this._peerValues.entries()).sort(function (a, b) {\n          return a[1] - b[1];\n        })));\n        log('%s: sorted peer values: %j', this._peerId, peerValues);\n        var disconnectPeer = peerValues[0];\n\n        if (disconnectPeer) {\n          var peerId = disconnectPeer[0];\n          log('%s: lowest value peer is %s', this._peerId, peerId);\n          log('%s: closing a connection to %j', this._peerId, peerId);\n\n          var _iterator3 = _createForOfIteratorHelper(this.connections.values()),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var connections = _step3.value;\n\n              if (connections[0].remotePeer.toB58String() === peerId) {\n                connections[0].close();\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      }\n    }\n  }]);\n\n  return ConnectionManager;\n}(EventEmitter);\n\nmodule.exports = ConnectionManager;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errcode","mergeOptions","LatencyMonitor","retimer","EventEmitter","PeerId","ERR_INVALID_PARAMETERS","codes","defaultOptions","maxConnections","Infinity","minConnections","maxData","maxSentData","maxReceivedData","maxEventLoopDelay","pollInterval","autoDialInterval","movingAverageInterval","defaultPeerValue","ConnectionManager","libp2p","options","_libp2p","_peerId","peerId","toB58String","_options","call","ignoreUndefined","Error","_peerValues","Map","connections","_started","_timer","_autoDialTimeout","_checkMetrics","bind","_autoDial","_latencyMonitor","latencyCheckIntervalMs","dataEmitIntervalMs","Array","from","values","reduce","accumulator","value","length","metrics","start","_onLatencyMeasure","on","autoDial","clear","removeListener","stop","_close","tasks","connectionList","connection","push","close","Promise","all","set","movingAverages","global","received","dataReceived","movingAverage","_checkMaxLimit","sent","dataSent","total","remotePeer","peerIdStr","storedConn","get","emit","peerStore","keyBook","pubKey","has","size","filter","conn","id","delete","getAll","isPeerId","stat","status","summary","avgMs","name","limit","_maybeDisconnectOne","peers","sort","a","b","protocols","i","dialer","connectToPeer","peerValues","entries","disconnectPeer","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/connection-manager/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:connection-manager'), {\n  error: debug('libp2p:connection-manager:err')\n})\n\nconst errcode = require('err-code')\nconst mergeOptions = require('merge-options')\nconst LatencyMonitor = require('./latency-monitor')\n// @ts-ignore retimer does not have types\nconst retimer = require('retimer')\n\nconst { EventEmitter } = require('events')\n\nconst PeerId = require('peer-id')\n\nconst {\n  codes: { ERR_INVALID_PARAMETERS }\n} = require('../errors')\n\nconst defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  autoDialInterval: 10000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n}\n\n/**\n * @typedef {import('../')} Libp2p\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n */\n\n/**\n * @typedef {Object} ConnectionManagerOptions\n * @property {number} [maxConnections = Infinity] - The maximum number of connections allowed.\n * @property {number} [minConnections = 0] - The minimum number of connections to avoid pruning.\n * @property {number} [maxData = Infinity] - The max data (in and out), per average interval to allow.\n * @property {number} [maxSentData = Infinity] - The max outgoing data, per average interval to allow.\n * @property {number} [maxReceivedData = Infinity] - The max incoming data, per average interval to allow.\n * @property {number} [maxEventLoopDelay = Infinity] - The upper limit the event loop can take to run.\n * @property {number} [pollInterval = 2000] - How often, in milliseconds, metrics and latency should be checked.\n * @property {number} [movingAverageInterval = 60000] - How often, in milliseconds, to compute averages.\n * @property {number} [defaultPeerValue = 1] - The value of the peer.\n * @property {boolean} [autoDial = true] - Should preemptively guarantee connections are above the low watermark.\n * @property {number} [autoDialInterval = 10000] - How often, in milliseconds, it should preemptively guarantee connections are above the low watermark.\n */\n\n/**\n *\n * @fires ConnectionManager#peer:connect Emitted when a new peer is connected.\n * @fires ConnectionManager#peer:disconnect Emitted when a peer is disconnected.\n */\nclass ConnectionManager extends EventEmitter {\n  /**\n   * Responsible for managing known connections.\n   *\n   * @class\n   * @param {Libp2p} libp2p\n   * @param {ConnectionManagerOptions} options\n   */\n  constructor (libp2p, options = {}) {\n    super()\n\n    this._libp2p = libp2p\n    this._peerId = libp2p.peerId.toB58String()\n\n    this._options = mergeOptions.call({ ignoreUndefined: true }, defaultOptions, options)\n    if (this._options.maxConnections < this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS)\n    }\n\n    log('options: %j', this._options)\n\n    /**\n     * Map of peer identifiers to their peer value for pruning connections.\n     *\n     * @type {Map<string, number>}\n     */\n    this._peerValues = new Map()\n\n    /**\n     * Map of connections per peer\n     *\n     * @type {Map<string, Connection[]>}\n     */\n    this.connections = new Map()\n\n    this._started = false\n    this._timer = null\n    this._autoDialTimeout = null\n    this._checkMetrics = this._checkMetrics.bind(this)\n    this._autoDial = this._autoDial.bind(this)\n\n    this._latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: this._options.pollInterval,\n      dataEmitIntervalMs: this._options.pollInterval\n    })\n  }\n\n  /**\n   * Get current number of open connections.\n   */\n  get size () {\n    return Array.from(this.connections.values())\n      .reduce((accumulator, value) => accumulator + value.length, 0)\n  }\n\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n  start () {\n    if (this._libp2p.metrics) {\n      this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval)\n    }\n\n    // latency monitor\n    this._latencyMonitor.start()\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this)\n    this._latencyMonitor.on('data', this._onLatencyMeasure)\n\n    this._started = true\n    log('started')\n\n    this._options.autoDial && this._autoDial()\n  }\n\n  /**\n   * Stops the Connection Manager\n   *\n   * @async\n   */\n  async stop () {\n    this._autoDialTimeout && this._autoDialTimeout.clear()\n    this._timer && this._timer.clear()\n\n    this._latencyMonitor.removeListener('data', this._onLatencyMeasure)\n    this._latencyMonitor.stop()\n\n    this._started = false\n    await this._close()\n    log('stopped')\n  }\n\n  /**\n   * Cleans up the connections\n   *\n   * @async\n   */\n  async _close () {\n    // Close all connections we're tracking\n    const tasks = []\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push(connection.close())\n      }\n    }\n\n    await Promise.all(tasks)\n    this.connections.clear()\n  }\n\n  /**\n   * Sets the value of the given peer. Peers with lower values\n   * will be disconnected first.\n   *\n   * @param {PeerId} peerId\n   * @param {number} value - A number between 0 and 1\n   * @returns {void}\n   */\n  setPeerValue (peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1')\n    }\n    this._peerValues.set(peerId.toB58String(), value)\n  }\n\n  /**\n   * Checks the libp2p metrics to determine if any values have exceeded\n   * the configured maximums.\n   *\n   * @private\n   */\n  _checkMetrics () {\n    if (this._libp2p.metrics) {\n      const movingAverages = this._libp2p.metrics.global.movingAverages\n      // @ts-ignore moving averages object types\n      const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage()\n      this._checkMaxLimit('maxReceivedData', received)\n      // @ts-ignore moving averages object types\n      const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage()\n      this._checkMaxLimit('maxSentData', sent)\n      const total = received + sent\n      this._checkMaxLimit('maxData', total)\n      log('metrics update', total)\n      this._timer = retimer(this._checkMetrics, this._options.pollInterval)\n    }\n  }\n\n  /**\n   * Tracks the incoming connection and check the connection limit\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n  onConnect (connection) {\n    const peerId = connection.remotePeer\n    const peerIdStr = peerId.toB58String()\n    const storedConn = this.connections.get(peerIdStr)\n\n    this.emit('peer:connect', connection)\n    if (storedConn) {\n      storedConn.push(connection)\n    } else {\n      this.connections.set(peerIdStr, [connection])\n    }\n\n    this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey)\n\n    if (!this._peerValues.has(peerIdStr)) {\n      this._peerValues.set(peerIdStr, this._options.defaultPeerValue)\n    }\n\n    this._checkMaxLimit('maxConnections', this.size)\n  }\n\n  /**\n   * Removes the connection from tracking\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n  onDisconnect (connection) {\n    const peerId = connection.remotePeer.toB58String()\n    let storedConn = this.connections.get(peerId)\n\n    if (storedConn && storedConn.length > 1) {\n      storedConn = storedConn.filter((conn) => conn.id !== connection.id)\n      this.connections.set(peerId, storedConn)\n    } else if (storedConn) {\n      this.connections.delete(peerId)\n      this._peerValues.delete(connection.remotePeer.toB58String())\n      this.emit('peer:disconnect', connection)\n    }\n  }\n\n  /**\n   * Get a connection with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection|null}\n   */\n  get (peerId) {\n    const connections = this.getAll(peerId)\n    if (connections.length) {\n      return connections[0]\n    }\n    return null\n  }\n\n  /**\n   * Get all open connections with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection[]}\n   */\n  getAll (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const id = peerId.toB58String()\n    const connections = this.connections.get(id)\n\n    // Return all open connections\n    if (connections) {\n      return connections.filter(connection => connection.stat.status === 'open')\n    }\n    return []\n  }\n\n  /**\n   * If the event loop is slow, maybe close a connection\n   *\n   * @private\n   * @param {*} summary - The LatencyMonitor summary\n   */\n  _onLatencyMeasure (summary) {\n    this._checkMaxLimit('maxEventLoopDelay', summary.avgMs)\n  }\n\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   *\n   * @private\n   * @param {string} name - The name of the field to check limits for\n   * @param {number} value - The current value of the field\n   */\n  _checkMaxLimit (name, value) {\n    const limit = this._options[name]\n    log('checking limit of %s. current value: %d of %d', name, value, limit)\n    if (value > limit) {\n      log('%s: limit exceeded: %s, %d', this._peerId, name, value)\n      this._maybeDisconnectOne()\n    }\n  }\n\n  /**\n   * Proactively tries to connect to known peers stored in the PeerStore.\n   * It will keep the number of connections below the upper limit and sort\n   * the peers to connect based on wether we know their keys and protocols.\n   *\n   * @async\n   * @private\n   */\n  async _autoDial () {\n    const minConnections = this._options.minConnections\n\n    // Already has enough connections\n    if (this.size >= minConnections) {\n      this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval)\n      return\n    }\n\n    // Sort peers on wether we know protocols of public keys for them\n    const peers = Array.from(this._libp2p.peerStore.peers.values())\n      .sort((a, b) => {\n        if (b.protocols && b.protocols.length && (!a.protocols || !a.protocols.length)) {\n          return 1\n        } else if (b.id.pubKey && !a.id.pubKey) {\n          return 1\n        }\n        return -1\n      })\n\n    for (let i = 0; i < peers.length && this.size < minConnections; i++) {\n      if (!this.get(peers[i].id)) {\n        log('connecting to a peerStore stored peer %s', peers[i].id.toB58String())\n        try {\n          await this._libp2p.dialer.connectToPeer(peers[i].id)\n\n          // Connection Manager was stopped\n          if (!this._started) {\n            return\n          }\n        } catch (err) {\n          log.error('could not connect to peerStore stored peer', err)\n        }\n      }\n    }\n\n    this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval)\n  }\n\n  /**\n   * If we have more connections than our maximum, close a connection\n   * to the lowest valued peer.\n   *\n   * @private\n   */\n  _maybeDisconnectOne () {\n    if (this._options.minConnections < this.connections.size) {\n      const peerValues = Array.from(new Map([...this._peerValues.entries()].sort((a, b) => a[1] - b[1])))\n      log('%s: sorted peer values: %j', this._peerId, peerValues)\n      const disconnectPeer = peerValues[0]\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0]\n        log('%s: lowest value peer is %s', this._peerId, peerId)\n        log('%s: closing a connection to %j', this._peerId, peerId)\n        for (const connections of this.connections.values()) {\n          if (connections[0].remotePeer.toB58String() === peerId) {\n            connections[0].close()\n            break\n          }\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = ConnectionManager\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}