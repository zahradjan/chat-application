{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../types/message/entry')} BitswapMessageEntry\n * @typedef {import('peer-id')} PeerId\n */\n\nconst {\n  CID\n} = require('multiformats');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst Message = require('../types/message');\n\nconst WantType = Message.WantType;\n\nconst Wantlist = require('../types/wantlist');\n\nconst Ledger = require('./ledger');\n\nconst RequestQueue = require('./req-queue');\n\nconst TaskMerger = require('./task-merger');\n\nconst {\n  logger\n} = require('../utils'); // The ideal size of the batched payload. We try to pop this much data off the\n// request queue, but\n// - if there isn't any more data in the queue we send whatever we have\n// - if there are several small items in the queue (eg HAVE response) followed\n//   by one big item (eg a block) that would exceed this target size, we\n//   include the big item in the message\n\n\nconst TARGET_MESSAGE_SIZE = 16 * 1024; // If the client sends a want-have, and the engine has the corresponding block,\n// we check the size of the block and if it's small enough we send the block\n// itself, rather than sending a HAVE.\n// This constant defines the maximum size up to which we replace a HAVE with\n// a block.\n\nconst MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;\n\nclass DecisionEngine {\n  /**\n   * @param {PeerId} peerId\n   * @param {import('interface-blockstore').Blockstore} blockstore\n   * @param {import('../network')} network\n   * @param {import('../stats')} stats\n   * @param {Object} [opts]\n   * @param {number} [opts.targetMessageSize]\n   * @param {number} [opts.maxSizeReplaceHasWithBlock]\n   */\n  constructor(peerId, blockstore, network, stats) {\n    let opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    this._log = logger(peerId, 'engine');\n    this.blockstore = blockstore;\n    this.network = network;\n    this._stats = stats;\n    this._opts = this._processOpts(opts); // A list of of ledgers by their partner id\n\n    /** @type {Map<string, Ledger>} */\n\n    this.ledgerMap = new Map();\n    this._running = false; // Queue of want-have / want-block per peer\n\n    this._requestQueue = new RequestQueue(TaskMerger);\n  }\n  /**\n   * @template {Object} Opts\n   * @param {Opts} opts\n   * @returns {Opts & {maxSizeReplaceHasWithBlock:number, targetMessageSize:number}}\n   * @private\n   */\n\n\n  _processOpts(opts) {\n    return {\n      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n      targetMessageSize: TARGET_MESSAGE_SIZE,\n      ...opts\n    };\n  }\n\n  _scheduleProcessTasks() {\n    setTimeout(() => {\n      this._processTasks();\n    });\n  }\n  /**\n   * Pull tasks off the request queue and send a message to the corresponding\n   * peer\n   */\n\n\n  async _processTasks() {\n    if (!this._running) {\n      return;\n    }\n\n    const {\n      peerId,\n      tasks,\n      pendingSize\n    } = this._requestQueue.popTasks(this._opts.targetMessageSize);\n\n    if (tasks.length === 0) {\n      return;\n    } // Create a new message\n\n\n    const msg = new Message(false); // Amount of data in the request queue still waiting to be popped\n\n    msg.setPendingBytes(pendingSize); // Split out want-blocks, want-haves and DONT_HAVEs\n\n    const blockCids = [];\n    const blockTasks = new Map();\n\n    for (const task of tasks) {\n      const cid = CID.parse(task.topic);\n\n      if (task.data.haveBlock) {\n        if (task.data.isWantBlock) {\n          blockCids.push(cid);\n          blockTasks.set(task.topic, task.data);\n        } else {\n          // Add HAVES to the message\n          msg.addHave(cid);\n        }\n      } else {\n        // Add DONT_HAVEs to the message\n        msg.addDontHave(cid);\n      }\n    }\n\n    const blocks = await this._getBlocks(blockCids);\n\n    for (const [topic, taskData] of blockTasks) {\n      const cid = CID.parse(topic);\n      const blk = blocks.get(topic); // If the block was found (it has not been removed)\n\n      if (blk) {\n        // Add the block to the message\n        msg.addBlock(cid, blk);\n      } else {\n        // The block was not found. If the client requested DONT_HAVE,\n        // add DONT_HAVE to the message.\n        if (taskData.sendDontHave) {\n          msg.addDontHave(cid);\n        }\n      }\n    } // If there's nothing in the message, bail out\n\n\n    if (msg.empty) {\n      peerId && this._requestQueue.tasksDone(peerId, tasks); // Trigger the next round of task processing\n\n      this._scheduleProcessTasks();\n\n      return;\n    }\n\n    try {\n      // Send the message\n      peerId && (await this.network.sendMessage(peerId, msg)); // Peform sent message accounting\n\n      for (const [cidStr, block] of blocks.entries()) {\n        peerId && this.messageSent(peerId, CID.parse(cidStr), block);\n      }\n    } catch (err) {\n      this._log.error(err);\n    } // Free the tasks up from the request queue\n\n\n    peerId && this._requestQueue.tasksDone(peerId, tasks); // Trigger the next round of task processing\n\n    this._scheduleProcessTasks();\n  }\n  /**\n   * @param {PeerId} peerId\n   * @returns {Map<string, import('../types/wantlist/entry')>}\n   */\n\n\n  wantlistForPeer(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger = this.ledgerMap.get(peerIdStr);\n    return ledger ? ledger.wantlist.sortedEntries() : new Map();\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  ledgerForPeer(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger = this.ledgerMap.get(peerIdStr);\n\n    if (!ledger) {\n      return null;\n    }\n\n    return {\n      peer: ledger.partner,\n      value: ledger.debtRatio(),\n      sent: ledger.accounting.bytesSent,\n      recv: ledger.accounting.bytesRecv,\n      exchanged: ledger.exchangeCount\n    };\n  }\n  /**\n   * @returns {PeerId[]}\n   */\n\n\n  peers() {\n    return Array.from(this.ledgerMap.values()).map(l => l.partner);\n  }\n  /**\n   * Receive blocks either from an incoming message from the network, or from\n   * blocks being added by the client on the localhost (eg IPFS add)\n   *\n   * @param {{ cid: CID, data: Uint8Array }[]} blocks\n   */\n\n\n  receivedBlocks(blocks) {\n    if (!blocks.length) {\n      return;\n    } // For each connected peer, check if it wants the block we received\n\n\n    for (const ledger of this.ledgerMap.values()) {\n      for (const block of blocks) {\n        // Filter out blocks that we don't want\n        const want = ledger.wantlistContains(block.cid);\n\n        if (!want) {\n          continue;\n        } // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n\n\n        const blockSize = block.data.length;\n\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);\n\n        let entrySize = blockSize;\n\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid);\n        }\n\n        this._requestQueue.pushTasks(ledger.partner, [{\n          topic: want.cid.toString(base58btc),\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            blockSize,\n            isWantBlock,\n            haveBlock: true,\n            sendDontHave: false\n          }\n        }]);\n      }\n    }\n\n    this._scheduleProcessTasks();\n  }\n  /**\n   * Handle incoming messages\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   * @returns {Promise<void>}\n   */\n\n\n  async messageReceived(peerId, msg) {\n    const ledger = this._findOrCreate(peerId);\n\n    if (msg.empty) {\n      return;\n    } // If the message has a full wantlist, clear the current wantlist\n\n\n    if (msg.full) {\n      ledger.wantlist = new Wantlist();\n    } // Record the amount of block data received\n\n\n    this._updateBlockAccounting(msg.blocks, ledger);\n\n    if (msg.wantlist.size === 0) {\n      this._scheduleProcessTasks();\n\n      return;\n    } // Clear cancelled wants and add new wants to the ledger\n\n    /** @type {CID[]} */\n\n\n    const cancels = [];\n    /** @type {BitswapMessageEntry[]} */\n\n    const wants = [];\n    msg.wantlist.forEach(entry => {\n      if (entry.cancel) {\n        ledger.cancelWant(entry.cid);\n        cancels.push(entry.cid);\n      } else {\n        ledger.wants(entry.cid, entry.priority, entry.wantType);\n        wants.push(entry);\n      }\n    });\n\n    this._cancelWants(peerId, cancels);\n\n    await this._addWants(peerId, wants);\n\n    this._scheduleProcessTasks();\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID[]} cids\n   * @returns {void}\n   */\n\n\n  _cancelWants(peerId, cids) {\n    for (const c of cids) {\n      this._requestQueue.remove(c.toString(base58btc), peerId);\n    }\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {BitswapMessageEntry[]} wants\n   * @returns {Promise<void>}\n   */\n\n\n  async _addWants(peerId, wants) {\n    // Get the size of each wanted block\n    const blockSizes = await this._getBlockSizes(wants.map(w => w.cid));\n    const tasks = [];\n\n    for (const want of wants) {\n      const id = want.cid.toString(base58btc);\n      const blockSize = blockSizes.get(id); // If the block was not found\n\n      if (blockSize == null) {\n        // Only add the task to the queue if the requester wants a DONT_HAVE\n        if (want.sendDontHave) {\n          tasks.push({\n            topic: id,\n            priority: want.priority,\n            size: Message.blockPresenceSize(want.cid),\n            data: {\n              isWantBlock: want.wantType === WantType.Block,\n              blockSize: 0,\n              haveBlock: false,\n              sendDontHave: want.sendDontHave\n            }\n          });\n        }\n      } else {\n        // The block was found, add it to the queue\n        // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize); // entrySize is the amount of space the entry takes up in the\n        // message we send to the recipient. If we're sending a block, the\n        // entrySize is the size of the block. Otherwise it's the size of\n        // a block presence entry.\n\n\n        let entrySize = blockSize;\n\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid);\n        }\n\n        tasks.push({\n          topic: id,\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            isWantBlock,\n            blockSize,\n            haveBlock: true,\n            sendDontHave: want.sendDontHave\n          }\n        });\n      }\n\n      this._requestQueue.pushTasks(peerId, tasks);\n    }\n  }\n  /**\n   * @private\n   * @param {import('../types/message/message').Message.Wantlist.WantType} wantType\n   * @param {number} blockSize\n   */\n\n\n  _sendAsBlock(wantType, blockSize) {\n    return wantType === WantType.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;\n  }\n  /**\n   * @private\n   * @param {CID[]} cids\n   * @returns {Promise<Map<string, number>>}\n   */\n\n\n  async _getBlockSizes(cids) {\n    const blocks = await this._getBlocks(cids);\n    return new Map([...blocks].map(_ref => {\n      let [k, v] = _ref;\n      return [k, v.length];\n    }));\n  }\n  /**\n   * @private\n   * @param {CID[]} cids\n   * @returns {Promise<Map<string, Uint8Array>>}\n   */\n\n\n  async _getBlocks(cids) {\n    const res = new Map();\n    await Promise.all(cids.map(async cid => {\n      try {\n        const block = await this.blockstore.get(cid);\n        res.set(cid.toString(base58btc), block);\n      } catch (e) {\n        if (e.code !== 'ERR_NOT_FOUND') {\n          this._log.error('failed to query blockstore for %s: %s', cid, e);\n        }\n      }\n    }));\n    return res;\n  }\n  /**\n   * @private\n   * @param {Map<string, Uint8Array>} blocksMap\n   * @param {Ledger} ledger\n   */\n\n\n  _updateBlockAccounting(blocksMap, ledger) {\n    for (const block of blocksMap.values()) {\n      this._log('got block (%s bytes)', block.length);\n\n      ledger.receivedBytes(block.length);\n    }\n  }\n  /**\n   * Clear up all accounting things after message was sent\n   *\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   */\n\n\n  messageSent(peerId, cid, block) {\n    const ledger = this._findOrCreate(peerId);\n\n    ledger.sentBytes(block.length);\n    ledger.wantlist.remove(cid);\n  }\n  /**\n   * @param {PeerId} peerId\n   * @returns {number}\n   */\n\n\n  numBytesSentTo(peerId) {\n    return this._findOrCreate(peerId).accounting.bytesSent;\n  }\n  /**\n   * @param {PeerId} peerId\n   * @returns {number}\n   */\n\n\n  numBytesReceivedFrom(peerId) {\n    return this._findOrCreate(peerId).accounting.bytesRecv;\n  }\n  /**\n   *\n   * @param {PeerId} _peerId\n   * @returns {void}\n   */\n\n\n  peerDisconnected(_peerId) {// if (this.ledgerMap.has(peerId.toB58String())) {\n    //   this.ledgerMap.delete(peerId.toB58String())\n    // }\n    //\n    // TODO: figure out how to remove all other references\n    // in the peer request queue\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @returns {Ledger}\n   */\n\n\n  _findOrCreate(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger = this.ledgerMap.get(peerIdStr);\n\n    if (ledger) {\n      return ledger;\n    }\n\n    const l = new Ledger(peerId);\n    this.ledgerMap.set(peerIdStr, l);\n\n    if (this._stats) {\n      this._stats.push(peerIdStr, 'peerCount', 1);\n    }\n\n    return l;\n  }\n\n  start() {\n    this._running = true;\n  }\n\n  stop() {\n    this._running = false;\n  }\n\n}\n\nmodule.exports = DecisionEngine;","map":{"version":3,"names":["CID","require","base58btc","Message","WantType","Wantlist","Ledger","RequestQueue","TaskMerger","logger","TARGET_MESSAGE_SIZE","MAX_SIZE_REPLACE_HAS_WITH_BLOCK","DecisionEngine","constructor","peerId","blockstore","network","stats","opts","_log","_stats","_opts","_processOpts","ledgerMap","Map","_running","_requestQueue","maxSizeReplaceHasWithBlock","targetMessageSize","_scheduleProcessTasks","setTimeout","_processTasks","tasks","pendingSize","popTasks","length","msg","setPendingBytes","blockCids","blockTasks","task","cid","parse","topic","data","haveBlock","isWantBlock","push","set","addHave","addDontHave","blocks","_getBlocks","taskData","blk","get","addBlock","sendDontHave","empty","tasksDone","sendMessage","cidStr","block","entries","messageSent","err","error","wantlistForPeer","peerIdStr","toB58String","ledger","wantlist","sortedEntries","ledgerForPeer","peer","partner","value","debtRatio","sent","accounting","bytesSent","recv","bytesRecv","exchanged","exchangeCount","peers","Array","from","values","map","l","receivedBlocks","want","wantlistContains","blockSize","_sendAsBlock","wantType","entrySize","blockPresenceSize","pushTasks","toString","priority","size","messageReceived","_findOrCreate","full","_updateBlockAccounting","cancels","wants","forEach","entry","cancel","cancelWant","_cancelWants","_addWants","cids","c","remove","blockSizes","_getBlockSizes","w","id","Block","k","v","res","Promise","all","e","code","blocksMap","receivedBytes","sentBytes","numBytesSentTo","numBytesReceivedFrom","peerDisconnected","_peerId","start","stop","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-bitswap/src/decision-engine/index.js"],"sourcesContent":["'use strict'\n\n/**\n * @typedef {import('../types/message/entry')} BitswapMessageEntry\n * @typedef {import('peer-id')} PeerId\n */\n\nconst { CID } = require('multiformats')\nconst { base58btc } = require('multiformats/bases/base58')\n\nconst Message = require('../types/message')\nconst WantType = Message.WantType\nconst Wantlist = require('../types/wantlist')\nconst Ledger = require('./ledger')\nconst RequestQueue = require('./req-queue')\nconst TaskMerger = require('./task-merger')\nconst { logger } = require('../utils')\n\n// The ideal size of the batched payload. We try to pop this much data off the\n// request queue, but\n// - if there isn't any more data in the queue we send whatever we have\n// - if there are several small items in the queue (eg HAVE response) followed\n//   by one big item (eg a block) that would exceed this target size, we\n//   include the big item in the message\nconst TARGET_MESSAGE_SIZE = 16 * 1024\n\n// If the client sends a want-have, and the engine has the corresponding block,\n// we check the size of the block and if it's small enough we send the block\n// itself, rather than sending a HAVE.\n// This constant defines the maximum size up to which we replace a HAVE with\n// a block.\nconst MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024\n\nclass DecisionEngine {\n  /**\n   * @param {PeerId} peerId\n   * @param {import('interface-blockstore').Blockstore} blockstore\n   * @param {import('../network')} network\n   * @param {import('../stats')} stats\n   * @param {Object} [opts]\n   * @param {number} [opts.targetMessageSize]\n   * @param {number} [opts.maxSizeReplaceHasWithBlock]\n   */\n  constructor (peerId, blockstore, network, stats, opts = {}) {\n    this._log = logger(peerId, 'engine')\n    this.blockstore = blockstore\n    this.network = network\n    this._stats = stats\n    this._opts = this._processOpts(opts)\n\n    // A list of of ledgers by their partner id\n    /** @type {Map<string, Ledger>} */\n    this.ledgerMap = new Map()\n    this._running = false\n\n    // Queue of want-have / want-block per peer\n    this._requestQueue = new RequestQueue(TaskMerger)\n  }\n\n  /**\n   * @template {Object} Opts\n   * @param {Opts} opts\n   * @returns {Opts & {maxSizeReplaceHasWithBlock:number, targetMessageSize:number}}\n   * @private\n   */\n  _processOpts (opts) {\n    return {\n      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n      targetMessageSize: TARGET_MESSAGE_SIZE,\n      ...opts\n    }\n  }\n\n  _scheduleProcessTasks () {\n    setTimeout(() => {\n      this._processTasks()\n    })\n  }\n\n  /**\n   * Pull tasks off the request queue and send a message to the corresponding\n   * peer\n   */\n  async _processTasks () {\n    if (!this._running) {\n      return\n    }\n\n    const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize)\n\n    if (tasks.length === 0) {\n      return\n    }\n\n    // Create a new message\n    const msg = new Message(false)\n\n    // Amount of data in the request queue still waiting to be popped\n    msg.setPendingBytes(pendingSize)\n\n    // Split out want-blocks, want-haves and DONT_HAVEs\n    const blockCids = []\n    const blockTasks = new Map()\n    for (const task of tasks) {\n      const cid = CID.parse(task.topic)\n      if (task.data.haveBlock) {\n        if (task.data.isWantBlock) {\n          blockCids.push(cid)\n          blockTasks.set(task.topic, task.data)\n        } else {\n          // Add HAVES to the message\n          msg.addHave(cid)\n        }\n      } else {\n        // Add DONT_HAVEs to the message\n        msg.addDontHave(cid)\n      }\n    }\n\n    const blocks = await this._getBlocks(blockCids)\n    for (const [topic, taskData] of blockTasks) {\n      const cid = CID.parse(topic)\n      const blk = blocks.get(topic)\n      // If the block was found (it has not been removed)\n      if (blk) {\n        // Add the block to the message\n        msg.addBlock(cid, blk)\n      } else {\n        // The block was not found. If the client requested DONT_HAVE,\n        // add DONT_HAVE to the message.\n        if (taskData.sendDontHave) {\n          msg.addDontHave(cid)\n        }\n      }\n    }\n\n    // If there's nothing in the message, bail out\n    if (msg.empty) {\n      peerId && this._requestQueue.tasksDone(peerId, tasks)\n\n      // Trigger the next round of task processing\n      this._scheduleProcessTasks()\n\n      return\n    }\n\n    try {\n      // Send the message\n      peerId && await this.network.sendMessage(peerId, msg)\n\n      // Peform sent message accounting\n      for (const [cidStr, block] of blocks.entries()) {\n        peerId && this.messageSent(peerId, CID.parse(cidStr), block)\n      }\n    } catch (err) {\n      this._log.error(err)\n    }\n\n    // Free the tasks up from the request queue\n    peerId && this._requestQueue.tasksDone(peerId, tasks)\n\n    // Trigger the next round of task processing\n    this._scheduleProcessTasks()\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @returns {Map<string, import('../types/wantlist/entry')>}\n   */\n  wantlistForPeer (peerId) {\n    const peerIdStr = peerId.toB58String()\n    const ledger = this.ledgerMap.get(peerIdStr)\n    return ledger ? ledger.wantlist.sortedEntries() : new Map()\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  ledgerForPeer (peerId) {\n    const peerIdStr = peerId.toB58String()\n\n    const ledger = this.ledgerMap.get(peerIdStr)\n\n    if (!ledger) {\n      return null\n    }\n\n    return {\n      peer: ledger.partner,\n      value: ledger.debtRatio(),\n      sent: ledger.accounting.bytesSent,\n      recv: ledger.accounting.bytesRecv,\n      exchanged: ledger.exchangeCount\n    }\n  }\n\n  /**\n   * @returns {PeerId[]}\n   */\n  peers () {\n    return Array.from(this.ledgerMap.values()).map((l) => l.partner)\n  }\n\n  /**\n   * Receive blocks either from an incoming message from the network, or from\n   * blocks being added by the client on the localhost (eg IPFS add)\n   *\n   * @param {{ cid: CID, data: Uint8Array }[]} blocks\n   */\n  receivedBlocks (blocks) {\n    if (!blocks.length) {\n      return\n    }\n\n    // For each connected peer, check if it wants the block we received\n    for (const ledger of this.ledgerMap.values()) {\n      for (const block of blocks) {\n        // Filter out blocks that we don't want\n        const want = ledger.wantlistContains(block.cid)\n\n        if (!want) {\n          continue\n        }\n\n        // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n        const blockSize = block.data.length\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize)\n\n        let entrySize = blockSize\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid)\n        }\n\n        this._requestQueue.pushTasks(ledger.partner, [{\n          topic: want.cid.toString(base58btc),\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            blockSize,\n            isWantBlock,\n            haveBlock: true,\n            sendDontHave: false\n          }\n        }])\n      }\n    }\n\n    this._scheduleProcessTasks()\n  }\n\n  /**\n   * Handle incoming messages\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   * @returns {Promise<void>}\n   */\n  async messageReceived (peerId, msg) {\n    const ledger = this._findOrCreate(peerId)\n\n    if (msg.empty) {\n      return\n    }\n\n    // If the message has a full wantlist, clear the current wantlist\n    if (msg.full) {\n      ledger.wantlist = new Wantlist()\n    }\n\n    // Record the amount of block data received\n    this._updateBlockAccounting(msg.blocks, ledger)\n\n    if (msg.wantlist.size === 0) {\n      this._scheduleProcessTasks()\n      return\n    }\n\n    // Clear cancelled wants and add new wants to the ledger\n    /** @type {CID[]} */\n    const cancels = []\n    /** @type {BitswapMessageEntry[]} */\n    const wants = []\n    msg.wantlist.forEach((entry) => {\n      if (entry.cancel) {\n        ledger.cancelWant(entry.cid)\n        cancels.push(entry.cid)\n      } else {\n        ledger.wants(entry.cid, entry.priority, entry.wantType)\n        wants.push(entry)\n      }\n    })\n\n    this._cancelWants(peerId, cancels)\n    await this._addWants(peerId, wants)\n\n    this._scheduleProcessTasks()\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {CID[]} cids\n   * @returns {void}\n   */\n  _cancelWants (peerId, cids) {\n    for (const c of cids) {\n      this._requestQueue.remove(c.toString(base58btc), peerId)\n    }\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {BitswapMessageEntry[]} wants\n   * @returns {Promise<void>}\n   */\n  async _addWants (peerId, wants) {\n    // Get the size of each wanted block\n    const blockSizes = await this._getBlockSizes(wants.map(w => w.cid))\n\n    const tasks = []\n    for (const want of wants) {\n      const id = want.cid.toString(base58btc)\n      const blockSize = blockSizes.get(id)\n\n      // If the block was not found\n      if (blockSize == null) {\n        // Only add the task to the queue if the requester wants a DONT_HAVE\n        if (want.sendDontHave) {\n          tasks.push({\n            topic: id,\n            priority: want.priority,\n            size: Message.blockPresenceSize(want.cid),\n            data: {\n              isWantBlock: want.wantType === WantType.Block,\n              blockSize: 0,\n              haveBlock: false,\n              sendDontHave: want.sendDontHave\n            }\n          })\n        }\n      } else {\n        // The block was found, add it to the queue\n\n        // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize)\n\n        // entrySize is the amount of space the entry takes up in the\n        // message we send to the recipient. If we're sending a block, the\n        // entrySize is the size of the block. Otherwise it's the size of\n        // a block presence entry.\n        let entrySize = blockSize\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid)\n        }\n\n        tasks.push({\n          topic: id,\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            isWantBlock,\n            blockSize,\n            haveBlock: true,\n            sendDontHave: want.sendDontHave\n          }\n        })\n      }\n\n      this._requestQueue.pushTasks(peerId, tasks)\n    }\n  }\n\n  /**\n   * @private\n   * @param {import('../types/message/message').Message.Wantlist.WantType} wantType\n   * @param {number} blockSize\n   */\n  _sendAsBlock (wantType, blockSize) {\n    return wantType === WantType.Block ||\n      blockSize <= this._opts.maxSizeReplaceHasWithBlock\n  }\n\n  /**\n   * @private\n   * @param {CID[]} cids\n   * @returns {Promise<Map<string, number>>}\n   */\n  async _getBlockSizes (cids) {\n    const blocks = await this._getBlocks(cids)\n    return new Map([...blocks].map(([k, v]) => [k, v.length]))\n  }\n\n  /**\n   * @private\n   * @param {CID[]} cids\n   * @returns {Promise<Map<string, Uint8Array>>}\n   */\n  async _getBlocks (cids) {\n    const res = new Map()\n    await Promise.all(cids.map(async (cid) => {\n      try {\n        const block = await this.blockstore.get(cid)\n        res.set(cid.toString(base58btc), block)\n      } catch (e) {\n        if (e.code !== 'ERR_NOT_FOUND') {\n          this._log.error('failed to query blockstore for %s: %s', cid, e)\n        }\n      }\n    }))\n    return res\n  }\n\n  /**\n   * @private\n   * @param {Map<string, Uint8Array>} blocksMap\n   * @param {Ledger} ledger\n   */\n  _updateBlockAccounting (blocksMap, ledger) {\n    for (const block of blocksMap.values()) {\n      this._log('got block (%s bytes)', block.length)\n      ledger.receivedBytes(block.length)\n    }\n  }\n\n  /**\n   * Clear up all accounting things after message was sent\n   *\n   * @param {PeerId} peerId\n   * @param {CID} cid\n   * @param {Uint8Array} block\n   */\n  messageSent (peerId, cid, block) {\n    const ledger = this._findOrCreate(peerId)\n    ledger.sentBytes(block.length)\n    ledger.wantlist.remove(cid)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @returns {number}\n   */\n  numBytesSentTo (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesSent\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @returns {number}\n   */\n\n  numBytesReceivedFrom (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesRecv\n  }\n\n  /**\n   *\n   * @param {PeerId} _peerId\n   * @returns {void}\n   */\n  peerDisconnected (_peerId) {\n    // if (this.ledgerMap.has(peerId.toB58String())) {\n    //   this.ledgerMap.delete(peerId.toB58String())\n    // }\n    //\n    // TODO: figure out how to remove all other references\n    // in the peer request queue\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @returns {Ledger}\n   */\n  _findOrCreate (peerId) {\n    const peerIdStr = peerId.toB58String()\n    const ledger = this.ledgerMap.get(peerIdStr)\n    if (ledger) {\n      return ledger\n    }\n\n    const l = new Ledger(peerId)\n\n    this.ledgerMap.set(peerIdStr, l)\n    if (this._stats) {\n      this._stats.push(peerIdStr, 'peerCount', 1)\n    }\n\n    return l\n  }\n\n  start () {\n    this._running = true\n  }\n\n  stop () {\n    this._running = false\n  }\n}\n\nmodule.exports = DecisionEngine\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}