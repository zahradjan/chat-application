{"ast":null,"code":"'use strict';\n\nconst drain = require('it-drain');\n\nconst pushable = require('it-pushable');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst raw = require('multiformats/codecs/raw');\n\nconst Digest = require('multiformats/hashes/digest');\n\nconst {\n  base32,\n  base32pad\n} = require('multiformats/bases/base32');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst errcode = require('err-code');\n\nconst {\n  BlockstoreAdapter\n} = require('interface-blockstore');\n/**\n * Transform a cid to the appropriate datastore key.\n *\n * @param {CID} cid\n * @returns {Key}\n */\n\n\nfunction cidToKey(cid) {\n  const c = CID.asCID(cid);\n\n  if (!c) {\n    throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n  }\n\n  return new Key('/' + base32.encode(c.multihash.bytes).slice(1).toUpperCase(), false);\n}\n/**\n * Transform a datastore Key instance to a CID\n * As Key is a multihash of the CID, it is reconstructed using IPLD's RAW codec.\n * Hence it is highly probable that stored CID will differ from a CID retrieved from blockstore.\n *\n * @param {Key} key\n * @returns {CID}\n */\n\n\nfunction keyToCid(key) {\n  // Block key is of the form <base32 encoded string>\n  return CID.createV1(raw.code, Digest.decode(base32.decode('b' + key.toString().slice(1).toLowerCase())));\n}\n/**\n * Tries to decode a prefix as the first part of a CID and then\n * strip off the version and codec bytes to just leave part of\n * the multihash.\n *\n * Only really works if the prefix length aligns with the byte\n * boundaries of the encoding.\n *\n * @param {string} prefix\n * @returns {string}\n */\n\n\nfunction convertPrefix(prefix) {\n  const firstChar = prefix.substring(0, 1);\n\n  if (firstChar === '/') {\n    return convertPrefix(prefix.substring(1));\n  }\n  /** @type {(input: string) => Uint8Array } */\n\n\n  let decoder;\n\n  if (firstChar.toLowerCase() === 'b') {\n    // v1 cid prefix, remove version and codec bytes\n    decoder = input => base32.decode(input.toLowerCase()).subarray(2);\n  } else if (firstChar.toLowerCase() === 'c') {\n    // v1 cid prefix, remove version and codec bytes\n    decoder = input => base32pad.decode(input.toLowerCase()).subarray(2);\n  } else if (firstChar === 'z') {\n    // v1 cid\n    decoder = input => base58btc.decode(input).subarray(2);\n  } else if (firstChar === 'Q') {\n    // v0 cid prefix\n    decoder = input => base58btc.decode('z' + input);\n  } else {\n    decoder = input => base32.decode('b' + input.toLowerCase()).subarray(2);\n  }\n\n  let bytes; // find the longest prefix that we can safely decode\n\n  for (let i = 1; i < prefix.length; i++) {\n    try {\n      bytes = decoder(prefix.substring(0, i));\n    } catch (err) {\n      if (err.message !== 'Unexpected end of data') {\n        throw err;\n      }\n    }\n  }\n\n  let str = '/C';\n\n  if (bytes) {\n    // slice one character from the end of the string to ensure we don't end up\n    // with a padded value which could have a non-matching string at the end\n    str = `/${base32.encode(bytes).slice(1, -1).toUpperCase() || 'C'}`;\n  }\n\n  return str;\n}\n/**\n * @param {import('interface-blockstore').Query} query\n * @returns {import('interface-datastore').Query}\n */\n\n\nfunction convertQuery(query) {\n  return { ...query,\n    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,\n    filters: query.filters ? query.filters.map(filter => pair => {\n      return filter({\n        key: keyToCid(pair.key),\n        value: pair.value\n      });\n    }) : undefined,\n    orders: query.orders ? query.orders.map(order => (a, b) => {\n      return order({\n        key: keyToCid(a.key),\n        value: a.value\n      }, {\n        key: keyToCid(b.key),\n        value: b.value\n      });\n    }) : undefined\n  };\n}\n/**\n * @param {import('interface-blockstore').KeyQuery} query\n * @returns {import('interface-datastore').KeyQuery}\n */\n\n\nfunction convertKeyQuery(query) {\n  return { ...query,\n    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,\n    filters: query.filters ? query.filters.map(filter => key => {\n      return filter(keyToCid(key));\n    }) : undefined,\n    orders: query.orders ? query.orders.map(order => (a, b) => {\n      return order(keyToCid(a), keyToCid(b));\n    }) : undefined\n  };\n}\n/**\n * @typedef {import('interface-blockstore').Query} Query\n * @typedef {import('interface-blockstore').KeyQuery} KeyQuery\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @implements {Blockstore}\n */\n\n\nclass BlockstoreDatastoreAdapter extends BlockstoreAdapter {\n  /**\n   * @param {Datastore} datastore\n   */\n  constructor(datastore) {\n    super();\n    this.child = datastore;\n  }\n\n  open() {\n    return this.child.open();\n  }\n\n  close() {\n    return this.child.close();\n  }\n  /**\n   * @param {Query} query\n   * @param {Options} [options]\n   */\n\n\n  async *query(query, options) {\n    for await (const {\n      key,\n      value\n    } of this.child.query(convertQuery(query), options)) {\n      yield {\n        key: keyToCid(key),\n        value\n      };\n    }\n  }\n  /**\n   * @param {KeyQuery} query\n   * @param {Options} [options]\n   */\n\n\n  async *queryKeys(query, options) {\n    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {\n      yield keyToCid(key);\n    }\n  }\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   * @returns\n   */\n\n\n  async get(cid, options) {\n    return this.child.get(cidToKey(cid), options);\n  }\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n\n\n  async *getMany(cids, options) {\n    for await (const cid of cids) {\n      yield this.get(cid, options);\n    }\n  }\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n\n\n  async put(cid, value, options) {\n    await this.child.put(cidToKey(cid), value, options);\n  }\n  /**\n   * @param {AsyncIterable<Pair> | Iterable<Pair>} blocks\n   * @param {Options} [options]\n   */\n\n\n  async *putMany(blocks, options) {\n    // eslint-disable-line require-await\n    // we cannot simply chain to `store.putMany` because we convert a CID into\n    // a key based on the multihash only, so we lose the version & codec and\n    // cannot give the user back the CID they used to create the block, so yield\n    // to `store.putMany` but return the actual block the user passed in.\n    //\n    // nb. we want to use `store.putMany` here so bitswap can control batching\n    // up block HAVEs to send to the network - if we use multiple `store.put`s\n    // it will not be able to guess we are about to `store.put` more blocks\n    const output = pushable(); // process.nextTick runs on the microtask queue, setImmediate runs on the next\n    // event loop iteration so is slower. Use process.nextTick if it is available.\n\n    const runner = process && process.nextTick ? process.nextTick : setImmediate;\n    runner(async () => {\n      try {\n        const store = this.child;\n        await drain(this.child.putMany(async function* () {\n          for await (const block of blocks) {\n            const key = cidToKey(block.key);\n            const exists = await store.has(key, options);\n\n            if (!exists) {\n              yield {\n                key,\n                value: block.value\n              };\n            } // there is an assumption here that after the yield has completed\n            // the underlying datastore has finished writing the block\n\n\n            output.push(block);\n          }\n        }()));\n        output.end();\n      } catch (err) {\n        output.end(err);\n      }\n    });\n    yield* output;\n  }\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n\n\n  has(cid, options) {\n    return this.child.has(cidToKey(cid), options);\n  }\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n\n\n  delete(cid, options) {\n    return this.child.delete(cidToKey(cid), options);\n  }\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n\n\n  deleteMany(cids, options) {\n    const out = pushable();\n    drain(this.child.deleteMany(async function* () {\n      for await (const cid of cids) {\n        yield cidToKey(cid);\n        out.push(cid);\n      }\n\n      out.end();\n    }(), options)).catch(err => {\n      out.end(err);\n    });\n    return out;\n  }\n\n}\n\nmodule.exports = BlockstoreDatastoreAdapter;","map":{"version":3,"names":["drain","require","pushable","Key","CID","raw","Digest","base32","base32pad","base58btc","errcode","BlockstoreAdapter","cidToKey","cid","c","asCID","Error","encode","multihash","bytes","slice","toUpperCase","keyToCid","key","createV1","code","decode","toString","toLowerCase","convertPrefix","prefix","firstChar","substring","decoder","input","subarray","i","length","err","message","str","convertQuery","query","undefined","filters","map","filter","pair","value","orders","order","a","b","convertKeyQuery","BlockstoreDatastoreAdapter","constructor","datastore","child","open","close","options","queryKeys","get","getMany","cids","put","putMany","blocks","output","runner","process","nextTick","setImmediate","store","block","exists","has","push","end","delete","deleteMany","out","catch","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/blockstore-datastore-adapter/src/index.js"],"sourcesContent":["'use strict'\n\nconst drain = require('it-drain')\nconst pushable = require('it-pushable')\nconst { Key } = require('interface-datastore')\nconst { CID } = require('multiformats/cid')\nconst raw = require('multiformats/codecs/raw')\nconst Digest = require('multiformats/hashes/digest')\nconst { base32, base32pad } = require('multiformats/bases/base32')\nconst { base58btc } = require('multiformats/bases/base58')\nconst errcode = require('err-code')\nconst { BlockstoreAdapter } = require('interface-blockstore')\n\n/**\n * Transform a cid to the appropriate datastore key.\n *\n * @param {CID} cid\n * @returns {Key}\n */\nfunction cidToKey (cid) {\n  const c = CID.asCID(cid)\n\n  if (!c) {\n    throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID')\n  }\n\n  return new Key('/' + base32.encode(c.multihash.bytes).slice(1).toUpperCase(), false)\n}\n\n/**\n * Transform a datastore Key instance to a CID\n * As Key is a multihash of the CID, it is reconstructed using IPLD's RAW codec.\n * Hence it is highly probable that stored CID will differ from a CID retrieved from blockstore.\n *\n * @param {Key} key\n * @returns {CID}\n */\nfunction keyToCid (key) {\n  // Block key is of the form <base32 encoded string>\n  return CID.createV1(raw.code, Digest.decode(base32.decode('b' + key.toString().slice(1).toLowerCase())))\n}\n\n/**\n * Tries to decode a prefix as the first part of a CID and then\n * strip off the version and codec bytes to just leave part of\n * the multihash.\n *\n * Only really works if the prefix length aligns with the byte\n * boundaries of the encoding.\n *\n * @param {string} prefix\n * @returns {string}\n */\nfunction convertPrefix (prefix) {\n  const firstChar = prefix.substring(0, 1)\n\n  if (firstChar === '/') {\n    return convertPrefix(prefix.substring(1))\n  }\n\n  /** @type {(input: string) => Uint8Array } */\n  let decoder\n\n  if (firstChar.toLowerCase() === 'b') {\n    // v1 cid prefix, remove version and codec bytes\n    decoder = (input) => base32.decode(input.toLowerCase()).subarray(2)\n  } else if (firstChar.toLowerCase() === 'c') {\n    // v1 cid prefix, remove version and codec bytes\n    decoder = (input) => base32pad.decode(input.toLowerCase()).subarray(2)\n  } else if (firstChar === 'z') {\n    // v1 cid\n    decoder = (input) => base58btc.decode(input).subarray(2)\n  } else if (firstChar === 'Q') {\n    // v0 cid prefix\n    decoder = (input) => base58btc.decode('z' + input)\n  } else {\n    decoder = (input) => base32.decode('b' + input.toLowerCase()).subarray(2)\n  }\n\n  let bytes\n\n  // find the longest prefix that we can safely decode\n  for (let i = 1; i < prefix.length; i++) {\n    try {\n      bytes = decoder(prefix.substring(0, i))\n    } catch (err) {\n      if (err.message !== 'Unexpected end of data') {\n        throw err\n      }\n    }\n  }\n\n  let str = '/C'\n\n  if (bytes) {\n    // slice one character from the end of the string to ensure we don't end up\n    // with a padded value which could have a non-matching string at the end\n    str = `/${base32.encode(bytes).slice(1, -1).toUpperCase() || 'C'}`\n  }\n\n  return str\n}\n\n/**\n * @param {import('interface-blockstore').Query} query\n * @returns {import('interface-datastore').Query}\n */\nfunction convertQuery (query) {\n  return {\n    ...query,\n    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,\n    filters: query.filters\n      ? query.filters.map(\n        filter => (pair) => {\n          return filter({ key: keyToCid(pair.key), value: pair.value })\n        }\n      )\n      : undefined,\n    orders: query.orders\n      ? query.orders.map(\n        order => (a, b) => {\n          return order({ key: keyToCid(a.key), value: a.value }, { key: keyToCid(b.key), value: b.value })\n        }\n      )\n      : undefined\n  }\n}\n\n/**\n * @param {import('interface-blockstore').KeyQuery} query\n * @returns {import('interface-datastore').KeyQuery}\n */\nfunction convertKeyQuery (query) {\n  return {\n    ...query,\n    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,\n    filters: query.filters\n      ? query.filters.map(\n        filter => (key) => {\n          return filter(keyToCid(key))\n        }\n      )\n      : undefined,\n    orders: query.orders\n      ? query.orders.map(\n        order => (a, b) => {\n          return order(keyToCid(a), keyToCid(b))\n        }\n      )\n      : undefined\n  }\n}\n\n/**\n * @typedef {import('interface-blockstore').Query} Query\n * @typedef {import('interface-blockstore').KeyQuery} KeyQuery\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @implements {Blockstore}\n */\nclass BlockstoreDatastoreAdapter extends BlockstoreAdapter {\n  /**\n   * @param {Datastore} datastore\n   */\n  constructor (datastore) {\n    super()\n\n    this.child = datastore\n  }\n\n  open () {\n    return this.child.open()\n  }\n\n  close () {\n    return this.child.close()\n  }\n\n  /**\n   * @param {Query} query\n   * @param {Options} [options]\n   */\n  async * query (query, options) {\n    for await (const { key, value } of this.child.query(convertQuery(query), options)) {\n      yield { key: keyToCid(key), value }\n    }\n  }\n\n  /**\n   * @param {KeyQuery} query\n   * @param {Options} [options]\n   */\n  async * queryKeys (query, options) {\n    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {\n      yield keyToCid(key)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   * @returns\n   */\n  async get (cid, options) {\n    return this.child.get(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n  async * getMany (cids, options) {\n    for await (const cid of cids) {\n      yield this.get(cid, options)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n  async put (cid, value, options) {\n    await this.child.put(cidToKey(cid), value, options)\n  }\n\n  /**\n   * @param {AsyncIterable<Pair> | Iterable<Pair>} blocks\n   * @param {Options} [options]\n   */\n  async * putMany (blocks, options) { // eslint-disable-line require-await\n    // we cannot simply chain to `store.putMany` because we convert a CID into\n    // a key based on the multihash only, so we lose the version & codec and\n    // cannot give the user back the CID they used to create the block, so yield\n    // to `store.putMany` but return the actual block the user passed in.\n    //\n    // nb. we want to use `store.putMany` here so bitswap can control batching\n    // up block HAVEs to send to the network - if we use multiple `store.put`s\n    // it will not be able to guess we are about to `store.put` more blocks\n    const output = pushable()\n\n    // process.nextTick runs on the microtask queue, setImmediate runs on the next\n    // event loop iteration so is slower. Use process.nextTick if it is available.\n    const runner = process && process.nextTick ? process.nextTick : setImmediate\n\n    runner(async () => {\n      try {\n        const store = this.child\n\n        await drain(this.child.putMany(async function * () {\n          for await (const block of blocks) {\n            const key = cidToKey(block.key)\n            const exists = await store.has(key, options)\n\n            if (!exists) {\n              yield { key, value: block.value }\n            }\n\n            // there is an assumption here that after the yield has completed\n            // the underlying datastore has finished writing the block\n            output.push(block)\n          }\n        }()))\n\n        output.end()\n      } catch (err) {\n        output.end(err)\n      }\n    })\n\n    yield * output\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n  has (cid, options) {\n    return this.child.has(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n  delete (cid, options) {\n    return this.child.delete(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n  deleteMany (cids, options) {\n    const out = pushable()\n\n    drain(this.child.deleteMany((async function * () {\n      for await (const cid of cids) {\n        yield cidToKey(cid)\n\n        out.push(cid)\n      }\n\n      out.end()\n    }()), options)).catch(err => {\n      out.end(err)\n    })\n\n    return out\n  }\n}\n\nmodule.exports = BlockstoreDatastoreAdapter\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}