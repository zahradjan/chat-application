{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _asyncGeneratorDelegate = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar drain = require('it-drain');\n\nvar pushable = require('it-pushable');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar _require2 = require('multiformats/cid'),\n    CID = _require2.CID;\n\nvar raw = require('multiformats/codecs/raw');\n\nvar Digest = require('multiformats/hashes/digest');\n\nvar _require3 = require('multiformats/bases/base32'),\n    base32 = _require3.base32,\n    base32pad = _require3.base32pad;\n\nvar _require4 = require('multiformats/bases/base58'),\n    base58btc = _require4.base58btc;\n\nvar errcode = require('err-code');\n\nvar _require5 = require('interface-blockstore'),\n    BlockstoreAdapter = _require5.BlockstoreAdapter;\n/**\n * Transform a cid to the appropriate datastore key.\n *\n * @param {CID} cid\n * @returns {Key}\n */\n\n\nfunction cidToKey(cid) {\n  var c = CID.asCID(cid);\n\n  if (!c) {\n    throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n  }\n\n  return new Key('/' + base32.encode(c.multihash.bytes).slice(1).toUpperCase(), false);\n}\n/**\n * Transform a datastore Key instance to a CID\n * As Key is a multihash of the CID, it is reconstructed using IPLD's RAW codec.\n * Hence it is highly probable that stored CID will differ from a CID retrieved from blockstore.\n *\n * @param {Key} key\n * @returns {CID}\n */\n\n\nfunction keyToCid(key) {\n  // Block key is of the form <base32 encoded string>\n  return CID.createV1(raw.code, Digest.decode(base32.decode('b' + key.toString().slice(1).toLowerCase())));\n}\n/**\n * Tries to decode a prefix as the first part of a CID and then\n * strip off the version and codec bytes to just leave part of\n * the multihash.\n *\n * Only really works if the prefix length aligns with the byte\n * boundaries of the encoding.\n *\n * @param {string} prefix\n * @returns {string}\n */\n\n\nfunction convertPrefix(prefix) {\n  var firstChar = prefix.substring(0, 1);\n\n  if (firstChar === '/') {\n    return convertPrefix(prefix.substring(1));\n  }\n  /** @type {(input: string) => Uint8Array } */\n\n\n  var decoder;\n\n  if (firstChar.toLowerCase() === 'b') {\n    // v1 cid prefix, remove version and codec bytes\n    decoder = function decoder(input) {\n      return base32.decode(input.toLowerCase()).subarray(2);\n    };\n  } else if (firstChar.toLowerCase() === 'c') {\n    // v1 cid prefix, remove version and codec bytes\n    decoder = function decoder(input) {\n      return base32pad.decode(input.toLowerCase()).subarray(2);\n    };\n  } else if (firstChar === 'z') {\n    // v1 cid\n    decoder = function decoder(input) {\n      return base58btc.decode(input).subarray(2);\n    };\n  } else if (firstChar === 'Q') {\n    // v0 cid prefix\n    decoder = function decoder(input) {\n      return base58btc.decode('z' + input);\n    };\n  } else {\n    decoder = function decoder(input) {\n      return base32.decode('b' + input.toLowerCase()).subarray(2);\n    };\n  }\n\n  var bytes; // find the longest prefix that we can safely decode\n\n  for (var i = 1; i < prefix.length; i++) {\n    try {\n      bytes = decoder(prefix.substring(0, i));\n    } catch (err) {\n      if (err.message !== 'Unexpected end of data') {\n        throw err;\n      }\n    }\n  }\n\n  var str = '/C';\n\n  if (bytes) {\n    // slice one character from the end of the string to ensure we don't end up\n    // with a padded value which could have a non-matching string at the end\n    str = \"/\".concat(base32.encode(bytes).slice(1, -1).toUpperCase() || 'C');\n  }\n\n  return str;\n}\n/**\n * @param {import('interface-blockstore').Query} query\n * @returns {import('interface-datastore').Query}\n */\n\n\nfunction convertQuery(query) {\n  return _objectSpread(_objectSpread({}, query), {}, {\n    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,\n    filters: query.filters ? query.filters.map(function (filter) {\n      return function (pair) {\n        return filter({\n          key: keyToCid(pair.key),\n          value: pair.value\n        });\n      };\n    }) : undefined,\n    orders: query.orders ? query.orders.map(function (order) {\n      return function (a, b) {\n        return order({\n          key: keyToCid(a.key),\n          value: a.value\n        }, {\n          key: keyToCid(b.key),\n          value: b.value\n        });\n      };\n    }) : undefined\n  });\n}\n/**\n * @param {import('interface-blockstore').KeyQuery} query\n * @returns {import('interface-datastore').KeyQuery}\n */\n\n\nfunction convertKeyQuery(query) {\n  return _objectSpread(_objectSpread({}, query), {}, {\n    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,\n    filters: query.filters ? query.filters.map(function (filter) {\n      return function (key) {\n        return filter(keyToCid(key));\n      };\n    }) : undefined,\n    orders: query.orders ? query.orders.map(function (order) {\n      return function (a, b) {\n        return order(keyToCid(a), keyToCid(b));\n      };\n    }) : undefined\n  });\n}\n/**\n * @typedef {import('interface-blockstore').Query} Query\n * @typedef {import('interface-blockstore').KeyQuery} KeyQuery\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @implements {Blockstore}\n */\n\n\nvar BlockstoreDatastoreAdapter = /*#__PURE__*/function (_BlockstoreAdapter) {\n  _inherits(BlockstoreDatastoreAdapter, _BlockstoreAdapter);\n\n  var _super = _createSuper(BlockstoreDatastoreAdapter);\n\n  /**\n   * @param {Datastore} datastore\n   */\n  function BlockstoreDatastoreAdapter(datastore) {\n    var _this5;\n\n    _classCallCheck(this, BlockstoreDatastoreAdapter);\n\n    _this5 = _super.call(this);\n    _this5.child = datastore;\n    return _this5;\n  }\n\n  _createClass(BlockstoreDatastoreAdapter, [{\n    key: \"open\",\n    value: function open() {\n      return this.child.open();\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      return this.child.close();\n    }\n    /**\n     * @param {Query} query\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"query\",\n    value: function query(_query, options) {\n      var _this = this;\n\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, key, value;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _iteratorAbruptCompletion = false;\n                _didIteratorError = false;\n                _context.prev = 2;\n                _iterator = _asyncIterator(_this.child.query(convertQuery(_query), options));\n\n              case 4:\n                _context.next = 6;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 6:\n                if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _step$value = _step.value, key = _step$value.key, value = _step$value.value;\n                _context.next = 10;\n                return {\n                  key: keyToCid(key),\n                  value: value\n                };\n\n              case 10:\n                _iteratorAbruptCompletion = false;\n                _context.next = 4;\n                break;\n\n              case 13:\n                _context.next = 19;\n                break;\n\n              case 15:\n                _context.prev = 15;\n                _context.t0 = _context[\"catch\"](2);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 19:\n                _context.prev = 19;\n                _context.prev = 20;\n\n                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                _context.next = 24;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 24:\n                _context.prev = 24;\n\n                if (!_didIteratorError) {\n                  _context.next = 27;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 27:\n                return _context.finish(24);\n\n              case 28:\n                return _context.finish(19);\n\n              case 29:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 15, 19, 29], [20,, 24, 28]]);\n      }))();\n    }\n    /**\n     * @param {KeyQuery} query\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"queryKeys\",\n    value: function queryKeys(query, options) {\n      var _this2 = this;\n\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, key;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _iteratorAbruptCompletion2 = false;\n                _didIteratorError2 = false;\n                _context2.prev = 2;\n                _iterator2 = _asyncIterator(_this2.child.queryKeys(convertKeyQuery(query), options));\n\n              case 4:\n                _context2.next = 6;\n                return _awaitAsyncGenerator(_iterator2.next());\n\n              case 6:\n                if (!(_iteratorAbruptCompletion2 = !(_step2 = _context2.sent).done)) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                key = _step2.value;\n                _context2.next = 10;\n                return keyToCid(key);\n\n              case 10:\n                _iteratorAbruptCompletion2 = false;\n                _context2.next = 4;\n                break;\n\n              case 13:\n                _context2.next = 19;\n                break;\n\n              case 15:\n                _context2.prev = 15;\n                _context2.t0 = _context2[\"catch\"](2);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context2.t0;\n\n              case 19:\n                _context2.prev = 19;\n                _context2.prev = 20;\n\n                if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                  _context2.next = 24;\n                  break;\n                }\n\n                _context2.next = 24;\n                return _awaitAsyncGenerator(_iterator2.return());\n\n              case 24:\n                _context2.prev = 24;\n\n                if (!_didIteratorError2) {\n                  _context2.next = 27;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 27:\n                return _context2.finish(24);\n\n              case 28:\n                return _context2.finish(19);\n\n              case 29:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[2, 15, 19, 29], [20,, 24, 28]]);\n      }))();\n    }\n    /**\n     * @param {CID} cid\n     * @param {Options} [options]\n     * @returns\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(cid, options) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.child.get(cidToKey(cid), options));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function get(_x, _x2) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * @param {AsyncIterable<CID> | Iterable<CID>} cids\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function getMany(cids, options) {\n      var _this3 = this;\n\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _iteratorAbruptCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, cid;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _iteratorAbruptCompletion3 = false;\n                _didIteratorError3 = false;\n                _context4.prev = 2;\n                _iterator3 = _asyncIterator(cids);\n\n              case 4:\n                _context4.next = 6;\n                return _awaitAsyncGenerator(_iterator3.next());\n\n              case 6:\n                if (!(_iteratorAbruptCompletion3 = !(_step3 = _context4.sent).done)) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                cid = _step3.value;\n                _context4.next = 10;\n                return _this3.get(cid, options);\n\n              case 10:\n                _iteratorAbruptCompletion3 = false;\n                _context4.next = 4;\n                break;\n\n              case 13:\n                _context4.next = 19;\n                break;\n\n              case 15:\n                _context4.prev = 15;\n                _context4.t0 = _context4[\"catch\"](2);\n                _didIteratorError3 = true;\n                _iteratorError3 = _context4.t0;\n\n              case 19:\n                _context4.prev = 19;\n                _context4.prev = 20;\n\n                if (!(_iteratorAbruptCompletion3 && _iterator3.return != null)) {\n                  _context4.next = 24;\n                  break;\n                }\n\n                _context4.next = 24;\n                return _awaitAsyncGenerator(_iterator3.return());\n\n              case 24:\n                _context4.prev = 24;\n\n                if (!_didIteratorError3) {\n                  _context4.next = 27;\n                  break;\n                }\n\n                throw _iteratorError3;\n\n              case 27:\n                return _context4.finish(24);\n\n              case 28:\n                return _context4.finish(19);\n\n              case 29:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, null, [[2, 15, 19, 29], [20,, 24, 28]]);\n      }))();\n    }\n    /**\n     * @param {CID} cid\n     * @param {Uint8Array} value\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(cid, value, options) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.child.put(cidToKey(cid), value, options);\n\n              case 2:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function put(_x3, _x4, _x5) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n    /**\n     * @param {AsyncIterable<Pair> | Iterable<Pair>} blocks\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"putMany\",\n    value: function putMany(blocks, options) {\n      var _this4 = this;\n\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var output, runner;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                // eslint-disable-line require-await\n                // we cannot simply chain to `store.putMany` because we convert a CID into\n                // a key based on the multihash only, so we lose the version & codec and\n                // cannot give the user back the CID they used to create the block, so yield\n                // to `store.putMany` but return the actual block the user passed in.\n                //\n                // nb. we want to use `store.putMany` here so bitswap can control batching\n                // up block HAVEs to send to the network - if we use multiple `store.put`s\n                // it will not be able to guess we are about to `store.put` more blocks\n                output = pushable(); // process.nextTick runs on the microtask queue, setImmediate runs on the next\n                // event loop iteration so is slower. Use process.nextTick if it is available.\n\n                runner = process && process.nextTick ? process.nextTick : setImmediate;\n                runner( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n                  var store;\n                  return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n                    while (1) {\n                      switch (_context7.prev = _context7.next) {\n                        case 0:\n                          _context7.prev = 0;\n                          store = _this4.child;\n                          _context7.next = 4;\n                          return drain(_this4.child.putMany(_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n                            var _iteratorAbruptCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, block, key, exists;\n\n                            return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                              while (1) {\n                                switch (_context6.prev = _context6.next) {\n                                  case 0:\n                                    _iteratorAbruptCompletion4 = false;\n                                    _didIteratorError4 = false;\n                                    _context6.prev = 2;\n                                    _iterator4 = _asyncIterator(blocks);\n\n                                  case 4:\n                                    _context6.next = 6;\n                                    return _awaitAsyncGenerator(_iterator4.next());\n\n                                  case 6:\n                                    if (!(_iteratorAbruptCompletion4 = !(_step4 = _context6.sent).done)) {\n                                      _context6.next = 19;\n                                      break;\n                                    }\n\n                                    block = _step4.value;\n                                    key = cidToKey(block.key);\n                                    _context6.next = 11;\n                                    return _awaitAsyncGenerator(store.has(key, options));\n\n                                  case 11:\n                                    exists = _context6.sent;\n\n                                    if (exists) {\n                                      _context6.next = 15;\n                                      break;\n                                    }\n\n                                    _context6.next = 15;\n                                    return {\n                                      key: key,\n                                      value: block.value\n                                    };\n\n                                  case 15:\n                                    // there is an assumption here that after the yield has completed\n                                    // the underlying datastore has finished writing the block\n                                    output.push(block);\n\n                                  case 16:\n                                    _iteratorAbruptCompletion4 = false;\n                                    _context6.next = 4;\n                                    break;\n\n                                  case 19:\n                                    _context6.next = 25;\n                                    break;\n\n                                  case 21:\n                                    _context6.prev = 21;\n                                    _context6.t0 = _context6[\"catch\"](2);\n                                    _didIteratorError4 = true;\n                                    _iteratorError4 = _context6.t0;\n\n                                  case 25:\n                                    _context6.prev = 25;\n                                    _context6.prev = 26;\n\n                                    if (!(_iteratorAbruptCompletion4 && _iterator4.return != null)) {\n                                      _context6.next = 30;\n                                      break;\n                                    }\n\n                                    _context6.next = 30;\n                                    return _awaitAsyncGenerator(_iterator4.return());\n\n                                  case 30:\n                                    _context6.prev = 30;\n\n                                    if (!_didIteratorError4) {\n                                      _context6.next = 33;\n                                      break;\n                                    }\n\n                                    throw _iteratorError4;\n\n                                  case 33:\n                                    return _context6.finish(30);\n\n                                  case 34:\n                                    return _context6.finish(25);\n\n                                  case 35:\n                                  case \"end\":\n                                    return _context6.stop();\n                                }\n                              }\n                            }, _callee6, null, [[2, 21, 25, 35], [26,, 30, 34]]);\n                          }))()));\n\n                        case 4:\n                          output.end();\n                          _context7.next = 10;\n                          break;\n\n                        case 7:\n                          _context7.prev = 7;\n                          _context7.t0 = _context7[\"catch\"](0);\n                          output.end(_context7.t0);\n\n                        case 10:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }\n                  }, _callee7, null, [[0, 7]]);\n                })));\n                return _context8.delegateYield(_asyncGeneratorDelegate(_asyncIterator(output), _awaitAsyncGenerator), \"t0\", 4);\n\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }))();\n    }\n    /**\n     * @param {CID} cid\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(cid, options) {\n      return this.child.has(cidToKey(cid), options);\n    }\n    /**\n     * @param {CID} cid\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(cid, options) {\n      return this.child.delete(cidToKey(cid), options);\n    }\n    /**\n     * @param {AsyncIterable<CID> | Iterable<CID>} cids\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"deleteMany\",\n    value: function deleteMany(cids, options) {\n      var out = pushable();\n      drain(this.child.deleteMany(_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var _iteratorAbruptCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, cid;\n\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _iteratorAbruptCompletion5 = false;\n                _didIteratorError5 = false;\n                _context9.prev = 2;\n                _iterator5 = _asyncIterator(cids);\n\n              case 4:\n                _context9.next = 6;\n                return _awaitAsyncGenerator(_iterator5.next());\n\n              case 6:\n                if (!(_iteratorAbruptCompletion5 = !(_step5 = _context9.sent).done)) {\n                  _context9.next = 14;\n                  break;\n                }\n\n                cid = _step5.value;\n                _context9.next = 10;\n                return cidToKey(cid);\n\n              case 10:\n                out.push(cid);\n\n              case 11:\n                _iteratorAbruptCompletion5 = false;\n                _context9.next = 4;\n                break;\n\n              case 14:\n                _context9.next = 20;\n                break;\n\n              case 16:\n                _context9.prev = 16;\n                _context9.t0 = _context9[\"catch\"](2);\n                _didIteratorError5 = true;\n                _iteratorError5 = _context9.t0;\n\n              case 20:\n                _context9.prev = 20;\n                _context9.prev = 21;\n\n                if (!(_iteratorAbruptCompletion5 && _iterator5.return != null)) {\n                  _context9.next = 25;\n                  break;\n                }\n\n                _context9.next = 25;\n                return _awaitAsyncGenerator(_iterator5.return());\n\n              case 25:\n                _context9.prev = 25;\n\n                if (!_didIteratorError5) {\n                  _context9.next = 28;\n                  break;\n                }\n\n                throw _iteratorError5;\n\n              case 28:\n                return _context9.finish(25);\n\n              case 29:\n                return _context9.finish(20);\n\n              case 30:\n                out.end();\n\n              case 31:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, null, [[2, 16, 20, 30], [21,, 25, 29]]);\n      }))(), options)).catch(function (err) {\n        out.end(err);\n      });\n      return out;\n    }\n  }]);\n\n  return BlockstoreDatastoreAdapter;\n}(BlockstoreAdapter);\n\nmodule.exports = BlockstoreDatastoreAdapter;","map":{"version":3,"names":["drain","require","pushable","Key","CID","raw","Digest","base32","base32pad","base58btc","errcode","BlockstoreAdapter","cidToKey","cid","c","asCID","Error","encode","multihash","bytes","slice","toUpperCase","keyToCid","key","createV1","code","decode","toString","toLowerCase","convertPrefix","prefix","firstChar","substring","decoder","input","subarray","i","length","err","message","str","convertQuery","query","undefined","filters","map","filter","pair","value","orders","order","a","b","convertKeyQuery","BlockstoreDatastoreAdapter","datastore","child","open","close","options","queryKeys","get","cids","put","blocks","output","runner","process","nextTick","setImmediate","store","putMany","block","has","exists","push","end","delete","out","deleteMany","catch","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/blockstore-datastore-adapter/src/index.js"],"sourcesContent":["'use strict'\n\nconst drain = require('it-drain')\nconst pushable = require('it-pushable')\nconst { Key } = require('interface-datastore')\nconst { CID } = require('multiformats/cid')\nconst raw = require('multiformats/codecs/raw')\nconst Digest = require('multiformats/hashes/digest')\nconst { base32, base32pad } = require('multiformats/bases/base32')\nconst { base58btc } = require('multiformats/bases/base58')\nconst errcode = require('err-code')\nconst { BlockstoreAdapter } = require('interface-blockstore')\n\n/**\n * Transform a cid to the appropriate datastore key.\n *\n * @param {CID} cid\n * @returns {Key}\n */\nfunction cidToKey (cid) {\n  const c = CID.asCID(cid)\n\n  if (!c) {\n    throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID')\n  }\n\n  return new Key('/' + base32.encode(c.multihash.bytes).slice(1).toUpperCase(), false)\n}\n\n/**\n * Transform a datastore Key instance to a CID\n * As Key is a multihash of the CID, it is reconstructed using IPLD's RAW codec.\n * Hence it is highly probable that stored CID will differ from a CID retrieved from blockstore.\n *\n * @param {Key} key\n * @returns {CID}\n */\nfunction keyToCid (key) {\n  // Block key is of the form <base32 encoded string>\n  return CID.createV1(raw.code, Digest.decode(base32.decode('b' + key.toString().slice(1).toLowerCase())))\n}\n\n/**\n * Tries to decode a prefix as the first part of a CID and then\n * strip off the version and codec bytes to just leave part of\n * the multihash.\n *\n * Only really works if the prefix length aligns with the byte\n * boundaries of the encoding.\n *\n * @param {string} prefix\n * @returns {string}\n */\nfunction convertPrefix (prefix) {\n  const firstChar = prefix.substring(0, 1)\n\n  if (firstChar === '/') {\n    return convertPrefix(prefix.substring(1))\n  }\n\n  /** @type {(input: string) => Uint8Array } */\n  let decoder\n\n  if (firstChar.toLowerCase() === 'b') {\n    // v1 cid prefix, remove version and codec bytes\n    decoder = (input) => base32.decode(input.toLowerCase()).subarray(2)\n  } else if (firstChar.toLowerCase() === 'c') {\n    // v1 cid prefix, remove version and codec bytes\n    decoder = (input) => base32pad.decode(input.toLowerCase()).subarray(2)\n  } else if (firstChar === 'z') {\n    // v1 cid\n    decoder = (input) => base58btc.decode(input).subarray(2)\n  } else if (firstChar === 'Q') {\n    // v0 cid prefix\n    decoder = (input) => base58btc.decode('z' + input)\n  } else {\n    decoder = (input) => base32.decode('b' + input.toLowerCase()).subarray(2)\n  }\n\n  let bytes\n\n  // find the longest prefix that we can safely decode\n  for (let i = 1; i < prefix.length; i++) {\n    try {\n      bytes = decoder(prefix.substring(0, i))\n    } catch (err) {\n      if (err.message !== 'Unexpected end of data') {\n        throw err\n      }\n    }\n  }\n\n  let str = '/C'\n\n  if (bytes) {\n    // slice one character from the end of the string to ensure we don't end up\n    // with a padded value which could have a non-matching string at the end\n    str = `/${base32.encode(bytes).slice(1, -1).toUpperCase() || 'C'}`\n  }\n\n  return str\n}\n\n/**\n * @param {import('interface-blockstore').Query} query\n * @returns {import('interface-datastore').Query}\n */\nfunction convertQuery (query) {\n  return {\n    ...query,\n    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,\n    filters: query.filters\n      ? query.filters.map(\n        filter => (pair) => {\n          return filter({ key: keyToCid(pair.key), value: pair.value })\n        }\n      )\n      : undefined,\n    orders: query.orders\n      ? query.orders.map(\n        order => (a, b) => {\n          return order({ key: keyToCid(a.key), value: a.value }, { key: keyToCid(b.key), value: b.value })\n        }\n      )\n      : undefined\n  }\n}\n\n/**\n * @param {import('interface-blockstore').KeyQuery} query\n * @returns {import('interface-datastore').KeyQuery}\n */\nfunction convertKeyQuery (query) {\n  return {\n    ...query,\n    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,\n    filters: query.filters\n      ? query.filters.map(\n        filter => (key) => {\n          return filter(keyToCid(key))\n        }\n      )\n      : undefined,\n    orders: query.orders\n      ? query.orders.map(\n        order => (a, b) => {\n          return order(keyToCid(a), keyToCid(b))\n        }\n      )\n      : undefined\n  }\n}\n\n/**\n * @typedef {import('interface-blockstore').Query} Query\n * @typedef {import('interface-blockstore').KeyQuery} KeyQuery\n * @typedef {import('interface-blockstore').Pair} Pair\n * @typedef {import('interface-blockstore').Options} Options\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n * @implements {Blockstore}\n */\nclass BlockstoreDatastoreAdapter extends BlockstoreAdapter {\n  /**\n   * @param {Datastore} datastore\n   */\n  constructor (datastore) {\n    super()\n\n    this.child = datastore\n  }\n\n  open () {\n    return this.child.open()\n  }\n\n  close () {\n    return this.child.close()\n  }\n\n  /**\n   * @param {Query} query\n   * @param {Options} [options]\n   */\n  async * query (query, options) {\n    for await (const { key, value } of this.child.query(convertQuery(query), options)) {\n      yield { key: keyToCid(key), value }\n    }\n  }\n\n  /**\n   * @param {KeyQuery} query\n   * @param {Options} [options]\n   */\n  async * queryKeys (query, options) {\n    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {\n      yield keyToCid(key)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   * @returns\n   */\n  async get (cid, options) {\n    return this.child.get(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n  async * getMany (cids, options) {\n    for await (const cid of cids) {\n      yield this.get(cid, options)\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n  async put (cid, value, options) {\n    await this.child.put(cidToKey(cid), value, options)\n  }\n\n  /**\n   * @param {AsyncIterable<Pair> | Iterable<Pair>} blocks\n   * @param {Options} [options]\n   */\n  async * putMany (blocks, options) { // eslint-disable-line require-await\n    // we cannot simply chain to `store.putMany` because we convert a CID into\n    // a key based on the multihash only, so we lose the version & codec and\n    // cannot give the user back the CID they used to create the block, so yield\n    // to `store.putMany` but return the actual block the user passed in.\n    //\n    // nb. we want to use `store.putMany` here so bitswap can control batching\n    // up block HAVEs to send to the network - if we use multiple `store.put`s\n    // it will not be able to guess we are about to `store.put` more blocks\n    const output = pushable()\n\n    // process.nextTick runs on the microtask queue, setImmediate runs on the next\n    // event loop iteration so is slower. Use process.nextTick if it is available.\n    const runner = process && process.nextTick ? process.nextTick : setImmediate\n\n    runner(async () => {\n      try {\n        const store = this.child\n\n        await drain(this.child.putMany(async function * () {\n          for await (const block of blocks) {\n            const key = cidToKey(block.key)\n            const exists = await store.has(key, options)\n\n            if (!exists) {\n              yield { key, value: block.value }\n            }\n\n            // there is an assumption here that after the yield has completed\n            // the underlying datastore has finished writing the block\n            output.push(block)\n          }\n        }()))\n\n        output.end()\n      } catch (err) {\n        output.end(err)\n      }\n    })\n\n    yield * output\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n  has (cid, options) {\n    return this.child.has(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {Options} [options]\n   */\n  delete (cid, options) {\n    return this.child.delete(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {AsyncIterable<CID> | Iterable<CID>} cids\n   * @param {Options} [options]\n   */\n  deleteMany (cids, options) {\n    const out = pushable()\n\n    drain(this.child.deleteMany((async function * () {\n      for await (const cid of cids) {\n        yield cidToKey(cid)\n\n        out.push(cid)\n      }\n\n      out.end()\n    }()), options)).catch(err => {\n      out.end(err)\n    })\n\n    return out\n  }\n}\n\nmodule.exports = BlockstoreDatastoreAdapter\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,UAAD,CAArB;;AACA,IAAMC,QAAQ,GAAGD,OAAO,CAAC,aAAD,CAAxB;;AACA,eAAgBA,OAAO,CAAC,qBAAD,CAAvB;AAAA,IAAQE,GAAR,YAAQA,GAAR;;AACA,gBAAgBF,OAAO,CAAC,kBAAD,CAAvB;AAAA,IAAQG,GAAR,aAAQA,GAAR;;AACA,IAAMC,GAAG,GAAGJ,OAAO,CAAC,yBAAD,CAAnB;;AACA,IAAMK,MAAM,GAAGL,OAAO,CAAC,4BAAD,CAAtB;;AACA,gBAA8BA,OAAO,CAAC,2BAAD,CAArC;AAAA,IAAQM,MAAR,aAAQA,MAAR;AAAA,IAAgBC,SAAhB,aAAgBA,SAAhB;;AACA,gBAAsBP,OAAO,CAAC,2BAAD,CAA7B;AAAA,IAAQQ,SAAR,aAAQA,SAAR;;AACA,IAAMC,OAAO,GAAGT,OAAO,CAAC,UAAD,CAAvB;;AACA,gBAA8BA,OAAO,CAAC,sBAAD,CAArC;AAAA,IAAQU,iBAAR,aAAQA,iBAAR;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,QAAT,CAAmBC,GAAnB,EAAwB;EACtB,IAAMC,CAAC,GAAGV,GAAG,CAACW,KAAJ,CAAUF,GAAV,CAAV;;EAEA,IAAI,CAACC,CAAL,EAAQ;IACN,MAAMJ,OAAO,CAAC,IAAIM,KAAJ,CAAU,iBAAV,CAAD,EAA+B,iBAA/B,CAAb;EACD;;EAED,OAAO,IAAIb,GAAJ,CAAQ,MAAMI,MAAM,CAACU,MAAP,CAAcH,CAAC,CAACI,SAAF,CAAYC,KAA1B,EAAiCC,KAAjC,CAAuC,CAAvC,EAA0CC,WAA1C,EAAd,EAAuE,KAAvE,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,QAAT,CAAmBC,GAAnB,EAAwB;EACtB;EACA,OAAOnB,GAAG,CAACoB,QAAJ,CAAanB,GAAG,CAACoB,IAAjB,EAAuBnB,MAAM,CAACoB,MAAP,CAAcnB,MAAM,CAACmB,MAAP,CAAc,MAAMH,GAAG,CAACI,QAAJ,GAAeP,KAAf,CAAqB,CAArB,EAAwBQ,WAAxB,EAApB,CAAd,CAAvB,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,aAAT,CAAwBC,MAAxB,EAAgC;EAC9B,IAAMC,SAAS,GAAGD,MAAM,CAACE,SAAP,CAAiB,CAAjB,EAAoB,CAApB,CAAlB;;EAEA,IAAID,SAAS,KAAK,GAAlB,EAAuB;IACrB,OAAOF,aAAa,CAACC,MAAM,CAACE,SAAP,CAAiB,CAAjB,CAAD,CAApB;EACD;EAED;;;EACA,IAAIC,OAAJ;;EAEA,IAAIF,SAAS,CAACH,WAAV,OAA4B,GAAhC,EAAqC;IACnC;IACAK,OAAO,GAAG,iBAACC,KAAD;MAAA,OAAW3B,MAAM,CAACmB,MAAP,CAAcQ,KAAK,CAACN,WAAN,EAAd,EAAmCO,QAAnC,CAA4C,CAA5C,CAAX;IAAA,CAAV;EACD,CAHD,MAGO,IAAIJ,SAAS,CAACH,WAAV,OAA4B,GAAhC,EAAqC;IAC1C;IACAK,OAAO,GAAG,iBAACC,KAAD;MAAA,OAAW1B,SAAS,CAACkB,MAAV,CAAiBQ,KAAK,CAACN,WAAN,EAAjB,EAAsCO,QAAtC,CAA+C,CAA/C,CAAX;IAAA,CAAV;EACD,CAHM,MAGA,IAAIJ,SAAS,KAAK,GAAlB,EAAuB;IAC5B;IACAE,OAAO,GAAG,iBAACC,KAAD;MAAA,OAAWzB,SAAS,CAACiB,MAAV,CAAiBQ,KAAjB,EAAwBC,QAAxB,CAAiC,CAAjC,CAAX;IAAA,CAAV;EACD,CAHM,MAGA,IAAIJ,SAAS,KAAK,GAAlB,EAAuB;IAC5B;IACAE,OAAO,GAAG,iBAACC,KAAD;MAAA,OAAWzB,SAAS,CAACiB,MAAV,CAAiB,MAAMQ,KAAvB,CAAX;IAAA,CAAV;EACD,CAHM,MAGA;IACLD,OAAO,GAAG,iBAACC,KAAD;MAAA,OAAW3B,MAAM,CAACmB,MAAP,CAAc,MAAMQ,KAAK,CAACN,WAAN,EAApB,EAAyCO,QAAzC,CAAkD,CAAlD,CAAX;IAAA,CAAV;EACD;;EAED,IAAIhB,KAAJ,CA1B8B,CA4B9B;;EACA,KAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,MAAM,CAACO,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;IACtC,IAAI;MACFjB,KAAK,GAAGc,OAAO,CAACH,MAAM,CAACE,SAAP,CAAiB,CAAjB,EAAoBI,CAApB,CAAD,CAAf;IACD,CAFD,CAEE,OAAOE,GAAP,EAAY;MACZ,IAAIA,GAAG,CAACC,OAAJ,KAAgB,wBAApB,EAA8C;QAC5C,MAAMD,GAAN;MACD;IACF;EACF;;EAED,IAAIE,GAAG,GAAG,IAAV;;EAEA,IAAIrB,KAAJ,EAAW;IACT;IACA;IACAqB,GAAG,cAAOjC,MAAM,CAACU,MAAP,CAAcE,KAAd,EAAqBC,KAArB,CAA2B,CAA3B,EAA8B,CAAC,CAA/B,EAAkCC,WAAlC,MAAmD,GAA1D,CAAH;EACD;;EAED,OAAOmB,GAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASC,YAAT,CAAuBC,KAAvB,EAA8B;EAC5B,uCACKA,KADL;IAEEZ,MAAM,EAAEY,KAAK,CAACZ,MAAN,GAAeD,aAAa,CAACa,KAAK,CAACZ,MAAP,CAA5B,GAA6Ca,SAFvD;IAGEC,OAAO,EAAEF,KAAK,CAACE,OAAN,GACLF,KAAK,CAACE,OAAN,CAAcC,GAAd,CACA,UAAAC,MAAM;MAAA,OAAI,UAACC,IAAD,EAAU;QAClB,OAAOD,MAAM,CAAC;UAAEvB,GAAG,EAAED,QAAQ,CAACyB,IAAI,CAACxB,GAAN,CAAf;UAA2ByB,KAAK,EAAED,IAAI,CAACC;QAAvC,CAAD,CAAb;MACD,CAFK;IAAA,CADN,CADK,GAMLL,SATN;IAUEM,MAAM,EAAEP,KAAK,CAACO,MAAN,GACJP,KAAK,CAACO,MAAN,CAAaJ,GAAb,CACA,UAAAK,KAAK;MAAA,OAAI,UAACC,CAAD,EAAIC,CAAJ,EAAU;QACjB,OAAOF,KAAK,CAAC;UAAE3B,GAAG,EAAED,QAAQ,CAAC6B,CAAC,CAAC5B,GAAH,CAAf;UAAwByB,KAAK,EAAEG,CAAC,CAACH;QAAjC,CAAD,EAA2C;UAAEzB,GAAG,EAAED,QAAQ,CAAC8B,CAAC,CAAC7B,GAAH,CAAf;UAAwByB,KAAK,EAAEI,CAAC,CAACJ;QAAjC,CAA3C,CAAZ;MACD,CAFI;IAAA,CADL,CADI,GAMJL;EAhBN;AAkBD;AAED;AACA;AACA;AACA;;;AACA,SAASU,eAAT,CAA0BX,KAA1B,EAAiC;EAC/B,uCACKA,KADL;IAEEZ,MAAM,EAAEY,KAAK,CAACZ,MAAN,GAAeD,aAAa,CAACa,KAAK,CAACZ,MAAP,CAA5B,GAA6Ca,SAFvD;IAGEC,OAAO,EAAEF,KAAK,CAACE,OAAN,GACLF,KAAK,CAACE,OAAN,CAAcC,GAAd,CACA,UAAAC,MAAM;MAAA,OAAI,UAACvB,GAAD,EAAS;QACjB,OAAOuB,MAAM,CAACxB,QAAQ,CAACC,GAAD,CAAT,CAAb;MACD,CAFK;IAAA,CADN,CADK,GAMLoB,SATN;IAUEM,MAAM,EAAEP,KAAK,CAACO,MAAN,GACJP,KAAK,CAACO,MAAN,CAAaJ,GAAb,CACA,UAAAK,KAAK;MAAA,OAAI,UAACC,CAAD,EAAIC,CAAJ,EAAU;QACjB,OAAOF,KAAK,CAAC5B,QAAQ,CAAC6B,CAAD,CAAT,EAAc7B,QAAQ,CAAC8B,CAAD,CAAtB,CAAZ;MACD,CAFI;IAAA,CADL,CADI,GAMJT;EAhBN;AAkBD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;IACMW,0B;;;;;EACJ;AACF;AACA;EACE,oCAAaC,SAAb,EAAwB;IAAA;;IAAA;;IACtB;IAEA,OAAKC,KAAL,GAAaD,SAAb;IAHsB;EAIvB;;;;WAED,gBAAQ;MACN,OAAO,KAAKC,KAAL,CAAWC,IAAX,EAAP;IACD;;;WAED,iBAAS;MACP,OAAO,KAAKD,KAAL,CAAWE,KAAX,EAAP;IACD;IAED;AACF;AACA;AACA;;;;WACE,eAAehB,MAAf,EAAsBiB,OAAtB,EAA+B;MAAA;;MAAA;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA;gBAAA;gBAAA,2BACM,KAAI,CAACH,KAAL,CAAWd,KAAX,CAAiBD,YAAY,CAACC,MAAD,CAA7B,EAAsCiB,OAAtC,CADN;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;;gBAAA,2BACVpC,GADU,eACVA,GADU,EACLyB,KADK,eACLA,KADK;gBAAA;gBAE3B,OAAM;kBAAEzB,GAAG,EAAED,QAAQ,CAACC,GAAD,CAAf;kBAAsByB,KAAK,EAALA;gBAAtB,CAAN;;cAF2B;gBAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;gBAAA;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA;;cAAA;gBAAA;;gBAAA;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAAA;;cAAA;gBAAA;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAI9B;IAED;AACF;AACA;AACA;;;;WACE,mBAAmBN,KAAnB,EAA0BiB,OAA1B,EAAmC;MAAA;;MAAA;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA;gBAAA;gBAAA,4BACT,MAAI,CAACH,KAAL,CAAWI,SAAX,CAAqBP,eAAe,CAACX,KAAD,CAApC,EAA6CiB,OAA7C,CADS;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;;gBAChBpC,GADgB;gBAAA;gBAE/B,OAAMD,QAAQ,CAACC,GAAD,CAAd;;cAF+B;gBAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;gBAAA;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA;;cAAA;gBAAA;;gBAAA;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAAA;;cAAA;gBAAA;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAIlC;IAED;AACF;AACA;AACA;AACA;;;;;4EACE,kBAAWV,GAAX,EAAgB8C,OAAhB;QAAA;UAAA;YAAA;cAAA;gBAAA,kCACS,KAAKH,KAAL,CAAWK,GAAX,CAAejD,QAAQ,CAACC,GAAD,CAAvB,EAA8B8C,OAA9B,CADT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAIA;AACF;AACA;AACA;;;;WACE,iBAAiBG,IAAjB,EAAuBH,OAAvB,EAAgC;MAAA;;MAAA;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA;gBAAA;gBAAA,4BACNG,IADM;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;;gBACbjD,GADa;gBAAA;gBAE5B,OAAM,MAAI,CAACgD,GAAL,CAAShD,GAAT,EAAc8C,OAAd,CAAN;;cAF4B;gBAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;gBAAA;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA;;cAAA;gBAAA;;gBAAA;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAAA;;cAAA;gBAAA;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAI/B;IAED;AACF;AACA;AACA;AACA;;;;;4EACE,kBAAW9C,GAAX,EAAgBmC,KAAhB,EAAuBW,OAAvB;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACQ,KAAKH,KAAL,CAAWO,GAAX,CAAenD,QAAQ,CAACC,GAAD,CAAvB,EAA8BmC,KAA9B,EAAqCW,OAArC,CADR;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAIA;AACF;AACA;AACA;;;;WACE,iBAAiBK,MAAjB,EAAyBL,OAAzB,EAAkC;MAAA;;MAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAE;gBAClC;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;gBACMM,MAT0B,GASjB/D,QAAQ,EATS,EAWhC;gBACA;;gBACMgE,MAb0B,GAajBC,OAAO,IAAIA,OAAO,CAACC,QAAnB,GAA8BD,OAAO,CAACC,QAAtC,GAAiDC,YAbhC;gBAehCH,MAAM,0EAAC;kBAAA;kBAAA;oBAAA;sBAAA;wBAAA;0BAAA;0BAEGI,KAFH,GAEW,MAAI,CAACd,KAFhB;0BAAA;0BAAA,OAIGxD,KAAK,CAAC,MAAI,CAACwD,KAAL,CAAWe,OAAX,CAAmB;4BAAA;;4BAAA;8BAAA;gCAAA;kCAAA;oCAAA;oCAAA;oCAAA;oCAAA,4BACHP,MADG;;kCAAA;oCAAA;oCAAA;;kCAAA;oCAAA;sCAAA;sCAAA;oCAAA;;oCACZQ,KADY;oCAErBjD,GAFqB,GAEfX,QAAQ,CAAC4D,KAAK,CAACjD,GAAP,CAFO;oCAAA;oCAAA,4BAGN+C,KAAK,CAACG,GAAN,CAAUlD,GAAV,EAAeoC,OAAf,CAHM;;kCAAA;oCAGrBe,MAHqB;;oCAAA,IAKtBA,MALsB;sCAAA;sCAAA;oCAAA;;oCAAA;oCAMzB,OAAM;sCAAEnD,GAAG,EAAHA,GAAF;sCAAOyB,KAAK,EAAEwB,KAAK,CAACxB;oCAApB,CAAN;;kCANyB;oCAS3B;oCACA;oCACAiB,MAAM,CAACU,IAAP,CAAYH,KAAZ;;kCAX2B;oCAAA;oCAAA;oCAAA;;kCAAA;oCAAA;oCAAA;;kCAAA;oCAAA;oCAAA;oCAAA;oCAAA;;kCAAA;oCAAA;oCAAA;;oCAAA;sCAAA;sCAAA;oCAAA;;oCAAA;oCAAA;;kCAAA;oCAAA;;oCAAA;sCAAA;sCAAA;oCAAA;;oCAAA;;kCAAA;oCAAA;;kCAAA;oCAAA;;kCAAA;kCAAA;oCAAA;gCAAA;8BAAA;4BAAA;0BAAA,KAAnB,CAAD,CAJR;;wBAAA;0BAmBHP,MAAM,CAACW,GAAP;0BAnBG;0BAAA;;wBAAA;0BAAA;0BAAA;0BAqBHX,MAAM,CAACW,GAAP;;wBArBG;wBAAA;0BAAA;sBAAA;oBAAA;kBAAA;gBAAA,CAAD,GAAN;gBAyBA,sEAAQX,MAAR;;cAxCgC;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAyCjC;IAED;AACF;AACA;AACA;;;;WACE,aAAKpD,GAAL,EAAU8C,OAAV,EAAmB;MACjB,OAAO,KAAKH,KAAL,CAAWiB,GAAX,CAAe7D,QAAQ,CAACC,GAAD,CAAvB,EAA8B8C,OAA9B,CAAP;IACD;IAED;AACF;AACA;AACA;;;;WACE,iBAAQ9C,GAAR,EAAa8C,OAAb,EAAsB;MACpB,OAAO,KAAKH,KAAL,CAAWqB,MAAX,CAAkBjE,QAAQ,CAACC,GAAD,CAA1B,EAAiC8C,OAAjC,CAAP;IACD;IAED;AACF;AACA;AACA;;;;WACE,oBAAYG,IAAZ,EAAkBH,OAAlB,EAA2B;MACzB,IAAMmB,GAAG,GAAG5E,QAAQ,EAApB;MAEAF,KAAK,CAAC,KAAKwD,KAAL,CAAWuB,UAAX,CAAuB;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA;gBAAA;gBAAA,4BACHjB,IADG;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;;gBACVjD,GADU;gBAAA;gBAEzB,OAAMD,QAAQ,CAACC,GAAD,CAAd;;cAFyB;gBAIzBiE,GAAG,CAACH,IAAJ,CAAS9D,GAAT;;cAJyB;gBAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;gBAAA;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA;;cAAA;gBAAA;;gBAAA;kBAAA;kBAAA;gBAAA;;gBAAA;;cAAA;gBAAA;;cAAA;gBAAA;;cAAA;gBAO3BiE,GAAG,CAACF,GAAJ;;cAP2B;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,KAAvB,EAQAjB,OARA,CAAD,CAAL,CAQgBqB,KARhB,CAQsB,UAAA1C,GAAG,EAAI;QAC3BwC,GAAG,CAACF,GAAJ,CAAQtC,GAAR;MACD,CAVD;MAYA,OAAOwC,GAAP;IACD;;;;EArJsCnE,iB;;AAwJzCsE,MAAM,CAACC,OAAP,GAAiB5B,0BAAjB"},"metadata":{},"sourceType":"script"}