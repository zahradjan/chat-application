{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Noise = void 0;\n\nvar x25519 = __importStar(require(\"@stablelib/x25519\"));\n\nvar buffer_1 = require(\"buffer\");\n\nvar it_pb_rpc_1 = __importDefault(require(\"it-pb-rpc\"));\n\nvar duplex_1 = __importDefault(require(\"it-pair/duplex\"));\n\nvar it_buffer_1 = __importDefault(require(\"it-buffer\"));\n\nvar it_pipe_1 = __importDefault(require(\"it-pipe\"));\n\nvar it_length_prefixed_1 = require(\"it-length-prefixed\");\n\nvar handshake_xx_1 = require(\"./handshake-xx\");\n\nvar handshake_ik_1 = require(\"./handshake-ik\");\n\nvar handshake_xx_fallback_1 = require(\"./handshake-xx-fallback\");\n\nvar utils_1 = require(\"./utils\");\n\nvar encoder_1 = require(\"./encoder\");\n\nvar crypto_1 = require(\"./crypto\");\n\nvar keycache_1 = require(\"./keycache\");\n\nvar logger_1 = require(\"./logger\");\n\nvar constants_1 = require(\"./constants\");\n\nvar Noise = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {bytes} staticNoiseKey - x25519 private key, reuse for faster handshakes\n   * @param {bytes} earlyData\n   */\n  function Noise(staticNoiseKey, earlyData) {\n    _classCallCheck(this, Noise);\n\n    this.protocol = '/noise';\n    this.prologue = buffer_1.Buffer.alloc(0);\n    this.earlyData = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0); // disabled until properly specked\n\n    this.useNoisePipes = false;\n\n    if (staticNoiseKey) {\n      // accepts x25519 private key of length 32\n      var keyPair = x25519.generateKeyPairFromSeed(staticNoiseKey);\n      this.staticKeys = {\n        privateKey: buffer_1.Buffer.from(keyPair.secretKey.buffer, keyPair.secretKey.byteOffset, keyPair.secretKey.length),\n        publicKey: buffer_1.Buffer.from(keyPair.publicKey.buffer, keyPair.publicKey.byteOffset, keyPair.publicKey.length)\n      };\n    } else {\n      this.staticKeys = utils_1.generateKeypair();\n    }\n  }\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param {any} connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  _createClass(Noise, [{\n    key: \"secureOutbound\",\n    value: function () {\n      var _secureOutbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(localPeer, connection, remotePeer) {\n        var wrappedConnection, handshake, conn;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                wrappedConnection = it_pb_rpc_1.default(connection, {\n                  lengthEncoder: encoder_1.uint16BEEncode,\n                  lengthDecoder: encoder_1.uint16BEDecode,\n                  maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n                });\n                _context.next = 3;\n                return this.performHandshake({\n                  connection: wrappedConnection,\n                  isInitiator: true,\n                  localPeer: localPeer,\n                  remotePeer: remotePeer\n                });\n\n              case 3:\n                handshake = _context.sent;\n                _context.next = 6;\n                return this.createSecureConnection(wrappedConnection, handshake);\n\n              case 6:\n                conn = _context.sent;\n                return _context.abrupt(\"return\", {\n                  conn: conn,\n                  remoteEarlyData: handshake.remoteEarlyData,\n                  remotePeer: handshake.remotePeer\n                });\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function secureOutbound(_x, _x2, _x3) {\n        return _secureOutbound.apply(this, arguments);\n      }\n\n      return secureOutbound;\n    }()\n    /**\n     * Decrypt incoming data (handshake as responder).\n     *\n     * @param {PeerId} localPeer - PeerId of the receiving peer.\n     * @param {any} connection - streaming iterable duplex that will be encryption.\n     * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n     * @returns {Promise<SecureOutbound>}\n     */\n\n  }, {\n    key: \"secureInbound\",\n    value: function () {\n      var _secureInbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(localPeer, connection, remotePeer) {\n        var wrappedConnection, handshake, conn;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                wrappedConnection = it_pb_rpc_1.default(connection, {\n                  lengthEncoder: encoder_1.uint16BEEncode,\n                  lengthDecoder: encoder_1.uint16BEDecode,\n                  maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n                });\n                _context2.next = 3;\n                return this.performHandshake({\n                  connection: wrappedConnection,\n                  isInitiator: false,\n                  localPeer: localPeer,\n                  remotePeer: remotePeer\n                });\n\n              case 3:\n                handshake = _context2.sent;\n                _context2.next = 6;\n                return this.createSecureConnection(wrappedConnection, handshake);\n\n              case 6:\n                conn = _context2.sent;\n                return _context2.abrupt(\"return\", {\n                  conn: conn,\n                  remoteEarlyData: handshake.remoteEarlyData,\n                  remotePeer: handshake.remotePeer\n                });\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function secureInbound(_x4, _x5, _x6) {\n        return _secureInbound.apply(this, arguments);\n      }\n\n      return secureInbound;\n    }()\n    /**\n     * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n     * If noise pipes disabled or remote peer static key is unknown, use XX.\n     *\n     * @param {HandshakeParams} params\n     */\n\n  }, {\n    key: \"performHandshake\",\n    value: function () {\n      var _performHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(params) {\n        var _a, payload, tryIK, remotePeer, connection, isInitiator, ikHandshake, ephemeralKeys;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return utils_1.getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n\n              case 2:\n                payload = _context3.sent;\n                tryIK = this.useNoisePipes;\n\n                if (params.isInitiator && keycache_1.KeyCache.load(params.remotePeer) === null) {\n                  // if we are initiator and remote static key is unknown, don't try IK\n                  tryIK = false;\n                } // Try IK if acting as responder or initiator that has remote's static key.\n\n\n                if (!tryIK) {\n                  _context3.next = 22;\n                  break;\n                }\n\n                // Try IK first\n                remotePeer = params.remotePeer, connection = params.connection, isInitiator = params.isInitiator;\n                ikHandshake = new handshake_ik_1.IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, // safe to cast as we did checks\n                (_a = keycache_1.KeyCache.load(params.remotePeer)) !== null && _a !== void 0 ? _a : buffer_1.Buffer.alloc(32), remotePeer);\n                _context3.prev = 8;\n                _context3.next = 11;\n                return this.performIKHandshake(ikHandshake);\n\n              case 11:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 14:\n                _context3.prev = 14;\n                _context3.t0 = _context3[\"catch\"](8);\n\n                // IK failed, go to XX fallback\n                if (params.isInitiator) {\n                  ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n                }\n\n                _context3.next = 19;\n                return this.performXXFallbackHandshake(params, payload, _context3.t0.initialMsg, ephemeralKeys);\n\n              case 19:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 20:\n                _context3.next = 25;\n                break;\n\n              case 22:\n                _context3.next = 24;\n                return this.performXXHandshake(params, payload);\n\n              case 24:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 25:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[8, 14]]);\n      }));\n\n      function performHandshake(_x7) {\n        return _performHandshake.apply(this, arguments);\n      }\n\n      return performHandshake;\n    }()\n  }, {\n    key: \"performXXFallbackHandshake\",\n    value: function () {\n      var _performXXFallbackHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(params, payload, initialMsg, ephemeralKeys) {\n        var isInitiator, remotePeer, connection, handshake, err;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                isInitiator = params.isInitiator, remotePeer = params.remotePeer, connection = params.connection;\n                handshake = new handshake_xx_fallback_1.XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n                _context4.prev = 2;\n                _context4.next = 5;\n                return handshake.propose();\n\n              case 5:\n                _context4.next = 7;\n                return handshake.exchange();\n\n              case 7:\n                _context4.next = 9;\n                return handshake.finish();\n\n              case 9:\n                _context4.next = 16;\n                break;\n\n              case 11:\n                _context4.prev = 11;\n                _context4.t0 = _context4[\"catch\"](2);\n                logger_1.logger(_context4.t0);\n                err = _context4.t0;\n                throw new Error(\"Error occurred during XX Fallback handshake: \".concat(err.message));\n\n              case 16:\n                return _context4.abrupt(\"return\", handshake);\n\n              case 17:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[2, 11]]);\n      }));\n\n      function performXXFallbackHandshake(_x8, _x9, _x10, _x11) {\n        return _performXXFallbackHandshake.apply(this, arguments);\n      }\n\n      return performXXFallbackHandshake;\n    }()\n  }, {\n    key: \"performXXHandshake\",\n    value: function () {\n      var _performXXHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(params, payload) {\n        var isInitiator, remotePeer, connection, handshake, err;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                isInitiator = params.isInitiator, remotePeer = params.remotePeer, connection = params.connection;\n                handshake = new handshake_xx_1.XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n                _context5.prev = 2;\n                _context5.next = 5;\n                return handshake.propose();\n\n              case 5:\n                _context5.next = 7;\n                return handshake.exchange();\n\n              case 7:\n                _context5.next = 9;\n                return handshake.finish();\n\n              case 9:\n                if (this.useNoisePipes && handshake.remotePeer) {\n                  keycache_1.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n                }\n\n                _context5.next = 16;\n                break;\n\n              case 12:\n                _context5.prev = 12;\n                _context5.t0 = _context5[\"catch\"](2);\n                err = _context5.t0;\n                throw new Error(\"Error occurred during XX handshake: \".concat(err.message));\n\n              case 16:\n                return _context5.abrupt(\"return\", handshake);\n\n              case 17:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[2, 12]]);\n      }));\n\n      function performXXHandshake(_x12, _x13) {\n        return _performXXHandshake.apply(this, arguments);\n      }\n\n      return performXXHandshake;\n    }()\n  }, {\n    key: \"performIKHandshake\",\n    value: function () {\n      var _performIKHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(handshake) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return handshake.stage0();\n\n              case 2:\n                _context6.next = 4;\n                return handshake.stage1();\n\n              case 4:\n                return _context6.abrupt(\"return\", handshake);\n\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function performIKHandshake(_x14) {\n        return _performIKHandshake.apply(this, arguments);\n      }\n\n      return performIKHandshake;\n    }()\n  }, {\n    key: \"createSecureConnection\",\n    value: function () {\n      var _createSecureConnection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(connection, handshake) {\n        var _duplex_1$default, _duplex_1$default2, secure, user, network;\n\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                // Create encryption box/unbox wrapper\n                _duplex_1$default = duplex_1.default(), _duplex_1$default2 = _slicedToArray(_duplex_1$default, 2), secure = _duplex_1$default2[0], user = _duplex_1$default2[1];\n                network = connection.unwrap();\n                _context7.next = 4;\n                return it_pipe_1.default(secure, // write to wrapper\n                it_buffer_1.default, // ensure any type of data is converted to buffer\n                crypto_1.encryptStream(handshake), // data is encrypted\n                it_length_prefixed_1.encode({\n                  lengthEncoder: encoder_1.uint16BEEncode\n                }), // prefix with message length\n                network, // send to the remote peer\n                it_length_prefixed_1.decode({\n                  lengthDecoder: encoder_1.uint16BEDecode\n                }), // read message length prefix\n                it_buffer_1.default, // ensure any type of data is converted to buffer\n                crypto_1.decryptStream(handshake), // decrypt the incoming data\n                secure // pipe to the wrapper\n                );\n\n              case 4:\n                return _context7.abrupt(\"return\", user);\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function createSecureConnection(_x15, _x16) {\n        return _createSecureConnection.apply(this, arguments);\n      }\n\n      return createSecureConnection;\n    }()\n  }]);\n\n  return Noise;\n}();\n\nexports.Noise = Noise;","map":{"version":3,"mappings":"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","names":["Noise","staticNoiseKey","earlyData","buffer_1","alloc","useNoisePipes","keyPair","x25519","generateKeyPairFromSeed","staticKeys","privateKey","from","secretKey","buffer","byteOffset","length","publicKey","utils_1","localPeer","connection","remotePeer","wrappedConnection","it_pb_rpc_1","lengthEncoder","encoder_1","lengthDecoder","maxDataLength","constants_1","performHandshake","isInitiator","handshake","createSecureConnection","conn","remoteEarlyData","params","payload","tryIK","keycache_1","load","ikHandshake","handshake_ik_1","prologue","_a","performIKHandshake","ephemeralKeys","getLocalEphemeralKeys","performXXFallbackHandshake","initialMsg","performXXHandshake","handshake_xx_fallback_1","propose","exchange","finish","logger_1","err","Error","message","handshake_xx_1","store","getRemoteStaticKey","stage0","stage1","duplex_1","secure","user","network","unwrap","it_pipe_1","it_buffer_1","crypto_1","it_length_prefixed_1","exports"],"sourceRoot":"","sources":["../../src/noise.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}