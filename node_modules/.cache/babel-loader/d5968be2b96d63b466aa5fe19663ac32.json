{"ast":null,"code":"'use strict';\n\nconst NanoDate = require('timestamp-nano');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst crypto = require('libp2p-crypto');\n\nconst PeerId = require('peer-id');\n\nconst Digest = require('multiformats/hashes/digest');\n\nconst {\n  identity\n} = require('multiformats/hashes/identity');\n\nconst errCode = require('err-code');\n\nconst {\n  base32upper\n} = require('multiformats/bases/base32');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst cborg = require('cborg');\n\nconst Long = require('long');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('jsipns'), {\n  error: debug('jsipns:error')\n});\n\nconst {\n  IpnsEntry: ipnsEntryProto\n} = require('./pb/ipns.js');\n\nconst {\n  parseRFC3339\n} = require('./utils');\n\nconst ERRORS = require('./errors');\n\nconst ID_MULTIHASH_CODE = identity.code;\nconst namespace = '/ipns/';\nconst IPNS_PREFIX = uint8ArrayFromString('/ipns/');\n/**\n * @typedef {import('./types').IPNSEntry} IPNSEntry\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n */\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {PrivateKey} privateKey - private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {number} lifetime - lifetime of the record (in milliseconds).\n */\n\nconst create = (privateKey, value, seq, lifetime) => {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  const expirationDate = new NanoDate(Date.now() + Number(lifetime));\n  const validityType = ipnsEntryProto.ValidityType.EOL;\n  const [ms, ns] = lifetime.toString().split('.');\n  const lifetimeNs = BigInt(ms) * 100000n + BigInt(ns || 0);\n  return _create(privateKey, value, seq, validityType, expirationDate, lifetimeNs);\n};\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n *\n * @param {PrivateKey} privateKey - private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {string} expiration - expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n */\n\n\nconst createWithExpiration = (privateKey, value, seq, expiration) => {\n  const expirationDate = NanoDate.fromString(expiration);\n  const validityType = ipnsEntryProto.ValidityType.EOL;\n  const ttlMs = expirationDate.toDate().getTime() - Date.now();\n  const ttlNs = BigInt(ttlMs) * 100000n + BigInt(expirationDate.getNano());\n  return _create(privateKey, value, seq, validityType, expirationDate, ttlNs);\n};\n/**\n * @param {PrivateKey} privateKey\n * @param {Uint8Array} value\n * @param {number | bigint} seq\n * @param {number} validityType\n * @param {NanoDate} expirationDate\n * @param {bigint} ttl\n * @returns {Promise<IPNSEntry>}\n */\n\n\nconst _create = async (privateKey, value, seq, validityType, expirationDate, ttl) => {\n  seq = BigInt(seq);\n  const isoValidity = uint8ArrayFromString(expirationDate.toString());\n  const signatureV1 = await sign(privateKey, value, validityType, isoValidity);\n  const data = createCborData(value, isoValidity, validityType, seq, ttl);\n  const sigData = ipnsEntryDataForV2Sig(data);\n  const signatureV2 = await privateKey.sign(sigData);\n  const entry = {\n    value,\n    signature: signatureV1,\n    validityType: validityType,\n    validity: isoValidity,\n    sequence: seq,\n    ttl,\n    signatureV2,\n    data\n  };\n  log(`ipns entry for ${value} created`);\n  return entry;\n};\n/**\n * @param {Uint8Array} value\n * @param {Uint8Array} validity\n * @param {number} validityType\n * @param {bigint} sequence\n * @param {bigint} ttl\n */\n\n\nconst createCborData = (value, validity, validityType, sequence, ttl) => {\n  const data = {\n    Value: value,\n    Validity: validity,\n    ValidityType: validityType,\n    Sequence: sequence,\n    TTL: ttl\n  };\n  return cborg.encode(data);\n};\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {PublicKey} publicKey - public key for validating the record.\n * @param {IPNSEntry} entry - ipns entry record.\n */\n\n\nconst validate = async (publicKey, entry) => {\n  const {\n    value,\n    validityType,\n    validity\n  } = entry;\n  /** @type {Uint8Array} */\n\n  let dataForSignature;\n  let signature; // Check v2 signature if it's available, otherwise use the v1 signature\n\n  if (entry.signatureV2 && entry.data) {\n    signature = entry.signatureV2;\n    dataForSignature = ipnsEntryDataForV2Sig(entry.data);\n    validateCborDataMatchesPbData(entry);\n  } else {\n    signature = entry.signature;\n    dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n  } // Validate Signature\n\n\n  let isValid;\n\n  try {\n    isValid = await publicKey.verify(dataForSignature, signature);\n  } catch (err) {\n    isValid = false;\n  }\n\n  if (!isValid) {\n    log.error('record signature verification failed');\n    throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  } // Validate according to the validity type\n\n\n  if (validityType === ipnsEntryProto.ValidityType.EOL) {\n    let validityDate;\n\n    try {\n      validityDate = parseRFC3339(uint8ArrayToString(validity));\n    } catch (e) {\n      log.error('unrecognized validity format (not an rfc3339 format)');\n      throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT);\n    }\n\n    if (validityDate.getTime() < Date.now()) {\n      log.error('record has expired');\n      throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD);\n    }\n  } else if (validityType) {\n    log.error('unrecognized validity type');\n    throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n  }\n\n  log(`ipns entry for ${value} is valid`);\n};\n/**\n * @param {IPNSEntry} entry\n */\n\n\nconst validateCborDataMatchesPbData = entry => {\n  if (!entry.data) {\n    throw errCode(new Error('Record data is missing'), ERRORS.ERR_INVALID_RECORD_DATA);\n  }\n\n  const data = cborg.decode(entry.data);\n\n  if (Number.isInteger(data.Sequence)) {\n    // sequence must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.Sequence = BigInt(data.Sequence);\n  }\n\n  if (Number.isInteger(data.TTL)) {\n    // ttl must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.TTL = BigInt(data.TTL);\n  }\n\n  if (!uint8ArrayEquals(data.Value, entry.value)) {\n    throw errCode(new Error('Field \"value\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (!uint8ArrayEquals(data.Validity, entry.validity)) {\n    throw errCode(new Error('Field \"validity\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.ValidityType !== entry.validityType) {\n    throw errCode(new Error('Field \"validityType\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.Sequence !== entry.sequence) {\n    throw errCode(new Error('Field \"sequence\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n\n  if (data.TTL !== entry.ttl) {\n    throw errCode(new Error('Field \"ttl\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  }\n};\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validate a record upon receipt, they need\n * the public key associated with it. For old RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {PublicKey} publicKey - public key to embed.\n * @param {IPNSEntry} entry - ipns entry record.\n */\n\n\nconst embedPublicKey = async (publicKey, entry) => {\n  if (!publicKey || !publicKey.bytes || !entry) {\n    const error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n  } // Create a peer id from the public key.\n\n\n  let peerId;\n\n  try {\n    peerId = await PeerId.createFromPubKey(publicKey.bytes);\n  } catch (err) {\n    throw errCode(err, ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY);\n  } // Try to extract the public key from the ID. If we can, no need to embed it\n\n\n  let extractedPublicKey;\n\n  try {\n    extractedPublicKey = extractPublicKeyFromId(peerId);\n  } catch (err) {\n    log.error(err);\n    throw errCode(err, ERRORS.ERR_PUBLIC_KEY_FROM_ID);\n  }\n\n  if (extractedPublicKey) {\n    return null;\n  } // If we failed to extract the public key from the peer ID, embed it in the record.\n\n\n  try {\n    entry.pubKey = crypto.keys.marshalPublicKey(publicKey);\n  } catch (err) {\n    log.error(err);\n    throw err;\n  }\n\n  return entry;\n};\n/**\n * Extracts a public key from the passed PeerId, falling\n * back to the pubKey embedded in the ipns record.\n *\n * @param {PeerId} peerId - peer identifier object.\n * @param {IPNSEntry} entry - ipns entry record.\n */\n\n\nconst extractPublicKey = async (peerId, entry) => {\n  if (!entry || !peerId) {\n    const error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n  }\n\n  let pubKey;\n\n  if (entry.pubKey) {\n    try {\n      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    const otherId = await PeerId.createFromPubKey(entry.pubKey);\n\n    if (!otherId.equals(peerId)) {\n      throw errCode(new Error('Embedded public key did not match PeerID'), ERRORS.ERR_INVALID_EMBEDDED_KEY);\n    }\n  } else if (peerId.pubKey) {\n    pubKey = peerId.pubKey;\n  }\n\n  if (pubKey) {\n    return pubKey;\n  }\n\n  throw errCode(new Error('no public key is available'), ERRORS.ERR_UNDEFINED_PARAMETER);\n};\n/**\n * rawStdEncoding with RFC4648\n *\n * @param {Uint8Array} key\n */\n\n\nconst rawStdEncoding = key => base32upper.encode(key).slice(1);\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Uint8Array} key - peer identifier object.\n */\n\n\nconst getLocalKey = key => new Key(`/ipns/${rawStdEncoding(key)}`);\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Uint8Array} pid - peer identifier represented by the multihash of the public key as Uint8Array.\n */\n\n\nconst getIdKeys = pid => {\n  const pkBuffer = uint8ArrayFromString('/pk/');\n  const ipnsBuffer = uint8ArrayFromString('/ipns/');\n  return {\n    routingPubKey: new Key(uint8ArrayConcat([pkBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(uint8ArrayConcat([pkBuffer, pid]))),\n    routingKey: new Key(uint8ArrayConcat([ipnsBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(uint8ArrayConcat([ipnsBuffer, pid])))\n  };\n};\n/**\n * Sign ipns record data\n *\n * @param {PrivateKey} privateKey\n * @param {Uint8Array} value\n * @param {number} validityType\n * @param {Uint8Array} validity\n */\n\n\nconst sign = (privateKey, value, validityType, validity) => {\n  try {\n    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);\n    return privateKey.sign(dataForSignature);\n  } catch (error) {\n    log.error('record signature creation failed');\n    throw errCode(new Error('record signature creation failed: ' + error.message), ERRORS.ERR_SIGNATURE_CREATION);\n  }\n};\n/**\n * Utility for getting the validity type code name of a validity\n *\n * @param {number} validityType\n */\n\n\nconst getValidityType = validityType => {\n  if (validityType.toString() === '0') {\n    return 'EOL';\n  }\n\n  const error = new Error(`unrecognized validity type ${validityType.toString()}`);\n  log.error(error);\n  throw errCode(error, ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n};\n/**\n * Utility for creating the record data for being signed\n *\n * @param {Uint8Array} value\n * @param {number} validityType\n * @param {Uint8Array} validity\n */\n\n\nconst ipnsEntryDataForV1Sig = (value, validityType, validity) => {\n  const validityTypeBuffer = uint8ArrayFromString(getValidityType(validityType));\n  return uint8ArrayConcat([value, validity, validityTypeBuffer]);\n};\n/**\n * Utility for creating the record data for being signed\n *\n * @param {Uint8Array} data\n */\n\n\nconst ipnsEntryDataForV2Sig = data => {\n  const entryData = uint8ArrayFromString('ipns-signature:');\n  return uint8ArrayConcat([entryData, data]);\n};\n/**\n * Utility for extracting the public key from a peer-id\n *\n * @param {PeerId} peerId\n */\n\n\nconst extractPublicKeyFromId = peerId => {\n  const digest = Digest.decode(peerId.id);\n\n  if (digest.code !== ID_MULTIHASH_CODE) {\n    return null;\n  }\n\n  return crypto.keys.unmarshalPublicKey(digest.digest);\n};\n/**\n * @param {IPNSEntry} obj\n */\n\n\nconst marshal = obj => {\n  return ipnsEntryProto.encode({ ...obj,\n    sequence: Long.fromString(obj.sequence.toString()),\n    ttl: obj.ttl == null ? undefined : Long.fromString(obj.ttl.toString())\n  }).finish();\n};\n/**\n * @param {Uint8Array} buf\n * @returns {IPNSEntry}\n */\n\n\nconst unmarshal = buf => {\n  const message = ipnsEntryProto.decode(buf);\n  const object = ipnsEntryProto.toObject(message, {\n    defaults: false,\n    arrays: true,\n    objects: false\n  });\n  return {\n    value: object.value,\n    signature: object.signature,\n    validityType: object.validityType,\n    validity: object.validity,\n    sequence: Object.hasOwnProperty.call(object, 'sequence') ? BigInt(`${object.sequence}`) : 0n,\n    pubKey: object.pubKey,\n    ttl: Object.hasOwnProperty.call(object, 'ttl') ? BigInt(`${object.ttl}`) : undefined,\n    signatureV2: object.signatureV2,\n    data: object.data\n  };\n};\n\nconst validator = {\n  /**\n   * @param {Uint8Array} marshalledData\n   * @param {Uint8Array} key\n   */\n  validate: async (marshalledData, key) => {\n    const receivedEntry = unmarshal(marshalledData);\n    const bufferId = key.slice(IPNS_PREFIX.length);\n    const peerId = PeerId.createFromBytes(bufferId); // extract public key\n\n    const pubKey = await extractPublicKey(peerId, receivedEntry); // Record validation\n\n    await validate(pubKey, receivedEntry);\n  },\n\n  /**\n   * @param {Uint8Array} dataA\n   * @param {Uint8Array} dataB\n   */\n  select: (dataA, dataB) => {\n    const entryA = unmarshal(dataA);\n    const entryB = unmarshal(dataB); // having a newer signature version is better than an older signature version\n\n    if (entryA.signatureV2 && !entryB.signatureV2) {\n      return 0;\n    } else if (entryB.signatureV2 && !entryA.signatureV2) {\n      return 1;\n    } // choose later sequence number\n\n\n    if (entryA.sequence > entryB.sequence) {\n      return 0;\n    } else if (entryA.sequence < entryB.sequence) {\n      return 1;\n    } // choose longer lived record if sequence numbers the same\n\n\n    const entryAValidityDate = parseRFC3339(uint8ArrayToString(entryA.validity));\n    const entryBValidityDate = parseRFC3339(uint8ArrayToString(entryB.validity));\n    return entryBValidityDate.getTime() > entryAValidityDate.getTime() ? 1 : 0;\n  }\n};\nmodule.exports = {\n  // create ipns entry record\n  create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration,\n  // validate ipns entry record\n  validate,\n  // embed public key in the record\n  embedPublicKey,\n  // extract public key from the record\n  extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey,\n  // get keys for routing\n  getIdKeys,\n  // marshal\n  marshal,\n  // unmarshal\n  unmarshal,\n  // validator\n  validator,\n  // namespace\n  namespace,\n  namespaceLength: namespace.length\n};","map":{"version":3,"names":["NanoDate","require","Key","crypto","PeerId","Digest","identity","errCode","base32upper","fromString","uint8ArrayFromString","toString","uint8ArrayToString","concat","uint8ArrayConcat","equals","uint8ArrayEquals","cborg","Long","debug","log","Object","assign","error","IpnsEntry","ipnsEntryProto","parseRFC3339","ERRORS","ID_MULTIHASH_CODE","code","namespace","IPNS_PREFIX","create","privateKey","value","seq","lifetime","expirationDate","Date","now","Number","validityType","ValidityType","EOL","ms","ns","split","lifetimeNs","BigInt","_create","createWithExpiration","expiration","ttlMs","toDate","getTime","ttlNs","getNano","ttl","isoValidity","signatureV1","sign","data","createCborData","sigData","ipnsEntryDataForV2Sig","signatureV2","entry","signature","validity","sequence","Value","Validity","Sequence","TTL","encode","validate","publicKey","dataForSignature","validateCborDataMatchesPbData","ipnsEntryDataForV1Sig","isValid","verify","err","Error","ERR_SIGNATURE_VERIFICATION","validityDate","e","ERR_UNRECOGNIZED_FORMAT","ERR_IPNS_EXPIRED_RECORD","ERR_UNRECOGNIZED_VALIDITY","ERR_INVALID_RECORD_DATA","decode","isInteger","embedPublicKey","bytes","ERR_UNDEFINED_PARAMETER","peerId","createFromPubKey","ERR_PEER_ID_FROM_PUBLIC_KEY","extractedPublicKey","extractPublicKeyFromId","ERR_PUBLIC_KEY_FROM_ID","pubKey","keys","marshalPublicKey","extractPublicKey","unmarshalPublicKey","otherId","ERR_INVALID_EMBEDDED_KEY","rawStdEncoding","key","slice","getLocalKey","getIdKeys","pid","pkBuffer","ipnsBuffer","routingPubKey","pkKey","routingKey","ipnsKey","message","ERR_SIGNATURE_CREATION","getValidityType","validityTypeBuffer","entryData","digest","id","marshal","obj","undefined","finish","unmarshal","buf","object","toObject","defaults","arrays","objects","hasOwnProperty","call","validator","marshalledData","receivedEntry","bufferId","length","createFromBytes","select","dataA","dataB","entryA","entryB","entryAValidityDate","entryBValidityDate","module","exports","namespaceLength"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipns/src/index.js"],"sourcesContent":["'use strict'\n\nconst NanoDate = require('timestamp-nano')\nconst { Key } = require('interface-datastore')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst Digest = require('multiformats/hashes/digest')\nconst { identity } = require('multiformats/hashes/identity')\nconst errCode = require('err-code')\nconst { base32upper } = require('multiformats/bases/base32')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst cborg = require('cborg')\nconst Long = require('long')\n\nconst debug = require('debug')\nconst log = Object.assign(debug('jsipns'), {\n  error: debug('jsipns:error')\n})\n\nconst {\n  IpnsEntry: ipnsEntryProto\n} = require('./pb/ipns.js')\nconst { parseRFC3339 } = require('./utils')\nconst ERRORS = require('./errors')\n\nconst ID_MULTIHASH_CODE = identity.code\n\nconst namespace = '/ipns/'\nconst IPNS_PREFIX = uint8ArrayFromString('/ipns/')\n\n/**\n * @typedef {import('./types').IPNSEntry} IPNSEntry\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n */\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {PrivateKey} privateKey - private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {number} lifetime - lifetime of the record (in milliseconds).\n */\nconst create = (privateKey, value, seq, lifetime) => {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  const expirationDate = new NanoDate(Date.now() + Number(lifetime))\n  const validityType = ipnsEntryProto.ValidityType.EOL\n  const [ms, ns] = lifetime.toString().split('.')\n  const lifetimeNs = BigInt(ms) * 100000n + BigInt(ns || 0)\n\n  return _create(privateKey, value, seq, validityType, expirationDate, lifetimeNs)\n}\n\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n *\n * @param {PrivateKey} privateKey - private key for signing the record.\n * @param {Uint8Array} value - value to be stored in the record.\n * @param {number | bigint} seq - number representing the current version of the record.\n * @param {string} expiration - expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n */\nconst createWithExpiration = (privateKey, value, seq, expiration) => {\n  const expirationDate = NanoDate.fromString(expiration)\n  const validityType = ipnsEntryProto.ValidityType.EOL\n\n  const ttlMs = expirationDate.toDate().getTime() - Date.now()\n  const ttlNs = (BigInt(ttlMs) * 100000n) + BigInt(expirationDate.getNano())\n\n  return _create(privateKey, value, seq, validityType, expirationDate, ttlNs)\n}\n\n/**\n * @param {PrivateKey} privateKey\n * @param {Uint8Array} value\n * @param {number | bigint} seq\n * @param {number} validityType\n * @param {NanoDate} expirationDate\n * @param {bigint} ttl\n * @returns {Promise<IPNSEntry>}\n */\nconst _create = async (privateKey, value, seq, validityType, expirationDate, ttl) => {\n  seq = BigInt(seq)\n  const isoValidity = uint8ArrayFromString(expirationDate.toString())\n  const signatureV1 = await sign(privateKey, value, validityType, isoValidity)\n  const data = createCborData(value, isoValidity, validityType, seq, ttl)\n  const sigData = ipnsEntryDataForV2Sig(data)\n  const signatureV2 = await privateKey.sign(sigData)\n\n  const entry = {\n    value,\n    signature: signatureV1,\n    validityType: validityType,\n    validity: isoValidity,\n    sequence: seq,\n    ttl,\n    signatureV2,\n    data\n  }\n\n  log(`ipns entry for ${value} created`)\n  return entry\n}\n\n/**\n * @param {Uint8Array} value\n * @param {Uint8Array} validity\n * @param {number} validityType\n * @param {bigint} sequence\n * @param {bigint} ttl\n */\nconst createCborData = (value, validity, validityType, sequence, ttl) => {\n  const data = {\n    Value: value,\n    Validity: validity,\n    ValidityType: validityType,\n    Sequence: sequence,\n    TTL: ttl\n  }\n\n  return cborg.encode(data)\n}\n\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {PublicKey} publicKey - public key for validating the record.\n * @param {IPNSEntry} entry - ipns entry record.\n */\nconst validate = async (publicKey, entry) => {\n  const { value, validityType, validity } = entry\n\n  /** @type {Uint8Array} */\n  let dataForSignature\n  let signature\n\n  // Check v2 signature if it's available, otherwise use the v1 signature\n  if (entry.signatureV2 && entry.data) {\n    signature = entry.signatureV2\n    dataForSignature = ipnsEntryDataForV2Sig(entry.data)\n\n    validateCborDataMatchesPbData(entry)\n  } else {\n    signature = entry.signature\n    dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity)\n  }\n\n  // Validate Signature\n  let isValid\n  try {\n    isValid = await publicKey.verify(dataForSignature, signature)\n  } catch (err) {\n    isValid = false\n  }\n  if (!isValid) {\n    log.error('record signature verification failed')\n    throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  // Validate according to the validity type\n  if (validityType === ipnsEntryProto.ValidityType.EOL) {\n    let validityDate\n\n    try {\n      validityDate = parseRFC3339(uint8ArrayToString(validity))\n    } catch (e) {\n      log.error('unrecognized validity format (not an rfc3339 format)')\n      throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT)\n    }\n\n    if (validityDate.getTime() < Date.now()) {\n      log.error('record has expired')\n      throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD)\n    }\n  } else if (validityType) {\n    log.error('unrecognized validity type')\n    throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n  }\n\n  log(`ipns entry for ${value} is valid`)\n}\n\n/**\n * @param {IPNSEntry} entry\n */\nconst validateCborDataMatchesPbData = (entry) => {\n  if (!entry.data) {\n    throw errCode(new Error('Record data is missing'), ERRORS.ERR_INVALID_RECORD_DATA)\n  }\n\n  const data = cborg.decode(entry.data)\n\n  if (Number.isInteger(data.Sequence)) {\n    // sequence must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.Sequence = BigInt(data.Sequence)\n  }\n\n  if (Number.isInteger(data.TTL)) {\n    // ttl must be a BigInt, but DAG-CBOR doesn't preserve this for Numbers within the safe-integer range\n    data.TTL = BigInt(data.TTL)\n  }\n\n  if (!uint8ArrayEquals(data.Value, entry.value)) {\n    throw errCode(new Error('Field \"value\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (!uint8ArrayEquals(data.Validity, entry.validity)) {\n    throw errCode(new Error('Field \"validity\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (data.ValidityType !== entry.validityType) {\n    throw errCode(new Error('Field \"validityType\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (data.Sequence !== entry.sequence) {\n    throw errCode(new Error('Field \"sequence\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  if (data.TTL !== entry.ttl) {\n    throw errCode(new Error('Field \"ttl\" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n}\n\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validate a record upon receipt, they need\n * the public key associated with it. For old RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {PublicKey} publicKey - public key to embed.\n * @param {IPNSEntry} entry - ipns entry record.\n */\nconst embedPublicKey = async (publicKey, entry) => {\n  if (!publicKey || !publicKey.bytes || !entry) {\n    const error = new Error('one or more of the provided parameters are not defined')\n    log.error(error)\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER)\n  }\n\n  // Create a peer id from the public key.\n  let peerId\n  try {\n    peerId = await PeerId.createFromPubKey(publicKey.bytes)\n  } catch (err) {\n    throw errCode(err, ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY)\n  }\n\n  // Try to extract the public key from the ID. If we can, no need to embed it\n  let extractedPublicKey\n  try {\n    extractedPublicKey = extractPublicKeyFromId(peerId)\n  } catch (err) {\n    log.error(err)\n    throw errCode(err, ERRORS.ERR_PUBLIC_KEY_FROM_ID)\n  }\n\n  if (extractedPublicKey) {\n    return null\n  }\n\n  // If we failed to extract the public key from the peer ID, embed it in the record.\n  try {\n    entry.pubKey = crypto.keys.marshalPublicKey(publicKey)\n  } catch (err) {\n    log.error(err)\n    throw err\n  }\n  return entry\n}\n\n/**\n * Extracts a public key from the passed PeerId, falling\n * back to the pubKey embedded in the ipns record.\n *\n * @param {PeerId} peerId - peer identifier object.\n * @param {IPNSEntry} entry - ipns entry record.\n */\nconst extractPublicKey = async (peerId, entry) => {\n  if (!entry || !peerId) {\n    const error = new Error('one or more of the provided parameters are not defined')\n\n    log.error(error)\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER)\n  }\n\n  let pubKey\n\n  if (entry.pubKey) {\n    try {\n      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    const otherId = await PeerId.createFromPubKey(entry.pubKey)\n\n    if (!otherId.equals(peerId)) {\n      throw errCode(new Error('Embedded public key did not match PeerID'), ERRORS.ERR_INVALID_EMBEDDED_KEY)\n    }\n  } else if (peerId.pubKey) {\n    pubKey = peerId.pubKey\n  }\n\n  if (pubKey) {\n    return pubKey\n  }\n\n  throw errCode(new Error('no public key is available'), ERRORS.ERR_UNDEFINED_PARAMETER)\n}\n\n/**\n * rawStdEncoding with RFC4648\n *\n * @param {Uint8Array} key\n */\nconst rawStdEncoding = (key) => base32upper.encode(key).slice(1)\n\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Uint8Array} key - peer identifier object.\n */\nconst getLocalKey = (key) => new Key(`/ipns/${rawStdEncoding(key)}`)\n\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Uint8Array} pid - peer identifier represented by the multihash of the public key as Uint8Array.\n */\nconst getIdKeys = (pid) => {\n  const pkBuffer = uint8ArrayFromString('/pk/')\n  const ipnsBuffer = uint8ArrayFromString('/ipns/')\n\n  return {\n    routingPubKey: new Key(uint8ArrayConcat([pkBuffer, pid]), false), // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(uint8ArrayConcat([pkBuffer, pid]))),\n    routingKey: new Key(uint8ArrayConcat([ipnsBuffer, pid]), false), // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(uint8ArrayConcat([ipnsBuffer, pid])))\n  }\n}\n\n/**\n * Sign ipns record data\n *\n * @param {PrivateKey} privateKey\n * @param {Uint8Array} value\n * @param {number} validityType\n * @param {Uint8Array} validity\n */\nconst sign = (privateKey, value, validityType, validity) => {\n  try {\n    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity)\n\n    return privateKey.sign(dataForSignature)\n  } catch (error) {\n    log.error('record signature creation failed')\n    throw errCode(new Error('record signature creation failed: ' + error.message), ERRORS.ERR_SIGNATURE_CREATION)\n  }\n}\n\n/**\n * Utility for getting the validity type code name of a validity\n *\n * @param {number} validityType\n */\nconst getValidityType = (validityType) => {\n  if (validityType.toString() === '0') {\n    return 'EOL'\n  }\n\n  const error = new Error(`unrecognized validity type ${validityType.toString()}`)\n  log.error(error)\n  throw errCode(error, ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n}\n\n/**\n * Utility for creating the record data for being signed\n *\n * @param {Uint8Array} value\n * @param {number} validityType\n * @param {Uint8Array} validity\n */\nconst ipnsEntryDataForV1Sig = (value, validityType, validity) => {\n  const validityTypeBuffer = uint8ArrayFromString(getValidityType(validityType))\n\n  return uint8ArrayConcat([value, validity, validityTypeBuffer])\n}\n\n/**\n * Utility for creating the record data for being signed\n *\n * @param {Uint8Array} data\n */\nconst ipnsEntryDataForV2Sig = (data) => {\n  const entryData = uint8ArrayFromString('ipns-signature:')\n\n  return uint8ArrayConcat([entryData, data])\n}\n\n/**\n * Utility for extracting the public key from a peer-id\n *\n * @param {PeerId} peerId\n */\nconst extractPublicKeyFromId = (peerId) => {\n  const digest = Digest.decode(peerId.id)\n\n  if (digest.code !== ID_MULTIHASH_CODE) {\n    return null\n  }\n\n  return crypto.keys.unmarshalPublicKey(digest.digest)\n}\n\n/**\n * @param {IPNSEntry} obj\n */\nconst marshal = (obj) => {\n  return ipnsEntryProto.encode({\n    ...obj,\n    sequence: Long.fromString(obj.sequence.toString()),\n    ttl: obj.ttl == null ? undefined : Long.fromString(obj.ttl.toString())\n  }).finish()\n}\n\n/**\n * @param {Uint8Array} buf\n * @returns {IPNSEntry}\n */\nconst unmarshal = (buf) => {\n  const message = ipnsEntryProto.decode(buf)\n  const object = ipnsEntryProto.toObject(message, {\n    defaults: false,\n    arrays: true,\n    objects: false\n  })\n\n  return {\n    value: object.value,\n    signature: object.signature,\n    validityType: object.validityType,\n    validity: object.validity,\n    sequence: Object.hasOwnProperty.call(object, 'sequence') ? BigInt(`${object.sequence}`) : 0n,\n    pubKey: object.pubKey,\n    ttl: Object.hasOwnProperty.call(object, 'ttl') ? BigInt(`${object.ttl}`) : undefined,\n    signatureV2: object.signatureV2,\n    data: object.data\n  }\n}\n\nconst validator = {\n  /**\n   * @param {Uint8Array} marshalledData\n   * @param {Uint8Array} key\n   */\n  validate: async (marshalledData, key) => {\n    const receivedEntry = unmarshal(marshalledData)\n    const bufferId = key.slice(IPNS_PREFIX.length)\n    const peerId = PeerId.createFromBytes(bufferId)\n\n    // extract public key\n    const pubKey = await extractPublicKey(peerId, receivedEntry)\n\n    // Record validation\n    await validate(pubKey, receivedEntry)\n  },\n\n  /**\n   * @param {Uint8Array} dataA\n   * @param {Uint8Array} dataB\n   */\n  select: (dataA, dataB) => {\n    const entryA = unmarshal(dataA)\n    const entryB = unmarshal(dataB)\n\n    // having a newer signature version is better than an older signature version\n    if (entryA.signatureV2 && !entryB.signatureV2) {\n      return 0\n    } else if (entryB.signatureV2 && !entryA.signatureV2) {\n      return 1\n    }\n\n    // choose later sequence number\n    if (entryA.sequence > entryB.sequence) {\n      return 0\n    } else if (entryA.sequence < entryB.sequence) {\n      return 1\n    }\n\n    // choose longer lived record if sequence numbers the same\n    const entryAValidityDate = parseRFC3339(uint8ArrayToString(entryA.validity))\n    const entryBValidityDate = parseRFC3339(uint8ArrayToString(entryB.validity))\n\n    return entryBValidityDate.getTime() > entryAValidityDate.getTime() ? 1 : 0\n  }\n}\n\nmodule.exports = {\n  // create ipns entry record\n  create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration,\n  // validate ipns entry record\n  validate,\n  // embed public key in the record\n  embedPublicKey,\n  // extract public key from the record\n  extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey,\n  // get keys for routing\n  getIdKeys,\n  // marshal\n  marshal,\n  // unmarshal\n  unmarshal,\n  // validator\n  validator,\n  // namespace\n  namespace,\n  namespaceLength: namespace.length\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}