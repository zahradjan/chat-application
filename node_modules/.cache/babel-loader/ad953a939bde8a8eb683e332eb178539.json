{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar loadMfsRoot = require('./with-mfs-root');\n\nvar toPathComponents = require('./to-path-components');\n\nvar _require = require('ipfs-unixfs-exporter'),\n    exporter = _require.exporter;\n\nvar errCode = require('err-code');\n\nvar _require2 = require('multiformats/cid'),\n    CID = _require2.CID;\n\nvar IPFS_PREFIX = 'ipfs';\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n * @typedef {import('ipfs-unixfs-exporter').ExporterOptions} ExporterOptions\n * @typedef {import('../').MfsContext} MfsContext\n *\n * @typedef {object} FilePath\n * @property {'mfs' | 'ipfs'} type\n * @property {'file'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} DirectoryPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'directory'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<UnixFSEntry>} content\n *\n * @typedef {object} ObjectPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'object'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<any>} content\n *\n * @typedef {object} RawPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'raw'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} IdentityPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'identity'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {FilePath | DirectoryPath | ObjectPath | RawPath | IdentityPath} MfsPath\n */\n\n/**\n * @param {MfsContext} context\n * @param {string | CID} path\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\n\nvar toMfsPath = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(context, path, options) {\n    var root, output, ipfsPath, pathComponents, mfsDirectory, mfsPath, _mfsDirectory, cidPath, res;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return loadMfsRoot(context, options);\n\n          case 2:\n            root = _context.sent;\n\n            /** @type {MfsPath} */\n            // @ts-ignore fields get set later\n            output = {\n              entryType: 'file'\n            };\n            ipfsPath = '';\n\n            if (CID.asCID(path)) {\n              ipfsPath = \"/ipfs/\".concat(path);\n            } else {\n              ipfsPath = path.toString();\n            }\n\n            ipfsPath = ipfsPath.trim();\n            ipfsPath = ipfsPath.replace(/(\\/\\/+)/g, '/');\n\n            if (ipfsPath.endsWith('/') && ipfsPath.length > 1) {\n              ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n            }\n\n            if (ipfsPath) {\n              _context.next = 11;\n              break;\n            }\n\n            throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH');\n\n          case 11:\n            if (!(ipfsPath.substring(0, 1) !== '/')) {\n              _context.next = 13;\n              break;\n            }\n\n            throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n\n          case 13:\n            if (ipfsPath.substring(ipfsPath.length - 1) === '/') {\n              ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);\n            }\n\n            pathComponents = toPathComponents(ipfsPath);\n\n            if (pathComponents[0] === IPFS_PREFIX) {\n              // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n              if (pathComponents.length === 2) {\n                mfsDirectory = \"/\".concat(pathComponents.join('/'));\n              } else {\n                mfsDirectory = \"/\".concat(pathComponents.slice(0, pathComponents.length - 1).join('/'));\n              } // @ts-ignore fields being set\n\n\n              output = {\n                type: 'ipfs',\n                depth: pathComponents.length - 2,\n                entryType: 'file',\n                mfsPath: \"/\".concat(pathComponents.join('/')),\n                mfsDirectory: mfsDirectory,\n                parts: pathComponents,\n                path: \"/\".concat(pathComponents.join('/')),\n                name: pathComponents[pathComponents.length - 1]\n              };\n            } else {\n              mfsPath = \"/\".concat(IPFS_PREFIX, \"/\").concat(root).concat(pathComponents.length ? '/' + pathComponents.join('/') : '');\n              _mfsDirectory = \"/\".concat(IPFS_PREFIX, \"/\").concat(root, \"/\").concat(pathComponents.slice(0, pathComponents.length - 1).join('/')); // @ts-ignore fields being set\n\n              output = {\n                type: 'mfs',\n                depth: pathComponents.length,\n                entryType: 'file',\n                mfsDirectory: _mfsDirectory,\n                mfsPath: mfsPath,\n                parts: pathComponents,\n                path: \"/\".concat(pathComponents.join('/')),\n                name: pathComponents[pathComponents.length - 1]\n              };\n            }\n\n            cidPath = output.type === 'mfs' ? output.mfsPath : output.path;\n            _context.prev = 17;\n            _context.next = 20;\n            return exporter(cidPath, context.repo.blocks, options);\n\n          case 20:\n            res = _context.sent;\n            output.cid = res.cid;\n            output.mfsPath = \"/ipfs/\".concat(res.path);\n            output.entryType = res.type;\n            output.content = res.content;\n\n            if ((output.entryType === 'file' || output.entryType === 'directory') && (res.type === 'file' || res.type === 'directory')) {\n              output.unixfs = res.unixfs;\n            }\n\n            _context.next = 32;\n            break;\n\n          case 28:\n            _context.prev = 28;\n            _context.t0 = _context[\"catch\"](17);\n\n            if (!(_context.t0.code !== 'ERR_NOT_FOUND')) {\n              _context.next = 32;\n              break;\n            }\n\n            throw _context.t0;\n\n          case 32:\n            output.exists = Boolean(output.cid);\n            return _context.abrupt(\"return\", output);\n\n          case 34:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[17, 28]]);\n  }));\n\n  return function toMfsPath(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = toMfsPath;","map":{"version":3,"names":["loadMfsRoot","require","toPathComponents","exporter","errCode","CID","IPFS_PREFIX","toMfsPath","context","path","options","root","output","entryType","ipfsPath","asCID","toString","trim","replace","endsWith","length","substring","Error","pathComponents","mfsDirectory","join","slice","type","depth","mfsPath","parts","name","cidPath","repo","blocks","res","cid","content","unixfs","code","exists","Boolean","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/utils/to-mfs-path.js"],"sourcesContent":["'use strict'\n\nconst loadMfsRoot = require('./with-mfs-root')\nconst toPathComponents = require('./to-path-components')\nconst { exporter } = require('ipfs-unixfs-exporter')\nconst errCode = require('err-code')\nconst { CID } = require('multiformats/cid')\n\nconst IPFS_PREFIX = 'ipfs'\n\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n * @typedef {import('ipfs-unixfs-exporter').ExporterOptions} ExporterOptions\n * @typedef {import('../').MfsContext} MfsContext\n *\n * @typedef {object} FilePath\n * @property {'mfs' | 'ipfs'} type\n * @property {'file'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} DirectoryPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'directory'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {import('ipfs-unixfs').UnixFS} unixfs\n * @property {(options?: ExporterOptions) => AsyncIterable<UnixFSEntry>} content\n *\n * @typedef {object} ObjectPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'object'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<any>} content\n *\n * @typedef {object} RawPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'raw'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {object} IdentityPath\n * @property {'mfs' | 'ipfs'} type\n * @property {'identity'} entryType\n * @property {number} depth\n * @property {string} mfsPath\n * @property {string} mfsDirectory\n * @property {string[]} parts\n * @property {string} path\n * @property {string} name\n * @property {CID} cid\n * @property {boolean} exists\n * @property {(options?: ExporterOptions) => AsyncIterable<Uint8Array>} content\n *\n * @typedef {FilePath | DirectoryPath | ObjectPath | RawPath | IdentityPath} MfsPath\n */\n\n/**\n * @param {MfsContext} context\n * @param {string | CID} path\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\nconst toMfsPath = async (context, path, options) => {\n  const root = await loadMfsRoot(context, options)\n\n  /** @type {MfsPath} */\n  // @ts-ignore fields get set later\n  let output = {\n    entryType: 'file'\n  }\n\n  let ipfsPath = ''\n\n  if (CID.asCID(path)) {\n    ipfsPath = `/ipfs/${path}`\n  } else {\n    ipfsPath = path.toString()\n  }\n\n  ipfsPath = ipfsPath.trim()\n  ipfsPath = ipfsPath.replace(/(\\/\\/+)/g, '/')\n\n  if (ipfsPath.endsWith('/') && ipfsPath.length > 1) {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1)\n  }\n\n  if (!ipfsPath) {\n    throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH')\n  }\n\n  if (ipfsPath.substring(0, 1) !== '/') {\n    throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n  }\n\n  if (ipfsPath.substring(ipfsPath.length - 1) === '/') {\n    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1)\n  }\n\n  const pathComponents = toPathComponents(ipfsPath)\n\n  if (pathComponents[0] === IPFS_PREFIX) {\n    // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n    let mfsDirectory\n\n    if (pathComponents.length === 2) {\n      mfsDirectory = `/${pathComponents.join('/')}`\n    } else {\n      mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n    }\n\n    // @ts-ignore fields being set\n    output = {\n      type: 'ipfs',\n      depth: pathComponents.length - 2,\n      entryType: 'file',\n\n      mfsPath: `/${pathComponents.join('/')}`,\n      mfsDirectory,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    }\n  } else {\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n\n    // @ts-ignore fields being set\n    output = {\n      type: 'mfs',\n      depth: pathComponents.length,\n      entryType: 'file',\n\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    }\n  }\n\n  const cidPath = output.type === 'mfs' ? output.mfsPath : output.path\n\n  try {\n    const res = await exporter(cidPath, context.repo.blocks, options)\n\n    output.cid = res.cid\n    output.mfsPath = `/ipfs/${res.path}`\n    output.entryType = res.type\n    output.content = res.content\n\n    if ((output.entryType === 'file' || output.entryType === 'directory') && (res.type === 'file' || res.type === 'directory')) {\n      output.unixfs = res.unixfs\n    }\n  } catch (err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err\n    }\n  }\n\n  output.exists = Boolean(output.cid)\n\n  return output\n}\n\nmodule.exports = toMfsPath\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}