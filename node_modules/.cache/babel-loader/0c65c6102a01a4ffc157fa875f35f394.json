{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar path = require('path');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar mapSeries = require('p-each-series');\n\nvar _require = require('p-queue'),\n    PQueue = _require.default;\n\nvar Log = require('ipfs-log');\n\nvar Entry = Log.Entry;\n\nvar Index = require('./Index');\n\nvar Replicator = require('./Replicator');\n\nvar ReplicationInfo = require('./replication-info');\n\nvar Logger = require('logplease');\n\nvar logger = Logger.create('orbit-db.store', {\n  color: Logger.Colors.Blue\n});\nLogger.setLogLevel('ERROR');\n\nvar io = require('orbit-db-io');\n\nvar DefaultOptions = {\n  Index: Index,\n  maxHistory: -1,\n  fetchEntryTimeout: null,\n  referenceCount: 32,\n  replicationConcurrency: 32,\n  syncLocal: false,\n  sortFn: undefined\n};\n\nvar Store = /*#__PURE__*/function () {\n  function Store(ipfs, identity, address, options) {\n    var _this = this;\n\n    _classCallCheck(this, Store);\n\n    if (!identity) {\n      throw new Error('Identity required');\n    } // Set the options\n\n\n    var opts = Object.assign({}, DefaultOptions);\n    Object.assign(opts, options);\n    this.options = opts; // Default type\n\n    this._type = 'store'; // Create IDs, names and paths\n\n    this.id = address.toString();\n    this.identity = identity;\n    this.address = address;\n    this.dbname = address.path || '';\n    this.events = new EventEmitter();\n    this.remoteHeadsPath = path.join(this.id, '_remoteHeads');\n    this.localHeadsPath = path.join(this.id, '_localHeads');\n    this.snapshotPath = path.join(this.id, 'snapshot');\n    this.queuePath = path.join(this.id, 'queue');\n    this.manifestPath = path.join(this.id, '_manifest'); // External dependencies\n\n    this._ipfs = ipfs;\n    this._cache = options.cache; // Access mapping\n\n    var defaultAccess = {\n      canAppend: function canAppend(entry) {\n        return entry.identity.publicKey === identity.publicKey;\n      }\n    };\n    this.access = options.accessController || defaultAccess; // Create the operations log\n\n    this._oplog = new Log(this._ipfs, this.identity, {\n      logId: this.id,\n      access: this.access,\n      sortFn: this.options.sortFn\n    }); // _addOperation and log-joins queue. Adding ops and joins to the queue\n    // makes sure they get processed sequentially to avoid race conditions\n    // between writes and joins (coming from Replicator)\n\n    this._queue = new PQueue({\n      concurrency: 1\n    }); // Create the index\n\n    this._index = new this.options.Index(this.address.root); // Replication progress info\n\n    this._replicationStatus = new ReplicationInfo(); // Statistics\n\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    };\n\n    try {\n      var onReplicationQueued = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(entry) {\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  // Update the latest entry state (latest is the entry with largest clock time)\n                  _this._recalculateReplicationMax(entry.clock ? entry.clock.time : 0);\n\n                  _this.events.emit('replicate', _this.address.toString(), entry);\n\n                case 2:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        return function onReplicationQueued(_x) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      var onReplicationProgress = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(entry) {\n          var previousProgress, previousMax;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  previousProgress = _this.replicationStatus.progress;\n                  previousMax = _this.replicationStatus.max;\n\n                  _this._recalculateReplicationStatus(entry.clock.time);\n\n                  if (_this._oplog.length + 1 > _this.replicationStatus.progress || _this.replicationStatus.progress > previousProgress || _this.replicationStatus.max > previousMax) {\n                    _this.events.emit('replicate.progress', _this.address.toString(), entry.hash, entry, _this.replicationStatus.progress, _this.replicationStatus.max);\n                  }\n\n                case 4:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function onReplicationProgress(_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      var onReplicationComplete = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(logs) {\n          var updateState;\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  updateState = /*#__PURE__*/function () {\n                    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                      var _iterator2, _step2, log, heads;\n\n                      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                        while (1) {\n                          switch (_context3.prev = _context3.next) {\n                            case 0:\n                              _context3.prev = 0;\n\n                              if (!(_this._oplog && logs.length > 0)) {\n                                _context3.next = 27;\n                                break;\n                              }\n\n                              _iterator2 = _createForOfIteratorHelper(logs);\n                              _context3.prev = 3;\n\n                              _iterator2.s();\n\n                            case 5:\n                              if ((_step2 = _iterator2.n()).done) {\n                                _context3.next = 11;\n                                break;\n                              }\n\n                              log = _step2.value;\n                              _context3.next = 9;\n                              return _this._oplog.join(log);\n\n                            case 9:\n                              _context3.next = 5;\n                              break;\n\n                            case 11:\n                              _context3.next = 16;\n                              break;\n\n                            case 13:\n                              _context3.prev = 13;\n                              _context3.t0 = _context3[\"catch\"](3);\n\n                              _iterator2.e(_context3.t0);\n\n                            case 16:\n                              _context3.prev = 16;\n\n                              _iterator2.f();\n\n                              return _context3.finish(16);\n\n                            case 19:\n                              // only store heads that has been verified and merges\n                              heads = _this._oplog.heads;\n                              _context3.next = 22;\n                              return _this._cache.set(_this.remoteHeadsPath, heads);\n\n                            case 22:\n                              logger.debug(\"Saved heads \".concat(heads.length, \" [\").concat(heads.map(function (e) {\n                                return e.hash;\n                              }).join(', '), \"]\")); // update the store's index after joining the logs\n                              // and persisting the latest heads\n\n                              _context3.next = 25;\n                              return _this._updateIndex();\n\n                            case 25:\n                              if (_this._oplog.length > _this.replicationStatus.progress) {\n                                _this._recalculateReplicationStatus(_this._oplog.length);\n                              }\n\n                              _this.events.emit('replicated', _this.address.toString(), logs.length, _this);\n\n                            case 27:\n                              _context3.next = 32;\n                              break;\n\n                            case 29:\n                              _context3.prev = 29;\n                              _context3.t1 = _context3[\"catch\"](0);\n                              console.error(_context3.t1);\n\n                            case 32:\n                            case \"end\":\n                              return _context3.stop();\n                          }\n                        }\n                      }, _callee3, null, [[0, 29], [3, 13, 16, 19]]);\n                    }));\n\n                    return function updateState() {\n                      return _ref4.apply(this, arguments);\n                    };\n                  }();\n\n                  _context4.next = 3;\n                  return _this._queue.add(updateState.bind(_this));\n\n                case 3:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4);\n        }));\n\n        return function onReplicationComplete(_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }(); // Create the replicator\n\n\n      this._replicator = new Replicator(this, this.options.replicationConcurrency); // For internal backwards compatibility,\n      // to be removed in future releases\n\n      this._loader = this._replicator; // Hook up the callbacks to the Replicator\n\n      this._replicator.onReplicationQueued = onReplicationQueued;\n      this._replicator.onReplicationProgress = onReplicationProgress;\n      this._replicator.onReplicationComplete = onReplicationComplete;\n    } catch (e) {\n      console.error('Store Error:', e);\n    } // TODO: verify if this is working since we don't seem to emit \"replicated.progress\" anywhere\n\n\n    this.events.on('replicated.progress', function (address, hash, entry, progress, have) {\n      _this._procEntry(entry);\n    });\n    this.events.on('write', function (address, entry, heads) {\n      _this._procEntry(entry);\n    });\n  }\n\n  _createClass(Store, [{\n    key: \"all\",\n    get: function get() {\n      var _this2 = this;\n\n      return Array.isArray(this._index._index) ? this._index._index : Object.keys(this._index._index).map(function (e) {\n        return _this2._index._index[e];\n      });\n    }\n  }, {\n    key: \"index\",\n    get: function get() {\n      return this._index._index;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"key\",\n    get: function get() {\n      return this._key;\n    }\n    /**\n     * Returns the database's current replication status information\n     * @return {[Object]} [description]\n     */\n\n  }, {\n    key: \"replicationStatus\",\n    get: function get() {\n      return this._replicationStatus;\n    }\n  }, {\n    key: \"setIdentity\",\n    value: function setIdentity(identity) {\n      this.identity = identity;\n\n      this._oplog.setIdentity(identity);\n    }\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var event;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._replicator.stop();\n\n              case 2:\n                _context5.next = 4;\n                return this._queue.onIdle();\n\n              case 4:\n                // Reset replication statistics\n                this._replicationStatus.reset(); // Reset database statistics\n\n\n                this._stats = {\n                  snapshot: {\n                    bytesLoaded: -1\n                  },\n                  syncRequestsReceieved: 0\n                };\n\n                if (!this.options.onClose) {\n                  _context5.next = 9;\n                  break;\n                }\n\n                _context5.next = 9;\n                return this.options.onClose(this);\n\n              case 9:\n                if (!this.access.close) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                _context5.next = 12;\n                return this.access.close();\n\n              case 12:\n                // Remove all event listeners\n                for (event in this.events._events) {\n                  this.events.removeAllListeners(event);\n                }\n\n                this._oplog = null; // Database is now closed\n                // TODO: afaik we don't use 'closed' event anymore,\n                // to be removed in future releases\n\n                this.events.emit('closed', this.address.toString());\n                return _context5.abrupt(\"return\", Promise.resolve());\n\n              case 16:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Drops a database and removes local data\n     * @return {[None]}\n     */\n\n  }, {\n    key: \"drop\",\n    value: function () {\n      var _drop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!this.options.onDrop) {\n                  _context6.next = 3;\n                  break;\n                }\n\n                _context6.next = 3;\n                return this.options.onDrop(this);\n\n              case 3:\n                _context6.next = 5;\n                return this._cache.del(this.localHeadsPath);\n\n              case 5:\n                _context6.next = 7;\n                return this._cache.del(this.remoteHeadsPath);\n\n              case 7:\n                _context6.next = 9;\n                return this._cache.del(this.snapshotPath);\n\n              case 9:\n                _context6.next = 11;\n                return this._cache.del(this.queuePath);\n\n              case 11:\n                _context6.next = 13;\n                return this._cache.del(this.manifestPath);\n\n              case 13:\n                _context6.next = 15;\n                return this.close();\n\n              case 15:\n                // Reset\n                this._index = new this.options.Index(this.address.root);\n                this._oplog = new Log(this._ipfs, this.identity, {\n                  logId: this.id,\n                  access: this.access,\n                  sortFn: this.options.sortFn\n                });\n                this._cache = this.options.cache;\n\n              case 18:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function drop() {\n        return _drop.apply(this, arguments);\n      }\n\n      return drop;\n    }()\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(amount) {\n        var _this3 = this;\n\n        var opts,\n            fetchEntryTimeout,\n            localHeads,\n            remoteHeads,\n            heads,\n            log,\n            _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                opts = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n\n                if (typeof amount === 'object') {\n                  opts = amount;\n                  amount = undefined;\n                }\n\n                amount = amount || this.options.maxHistory;\n                fetchEntryTimeout = opts.fetchEntryTimeout || this.options.fetchEntryTimeout;\n\n                if (!this.options.onLoad) {\n                  _context7.next = 7;\n                  break;\n                }\n\n                _context7.next = 7;\n                return this.options.onLoad(this);\n\n              case 7:\n                _context7.next = 9;\n                return this._cache.get(this.localHeadsPath);\n\n              case 9:\n                _context7.t0 = _context7.sent;\n\n                if (_context7.t0) {\n                  _context7.next = 12;\n                  break;\n                }\n\n                _context7.t0 = [];\n\n              case 12:\n                localHeads = _context7.t0;\n                _context7.next = 15;\n                return this._cache.get(this.remoteHeadsPath);\n\n              case 15:\n                _context7.t1 = _context7.sent;\n\n                if (_context7.t1) {\n                  _context7.next = 18;\n                  break;\n                }\n\n                _context7.t1 = [];\n\n              case 18:\n                remoteHeads = _context7.t1;\n                heads = localHeads.concat(remoteHeads);\n\n                if (heads.length > 0) {\n                  this.events.emit('load', this.address.toString(), heads);\n                } // Update the replication status from the heads\n\n\n                heads.forEach(function (h) {\n                  return _this3._recalculateReplicationMax(h.clock.time);\n                }); // Load the log\n\n                _context7.next = 24;\n                return Log.fromEntryHash(this._ipfs, this.identity, heads.map(function (e) {\n                  return e.hash;\n                }), {\n                  logId: this.id,\n                  access: this.access,\n                  sortFn: this.options.sortFn,\n                  length: amount,\n                  onProgressCallback: this._onLoadProgress.bind(this),\n                  timeout: fetchEntryTimeout,\n                  concurrency: this.options.replicationConcurrency\n                });\n\n              case 24:\n                log = _context7.sent;\n                this._oplog = log; // Update the index\n\n                if (!(heads.length > 0)) {\n                  _context7.next = 29;\n                  break;\n                }\n\n                _context7.next = 29;\n                return this._updateIndex();\n\n              case 29:\n                this.events.emit('ready', this.address.toString(), this._oplog.heads);\n\n              case 30:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function load(_x4) {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }, {\n    key: \"sync\",\n    value: function () {\n      var _sync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(heads) {\n        var _this4 = this;\n\n        var saveToIpfs;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this._stats.syncRequestsReceieved += 1;\n                logger.debug(\"Sync request #\".concat(this._stats.syncRequestsReceieved, \" \").concat(heads.length));\n\n                if (!(heads.length === 0)) {\n                  _context10.next = 4;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\");\n\n              case 4:\n                // To simulate network latency, uncomment this line\n                // and comment out the rest of the function\n                // That way the object (received as head message from pubsub)\n                // doesn't get written to IPFS and so when the Replicator is fetching\n                // the log, it'll fetch it from the network instead from the disk.\n                // return this._replicator.load(heads)\n                saveToIpfs = /*#__PURE__*/function () {\n                  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(head) {\n                    var identityProvider, canAppend, logEntry, hash;\n                    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n                      while (1) {\n                        switch (_context8.prev = _context8.next) {\n                          case 0:\n                            if (head) {\n                              _context8.next = 3;\n                              break;\n                            }\n\n                            console.warn(\"Warning: Given input entry was 'null'.\");\n                            return _context8.abrupt(\"return\", Promise.resolve(null));\n\n                          case 3:\n                            identityProvider = _this4.identity.provider;\n\n                            if (identityProvider) {\n                              _context8.next = 6;\n                              break;\n                            }\n\n                            throw new Error('Identity-provider is required, cannot verify entry');\n\n                          case 6:\n                            _context8.next = 8;\n                            return _this4.access.canAppend(head, identityProvider);\n\n                          case 8:\n                            canAppend = _context8.sent;\n\n                            if (canAppend) {\n                              _context8.next = 12;\n                              break;\n                            }\n\n                            console.warn('Warning: Given input entry is not allowed in this log and was discarded (no write access).');\n                            return _context8.abrupt(\"return\", Promise.resolve(null));\n\n                          case 12:\n                            logEntry = Entry.toEntry(head);\n                            _context8.next = 15;\n                            return io.write(_this4._ipfs, Entry.getWriteFormat(logEntry), logEntry, {\n                              links: Entry.IPLD_LINKS,\n                              onlyHash: true\n                            });\n\n                          case 15:\n                            hash = _context8.sent;\n\n                            if (hash !== head.hash) {\n                              console.warn('\"WARNING! Head hash didn\\'t match the contents');\n                            }\n\n                            return _context8.abrupt(\"return\", head);\n\n                          case 18:\n                          case \"end\":\n                            return _context8.stop();\n                        }\n                      }\n                    }, _callee8);\n                  }));\n\n                  return function saveToIpfs(_x6) {\n                    return _ref5.apply(this, arguments);\n                  };\n                }();\n\n                return _context10.abrupt(\"return\", mapSeries(heads, saveToIpfs).then( /*#__PURE__*/function () {\n                  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(saved) {\n                    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                      while (1) {\n                        switch (_context9.prev = _context9.next) {\n                          case 0:\n                            return _context9.abrupt(\"return\", _this4._replicator.load(saved.filter(function (e) {\n                              return e !== null;\n                            })));\n\n                          case 1:\n                          case \"end\":\n                            return _context9.stop();\n                        }\n                      }\n                    }, _callee9);\n                  }));\n\n                  return function (_x7) {\n                    return _ref6.apply(this, arguments);\n                  };\n                }()));\n\n              case 6:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function sync(_x5) {\n        return _sync.apply(this, arguments);\n      }\n\n      return sync;\n    }()\n  }, {\n    key: \"loadMoreFrom\",\n    value: function loadMoreFrom(amount, entries) {\n      this._replicator.load(entries);\n    }\n  }, {\n    key: \"saveSnapshot\",\n    value: function () {\n      var _saveSnapshot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var unfinished, snapshotData, buf, snapshot;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                unfinished = this._replicator.unfinished;\n                snapshotData = this._oplog.toSnapshot();\n                buf = Buffer.from(JSON.stringify({\n                  id: snapshotData.id,\n                  heads: snapshotData.heads,\n                  size: snapshotData.values.length,\n                  values: snapshotData.values,\n                  type: this.type\n                }));\n                _context11.next = 5;\n                return this._ipfs.add(buf);\n\n              case 5:\n                snapshot = _context11.sent;\n                snapshot.hash = snapshot.cid.toString(); // js-ipfs >= 0.41, ipfs.add results contain a cid property (a CID instance) instead of a string hash property\n\n                _context11.next = 9;\n                return this._cache.set(this.snapshotPath, snapshot);\n\n              case 9:\n                _context11.next = 11;\n                return this._cache.set(this.queuePath, unfinished);\n\n              case 11:\n                logger.debug(\"Saved snapshot: \".concat(snapshot.hash, \", queue length: \").concat(unfinished.length));\n                return _context11.abrupt(\"return\", [snapshot]);\n\n              case 13:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function saveSnapshot() {\n        return _saveSnapshot.apply(this, arguments);\n      }\n\n      return saveSnapshot;\n    }()\n  }, {\n    key: \"loadFromSnapshot\",\n    value: function () {\n      var _loadFromSnapshot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(onProgressCallback) {\n        var maxClock, queue, snapshot, chunks, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk, buffer, snapshotData;\n\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (!this.options.onLoad) {\n                  _context12.next = 3;\n                  break;\n                }\n\n                _context12.next = 3;\n                return this.options.onLoad(this);\n\n              case 3:\n                this.events.emit('load', this.address.toString()); // TODO emits inconsistent params, missing heads param\n\n                maxClock = function maxClock(res, val) {\n                  return Math.max(res, val.clock.time);\n                };\n\n                _context12.next = 7;\n                return this._cache.get(this.queuePath);\n\n              case 7:\n                queue = _context12.sent;\n                this.sync(queue || []);\n                _context12.next = 11;\n                return this._cache.get(this.snapshotPath);\n\n              case 11:\n                snapshot = _context12.sent;\n\n                if (!snapshot) {\n                  _context12.next = 55;\n                  break;\n                }\n\n                chunks = [];\n                _iteratorAbruptCompletion = false;\n                _didIteratorError = false;\n                _context12.prev = 16;\n                _iterator = _asyncIterator(this._ipfs.cat(snapshot.hash));\n\n              case 18:\n                _context12.next = 20;\n                return _iterator.next();\n\n              case 20:\n                if (!(_iteratorAbruptCompletion = !(_step = _context12.sent).done)) {\n                  _context12.next = 26;\n                  break;\n                }\n\n                chunk = _step.value;\n                chunks.push(chunk);\n\n              case 23:\n                _iteratorAbruptCompletion = false;\n                _context12.next = 18;\n                break;\n\n              case 26:\n                _context12.next = 32;\n                break;\n\n              case 28:\n                _context12.prev = 28;\n                _context12.t0 = _context12[\"catch\"](16);\n                _didIteratorError = true;\n                _iteratorError = _context12.t0;\n\n              case 32:\n                _context12.prev = 32;\n                _context12.prev = 33;\n\n                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                  _context12.next = 37;\n                  break;\n                }\n\n                _context12.next = 37;\n                return _iterator.return();\n\n              case 37:\n                _context12.prev = 37;\n\n                if (!_didIteratorError) {\n                  _context12.next = 40;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 40:\n                return _context12.finish(37);\n\n              case 41:\n                return _context12.finish(32);\n\n              case 42:\n                buffer = Buffer.concat(chunks);\n                snapshotData = JSON.parse(buffer.toString()); // Fetch the entries\n                // Timeout 1 sec to only load entries that are already fetched (in order to not get stuck at loading)\n\n                this._recalculateReplicationMax(snapshotData.values.reduce(maxClock, 0));\n\n                if (!snapshotData) {\n                  _context12.next = 52;\n                  break;\n                }\n\n                _context12.next = 48;\n                return Log.fromJSON(this._ipfs, this.identity, snapshotData, {\n                  access: this.access,\n                  sortFn: this.options.sortFn,\n                  length: -1,\n                  timeout: 1000,\n                  onProgressCallback: this._onLoadProgress.bind(this)\n                });\n\n              case 48:\n                this._oplog = _context12.sent;\n                _context12.next = 51;\n                return this._updateIndex();\n\n              case 51:\n                this.events.emit('replicated', this.address.toString()); // TODO: inconsistent params, count param not emited\n\n              case 52:\n                this.events.emit('ready', this.address.toString(), this._oplog.heads);\n                _context12.next = 56;\n                break;\n\n              case 55:\n                throw new Error(\"Snapshot for \".concat(this.address, \" not found!\"));\n\n              case 56:\n                return _context12.abrupt(\"return\", this);\n\n              case 57:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[16, 28, 32, 42], [33,, 37, 41]]);\n      }));\n\n      function loadFromSnapshot(_x8) {\n        return _loadFromSnapshot.apply(this, arguments);\n      }\n\n      return loadFromSnapshot;\n    }()\n  }, {\n    key: \"_updateIndex\",\n    value: function () {\n      var _updateIndex2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this._index.updateIndex(this._oplog);\n\n              case 2:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function _updateIndex() {\n        return _updateIndex2.apply(this, arguments);\n      }\n\n      return _updateIndex;\n    }()\n  }, {\n    key: \"syncLocal\",\n    value: function () {\n      var _syncLocal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var localHeads, remoteHeads, heads, i, head;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this._cache.get(this.localHeadsPath);\n\n              case 2:\n                _context14.t0 = _context14.sent;\n\n                if (_context14.t0) {\n                  _context14.next = 5;\n                  break;\n                }\n\n                _context14.t0 = [];\n\n              case 5:\n                localHeads = _context14.t0;\n                _context14.next = 8;\n                return this._cache.get(this.remoteHeadsPath);\n\n              case 8:\n                _context14.t1 = _context14.sent;\n\n                if (_context14.t1) {\n                  _context14.next = 11;\n                  break;\n                }\n\n                _context14.t1 = [];\n\n              case 11:\n                remoteHeads = _context14.t1;\n                heads = localHeads.concat(remoteHeads);\n                i = 0;\n\n              case 14:\n                if (!(i < heads.length)) {\n                  _context14.next = 23;\n                  break;\n                }\n\n                head = heads[i];\n\n                if (this._oplog.heads.includes(head)) {\n                  _context14.next = 20;\n                  break;\n                }\n\n                _context14.next = 19;\n                return this.load();\n\n              case 19:\n                return _context14.abrupt(\"break\", 23);\n\n              case 20:\n                i++;\n                _context14.next = 14;\n                break;\n\n              case 23:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function syncLocal() {\n        return _syncLocal.apply(this, arguments);\n      }\n\n      return syncLocal;\n    }()\n  }, {\n    key: \"_addOperation\",\n    value: function () {\n      var _addOperation2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(data) {\n        var _ref7,\n            onProgressCallback,\n            _ref7$pin,\n            pin,\n            addOperation,\n            _addOperation3,\n            _args16 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _addOperation3 = function _addOperation5() {\n                  _addOperation3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n                    var entry;\n                    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n                      while (1) {\n                        switch (_context15.prev = _context15.next) {\n                          case 0:\n                            if (!this._oplog) {\n                              _context15.next = 15;\n                              break;\n                            }\n\n                            if (!this.options.syncLocal) {\n                              _context15.next = 4;\n                              break;\n                            }\n\n                            _context15.next = 4;\n                            return this.syncLocal();\n\n                          case 4:\n                            _context15.next = 6;\n                            return this._oplog.append(data, this.options.referenceCount, pin);\n\n                          case 6:\n                            entry = _context15.sent;\n\n                            this._recalculateReplicationStatus(entry.clock.time);\n\n                            _context15.next = 10;\n                            return this._cache.set(this.localHeadsPath, [entry]);\n\n                          case 10:\n                            _context15.next = 12;\n                            return this._updateIndex();\n\n                          case 12:\n                            this.events.emit('write', this.address.toString(), entry, this._oplog.heads);\n                            if (onProgressCallback) onProgressCallback(entry);\n                            return _context15.abrupt(\"return\", entry.hash);\n\n                          case 15:\n                          case \"end\":\n                            return _context15.stop();\n                        }\n                      }\n                    }, _callee15, this);\n                  }));\n                  return _addOperation3.apply(this, arguments);\n                };\n\n                addOperation = function _addOperation4() {\n                  return _addOperation3.apply(this, arguments);\n                };\n\n                _ref7 = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : {}, onProgressCallback = _ref7.onProgressCallback, _ref7$pin = _ref7.pin, pin = _ref7$pin === void 0 ? false : _ref7$pin;\n                return _context16.abrupt(\"return\", this._queue.add(addOperation.bind(this)));\n\n              case 4:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function _addOperation(_x9) {\n        return _addOperation2.apply(this, arguments);\n      }\n\n      return _addOperation;\n    }()\n  }, {\n    key: \"_addOperationBatch\",\n    value: function _addOperationBatch(data, batchOperation, lastOperation, onProgressCallback) {\n      throw new Error('Not implemented!');\n    }\n  }, {\n    key: \"_procEntry\",\n    value: function _procEntry(entry) {\n      var payload = entry.payload,\n          hash = entry.hash;\n      var op = payload.op;\n\n      if (op) {\n        this.events.emit(\"log.op.\".concat(op), this.address.toString(), hash, payload);\n      } else {\n        this.events.emit('log.op.none', this.address.toString(), hash, payload);\n      }\n\n      this.events.emit('log.op', op, this.address.toString(), hash, payload);\n    }\n    /* Replication Status state updates */\n\n  }, {\n    key: \"_recalculateReplicationProgress\",\n    value: function _recalculateReplicationProgress() {\n      this._replicationStatus.progress = Math.max(Math.min(this._replicationStatus.progress + 1, this._replicationStatus.max), this._oplog ? this._oplog.length : 0);\n    }\n  }, {\n    key: \"_recalculateReplicationMax\",\n    value: function _recalculateReplicationMax(max) {\n      this._replicationStatus.max = Math.max.apply(null, [this.replicationStatus.max, this._oplog ? this._oplog.length : 0, max || 0]);\n    }\n  }, {\n    key: \"_recalculateReplicationStatus\",\n    value: function _recalculateReplicationStatus(maxTotal) {\n      this._recalculateReplicationMax(maxTotal);\n\n      this._recalculateReplicationProgress();\n    }\n    /* Loading progress callback */\n\n  }, {\n    key: \"_onLoadProgress\",\n    value: function _onLoadProgress(entry) {\n      this._recalculateReplicationStatus(entry.clock.time);\n\n      this.events.emit('load.progress', this.address.toString(), entry.hash, entry, this.replicationStatus.progress, this.replicationStatus.max);\n    }\n  }]);\n\n  return Store;\n}();\n\nmodule.exports = Store;\nmodule.exports.DefaultOptions = DefaultOptions;","map":{"version":3,"names":["path","require","EventEmitter","mapSeries","PQueue","default","Log","Entry","Index","Replicator","ReplicationInfo","Logger","logger","create","color","Colors","Blue","setLogLevel","io","DefaultOptions","maxHistory","fetchEntryTimeout","referenceCount","replicationConcurrency","syncLocal","sortFn","undefined","Store","ipfs","identity","address","options","Error","opts","Object","assign","_type","id","toString","dbname","events","remoteHeadsPath","join","localHeadsPath","snapshotPath","queuePath","manifestPath","_ipfs","_cache","cache","defaultAccess","canAppend","entry","publicKey","access","accessController","_oplog","logId","_queue","concurrency","_index","root","_replicationStatus","_stats","snapshot","bytesLoaded","syncRequestsReceieved","onReplicationQueued","_recalculateReplicationMax","clock","time","emit","onReplicationProgress","previousProgress","replicationStatus","progress","previousMax","max","_recalculateReplicationStatus","length","hash","onReplicationComplete","logs","updateState","log","heads","set","debug","map","e","_updateIndex","console","error","add","bind","_replicator","_loader","on","have","_procEntry","Array","isArray","keys","_key","setIdentity","stop","onIdle","reset","onClose","close","event","_events","removeAllListeners","Promise","resolve","onDrop","del","amount","onLoad","get","localHeads","remoteHeads","concat","forEach","h","fromEntryHash","onProgressCallback","_onLoadProgress","timeout","saveToIpfs","head","warn","identityProvider","provider","logEntry","toEntry","write","getWriteFormat","links","IPLD_LINKS","onlyHash","then","saved","load","filter","entries","unfinished","snapshotData","toSnapshot","buf","Buffer","from","JSON","stringify","size","values","type","cid","maxClock","res","val","Math","queue","sync","chunks","cat","chunk","push","buffer","parse","reduce","fromJSON","updateIndex","i","includes","data","addOperation","append","pin","batchOperation","lastOperation","payload","op","min","apply","maxTotal","_recalculateReplicationProgress","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-store/src/Store.js"],"sourcesContent":["'use strict'\n\nconst path = require('path')\nconst EventEmitter = require('events').EventEmitter\nconst mapSeries = require('p-each-series')\nconst { default: PQueue } = require('p-queue')\nconst Log = require('ipfs-log')\nconst Entry = Log.Entry\nconst Index = require('./Index')\nconst Replicator = require('./Replicator')\nconst ReplicationInfo = require('./replication-info')\n\nconst Logger = require('logplease')\nconst logger = Logger.create('orbit-db.store', { color: Logger.Colors.Blue })\nLogger.setLogLevel('ERROR')\nconst io = require('orbit-db-io')\n\nconst DefaultOptions = {\n  Index: Index,\n  maxHistory: -1,\n  fetchEntryTimeout: null,\n  referenceCount: 32,\n  replicationConcurrency: 32,\n  syncLocal: false,\n  sortFn: undefined\n}\n\nclass Store {\n  constructor (ipfs, identity, address, options) {\n    if (!identity) {\n      throw new Error('Identity required')\n    }\n\n    // Set the options\n    const opts = Object.assign({}, DefaultOptions)\n    Object.assign(opts, options)\n    this.options = opts\n\n    // Default type\n    this._type = 'store'\n\n    // Create IDs, names and paths\n    this.id = address.toString()\n    this.identity = identity\n    this.address = address\n    this.dbname = address.path || ''\n    this.events = new EventEmitter()\n\n    this.remoteHeadsPath = path.join(this.id, '_remoteHeads')\n    this.localHeadsPath = path.join(this.id, '_localHeads')\n    this.snapshotPath = path.join(this.id, 'snapshot')\n    this.queuePath = path.join(this.id, 'queue')\n    this.manifestPath = path.join(this.id, '_manifest')\n\n    // External dependencies\n    this._ipfs = ipfs\n    this._cache = options.cache\n\n    // Access mapping\n    const defaultAccess = {\n      canAppend: (entry) => (entry.identity.publicKey === identity.publicKey)\n    }\n    this.access = options.accessController || defaultAccess\n\n    // Create the operations log\n    this._oplog = new Log(this._ipfs, this.identity, { logId: this.id, access: this.access, sortFn: this.options.sortFn })\n\n    // _addOperation and log-joins queue. Adding ops and joins to the queue\n    // makes sure they get processed sequentially to avoid race conditions\n    // between writes and joins (coming from Replicator)\n    this._queue = new PQueue({ concurrency: 1 })\n\n    // Create the index\n    this._index = new this.options.Index(this.address.root)\n\n    // Replication progress info\n    this._replicationStatus = new ReplicationInfo()\n\n    // Statistics\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    }\n\n    try {\n      const onReplicationQueued = async (entry) => {\n        // Update the latest entry state (latest is the entry with largest clock time)\n        this._recalculateReplicationMax(entry.clock ? entry.clock.time : 0)\n        this.events.emit('replicate', this.address.toString(), entry)\n      }\n\n      const onReplicationProgress = async (entry) => {\n        const previousProgress = this.replicationStatus.progress\n        const previousMax = this.replicationStatus.max\n        this._recalculateReplicationStatus(entry.clock.time)\n        if (this._oplog.length + 1 > this.replicationStatus.progress ||\n          this.replicationStatus.progress > previousProgress ||\n          this.replicationStatus.max > previousMax) {\n          this.events.emit('replicate.progress', this.address.toString(), entry.hash, entry, this.replicationStatus.progress, this.replicationStatus.max)\n        }\n      }\n\n      const onReplicationComplete = async (logs) => {\n        const updateState = async () => {\n          try {\n            if (this._oplog && logs.length > 0) {\n              for (const log of logs) {\n                await this._oplog.join(log)\n              }\n\n              // only store heads that has been verified and merges\n              const heads = this._oplog.heads\n              await this._cache.set(this.remoteHeadsPath, heads)\n              logger.debug(`Saved heads ${heads.length} [${heads.map(e => e.hash).join(', ')}]`)\n\n              // update the store's index after joining the logs\n              // and persisting the latest heads\n              await this._updateIndex()\n\n              if (this._oplog.length > this.replicationStatus.progress) {\n                this._recalculateReplicationStatus(this._oplog.length)\n              }\n\n              this.events.emit('replicated', this.address.toString(), logs.length, this)\n            }\n          } catch (e) {\n            console.error(e)\n          }\n        }\n        await this._queue.add(updateState.bind(this))\n      }\n      // Create the replicator\n      this._replicator = new Replicator(this, this.options.replicationConcurrency)\n      // For internal backwards compatibility,\n      // to be removed in future releases\n      this._loader = this._replicator\n      // Hook up the callbacks to the Replicator\n      this._replicator.onReplicationQueued = onReplicationQueued\n      this._replicator.onReplicationProgress = onReplicationProgress\n      this._replicator.onReplicationComplete = onReplicationComplete\n    } catch (e) {\n      console.error('Store Error:', e)\n    }\n    // TODO: verify if this is working since we don't seem to emit \"replicated.progress\" anywhere\n    this.events.on('replicated.progress', (address, hash, entry, progress, have) => {\n      this._procEntry(entry)\n    })\n    this.events.on('write', (address, entry, heads) => {\n      this._procEntry(entry)\n    })\n  }\n\n  get all () {\n    return Array.isArray(this._index._index)\n      ? this._index._index\n      : Object.keys(this._index._index).map(e => this._index._index[e])\n  }\n\n  get index () {\n    return this._index._index\n  }\n\n  get type () {\n    return this._type\n  }\n\n  get key () {\n    return this._key\n  }\n\n  /**\n   * Returns the database's current replication status information\n   * @return {[Object]} [description]\n   */\n  get replicationStatus () {\n    return this._replicationStatus\n  }\n\n  setIdentity (identity) {\n    this.identity = identity\n    this._oplog.setIdentity(identity)\n  }\n\n  async close () {\n    // Stop the Replicator\n    await this._replicator.stop()\n\n    // Wait for the operations queue to finish processing\n    // to make sure everything that all operations that have\n    // been queued will be written to disk\n    await this._queue.onIdle()\n\n    // Reset replication statistics\n    this._replicationStatus.reset()\n\n    // Reset database statistics\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    }\n\n    if (this.options.onClose) {\n      await this.options.onClose(this)\n    }\n\n    // Close store access controller\n    if (this.access.close) {\n      await this.access.close()\n    }\n\n    // Remove all event listeners\n    for (const event in this.events._events) {\n      this.events.removeAllListeners(event)\n    }\n\n    this._oplog = null\n\n    // Database is now closed\n    // TODO: afaik we don't use 'closed' event anymore,\n    // to be removed in future releases\n    this.events.emit('closed', this.address.toString())\n    return Promise.resolve()\n  }\n\n  /**\n   * Drops a database and removes local data\n   * @return {[None]}\n   */\n  async drop () {\n    if (this.options.onDrop) {\n      await this.options.onDrop(this)\n    }\n\n    await this._cache.del(this.localHeadsPath)\n    await this._cache.del(this.remoteHeadsPath)\n    await this._cache.del(this.snapshotPath)\n    await this._cache.del(this.queuePath)\n    await this._cache.del(this.manifestPath)\n\n    await this.close()\n\n    // Reset\n    this._index = new this.options.Index(this.address.root)\n    this._oplog = new Log(this._ipfs, this.identity, { logId: this.id, access: this.access, sortFn: this.options.sortFn })\n    this._cache = this.options.cache\n  }\n\n  async load (amount, opts = {}) {\n    if (typeof amount === 'object') {\n      opts = amount\n      amount = undefined\n    }\n    amount = amount || this.options.maxHistory\n    const fetchEntryTimeout = opts.fetchEntryTimeout || this.options.fetchEntryTimeout\n\n    if (this.options.onLoad) {\n      await this.options.onLoad(this)\n    }\n    const localHeads = await this._cache.get(this.localHeadsPath) || []\n    const remoteHeads = await this._cache.get(this.remoteHeadsPath) || []\n    const heads = localHeads.concat(remoteHeads)\n\n    if (heads.length > 0) {\n      this.events.emit('load', this.address.toString(), heads)\n    }\n\n    // Update the replication status from the heads\n    heads.forEach(h => this._recalculateReplicationMax(h.clock.time))\n\n    // Load the log\n    const log = await Log.fromEntryHash(this._ipfs, this.identity, heads.map(e => e.hash), {\n      logId: this.id,\n      access: this.access,\n      sortFn: this.options.sortFn,\n      length: amount,\n      onProgressCallback: this._onLoadProgress.bind(this),\n      timeout: fetchEntryTimeout,\n      concurrency: this.options.replicationConcurrency\n    })\n\n    this._oplog = log\n\n    // Update the index\n    if (heads.length > 0) {\n      await this._updateIndex()\n    }\n\n    this.events.emit('ready', this.address.toString(), this._oplog.heads)\n  }\n\n  async sync (heads) {\n    this._stats.syncRequestsReceieved += 1\n    logger.debug(`Sync request #${this._stats.syncRequestsReceieved} ${heads.length}`)\n    if (heads.length === 0) {\n      return\n    }\n\n    // To simulate network latency, uncomment this line\n    // and comment out the rest of the function\n    // That way the object (received as head message from pubsub)\n    // doesn't get written to IPFS and so when the Replicator is fetching\n    // the log, it'll fetch it from the network instead from the disk.\n    // return this._replicator.load(heads)\n\n    const saveToIpfs = async (head) => {\n      if (!head) {\n        console.warn(\"Warning: Given input entry was 'null'.\")\n        return Promise.resolve(null)\n      }\n\n      const identityProvider = this.identity.provider\n      if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry')\n\n      const canAppend = await this.access.canAppend(head, identityProvider)\n      if (!canAppend) {\n        console.warn('Warning: Given input entry is not allowed in this log and was discarded (no write access).')\n        return Promise.resolve(null)\n      }\n\n      const logEntry = Entry.toEntry(head)\n      const hash = await io.write(this._ipfs, Entry.getWriteFormat(logEntry), logEntry, { links: Entry.IPLD_LINKS, onlyHash: true })\n\n      if (hash !== head.hash) {\n        console.warn('\"WARNING! Head hash didn\\'t match the contents')\n      }\n\n      return head\n    }\n\n    return mapSeries(heads, saveToIpfs)\n      .then(async (saved) => {\n        return this._replicator.load(saved.filter(e => e !== null))\n      })\n  }\n\n  loadMoreFrom (amount, entries) {\n    this._replicator.load(entries)\n  }\n\n  async saveSnapshot () {\n    const unfinished = this._replicator.unfinished\n\n    const snapshotData = this._oplog.toSnapshot()\n    const buf = Buffer.from(JSON.stringify({\n      id: snapshotData.id,\n      heads: snapshotData.heads,\n      size: snapshotData.values.length,\n      values: snapshotData.values,\n      type: this.type\n    }))\n\n    const snapshot = await this._ipfs.add(buf)\n\n    snapshot.hash = snapshot.cid.toString() // js-ipfs >= 0.41, ipfs.add results contain a cid property (a CID instance) instead of a string hash property\n    await this._cache.set(this.snapshotPath, snapshot)\n    await this._cache.set(this.queuePath, unfinished)\n\n    logger.debug(`Saved snapshot: ${snapshot.hash}, queue length: ${unfinished.length}`)\n\n    return [snapshot]\n  }\n\n  async loadFromSnapshot (onProgressCallback) {\n    if (this.options.onLoad) {\n      await this.options.onLoad(this)\n    }\n\n    this.events.emit('load', this.address.toString()) // TODO emits inconsistent params, missing heads param\n\n    const maxClock = (res, val) => Math.max(res, val.clock.time)\n\n    const queue = await this._cache.get(this.queuePath)\n    this.sync(queue || [])\n\n    const snapshot = await this._cache.get(this.snapshotPath)\n\n    if (snapshot) {\n      const chunks = []\n      for await (const chunk of this._ipfs.cat(snapshot.hash)) {\n        chunks.push(chunk)\n      }\n      const buffer = Buffer.concat(chunks)\n      const snapshotData = JSON.parse(buffer.toString())\n\n      // Fetch the entries\n      // Timeout 1 sec to only load entries that are already fetched (in order to not get stuck at loading)\n      this._recalculateReplicationMax(snapshotData.values.reduce(maxClock, 0))\n      if (snapshotData) {\n        this._oplog = await Log.fromJSON(this._ipfs, this.identity, snapshotData, {\n          access: this.access,\n          sortFn: this.options.sortFn,\n          length: -1,\n          timeout: 1000,\n          onProgressCallback: this._onLoadProgress.bind(this)\n        })\n        await this._updateIndex()\n        this.events.emit('replicated', this.address.toString()) // TODO: inconsistent params, count param not emited\n      }\n      this.events.emit('ready', this.address.toString(), this._oplog.heads)\n    } else {\n      throw new Error(`Snapshot for ${this.address} not found!`)\n    }\n\n    return this\n  }\n\n  async _updateIndex () {\n    await this._index.updateIndex(this._oplog)\n  }\n\n  async syncLocal () {\n    const localHeads = await this._cache.get(this.localHeadsPath) || []\n    const remoteHeads = await this._cache.get(this.remoteHeadsPath) || []\n    const heads = localHeads.concat(remoteHeads)\n    for (let i = 0; i < heads.length; i++) {\n      const head = heads[i]\n      if (!this._oplog.heads.includes(head)) {\n        await this.load()\n        break\n      }\n    }\n  }\n\n  async _addOperation (data, { onProgressCallback, pin = false } = {}) {\n    async function addOperation () {\n      if (this._oplog) {\n        // check local cache for latest heads\n        if (this.options.syncLocal) {\n          await this.syncLocal()\n        }\n        const entry = await this._oplog.append(data, this.options.referenceCount, pin)\n        this._recalculateReplicationStatus(entry.clock.time)\n        await this._cache.set(this.localHeadsPath, [entry])\n        await this._updateIndex()\n        this.events.emit('write', this.address.toString(), entry, this._oplog.heads)\n        if (onProgressCallback) onProgressCallback(entry)\n        return entry.hash\n      }\n    }\n    return this._queue.add(addOperation.bind(this))\n  }\n\n  _addOperationBatch (data, batchOperation, lastOperation, onProgressCallback) {\n    throw new Error('Not implemented!')\n  }\n\n  _procEntry (entry) {\n    const { payload, hash } = entry\n    const { op } = payload\n    if (op) {\n      this.events.emit(`log.op.${op}`, this.address.toString(), hash, payload)\n    } else {\n      this.events.emit('log.op.none', this.address.toString(), hash, payload)\n    }\n    this.events.emit('log.op', op, this.address.toString(), hash, payload)\n  }\n\n  /* Replication Status state updates */\n  _recalculateReplicationProgress () {\n    this._replicationStatus.progress = Math.max(\n      Math.min(this._replicationStatus.progress + 1, this._replicationStatus.max),\n      this._oplog ? this._oplog.length : 0\n    )\n  }\n\n  _recalculateReplicationMax (max) {\n    this._replicationStatus.max = Math.max.apply(null, [\n      this.replicationStatus.max,\n      this._oplog ? this._oplog.length : 0,\n      (max || 0)\n    ])\n  }\n\n  _recalculateReplicationStatus (maxTotal) {\n    this._recalculateReplicationMax(maxTotal)\n    this._recalculateReplicationProgress()\n  }\n\n  /* Loading progress callback */\n  _onLoadProgress (entry) {\n    this._recalculateReplicationStatus(entry.clock.time)\n    this.events.emit('load.progress', this.address.toString(), entry.hash, entry, this.replicationStatus.progress, this.replicationStatus.max)\n  }\n}\n\nmodule.exports = Store\nmodule.exports.DefaultOptions = DefaultOptions\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}