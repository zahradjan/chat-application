{"ast":null,"code":"'use strict';\n\nconst {\n  exporter,\n  recursive\n} = require('ipfs-unixfs-exporter');\n\nconst errCode = require('err-code');\n\nconst {\n  normalizeCidPath\n} = require('../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst {\n  pack\n} = require('it-tar');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  gzip\n} = require('pako');\n\nconst map = require('it-map');\n\nconst toBuffer = require('it-to-buffer'); // https://www.gnu.org/software/gzip/manual/gzip.html\n\n\nconst DEFAULT_COMPRESSION_LEVEL = 6;\n/**\n * @typedef {Object} Context\n * @property {import('ipfs-repo').IPFSRepo} repo\n * @property {import('../types').Preload} preload\n *\n * @param {Context} context\n */\n\nmodule.exports = function (_ref) {\n  let {\n    repo,\n    preload\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"get\"]}\n   */\n  async function* get(ipfsPath) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.compressionLevel < 0 || options.compressionLevel > 9) {\n      throw errCode(new Error('Compression level must be between 1 and 9'), 'ERR_INVALID_PARAMS');\n    }\n\n    if (options.preload !== false) {\n      let pathComponents;\n\n      try {\n        pathComponents = normalizeCidPath(ipfsPath).split('/');\n      } catch (err) {\n        throw errCode(err, 'ERR_INVALID_PATH');\n      }\n\n      preload(CID.parse(pathComponents[0]));\n    }\n\n    const ipfsPathOrCid = CID.asCID(ipfsPath) || ipfsPath;\n    const file = await exporter(ipfsPathOrCid, repo.blocks, options);\n\n    if (file.type === 'file' || file.type === 'raw') {\n      const args = [];\n\n      if (!options.compress || options.archive === true) {\n        args.push([{\n          header: {\n            name: file.path,\n            mode: file.type === 'file' && file.unixfs.mode,\n            mtime: file.type === 'file' && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1000) : undefined,\n            size: file.size,\n            type: 'file'\n          },\n          body: file.content()\n        }], pack(),\n        /**\n         * @param {AsyncIterable<Uint8Array>} source\n         */\n        source => map(source, buf => buf.slice()));\n      } else {\n        args.push(file.content);\n      }\n\n      if (options.compress) {\n        args.push(\n        /**\n         * @param {AsyncIterable<Uint8Array>} source\n         */\n        async function* (source) {\n          const buf = await toBuffer(source);\n          yield gzip(buf, {\n            level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n          });\n        });\n      } // @ts-ignore cannot derive type\n\n\n      yield* pipe(...args);\n      return;\n    }\n\n    if (file.type === 'directory') {\n      /** @type {any[]} */\n      const args = [recursive(ipfsPathOrCid, repo.blocks, options),\n      /**\n       * @param {AsyncIterable<import('ipfs-unixfs-exporter').UnixFSEntry>} source\n       */\n      async function* (source) {\n        for await (const entry of source) {\n          /** @type {import('it-tar').TarImportCandidate} */\n          const output = {\n            header: {\n              name: entry.path,\n              size: entry.size\n            }\n          };\n\n          if (entry.type === 'file') {\n            output.header.type = 'file';\n            output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined;\n            output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined;\n            output.body = entry.content();\n          } else if (entry.type === 'raw') {\n            output.header.type = 'file';\n            output.body = entry.content();\n          } else if (entry.type === 'directory') {\n            output.header.type = 'directory';\n            output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined;\n            output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined;\n          } else {\n            throw errCode(new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS');\n          }\n\n          yield output;\n        }\n      }, pack(),\n      /**\n       * @param {AsyncIterable<Uint8Array>} source\n       */\n      source => map(source, buf => buf.slice())];\n\n      if (options.compress) {\n        if (!options.archive) {\n          throw errCode(new Error('file is not regular'), 'ERR_INVALID_PATH');\n        }\n\n        if (options.compress) {\n          args.push(\n          /**\n           * @param {AsyncIterable<Uint8Array>} source\n           */\n          async function* (source) {\n            const buf = await toBuffer(source);\n            yield gzip(buf, {\n              level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n            });\n          });\n        }\n      } // @ts-ignore cannot derive type\n\n\n      yield* pipe(...args);\n      return;\n    }\n\n    throw errCode(new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS');\n  }\n\n  return withTimeoutOption(get);\n};","map":{"version":3,"names":["exporter","recursive","require","errCode","normalizeCidPath","withTimeoutOption","CID","pack","pipe","gzip","map","toBuffer","DEFAULT_COMPRESSION_LEVEL","module","exports","repo","preload","get","ipfsPath","options","compressionLevel","Error","pathComponents","split","err","parse","ipfsPathOrCid","asCID","file","blocks","type","args","compress","archive","push","header","name","path","mode","unixfs","mtime","Date","secs","undefined","size","body","content","source","buf","slice","level","entry","output"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/get.js"],"sourcesContent":["'use strict'\n\nconst { exporter, recursive } = require('ipfs-unixfs-exporter')\nconst errCode = require('err-code')\nconst { normalizeCidPath } = require('../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { CID } = require('multiformats/cid')\nconst { pack } = require('it-tar')\nconst { pipe } = require('it-pipe')\nconst { gzip } = require('pako')\nconst map = require('it-map')\nconst toBuffer = require('it-to-buffer')\n\n// https://www.gnu.org/software/gzip/manual/gzip.html\nconst DEFAULT_COMPRESSION_LEVEL = 6\n\n/**\n * @typedef {Object} Context\n * @property {import('ipfs-repo').IPFSRepo} repo\n * @property {import('../types').Preload} preload\n *\n * @param {Context} context\n */\nmodule.exports = function ({ repo, preload }) {\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"get\"]}\n   */\n  async function * get (ipfsPath, options = {}) {\n    if (options.compressionLevel < 0 || options.compressionLevel > 9) {\n      throw errCode(new Error('Compression level must be between 1 and 9'), 'ERR_INVALID_PARAMS')\n    }\n\n    if (options.preload !== false) {\n      let pathComponents\n\n      try {\n        pathComponents = normalizeCidPath(ipfsPath).split('/')\n      } catch (err) {\n        throw errCode(err, 'ERR_INVALID_PATH')\n      }\n\n      preload(CID.parse(pathComponents[0]))\n    }\n\n    const ipfsPathOrCid = CID.asCID(ipfsPath) || ipfsPath\n    const file = await exporter(ipfsPathOrCid, repo.blocks, options)\n\n    if (file.type === 'file' || file.type === 'raw') {\n      const args = []\n\n      if (!options.compress || options.archive === true) {\n        args.push([{\n          header: {\n            name: file.path,\n            mode: file.type === 'file' && file.unixfs.mode,\n            mtime: file.type === 'file' && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1000) : undefined,\n            size: file.size,\n            type: 'file'\n          },\n          body: file.content()\n        }],\n        pack(),\n        /**\n         * @param {AsyncIterable<Uint8Array>} source\n         */\n        (source) => map(source, buf => buf.slice())\n        )\n      } else {\n        args.push(\n          file.content\n        )\n      }\n\n      if (options.compress) {\n        args.push(\n          /**\n           * @param {AsyncIterable<Uint8Array>} source\n           */\n          async function * (source) {\n            const buf = await toBuffer(source)\n\n            yield gzip(buf, {\n              level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n            })\n          }\n        )\n      }\n\n      // @ts-ignore cannot derive type\n      yield * pipe(...args)\n\n      return\n    }\n\n    if (file.type === 'directory') {\n      /** @type {any[]} */\n      const args = [\n        recursive(ipfsPathOrCid, repo.blocks, options),\n        /**\n         * @param {AsyncIterable<import('ipfs-unixfs-exporter').UnixFSEntry>} source\n         */\n        async function * (source) {\n          for await (const entry of source) {\n            /** @type {import('it-tar').TarImportCandidate} */\n            const output = {\n              header: {\n                name: entry.path,\n                size: entry.size\n              }\n            }\n\n            if (entry.type === 'file') {\n              output.header.type = 'file'\n              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined\n              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined\n              output.body = entry.content()\n            } else if (entry.type === 'raw') {\n              output.header.type = 'file'\n              output.body = entry.content()\n            } else if (entry.type === 'directory') {\n              output.header.type = 'directory'\n              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined\n              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined\n            } else {\n              throw errCode(new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS')\n            }\n\n            yield output\n          }\n        },\n        pack(),\n        /**\n         * @param {AsyncIterable<Uint8Array>} source\n         */\n        (source) => map(source, buf => buf.slice())\n      ]\n\n      if (options.compress) {\n        if (!options.archive) {\n          throw errCode(new Error('file is not regular'), 'ERR_INVALID_PATH')\n        }\n\n        if (options.compress) {\n          args.push(\n            /**\n             * @param {AsyncIterable<Uint8Array>} source\n             */\n            async function * (source) {\n              const buf = await toBuffer(source)\n\n              yield gzip(buf, {\n                level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL\n              })\n            }\n          )\n        }\n      }\n\n      // @ts-ignore cannot derive type\n      yield * pipe(...args)\n\n      return\n    }\n\n    throw errCode(new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS')\n  }\n\n  return withTimeoutOption(get)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}