{"ast":null,"code":"import EventEmitter from 'events';\nimport { pipe } from 'it-pipe';\nimport PROTOCOL from './protocol.js';\nimport encoding from './encoding.js';\nexport default class Connection extends EventEmitter {\n  constructor(remoteId, libp2p, room) {\n    super();\n    this._remoteId = remoteId;\n    this._libp2p = libp2p;\n    this._room = room;\n    this._connection = null;\n    this._connecting = false;\n  }\n\n  push(message) {\n    if (this._connection) {\n      this._connection.push(encoding(message));\n\n      return;\n    }\n\n    this.once('connect', () => {\n      this.push(message);\n    });\n\n    if (!this._connecting) {\n      this._connect();\n    }\n  }\n\n  stop() {\n    if (this._connection) {\n      this._connection.end();\n    }\n  }\n\n  async _connect() {\n    this._connecting = true;\n\n    if (!this._isConnectedToRemote()) {\n      this.emit('disconnect');\n      this._connecting = false;\n      return; // early\n    }\n\n    const peer = await this._libp2p.peerStore.get(this._remoteId);\n    const {\n      stream\n    } = await this._libp2p.dialProtocol(peer.id, PROTOCOL);\n    this._connection = new FiFoMessageQueue();\n    pipe(this._connection, stream, async source => {\n      this._connecting = false;\n      this.emit('connect', this._connection);\n\n      for await (const message of source) {\n        this.emit('message', message);\n      }\n\n      this.emit('disconnect');\n    }).catch(err => {\n      this.emit('error', err);\n    });\n  }\n\n  _isConnectedToRemote() {\n    return this._libp2p.getConnections(this._remoteId).length !== 0;\n  }\n\n}\n\nclass FiFoMessageQueue {\n  constructor() {\n    this._queue = [];\n  }\n\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n\n  push(message) {\n    if (this._ended) {\n      throw new Error('Message queue ended');\n    }\n\n    if (this._resolve) {\n      return this._resolve({\n        done: false,\n        value: message\n      });\n    }\n\n    this._queue.push(message);\n  }\n\n  end() {\n    this._ended = true;\n\n    if (this._resolve) {\n      this._resolve({\n        done: true\n      });\n    }\n  }\n\n  next() {\n    if (this._ended) {\n      return {\n        done: true\n      };\n    }\n\n    if (this._queue.length) {\n      return {\n        done: false,\n        value: this._queue.shift()\n      };\n    }\n\n    return new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n}","map":{"version":3,"names":["EventEmitter","pipe","PROTOCOL","encoding","Connection","constructor","remoteId","libp2p","room","_remoteId","_libp2p","_room","_connection","_connecting","push","message","once","_connect","stop","end","_isConnectedToRemote","emit","peer","peerStore","get","stream","dialProtocol","id","FiFoMessageQueue","source","catch","err","getConnections","length","_queue","Symbol","asyncIterator","_ended","Error","_resolve","done","value","next","shift","Promise","resolve"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-pubsub-room/src/connection.js"],"sourcesContent":["import EventEmitter from 'events'\nimport { pipe } from 'it-pipe'\nimport PROTOCOL from './protocol.js'\nimport encoding from './encoding.js'\n\nexport default class Connection extends EventEmitter {\n  constructor (remoteId, libp2p, room) {\n    super()\n    this._remoteId = remoteId\n    this._libp2p = libp2p\n    this._room = room\n    this._connection = null\n    this._connecting = false\n  }\n\n  push (message) {\n    if (this._connection) {\n      this._connection.push(encoding(message))\n\n      return\n    }\n\n    this.once('connect', () => {\n      this.push(message)\n    })\n\n    if (!this._connecting) {\n      this._connect()\n    }\n  }\n\n  stop () {\n    if (this._connection) {\n      this._connection.end()\n    }\n  }\n\n  async _connect () {\n    this._connecting = true\n\n    if (!this._isConnectedToRemote()) {\n      this.emit('disconnect')\n      this._connecting = false\n      return // early\n    }\n\n    const peer = await this._libp2p.peerStore.get(this._remoteId)\n    const { stream } = await this._libp2p.dialProtocol(peer.id, PROTOCOL)\n    this._connection = new FiFoMessageQueue()\n\n    pipe(this._connection, stream, async (source) => {\n      this._connecting = false\n      this.emit('connect', this._connection)\n\n      for await (const message of source) {\n        this.emit('message', message)\n      }\n\n      this.emit('disconnect')\n    })\n      .catch((err) => {\n        this.emit('error', err)\n      })\n  }\n\n  _isConnectedToRemote () {\n    return this._libp2p.getConnections(this._remoteId).length !== 0\n  }\n}\n\nclass FiFoMessageQueue {\n  constructor () {\n    this._queue = []\n  }\n\n  [Symbol.asyncIterator] () {\n    return this\n  }\n\n  push (message) {\n    if (this._ended) {\n      throw new Error('Message queue ended')\n    }\n\n    if (this._resolve) {\n      return this._resolve({\n        done: false,\n        value: message\n      })\n    }\n\n    this._queue.push(message)\n  }\n\n  end () {\n    this._ended = true\n    if (this._resolve) {\n      this._resolve({\n        done: true\n      })\n    }\n  }\n\n  next () {\n    if (this._ended) {\n      return {\n        done: true\n      }\n    }\n\n    if (this._queue.length) {\n      return {\n        done: false,\n        value: this._queue.shift()\n      }\n    }\n\n    return new Promise((resolve) => {\n      this._resolve = resolve\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}