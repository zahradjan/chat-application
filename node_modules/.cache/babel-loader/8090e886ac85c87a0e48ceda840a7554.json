{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nvar errCode = require('err-code');\n\nvar _require = require('../errors'),\n    NotEnabledError = _require.NotEnabledError;\n\nvar get = require('dlv');\n/**\n * @param {Object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-core-types/src/config').Config} [config.config]\n */\n\n\nmodule.exports = function (_ref) {\n  var network = _ref.network,\n      config = _ref.config;\n  var isEnabled = get(config || {}, 'Pubsub.Enabled', true);\n  return {\n    subscribe: isEnabled ? withTimeoutOption(subscribe) : notEnabled,\n    unsubscribe: isEnabled ? withTimeoutOption(unsubscribe) : notEnabled,\n    publish: isEnabled ? withTimeoutOption(publish) : notEnabled,\n    ls: isEnabled ? withTimeoutOption(ls) : notEnabled,\n    peers: isEnabled ? withTimeoutOption(peers) : notEnabled\n  };\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API[\"subscribe\"]}\n   */\n\n  function subscribe(_x, _x2) {\n    return _subscribe.apply(this, arguments);\n  }\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API[\"unsubscribe\"]}\n   */\n\n\n  function _subscribe() {\n    _subscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(topic, handler) {\n      var options,\n          _yield$network$use,\n          libp2p,\n          _args = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n              _context.next = 3;\n              return network.use(options);\n\n            case 3:\n              _yield$network$use = _context.sent;\n              libp2p = _yield$network$use.libp2p;\n              return _context.abrupt(\"return\", libp2p.pubsub.subscribe(topic, handler, options));\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return _subscribe.apply(this, arguments);\n  }\n\n  function unsubscribe(_x3, _x4) {\n    return _unsubscribe.apply(this, arguments);\n  }\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API[\"publish\"]}\n   */\n\n\n  function _unsubscribe() {\n    _unsubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(topic, handler) {\n      var options,\n          _yield$network$use2,\n          libp2p,\n          _args2 = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n              _context2.next = 3;\n              return network.use(options);\n\n            case 3:\n              _yield$network$use2 = _context2.sent;\n              libp2p = _yield$network$use2.libp2p;\n              // @ts-ignore Libp2p Pubsub is deprecating the handler, using the EventEmitter\n              libp2p.pubsub.unsubscribe(topic, handler, options);\n\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return _unsubscribe.apply(this, arguments);\n  }\n\n  function publish(_x5, _x6) {\n    return _publish.apply(this, arguments);\n  }\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API[\"ls\"]}\n   */\n\n\n  function _publish() {\n    _publish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(topic, data) {\n      var options,\n          _yield$network$use3,\n          libp2p,\n          _args3 = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};\n              _context3.next = 3;\n              return network.use(options);\n\n            case 3:\n              _yield$network$use3 = _context3.sent;\n              libp2p = _yield$network$use3.libp2p;\n\n              if (data) {\n                _context3.next = 7;\n                break;\n              }\n\n              throw errCode(new Error('argument \"data\" is required'), 'ERR_ARG_REQUIRED');\n\n            case 7:\n              _context3.next = 9;\n              return libp2p.pubsub.publish(topic, data);\n\n            case 9:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    return _publish.apply(this, arguments);\n  }\n\n  function ls() {\n    return _ls.apply(this, arguments);\n  }\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API[\"peers\"]}\n   */\n\n\n  function _ls() {\n    _ls = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n      var options,\n          _yield$network$use4,\n          libp2p,\n          _args4 = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};\n              _context4.next = 3;\n              return network.use(options);\n\n            case 3:\n              _yield$network$use4 = _context4.sent;\n              libp2p = _yield$network$use4.libp2p;\n              return _context4.abrupt(\"return\", libp2p.pubsub.getTopics());\n\n            case 6:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return _ls.apply(this, arguments);\n  }\n\n  function peers(_x7) {\n    return _peers.apply(this, arguments);\n  }\n\n  function _peers() {\n    _peers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(topic) {\n      var options,\n          _yield$network$use5,\n          libp2p,\n          _args5 = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              options = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};\n              _context5.next = 3;\n              return network.use(options);\n\n            case 3:\n              _yield$network$use5 = _context5.sent;\n              libp2p = _yield$network$use5.libp2p;\n              return _context5.abrupt(\"return\", libp2p.pubsub.getSubscribers(topic));\n\n            case 6:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n    return _peers.apply(this, arguments);\n  }\n};\n\nvar notEnabled = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            throw new NotEnabledError('pubsub not enabled');\n\n          case 1:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function notEnabled() {\n    return _ref2.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["withTimeoutOption","require","errCode","NotEnabledError","get","module","exports","network","config","isEnabled","subscribe","notEnabled","unsubscribe","publish","ls","peers","topic","handler","options","use","libp2p","pubsub","data","Error","getTopics","getSubscribers"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/pubsub.js"],"sourcesContent":["'use strict'\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst errCode = require('err-code')\nconst { NotEnabledError } = require('../errors')\nconst get = require('dlv')\n\n/**\n * @param {Object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-core-types/src/config').Config} [config.config]\n */\nmodule.exports = ({ network, config }) => {\n  const isEnabled = get(config || {}, 'Pubsub.Enabled', true)\n\n  return {\n    subscribe: isEnabled ? withTimeoutOption(subscribe) : notEnabled,\n    unsubscribe: isEnabled ? withTimeoutOption(unsubscribe) : notEnabled,\n    publish: isEnabled ? withTimeoutOption(publish) : notEnabled,\n    ls: isEnabled ? withTimeoutOption(ls) : notEnabled,\n    peers: isEnabled ? withTimeoutOption(peers) : notEnabled\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API[\"subscribe\"]}\n   */\n  async function subscribe (topic, handler, options = {}) {\n    const { libp2p } = await network.use(options)\n    // @ts-ignore Libp2p Pubsub is deprecating the handler, using the EventEmitter\n    return libp2p.pubsub.subscribe(topic, handler, options)\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API[\"unsubscribe\"]}\n   */\n  async function unsubscribe (topic, handler, options = {}) {\n    const { libp2p } = await network.use(options)\n    // @ts-ignore Libp2p Pubsub is deprecating the handler, using the EventEmitter\n    libp2p.pubsub.unsubscribe(topic, handler, options)\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API[\"publish\"]}\n   */\n  async function publish (topic, data, options = {}) {\n    const { libp2p } = await network.use(options)\n    if (!data) {\n      throw errCode(new Error('argument \"data\" is required'), 'ERR_ARG_REQUIRED')\n    }\n    await libp2p.pubsub.publish(topic, data)\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API[\"ls\"]}\n   */\n  async function ls (options = {}) {\n    const { libp2p } = await network.use(options)\n    return libp2p.pubsub.getTopics()\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/pubsub').API[\"peers\"]}\n   */\n  async function peers (topic, options = {}) {\n    const { libp2p } = await network.use(options)\n    return libp2p.pubsub.getSubscribers(topic)\n  }\n}\n\nconst notEnabled = async () => { // eslint-disable-line require-await\n  throw new NotEnabledError('pubsub not enabled')\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}