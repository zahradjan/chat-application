{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar PeerId = require('peer-id');\n\nvar _require = require('multiformats/bases/base58'),\n    base58btc = _require.base58btc;\n\nvar _require2 = require('p-queue'),\n    PQueue = _require2.default;\n\nvar defer = require('p-defer');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p-delegated-peer-routing');\nlog.error = debug('libp2p-delegated-peer-routing:error');\nvar DEFAULT_TIMEOUT = 30e3; // 30 second default\n\nvar CONCURRENT_HTTP_REQUESTS = 4;\n\nvar DelegatedPeerRouting = /*#__PURE__*/function () {\n  /**\n   * Create a new DelegatedPeerRouting instance.\n   *\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  function DelegatedPeerRouting(client) {\n    _classCallCheck(this, DelegatedPeerRouting);\n\n    if (client == null) {\n      throw new Error('missing ipfs http client');\n    }\n\n    this._client = client; // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n\n    this._httpQueue = new PQueue({\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    });\n\n    var _client$getEndpointCo = client.getEndpointConfig(),\n        protocol = _client$getEndpointCo.protocol,\n        host = _client$getEndpointCo.host,\n        port = _client$getEndpointCo.port;\n\n    log(\"enabled DelegatedPeerRouting via \".concat(protocol, \"://\").concat(host, \":\").concat(port));\n  }\n  /**\n   * Attempts to find the given peer\n   *\n   * @param {PeerID} id\n   * @param {object} options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  _createClass(DelegatedPeerRouting, [{\n    key: \"findPeer\",\n    value: function () {\n      var _findPeer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(id) {\n        var _this2 = this;\n\n        var options,\n            idStr,\n            _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n                idStr = id;\n\n                if (PeerId.isPeerId(idStr)) {\n                  idStr = id.toB58String();\n                }\n\n                log('findPeer starts: ' + id);\n                options.timeout = options.timeout || DEFAULT_TIMEOUT;\n                _context2.prev = 5;\n                _context2.next = 8;\n                return this._httpQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                  var _yield$_this2$_client, addrs;\n\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return _this2._client.dht.findPeer(idStr, {\n                            timeout: options.timeout\n                          });\n\n                        case 2:\n                          _yield$_this2$_client = _context.sent;\n                          addrs = _yield$_this2$_client.addrs;\n                          return _context.abrupt(\"return\", {\n                            id: id,\n                            multiaddrs: addrs\n                          });\n\n                        case 5:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                })));\n\n              case 8:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 11:\n                _context2.prev = 11;\n                _context2.t0 = _context2[\"catch\"](5);\n\n                if (!_context2.t0.message.includes('not found')) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", undefined);\n\n              case 15:\n                throw _context2.t0;\n\n              case 16:\n                _context2.prev = 16;\n                log('findPeer finished: ' + id);\n                return _context2.finish(16);\n\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[5, 11, 16, 19]]);\n      }));\n\n      function findPeer(_x) {\n        return _findPeer.apply(this, arguments);\n      }\n\n      return findPeer;\n    }()\n    /**\n     * Attempt to find the closest peers on the network to the given key\n     *\n     * @param {Uint8Array} key - A CID like key\n     * @param {object} [options]\n     * @param {number} [options.timeout=30e3] - How long the query can take.\n     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n\n  }, {\n    key: \"getClosestPeers\",\n    value: function getClosestPeers(key) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var keyStr, onStart, onFinish, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                keyStr = base58btc.encode(key).substring(1);\n                log('getClosestPeers starts:', keyStr);\n                options.timeout = options.timeout || DEFAULT_TIMEOUT;\n                onStart = defer();\n                onFinish = defer();\n\n                _this._httpQueue.add(function () {\n                  onStart.resolve();\n                  return onFinish.promise;\n                });\n\n                _context4.prev = 6;\n                return _context4.delegateYield( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                  var peers, result;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          _context3.next = 2;\n                          return _awaitAsyncGenerator(onStart.promise);\n\n                        case 2:\n                          peers = new Map();\n                          _iteratorAbruptCompletion = false;\n                          _didIteratorError = false;\n                          _context3.prev = 5;\n                          _iterator = _asyncIterator(_this._client.dht.query(keyStr, {\n                            timeout: options.timeout\n                          }));\n\n                        case 7:\n                          _context3.next = 9;\n                          return _awaitAsyncGenerator(_iterator.next());\n\n                        case 9:\n                          if (!(_iteratorAbruptCompletion = !(_step = _context3.sent).done)) {\n                            _context3.next = 23;\n                            break;\n                          }\n\n                          result = _step.value;\n                          _context3.t0 = result.type;\n                          _context3.next = _context3.t0 === 1 ? 14 : _context3.t0 === 2 ? 16 : 19;\n                          break;\n\n                        case 14:\n                          // Found Closer\n                          // Track the addresses, so we can yield them when done\n                          result.responses.forEach(function (response) {\n                            peers.set(response.id, {\n                              id: PeerId.parse(response.id),\n                              multiaddrs: response.addrs\n                            });\n                          });\n                          return _context3.abrupt(\"break\", 20);\n\n                        case 16:\n                          _context3.next = 18;\n                          return peers.get(result.id.string) || {\n                            id: PeerId.createFromCID(result.id),\n                            multiaddrs: []\n                          };\n\n                        case 18:\n                          return _context3.abrupt(\"break\", 20);\n\n                        case 19:\n                          log('getClosestPeers unhandled response', result);\n\n                        case 20:\n                          _iteratorAbruptCompletion = false;\n                          _context3.next = 7;\n                          break;\n\n                        case 23:\n                          _context3.next = 29;\n                          break;\n\n                        case 25:\n                          _context3.prev = 25;\n                          _context3.t1 = _context3[\"catch\"](5);\n                          _didIteratorError = true;\n                          _iteratorError = _context3.t1;\n\n                        case 29:\n                          _context3.prev = 29;\n                          _context3.prev = 30;\n\n                          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                            _context3.next = 34;\n                            break;\n                          }\n\n                          _context3.next = 34;\n                          return _awaitAsyncGenerator(_iterator.return());\n\n                        case 34:\n                          _context3.prev = 34;\n\n                          if (!_didIteratorError) {\n                            _context3.next = 37;\n                            break;\n                          }\n\n                          throw _iteratorError;\n\n                        case 37:\n                          return _context3.finish(34);\n\n                        case 38:\n                          return _context3.finish(29);\n\n                        case 39:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3, null, [[5, 25, 29, 39], [30,, 34, 38]]);\n                })(), \"t0\", 8);\n\n              case 8:\n                _context4.next = 14;\n                break;\n\n              case 10:\n                _context4.prev = 10;\n                _context4.t1 = _context4[\"catch\"](6);\n                log.error('getClosestPeers errored:', _context4.t1);\n                throw _context4.t1;\n\n              case 14:\n                _context4.prev = 14;\n                onFinish.resolve();\n                log('getClosestPeers finished:', keyStr);\n                return _context4.finish(14);\n\n              case 18:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, null, [[6, 10, 14, 18]]);\n      }))();\n    }\n  }]);\n\n  return DelegatedPeerRouting;\n}();\n\nmodule.exports = DelegatedPeerRouting;","map":{"version":3,"names":["PeerId","require","base58btc","PQueue","default","defer","debug","log","error","DEFAULT_TIMEOUT","CONCURRENT_HTTP_REQUESTS","DelegatedPeerRouting","client","Error","_client","_httpQueue","concurrency","getEndpointConfig","protocol","host","port","id","options","idStr","isPeerId","toB58String","timeout","add","dht","findPeer","addrs","multiaddrs","message","includes","undefined","key","keyStr","encode","substring","onStart","onFinish","resolve","promise","peers","Map","query","result","type","responses","forEach","response","set","parse","get","string","createFromCID","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-delegated-peer-routing/src/index.js"],"sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { base58btc } = require('multiformats/bases/base58')\nconst { default: PQueue } = require('p-queue')\nconst defer = require('p-defer')\nconst debug = require('debug')\n\nconst log = debug('libp2p-delegated-peer-routing')\nlog.error = debug('libp2p-delegated-peer-routing:error')\n\nconst DEFAULT_TIMEOUT = 30e3 // 30 second default\nconst CONCURRENT_HTTP_REQUESTS = 4\n\nclass DelegatedPeerRouting {\n  /**\n   * Create a new DelegatedPeerRouting instance.\n   *\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor (client) {\n    if (client == null) {\n      throw new Error('missing ipfs http client')\n    }\n\n    this._client = client\n\n    // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n    this._httpQueue = new PQueue({\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    })\n\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig()\n\n    log(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`)\n  }\n\n  /**\n   * Attempts to find the given peer\n   *\n   * @param {PeerID} id\n   * @param {object} options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async findPeer (id, options = {}) {\n    let idStr = id\n    if (PeerId.isPeerId(idStr)) {\n      idStr = id.toB58String()\n    }\n\n    log('findPeer starts: ' + id)\n\n    options.timeout = options.timeout || DEFAULT_TIMEOUT\n\n    try {\n      return await this._httpQueue.add(async () => {\n        const { addrs } = await this._client.dht.findPeer(idStr, {\n          timeout: options.timeout\n        })\n\n        return {\n          id,\n          multiaddrs: addrs\n        }\n      })\n    } catch (err) {\n      if (err.message.includes('not found')) {\n        return undefined\n      }\n\n      throw err\n    } finally {\n      log('findPeer finished: ' + id)\n    }\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async * getClosestPeers (key, options = {}) {\n    const keyStr = base58btc.encode(key).substring(1)\n\n    log('getClosestPeers starts:', keyStr)\n    options.timeout = options.timeout || DEFAULT_TIMEOUT\n\n    const onStart = defer()\n    const onFinish = defer()\n\n    this._httpQueue.add(() => {\n      onStart.resolve()\n      return onFinish.promise\n    })\n\n    try {\n      await onStart.promise\n\n      const peers = new Map()\n\n      for await (const result of this._client.dht.query(keyStr, {\n        timeout: options.timeout\n      })) {\n        switch (result.type) {\n          case 1: // Found Closer\n            // Track the addresses, so we can yield them when done\n            result.responses.forEach(response => {\n              peers.set(response.id, {\n                id: PeerId.parse(response.id),\n                multiaddrs: response.addrs\n              })\n            })\n            break\n          case 2: // Final Peer\n            yield peers.get(result.id.string) || {\n              id: PeerId.createFromCID(result.id),\n              multiaddrs: []\n            }\n            break\n          default:\n            log('getClosestPeers unhandled response', result)\n        }\n      }\n    } catch (err) {\n      log.error('getClosestPeers errored:', err)\n      throw err\n    } finally {\n      onFinish.resolve()\n      log('getClosestPeers finished:', keyStr)\n    }\n  }\n}\n\nmodule.exports = DelegatedPeerRouting\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}