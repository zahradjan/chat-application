{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst {\n  concat: uint8arraysConcat\n} = require('uint8arrays/concat');\n\nconst {\n  fromString: uint8arraysFromString\n} = require('uint8arrays/from-string'); // @ts-ignore libp2p-crypto does not support types\n\n\nconst cryptoKeys = require('libp2p-crypto/src/keys');\n\nconst PeerId = require('peer-id');\n\nconst varint = require('varint');\n\nconst {\n  equals: uint8arraysEquals\n} = require('uint8arrays/equals');\n\nconst {\n  codes\n} = require('../../errors');\n\nconst {\n  Envelope: Protobuf\n} = require('./envelope');\n/**\n * @typedef {import('libp2p-interfaces/src/record/types').Record} Record\n */\n\n\nclass Envelope {\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   *\n   * @class\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {Uint8Array} params.payloadType\n   * @param {Uint8Array} params.payload - marshaled record\n   * @param {Uint8Array} params.signature - signature of the domain string :: type hint :: payload.\n   */\n  constructor(_ref) {\n    let {\n      peerId,\n      payloadType,\n      payload,\n      signature\n    } = _ref;\n    this.peerId = peerId;\n    this.payloadType = payloadType;\n    this.payload = payload;\n    this.signature = signature; // Cache\n\n    this._marshal = undefined;\n  }\n  /**\n   * Marshal the envelope content.\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  marshal() {\n    if (this._marshal) {\n      return this._marshal;\n    }\n\n    const publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey);\n    this._marshal = Protobuf.encode({\n      publicKey: publicKey,\n      payloadType: this.payloadType,\n      payload: this.payload,\n      signature: this.signature\n    }).finish();\n    return this._marshal;\n  }\n  /**\n   * Verifies if the other Envelope is identical to this one.\n   *\n   * @param {Envelope} other\n   * @returns {boolean}\n   */\n\n\n  equals(other) {\n    return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) && uint8arraysEquals(this.payloadType, other.payloadType) && uint8arraysEquals(this.payload, other.payload) && uint8arraysEquals(this.signature, other.signature);\n  }\n  /**\n   * Validate envelope data signature for the given domain.\n   *\n   * @param {string} domain\n   * @returns {Promise<boolean>}\n   */\n\n\n  validate(domain) {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);\n    return this.peerId.pubKey.verify(signData, this.signature);\n  }\n\n}\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature.\n *\n * @param {string} domain\n * @param {Uint8Array} payloadType\n * @param {Uint8Array} payload\n * @returns {Uint8Array}\n */\n\n\nconst formatSignaturePayload = (domain, payloadType, payload) => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n  const domainUint8Array = uint8arraysFromString(domain);\n  const domainLength = varint.encode(domainUint8Array.byteLength);\n  const payloadTypeLength = varint.encode(payloadType.length);\n  const payloadLength = varint.encode(payload.length);\n  return uint8arraysConcat([new Uint8Array(domainLength), domainUint8Array, new Uint8Array(payloadTypeLength), payloadType, new Uint8Array(payloadLength), payload]);\n};\n/**\n * Unmarshal a serialized Envelope protobuf message.\n *\n * @param {Uint8Array} data\n * @returns {Promise<Envelope>}\n */\n\n\nEnvelope.createFromProtobuf = async data => {\n  const envelopeData = Protobuf.decode(data);\n  const peerId = await PeerId.createFromPubKey(envelopeData.publicKey);\n  return new Envelope({\n    peerId,\n    payloadType: envelopeData.payloadType,\n    payload: envelopeData.payload,\n    signature: envelopeData.signature\n  });\n};\n/**\n * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n * and signs it with the given peerId's private key.\n *\n * @async\n * @param {Record} record\n * @param {PeerId} peerId\n * @returns {Promise<Envelope>}\n */\n\n\nEnvelope.seal = async (record, peerId) => {\n  const domain = record.domain;\n  const payloadType = record.codec;\n  const payload = record.marshal();\n  const signData = formatSignaturePayload(domain, payloadType, payload);\n  const signature = await peerId.privKey.sign(signData);\n  return new Envelope({\n    peerId,\n    payloadType,\n    payload,\n    signature\n  });\n};\n/**\n * Open and certify a given marshalled envelope.\n * Data is unmarshalled and the signature validated for the given domain.\n *\n * @param {Uint8Array} data\n * @param {string} domain\n * @returns {Promise<Envelope>}\n */\n\n\nEnvelope.openAndCertify = async (data, domain) => {\n  const envelope = await Envelope.createFromProtobuf(data);\n  const valid = await envelope.validate(domain);\n\n  if (!valid) {\n    throw errCode(new Error('envelope signature is not valid for the given domain'), codes.ERR_SIGNATURE_NOT_VALID);\n  }\n\n  return envelope;\n};\n\nmodule.exports = Envelope;","map":{"version":3,"names":["errCode","require","concat","uint8arraysConcat","fromString","uint8arraysFromString","cryptoKeys","PeerId","varint","equals","uint8arraysEquals","codes","Envelope","Protobuf","constructor","peerId","payloadType","payload","signature","_marshal","undefined","marshal","publicKey","marshalPublicKey","pubKey","encode","finish","other","bytes","validate","domain","signData","formatSignaturePayload","verify","domainUint8Array","domainLength","byteLength","payloadTypeLength","length","payloadLength","Uint8Array","createFromProtobuf","data","envelopeData","decode","createFromPubKey","seal","record","codec","privKey","sign","openAndCertify","envelope","valid","Error","ERR_SIGNATURE_NOT_VALID","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/record/envelope/index.js"],"sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst { concat: uint8arraysConcat } = require('uint8arrays/concat')\nconst { fromString: uint8arraysFromString } = require('uint8arrays/from-string')\n// @ts-ignore libp2p-crypto does not support types\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst PeerId = require('peer-id')\nconst varint = require('varint')\nconst { equals: uint8arraysEquals } = require('uint8arrays/equals')\n\nconst { codes } = require('../../errors')\nconst { Envelope: Protobuf } = require('./envelope')\n\n/**\n * @typedef {import('libp2p-interfaces/src/record/types').Record} Record\n */\n\nclass Envelope {\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   *\n   * @class\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {Uint8Array} params.payloadType\n   * @param {Uint8Array} params.payload - marshaled record\n   * @param {Uint8Array} params.signature - signature of the domain string :: type hint :: payload.\n   */\n  constructor ({ peerId, payloadType, payload, signature }) {\n    this.peerId = peerId\n    this.payloadType = payloadType\n    this.payload = payload\n    this.signature = signature\n\n    // Cache\n    this._marshal = undefined\n  }\n\n  /**\n   * Marshal the envelope content.\n   *\n   * @returns {Uint8Array}\n   */\n  marshal () {\n    if (this._marshal) {\n      return this._marshal\n    }\n\n    const publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey)\n\n    this._marshal = Protobuf.encode({\n      publicKey: publicKey,\n      payloadType: this.payloadType,\n      payload: this.payload,\n      signature: this.signature\n    }).finish()\n\n    return this._marshal\n  }\n\n  /**\n   * Verifies if the other Envelope is identical to this one.\n   *\n   * @param {Envelope} other\n   * @returns {boolean}\n   */\n  equals (other) {\n    return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) &&\n      uint8arraysEquals(this.payloadType, other.payloadType) &&\n      uint8arraysEquals(this.payload, other.payload) &&\n      uint8arraysEquals(this.signature, other.signature)\n  }\n\n  /**\n   * Validate envelope data signature for the given domain.\n   *\n   * @param {string} domain\n   * @returns {Promise<boolean>}\n   */\n  validate (domain) {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload)\n\n    return this.peerId.pubKey.verify(signData, this.signature)\n  }\n}\n\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature.\n *\n * @param {string} domain\n * @param {Uint8Array} payloadType\n * @param {Uint8Array} payload\n * @returns {Uint8Array}\n */\nconst formatSignaturePayload = (domain, payloadType, payload) => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n\n  const domainUint8Array = uint8arraysFromString(domain)\n  const domainLength = varint.encode(domainUint8Array.byteLength)\n  const payloadTypeLength = varint.encode(payloadType.length)\n  const payloadLength = varint.encode(payload.length)\n\n  return uint8arraysConcat([\n    new Uint8Array(domainLength),\n    domainUint8Array,\n    new Uint8Array(payloadTypeLength),\n    payloadType,\n    new Uint8Array(payloadLength),\n    payload\n  ])\n}\n\n/**\n * Unmarshal a serialized Envelope protobuf message.\n *\n * @param {Uint8Array} data\n * @returns {Promise<Envelope>}\n */\nEnvelope.createFromProtobuf = async (data) => {\n  const envelopeData = Protobuf.decode(data)\n  const peerId = await PeerId.createFromPubKey(envelopeData.publicKey)\n\n  return new Envelope({\n    peerId,\n    payloadType: envelopeData.payloadType,\n    payload: envelopeData.payload,\n    signature: envelopeData.signature\n  })\n}\n\n/**\n * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n * and signs it with the given peerId's private key.\n *\n * @async\n * @param {Record} record\n * @param {PeerId} peerId\n * @returns {Promise<Envelope>}\n */\nEnvelope.seal = async (record, peerId) => {\n  const domain = record.domain\n  const payloadType = record.codec\n  const payload = record.marshal()\n\n  const signData = formatSignaturePayload(domain, payloadType, payload)\n  const signature = await peerId.privKey.sign(signData)\n\n  return new Envelope({\n    peerId,\n    payloadType,\n    payload,\n    signature\n  })\n}\n\n/**\n * Open and certify a given marshalled envelope.\n * Data is unmarshalled and the signature validated for the given domain.\n *\n * @param {Uint8Array} data\n * @param {string} domain\n * @returns {Promise<Envelope>}\n */\nEnvelope.openAndCertify = async (data, domain) => {\n  const envelope = await Envelope.createFromProtobuf(data)\n  const valid = await envelope.validate(domain)\n\n  if (!valid) {\n    throw errCode(new Error('envelope signature is not valid for the given domain'), codes.ERR_SIGNATURE_NOT_VALID)\n  }\n\n  return envelope\n}\n\nmodule.exports = Envelope\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}