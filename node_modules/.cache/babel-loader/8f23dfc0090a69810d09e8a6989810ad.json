{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:dialer'), {\n  error: debug('libp2p:dialer:err')\n});\n\nconst errCode = require('err-code');\n\nconst {\n  Multiaddr\n} = require('multiaddr'); // @ts-ignore timeout-abourt-controles does not export types\n\n\nconst TimeoutController = require('timeout-abort-controller');\n\nconst {\n  AbortError\n} = require('abortable-iterator');\n\nconst {\n  anySignal\n} = require('any-signal');\n\nconst DialRequest = require('./dial-request');\n\nconst {\n  publicAddressesFirst\n} = require('libp2p-utils/src/address-sort');\n\nconst getPeer = require('../get-peer');\n\nconst {\n  codes\n} = require('../errors');\n\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS,\n  MAX_ADDRS_TO_DIAL\n} = require('../constants');\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../peer-store')} PeerStore\n * @typedef {import('../peer-store/address-book').Address} Address\n * @typedef {import('../transport-manager')} TransportManager\n */\n\n/**\n * @typedef {Object} DialerProperties\n * @property {PeerStore} peerStore\n * @property {TransportManager} transportManager\n *\n * @typedef {(addr:Multiaddr) => Promise<string[]>} Resolver\n *\n * @typedef {Object} DialerOptions\n * @property {(addresses: Address[]) => Address[]} [options.addressSorter = publicAddressesFirst] - Sort the known addresses of a peer before trying to dial.\n * @property {number} [maxParallelDials = MAX_PARALLEL_DIALS] - Number of max concurrent dials.\n * @property {number} [maxAddrsToDial = MAX_ADDRS_TO_DIAL] - Number of max addresses to dial for a given peer.\n * @property {number} [maxDialsPerPeer = MAX_PER_PEER_DIALS] - Number of max concurrent dials per peer.\n * @property {number} [dialTimeout = DIAL_TIMEOUT] - How long a dial attempt is allowed to take.\n * @property {Record<string, Resolver>} [resolvers = {}] - multiaddr resolvers to use when dialing\n *\n * @typedef DialTarget\n * @property {string} id\n * @property {Multiaddr[]} addrs\n *\n * @typedef PendingDial\n * @property {DialRequest} dialRequest\n * @property {TimeoutController} controller\n * @property {Promise<Connection>} promise\n * @property {function():void} destroy\n */\n\n\nclass Dialer {\n  /**\n   * @class\n   * @param {DialerProperties & DialerOptions} options\n   */\n  constructor(_ref) {\n    let {\n      transportManager,\n      peerStore,\n      addressSorter = publicAddressesFirst,\n      maxParallelDials = MAX_PARALLEL_DIALS,\n      maxAddrsToDial = MAX_ADDRS_TO_DIAL,\n      dialTimeout = DIAL_TIMEOUT,\n      maxDialsPerPeer = MAX_PER_PEER_DIALS,\n      resolvers = {}\n    } = _ref;\n    this.transportManager = transportManager;\n    this.peerStore = peerStore;\n    this.addressSorter = addressSorter;\n    this.maxParallelDials = maxParallelDials;\n    this.maxAddrsToDial = maxAddrsToDial;\n    this.timeout = dialTimeout;\n    this.maxDialsPerPeer = maxDialsPerPeer;\n    this.tokens = [...new Array(maxParallelDials)].map((_, index) => index);\n    this._pendingDials = new Map();\n    this._pendingDialTargets = new Map();\n\n    for (const [key, value] of Object.entries(resolvers)) {\n      Multiaddr.resolvers.set(key, value);\n    }\n  }\n  /**\n   * Clears any pending dials\n   */\n\n\n  destroy() {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort();\n      } catch (err) {\n        log.error(err);\n      }\n    }\n\n    this._pendingDials.clear();\n\n    for (const pendingTarget of this._pendingDialTargets.values()) {\n      pendingTarget.reject(new AbortError('Dialer was destroyed'));\n    }\n\n    this._pendingDialTargets.clear();\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n\n\n  async connectToPeer(peer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const dialTarget = await this._createCancellableDialTarget(peer);\n\n    if (!dialTarget.addrs.length) {\n      throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES);\n    }\n\n    const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);\n\n    try {\n      const connection = await pendingDial.promise;\n      log('dial succeeded to %s', dialTarget.id);\n      return connection;\n    } catch (err) {\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT;\n      }\n\n      log.error(err);\n      throw err;\n    } finally {\n      pendingDial.destroy();\n    }\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @returns {Promise<DialTarget>}\n   */\n\n\n  async _createCancellableDialTarget(peer) {\n    // Make dial target promise cancellable\n    const id = `${parseInt(String(Math.random() * 1e9), 10).toString() + Date.now()}`;\n    const cancellablePromise = new Promise((resolve, reject) => {\n      this._pendingDialTargets.set(id, {\n        resolve,\n        reject\n      });\n    });\n    const dialTarget = await Promise.race([this._createDialTarget(peer), cancellablePromise]);\n\n    this._pendingDialTargets.delete(id);\n\n    return dialTarget;\n  }\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * Multiaddrs not supported by the available transports will be filtered out.\n   *\n   * @private\n   * @param {PeerId|Multiaddr|string} peer - A PeerId or Multiaddr\n   * @returns {Promise<DialTarget>}\n   */\n\n\n  async _createDialTarget(peer) {\n    const {\n      id,\n      multiaddrs\n    } = getPeer(peer);\n\n    if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs);\n    }\n\n    let knownAddrs = this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter) || []; // If received a multiaddr to dial, it should be the first to use\n    // But, if we know other multiaddrs for the peer, we should try them too.\n\n    if (Multiaddr.isMultiaddr(peer)) {\n      knownAddrs = knownAddrs.filter(addr => !peer.equals(addr));\n      knownAddrs.unshift(peer);\n    }\n    /** @type {Multiaddr[]} */\n\n\n    const addrs = [];\n\n    for (const a of knownAddrs) {\n      const resolvedAddrs = await this._resolve(a);\n      resolvedAddrs.forEach(ra => addrs.push(ra));\n    } // Multiaddrs not supported by the available transports will be filtered out.\n\n\n    const supportedAddrs = addrs.filter(a => this.transportManager.transportForMultiaddr(a));\n\n    if (supportedAddrs.length > this.maxAddrsToDial) {\n      this.peerStore.delete(id);\n      throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES);\n    }\n\n    return {\n      id: id.toB58String(),\n      addrs: supportedAddrs\n    };\n  }\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   *\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {PendingDial}\n   */\n\n\n  _createPendingDial(dialTarget) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n      return this.transportManager.dial(addr, options);\n    };\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    }); // Combine the timeout signal and options.signal, if provided\n\n    const timeoutController = new TimeoutController(this.timeout);\n    const signals = [timeoutController.signal];\n    options.signal && signals.push(options.signal);\n    const signal = anySignal(signals);\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options,\n        signal\n      }),\n      destroy: () => {\n        timeoutController.clear();\n\n        this._pendingDials.delete(dialTarget.id);\n      }\n    };\n\n    this._pendingDials.set(dialTarget.id, pendingDial);\n\n    return pendingDial;\n  }\n  /**\n   * @param {number} num\n   */\n\n\n  getTokens(num) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);\n    const tokens = this.tokens.splice(0, total);\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n    return tokens;\n  }\n  /**\n   * @param {number} token\n   */\n\n\n  releaseToken(token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return;\n    log('token %d released', token);\n    this.tokens.push(token);\n  }\n  /**\n   * Resolve multiaddr recursively.\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n\n\n  async _resolve(ma) {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr'); // Multiaddr is not resolvable? End recursion!\n\n    if (!resolvableProto) {\n      return [ma];\n    }\n\n    const resolvedMultiaddrs = await this._resolveRecord(ma);\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(nm => {\n      return this._resolve(nm);\n    }));\n    const addrs = recursiveMultiaddrs.flat();\n    return addrs.reduce((array, newM) => {\n      if (!array.find(m => m.equals(newM))) {\n        array.push(newM);\n      }\n\n      return array;\n    },\n    /** @type  {Multiaddr[]} */\n    []);\n  }\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n\n\n  async _resolveRecord(ma) {\n    try {\n      ma = new Multiaddr(ma.toString()); // Use current multiaddr module\n\n      const multiaddrs = await ma.resolve();\n      return multiaddrs;\n    } catch (_) {\n      log.error(`multiaddr ${ma} could not be resolved`);\n      return [];\n    }\n  }\n\n}\n\nmodule.exports = Dialer;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errCode","Multiaddr","TimeoutController","AbortError","anySignal","DialRequest","publicAddressesFirst","getPeer","codes","DIAL_TIMEOUT","MAX_PARALLEL_DIALS","MAX_PER_PEER_DIALS","MAX_ADDRS_TO_DIAL","Dialer","constructor","transportManager","peerStore","addressSorter","maxParallelDials","maxAddrsToDial","dialTimeout","maxDialsPerPeer","resolvers","timeout","tokens","Array","map","_","index","_pendingDials","Map","_pendingDialTargets","key","value","entries","set","destroy","dial","values","controller","abort","err","clear","pendingTarget","reject","connectToPeer","peer","options","dialTarget","_createCancellableDialTarget","addrs","length","Error","ERR_NO_VALID_ADDRESSES","pendingDial","get","id","_createPendingDial","connection","promise","signal","aborted","code","ERR_TIMEOUT","parseInt","String","Math","random","toString","Date","now","cancellablePromise","Promise","resolve","race","_createDialTarget","delete","multiaddrs","addressBook","add","knownAddrs","getMultiaddrsForPeer","isMultiaddr","filter","addr","equals","unshift","a","resolvedAddrs","_resolve","forEach","ra","push","supportedAddrs","transportForMultiaddr","ERR_TOO_MANY_ADDRESSES","toB58String","dialAction","ERR_ALREADY_ABORTED","dialRequest","dialer","timeoutController","signals","run","getTokens","num","total","min","splice","releaseToken","token","indexOf","ma","resolvableProto","protoNames","includes","resolvedMultiaddrs","_resolveRecord","recursiveMultiaddrs","all","nm","flat","reduce","array","newM","find","m","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/dialer/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:dialer'), {\n  error: debug('libp2p:dialer:err')\n})\nconst errCode = require('err-code')\nconst { Multiaddr } = require('multiaddr')\n// @ts-ignore timeout-abourt-controles does not export types\nconst TimeoutController = require('timeout-abort-controller')\nconst { AbortError } = require('abortable-iterator')\nconst { anySignal } = require('any-signal')\n\nconst DialRequest = require('./dial-request')\nconst { publicAddressesFirst } = require('libp2p-utils/src/address-sort')\nconst getPeer = require('../get-peer')\n\nconst { codes } = require('../errors')\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS,\n  MAX_ADDRS_TO_DIAL\n} = require('../constants')\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../peer-store')} PeerStore\n * @typedef {import('../peer-store/address-book').Address} Address\n * @typedef {import('../transport-manager')} TransportManager\n */\n\n/**\n * @typedef {Object} DialerProperties\n * @property {PeerStore} peerStore\n * @property {TransportManager} transportManager\n *\n * @typedef {(addr:Multiaddr) => Promise<string[]>} Resolver\n *\n * @typedef {Object} DialerOptions\n * @property {(addresses: Address[]) => Address[]} [options.addressSorter = publicAddressesFirst] - Sort the known addresses of a peer before trying to dial.\n * @property {number} [maxParallelDials = MAX_PARALLEL_DIALS] - Number of max concurrent dials.\n * @property {number} [maxAddrsToDial = MAX_ADDRS_TO_DIAL] - Number of max addresses to dial for a given peer.\n * @property {number} [maxDialsPerPeer = MAX_PER_PEER_DIALS] - Number of max concurrent dials per peer.\n * @property {number} [dialTimeout = DIAL_TIMEOUT] - How long a dial attempt is allowed to take.\n * @property {Record<string, Resolver>} [resolvers = {}] - multiaddr resolvers to use when dialing\n *\n * @typedef DialTarget\n * @property {string} id\n * @property {Multiaddr[]} addrs\n *\n * @typedef PendingDial\n * @property {DialRequest} dialRequest\n * @property {TimeoutController} controller\n * @property {Promise<Connection>} promise\n * @property {function():void} destroy\n */\n\nclass Dialer {\n  /**\n   * @class\n   * @param {DialerProperties & DialerOptions} options\n   */\n  constructor ({\n    transportManager,\n    peerStore,\n    addressSorter = publicAddressesFirst,\n    maxParallelDials = MAX_PARALLEL_DIALS,\n    maxAddrsToDial = MAX_ADDRS_TO_DIAL,\n    dialTimeout = DIAL_TIMEOUT,\n    maxDialsPerPeer = MAX_PER_PEER_DIALS,\n    resolvers = {}\n  }) {\n    this.transportManager = transportManager\n    this.peerStore = peerStore\n    this.addressSorter = addressSorter\n    this.maxParallelDials = maxParallelDials\n    this.maxAddrsToDial = maxAddrsToDial\n    this.timeout = dialTimeout\n    this.maxDialsPerPeer = maxDialsPerPeer\n    this.tokens = [...new Array(maxParallelDials)].map((_, index) => index)\n    this._pendingDials = new Map()\n    this._pendingDialTargets = new Map()\n\n    for (const [key, value] of Object.entries(resolvers)) {\n      Multiaddr.resolvers.set(key, value)\n    }\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  destroy () {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort()\n      } catch (err) {\n        log.error(err)\n      }\n    }\n    this._pendingDials.clear()\n\n    for (const pendingTarget of this._pendingDialTargets.values()) {\n      pendingTarget.reject(new AbortError('Dialer was destroyed'))\n    }\n    this._pendingDialTargets.clear()\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n  async connectToPeer (peer, options = {}) {\n    const dialTarget = await this._createCancellableDialTarget(peer)\n\n    if (!dialTarget.addrs.length) {\n      throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES)\n    }\n    const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options)\n\n    try {\n      const connection = await pendingDial.promise\n      log('dial succeeded to %s', dialTarget.id)\n      return connection\n    } catch (err) {\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT\n      }\n      log.error(err)\n      throw err\n    } finally {\n      pendingDial.destroy()\n    }\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @returns {Promise<DialTarget>}\n   */\n  async _createCancellableDialTarget (peer) {\n    // Make dial target promise cancellable\n    const id = `${(parseInt(String(Math.random() * 1e9), 10)).toString() + Date.now()}`\n    const cancellablePromise = new Promise((resolve, reject) => {\n      this._pendingDialTargets.set(id, { resolve, reject })\n    })\n\n    const dialTarget = await Promise.race([\n      this._createDialTarget(peer),\n      cancellablePromise\n    ])\n\n    this._pendingDialTargets.delete(id)\n\n    return dialTarget\n  }\n\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * Multiaddrs not supported by the available transports will be filtered out.\n   *\n   * @private\n   * @param {PeerId|Multiaddr|string} peer - A PeerId or Multiaddr\n   * @returns {Promise<DialTarget>}\n   */\n  async _createDialTarget (peer) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    let knownAddrs = this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter) || []\n\n    // If received a multiaddr to dial, it should be the first to use\n    // But, if we know other multiaddrs for the peer, we should try them too.\n    if (Multiaddr.isMultiaddr(peer)) {\n      knownAddrs = knownAddrs.filter((addr) => !peer.equals(addr))\n      knownAddrs.unshift(peer)\n    }\n\n    /** @type {Multiaddr[]} */\n    const addrs = []\n    for (const a of knownAddrs) {\n      const resolvedAddrs = await this._resolve(a)\n      resolvedAddrs.forEach(ra => addrs.push(ra))\n    }\n\n    // Multiaddrs not supported by the available transports will be filtered out.\n    const supportedAddrs = addrs.filter(a => this.transportManager.transportForMultiaddr(a))\n\n    if (supportedAddrs.length > this.maxAddrsToDial) {\n      this.peerStore.delete(id)\n      throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES)\n    }\n\n    return {\n      id: id.toB58String(),\n      addrs: supportedAddrs\n    }\n  }\n\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   *\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {PendingDial}\n   */\n  _createPendingDial (dialTarget, options = {}) {\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED)\n      return this.transportManager.dial(addr, options)\n    }\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    })\n\n    // Combine the timeout signal and options.signal, if provided\n    const timeoutController = new TimeoutController(this.timeout)\n    const signals = [timeoutController.signal]\n    options.signal && signals.push(options.signal)\n    const signal = anySignal(signals)\n\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options, signal }),\n      destroy: () => {\n        timeoutController.clear()\n        this._pendingDials.delete(dialTarget.id)\n      }\n    }\n    this._pendingDials.set(dialTarget.id, pendingDial)\n    return pendingDial\n  }\n\n  /**\n   * @param {number} num\n   */\n  getTokens (num) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length)\n    const tokens = this.tokens.splice(0, total)\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length)\n    return tokens\n  }\n\n  /**\n   * @param {number} token\n   */\n  releaseToken (token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return\n    log('token %d released', token)\n    this.tokens.push(token)\n  }\n\n  /**\n   * Resolve multiaddr recursively.\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n  async _resolve (ma) {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr')\n\n    // Multiaddr is not resolvable? End recursion!\n    if (!resolvableProto) {\n      return [ma]\n    }\n\n    const resolvedMultiaddrs = await this._resolveRecord(ma)\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map((nm) => {\n      return this._resolve(nm)\n    }))\n\n    const addrs = recursiveMultiaddrs.flat()\n    return addrs.reduce((array, newM) => {\n      if (!array.find(m => m.equals(newM))) {\n        array.push(newM)\n      }\n      return array\n    }, /** @type  {Multiaddr[]} */([]))\n  }\n\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n  async _resolveRecord (ma) {\n    try {\n      ma = new Multiaddr(ma.toString()) // Use current multiaddr module\n      const multiaddrs = await ma.resolve()\n      return multiaddrs\n    } catch (_) {\n      log.error(`multiaddr ${ma} could not be resolved`)\n      return []\n    }\n  }\n}\n\nmodule.exports = Dialer\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}