{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar cache = require('hashlru'); // @ts-ignore\n\n\nvar varint = require('varint');\n\nvar PeerId = require('peer-id');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar _require2 = require('p-queue'),\n    Queue = _require2.default;\n\nvar c = require('./constants');\n\nvar utils = require('./utils');\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\n\n\nvar Providers = /*#__PURE__*/function () {\n  /**\n   * @param {Datastore} datastore\n   * @param {PeerId} [self]\n   * @param {number} [cacheSize=256]\n   */\n  function Providers(datastore, self, cacheSize) {\n    _classCallCheck(this, Providers);\n\n    this.datastore = datastore;\n    this._log = utils.logger(self, 'providers');\n    /**\n     * How often invalid records are cleaned. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL;\n    /**\n     * How long is a provider valid for. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.provideValidity = c.PROVIDERS_VALIDITY;\n    /**\n     * LRU cache size\n     *\n     * @type {number}\n     */\n\n    this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE; // @ts-ignore hashlru types are wrong\n\n    this.providers = cache(this.lruCacheSize);\n    this.syncQueue = new Queue({\n      concurrency: 1\n    });\n  }\n  /**\n   * Start the provider cleanup service\n   */\n\n\n  _createClass(Providers, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      if (this._started) {\n        return;\n      }\n\n      this._started = true;\n      this._cleaner = setInterval(function () {\n        return _this._cleanup();\n      }, this.cleanupInterval);\n    }\n    /**\n     * Release any resources.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._started = false;\n\n      if (this._cleaner) {\n        clearInterval(this._cleaner);\n        this._cleaner = null;\n      }\n    }\n    /**\n     * Check all providers if they are still valid, and if not delete them.\n     *\n     * @returns {Promise<void>}\n     * @private\n     */\n\n  }, {\n    key: \"_cleanup\",\n    value: function _cleanup() {\n      var _this2 = this;\n\n      return this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var start, count, deleteCount, deleted, batch, query, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry, _parseProviderKey, cid, peerId, time, now, delta, expired, peers, _iterator3, _step3, _step3$value, _cid, _peers, key, provs, _iterator4, _step4, _peerId;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this2._log('start cleanup');\n\n                start = Date.now();\n                count = 0;\n                deleteCount = 0;\n                deleted = new Map();\n                batch = _this2.datastore.batch(); // Get all provider entries from the datastore\n\n                query = _this2.datastore.query({\n                  prefix: c.PROVIDERS_KEY_PREFIX\n                });\n                _iteratorAbruptCompletion = false;\n                _didIteratorError = false;\n                _context.prev = 9;\n                _iterator = _asyncIterator(query);\n\n              case 11:\n                _context.next = 13;\n                return _iterator.next();\n\n              case 13:\n                if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                  _context.next = 19;\n                  break;\n                }\n\n                entry = _step.value;\n\n                try {\n                  // Add a delete to the batch for each expired entry\n                  _parseProviderKey = parseProviderKey(entry.key), cid = _parseProviderKey.cid, peerId = _parseProviderKey.peerId;\n                  time = readTime(entry.value);\n                  now = Date.now();\n                  delta = now - time;\n                  expired = delta > _this2.provideValidity;\n\n                  _this2._log('comparing: %d - %d = %d > %d %s', now, time, delta, _this2.provideValidity, expired ? '(expired)' : '');\n\n                  if (expired) {\n                    deleteCount++;\n                    batch.delete(entry.key);\n                    peers = deleted.get(cid) || new Set();\n                    peers.add(peerId);\n                    deleted.set(cid, peers);\n                  }\n\n                  count++;\n                } catch (err) {\n                  _this2._log.error(err.message);\n                }\n\n              case 16:\n                _iteratorAbruptCompletion = false;\n                _context.next = 11;\n                break;\n\n              case 19:\n                _context.next = 25;\n                break;\n\n              case 21:\n                _context.prev = 21;\n                _context.t0 = _context[\"catch\"](9);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 25:\n                _context.prev = 25;\n                _context.prev = 26;\n\n                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                  _context.next = 30;\n                  break;\n                }\n\n                _context.next = 30;\n                return _iterator.return();\n\n              case 30:\n                _context.prev = 30;\n\n                if (!_didIteratorError) {\n                  _context.next = 33;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 33:\n                return _context.finish(30);\n\n              case 34:\n                return _context.finish(25);\n\n              case 35:\n                _this2._log('deleting %d / %d entries', deleteCount, count); // Commit the deletes to the datastore\n\n\n                if (!deleted.size) {\n                  _context.next = 39;\n                  break;\n                }\n\n                _context.next = 39;\n                return batch.commit();\n\n              case 39:\n                // Clear expired entries from the cache\n                _iterator3 = _createForOfIteratorHelper(deleted);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    _step3$value = _slicedToArray(_step3.value, 2), _cid = _step3$value[0], _peers = _step3$value[1];\n                    key = makeProviderKey(_cid);\n                    provs = _this2.providers.get(key);\n\n                    if (provs) {\n                      _iterator4 = _createForOfIteratorHelper(_peers);\n\n                      try {\n                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                          _peerId = _step4.value;\n                          provs.delete(_peerId);\n                        }\n                      } catch (err) {\n                        _iterator4.e(err);\n                      } finally {\n                        _iterator4.f();\n                      }\n\n                      if (provs.size === 0) {\n                        _this2.providers.remove(key);\n                      } else {\n                        _this2.providers.set(key, provs);\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                _this2._log('Cleanup successful (%dms)', Date.now() - start);\n\n              case 42:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[9, 21, 25, 35], [26,, 30, 34]]);\n      })));\n    }\n    /**\n     * Get the currently known provider peer ids for a given CID.\n     *\n     * @param {CID} cid\n     * @returns {Promise<Map<string, Date>>}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_getProvidersMap\",\n    value: function () {\n      var _getProvidersMap2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(cid) {\n        var cacheKey, provs;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                cacheKey = makeProviderKey(cid);\n                provs = this.providers.get(cacheKey);\n\n                if (provs) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.next = 5;\n                return loadProviders(this.datastore, cid);\n\n              case 5:\n                provs = _context2.sent;\n                this.providers.set(cacheKey, provs);\n\n              case 7:\n                return _context2.abrupt(\"return\", provs);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _getProvidersMap(_x) {\n        return _getProvidersMap2.apply(this, arguments);\n      }\n\n      return _getProvidersMap;\n    }()\n    /**\n     * Add a new provider for the given CID.\n     *\n     * @param {CID} cid\n     * @param {PeerId} provider\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"addProvider\",\n    value: function () {\n      var _addProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(cid, provider) {\n        var _this3 = this;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                  var provs, now, dsKey;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          _this3._log('addProvider %s', cid.toString());\n\n                          _context3.next = 3;\n                          return _this3._getProvidersMap(cid);\n\n                        case 3:\n                          provs = _context3.sent;\n\n                          _this3._log('loaded %s provs', provs.size);\n\n                          now = new Date();\n                          provs.set(utils.encodeBase32(provider.id), now);\n                          dsKey = makeProviderKey(cid);\n\n                          _this3.providers.set(dsKey, provs);\n\n                          return _context3.abrupt(\"return\", writeProviderEntry(_this3.datastore, cid, provider, now));\n\n                        case 10:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3);\n                }))));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function addProvider(_x2, _x3) {\n        return _addProvider.apply(this, arguments);\n      }\n\n      return addProvider;\n    }()\n    /**\n     * Get a list of providers for the given CID.\n     *\n     * @param {CID} cid\n     * @returns {Promise<Array<PeerId>>}\n     */\n\n  }, {\n    key: \"getProviders\",\n    value: function () {\n      var _getProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(cid) {\n        var _this4 = this;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n                  var provs;\n                  return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                    while (1) {\n                      switch (_context5.prev = _context5.next) {\n                        case 0:\n                          _this4._log('getProviders %s', cid.toString());\n\n                          _context5.next = 3;\n                          return _this4._getProvidersMap(cid);\n\n                        case 3:\n                          provs = _context5.sent;\n                          return _context5.abrupt(\"return\", _toConsumableArray(provs.keys()).map(function (base32PeerId) {\n                            return new PeerId(utils.decodeBase32(base32PeerId));\n                          }));\n\n                        case 5:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }\n                  }, _callee5);\n                }))));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getProviders(_x4) {\n        return _getProviders.apply(this, arguments);\n      }\n\n      return getProviders;\n    }()\n  }]);\n\n  return Providers;\n}();\n/**\n * Encode the given key its matching datastore key.\n *\n * @param {CID|string} cid - cid or base32 encoded string\n * @returns {string}\n *\n * @private\n */\n\n\nfunction makeProviderKey(cid) {\n  cid = typeof cid === 'string' ? cid : utils.encodeBase32(cid.bytes);\n  return c.PROVIDERS_KEY_PREFIX + cid;\n}\n/**\n * Write a provider into the given store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {PeerId} peer\n * @param {Date} time\n */\n\n\nfunction writeProviderEntry(_x5, _x6, _x7, _x8) {\n  return _writeProviderEntry.apply(this, arguments);\n}\n/**\n * Parse the CID and provider peer id from the key\n *\n * @param {import('interface-datastore').Key} key\n */\n\n\nfunction _writeProviderEntry() {\n  _writeProviderEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(store, cid, peer, time) {\n    var dsKey, key, buffer;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            // eslint-disable-line require-await\n            dsKey = [makeProviderKey(cid), '/', utils.encodeBase32(peer.id)].join('');\n            key = new Key(dsKey);\n            buffer = Uint8Array.from(varint.encode(time.getTime()));\n            return _context7.abrupt(\"return\", store.put(key, buffer));\n\n          case 4:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _writeProviderEntry.apply(this, arguments);\n}\n\nfunction parseProviderKey(key) {\n  var parts = key.toString().split('/');\n\n  if (parts.length !== 4) {\n    throw new Error('incorrectly formatted provider entry key in datastore: ' + key);\n  }\n\n  return {\n    cid: parts[2],\n    peerId: parts[3]\n  };\n}\n/**\n * Load providers for the given CID from the store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @returns {Promise<Map<PeerId, Date>>}\n *\n * @private\n */\n\n\nfunction loadProviders(_x9, _x10) {\n  return _loadProviders.apply(this, arguments);\n}\n/**\n * @param {Uint8Array} buf\n */\n\n\nfunction _loadProviders() {\n  _loadProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(store, cid) {\n    var providers, query, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, entry, _parseProviderKey2, peerId;\n\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            providers = new Map();\n            query = store.query({\n              prefix: makeProviderKey(cid)\n            });\n            _iteratorAbruptCompletion2 = false;\n            _didIteratorError2 = false;\n            _context8.prev = 4;\n            _iterator2 = _asyncIterator(query);\n\n          case 6:\n            _context8.next = 8;\n            return _iterator2.next();\n\n          case 8:\n            if (!(_iteratorAbruptCompletion2 = !(_step2 = _context8.sent).done)) {\n              _context8.next = 15;\n              break;\n            }\n\n            entry = _step2.value;\n            _parseProviderKey2 = parseProviderKey(entry.key), peerId = _parseProviderKey2.peerId;\n            providers.set(peerId, readTime(entry.value));\n\n          case 12:\n            _iteratorAbruptCompletion2 = false;\n            _context8.next = 6;\n            break;\n\n          case 15:\n            _context8.next = 21;\n            break;\n\n          case 17:\n            _context8.prev = 17;\n            _context8.t0 = _context8[\"catch\"](4);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context8.t0;\n\n          case 21:\n            _context8.prev = 21;\n            _context8.prev = 22;\n\n            if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n              _context8.next = 26;\n              break;\n            }\n\n            _context8.next = 26;\n            return _iterator2.return();\n\n          case 26:\n            _context8.prev = 26;\n\n            if (!_didIteratorError2) {\n              _context8.next = 29;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 29:\n            return _context8.finish(26);\n\n          case 30:\n            return _context8.finish(21);\n\n          case 31:\n            return _context8.abrupt(\"return\", providers);\n\n          case 32:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8, null, [[4, 17, 21, 31], [22,, 26, 30]]);\n  }));\n  return _loadProviders.apply(this, arguments);\n}\n\nfunction readTime(buf) {\n  return varint.decode(buf);\n}\n\nmodule.exports = Providers;","map":{"version":3,"names":["cache","require","varint","PeerId","Key","Queue","default","c","utils","Providers","datastore","self","cacheSize","_log","logger","cleanupInterval","PROVIDERS_CLEANUP_INTERVAL","provideValidity","PROVIDERS_VALIDITY","lruCacheSize","PROVIDERS_LRU_CACHE_SIZE","providers","syncQueue","concurrency","_started","_cleaner","setInterval","_cleanup","clearInterval","add","start","Date","now","count","deleteCount","deleted","Map","batch","query","prefix","PROVIDERS_KEY_PREFIX","entry","parseProviderKey","key","cid","peerId","time","readTime","value","delta","expired","delete","peers","get","Set","set","err","error","message","size","commit","makeProviderKey","provs","remove","cacheKey","loadProviders","provider","toString","_getProvidersMap","encodeBase32","id","dsKey","writeProviderEntry","keys","map","base32PeerId","decodeBase32","bytes","store","peer","join","buffer","Uint8Array","from","encode","getTime","put","parts","split","length","Error","buf","decode","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-kad-dht/src/providers.js"],"sourcesContent":["'use strict'\n\nconst cache = require('hashlru')\n// @ts-ignore\nconst varint = require('varint')\nconst PeerId = require('peer-id')\nconst { Key } = require('interface-datastore')\nconst { default: Queue } = require('p-queue')\nconst c = require('./constants')\nconst utils = require('./utils')\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\nclass Providers {\n  /**\n   * @param {Datastore} datastore\n   * @param {PeerId} [self]\n   * @param {number} [cacheSize=256]\n   */\n  constructor (datastore, self, cacheSize) {\n    this.datastore = datastore\n\n    this._log = utils.logger(self, 'providers')\n\n    /**\n     * How often invalid records are cleaned. (in seconds)\n     *\n     * @type {number}\n     */\n    this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL\n\n    /**\n     * How long is a provider valid for. (in seconds)\n     *\n     * @type {number}\n     */\n    this.provideValidity = c.PROVIDERS_VALIDITY\n\n    /**\n     * LRU cache size\n     *\n     * @type {number}\n     */\n    this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE\n\n    // @ts-ignore hashlru types are wrong\n    this.providers = cache(this.lruCacheSize)\n\n    this.syncQueue = new Queue({ concurrency: 1 })\n  }\n\n  /**\n   * Start the provider cleanup service\n   */\n  start () {\n    if (this._started) {\n      return\n    }\n\n    this._started = true\n\n    this._cleaner = setInterval(\n      () => this._cleanup(),\n      this.cleanupInterval\n    )\n  }\n\n  /**\n   * Release any resources.\n   */\n  stop () {\n    this._started = false\n\n    if (this._cleaner) {\n      clearInterval(this._cleaner)\n      this._cleaner = null\n    }\n  }\n\n  /**\n   * Check all providers if they are still valid, and if not delete them.\n   *\n   * @returns {Promise<void>}\n   * @private\n   */\n  _cleanup () {\n    return this.syncQueue.add(async () => {\n      this._log('start cleanup')\n      const start = Date.now()\n\n      let count = 0\n      let deleteCount = 0\n      const deleted = new Map()\n      const batch = this.datastore.batch()\n\n      // Get all provider entries from the datastore\n      const query = this.datastore.query({ prefix: c.PROVIDERS_KEY_PREFIX })\n      for await (const entry of query) {\n        try {\n          // Add a delete to the batch for each expired entry\n          const { cid, peerId } = parseProviderKey(entry.key)\n          const time = readTime(entry.value)\n          const now = Date.now()\n          const delta = now - time\n          const expired = delta > this.provideValidity\n          this._log('comparing: %d - %d = %d > %d %s',\n            now, time, delta, this.provideValidity, expired ? '(expired)' : '')\n          if (expired) {\n            deleteCount++\n            batch.delete(entry.key)\n            const peers = deleted.get(cid) || new Set()\n            peers.add(peerId)\n            deleted.set(cid, peers)\n          }\n          count++\n        } catch (err) {\n          this._log.error(err.message)\n        }\n      }\n      this._log('deleting %d / %d entries', deleteCount, count)\n\n      // Commit the deletes to the datastore\n      if (deleted.size) {\n        await batch.commit()\n      }\n\n      // Clear expired entries from the cache\n      for (const [cid, peers] of deleted) {\n        const key = makeProviderKey(cid)\n        const provs = this.providers.get(key)\n        if (provs) {\n          for (const peerId of peers) {\n            provs.delete(peerId)\n          }\n          if (provs.size === 0) {\n            this.providers.remove(key)\n          } else {\n            this.providers.set(key, provs)\n          }\n        }\n      }\n\n      this._log('Cleanup successful (%dms)', Date.now() - start)\n    })\n  }\n\n  /**\n   * Get the currently known provider peer ids for a given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Map<string, Date>>}\n   *\n   * @private\n   */\n  async _getProvidersMap (cid) {\n    const cacheKey = makeProviderKey(cid)\n    let provs = this.providers.get(cacheKey)\n    if (!provs) {\n      provs = await loadProviders(this.datastore, cid)\n      this.providers.set(cacheKey, provs)\n    }\n    return provs\n  }\n\n  /**\n   * Add a new provider for the given CID.\n   *\n   * @param {CID} cid\n   * @param {PeerId} provider\n   * @returns {Promise<void>}\n   */\n  async addProvider (cid, provider) { // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      this._log('addProvider %s', cid.toString())\n      const provs = await this._getProvidersMap(cid)\n\n      this._log('loaded %s provs', provs.size)\n      const now = new Date()\n      provs.set(utils.encodeBase32(provider.id), now)\n\n      const dsKey = makeProviderKey(cid)\n      this.providers.set(dsKey, provs)\n      return writeProviderEntry(this.datastore, cid, provider, now)\n    })\n  }\n\n  /**\n   * Get a list of providers for the given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Array<PeerId>>}\n   */\n  async getProviders (cid) { // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      this._log('getProviders %s', cid.toString())\n      const provs = await this._getProvidersMap(cid)\n      return [...provs.keys()].map((base32PeerId) => {\n        return new PeerId(utils.decodeBase32(base32PeerId))\n      })\n    })\n  }\n}\n\n/**\n * Encode the given key its matching datastore key.\n *\n * @param {CID|string} cid - cid or base32 encoded string\n * @returns {string}\n *\n * @private\n */\nfunction makeProviderKey (cid) {\n  cid = typeof cid === 'string' ? cid : utils.encodeBase32(cid.bytes)\n  return c.PROVIDERS_KEY_PREFIX + cid\n}\n\n/**\n * Write a provider into the given store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {PeerId} peer\n * @param {Date} time\n */\nasync function writeProviderEntry (store, cid, peer, time) { // eslint-disable-line require-await\n  const dsKey = [\n    makeProviderKey(cid),\n    '/',\n    utils.encodeBase32(peer.id)\n  ].join('')\n\n  const key = new Key(dsKey)\n  const buffer = Uint8Array.from(varint.encode(time.getTime()))\n  return store.put(key, buffer)\n}\n\n/**\n * Parse the CID and provider peer id from the key\n *\n * @param {import('interface-datastore').Key} key\n */\nfunction parseProviderKey (key) {\n  const parts = key.toString().split('/')\n  if (parts.length !== 4) {\n    throw new Error('incorrectly formatted provider entry key in datastore: ' + key)\n  }\n\n  return {\n    cid: parts[2],\n    peerId: parts[3]\n  }\n}\n\n/**\n * Load providers for the given CID from the store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @returns {Promise<Map<PeerId, Date>>}\n *\n * @private\n */\nasync function loadProviders (store, cid) {\n  const providers = new Map()\n  const query = store.query({ prefix: makeProviderKey(cid) })\n  for await (const entry of query) {\n    const { peerId } = parseProviderKey(entry.key)\n    providers.set(peerId, readTime(entry.value))\n  }\n  return providers\n}\n\n/**\n * @param {Uint8Array} buf\n */\nfunction readTime (buf) {\n  return varint.decode(buf)\n}\n\nmodule.exports = Providers\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}