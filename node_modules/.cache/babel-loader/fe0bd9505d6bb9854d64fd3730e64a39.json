{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XXFallbackHandshake = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst handshake_xx_1 = require(\"./handshake-xx\");\n\nconst utils_1 = require(\"./utils\");\n\nconst logger_1 = require(\"./logger\");\n\nconst encoder_1 = require(\"./encoder\");\n\nclass XXFallbackHandshake extends handshake_xx_1.XXHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {\n    super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n\n    if (ephemeralKeys) {\n      this.ephemeralKeys = ephemeralKeys;\n    }\n\n    this.initialMsg = initialMsg;\n  } // stage 0\n  // eslint-disable-next-line require-await\n\n\n  async propose() {\n    if (this.isInitiator) {\n      this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0), this.ephemeralKeys);\n      logger_1.logger('XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.');\n      logger_1.logLocalEphemeralKeys(this.session.hs.e);\n    } else {\n      logger_1.logger('XX Fallback Stage 0 - Responder decoding initial msg from IK.');\n      const receivedMessageBuffer = encoder_1.decode0(this.initialMsg);\n      const {\n        valid\n      } = this.xx.recvMessage(this.session, {\n        ne: receivedMessageBuffer.ne,\n        ns: buffer_1.Buffer.alloc(0),\n        ciphertext: buffer_1.Buffer.alloc(0)\n      });\n\n      if (!valid) {\n        throw new Error('xx fallback stage 0 decryption validation fail');\n      }\n\n      logger_1.logger('XX Fallback Stage 0 - Responder used received message from IK.');\n      logger_1.logRemoteEphemeralKey(this.session.hs.re);\n    }\n  } // stage 1\n\n\n  async exchange() {\n    if (this.isInitiator) {\n      const receivedMessageBuffer = encoder_1.decode1(this.initialMsg);\n      const {\n        plaintext,\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error('xx fallback stage 1 decryption validation fail');\n      }\n\n      logger_1.logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n      logger_1.logRemoteEphemeralKey(this.session.hs.re);\n      logger_1.logRemoteStaticKey(this.session.hs.rs);\n      logger_1.logger(\"Initiator going to check remote's signature...\");\n\n      try {\n        const decodedPayload = await utils_1.decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await utils_1.getPeerIdFromPayload(decodedPayload));\n        await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n      } catch (e) {\n        const err = e;\n        throw new Error(`Error occurred while verifying signed payload from responder: ${err.message}`);\n      }\n\n      logger_1.logger('All good with the signature!');\n    } else {\n      logger_1.logger('XX Fallback Stage 1 - Responder start');\n      await super.exchange();\n      logger_1.logger('XX Fallback Stage 1 - Responder end');\n    }\n  }\n\n}\n\nexports.XXFallbackHandshake = XXFallbackHandshake;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AAIA;;AACA;;AAEA;;AAGA,MAAaA,mBAAb,SAAyCC,0BAAzC,CAAoD;EAIlDC,YACEC,WADF,EAEEC,OAFF,EAGEC,QAHF,EAIEC,aAJF,EAKEC,UALF,EAMEC,UANF,EAOEC,UAPF,EAQEC,aARF,EASEC,SATF,EASgB;IAEd,MAAMR,WAAN,EAAmBC,OAAnB,EAA4BC,QAA5B,EAAsCC,aAAtC,EAAqDC,UAArD,EAAiEE,UAAjE,EAA6EE,SAA7E;;IACA,IAAID,aAAJ,EAAmB;MACjB,KAAKA,aAAL,GAAqBA,aAArB;IACD;;IACD,KAAKF,UAAL,GAAkBA,UAAlB;EACD,CApBiD,CAsBlD;EACA;;;EACoB,MAAPI,OAAO;IAClB,IAAI,KAAKT,WAAT,EAAsB;MACpB,KAAKU,EAAL,CAAQC,WAAR,CAAoB,KAAKC,OAAzB,EAAkCC,gBAAOC,KAAP,CAAa,CAAb,CAAlC,EAAmD,KAAKP,aAAxD;MACAQ,gBAAO,qFAAP;MACAA,+BAAsB,KAAKH,OAAL,CAAaI,EAAb,CAAgBC,CAAtC;IACD,CAJD,MAIO;MACLF,gBAAO,+DAAP;MACA,MAAMG,qBAAqB,GAAGC,kBAAQ,KAAKd,UAAb,CAA9B;MACA,MAAM;QAAEe;MAAF,IAAY,KAAKV,EAAL,CAAQW,WAAR,CAAoB,KAAKT,OAAzB,EAAkC;QAClDU,EAAE,EAAEJ,qBAAqB,CAACI,EADwB;QAElDC,EAAE,EAAEV,gBAAOC,KAAP,CAAa,CAAb,CAF8C;QAGlDU,UAAU,EAAEX,gBAAOC,KAAP,CAAa,CAAb;MAHsC,CAAlC,CAAlB;;MAKA,IAAI,CAACM,KAAL,EAAY;QACV,MAAM,IAAIK,KAAJ,CAAU,gDAAV,CAAN;MACD;;MACDV,gBAAO,gEAAP;MACAA,+BAAsB,KAAKH,OAAL,CAAaI,EAAb,CAAgBU,EAAtC;IACD;EACF,CA3CiD,CA6ClD;;;EACqB,MAARC,QAAQ;IACnB,IAAI,KAAK3B,WAAT,EAAsB;MACpB,MAAMkB,qBAAqB,GAAGC,kBAAQ,KAAKd,UAAb,CAA9B;MACA,MAAM;QAAEuB,SAAF;QAAaR;MAAb,IAAuB,KAAKV,EAAL,CAAQW,WAAR,CAAoB,KAAKT,OAAzB,EAAkCM,qBAAlC,CAA7B;;MACA,IAAI,CAACE,KAAL,EAAY;QACV,MAAM,IAAIK,KAAJ,CAAU,gDAAV,CAAN;MACD;;MACDV,gBAAO,gEAAP;MACAA,+BAAsB,KAAKH,OAAL,CAAaI,EAAb,CAAgBU,EAAtC;MACAX,4BAAmB,KAAKH,OAAL,CAAaI,EAAb,CAAgBa,EAAnC;MAEAd,gBAAO,gDAAP;;MACA,IAAI;QACF,MAAMe,cAAc,GAAG,MAAMC,sBAAcH,SAAd,CAA7B;QACA,KAAKtB,UAAL,GAAkB,KAAKA,UAAL,KAAmB,MAAMyB,6BAAqBD,cAArB,CAAzB,CAAlB;QACA,MAAMC,4BAAoB,KAAKnB,OAAL,CAAaI,EAAb,CAAgBa,EAApC,EAAwCC,cAAxC,EAAwD,KAAKxB,UAA7D,CAAN;QACA,KAAK0B,kBAAL,CAAwBF,cAAc,CAACG,IAAvC;MACD,CALD,CAKE,OAAOhB,CAAP,EAAU;QACV,MAAMiB,GAAG,GAAGjB,CAAZ;QACA,MAAM,IAAIQ,KAAJ,CAAU,iEAAiES,GAAG,CAACC,OAAO,EAAtF,CAAN;MACD;;MACDpB,gBAAO,8BAAP;IACD,CArBD,MAqBO;MACLA,gBAAO,uCAAP;MACA,MAAM,MAAMY,QAAN,EAAN;MACAZ,gBAAO,qCAAP;IACD;EACF;;AAzEiD;;AAApDqB","names":["XXFallbackHandshake","handshake_xx_1","constructor","isInitiator","payload","prologue","staticKeypair","connection","initialMsg","remotePeer","ephemeralKeys","handshake","propose","xx","sendMessage","session","buffer_1","alloc","logger_1","hs","e","receivedMessageBuffer","encoder_1","valid","recvMessage","ne","ns","ciphertext","Error","re","exchange","plaintext","rs","decodedPayload","utils_1","setRemoteEarlyData","data","err","message","exports"],"sourceRoot":"","sources":["../../src/handshake-xx-fallback.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}