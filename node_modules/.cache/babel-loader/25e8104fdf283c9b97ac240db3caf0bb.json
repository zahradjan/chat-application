{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _require = require('uint8arrays/concat'),\n    concat = _require.concat;\n\nvar _require2 = require('uint8arrays/from-string'),\n    fromString = _require2.fromString;\n\nvar webcrypto = require('../webcrypto'); // Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\n\n/**\n *\n * @param {object} [options]\n * @param {string} [options.algorithm=AES-GCM]\n * @param {number} [options.nonceLength=12]\n * @param {number} [options.keyLength=16]\n * @param {string} [options.digest=sha256]\n * @param {number} [options.saltLength=16]\n * @param {number} [options.iterations=32767]\n * @returns {*}\n */\n\n\nfunction create() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$algorithm = _ref.algorithm,\n      algorithm = _ref$algorithm === void 0 ? 'AES-GCM' : _ref$algorithm,\n      _ref$nonceLength = _ref.nonceLength,\n      nonceLength = _ref$nonceLength === void 0 ? 12 : _ref$nonceLength,\n      _ref$keyLength = _ref.keyLength,\n      keyLength = _ref$keyLength === void 0 ? 16 : _ref$keyLength,\n      _ref$digest = _ref.digest,\n      digest = _ref$digest === void 0 ? 'SHA-256' : _ref$digest,\n      _ref$saltLength = _ref.saltLength,\n      saltLength = _ref$saltLength === void 0 ? 16 : _ref$saltLength,\n      _ref$iterations = _ref.iterations,\n      iterations = _ref$iterations === void 0 ? 32767 : _ref$iterations;\n\n  var crypto = webcrypto.get();\n  keyLength *= 8; // Browser crypto uses bits instead of bytes\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to encrypt the data.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n\n  function encrypt(_x, _x2) {\n    return _encrypt.apply(this, arguments);\n  }\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to decrypt the data. The options used to create\n   * this decryption cipher must be the same as those used to create\n   * the encryption cipher.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  function _encrypt() {\n    _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data, password) {\n      var salt, nonce, aesGcm, deriveParams, rawKey, cryptoKey, ciphertext;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // eslint-disable-line require-await\n              salt = crypto.getRandomValues(new Uint8Array(saltLength));\n              nonce = crypto.getRandomValues(new Uint8Array(nonceLength));\n              aesGcm = {\n                name: algorithm,\n                iv: nonce\n              }; // Derive a key using PBKDF2.\n\n              deriveParams = {\n                name: 'PBKDF2',\n                salt: salt,\n                iterations: iterations,\n                hash: {\n                  name: digest\n                }\n              };\n              _context.next = 6;\n              return crypto.subtle.importKey('raw', fromString(password), {\n                name: 'PBKDF2'\n              }, false, ['deriveKey', 'deriveBits']);\n\n            case 6:\n              rawKey = _context.sent;\n              _context.next = 9;\n              return crypto.subtle.deriveKey(deriveParams, rawKey, {\n                name: algorithm,\n                length: keyLength\n              }, true, ['encrypt']);\n\n            case 9:\n              cryptoKey = _context.sent;\n              _context.next = 12;\n              return crypto.subtle.encrypt(aesGcm, cryptoKey, data);\n\n            case 12:\n              ciphertext = _context.sent;\n              return _context.abrupt(\"return\", concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]));\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return _encrypt.apply(this, arguments);\n  }\n\n  function decrypt(_x3, _x4) {\n    return _decrypt.apply(this, arguments);\n  }\n\n  function _decrypt() {\n    _decrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(data, password) {\n      var salt, nonce, ciphertext, aesGcm, deriveParams, rawKey, cryptoKey, plaintext;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              salt = data.slice(0, saltLength);\n              nonce = data.slice(saltLength, saltLength + nonceLength);\n              ciphertext = data.slice(saltLength + nonceLength);\n              aesGcm = {\n                name: algorithm,\n                iv: nonce\n              }; // Derive the key using PBKDF2.\n\n              deriveParams = {\n                name: 'PBKDF2',\n                salt: salt,\n                iterations: iterations,\n                hash: {\n                  name: digest\n                }\n              };\n              _context2.next = 7;\n              return crypto.subtle.importKey('raw', fromString(password), {\n                name: 'PBKDF2'\n              }, false, ['deriveKey', 'deriveBits']);\n\n            case 7:\n              rawKey = _context2.sent;\n              _context2.next = 10;\n              return crypto.subtle.deriveKey(deriveParams, rawKey, {\n                name: algorithm,\n                length: keyLength\n              }, true, ['decrypt']);\n\n            case 10:\n              cryptoKey = _context2.sent;\n              _context2.next = 13;\n              return crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext);\n\n            case 13:\n              plaintext = _context2.sent;\n              return _context2.abrupt(\"return\", new Uint8Array(plaintext));\n\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return _decrypt.apply(this, arguments);\n  }\n\n  return {\n    encrypt: encrypt,\n    decrypt: decrypt\n  };\n}\n\nmodule.exports = {\n  create: create\n};","map":{"version":3,"names":["require","concat","fromString","webcrypto","create","algorithm","nonceLength","keyLength","digest","saltLength","iterations","crypto","get","encrypt","data","password","salt","getRandomValues","Uint8Array","nonce","aesGcm","name","iv","deriveParams","hash","subtle","importKey","rawKey","deriveKey","length","cryptoKey","ciphertext","decrypt","slice","plaintext","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js"],"sourcesContent":["'use strict'\n\nconst { concat } = require('uint8arrays/concat')\nconst { fromString } = require('uint8arrays/from-string')\n\nconst webcrypto = require('../webcrypto')\n\n// Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\n\n/**\n *\n * @param {object} [options]\n * @param {string} [options.algorithm=AES-GCM]\n * @param {number} [options.nonceLength=12]\n * @param {number} [options.keyLength=16]\n * @param {string} [options.digest=sha256]\n * @param {number} [options.saltLength=16]\n * @param {number} [options.iterations=32767]\n * @returns {*}\n */\nfunction create ({\n  algorithm = 'AES-GCM',\n  nonceLength = 12,\n  keyLength = 16,\n  digest = 'SHA-256',\n  saltLength = 16,\n  iterations = 32767\n} = {}) {\n  const crypto = webcrypto.get()\n  keyLength *= 8 // Browser crypto uses bits instead of bytes\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to encrypt the data.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n  async function encrypt (data, password) { // eslint-disable-line require-await\n    const salt = crypto.getRandomValues(new Uint8Array(saltLength))\n    const nonce = crypto.getRandomValues(new Uint8Array(nonceLength))\n    const aesGcm = { name: algorithm, iv: nonce }\n\n    // Derive a key using PBKDF2.\n    const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), { name: 'PBKDF2' }, false, ['deriveKey', 'deriveBits'])\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['encrypt'])\n\n    // Encrypt the string.\n    const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data)\n    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)])\n  }\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to decrypt the data. The options used to create\n   * this decryption cipher must be the same as those used to create\n   * the encryption cipher.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n  async function decrypt (data, password) {\n    const salt = data.slice(0, saltLength)\n    const nonce = data.slice(saltLength, saltLength + nonceLength)\n    const ciphertext = data.slice(saltLength + nonceLength)\n    const aesGcm = { name: algorithm, iv: nonce }\n\n    // Derive the key using PBKDF2.\n    const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), { name: 'PBKDF2' }, false, ['deriveKey', 'deriveBits'])\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['decrypt'])\n\n    // Decrypt the string.\n    const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext)\n    return new Uint8Array(plaintext)\n  }\n\n  return {\n    encrypt,\n    decrypt\n  }\n}\n\nmodule.exports = {\n  create\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}