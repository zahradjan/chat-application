{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar log = require('debug')('ipfs:mfs:touch');\n\nvar errCode = require('err-code');\n\nvar _require = require('ipfs-unixfs'),\n    UnixFS = _require.UnixFS;\n\nvar toTrail = require('./utils/to-trail');\n\nvar addLink = require('./utils/add-link');\n\nvar updateTree = require('./utils/update-tree');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar dagPb = require('@ipld/dag-pb');\n\nvar _require2 = require('multiformats/cid'),\n    CID = _require2.CID;\n\nvar withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nvar defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  cidVersion: 0,\n  hashAlg: 'sha2-256'\n};\n/**\n * @param {MfsContext} context\n */\n\nmodule.exports = function (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"touch\"]}\n   */\n  function mfsTouch(_x) {\n    return _mfsTouch.apply(this, arguments);\n  }\n\n  function _mfsTouch() {\n    _mfsTouch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(path) {\n      var options,\n          settings,\n          _yield$toMfsPath,\n          cid,\n          mfsDirectory,\n          name,\n          exists,\n          hashAlg,\n          hasher,\n          updatedBlock,\n          updatedCid,\n          cidVersion,\n          metadata,\n          hash,\n          block,\n          node,\n          _metadata,\n          _hash,\n          trail,\n          parent,\n          parentCid,\n          parentBlock,\n          parentNode,\n          result,\n          newRootCid,\n          _args = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n              /** @type {DefaultOptions} */\n              settings = mergeOptions(defaultOptions, options);\n              settings.mtime = settings.mtime || new Date();\n              log(\"Touching \".concat(path, \" mtime: \").concat(settings.mtime));\n              _context.next = 6;\n              return toMfsPath(context, path, settings);\n\n            case 6:\n              _yield$toMfsPath = _context.sent;\n              cid = _yield$toMfsPath.cid;\n              mfsDirectory = _yield$toMfsPath.mfsDirectory;\n              name = _yield$toMfsPath.name;\n              exists = _yield$toMfsPath.exists;\n              hashAlg = options.hashAlg || defaultOptions.hashAlg;\n              _context.next = 14;\n              return context.hashers.getHasher(hashAlg);\n\n            case 14:\n              hasher = _context.sent;\n              cidVersion = settings.cidVersion;\n\n              if (exists) {\n                _context.next = 28;\n                break;\n              }\n\n              metadata = new UnixFS({\n                type: 'file',\n                // @ts-ignore TODO: restore hrtime support to ipfs-unixfs constructor - it's in the code, just not the signature\n                mtime: settings.mtime\n              });\n              updatedBlock = dagPb.encode({\n                Data: metadata.marshal(),\n                Links: []\n              });\n              _context.next = 21;\n              return hasher.digest(updatedBlock);\n\n            case 21:\n              hash = _context.sent;\n              updatedCid = CID.create(settings.cidVersion, dagPb.code, hash);\n\n              if (!settings.flush) {\n                _context.next = 26;\n                break;\n              }\n\n              _context.next = 26;\n              return context.repo.blocks.put(updatedCid, updatedBlock);\n\n            case 26:\n              _context.next = 47;\n              break;\n\n            case 28:\n              if (!(cid.code !== dagPb.code)) {\n                _context.next = 30;\n                break;\n              }\n\n              throw errCode(new Error(\"\".concat(path, \" was not a UnixFS node\")), 'ERR_NOT_UNIXFS');\n\n            case 30:\n              cidVersion = cid.version;\n              _context.next = 33;\n              return context.repo.blocks.get(cid);\n\n            case 33:\n              block = _context.sent;\n              node = dagPb.decode(block);\n\n              if (node.Data) {\n                _context.next = 37;\n                break;\n              }\n\n              throw errCode(new Error(\"\".concat(path, \" had no data\")), 'ERR_INVALID_NODE');\n\n            case 37:\n              _metadata = UnixFS.unmarshal(node.Data); // @ts-ignore TODO: restore setting all date types as mtime - it's in the code, just not the signature\n\n              _metadata.mtime = settings.mtime;\n              updatedBlock = dagPb.encode({\n                Data: _metadata.marshal(),\n                Links: node.Links\n              });\n              _context.next = 42;\n              return hasher.digest(updatedBlock);\n\n            case 42:\n              _hash = _context.sent;\n              updatedCid = CID.create(settings.cidVersion, dagPb.code, _hash);\n\n              if (!settings.flush) {\n                _context.next = 47;\n                break;\n              }\n\n              _context.next = 47;\n              return context.repo.blocks.put(updatedCid, updatedBlock);\n\n            case 47:\n              _context.next = 49;\n              return toTrail(context, mfsDirectory);\n\n            case 49:\n              trail = _context.sent;\n              parent = trail[trail.length - 1];\n              parentCid = parent.cid;\n              _context.next = 54;\n              return context.repo.blocks.get(parentCid);\n\n            case 54:\n              parentBlock = _context.sent;\n              parentNode = dagPb.decode(parentBlock);\n              _context.next = 58;\n              return addLink(context, {\n                parent: parentNode,\n                name: name,\n                cid: updatedCid,\n                size: updatedBlock.length,\n                flush: settings.flush,\n                shardSplitThreshold: settings.shardSplitThreshold,\n                hashAlg: settings.hashAlg,\n                cidVersion: cidVersion\n              });\n\n            case 58:\n              result = _context.sent;\n              parent.cid = result.cid; // update the tree with the new child\n\n              _context.next = 62;\n              return updateTree(context, trail, settings);\n\n            case 62:\n              newRootCid = _context.sent;\n              _context.next = 65;\n              return updateMfsRoot(context, newRootCid, settings);\n\n            case 65:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return _mfsTouch.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsTouch);\n};","map":{"version":3,"names":["mergeOptions","require","bind","ignoreUndefined","toMfsPath","log","errCode","UnixFS","toTrail","addLink","updateTree","updateMfsRoot","dagPb","CID","withTimeoutOption","defaultOptions","flush","shardSplitThreshold","cidVersion","hashAlg","module","exports","context","mfsTouch","path","options","settings","mtime","Date","cid","mfsDirectory","name","exists","hashers","getHasher","hasher","metadata","type","updatedBlock","encode","Data","marshal","Links","digest","hash","updatedCid","create","code","repo","blocks","put","Error","version","get","block","node","decode","unmarshal","trail","parent","length","parentCid","parentBlock","parentNode","size","result","newRootCid"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/touch.js"],"sourcesContent":["'use strict'\n\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst toMfsPath = require('./utils/to-mfs-path')\nconst log = require('debug')('ipfs:mfs:touch')\nconst errCode = require('err-code')\nconst { UnixFS } = require('ipfs-unixfs')\nconst toTrail = require('./utils/to-trail')\nconst addLink = require('./utils/add-link')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst dagPb = require('@ipld/dag-pb')\nconst { CID } = require('multiformats/cid')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {number} shardSplitThreshold\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  cidVersion: 0,\n  hashAlg: 'sha2-256'\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"touch\"]}\n   */\n  async function mfsTouch (path, options = {}) {\n    /** @type {DefaultOptions} */\n    const settings = mergeOptions(defaultOptions, options)\n    settings.mtime = settings.mtime || new Date()\n\n    log(`Touching ${path} mtime: ${settings.mtime}`)\n\n    const {\n      cid,\n      mfsDirectory,\n      name,\n      exists\n    } = await toMfsPath(context, path, settings)\n\n    const hashAlg = options.hashAlg || defaultOptions.hashAlg\n    const hasher = await context.hashers.getHasher(hashAlg)\n\n    let updatedBlock\n    let updatedCid\n\n    let cidVersion = settings.cidVersion\n\n    if (!exists) {\n      const metadata = new UnixFS({\n        type: 'file',\n        // @ts-ignore TODO: restore hrtime support to ipfs-unixfs constructor - it's in the code, just not the signature\n        mtime: settings.mtime\n      })\n      updatedBlock = dagPb.encode({ Data: metadata.marshal(), Links: [] })\n\n      const hash = await hasher.digest(updatedBlock)\n\n      updatedCid = CID.create(settings.cidVersion, dagPb.code, hash)\n\n      if (settings.flush) {\n        await context.repo.blocks.put(updatedCid, updatedBlock)\n      }\n    } else {\n      if (cid.code !== dagPb.code) {\n        throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n      }\n\n      cidVersion = cid.version\n\n      const block = await context.repo.blocks.get(cid)\n      const node = dagPb.decode(block)\n\n      if (!node.Data) {\n        throw errCode(new Error(`${path} had no data`), 'ERR_INVALID_NODE')\n      }\n\n      const metadata = UnixFS.unmarshal(node.Data)\n\n      // @ts-ignore TODO: restore setting all date types as mtime - it's in the code, just not the signature\n      metadata.mtime = settings.mtime\n\n      updatedBlock = dagPb.encode({\n        Data: metadata.marshal(),\n        Links: node.Links\n      })\n\n      const hash = await hasher.digest(updatedBlock)\n      updatedCid = CID.create(settings.cidVersion, dagPb.code, hash)\n\n      if (settings.flush) {\n        await context.repo.blocks.put(updatedCid, updatedBlock)\n      }\n    }\n\n    const trail = await toTrail(context, mfsDirectory)\n    const parent = trail[trail.length - 1]\n    const parentCid = parent.cid\n    const parentBlock = await context.repo.blocks.get(parentCid)\n    const parentNode = dagPb.decode(parentBlock)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: settings.flush,\n      shardSplitThreshold: settings.shardSplitThreshold,\n      hashAlg: settings.hashAlg,\n      cidVersion\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, settings)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, settings)\n  }\n\n  return withTimeoutOption(mfsTouch)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}