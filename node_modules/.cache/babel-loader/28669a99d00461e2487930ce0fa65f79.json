{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar _require2 = require('multiaddr'),\n    Multiaddr = _require2.Multiaddr;\n\nvar PeerId = require('peer-id');\n/**\n * @typedef {Object} AddressManagerOptions\n * @property {string[]} [listen = []] - list of multiaddrs string representation to listen.\n * @property {string[]} [announce = []] - list of multiaddrs string representation to announce.\n */\n\n/**\n * @fires AddressManager#change:addresses Emitted when a addresses change.\n */\n\n\nvar AddressManager = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(AddressManager, _EventEmitter);\n\n  var _super = _createSuper(AddressManager);\n\n  /**\n   * Responsible for managing the peer addresses.\n   * Peers can specify their listen and announce addresses.\n   * The listen addresses will be used by the libp2p transports to listen for new connections,\n   * while the announce addresses will be used for the peer addresses' to other peers in the network.\n   *\n   * @class\n   * @param {PeerId} peerId - The Peer ID of the node\n   * @param {object} [options]\n   * @param {Array<string>} [options.listen = []] - list of multiaddrs string representation to listen.\n   * @param {Array<string>} [options.announce = []] - list of multiaddrs string representation to announce.\n   */\n  function AddressManager(peerId) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$listen = _ref.listen,\n        listen = _ref$listen === void 0 ? [] : _ref$listen,\n        _ref$announce = _ref.announce,\n        announce = _ref$announce === void 0 ? [] : _ref$announce;\n\n    _classCallCheck(this, AddressManager);\n\n    _this = _super.call(this);\n    _this.peerId = peerId;\n    _this.listen = new Set(listen.map(function (ma) {\n      return ma.toString();\n    }));\n    _this.announce = new Set(announce.map(function (ma) {\n      return ma.toString();\n    }));\n    _this.observed = new Set();\n    return _this;\n  }\n  /**\n   * Get peer listen multiaddrs.\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  _createClass(AddressManager, [{\n    key: \"getListenAddrs\",\n    value: function getListenAddrs() {\n      return Array.from(this.listen).map(function (a) {\n        return new Multiaddr(a);\n      });\n    }\n    /**\n     * Get peer announcing multiaddrs.\n     *\n     * @returns {Multiaddr[]}\n     */\n\n  }, {\n    key: \"getAnnounceAddrs\",\n    value: function getAnnounceAddrs() {\n      return Array.from(this.announce).map(function (a) {\n        return new Multiaddr(a);\n      });\n    }\n    /**\n     * Get observed multiaddrs.\n     *\n     * @returns {Array<Multiaddr>}\n     */\n\n  }, {\n    key: \"getObservedAddrs\",\n    value: function getObservedAddrs() {\n      return Array.from(this.observed).map(function (a) {\n        return new Multiaddr(a);\n      });\n    }\n    /**\n     * Add peer observed addresses\n     *\n     * @param {string | Multiaddr} addr\n     */\n\n  }, {\n    key: \"addObservedAddr\",\n    value: function addObservedAddr(addr) {\n      var ma = new Multiaddr(addr);\n      var remotePeer = ma.getPeerId(); // strip our peer id if it has been passed\n\n      if (remotePeer) {\n        var remotePeerId = PeerId.createFromB58String(remotePeer); // use same encoding for comparison\n\n        if (remotePeerId.equals(this.peerId)) {\n          ma = ma.decapsulate(new Multiaddr(\"/p2p/\".concat(this.peerId)));\n        }\n      }\n\n      var addrString = ma.toString(); // do not trigger the change:addresses event if we already know about this address\n\n      if (this.observed.has(addrString)) {\n        return;\n      }\n\n      this.observed.add(addrString);\n      this.emit('change:addresses');\n    }\n  }]);\n\n  return AddressManager;\n}(EventEmitter);\n\nmodule.exports = AddressManager;","map":{"version":3,"names":["require","EventEmitter","Multiaddr","PeerId","AddressManager","peerId","listen","announce","Set","map","ma","toString","observed","Array","from","a","addr","remotePeer","getPeerId","remotePeerId","createFromB58String","equals","decapsulate","addrString","has","add","emit","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/address-manager/index.js"],"sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst { Multiaddr } = require('multiaddr')\nconst PeerId = require('peer-id')\n\n/**\n * @typedef {Object} AddressManagerOptions\n * @property {string[]} [listen = []] - list of multiaddrs string representation to listen.\n * @property {string[]} [announce = []] - list of multiaddrs string representation to announce.\n */\n\n/**\n * @fires AddressManager#change:addresses Emitted when a addresses change.\n */\nclass AddressManager extends EventEmitter {\n  /**\n   * Responsible for managing the peer addresses.\n   * Peers can specify their listen and announce addresses.\n   * The listen addresses will be used by the libp2p transports to listen for new connections,\n   * while the announce addresses will be used for the peer addresses' to other peers in the network.\n   *\n   * @class\n   * @param {PeerId} peerId - The Peer ID of the node\n   * @param {object} [options]\n   * @param {Array<string>} [options.listen = []] - list of multiaddrs string representation to listen.\n   * @param {Array<string>} [options.announce = []] - list of multiaddrs string representation to announce.\n   */\n  constructor (peerId, { listen = [], announce = [] } = {}) {\n    super()\n\n    this.peerId = peerId\n    this.listen = new Set(listen.map(ma => ma.toString()))\n    this.announce = new Set(announce.map(ma => ma.toString()))\n    this.observed = new Set()\n  }\n\n  /**\n   * Get peer listen multiaddrs.\n   *\n   * @returns {Multiaddr[]}\n   */\n  getListenAddrs () {\n    return Array.from(this.listen).map((a) => new Multiaddr(a))\n  }\n\n  /**\n   * Get peer announcing multiaddrs.\n   *\n   * @returns {Multiaddr[]}\n   */\n  getAnnounceAddrs () {\n    return Array.from(this.announce).map((a) => new Multiaddr(a))\n  }\n\n  /**\n   * Get observed multiaddrs.\n   *\n   * @returns {Array<Multiaddr>}\n   */\n  getObservedAddrs () {\n    return Array.from(this.observed).map((a) => new Multiaddr(a))\n  }\n\n  /**\n   * Add peer observed addresses\n   *\n   * @param {string | Multiaddr} addr\n   */\n  addObservedAddr (addr) {\n    let ma = new Multiaddr(addr)\n    const remotePeer = ma.getPeerId()\n\n    // strip our peer id if it has been passed\n    if (remotePeer) {\n      const remotePeerId = PeerId.createFromB58String(remotePeer)\n\n      // use same encoding for comparison\n      if (remotePeerId.equals(this.peerId)) {\n        ma = ma.decapsulate(new Multiaddr(`/p2p/${this.peerId}`))\n      }\n    }\n\n    const addrString = ma.toString()\n\n    // do not trigger the change:addresses event if we already know about this address\n    if (this.observed.has(addrString)) {\n      return\n    }\n\n    this.observed.add(addrString)\n    this.emit('change:addresses')\n  }\n}\n\nmodule.exports = AddressManager\n"],"mappings":"AAAA;;;;;;;;;;AAEA,eAAyBA,OAAO,CAAC,QAAD,CAAhC;AAAA,IAAQC,YAAR,YAAQA,YAAR;;AACA,gBAAsBD,OAAO,CAAC,WAAD,CAA7B;AAAA,IAAQE,SAAR,aAAQA,SAAR;;AACA,IAAMC,MAAM,GAAGH,OAAO,CAAC,SAAD,CAAtB;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;IACMI,c;;;;;EACJ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,wBAAaC,MAAb,EAA0D;IAAA;;IAAA,+EAAJ,EAAI;IAAA,uBAAnCC,MAAmC;IAAA,IAAnCA,MAAmC,4BAA1B,EAA0B;IAAA,yBAAtBC,QAAsB;IAAA,IAAtBA,QAAsB,8BAAX,EAAW;;IAAA;;IACxD;IAEA,MAAKF,MAAL,GAAcA,MAAd;IACA,MAAKC,MAAL,GAAc,IAAIE,GAAJ,CAAQF,MAAM,CAACG,GAAP,CAAW,UAAAC,EAAE;MAAA,OAAIA,EAAE,CAACC,QAAH,EAAJ;IAAA,CAAb,CAAR,CAAd;IACA,MAAKJ,QAAL,GAAgB,IAAIC,GAAJ,CAAQD,QAAQ,CAACE,GAAT,CAAa,UAAAC,EAAE;MAAA,OAAIA,EAAE,CAACC,QAAH,EAAJ;IAAA,CAAf,CAAR,CAAhB;IACA,MAAKC,QAAL,GAAgB,IAAIJ,GAAJ,EAAhB;IANwD;EAOzD;EAED;AACF;AACA;AACA;AACA;;;;;WACE,0BAAkB;MAChB,OAAOK,KAAK,CAACC,IAAN,CAAW,KAAKR,MAAhB,EAAwBG,GAAxB,CAA4B,UAACM,CAAD;QAAA,OAAO,IAAIb,SAAJ,CAAca,CAAd,CAAP;MAAA,CAA5B,CAAP;IACD;IAED;AACF;AACA;AACA;AACA;;;;WACE,4BAAoB;MAClB,OAAOF,KAAK,CAACC,IAAN,CAAW,KAAKP,QAAhB,EAA0BE,GAA1B,CAA8B,UAACM,CAAD;QAAA,OAAO,IAAIb,SAAJ,CAAca,CAAd,CAAP;MAAA,CAA9B,CAAP;IACD;IAED;AACF;AACA;AACA;AACA;;;;WACE,4BAAoB;MAClB,OAAOF,KAAK,CAACC,IAAN,CAAW,KAAKF,QAAhB,EAA0BH,GAA1B,CAA8B,UAACM,CAAD;QAAA,OAAO,IAAIb,SAAJ,CAAca,CAAd,CAAP;MAAA,CAA9B,CAAP;IACD;IAED;AACF;AACA;AACA;AACA;;;;WACE,yBAAiBC,IAAjB,EAAuB;MACrB,IAAIN,EAAE,GAAG,IAAIR,SAAJ,CAAcc,IAAd,CAAT;MACA,IAAMC,UAAU,GAAGP,EAAE,CAACQ,SAAH,EAAnB,CAFqB,CAIrB;;MACA,IAAID,UAAJ,EAAgB;QACd,IAAME,YAAY,GAAGhB,MAAM,CAACiB,mBAAP,CAA2BH,UAA3B,CAArB,CADc,CAGd;;QACA,IAAIE,YAAY,CAACE,MAAb,CAAoB,KAAKhB,MAAzB,CAAJ,EAAsC;UACpCK,EAAE,GAAGA,EAAE,CAACY,WAAH,CAAe,IAAIpB,SAAJ,gBAAsB,KAAKG,MAA3B,EAAf,CAAL;QACD;MACF;;MAED,IAAMkB,UAAU,GAAGb,EAAE,CAACC,QAAH,EAAnB,CAdqB,CAgBrB;;MACA,IAAI,KAAKC,QAAL,CAAcY,GAAd,CAAkBD,UAAlB,CAAJ,EAAmC;QACjC;MACD;;MAED,KAAKX,QAAL,CAAca,GAAd,CAAkBF,UAAlB;MACA,KAAKG,IAAL,CAAU,kBAAV;IACD;;;;EA7E0BzB,Y;;AAgF7B0B,MAAM,CAACC,OAAP,GAAiBxB,cAAjB"},"metadata":{},"sourceType":"script"}