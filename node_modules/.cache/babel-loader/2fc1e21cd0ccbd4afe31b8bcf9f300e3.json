{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst b32 = require('multiformats/bases/base32');\n\nconst b36 = require('multiformats/bases/base36');\n\nconst b58 = require('multiformats/bases/base58');\n\nconst b64 = require('multiformats/bases/base64');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst {\n  base16\n} = require('multiformats/bases/base16');\n\nconst Digest = require('multiformats/hashes/digest');\n\nconst cryptoKeys = require('libp2p-crypto/src/keys');\n\nconst withIs = require('class-is');\n\nconst {\n  PeerIdProto\n} = require('./proto');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  identity\n} = require('multiformats/hashes/identity');\n\nconst bases = { ...b32,\n  ...b36,\n  ...b58,\n  ...b64\n};\nconst baseDecoder = Object.keys(bases).reduce((acc, curr) => acc.or(bases[curr]), base32.decoder); // these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\n\nconst DAG_PB_CODE = 0x70;\nconst LIBP2P_KEY_CODE = 0x72;\n\nclass PeerId {\n  constructor(id, privKey, pubKey) {\n    if (!(id instanceof Uint8Array)) {\n      throw new Error('invalid id provided');\n    }\n\n    if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {\n      throw new Error('inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = base58btc.encode(this.id).substring(1);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(val) {\n    throw new Error('Id is immutable');\n  }\n\n  get privKey() {\n    return this._privKey;\n  }\n\n  set privKey(privKey) {\n    this._privKey = privKey;\n  }\n\n  get pubKey() {\n    if (this._pubKey) {\n      return this._pubKey;\n    }\n\n    if (this._privKey) {\n      return this._privKey.public;\n    }\n\n    try {\n      const decoded = Digest.decode(this.id);\n\n      if (decoded.code === identity.code) {\n        this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);\n      }\n    } catch (_) {// Ignore, there is no valid public key\n    }\n\n    return this._pubKey;\n  }\n\n  set pubKey(pubKey) {\n    this._pubKey = pubKey;\n  } // Return the protobuf version of the public key, matching go ipfs formatting\n\n\n  marshalPubKey() {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey);\n    }\n  } // Return the protobuf version of the private key, matching go ipfs formatting\n\n\n  marshalPrivKey() {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey);\n    }\n  } // Return the protobuf version of the peer-id\n\n\n  marshal(excludePriv) {\n    return PeerIdProto.encode({\n      id: this.toBytes(),\n      pubKey: this.marshalPubKey(),\n      privKey: excludePriv ? null : this.marshalPrivKey()\n    }).finish();\n  }\n\n  toPrint() {\n    let pid = this.toB58String(); // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2);\n    }\n\n    let maxRunes = 6;\n\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length;\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n  } // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n\n\n  toJSON() {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    };\n  } // encode/decode functions\n\n\n  toHexString() {\n    return base16.encode(this.id).substring(1);\n  }\n\n  toBytes() {\n    return this.id;\n  }\n\n  toB58String() {\n    return this._idB58String;\n  } // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n\n\n  toString() {\n    if (!this._idCIDString) {\n      const cid = CID.createV1(LIBP2P_KEY_CODE, Digest.decode(this.id));\n      Object.defineProperty(this, '_idCIDString', {\n        value: cid.toString(),\n        enumerable: false\n      });\n    }\n\n    return this._idCIDString;\n  }\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   *\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n\n\n  equals(id) {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.id, id);\n    } else if (id.id) {\n      return uint8ArrayEquals(this.id, id.id);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   *\n   * @deprecated Use `.equals`\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n\n\n  isEqual(id) {\n    return this.equals(id);\n  }\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n\n\n  isValid() {\n    // TODO: needs better checking\n    return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && this.pubKey.bytes instanceof Uint8Array && uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes));\n  }\n  /**\n   * Check if the PeerId has an inline public key.\n   *\n   * @returns {boolean}\n   */\n\n\n  hasInlinePublicKey() {\n    try {\n      const decoded = Digest.decode(this.id);\n\n      if (decoded.code === identity.code) {\n        return true;\n      }\n    } catch (_) {// Ignore, there is no valid public key\n    }\n\n    return false;\n  }\n\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\n\nconst computeDigest = pubKey => {\n  if (pubKey.bytes.length <= 42) {\n    return Digest.create(identity.code, pubKey.bytes).bytes;\n  } else {\n    return pubKey.hash();\n  }\n};\n\nconst computePeerId = async (privKey, pubKey) => {\n  const digest = await computeDigest(pubKey);\n  return new PeerIdWithIs(digest, privKey, pubKey);\n}; // generation\n\n\nexports.create = async opts => {\n  opts = opts || {};\n  opts.bits = opts.bits || 2048;\n  opts.keyType = opts.keyType || 'RSA';\n  const key = await cryptoKeys.generateKeyPair(opts.keyType, opts.bits);\n  return computePeerId(key, key.public);\n};\n\nexports.createFromHexString = str => {\n  return new PeerIdWithIs(base16.decode('f' + str));\n};\n\nexports.createFromBytes = buf => {\n  try {\n    const cid = CID.decode(buf);\n\n    if (!validMulticodec(cid)) {\n      throw new Error('Supplied PeerID CID is invalid');\n    }\n\n    return exports.createFromCID(cid);\n  } catch {\n    const digest = Digest.decode(buf);\n\n    if (digest.code !== identity.code) {\n      throw new Error('Supplied PeerID CID is invalid');\n    }\n\n    return new PeerIdWithIs(buf);\n  }\n};\n\nexports.createFromB58String = str => {\n  return exports.createFromBytes(base58btc.decode('z' + str));\n};\n\nconst validMulticodec = cid => {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.code === LIBP2P_KEY_CODE || cid.code === DAG_PB_CODE;\n};\n\nexports.createFromCID = cid => {\n  cid = CID.asCID(cid);\n\n  if (!cid || !validMulticodec(cid)) {\n    throw new Error('Supplied PeerID CID is invalid');\n  }\n\n  return new PeerIdWithIs(cid.multihash.bytes);\n}; // Public Key input will be a Uint8Array\n\n\nexports.createFromPubKey = async key => {\n  let buf = key;\n\n  if (typeof buf === 'string') {\n    buf = uint8ArrayFromString(key, 'base64pad');\n  }\n\n  if (!(buf instanceof Uint8Array)) {\n    throw new Error('Supplied key is neither a base64 string nor a Uint8Array');\n  }\n\n  const pubKey = await cryptoKeys.unmarshalPublicKey(buf);\n  return computePeerId(undefined, pubKey);\n}; // Private key input will be a string\n\n\nexports.createFromPrivKey = async key => {\n  if (typeof key === 'string') {\n    key = uint8ArrayFromString(key, 'base64pad');\n  }\n\n  if (!(key instanceof Uint8Array)) {\n    throw new Error('Supplied key is neither a base64 string nor a Uint8Array');\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(key);\n  return computePeerId(privKey, privKey.public);\n};\n\nexports.createFromJSON = async obj => {\n  const id = base58btc.decode('z' + obj.id);\n  const rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, 'base64pad');\n  const rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, 'base64pad');\n  const pub = rawPubKey && (await cryptoKeys.unmarshalPublicKey(rawPubKey));\n\n  if (!rawPrivKey) {\n    return new PeerIdWithIs(id, undefined, pub);\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(rawPrivKey);\n  const privDigest = await computeDigest(privKey.public);\n  let pubDigest;\n\n  if (pub) {\n    pubDigest = await computeDigest(pub);\n  }\n\n  if (pub && !uint8ArrayEquals(privDigest, pubDigest)) {\n    throw new Error('Public and private key do not match');\n  }\n\n  if (id && !uint8ArrayEquals(privDigest, id)) {\n    throw new Error('Id and private key do not match');\n  }\n\n  return new PeerIdWithIs(id, privKey, pub);\n};\n\nexports.createFromProtobuf = async buf => {\n  if (typeof buf === 'string') {\n    buf = uint8ArrayFromString(buf, 'base16');\n  }\n\n  let {\n    id,\n    privKey,\n    pubKey\n  } = PeerIdProto.decode(buf);\n  privKey = privKey ? await cryptoKeys.unmarshalPrivateKey(privKey) : false;\n  pubKey = pubKey ? await cryptoKeys.unmarshalPublicKey(pubKey) : false;\n  let pubDigest;\n  let privDigest;\n\n  if (privKey) {\n    privDigest = await computeDigest(privKey.public);\n  }\n\n  if (pubKey) {\n    pubDigest = await computeDigest(pubKey);\n  }\n\n  if (privKey) {\n    if (pubKey) {\n      if (!uint8ArrayEquals(privDigest, pubDigest)) {\n        throw new Error('Public and private key do not match');\n      }\n    }\n\n    return new PeerIdWithIs(privDigest, privKey, privKey.public);\n  } // TODO: val id and pubDigest\n\n\n  if (pubKey) {\n    return new PeerIdWithIs(pubDigest, undefined, pubKey);\n  }\n\n  if (id) {\n    return new PeerIdWithIs(id);\n  }\n\n  throw new Error('Protobuf did not contain any usable key material');\n};\n\nexports.parse = str => {\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519 key or sha2-256 hash of rsa public key\n    // base58btc encoded either way\n    str = `z${str}`;\n  }\n\n  return exports.createFromBytes(baseDecoder.decode(str));\n};\n\nexports.isPeerId = peerId => {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return uint8ArrayToString(val, 'base64pad');\n  }\n}","map":{"version":3,"names":["CID","require","b32","b36","b58","b64","base58btc","base32","base16","Digest","cryptoKeys","withIs","PeerIdProto","equals","uint8ArrayEquals","fromString","uint8ArrayFromString","toString","uint8ArrayToString","identity","bases","baseDecoder","Object","keys","reduce","acc","curr","or","decoder","DAG_PB_CODE","LIBP2P_KEY_CODE","PeerId","constructor","id","privKey","pubKey","Uint8Array","Error","public","bytes","_id","_idB58String","encode","substring","_privKey","_pubKey","val","decoded","decode","code","unmarshalPublicKey","digest","_","marshalPubKey","marshalPublicKey","marshalPrivKey","marshalPrivateKey","marshal","excludePriv","toBytes","finish","toPrint","pid","toB58String","startsWith","slice","maxRunes","length","substr","toJSON","toB64Opt","toHexString","_idCIDString","cid","createV1","defineProperty","value","enumerable","isEqual","isValid","Boolean","hasInlinePublicKey","PeerIdWithIs","className","symbolName","exports","module","computeDigest","create","hash","computePeerId","opts","bits","keyType","key","generateKeyPair","createFromHexString","str","createFromBytes","buf","validMulticodec","createFromCID","createFromB58String","asCID","multihash","createFromPubKey","undefined","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","rawPrivKey","rawPubKey","pub","privDigest","pubDigest","createFromProtobuf","parse","charAt","isPeerId","peerId"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-delegated-content-routing/node_modules/peer-id/src/index.js"],"sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst b32 = require('multiformats/bases/base32')\nconst b36 = require('multiformats/bases/base36')\nconst b58 = require('multiformats/bases/base58')\nconst b64 = require('multiformats/bases/base64')\nconst { base58btc } = require('multiformats/bases/base58')\nconst { base32 } = require('multiformats/bases/base32')\nconst { base16 } = require('multiformats/bases/base16')\nconst Digest = require('multiformats/hashes/digest')\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst withIs = require('class-is')\nconst { PeerIdProto } = require('./proto')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { identity } = require('multiformats/hashes/identity')\n\nconst bases = {\n  ...b32,\n  ...b36,\n  ...b58,\n  ...b64\n}\nconst baseDecoder = Object.keys(bases).reduce(\n  (acc, curr) => acc.or(bases[curr]),\n  base32.decoder\n)\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst DAG_PB_CODE = 0x70\nconst LIBP2P_KEY_CODE = 0x72\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    if (!(id instanceof Uint8Array)) {\n      throw new Error('invalid id provided')\n    }\n\n    if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {\n      throw new Error('inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = base58btc.encode(this.id).substring(1)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n\n    try {\n      const decoded = Digest.decode(this.id)\n\n      if (decoded.code === identity.code) {\n        this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest)\n      }\n    } catch (_) {\n      // Ignore, there is no valid public key\n    }\n\n    return this._pubKey\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  // Return the protobuf version of the peer-id\n  marshal (excludePriv) {\n    return PeerIdProto.encode({\n      id: this.toBytes(),\n      pubKey: this.marshalPubKey(),\n      privKey: excludePriv ? null : this.marshalPrivKey()\n    }).finish()\n  }\n\n  toPrint () {\n    let pid = this.toB58String()\n    // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2)\n    }\n    let maxRunes = 6\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>'\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return base16.encode(this.id).substring(1)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toString () {\n    if (!this._idCIDString) {\n      const cid = CID.createV1(LIBP2P_KEY_CODE, Digest.decode(this.id))\n\n      Object.defineProperty(this, '_idCIDString', {\n        value: cid.toString(),\n        enumerable: false\n      })\n    }\n    return this._idCIDString\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   *\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n  equals (id) {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.id, id)\n    } else if (id.id) {\n      return uint8ArrayEquals(this.id, id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   *\n   * @deprecated Use `.equals`\n   * @param {Uint8Array|PeerId} id\n   * @returns {boolean}\n   */\n  isEqual (id) {\n    return this.equals(id)\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid () {\n    // TODO: needs better checking\n    return Boolean(this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      this.pubKey.bytes instanceof Uint8Array &&\n        uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes))\n  }\n\n  /**\n   * Check if the PeerId has an inline public key.\n   *\n   * @returns {boolean}\n   */\n  hasInlinePublicKey () {\n    try {\n      const decoded = Digest.decode(this.id)\n\n      if (decoded.code === identity.code) {\n        return true\n      }\n    } catch (_) {\n      // Ignore, there is no valid public key\n    }\n\n    return false\n  }\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n})\n\nexports = module.exports = PeerIdWithIs\n\nconst computeDigest = (pubKey) => {\n  if (pubKey.bytes.length <= 42) {\n    return Digest.create(identity.code, pubKey.bytes).bytes\n  } else {\n    return pubKey.hash()\n  }\n}\n\nconst computePeerId = async (privKey, pubKey) => {\n  const digest = await computeDigest(pubKey)\n  return new PeerIdWithIs(digest, privKey, pubKey)\n}\n\n// generation\nexports.create = async (opts) => {\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n  opts.keyType = opts.keyType || 'RSA'\n\n  const key = await cryptoKeys.generateKeyPair(opts.keyType, opts.bits)\n  return computePeerId(key, key.public)\n}\n\nexports.createFromHexString = (str) => {\n  return new PeerIdWithIs(base16.decode('f' + str))\n}\n\nexports.createFromBytes = (buf) => {\n  try {\n    const cid = CID.decode(buf)\n\n    if (!validMulticodec(cid)) {\n      throw new Error('Supplied PeerID CID is invalid')\n    }\n\n    return exports.createFromCID(cid)\n  } catch {\n    const digest = Digest.decode(buf)\n\n    if (digest.code !== identity.code) {\n      throw new Error('Supplied PeerID CID is invalid')\n    }\n\n    return new PeerIdWithIs(buf)\n  }\n}\n\nexports.createFromB58String = (str) => {\n  return exports.createFromBytes(base58btc.decode('z' + str))\n}\n\nconst validMulticodec = (cid) => {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.code === LIBP2P_KEY_CODE || cid.code === DAG_PB_CODE\n}\n\nexports.createFromCID = (cid) => {\n  cid = CID.asCID(cid)\n\n  if (!cid || !validMulticodec(cid)) {\n    throw new Error('Supplied PeerID CID is invalid')\n  }\n\n  return new PeerIdWithIs(cid.multihash.bytes)\n}\n\n// Public Key input will be a Uint8Array\nexports.createFromPubKey = async (key) => {\n  let buf = key\n\n  if (typeof buf === 'string') {\n    buf = uint8ArrayFromString(key, 'base64pad')\n  }\n\n  if (!(buf instanceof Uint8Array)) {\n    throw new Error('Supplied key is neither a base64 string nor a Uint8Array')\n  }\n\n  const pubKey = await cryptoKeys.unmarshalPublicKey(buf)\n  return computePeerId(undefined, pubKey)\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = async (key) => {\n  if (typeof key === 'string') {\n    key = uint8ArrayFromString(key, 'base64pad')\n  }\n\n  if (!(key instanceof Uint8Array)) {\n    throw new Error('Supplied key is neither a base64 string nor a Uint8Array')\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(key)\n  return computePeerId(privKey, privKey.public)\n}\n\nexports.createFromJSON = async (obj) => {\n  const id = base58btc.decode('z' + obj.id)\n  const rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, 'base64pad')\n  const rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, 'base64pad')\n  const pub = rawPubKey && await cryptoKeys.unmarshalPublicKey(rawPubKey)\n\n  if (!rawPrivKey) {\n    return new PeerIdWithIs(id, undefined, pub)\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(rawPrivKey)\n  const privDigest = await computeDigest(privKey.public)\n\n  let pubDigest\n\n  if (pub) {\n    pubDigest = await computeDigest(pub)\n  }\n\n  if (pub && !uint8ArrayEquals(privDigest, pubDigest)) {\n    throw new Error('Public and private key do not match')\n  }\n\n  if (id && !uint8ArrayEquals(privDigest, id)) {\n    throw new Error('Id and private key do not match')\n  }\n\n  return new PeerIdWithIs(id, privKey, pub)\n}\n\nexports.createFromProtobuf = async (buf) => {\n  if (typeof buf === 'string') {\n    buf = uint8ArrayFromString(buf, 'base16')\n  }\n\n  let { id, privKey, pubKey } = PeerIdProto.decode(buf)\n\n  privKey = privKey ? await cryptoKeys.unmarshalPrivateKey(privKey) : false\n  pubKey = pubKey ? await cryptoKeys.unmarshalPublicKey(pubKey) : false\n\n  let pubDigest\n  let privDigest\n\n  if (privKey) {\n    privDigest = await computeDigest(privKey.public)\n  }\n\n  if (pubKey) {\n    pubDigest = await computeDigest(pubKey)\n  }\n\n  if (privKey) {\n    if (pubKey) {\n      if (!uint8ArrayEquals(privDigest, pubDigest)) {\n        throw new Error('Public and private key do not match')\n      }\n    }\n    return new PeerIdWithIs(privDigest, privKey, privKey.public)\n  }\n\n  // TODO: val id and pubDigest\n\n  if (pubKey) {\n    return new PeerIdWithIs(pubDigest, undefined, pubKey)\n  }\n\n  if (id) {\n    return new PeerIdWithIs(id)\n  }\n\n  throw new Error('Protobuf did not contain any usable key material')\n}\n\nexports.parse = (str) => {\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519 key or sha2-256 hash of rsa public key\n    // base58btc encoded either way\n    str = `z${str}`\n  }\n\n  return exports.createFromBytes(baseDecoder.decode(str))\n}\n\nexports.isPeerId = (peerId) => {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return uint8ArrayToString(val, 'base64pad')\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA;;AAEA,MAAM;EAAEA;AAAF,IAAUC,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,2BAAD,CAAnB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,2BAAD,CAAnB;;AACA,MAAMG,GAAG,GAAGH,OAAO,CAAC,2BAAD,CAAnB;;AACA,MAAMI,GAAG,GAAGJ,OAAO,CAAC,2BAAD,CAAnB;;AACA,MAAM;EAAEK;AAAF,IAAgBL,OAAO,CAAC,2BAAD,CAA7B;;AACA,MAAM;EAAEM;AAAF,IAAaN,OAAO,CAAC,2BAAD,CAA1B;;AACA,MAAM;EAAEO;AAAF,IAAaP,OAAO,CAAC,2BAAD,CAA1B;;AACA,MAAMQ,MAAM,GAAGR,OAAO,CAAC,4BAAD,CAAtB;;AACA,MAAMS,UAAU,GAAGT,OAAO,CAAC,wBAAD,CAA1B;;AACA,MAAMU,MAAM,GAAGV,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAM;EAAEW;AAAF,IAAkBX,OAAO,CAAC,SAAD,CAA/B;;AACA,MAAM;EAAEY,MAAM,EAAEC;AAAV,IAA+Bb,OAAO,CAAC,oBAAD,CAA5C;;AACA,MAAM;EAAEc,UAAU,EAAEC;AAAd,IAAuCf,OAAO,CAAC,yBAAD,CAApD;;AACA,MAAM;EAAEgB,QAAQ,EAAEC;AAAZ,IAAmCjB,OAAO,CAAC,uBAAD,CAAhD;;AACA,MAAM;EAAEkB;AAAF,IAAelB,OAAO,CAAC,8BAAD,CAA5B;;AAEA,MAAMmB,KAAK,GAAG,EACZ,GAAGlB,GADS;EAEZ,GAAGC,GAFS;EAGZ,GAAGC,GAHS;EAIZ,GAAGC;AAJS,CAAd;AAMA,MAAMgB,WAAW,GAAGC,MAAM,CAACC,IAAP,CAAYH,KAAZ,EAAmBI,MAAnB,CAClB,CAACC,GAAD,EAAMC,IAAN,KAAeD,GAAG,CAACE,EAAJ,CAAOP,KAAK,CAACM,IAAD,CAAZ,CADG,EAElBnB,MAAM,CAACqB,OAFW,CAApB,C,CAKA;;AACA,MAAMC,WAAW,GAAG,IAApB;AACA,MAAMC,eAAe,GAAG,IAAxB;;AAEA,MAAMC,MAAN,CAAa;EACXC,WAAW,CAAEC,EAAF,EAAMC,OAAN,EAAeC,MAAf,EAAuB;IAChC,IAAI,EAAEF,EAAE,YAAYG,UAAhB,CAAJ,EAAiC;MAC/B,MAAM,IAAIC,KAAJ,CAAU,qBAAV,CAAN;IACD;;IAED,IAAIH,OAAO,IAAIC,MAAX,IAAqB,CAACrB,gBAAgB,CAACoB,OAAO,CAACI,MAAR,CAAeC,KAAhB,EAAuBJ,MAAM,CAACI,KAA9B,CAA1C,EAAgF;MAC9E,MAAM,IAAIF,KAAJ,CAAU,wBAAV,CAAN;IACD;;IAED,KAAKG,GAAL,GAAWP,EAAX;IACA,KAAKQ,YAAL,GAAoBnC,SAAS,CAACoC,MAAV,CAAiB,KAAKT,EAAtB,EAA0BU,SAA1B,CAAoC,CAApC,CAApB;IACA,KAAKC,QAAL,GAAgBV,OAAhB;IACA,KAAKW,OAAL,GAAeV,MAAf;EACD;;EAEK,IAAFF,EAAE,GAAI;IACR,OAAO,KAAKO,GAAZ;EACD;;EAEK,IAAFP,EAAE,CAAEa,GAAF,EAAO;IACX,MAAM,IAAIT,KAAJ,CAAU,iBAAV,CAAN;EACD;;EAEU,IAAPH,OAAO,GAAI;IACb,OAAO,KAAKU,QAAZ;EACD;;EAEU,IAAPV,OAAO,CAAEA,OAAF,EAAW;IACpB,KAAKU,QAAL,GAAgBV,OAAhB;EACD;;EAES,IAANC,MAAM,GAAI;IACZ,IAAI,KAAKU,OAAT,EAAkB;MAChB,OAAO,KAAKA,OAAZ;IACD;;IAED,IAAI,KAAKD,QAAT,EAAmB;MACjB,OAAO,KAAKA,QAAL,CAAcN,MAArB;IACD;;IAED,IAAI;MACF,MAAMS,OAAO,GAAGtC,MAAM,CAACuC,MAAP,CAAc,KAAKf,EAAnB,CAAhB;;MAEA,IAAIc,OAAO,CAACE,IAAR,KAAiB9B,QAAQ,CAAC8B,IAA9B,EAAoC;QAClC,KAAKJ,OAAL,GAAenC,UAAU,CAACwC,kBAAX,CAA8BH,OAAO,CAACI,MAAtC,CAAf;MACD;IACF,CAND,CAME,OAAOC,CAAP,EAAU,CACV;IACD;;IAED,OAAO,KAAKP,OAAZ;EACD;;EAES,IAANV,MAAM,CAAEA,MAAF,EAAU;IAClB,KAAKU,OAAL,GAAeV,MAAf;EACD,CAxDU,CA0DX;;;EACAkB,aAAa,GAAI;IACf,IAAI,KAAKlB,MAAT,EAAiB;MACf,OAAOzB,UAAU,CAAC4C,gBAAX,CAA4B,KAAKnB,MAAjC,CAAP;IACD;EACF,CA/DU,CAiEX;;;EACAoB,cAAc,GAAI;IAChB,IAAI,KAAKrB,OAAT,EAAkB;MAChB,OAAOxB,UAAU,CAAC8C,iBAAX,CAA6B,KAAKtB,OAAlC,CAAP;IACD;EACF,CAtEU,CAwEX;;;EACAuB,OAAO,CAAEC,WAAF,EAAe;IACpB,OAAO9C,WAAW,CAAC8B,MAAZ,CAAmB;MACxBT,EAAE,EAAE,KAAK0B,OAAL,EADoB;MAExBxB,MAAM,EAAE,KAAKkB,aAAL,EAFgB;MAGxBnB,OAAO,EAAEwB,WAAW,GAAG,IAAH,GAAU,KAAKH,cAAL;IAHN,CAAnB,EAIJK,MAJI,EAAP;EAKD;;EAEDC,OAAO,GAAI;IACT,IAAIC,GAAG,GAAG,KAAKC,WAAL,EAAV,CADS,CAET;IACA;;IACA,IAAID,GAAG,CAACE,UAAJ,CAAe,IAAf,CAAJ,EAA0B;MACxBF,GAAG,GAAGA,GAAG,CAACG,KAAJ,CAAU,CAAV,CAAN;IACD;;IACD,IAAIC,QAAQ,GAAG,CAAf;;IACA,IAAIJ,GAAG,CAACK,MAAJ,GAAaD,QAAjB,EAA2B;MACzBA,QAAQ,GAAGJ,GAAG,CAACK,MAAf;IACD;;IAED,OAAO,cAAcL,GAAG,CAACM,MAAJ,CAAW,CAAX,EAAcF,QAAd,CAAd,GAAwC,GAA/C;EACD,CA9FU,CAgGX;EACA;;;EACAG,MAAM,GAAI;IACR,OAAO;MACLpC,EAAE,EAAE,KAAK8B,WAAL,EADC;MAEL7B,OAAO,EAAEoC,QAAQ,CAAC,KAAKf,cAAL,EAAD,CAFZ;MAGLpB,MAAM,EAAEmC,QAAQ,CAAC,KAAKjB,aAAL,EAAD;IAHX,CAAP;EAKD,CAxGU,CA0GX;;;EACAkB,WAAW,GAAI;IACb,OAAO/D,MAAM,CAACkC,MAAP,CAAc,KAAKT,EAAnB,EAAuBU,SAAvB,CAAiC,CAAjC,CAAP;EACD;;EAEDgB,OAAO,GAAI;IACT,OAAO,KAAK1B,EAAZ;EACD;;EAED8B,WAAW,GAAI;IACb,OAAO,KAAKtB,YAAZ;EACD,CArHU,CAuHX;EACA;;;EACAxB,QAAQ,GAAI;IACV,IAAI,CAAC,KAAKuD,YAAV,EAAwB;MACtB,MAAMC,GAAG,GAAGzE,GAAG,CAAC0E,QAAJ,CAAa5C,eAAb,EAA8BrB,MAAM,CAACuC,MAAP,CAAc,KAAKf,EAAnB,CAA9B,CAAZ;MAEAX,MAAM,CAACqD,cAAP,CAAsB,IAAtB,EAA4B,cAA5B,EAA4C;QAC1CC,KAAK,EAAEH,GAAG,CAACxD,QAAJ,EADmC;QAE1C4D,UAAU,EAAE;MAF8B,CAA5C;IAID;;IACD,OAAO,KAAKL,YAAZ;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACE3D,MAAM,CAAEoB,EAAF,EAAM;IACV,IAAIA,EAAE,YAAYG,UAAlB,EAA8B;MAC5B,OAAOtB,gBAAgB,CAAC,KAAKmB,EAAN,EAAUA,EAAV,CAAvB;IACD,CAFD,MAEO,IAAIA,EAAE,CAACA,EAAP,EAAW;MAChB,OAAOnB,gBAAgB,CAAC,KAAKmB,EAAN,EAAUA,EAAE,CAACA,EAAb,CAAvB;IACD,CAFM,MAEA;MACL,MAAM,IAAII,KAAJ,CAAU,cAAV,CAAN;IACD;EACF;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEyC,OAAO,CAAE7C,EAAF,EAAM;IACX,OAAO,KAAKpB,MAAL,CAAYoB,EAAZ,CAAP;EACD;EAED;AACF;AACA;;;EACE8C,OAAO,GAAI;IACT;IACA,OAAOC,OAAO,CAAC,KAAK9C,OAAL,IACb,KAAKA,OAAL,CAAaI,MADA,IAEb,KAAKJ,OAAL,CAAaI,MAAb,CAAoBC,KAFP,IAGb,KAAKJ,MAAL,CAAYI,KAAZ,YAA6BH,UAHhB,IAIXtB,gBAAgB,CAAC,KAAKoB,OAAL,CAAaI,MAAb,CAAoBC,KAArB,EAA4B,KAAKJ,MAAL,CAAYI,KAAxC,CAJN,CAAd;EAKD;EAED;AACF;AACA;AACA;AACA;;;EACE0C,kBAAkB,GAAI;IACpB,IAAI;MACF,MAAMlC,OAAO,GAAGtC,MAAM,CAACuC,MAAP,CAAc,KAAKf,EAAnB,CAAhB;;MAEA,IAAIc,OAAO,CAACE,IAAR,KAAiB9B,QAAQ,CAAC8B,IAA9B,EAAoC;QAClC,OAAO,IAAP;MACD;IACF,CAND,CAME,OAAOG,CAAP,EAAU,CACV;IACD;;IAED,OAAO,KAAP;EACD;;AA7LU;;AAgMb,MAAM8B,YAAY,GAAGvE,MAAM,CAACoB,MAAD,EAAS;EAClCoD,SAAS,EAAE,QADuB;EAElCC,UAAU,EAAE;AAFsB,CAAT,CAA3B;AAKAC,OAAO,GAAGC,MAAM,CAACD,OAAP,GAAiBH,YAA3B;;AAEA,MAAMK,aAAa,GAAIpD,MAAD,IAAY;EAChC,IAAIA,MAAM,CAACI,KAAP,CAAa4B,MAAb,IAAuB,EAA3B,EAA+B;IAC7B,OAAO1D,MAAM,CAAC+E,MAAP,CAAcrE,QAAQ,CAAC8B,IAAvB,EAA6Bd,MAAM,CAACI,KAApC,EAA2CA,KAAlD;EACD,CAFD,MAEO;IACL,OAAOJ,MAAM,CAACsD,IAAP,EAAP;EACD;AACF,CAND;;AAQA,MAAMC,aAAa,GAAG,OAAOxD,OAAP,EAAgBC,MAAhB,KAA2B;EAC/C,MAAMgB,MAAM,GAAG,MAAMoC,aAAa,CAACpD,MAAD,CAAlC;EACA,OAAO,IAAI+C,YAAJ,CAAiB/B,MAAjB,EAAyBjB,OAAzB,EAAkCC,MAAlC,CAAP;AACD,CAHD,C,CAKA;;;AACAkD,OAAO,CAACG,MAAR,GAAiB,MAAOG,IAAP,IAAgB;EAC/BA,IAAI,GAAGA,IAAI,IAAI,EAAf;EACAA,IAAI,CAACC,IAAL,GAAYD,IAAI,CAACC,IAAL,IAAa,IAAzB;EACAD,IAAI,CAACE,OAAL,GAAeF,IAAI,CAACE,OAAL,IAAgB,KAA/B;EAEA,MAAMC,GAAG,GAAG,MAAMpF,UAAU,CAACqF,eAAX,CAA2BJ,IAAI,CAACE,OAAhC,EAAyCF,IAAI,CAACC,IAA9C,CAAlB;EACA,OAAOF,aAAa,CAACI,GAAD,EAAMA,GAAG,CAACxD,MAAV,CAApB;AACD,CAPD;;AASA+C,OAAO,CAACW,mBAAR,GAA+BC,GAAD,IAAS;EACrC,OAAO,IAAIf,YAAJ,CAAiB1E,MAAM,CAACwC,MAAP,CAAc,MAAMiD,GAApB,CAAjB,CAAP;AACD,CAFD;;AAIAZ,OAAO,CAACa,eAAR,GAA2BC,GAAD,IAAS;EACjC,IAAI;IACF,MAAM1B,GAAG,GAAGzE,GAAG,CAACgD,MAAJ,CAAWmD,GAAX,CAAZ;;IAEA,IAAI,CAACC,eAAe,CAAC3B,GAAD,CAApB,EAA2B;MACzB,MAAM,IAAIpC,KAAJ,CAAU,gCAAV,CAAN;IACD;;IAED,OAAOgD,OAAO,CAACgB,aAAR,CAAsB5B,GAAtB,CAAP;EACD,CARD,CAQE,MAAM;IACN,MAAMtB,MAAM,GAAG1C,MAAM,CAACuC,MAAP,CAAcmD,GAAd,CAAf;;IAEA,IAAIhD,MAAM,CAACF,IAAP,KAAgB9B,QAAQ,CAAC8B,IAA7B,EAAmC;MACjC,MAAM,IAAIZ,KAAJ,CAAU,gCAAV,CAAN;IACD;;IAED,OAAO,IAAI6C,YAAJ,CAAiBiB,GAAjB,CAAP;EACD;AACF,CAlBD;;AAoBAd,OAAO,CAACiB,mBAAR,GAA+BL,GAAD,IAAS;EACrC,OAAOZ,OAAO,CAACa,eAAR,CAAwB5F,SAAS,CAAC0C,MAAV,CAAiB,MAAMiD,GAAvB,CAAxB,CAAP;AACD,CAFD;;AAIA,MAAMG,eAAe,GAAI3B,GAAD,IAAS;EAC/B;EACA,OAAOA,GAAG,CAACxB,IAAJ,KAAanB,eAAb,IAAgC2C,GAAG,CAACxB,IAAJ,KAAapB,WAApD;AACD,CAHD;;AAKAwD,OAAO,CAACgB,aAAR,GAAyB5B,GAAD,IAAS;EAC/BA,GAAG,GAAGzE,GAAG,CAACuG,KAAJ,CAAU9B,GAAV,CAAN;;EAEA,IAAI,CAACA,GAAD,IAAQ,CAAC2B,eAAe,CAAC3B,GAAD,CAA5B,EAAmC;IACjC,MAAM,IAAIpC,KAAJ,CAAU,gCAAV,CAAN;EACD;;EAED,OAAO,IAAI6C,YAAJ,CAAiBT,GAAG,CAAC+B,SAAJ,CAAcjE,KAA/B,CAAP;AACD,CARD,C,CAUA;;;AACA8C,OAAO,CAACoB,gBAAR,GAA2B,MAAOX,GAAP,IAAe;EACxC,IAAIK,GAAG,GAAGL,GAAV;;EAEA,IAAI,OAAOK,GAAP,KAAe,QAAnB,EAA6B;IAC3BA,GAAG,GAAGnF,oBAAoB,CAAC8E,GAAD,EAAM,WAAN,CAA1B;EACD;;EAED,IAAI,EAAEK,GAAG,YAAY/D,UAAjB,CAAJ,EAAkC;IAChC,MAAM,IAAIC,KAAJ,CAAU,0DAAV,CAAN;EACD;;EAED,MAAMF,MAAM,GAAG,MAAMzB,UAAU,CAACwC,kBAAX,CAA8BiD,GAA9B,CAArB;EACA,OAAOT,aAAa,CAACgB,SAAD,EAAYvE,MAAZ,CAApB;AACD,CAbD,C,CAeA;;;AACAkD,OAAO,CAACsB,iBAAR,GAA4B,MAAOb,GAAP,IAAe;EACzC,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;IAC3BA,GAAG,GAAG9E,oBAAoB,CAAC8E,GAAD,EAAM,WAAN,CAA1B;EACD;;EAED,IAAI,EAAEA,GAAG,YAAY1D,UAAjB,CAAJ,EAAkC;IAChC,MAAM,IAAIC,KAAJ,CAAU,0DAAV,CAAN;EACD;;EAED,MAAMH,OAAO,GAAG,MAAMxB,UAAU,CAACkG,mBAAX,CAA+Bd,GAA/B,CAAtB;EACA,OAAOJ,aAAa,CAACxD,OAAD,EAAUA,OAAO,CAACI,MAAlB,CAApB;AACD,CAXD;;AAaA+C,OAAO,CAACwB,cAAR,GAAyB,MAAOC,GAAP,IAAe;EACtC,MAAM7E,EAAE,GAAG3B,SAAS,CAAC0C,MAAV,CAAiB,MAAM8D,GAAG,CAAC7E,EAA3B,CAAX;EACA,MAAM8E,UAAU,GAAGD,GAAG,CAAC5E,OAAJ,IAAelB,oBAAoB,CAAC8F,GAAG,CAAC5E,OAAL,EAAc,WAAd,CAAtD;EACA,MAAM8E,SAAS,GAAGF,GAAG,CAAC3E,MAAJ,IAAcnB,oBAAoB,CAAC8F,GAAG,CAAC3E,MAAL,EAAa,WAAb,CAApD;EACA,MAAM8E,GAAG,GAAGD,SAAS,KAAI,MAAMtG,UAAU,CAACwC,kBAAX,CAA8B8D,SAA9B,CAAV,CAArB;;EAEA,IAAI,CAACD,UAAL,EAAiB;IACf,OAAO,IAAI7B,YAAJ,CAAiBjD,EAAjB,EAAqByE,SAArB,EAAgCO,GAAhC,CAAP;EACD;;EAED,MAAM/E,OAAO,GAAG,MAAMxB,UAAU,CAACkG,mBAAX,CAA+BG,UAA/B,CAAtB;EACA,MAAMG,UAAU,GAAG,MAAM3B,aAAa,CAACrD,OAAO,CAACI,MAAT,CAAtC;EAEA,IAAI6E,SAAJ;;EAEA,IAAIF,GAAJ,EAAS;IACPE,SAAS,GAAG,MAAM5B,aAAa,CAAC0B,GAAD,CAA/B;EACD;;EAED,IAAIA,GAAG,IAAI,CAACnG,gBAAgB,CAACoG,UAAD,EAAaC,SAAb,CAA5B,EAAqD;IACnD,MAAM,IAAI9E,KAAJ,CAAU,qCAAV,CAAN;EACD;;EAED,IAAIJ,EAAE,IAAI,CAACnB,gBAAgB,CAACoG,UAAD,EAAajF,EAAb,CAA3B,EAA6C;IAC3C,MAAM,IAAII,KAAJ,CAAU,iCAAV,CAAN;EACD;;EAED,OAAO,IAAI6C,YAAJ,CAAiBjD,EAAjB,EAAqBC,OAArB,EAA8B+E,GAA9B,CAAP;AACD,CA5BD;;AA8BA5B,OAAO,CAAC+B,kBAAR,GAA6B,MAAOjB,GAAP,IAAe;EAC1C,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;IAC3BA,GAAG,GAAGnF,oBAAoB,CAACmF,GAAD,EAAM,QAAN,CAA1B;EACD;;EAED,IAAI;IAAElE,EAAF;IAAMC,OAAN;IAAeC;EAAf,IAA0BvB,WAAW,CAACoC,MAAZ,CAAmBmD,GAAnB,CAA9B;EAEAjE,OAAO,GAAGA,OAAO,GAAG,MAAMxB,UAAU,CAACkG,mBAAX,CAA+B1E,OAA/B,CAAT,GAAmD,KAApE;EACAC,MAAM,GAAGA,MAAM,GAAG,MAAMzB,UAAU,CAACwC,kBAAX,CAA8Bf,MAA9B,CAAT,GAAiD,KAAhE;EAEA,IAAIgF,SAAJ;EACA,IAAID,UAAJ;;EAEA,IAAIhF,OAAJ,EAAa;IACXgF,UAAU,GAAG,MAAM3B,aAAa,CAACrD,OAAO,CAACI,MAAT,CAAhC;EACD;;EAED,IAAIH,MAAJ,EAAY;IACVgF,SAAS,GAAG,MAAM5B,aAAa,CAACpD,MAAD,CAA/B;EACD;;EAED,IAAID,OAAJ,EAAa;IACX,IAAIC,MAAJ,EAAY;MACV,IAAI,CAACrB,gBAAgB,CAACoG,UAAD,EAAaC,SAAb,CAArB,EAA8C;QAC5C,MAAM,IAAI9E,KAAJ,CAAU,qCAAV,CAAN;MACD;IACF;;IACD,OAAO,IAAI6C,YAAJ,CAAiBgC,UAAjB,EAA6BhF,OAA7B,EAAsCA,OAAO,CAACI,MAA9C,CAAP;EACD,CA5ByC,CA8B1C;;;EAEA,IAAIH,MAAJ,EAAY;IACV,OAAO,IAAI+C,YAAJ,CAAiBiC,SAAjB,EAA4BT,SAA5B,EAAuCvE,MAAvC,CAAP;EACD;;EAED,IAAIF,EAAJ,EAAQ;IACN,OAAO,IAAIiD,YAAJ,CAAiBjD,EAAjB,CAAP;EACD;;EAED,MAAM,IAAII,KAAJ,CAAU,kDAAV,CAAN;AACD,CAzCD;;AA2CAgD,OAAO,CAACgC,KAAR,GAAiBpB,GAAD,IAAS;EACvB,IAAIA,GAAG,CAACqB,MAAJ,CAAW,CAAX,MAAkB,GAAlB,IAAyBrB,GAAG,CAACqB,MAAJ,CAAW,CAAX,MAAkB,GAA/C,EAAoD;IAClD;IACA;IACArB,GAAG,GAAI,IAAGA,GAAI,EAAd;EACD;;EAED,OAAOZ,OAAO,CAACa,eAAR,CAAwB7E,WAAW,CAAC2B,MAAZ,CAAmBiD,GAAnB,CAAxB,CAAP;AACD,CARD;;AAUAZ,OAAO,CAACkC,QAAR,GAAoBC,MAAD,IAAY;EAC7B,OAAOxC,OAAO,CAAC,OAAOwC,MAAP,KAAkB,QAAlB,IACbA,MAAM,CAAChF,GADM,IAEbgF,MAAM,CAAC/E,YAFK,CAAd;AAGD,CAJD;;AAMA,SAAS6B,QAAT,CAAmBxB,GAAnB,EAAwB;EACtB,IAAIA,GAAJ,EAAS;IACP,OAAO5B,kBAAkB,CAAC4B,GAAD,EAAM,WAAN,CAAzB;EACD;AACF"},"metadata":{},"sourceType":"script"}