{"ast":null,"code":"'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst Key = require('interface-datastore').Key;\n\nconst log = require('debug')('ipfs:repo:migrator:migration-8');\n\nconst length = require('it-length');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst raw = require('multiformats/codecs/raw');\n\nconst mhd = require('multiformats/hashes/digest');\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {*} blockstore\n * @returns {Datastore}\n */\n\n\nfunction unwrap(blockstore) {\n  if (blockstore.child) {\n    return unwrap(blockstore.child);\n  }\n\n  return blockstore;\n}\n/**\n * @param {Key} key\n */\n\n\nfunction keyToMultihash(key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`); // Extract multihash from CID\n\n    const multihash = CID.decode(buf).multihash.bytes; // Encode and slice off multibase codec\n    // Should be uppercase for interop with go\n\n    const multihashStr = base32.encode(multihash).slice(1).toUpperCase();\n    return new Key(`/${multihashStr}`, false);\n  } catch (err) {\n    return key;\n  }\n}\n/**\n * @param {Key} key\n */\n\n\nfunction keyToCid(key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`);\n    const digest = mhd.decode(buf); // CID to Key\n\n    const multihash = base32.encode(CID.createV1(raw.code, digest).bytes).slice(1);\n    return new Key(`/${multihash.toUpperCase()}`, false);\n  } catch {\n    return key;\n  }\n}\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {(percent: number, message: string) => void} onProgress\n * @param {(key: Key) => Key} keyFunction\n */\n\n\nasync function process(backends, onProgress, keyFunction) {\n  const blockstore = backends.blocks;\n  await blockstore.open();\n  const unwrapped = unwrap(blockstore);\n  const blockCount = await length(unwrapped.queryKeys({\n    filters: [key => {\n      const newKey = keyFunction(key);\n      return newKey.toString() !== key.toString();\n    }]\n  }));\n\n  try {\n    let counter = 0;\n\n    for await (const block of unwrapped.query({})) {\n      const newKey = keyFunction(block.key); // If the Key is base32 CIDv0 then there's nothing to do\n\n      if (newKey.toString() !== block.key.toString()) {\n        counter += 1;\n        log(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key));\n        await unwrapped.delete(block.key);\n        await unwrapped.put(newKey, block.value);\n        onProgress(counter / blockCount * 100, `Migrated Block from ${block.key} to ${newKey}`);\n      }\n    }\n  } finally {\n    await blockstore.close();\n  }\n}\n/** @type {Migration} */\n\n\nmodule.exports = {\n  version: 8,\n  description: 'Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32',\n  migrate: function (backends) {\n    let onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n    return process(backends, onProgress, keyToMultihash);\n  },\n  revert: function (backends) {\n    let onProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n    return process(backends, onProgress, keyToCid);\n  }\n};","map":{"version":3,"names":["CID","require","Key","log","length","base32","raw","mhd","unwrap","blockstore","child","keyToMultihash","key","buf","decode","toString","toLowerCase","slice","multihash","bytes","multihashStr","encode","toUpperCase","err","keyToCid","digest","createV1","code","process","backends","onProgress","keyFunction","blocks","open","unwrapped","blockCount","queryKeys","filters","newKey","counter","block","query","has","delete","put","value","close","module","exports","version","description","migrate","revert"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-repo-migrations/migrations/migration-8/index.js"],"sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst Key = require('interface-datastore').Key\nconst log = require('debug')('ipfs:repo:migrator:migration-8')\n\nconst length = require('it-length')\nconst { base32 } = require('multiformats/bases/base32')\nconst raw = require('multiformats/codecs/raw')\nconst mhd = require('multiformats/hashes/digest')\n\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @param {*} blockstore\n * @returns {Datastore}\n */\nfunction unwrap (blockstore) {\n  if (blockstore.child) {\n    return unwrap(blockstore.child)\n  }\n\n  return blockstore\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToMultihash (key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`)\n\n    // Extract multihash from CID\n    const multihash = CID.decode(buf).multihash.bytes\n\n    // Encode and slice off multibase codec\n    // Should be uppercase for interop with go\n    const multihashStr = base32.encode(multihash).slice(1).toUpperCase()\n\n    return new Key(`/${multihashStr}`, false)\n  } catch (err) {\n    return key\n  }\n}\n\n/**\n * @param {Key} key\n */\nfunction keyToCid (key) {\n  try {\n    const buf = base32.decode(`b${key.toString().toLowerCase().slice(1)}`)\n    const digest = mhd.decode(buf)\n\n    // CID to Key\n    const multihash = base32.encode(CID.createV1(raw.code, digest).bytes).slice(1)\n\n    return new Key(`/${multihash.toUpperCase()}`, false)\n  } catch {\n    return key\n  }\n}\n\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {(percent: number, message: string) => void} onProgress\n * @param {(key: Key) => Key} keyFunction\n */\nasync function process (backends, onProgress, keyFunction) {\n  const blockstore = backends.blocks\n  await blockstore.open()\n\n  const unwrapped = unwrap(blockstore)\n\n  const blockCount = await length(unwrapped.queryKeys({\n    filters: [(key) => {\n      const newKey = keyFunction(key)\n\n      return newKey.toString() !== key.toString()\n    }]\n  }))\n\n  try {\n    let counter = 0\n\n    for await (const block of unwrapped.query({})) {\n      const newKey = keyFunction(block.key)\n\n      // If the Key is base32 CIDv0 then there's nothing to do\n      if (newKey.toString() !== block.key.toString()) {\n        counter += 1\n        log(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key))\n\n        await unwrapped.delete(block.key)\n        await unwrapped.put(newKey, block.value)\n\n        onProgress((counter / blockCount) * 100, `Migrated Block from ${block.key} to ${newKey}`)\n      }\n    }\n  } finally {\n    await blockstore.close()\n  }\n}\n\n/** @type {Migration} */\nmodule.exports = {\n  version: 8,\n  description: 'Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToMultihash)\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, keyToCid)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}