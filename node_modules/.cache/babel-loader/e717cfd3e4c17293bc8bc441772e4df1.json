{"ast":null,"code":"'use strict';\n\nconst ipns = require('ipns');\n\nconst PeerId = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns:resolver'), {\n  error: debug('ipfs:ipns:resolver:error')\n});\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultMaximumRecursiveDepth = 32;\n\nclass IpnsResolver {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   */\n  constructor(routing) {\n    this._routing = routing;\n  }\n  /**\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.recursive]\n   */\n\n\n  async resolve(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    const recursive = options.recursive && options.recursive.toString() === 'true';\n    const nameSegments = name.split('/');\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    const key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n    let depth = Infinity;\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth;\n    }\n\n    const res = await this.resolver(key, depth);\n    log(`${name} was locally resolved correctly`);\n    return res;\n  }\n  /**\n   * Recursive resolver according to the specified depth\n   *\n   * @param {string} name\n   * @param {number} depth\n   * @returns {Promise<string>}\n   */\n\n\n  async resolver(name, depth) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n    }\n\n    const res = await this._resolveName(name);\n    const nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res;\n    } // continue recursively until depth equals 0\n\n\n    return this.resolver(nameSegments[2], depth - 1);\n  }\n  /**\n   * Resolve ipns entries from the provided routing\n   *\n   * @param {string} name\n   */\n\n\n  async _resolveName(name) {\n    const peerId = PeerId.parse(name);\n    const {\n      routingKey\n    } = ipns.getIdKeys(peerId.toBytes());\n    let record;\n\n    try {\n      record = await this._routing.get(routingKey.uint8Array());\n    } catch (err) {\n      log.error('could not get record from routing', err);\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND');\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n    } // IPNS entry\n\n\n    let ipnsEntry;\n\n    try {\n      ipnsEntry = ipns.unmarshal(record);\n    } catch (err) {\n      log.error('could not unmarshal record', err);\n      throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');\n    } // We should have the public key by now (inline, or in the entry)\n\n\n    return this._validateRecord(peerId, ipnsEntry);\n  }\n  /**\n   * Validate a resolved record\n   *\n   * @param {PeerId} peerId\n   * @param {import('ipns').IPNSEntry} ipnsEntry\n   */\n\n\n  async _validateRecord(peerId, ipnsEntry) {\n    const pubKey = await ipns.extractPublicKey(peerId, ipnsEntry); // IPNS entry validation\n\n    await ipns.validate(pubKey, ipnsEntry);\n    return uint8ArrayToString(ipnsEntry.value);\n  }\n\n}\n\nexports = module.exports = IpnsResolver;","map":{"version":3,"names":["ipns","require","PeerId","errcode","debug","log","Object","assign","error","toString","uint8ArrayToString","Errors","ERR_NOT_FOUND","notFoundError","code","defaultMaximumRecursiveDepth","IpnsResolver","constructor","routing","_routing","resolve","name","options","Error","recursive","nameSegments","split","length","key","depth","Infinity","res","resolver","errMsg","_resolveName","peerId","parse","routingKey","getIdKeys","toBytes","record","get","uint8Array","err","ipnsEntry","unmarshal","_validateRecord","pubKey","extractPublicKey","validate","value","exports","module"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/ipns/resolver.js"],"sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst PeerId = require('peer-id')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns:resolver'), {\n  error: debug('ipfs:ipns:resolver:error')\n})\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\n\nconst defaultMaximumRecursiveDepth = 32\n\nclass IpnsResolver {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   */\n  constructor (routing) {\n    this._routing = routing\n  }\n\n  /**\n   * @param {string} name\n   * @param {object} options\n   * @param {boolean} [options.recursive]\n   */\n  async resolve (name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const recursive = options.recursive && options.recursive.toString() === 'true'\n\n    const nameSegments = name.split('/')\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const key = nameSegments[2]\n\n    // Define a maximum depth if recursive option enabled\n    let depth = Infinity\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth\n    }\n\n    const res = await this.resolver(key, depth)\n\n    log(`${name} was locally resolved correctly`)\n    return res\n  }\n\n  /**\n   * Recursive resolver according to the specified depth\n   *\n   * @param {string} name\n   * @param {number} depth\n   * @returns {Promise<string>}\n   */\n  async resolver (name, depth) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT')\n    }\n\n    const res = await this._resolveName(name)\n    const nameSegments = res.split('/')\n\n    // If obtained a ipfs cid or recursive option is disabled\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res\n    }\n\n    // continue recursively until depth equals 0\n    return this.resolver(nameSegments[2], depth - 1)\n  }\n\n  /**\n   * Resolve ipns entries from the provided routing\n   *\n   * @param {string} name\n   */\n  async _resolveName (name) {\n    const peerId = PeerId.parse(name)\n    const { routingKey } = ipns.getIdKeys(peerId.toBytes())\n    let record\n\n    try {\n      record = await this._routing.get(routingKey.uint8Array())\n    } catch (err) {\n      log.error('could not get record from routing', err)\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND')\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n    }\n\n    // IPNS entry\n    let ipnsEntry\n    try {\n      ipnsEntry = ipns.unmarshal(record)\n    } catch (err) {\n      log.error('could not unmarshal record', err)\n\n      throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    // We should have the public key by now (inline, or in the entry)\n    return this._validateRecord(peerId, ipnsEntry)\n  }\n\n  /**\n   * Validate a resolved record\n   *\n   * @param {PeerId} peerId\n   * @param {import('ipns').IPNSEntry} ipnsEntry\n   */\n  async _validateRecord (peerId, ipnsEntry) {\n    const pubKey = await ipns.extractPublicKey(peerId, ipnsEntry)\n\n    // IPNS entry validation\n    await ipns.validate(pubKey, ipnsEntry)\n\n    return uint8ArrayToString(ipnsEntry.value)\n  }\n}\n\nexports = module.exports = IpnsResolver\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}