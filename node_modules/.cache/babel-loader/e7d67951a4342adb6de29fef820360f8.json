{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst {\n  default: parseDuration\n} = require('parse-duration');\n\nconst crypto = require('libp2p-crypto');\n\nconst errcode = require('err-code');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst log = Object.assign(debug('ipfs:name:publish'), {\n  error: debug('ipfs:name:publish:error')\n});\n\nconst {\n  OFFLINE_ERROR,\n  normalizePath\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  resolvePath\n} = require('./utils');\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('../ipns')} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('libp2p/src/keychain')} config.keychain\n */\n\n\nmodule.exports = _ref => {\n  let {\n    ipns,\n    repo,\n    codecs,\n    peerId,\n    isOnline,\n    keychain\n  } = _ref;\n\n  /**\n   * @param {string} keyName\n   */\n  const lookupKey = async keyName => {\n    if (keyName === 'self') {\n      return peerId.privKey;\n    }\n\n    try {\n      // We're exporting and immediately importing the key, so we can just use a throw away password\n      const pem = await keychain.exportKey(keyName, 'temp');\n      const privateKey = await crypto.keys.import(pem, 'temp');\n      return privateKey;\n    } catch (err) {\n      log.error(err);\n      throw errcode(err, 'ERR_CANNOT_GET_KEY');\n    }\n  };\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"publish\"]}\n   */\n\n\n  async function publish(value) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const resolve = !(options.resolve === false);\n    const lifetime = options.lifetime || '24h';\n    const key = options.key || 'self';\n\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n    } // TODO: params related logic should be in the core implementation\n    // Normalize path value\n\n\n    try {\n      value = normalizePath(value);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    let pubLifetime = 0;\n\n    try {\n      pubLifetime = parseDuration(lifetime) || 0; // Calculate lifetime with nanoseconds precision\n\n      pubLifetime = parseFloat(pubLifetime.toFixed(6));\n    } catch (err) {\n      log.error(err);\n      throw err;\n    } // TODO: ttl human for cache\n\n\n    const results = await Promise.all([// verify if the path exists, if not, an error will stop the execution\n    lookupKey(key), // if resolving, do a get so we make sure we have the blocks\n    resolve ? resolvePath({\n      ipns,\n      repo,\n      codecs\n    }, value) : Promise.resolve()]);\n    const bytes = uint8ArrayFromString(value); // Start publishing process\n\n    const result = await ipns.publish(results[0], bytes, pubLifetime);\n    return {\n      name: result.name,\n      value: uint8ArrayToString(result.value)\n    };\n  }\n\n  return withTimeoutOption(publish);\n};","map":{"version":3,"names":["debug","require","default","parseDuration","crypto","errcode","fromString","uint8ArrayFromString","toString","uint8ArrayToString","log","Object","assign","error","OFFLINE_ERROR","normalizePath","withTimeoutOption","resolvePath","module","exports","ipns","repo","codecs","peerId","isOnline","keychain","lookupKey","keyName","privKey","pem","exportKey","privateKey","keys","import","err","publish","value","options","resolve","lifetime","key","Error","pubLifetime","parseFloat","toFixed","results","Promise","all","bytes","result","name"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/name/publish.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst { default: parseDuration } = require('parse-duration')\nconst crypto = require('libp2p-crypto')\nconst errcode = require('err-code')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst log = Object.assign(debug('ipfs:name:publish'), {\n  error: debug('ipfs:name:publish:error')\n})\n\nconst { OFFLINE_ERROR, normalizePath } = require('../../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { resolvePath } = require('./utils')\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('../ipns')} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('libp2p/src/keychain')} config.keychain\n */\nmodule.exports = ({ ipns, repo, codecs, peerId, isOnline, keychain }) => {\n  /**\n   * @param {string} keyName\n   */\n  const lookupKey = async keyName => {\n    if (keyName === 'self') {\n      return peerId.privKey\n    }\n\n    try {\n      // We're exporting and immediately importing the key, so we can just use a throw away password\n      const pem = await keychain.exportKey(keyName, 'temp')\n      const privateKey = await crypto.keys.import(pem, 'temp')\n      return privateKey\n    } catch (err) {\n      log.error(err)\n      throw errcode(err, 'ERR_CANNOT_GET_KEY')\n    }\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"publish\"]}\n   */\n  async function publish (value, options = {}) {\n    const resolve = !(options.resolve === false)\n    const lifetime = options.lifetime || '24h'\n    const key = options.key || 'self'\n\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    // TODO: params related logic should be in the core implementation\n    // Normalize path value\n    try {\n      value = normalizePath(value)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    let pubLifetime = 0\n    try {\n      pubLifetime = parseDuration(lifetime) || 0\n\n      // Calculate lifetime with nanoseconds precision\n      pubLifetime = parseFloat(pubLifetime.toFixed(6))\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    // TODO: ttl human for cache\n    const results = await Promise.all([\n      // verify if the path exists, if not, an error will stop the execution\n      lookupKey(key),\n      // if resolving, do a get so we make sure we have the blocks\n      resolve ? resolvePath({ ipns, repo, codecs }, value) : Promise.resolve()\n    ])\n\n    const bytes = uint8ArrayFromString(value)\n\n    // Start publishing process\n    const result = await ipns.publish(results[0], bytes, pubLifetime)\n\n    return {\n      name: result.name,\n      value: uint8ArrayToString(result.value)\n    }\n  }\n\n  return withTimeoutOption(publish)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}