{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('./types').Task} Task\n * @typedef {import('./types').TaskMerger} TaskMergerAPI\n */\n\n/** @type {TaskMergerAPI} */\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar TaskMerger = {\n  /**\n   * Indicates whether the given task has newer information than the active\n   * tasks with the same topic.\n   *\n   * @param {Task} task\n   * @param {Task[]} tasksWithTopic\n   * @returns {boolean}\n   */\n  hasNewInfo: function hasNewInfo(task, tasksWithTopic) {\n    var haveBlock = false;\n    var isWantBlock = false;\n\n    var _iterator = _createForOfIteratorHelper(tasksWithTopic),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var existing = _step.value;\n\n        if (existing.data.haveBlock) {\n          haveBlock = true;\n        }\n\n        if (existing.data.isWantBlock) {\n          isWantBlock = true;\n        }\n      } // If there is no active want-block and the new task is a want-block,\n      // the new task is better\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (!isWantBlock && task.data.isWantBlock) {\n      return true;\n    } // If we didn't have the block, and the new task indicates that we now\n    // do have the block, then we must also have size information for the\n    // block, so the new task has new information.\n\n\n    if (!haveBlock && task.data.haveBlock) {\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * Merge the information from the given task into the existing task (with the\n   * same topic)\n   *\n   * @param {Task} newTask\n   * @param {Task} existingTask\n   */\n  merge: function merge(newTask, existingTask) {\n    // The merge function ignores the topic and priority as these don't change.\n    //\n    // We may receive new information about a want before the want has been\n    // popped from the queue in the following scenarios:\n    //\n    // - Replace want type:\n    //   1. Client sends want-have CID1\n    //   2. Client sends want-block CID1\n    //   In this case we should replace want-have with want-block, including\n    //   updating the task size to be the block size.\n    //\n    // - Replace DONT_HAVE with want:\n    //   1. Client sends want-have CID1 or want-block CID1\n    //   2. Local node doesn't have block for CID1\n    //   3. Local node receives block for CID1 from peer\n    //   In this case we should replace DONT_HAVE with the want, including\n    //   updating the task size and block size.\n    var taskData = newTask.data;\n    var existingData = existingTask.data; // If we didn't have block size information (because we didn't have the\n    // block) and we receive the block from a peer, update the task with the\n    // new block size\n\n    if (!existingData.haveBlock && taskData.haveBlock) {\n      existingData.haveBlock = taskData.haveBlock;\n      existingData.blockSize = taskData.blockSize;\n    } // If replacing a want-have with a want-block\n\n\n    if (!existingData.isWantBlock && taskData.isWantBlock) {\n      // Change the type from want-have to want-block\n      existingData.isWantBlock = true; // If the want-have was a DONT_HAVE, or the want-block has a size\n\n      if (!existingData.haveBlock || taskData.haveBlock) {\n        // Update the entry size\n        existingData.haveBlock = taskData.haveBlock;\n        existingTask.size = newTask.size;\n      }\n    } // If the task is a want-block, make sure the entry size is equal\n    // to the block size (because we will send the whole block)\n\n\n    if (existingData.isWantBlock && existingData.haveBlock) {\n      existingTask.size = existingData.blockSize;\n    }\n  }\n};\nmodule.exports = TaskMerger;","map":{"version":3,"names":["TaskMerger","hasNewInfo","task","tasksWithTopic","haveBlock","isWantBlock","existing","data","merge","newTask","existingTask","taskData","existingData","blockSize","size","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-bitswap/src/decision-engine/task-merger.js"],"sourcesContent":["'use strict'\n\n/**\n * @typedef {import('./types').Task} Task\n * @typedef {import('./types').TaskMerger} TaskMergerAPI\n */\n\n/** @type {TaskMergerAPI} */\nconst TaskMerger = {\n  /**\n   * Indicates whether the given task has newer information than the active\n   * tasks with the same topic.\n   *\n   * @param {Task} task\n   * @param {Task[]} tasksWithTopic\n   * @returns {boolean}\n   */\n  hasNewInfo (task, tasksWithTopic) {\n    let haveBlock = false\n    let isWantBlock = false\n    for (const existing of tasksWithTopic) {\n      if (existing.data.haveBlock) {\n        haveBlock = true\n      }\n\n      if (existing.data.isWantBlock) {\n        isWantBlock = true\n      }\n    }\n\n    // If there is no active want-block and the new task is a want-block,\n    // the new task is better\n    if (!isWantBlock && task.data.isWantBlock) {\n      return true\n    }\n\n    // If we didn't have the block, and the new task indicates that we now\n    // do have the block, then we must also have size information for the\n    // block, so the new task has new information.\n    if (!haveBlock && task.data.haveBlock) {\n      return true\n    }\n\n    return false\n  },\n\n  /**\n   * Merge the information from the given task into the existing task (with the\n   * same topic)\n   *\n   * @param {Task} newTask\n   * @param {Task} existingTask\n   */\n  merge (newTask, existingTask) {\n    // The merge function ignores the topic and priority as these don't change.\n    //\n    // We may receive new information about a want before the want has been\n    // popped from the queue in the following scenarios:\n    //\n    // - Replace want type:\n    //   1. Client sends want-have CID1\n    //   2. Client sends want-block CID1\n    //   In this case we should replace want-have with want-block, including\n    //   updating the task size to be the block size.\n    //\n    // - Replace DONT_HAVE with want:\n    //   1. Client sends want-have CID1 or want-block CID1\n    //   2. Local node doesn't have block for CID1\n    //   3. Local node receives block for CID1 from peer\n    //   In this case we should replace DONT_HAVE with the want, including\n    //   updating the task size and block size.\n    const taskData = newTask.data\n    const existingData = existingTask.data\n\n    // If we didn't have block size information (because we didn't have the\n    // block) and we receive the block from a peer, update the task with the\n    // new block size\n    if (!existingData.haveBlock && taskData.haveBlock) {\n      existingData.haveBlock = taskData.haveBlock\n      existingData.blockSize = taskData.blockSize\n    }\n\n    // If replacing a want-have with a want-block\n    if (!existingData.isWantBlock && taskData.isWantBlock) {\n      // Change the type from want-have to want-block\n      existingData.isWantBlock = true\n      // If the want-have was a DONT_HAVE, or the want-block has a size\n      if (!existingData.haveBlock || taskData.haveBlock) {\n        // Update the entry size\n        existingData.haveBlock = taskData.haveBlock\n        existingTask.size = newTask.size\n      }\n    }\n\n    // If the task is a want-block, make sure the entry size is equal\n    // to the block size (because we will send the whole block)\n    if (existingData.isWantBlock && existingData.haveBlock) {\n      existingTask.size = existingData.blockSize\n    }\n  }\n}\n\nmodule.exports = TaskMerger\n"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;;AAEA;;;;AACA,IAAMA,UAAU,GAAG;EACjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,UATiB,sBASLC,IATK,EASCC,cATD,EASiB;IAChC,IAAIC,SAAS,GAAG,KAAhB;IACA,IAAIC,WAAW,GAAG,KAAlB;;IAFgC,2CAGTF,cAHS;IAAA;;IAAA;MAGhC,oDAAuC;QAAA,IAA5BG,QAA4B;;QACrC,IAAIA,QAAQ,CAACC,IAAT,CAAcH,SAAlB,EAA6B;UAC3BA,SAAS,GAAG,IAAZ;QACD;;QAED,IAAIE,QAAQ,CAACC,IAAT,CAAcF,WAAlB,EAA+B;UAC7BA,WAAW,GAAG,IAAd;QACD;MACF,CAX+B,CAahC;MACA;;IAdgC;MAAA;IAAA;MAAA;IAAA;;IAehC,IAAI,CAACA,WAAD,IAAgBH,IAAI,CAACK,IAAL,CAAUF,WAA9B,EAA2C;MACzC,OAAO,IAAP;IACD,CAjB+B,CAmBhC;IACA;IACA;;;IACA,IAAI,CAACD,SAAD,IAAcF,IAAI,CAACK,IAAL,CAAUH,SAA5B,EAAuC;MACrC,OAAO,IAAP;IACD;;IAED,OAAO,KAAP;EACD,CApCgB;;EAsCjB;AACF;AACA;AACA;AACA;AACA;AACA;EACEI,KA7CiB,iBA6CVC,OA7CU,EA6CDC,YA7CC,EA6Ca;IAC5B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAMC,QAAQ,GAAGF,OAAO,CAACF,IAAzB;IACA,IAAMK,YAAY,GAAGF,YAAY,CAACH,IAAlC,CAnB4B,CAqB5B;IACA;IACA;;IACA,IAAI,CAACK,YAAY,CAACR,SAAd,IAA2BO,QAAQ,CAACP,SAAxC,EAAmD;MACjDQ,YAAY,CAACR,SAAb,GAAyBO,QAAQ,CAACP,SAAlC;MACAQ,YAAY,CAACC,SAAb,GAAyBF,QAAQ,CAACE,SAAlC;IACD,CA3B2B,CA6B5B;;;IACA,IAAI,CAACD,YAAY,CAACP,WAAd,IAA6BM,QAAQ,CAACN,WAA1C,EAAuD;MACrD;MACAO,YAAY,CAACP,WAAb,GAA2B,IAA3B,CAFqD,CAGrD;;MACA,IAAI,CAACO,YAAY,CAACR,SAAd,IAA2BO,QAAQ,CAACP,SAAxC,EAAmD;QACjD;QACAQ,YAAY,CAACR,SAAb,GAAyBO,QAAQ,CAACP,SAAlC;QACAM,YAAY,CAACI,IAAb,GAAoBL,OAAO,CAACK,IAA5B;MACD;IACF,CAvC2B,CAyC5B;IACA;;;IACA,IAAIF,YAAY,CAACP,WAAb,IAA4BO,YAAY,CAACR,SAA7C,EAAwD;MACtDM,YAAY,CAACI,IAAb,GAAoBF,YAAY,CAACC,SAAjC;IACD;EACF;AA3FgB,CAAnB;AA8FAE,MAAM,CAACC,OAAP,GAAiBhB,UAAjB"},"metadata":{},"sourceType":"script"}