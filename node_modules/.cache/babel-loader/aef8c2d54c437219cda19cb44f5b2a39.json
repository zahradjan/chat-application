{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar errcode = require('err-code');\n\nvar pTimeout = require('p-timeout');\n\nvar c = require('../constants');\n\nvar LimitedPeerList = require('../peer-list/limited-peer-list');\n\nvar Message = require('../message');\n\nvar Query = require('../query');\n\nvar utils = require('../utils');\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {import('../')} dht\n */\n\n\nmodule.exports = function (dht) {\n  /**\n   * Check for providers from a single node.\n   *\n   * @param {PeerId} peer\n   * @param {CID} key\n   *\n   * @private\n   */\n  var findProvidersSingle = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(peer, key) {\n      var msg;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // eslint-disable-line require-await\n              msg = new Message(Message.TYPES.GET_PROVIDERS, key.bytes, 0);\n              return _context.abrupt(\"return\", dht.network.sendRequest(peer, msg));\n\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function findProvidersSingle(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  return {\n    /**\n     * Announce to the network that we can provide the value for a given key\n     *\n     * @param {CID} key\n     */\n    provide: function provide(key) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var errors, multiaddrs, msg, mapPeer, _mapPeer;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _mapPeer = function _mapPeer3() {\n                  _mapPeer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peer) {\n                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            dht._log(\"putProvider \".concat(key, \" to \").concat(peer.toB58String()));\n\n                            _context2.prev = 1;\n                            _context2.next = 4;\n                            return dht.network.sendMessage(peer, msg);\n\n                          case 4:\n                            _context2.next = 9;\n                            break;\n\n                          case 6:\n                            _context2.prev = 6;\n                            _context2.t0 = _context2[\"catch\"](1);\n                            errors.push(_context2.t0);\n\n                          case 9:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, null, [[1, 6]]);\n                  }));\n                  return _mapPeer.apply(this, arguments);\n                };\n\n                mapPeer = function _mapPeer2(_x3) {\n                  return _mapPeer.apply(this, arguments);\n                };\n\n                dht._log(\"provide: \".concat(key));\n                /** @type {Error[]} */\n\n\n                errors = []; // Add peer as provider\n\n                _context3.next = 6;\n                return dht.providers.addProvider(key, dht.peerId);\n\n              case 6:\n                multiaddrs = dht.libp2p ? dht.libp2p.multiaddrs : [];\n                msg = new Message(Message.TYPES.ADD_PROVIDER, key.bytes, 0);\n                msg.providerPeers = [{\n                  id: dht.peerId,\n                  multiaddrs: multiaddrs\n                }];\n                /**\n                 * @param {PeerId} peer\n                 */\n\n                _context3.next = 11;\n                return utils.mapParallel(dht.getClosestPeers(key.bytes), mapPeer);\n\n              case 11:\n                if (!errors.length) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                throw errcode(new Error(\"Failed to provide to \".concat(errors.length, \" of \").concat(dht.kBucketSize, \" peers\")), 'ERR_SOME_PROVIDES_FAILED', {\n                  errors: errors\n                });\n\n              case 13:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    },\n\n    /**\n     * Search the dht for up to `K` providers of the given CID.\n     *\n     * @param {CID} key\n     * @param {Object} [options] - findProviders options\n     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds\n     * @param {number} [options.maxNumProviders=5] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    findProviders: function findProviders(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        timeout: 60000,\n        maxNumProviders: 5\n      };\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var providerTimeout, n, out, provs, _iterator, _step, pData, paths, makePath, query, peers, _iterator2, _step2, _pData;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                makePath = function _makePath(pathIndex, numPaths) {\n                  // This function body runs once per disjoint path\n                  var pathSize = utils.pathSize(n - out.length, numPaths);\n                  var pathProviders = new LimitedPeerList(pathSize);\n                  paths.push(pathProviders);\n                  /**\n                   * The query function to use on this particular disjoint path\n                   *\n                   * @param {PeerId} peer\n                   */\n\n                  function queryDisjointPath(_x4) {\n                    return _queryDisjointPath.apply(this, arguments);\n                  }\n\n                  function _queryDisjointPath() {\n                    _queryDisjointPath = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(peer) {\n                      var msg, provs;\n                      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                        while (1) {\n                          switch (_context4.prev = _context4.next) {\n                            case 0:\n                              _context4.next = 2;\n                              return findProvidersSingle(peer, key);\n\n                            case 2:\n                              msg = _context4.sent;\n                              provs = msg.providerPeers;\n\n                              dht._log(\"Found \".concat(provs.length, \" provider entries for \").concat(key));\n\n                              provs.forEach(function (prov) {\n                                pathProviders.push(_objectSpread({}, prov));\n                              }); // hooray we have all that we want\n\n                              if (!(pathProviders.length >= pathSize)) {\n                                _context4.next = 8;\n                                break;\n                              }\n\n                              return _context4.abrupt(\"return\", {\n                                pathComplete: true\n                              });\n\n                            case 8:\n                              return _context4.abrupt(\"return\", {\n                                closerPeers: msg.closerPeers\n                              });\n\n                            case 9:\n                            case \"end\":\n                              return _context4.stop();\n                          }\n                        }\n                      }, _callee4);\n                    }));\n                    return _queryDisjointPath.apply(this, arguments);\n                  }\n\n                  return queryDisjointPath;\n                };\n\n                providerTimeout = options.timeout || c.minute;\n                n = options.maxNumProviders || c.K;\n\n                dht._log(\"findProviders \".concat(key));\n\n                out = new LimitedPeerList(n);\n                _context5.next = 7;\n                return _awaitAsyncGenerator(dht.providers.getProviders(key));\n\n              case 7:\n                provs = _context5.sent;\n                provs.forEach(function (id) {\n                  /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n                  var peerData = dht.peerStore.get(id);\n\n                  if (peerData) {\n                    out.push({\n                      id: peerData.id,\n                      multiaddrs: peerData.addresses.map(function (address) {\n                        return address.multiaddr;\n                      })\n                    });\n                  } else {\n                    out.push({\n                      id: id,\n                      multiaddrs: []\n                    });\n                  }\n                }); // All done\n\n                if (!(out.length >= n)) {\n                  _context5.next = 28;\n                  break;\n                }\n\n                // yield values\n                _iterator = _createForOfIteratorHelper(out.toArray());\n                _context5.prev = 11;\n\n                _iterator.s();\n\n              case 13:\n                if ((_step = _iterator.n()).done) {\n                  _context5.next = 19;\n                  break;\n                }\n\n                pData = _step.value;\n                _context5.next = 17;\n                return pData;\n\n              case 17:\n                _context5.next = 13;\n                break;\n\n              case 19:\n                _context5.next = 24;\n                break;\n\n              case 21:\n                _context5.prev = 21;\n                _context5.t0 = _context5[\"catch\"](11);\n\n                _iterator.e(_context5.t0);\n\n              case 24:\n                _context5.prev = 24;\n\n                _iterator.f();\n\n                return _context5.finish(24);\n\n              case 27:\n                return _context5.abrupt(\"return\");\n\n              case 28:\n                // need more, query the network\n\n                /** @type {LimitedPeerList[]} */\n                paths = [];\n                /**\n                 *\n                 * @param {number} pathIndex\n                 * @param {number} numPaths\n                 */\n\n                query = new Query(dht, key.bytes, makePath);\n                peers = dht.routingTable.closestPeers(key.bytes, dht.kBucketSize);\n                _context5.prev = 31;\n                _context5.next = 34;\n                return _awaitAsyncGenerator(pTimeout(query.run(peers), providerTimeout));\n\n              case 34:\n                _context5.next = 40;\n                break;\n\n              case 36:\n                _context5.prev = 36;\n                _context5.t1 = _context5[\"catch\"](31);\n\n                if (!(_context5.t1.name !== pTimeout.TimeoutError.name)) {\n                  _context5.next = 40;\n                  break;\n                }\n\n                throw _context5.t1;\n\n              case 40:\n                _context5.prev = 40;\n                query.stop();\n                return _context5.finish(40);\n\n              case 43:\n                // combine peers from each path\n                paths.forEach(function (path) {\n                  path.toArray().forEach(function (peer) {\n                    out.push(peer);\n                  });\n                });\n                _iterator2 = _createForOfIteratorHelper(out.toArray());\n                _context5.prev = 45;\n\n                _iterator2.s();\n\n              case 47:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context5.next = 53;\n                  break;\n                }\n\n                _pData = _step2.value;\n                _context5.next = 51;\n                return _pData;\n\n              case 51:\n                _context5.next = 47;\n                break;\n\n              case 53:\n                _context5.next = 58;\n                break;\n\n              case 55:\n                _context5.prev = 55;\n                _context5.t2 = _context5[\"catch\"](45);\n\n                _iterator2.e(_context5.t2);\n\n              case 58:\n                _context5.prev = 58;\n\n                _iterator2.f();\n\n                return _context5.finish(58);\n\n              case 61:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[11, 21, 24, 27], [31, 36, 40, 43], [45, 55, 58, 61]]);\n      }))();\n    }\n  };\n};","map":{"version":3,"names":["errcode","require","pTimeout","c","LimitedPeerList","Message","Query","utils","module","exports","dht","findProvidersSingle","peer","key","msg","TYPES","GET_PROVIDERS","bytes","network","sendRequest","provide","mapPeer","_log","toB58String","sendMessage","errors","push","providers","addProvider","peerId","multiaddrs","libp2p","ADD_PROVIDER","providerPeers","id","mapParallel","getClosestPeers","length","Error","kBucketSize","findProviders","options","timeout","maxNumProviders","makePath","pathIndex","numPaths","pathSize","n","out","pathProviders","paths","queryDisjointPath","provs","forEach","prov","pathComplete","closerPeers","providerTimeout","minute","K","getProviders","peerData","peerStore","get","addresses","map","address","multiaddr","toArray","pData","query","peers","routingTable","closestPeers","run","name","TimeoutError","stop","path"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-kad-dht/src/content-routing/index.js"],"sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\n\nconst c = require('../constants')\nconst LimitedPeerList = require('../peer-list/limited-peer-list')\nconst Message = require('../message')\nconst Query = require('../query')\nconst utils = require('../utils')\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {import('../')} dht\n */\nmodule.exports = (dht) => {\n  /**\n   * Check for providers from a single node.\n   *\n   * @param {PeerId} peer\n   * @param {CID} key\n   *\n   * @private\n   */\n  const findProvidersSingle = async (peer, key) => { // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_PROVIDERS, key.bytes, 0)\n    return dht.network.sendRequest(peer, msg)\n  }\n\n  return {\n    /**\n     * Announce to the network that we can provide the value for a given key\n     *\n     * @param {CID} key\n     */\n    async provide (key) {\n      dht._log(`provide: ${key}`)\n\n      /** @type {Error[]} */\n      const errors = []\n\n      // Add peer as provider\n      await dht.providers.addProvider(key, dht.peerId)\n\n      const multiaddrs = dht.libp2p ? dht.libp2p.multiaddrs : []\n      const msg = new Message(Message.TYPES.ADD_PROVIDER, key.bytes, 0)\n      msg.providerPeers = [{\n        id: dht.peerId,\n        multiaddrs\n      }]\n\n      /**\n       * @param {PeerId} peer\n       */\n      async function mapPeer (peer) {\n        dht._log(`putProvider ${key} to ${peer.toB58String()}`)\n        try {\n          await dht.network.sendMessage(peer, msg)\n        } catch (err) {\n          errors.push(err)\n        }\n      }\n\n      // Notify closest peers\n      await utils.mapParallel(dht.getClosestPeers(key.bytes), mapPeer)\n\n      if (errors.length) {\n        // TODO:\n        // This should be infrequent. This means a peer we previously connected\n        // to failed to exchange the provide message. If getClosestPeers was an\n        // iterator, we could continue to pull until we announce to kBucketSize peers.\n        throw errcode(new Error(`Failed to provide to ${errors.length} of ${dht.kBucketSize} peers`), 'ERR_SOME_PROVIDES_FAILED', { errors })\n      }\n    },\n\n    /**\n     * Search the dht for up to `K` providers of the given CID.\n     *\n     * @param {CID} key\n     * @param {Object} [options] - findProviders options\n     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds\n     * @param {number} [options.maxNumProviders=5] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async * findProviders (key, options = { timeout: 60000, maxNumProviders: 5 }) {\n      const providerTimeout = options.timeout || c.minute\n      const n = options.maxNumProviders || c.K\n\n      dht._log(`findProviders ${key}`)\n\n      const out = new LimitedPeerList(n)\n      const provs = await dht.providers.getProviders(key)\n\n      provs\n        .forEach(id => {\n          /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n          const peerData = dht.peerStore.get(id)\n\n          if (peerData) {\n            out.push({\n              id: peerData.id,\n              multiaddrs: peerData.addresses\n                .map((address) => address.multiaddr)\n            })\n          } else {\n            out.push({\n              id,\n              multiaddrs: []\n            })\n          }\n        })\n\n      // All done\n      if (out.length >= n) {\n        // yield values\n        for (const pData of out.toArray()) {\n          yield pData\n        }\n        return\n      }\n\n      // need more, query the network\n      /** @type {LimitedPeerList[]} */\n      const paths = []\n\n      /**\n       *\n       * @param {number} pathIndex\n       * @param {number} numPaths\n       */\n      function makePath (pathIndex, numPaths) {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(n - out.length, numPaths)\n        const pathProviders = new LimitedPeerList(pathSize)\n        paths.push(pathProviders)\n\n        /**\n         * The query function to use on this particular disjoint path\n         *\n         * @param {PeerId} peer\n         */\n        async function queryDisjointPath (peer) {\n          const msg = await findProvidersSingle(peer, key)\n          const provs = msg.providerPeers\n          dht._log(`Found ${provs.length} provider entries for ${key}`)\n\n          provs.forEach((prov) => {\n            pathProviders.push({\n              ...prov\n            })\n          })\n\n          // hooray we have all that we want\n          if (pathProviders.length >= pathSize) {\n            return { pathComplete: true }\n          }\n\n          // it looks like we want some more\n          return { closerPeers: msg.closerPeers }\n        }\n\n        return queryDisjointPath\n      }\n\n      const query = new Query(dht, key.bytes, makePath)\n      const peers = dht.routingTable.closestPeers(key.bytes, dht.kBucketSize)\n\n      try {\n        await pTimeout(\n          query.run(peers),\n          providerTimeout\n        )\n      } catch (err) {\n        if (err.name !== pTimeout.TimeoutError.name) {\n          throw err\n        }\n      } finally {\n        query.stop()\n      }\n\n      // combine peers from each path\n      paths.forEach((path) => {\n        path.toArray().forEach((peer) => {\n          out.push(peer)\n        })\n      })\n\n      for (const pData of out.toArray()) {\n        yield pData\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}