{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _toConsumableArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('libp2p:dialer'), {\n  error: debug('libp2p:dialer:err')\n});\n\nvar errCode = require('err-code');\n\nvar _require = require('multiaddr'),\n    Multiaddr = _require.Multiaddr; // @ts-ignore timeout-abourt-controles does not export types\n\n\nvar TimeoutController = require('timeout-abort-controller');\n\nvar _require2 = require('abortable-iterator'),\n    AbortError = _require2.AbortError;\n\nvar _require3 = require('any-signal'),\n    anySignal = _require3.anySignal;\n\nvar DialRequest = require('./dial-request');\n\nvar _require4 = require('libp2p-utils/src/address-sort'),\n    publicAddressesFirst = _require4.publicAddressesFirst;\n\nvar getPeer = require('../get-peer');\n\nvar _require5 = require('../errors'),\n    codes = _require5.codes;\n\nvar _require6 = require('../constants'),\n    DIAL_TIMEOUT = _require6.DIAL_TIMEOUT,\n    MAX_PARALLEL_DIALS = _require6.MAX_PARALLEL_DIALS,\n    MAX_PER_PEER_DIALS = _require6.MAX_PER_PEER_DIALS,\n    MAX_ADDRS_TO_DIAL = _require6.MAX_ADDRS_TO_DIAL;\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../peer-store')} PeerStore\n * @typedef {import('../peer-store/address-book').Address} Address\n * @typedef {import('../transport-manager')} TransportManager\n */\n\n/**\n * @typedef {Object} DialerProperties\n * @property {PeerStore} peerStore\n * @property {TransportManager} transportManager\n *\n * @typedef {(addr:Multiaddr) => Promise<string[]>} Resolver\n *\n * @typedef {Object} DialerOptions\n * @property {(addresses: Address[]) => Address[]} [options.addressSorter = publicAddressesFirst] - Sort the known addresses of a peer before trying to dial.\n * @property {number} [maxParallelDials = MAX_PARALLEL_DIALS] - Number of max concurrent dials.\n * @property {number} [maxAddrsToDial = MAX_ADDRS_TO_DIAL] - Number of max addresses to dial for a given peer.\n * @property {number} [maxDialsPerPeer = MAX_PER_PEER_DIALS] - Number of max concurrent dials per peer.\n * @property {number} [dialTimeout = DIAL_TIMEOUT] - How long a dial attempt is allowed to take.\n * @property {Record<string, Resolver>} [resolvers = {}] - multiaddr resolvers to use when dialing\n *\n * @typedef DialTarget\n * @property {string} id\n * @property {Multiaddr[]} addrs\n *\n * @typedef PendingDial\n * @property {DialRequest} dialRequest\n * @property {TimeoutController} controller\n * @property {Promise<Connection>} promise\n * @property {function():void} destroy\n */\n\n\nvar Dialer = /*#__PURE__*/function () {\n  /**\n   * @class\n   * @param {DialerProperties & DialerOptions} options\n   */\n  function Dialer(_ref) {\n    var transportManager = _ref.transportManager,\n        peerStore = _ref.peerStore,\n        _ref$addressSorter = _ref.addressSorter,\n        addressSorter = _ref$addressSorter === void 0 ? publicAddressesFirst : _ref$addressSorter,\n        _ref$maxParallelDials = _ref.maxParallelDials,\n        maxParallelDials = _ref$maxParallelDials === void 0 ? MAX_PARALLEL_DIALS : _ref$maxParallelDials,\n        _ref$maxAddrsToDial = _ref.maxAddrsToDial,\n        maxAddrsToDial = _ref$maxAddrsToDial === void 0 ? MAX_ADDRS_TO_DIAL : _ref$maxAddrsToDial,\n        _ref$dialTimeout = _ref.dialTimeout,\n        dialTimeout = _ref$dialTimeout === void 0 ? DIAL_TIMEOUT : _ref$dialTimeout,\n        _ref$maxDialsPerPeer = _ref.maxDialsPerPeer,\n        maxDialsPerPeer = _ref$maxDialsPerPeer === void 0 ? MAX_PER_PEER_DIALS : _ref$maxDialsPerPeer,\n        _ref$resolvers = _ref.resolvers,\n        resolvers = _ref$resolvers === void 0 ? {} : _ref$resolvers;\n\n    _classCallCheck(this, Dialer);\n\n    this.transportManager = transportManager;\n    this.peerStore = peerStore;\n    this.addressSorter = addressSorter;\n    this.maxParallelDials = maxParallelDials;\n    this.maxAddrsToDial = maxAddrsToDial;\n    this.timeout = dialTimeout;\n    this.maxDialsPerPeer = maxDialsPerPeer;\n    this.tokens = _toConsumableArray(new Array(maxParallelDials)).map(function (_, index) {\n      return index;\n    });\n    this._pendingDials = new Map();\n    this._pendingDialTargets = new Map();\n\n    for (var _i = 0, _Object$entries = Object.entries(resolvers); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          key = _Object$entries$_i[0],\n          value = _Object$entries$_i[1];\n\n      Multiaddr.resolvers.set(key, value);\n    }\n  }\n  /**\n   * Clears any pending dials\n   */\n\n\n  _createClass(Dialer, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _iterator = _createForOfIteratorHelper(this._pendingDials.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dial = _step.value;\n\n          try {\n            dial.controller.abort();\n          } catch (err) {\n            log.error(err);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this._pendingDials.clear();\n\n      var _iterator2 = _createForOfIteratorHelper(this._pendingDialTargets.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var pendingTarget = _step2.value;\n          pendingTarget.reject(new AbortError('Dialer was destroyed'));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this._pendingDialTargets.clear();\n    }\n    /**\n     * Connects to a given `peer` by dialing all of its known addresses.\n     * The dial to the first address that is successfully able to upgrade a connection\n     * will be used.\n     *\n     * @param {PeerId|Multiaddr|string} peer - The peer to dial\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal] - An AbortController signal\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"connectToPeer\",\n    value: function () {\n      var _connectToPeer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(peer) {\n        var options,\n            dialTarget,\n            pendingDial,\n            connection,\n            _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                _context.next = 3;\n                return this._createCancellableDialTarget(peer);\n\n              case 3:\n                dialTarget = _context.sent;\n\n                if (dialTarget.addrs.length) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES);\n\n              case 6:\n                pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);\n                _context.prev = 7;\n                _context.next = 10;\n                return pendingDial.promise;\n\n              case 10:\n                connection = _context.sent;\n                log('dial succeeded to %s', dialTarget.id);\n                return _context.abrupt(\"return\", connection);\n\n              case 15:\n                _context.prev = 15;\n                _context.t0 = _context[\"catch\"](7);\n\n                // Error is a timeout\n                if (pendingDial.controller.signal.aborted) {\n                  _context.t0.code = codes.ERR_TIMEOUT;\n                }\n\n                log.error(_context.t0);\n                throw _context.t0;\n\n              case 20:\n                _context.prev = 20;\n                pendingDial.destroy();\n                return _context.finish(20);\n\n              case 23:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 15, 20, 23]]);\n      }));\n\n      function connectToPeer(_x) {\n        return _connectToPeer.apply(this, arguments);\n      }\n\n      return connectToPeer;\n    }()\n    /**\n     * Connects to a given `peer` by dialing all of its known addresses.\n     * The dial to the first address that is successfully able to upgrade a connection\n     * will be used.\n     *\n     * @param {PeerId|Multiaddr|string} peer - The peer to dial\n     * @returns {Promise<DialTarget>}\n     */\n\n  }, {\n    key: \"_createCancellableDialTarget\",\n    value: function () {\n      var _createCancellableDialTarget2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(peer) {\n        var _this = this;\n\n        var id, cancellablePromise, dialTarget;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // Make dial target promise cancellable\n                id = \"\".concat(parseInt(String(Math.random() * 1e9), 10).toString() + Date.now());\n                cancellablePromise = new Promise(function (resolve, reject) {\n                  _this._pendingDialTargets.set(id, {\n                    resolve: resolve,\n                    reject: reject\n                  });\n                });\n                _context2.next = 4;\n                return Promise.race([this._createDialTarget(peer), cancellablePromise]);\n\n              case 4:\n                dialTarget = _context2.sent;\n\n                this._pendingDialTargets.delete(id);\n\n                return _context2.abrupt(\"return\", dialTarget);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _createCancellableDialTarget(_x2) {\n        return _createCancellableDialTarget2.apply(this, arguments);\n      }\n\n      return _createCancellableDialTarget;\n    }()\n    /**\n     * Creates a DialTarget. The DialTarget is used to create and track\n     * the DialRequest to a given peer.\n     * If a multiaddr is received it should be the first address attempted.\n     * Multiaddrs not supported by the available transports will be filtered out.\n     *\n     * @private\n     * @param {PeerId|Multiaddr|string} peer - A PeerId or Multiaddr\n     * @returns {Promise<DialTarget>}\n     */\n\n  }, {\n    key: \"_createDialTarget\",\n    value: function () {\n      var _createDialTarget2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(peer) {\n        var _this2 = this;\n\n        var _getPeer, id, multiaddrs, knownAddrs, addrs, _iterator3, _step3, a, resolvedAddrs, supportedAddrs;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _getPeer = getPeer(peer), id = _getPeer.id, multiaddrs = _getPeer.multiaddrs;\n\n                if (multiaddrs) {\n                  this.peerStore.addressBook.add(id, multiaddrs);\n                }\n\n                knownAddrs = this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter) || []; // If received a multiaddr to dial, it should be the first to use\n                // But, if we know other multiaddrs for the peer, we should try them too.\n\n                if (Multiaddr.isMultiaddr(peer)) {\n                  knownAddrs = knownAddrs.filter(function (addr) {\n                    return !peer.equals(addr);\n                  });\n                  knownAddrs.unshift(peer);\n                }\n                /** @type {Multiaddr[]} */\n\n\n                addrs = [];\n                _iterator3 = _createForOfIteratorHelper(knownAddrs);\n                _context3.prev = 6;\n\n                _iterator3.s();\n\n              case 8:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context3.next = 16;\n                  break;\n                }\n\n                a = _step3.value;\n                _context3.next = 12;\n                return this._resolve(a);\n\n              case 12:\n                resolvedAddrs = _context3.sent;\n                resolvedAddrs.forEach(function (ra) {\n                  return addrs.push(ra);\n                });\n\n              case 14:\n                _context3.next = 8;\n                break;\n\n              case 16:\n                _context3.next = 21;\n                break;\n\n              case 18:\n                _context3.prev = 18;\n                _context3.t0 = _context3[\"catch\"](6);\n\n                _iterator3.e(_context3.t0);\n\n              case 21:\n                _context3.prev = 21;\n\n                _iterator3.f();\n\n                return _context3.finish(21);\n\n              case 24:\n                // Multiaddrs not supported by the available transports will be filtered out.\n                supportedAddrs = addrs.filter(function (a) {\n                  return _this2.transportManager.transportForMultiaddr(a);\n                });\n\n                if (!(supportedAddrs.length > this.maxAddrsToDial)) {\n                  _context3.next = 28;\n                  break;\n                }\n\n                this.peerStore.delete(id);\n                throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES);\n\n              case 28:\n                return _context3.abrupt(\"return\", {\n                  id: id.toB58String(),\n                  addrs: supportedAddrs\n                });\n\n              case 29:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[6, 18, 21, 24]]);\n      }));\n\n      function _createDialTarget(_x3) {\n        return _createDialTarget2.apply(this, arguments);\n      }\n\n      return _createDialTarget;\n    }()\n    /**\n     * Creates a PendingDial that wraps the underlying DialRequest\n     *\n     * @private\n     * @param {DialTarget} dialTarget\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal] - An AbortController signal\n     * @returns {PendingDial}\n     */\n\n  }, {\n    key: \"_createPendingDial\",\n    value: function _createPendingDial(dialTarget) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      /**\n       * @param {Multiaddr} addr\n       * @param {{ signal: { aborted: any; }; }} options\n       */\n      var dialAction = function dialAction(addr, options) {\n        if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n        return _this3.transportManager.dial(addr, options);\n      };\n\n      var dialRequest = new DialRequest({\n        addrs: dialTarget.addrs,\n        dialAction: dialAction,\n        dialer: this\n      }); // Combine the timeout signal and options.signal, if provided\n\n      var timeoutController = new TimeoutController(this.timeout);\n      var signals = [timeoutController.signal];\n      options.signal && signals.push(options.signal);\n      var signal = anySignal(signals);\n      var pendingDial = {\n        dialRequest: dialRequest,\n        controller: timeoutController,\n        promise: dialRequest.run(_objectSpread(_objectSpread({}, options), {}, {\n          signal: signal\n        })),\n        destroy: function destroy() {\n          timeoutController.clear();\n\n          _this3._pendingDials.delete(dialTarget.id);\n        }\n      };\n\n      this._pendingDials.set(dialTarget.id, pendingDial);\n\n      return pendingDial;\n    }\n    /**\n     * @param {number} num\n     */\n\n  }, {\n    key: \"getTokens\",\n    value: function getTokens(num) {\n      var total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);\n      var tokens = this.tokens.splice(0, total);\n      log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n      return tokens;\n    }\n    /**\n     * @param {number} token\n     */\n\n  }, {\n    key: \"releaseToken\",\n    value: function releaseToken(token) {\n      // Guard against duplicate releases\n      if (this.tokens.indexOf(token) > -1) return;\n      log('token %d released', token);\n      this.tokens.push(token);\n    }\n    /**\n     * Resolve multiaddr recursively.\n     *\n     * @param {Multiaddr} ma\n     * @returns {Promise<Multiaddr[]>}\n     */\n\n  }, {\n    key: \"_resolve\",\n    value: function () {\n      var _resolve2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(ma) {\n        var _this4 = this;\n\n        var resolvableProto, resolvedMultiaddrs, recursiveMultiaddrs, addrs;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n                // Now only supporting resolve for dnsaddr\n                resolvableProto = ma.protoNames().includes('dnsaddr'); // Multiaddr is not resolvable? End recursion!\n\n                if (resolvableProto) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", [ma]);\n\n              case 3:\n                _context4.next = 5;\n                return this._resolveRecord(ma);\n\n              case 5:\n                resolvedMultiaddrs = _context4.sent;\n                _context4.next = 8;\n                return Promise.all(resolvedMultiaddrs.map(function (nm) {\n                  return _this4._resolve(nm);\n                }));\n\n              case 8:\n                recursiveMultiaddrs = _context4.sent;\n                addrs = recursiveMultiaddrs.flat();\n                return _context4.abrupt(\"return\", addrs.reduce(function (array, newM) {\n                  if (!array.find(function (m) {\n                    return m.equals(newM);\n                  })) {\n                    array.push(newM);\n                  }\n\n                  return array;\n                },\n                /** @type  {Multiaddr[]} */\n                []));\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _resolve(_x4) {\n        return _resolve2.apply(this, arguments);\n      }\n\n      return _resolve;\n    }()\n    /**\n     * Resolve a given multiaddr. If this fails, an empty array will be returned\n     *\n     * @param {Multiaddr} ma\n     * @returns {Promise<Multiaddr[]>}\n     */\n\n  }, {\n    key: \"_resolveRecord\",\n    value: function () {\n      var _resolveRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(ma) {\n        var multiaddrs;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                ma = new Multiaddr(ma.toString()); // Use current multiaddr module\n\n                _context5.next = 4;\n                return ma.resolve();\n\n              case 4:\n                multiaddrs = _context5.sent;\n                return _context5.abrupt(\"return\", multiaddrs);\n\n              case 8:\n                _context5.prev = 8;\n                _context5.t0 = _context5[\"catch\"](0);\n                log.error(\"multiaddr \".concat(ma, \" could not be resolved\"));\n                return _context5.abrupt(\"return\", []);\n\n              case 12:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[0, 8]]);\n      }));\n\n      function _resolveRecord(_x5) {\n        return _resolveRecord2.apply(this, arguments);\n      }\n\n      return _resolveRecord;\n    }()\n  }]);\n\n  return Dialer;\n}();\n\nmodule.exports = Dialer;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errCode","Multiaddr","TimeoutController","AbortError","anySignal","DialRequest","publicAddressesFirst","getPeer","codes","DIAL_TIMEOUT","MAX_PARALLEL_DIALS","MAX_PER_PEER_DIALS","MAX_ADDRS_TO_DIAL","Dialer","transportManager","peerStore","addressSorter","maxParallelDials","maxAddrsToDial","dialTimeout","maxDialsPerPeer","resolvers","timeout","tokens","Array","map","_","index","_pendingDials","Map","_pendingDialTargets","entries","key","value","set","values","dial","controller","abort","err","clear","pendingTarget","reject","peer","options","_createCancellableDialTarget","dialTarget","addrs","length","Error","ERR_NO_VALID_ADDRESSES","pendingDial","get","id","_createPendingDial","promise","connection","signal","aborted","code","ERR_TIMEOUT","destroy","parseInt","String","Math","random","toString","Date","now","cancellablePromise","Promise","resolve","race","_createDialTarget","delete","multiaddrs","addressBook","add","knownAddrs","getMultiaddrsForPeer","isMultiaddr","filter","addr","equals","unshift","a","_resolve","resolvedAddrs","forEach","ra","push","supportedAddrs","transportForMultiaddr","ERR_TOO_MANY_ADDRESSES","toB58String","dialAction","ERR_ALREADY_ABORTED","dialRequest","dialer","timeoutController","signals","run","num","total","min","splice","token","indexOf","ma","resolvableProto","protoNames","includes","_resolveRecord","resolvedMultiaddrs","all","nm","recursiveMultiaddrs","flat","reduce","array","newM","find","m","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/dialer/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:dialer'), {\n  error: debug('libp2p:dialer:err')\n})\nconst errCode = require('err-code')\nconst { Multiaddr } = require('multiaddr')\n// @ts-ignore timeout-abourt-controles does not export types\nconst TimeoutController = require('timeout-abort-controller')\nconst { AbortError } = require('abortable-iterator')\nconst { anySignal } = require('any-signal')\n\nconst DialRequest = require('./dial-request')\nconst { publicAddressesFirst } = require('libp2p-utils/src/address-sort')\nconst getPeer = require('../get-peer')\n\nconst { codes } = require('../errors')\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS,\n  MAX_ADDRS_TO_DIAL\n} = require('../constants')\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../peer-store')} PeerStore\n * @typedef {import('../peer-store/address-book').Address} Address\n * @typedef {import('../transport-manager')} TransportManager\n */\n\n/**\n * @typedef {Object} DialerProperties\n * @property {PeerStore} peerStore\n * @property {TransportManager} transportManager\n *\n * @typedef {(addr:Multiaddr) => Promise<string[]>} Resolver\n *\n * @typedef {Object} DialerOptions\n * @property {(addresses: Address[]) => Address[]} [options.addressSorter = publicAddressesFirst] - Sort the known addresses of a peer before trying to dial.\n * @property {number} [maxParallelDials = MAX_PARALLEL_DIALS] - Number of max concurrent dials.\n * @property {number} [maxAddrsToDial = MAX_ADDRS_TO_DIAL] - Number of max addresses to dial for a given peer.\n * @property {number} [maxDialsPerPeer = MAX_PER_PEER_DIALS] - Number of max concurrent dials per peer.\n * @property {number} [dialTimeout = DIAL_TIMEOUT] - How long a dial attempt is allowed to take.\n * @property {Record<string, Resolver>} [resolvers = {}] - multiaddr resolvers to use when dialing\n *\n * @typedef DialTarget\n * @property {string} id\n * @property {Multiaddr[]} addrs\n *\n * @typedef PendingDial\n * @property {DialRequest} dialRequest\n * @property {TimeoutController} controller\n * @property {Promise<Connection>} promise\n * @property {function():void} destroy\n */\n\nclass Dialer {\n  /**\n   * @class\n   * @param {DialerProperties & DialerOptions} options\n   */\n  constructor ({\n    transportManager,\n    peerStore,\n    addressSorter = publicAddressesFirst,\n    maxParallelDials = MAX_PARALLEL_DIALS,\n    maxAddrsToDial = MAX_ADDRS_TO_DIAL,\n    dialTimeout = DIAL_TIMEOUT,\n    maxDialsPerPeer = MAX_PER_PEER_DIALS,\n    resolvers = {}\n  }) {\n    this.transportManager = transportManager\n    this.peerStore = peerStore\n    this.addressSorter = addressSorter\n    this.maxParallelDials = maxParallelDials\n    this.maxAddrsToDial = maxAddrsToDial\n    this.timeout = dialTimeout\n    this.maxDialsPerPeer = maxDialsPerPeer\n    this.tokens = [...new Array(maxParallelDials)].map((_, index) => index)\n    this._pendingDials = new Map()\n    this._pendingDialTargets = new Map()\n\n    for (const [key, value] of Object.entries(resolvers)) {\n      Multiaddr.resolvers.set(key, value)\n    }\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  destroy () {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort()\n      } catch (err) {\n        log.error(err)\n      }\n    }\n    this._pendingDials.clear()\n\n    for (const pendingTarget of this._pendingDialTargets.values()) {\n      pendingTarget.reject(new AbortError('Dialer was destroyed'))\n    }\n    this._pendingDialTargets.clear()\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n  async connectToPeer (peer, options = {}) {\n    const dialTarget = await this._createCancellableDialTarget(peer)\n\n    if (!dialTarget.addrs.length) {\n      throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES)\n    }\n    const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options)\n\n    try {\n      const connection = await pendingDial.promise\n      log('dial succeeded to %s', dialTarget.id)\n      return connection\n    } catch (err) {\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT\n      }\n      log.error(err)\n      throw err\n    } finally {\n      pendingDial.destroy()\n    }\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @returns {Promise<DialTarget>}\n   */\n  async _createCancellableDialTarget (peer) {\n    // Make dial target promise cancellable\n    const id = `${(parseInt(String(Math.random() * 1e9), 10)).toString() + Date.now()}`\n    const cancellablePromise = new Promise((resolve, reject) => {\n      this._pendingDialTargets.set(id, { resolve, reject })\n    })\n\n    const dialTarget = await Promise.race([\n      this._createDialTarget(peer),\n      cancellablePromise\n    ])\n\n    this._pendingDialTargets.delete(id)\n\n    return dialTarget\n  }\n\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * Multiaddrs not supported by the available transports will be filtered out.\n   *\n   * @private\n   * @param {PeerId|Multiaddr|string} peer - A PeerId or Multiaddr\n   * @returns {Promise<DialTarget>}\n   */\n  async _createDialTarget (peer) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    let knownAddrs = this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter) || []\n\n    // If received a multiaddr to dial, it should be the first to use\n    // But, if we know other multiaddrs for the peer, we should try them too.\n    if (Multiaddr.isMultiaddr(peer)) {\n      knownAddrs = knownAddrs.filter((addr) => !peer.equals(addr))\n      knownAddrs.unshift(peer)\n    }\n\n    /** @type {Multiaddr[]} */\n    const addrs = []\n    for (const a of knownAddrs) {\n      const resolvedAddrs = await this._resolve(a)\n      resolvedAddrs.forEach(ra => addrs.push(ra))\n    }\n\n    // Multiaddrs not supported by the available transports will be filtered out.\n    const supportedAddrs = addrs.filter(a => this.transportManager.transportForMultiaddr(a))\n\n    if (supportedAddrs.length > this.maxAddrsToDial) {\n      this.peerStore.delete(id)\n      throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES)\n    }\n\n    return {\n      id: id.toB58String(),\n      addrs: supportedAddrs\n    }\n  }\n\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   *\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {PendingDial}\n   */\n  _createPendingDial (dialTarget, options = {}) {\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED)\n      return this.transportManager.dial(addr, options)\n    }\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    })\n\n    // Combine the timeout signal and options.signal, if provided\n    const timeoutController = new TimeoutController(this.timeout)\n    const signals = [timeoutController.signal]\n    options.signal && signals.push(options.signal)\n    const signal = anySignal(signals)\n\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options, signal }),\n      destroy: () => {\n        timeoutController.clear()\n        this._pendingDials.delete(dialTarget.id)\n      }\n    }\n    this._pendingDials.set(dialTarget.id, pendingDial)\n    return pendingDial\n  }\n\n  /**\n   * @param {number} num\n   */\n  getTokens (num) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length)\n    const tokens = this.tokens.splice(0, total)\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length)\n    return tokens\n  }\n\n  /**\n   * @param {number} token\n   */\n  releaseToken (token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return\n    log('token %d released', token)\n    this.tokens.push(token)\n  }\n\n  /**\n   * Resolve multiaddr recursively.\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n  async _resolve (ma) {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr')\n\n    // Multiaddr is not resolvable? End recursion!\n    if (!resolvableProto) {\n      return [ma]\n    }\n\n    const resolvedMultiaddrs = await this._resolveRecord(ma)\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map((nm) => {\n      return this._resolve(nm)\n    }))\n\n    const addrs = recursiveMultiaddrs.flat()\n    return addrs.reduce((array, newM) => {\n      if (!array.find(m => m.equals(newM))) {\n        array.push(newM)\n      }\n      return array\n    }, /** @type  {Multiaddr[]} */([]))\n  }\n\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n  async _resolveRecord (ma) {\n    try {\n      ma = new Multiaddr(ma.toString()) // Use current multiaddr module\n      const multiaddrs = await ma.resolve()\n      return multiaddrs\n    } catch (_) {\n      log.error(`multiaddr ${ma} could not be resolved`)\n      return []\n    }\n  }\n}\n\nmodule.exports = Dialer\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}