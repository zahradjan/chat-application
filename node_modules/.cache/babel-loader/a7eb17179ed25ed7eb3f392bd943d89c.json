{"ast":null,"code":"'use strict';\n\nconst {\n  deepEqual\n} = require('./utils');\n\nconst sum = (acc, val) => acc + val;\n/**\n * G-Counter\n *\n * Operation-based Increment-Only Counter CRDT\n *\n * Sources: \n * \"A comprehensive study of Convergent and Commutative Replicated Data Types\"\n * http://hal.upmc.fr/inria-00555588/document, \"3.1.1 Op-based counter and 3.1.2  State-based increment-only Counter (G-Counter)\"\n */\n\n\nclass GCounter {\n  constructor(id, counter) {\n    this.id = id;\n    this._counters = counter ? counter : {};\n    this._counters[this.id] = this._counters[this.id] ? this._counters[this.id] : 0;\n  }\n\n  get value() {\n    return Object.values(this._counters).reduce(sum, 0);\n  }\n\n  increment(amount) {\n    if (amount && amount < 1) return;\n    if (amount === undefined || amount === null) amount = 1;\n    this._counters[this.id] = this._counters[this.id] + amount;\n  }\n\n  merge(other) {\n    // Go through each counter in the other counter\n    Object.entries(other._counters).forEach(_ref => {\n      let [id, value] = _ref;\n      // Take the maximum of the counter value we have or the counter value they have\n      this._counters[id] = Math.max(this._counters[id] || 0, value);\n    });\n  }\n\n  toJSON() {\n    return {\n      id: this.id,\n      counters: this._counters\n    };\n  }\n\n  isEqual(other) {\n    return GCounter.isEqual(this, other);\n  }\n\n  static from(json) {\n    return new GCounter(json.id, json.counters);\n  }\n\n  static isEqual(a, b) {\n    if (a.id !== b.id) return false;\n    return deepEqual(a._counters, b._counters);\n  }\n\n}\n\nmodule.exports = GCounter;","map":{"version":3,"names":["deepEqual","require","sum","acc","val","GCounter","constructor","id","counter","_counters","value","Object","values","reduce","increment","amount","undefined","merge","other","entries","forEach","Math","max","toJSON","counters","isEqual","from","json","a","b","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/crdts/src/G-Counter.js"],"sourcesContent":["'use strict'\n\nconst { deepEqual } = require('./utils')\nconst sum = (acc, val) => acc + val\n\n/**\n * G-Counter\n *\n * Operation-based Increment-Only Counter CRDT\n *\n * Sources: \n * \"A comprehensive study of Convergent and Commutative Replicated Data Types\"\n * http://hal.upmc.fr/inria-00555588/document, \"3.1.1 Op-based counter and 3.1.2  State-based increment-only Counter (G-Counter)\"\n */\n\nclass GCounter {\n  constructor (id, counter) {\n    this.id = id\n    this._counters = counter ? counter : {}\n    this._counters[this.id] = this._counters[this.id] ? this._counters[this.id] : 0\n  }\n\n  get value () {\n    return Object.values(this._counters).reduce(sum, 0)\n  }\n\n  increment (amount) {\n    if (amount && amount < 1) \n      return\n\n    if (amount === undefined || amount === null)\n      amount = 1\n\n    this._counters[this.id] = this._counters[this.id] + amount\n  }\n\n  merge (other) {\n    // Go through each counter in the other counter\n    Object.entries(other._counters).forEach(([id, value]) => {\n      // Take the maximum of the counter value we have or the counter value they have\n      this._counters[id] = Math.max(this._counters[id] || 0, value)\n    })\n  }\n\n  toJSON () {\n    return { \n      id: this.id, \n      counters: this._counters \n    }\n  }\n\n  isEqual (other) {\n    return GCounter.isEqual(this, other)\n  }\n\n  static from (json) {\n    return new GCounter(json.id, json.counters)\n  }\n\n  static isEqual (a, b) {\n    if(a.id !== b.id)\n      return false\n\n    return deepEqual(a._counters, b._counters)\n  }\n}\n\nmodule.exports = GCounter\n"],"mappings":"AAAA;;AAEA,MAAM;EAAEA;AAAF,IAAgBC,OAAO,CAAC,SAAD,CAA7B;;AACA,MAAMC,GAAG,GAAG,CAACC,GAAD,EAAMC,GAAN,KAAcD,GAAG,GAAGC,GAAhC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMC,QAAN,CAAe;EACbC,WAAW,CAAEC,EAAF,EAAMC,OAAN,EAAe;IACxB,KAAKD,EAAL,GAAUA,EAAV;IACA,KAAKE,SAAL,GAAiBD,OAAO,GAAGA,OAAH,GAAa,EAArC;IACA,KAAKC,SAAL,CAAe,KAAKF,EAApB,IAA0B,KAAKE,SAAL,CAAe,KAAKF,EAApB,IAA0B,KAAKE,SAAL,CAAe,KAAKF,EAApB,CAA1B,GAAoD,CAA9E;EACD;;EAEQ,IAALG,KAAK,GAAI;IACX,OAAOC,MAAM,CAACC,MAAP,CAAc,KAAKH,SAAnB,EAA8BI,MAA9B,CAAqCX,GAArC,EAA0C,CAA1C,CAAP;EACD;;EAEDY,SAAS,CAAEC,MAAF,EAAU;IACjB,IAAIA,MAAM,IAAIA,MAAM,GAAG,CAAvB,EACE;IAEF,IAAIA,MAAM,KAAKC,SAAX,IAAwBD,MAAM,KAAK,IAAvC,EACEA,MAAM,GAAG,CAAT;IAEF,KAAKN,SAAL,CAAe,KAAKF,EAApB,IAA0B,KAAKE,SAAL,CAAe,KAAKF,EAApB,IAA0BQ,MAApD;EACD;;EAEDE,KAAK,CAAEC,KAAF,EAAS;IACZ;IACAP,MAAM,CAACQ,OAAP,CAAeD,KAAK,CAACT,SAArB,EAAgCW,OAAhC,CAAwC,QAAiB;MAAA,IAAhB,CAACb,EAAD,EAAKG,KAAL,CAAgB;MACvD;MACA,KAAKD,SAAL,CAAeF,EAAf,IAAqBc,IAAI,CAACC,GAAL,CAAS,KAAKb,SAAL,CAAeF,EAAf,KAAsB,CAA/B,EAAkCG,KAAlC,CAArB;IACD,CAHD;EAID;;EAEDa,MAAM,GAAI;IACR,OAAO;MACLhB,EAAE,EAAE,KAAKA,EADJ;MAELiB,QAAQ,EAAE,KAAKf;IAFV,CAAP;EAID;;EAEDgB,OAAO,CAAEP,KAAF,EAAS;IACd,OAAOb,QAAQ,CAACoB,OAAT,CAAiB,IAAjB,EAAuBP,KAAvB,CAAP;EACD;;EAEU,OAAJQ,IAAI,CAAEC,IAAF,EAAQ;IACjB,OAAO,IAAItB,QAAJ,CAAasB,IAAI,CAACpB,EAAlB,EAAsBoB,IAAI,CAACH,QAA3B,CAAP;EACD;;EAEa,OAAPC,OAAO,CAAEG,CAAF,EAAKC,CAAL,EAAQ;IACpB,IAAGD,CAAC,CAACrB,EAAF,KAASsB,CAAC,CAACtB,EAAd,EACE,OAAO,KAAP;IAEF,OAAOP,SAAS,CAAC4B,CAAC,CAACnB,SAAH,EAAcoB,CAAC,CAACpB,SAAhB,CAAhB;EACD;;AAjDY;;AAoDfqB,MAAM,CAACC,OAAP,GAAiB1B,QAAjB"},"metadata":{},"sourceType":"script"}