{"ast":null,"code":"'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst log = require('debug')('ipfs:repo:gc');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst parallelBatch = require('it-parallel-batch');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst merge = require('it-merge');\n\nconst map = require('it-map');\n\nconst filter = require('it-filter');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst walkDag = require('./utils/walk-dag'); // Limit on the number of parallel block remove operations\n\n\nconst BLOCK_RM_CONCURRENCY = 256;\nconst MFS_ROOT_KEY = new Key('/local/filesroot');\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./pins').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\n\nmodule.exports = _ref => {\n  let {\n    gcLock,\n    pins,\n    blockstore,\n    root,\n    loadCodec\n  } = _ref;\n\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  async function* gc() {\n    const start = Date.now();\n    log('Creating set of marked blocks');\n    const release = await gcLock.writeLock();\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({\n        pins,\n        blockstore,\n        root,\n        loadCodec\n      }); // Get all blocks keys from the blockstore\n\n      const blockKeys = blockstore.queryKeys({}); // Delete blocks that are not being used\n      // @ts-ignore ts cannot tell that we filter out null results\n\n      yield* deleteUnmarkedBlocks({\n        blockstore\n      }, markedSet, blockKeys);\n      log(`Complete (${Date.now() - start}ms)`);\n    } finally {\n      release();\n    }\n  }\n\n  return gc;\n};\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pins').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\n\n\nasync function createMarkedSet(_ref2) {\n  let {\n    pins,\n    blockstore,\n    loadCodec,\n    root\n  } = _ref2;\n\n  const mfsSource = async function* () {\n    let mh;\n\n    try {\n      mh = await root.get(MFS_ROOT_KEY);\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS');\n        return;\n      }\n\n      throw err;\n    }\n\n    const rootCid = CID.decode(mh);\n    yield rootCid;\n    yield* walkDag(rootCid, blockstore, loadCodec);\n  }();\n\n  const pinsSource = merge(map(pins.recursiveKeys(), _ref3 => {\n    let {\n      cid\n    } = _ref3;\n    return cid;\n  }), pins.indirectKeys(), map(pins.directKeys(), _ref4 => {\n    let {\n      cid\n    } = _ref4;\n    return cid;\n  }), mfsSource);\n  const output = new Set();\n\n  for await (const cid of merge(pinsSource, mfsSource)) {\n    output.add(base32.encode(cid.multihash.bytes));\n  }\n\n  return output;\n}\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\n\n\nasync function* deleteUnmarkedBlocks(_ref5, markedSet, blockKeys) {\n  let {\n    blockstore\n  } = _ref5;\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0;\n  let removedBlocksCount = 0;\n  /**\n   * @param {CID} cid\n   */\n\n  const removeBlock = async cid => {\n    return async function remove() {\n      blocksCount++;\n\n      try {\n        const b32 = base32.encode(cid.multihash.bytes);\n\n        if (markedSet.has(b32)) {\n          return null;\n        }\n\n        try {\n          await blockstore.delete(cid);\n          removedBlocksCount++;\n        } catch (err) {\n          return {\n            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n          };\n        }\n\n        return {\n          cid\n        };\n      } catch (err) {\n        const msg = `Could delete block with CID ${cid}`;\n        log(msg, err);\n        return {\n          err: new Error(msg + `: ${err.message}`)\n        };\n      }\n    };\n  };\n\n  yield* pipe(parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY), // filter nulls (blocks that were retained)\n  source => filter(source, Boolean));\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` + `Deleted ${removedBlocksCount} blocks.`);\n}","map":{"version":3,"names":["CID","require","log","Errors","ERR_NOT_FOUND","notFoundError","code","parallelBatch","pipe","merge","map","filter","Key","base32","walkDag","BLOCK_RM_CONCURRENCY","MFS_ROOT_KEY","module","exports","gcLock","pins","blockstore","root","loadCodec","gc","start","Date","now","release","writeLock","markedSet","createMarkedSet","blockKeys","queryKeys","deleteUnmarkedBlocks","mfsSource","mh","get","err","rootCid","decode","pinsSource","recursiveKeys","cid","indirectKeys","directKeys","output","Set","add","encode","multihash","bytes","blocksCount","removedBlocksCount","removeBlock","remove","b32","has","delete","Error","message","msg","source","Boolean","size"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-repo/src/gc.js"],"sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst log = require('debug')('ipfs:repo:gc')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst parallelBatch = require('it-parallel-batch')\nconst { pipe } = require('it-pipe')\nconst merge = require('it-merge')\nconst map = require('it-map')\nconst filter = require('it-filter')\nconst { Key } = require('interface-datastore')\nconst { base32 } = require('multiformats/bases/base32')\nconst walkDag = require('./utils/walk-dag')\n\n// Limit on the number of parallel block remove operations\nconst BLOCK_RM_CONCURRENCY = 256\n\nconst MFS_ROOT_KEY = new Key('/local/filesroot')\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./pins').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nmodule.exports = ({ gcLock, pins, blockstore, root, loadCodec }) => {\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  async function * gc () {\n    const start = Date.now()\n    log('Creating set of marked blocks')\n\n    const release = await gcLock.writeLock()\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({ pins, blockstore, root, loadCodec })\n      // Get all blocks keys from the blockstore\n      const blockKeys = blockstore.queryKeys({})\n\n      // Delete blocks that are not being used\n      // @ts-ignore ts cannot tell that we filter out null results\n      yield * deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys)\n\n      log(`Complete (${Date.now() - start}ms)`)\n    } finally {\n      release()\n    }\n  }\n\n  return gc\n}\n\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pins').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nasync function createMarkedSet ({ pins, blockstore, loadCodec, root }) {\n  const mfsSource = (async function * () {\n    let mh\n    try {\n      mh = await root.get(MFS_ROOT_KEY)\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS')\n        return\n      }\n\n      throw err\n    }\n\n    const rootCid = CID.decode(mh)\n    yield rootCid\n    yield * walkDag(rootCid, blockstore, loadCodec)\n  })()\n\n  const pinsSource = merge(\n    map(pins.recursiveKeys(), ({ cid }) => cid),\n    pins.indirectKeys(),\n    map(pins.directKeys(), ({ cid }) => cid),\n    mfsSource\n  )\n\n  const output = new Set()\n\n  for await (const cid of merge(pinsSource, mfsSource)) {\n    output.add(base32.encode(cid.multihash.bytes))\n  }\n\n  return output\n}\n\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\nasync function * deleteUnmarkedBlocks ({ blockstore }, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0\n  let removedBlocksCount = 0\n\n  /**\n   * @param {CID} cid\n   */\n  const removeBlock = async (cid) => {\n    return async function remove () {\n      blocksCount++\n\n      try {\n        const b32 = base32.encode(cid.multihash.bytes)\n\n        if (markedSet.has(b32)) {\n          return null\n        }\n\n        try {\n          await blockstore.delete(cid)\n          removedBlocksCount++\n        } catch (err) {\n          return {\n            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n          }\n        }\n\n        return { cid }\n      } catch (err) {\n        const msg = `Could delete block with CID ${cid}`\n        log(msg, err)\n        return { err: new Error(msg + `: ${err.message}`) }\n      }\n    }\n  }\n\n  yield * pipe(\n    parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY),\n    // filter nulls (blocks that were retained)\n    source => filter(source, Boolean)\n  )\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` +\n  `Deleted ${removedBlocksCount} blocks.`)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}