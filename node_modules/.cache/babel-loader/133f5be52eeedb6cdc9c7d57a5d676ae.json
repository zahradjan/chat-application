{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst log = require('debug')('ipfs:mfs:mkdir');\n\nconst {\n  exporter\n} = require('ipfs-unixfs-exporter');\n\nconst createNode = require('./utils/create-node');\n\nconst toPathComponents = require('./utils/to-path-components');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst updateTree = require('./utils/update-tree');\n\nconst addLink = require('./utils/add-link');\n\nconst withMfsRoot = require('./utils/with-mfs-root');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} flush\n * @property {number} [mode]\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true\n};\n/**\n * @param {MfsContext} context\n */\n\nmodule.exports = context => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"mkdir\"]}\n   */\n  async function mfsMkdir(path) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options);\n\n    if (!path) {\n      throw new Error('no path given to Mkdir');\n    }\n\n    path = path.trim();\n\n    if (path === '/') {\n      if (opts.parents) {\n        return;\n      }\n\n      throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH');\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n    }\n\n    log(`Creating ${path}`);\n    const pathComponents = toPathComponents(path);\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH');\n    }\n\n    const root = await withMfsRoot(context, opts);\n    let parent;\n    const trail = [];\n    const emptyDir = await createNode(context, 'directory', opts); // make sure the containing folder exists, creating it if necessary\n\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i);\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`;\n\n      try {\n        parent = await exporter(subPath, context.repo.blocks);\n\n        if (parent.type !== 'file' && parent.type !== 'directory') {\n          throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n        }\n\n        if (i === pathComponents.length) {\n          if (opts.parents) {\n            return;\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        });\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !opts.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND');\n          } // add the intermediate directory\n\n\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);\n        } else {\n          throw err;\n        }\n      }\n    } // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n    // update the tree from the leaf to the root\n\n\n    const newRootCid = await updateTree(context, trail, opts); // Update the MFS record with the new CID for the root of the tree\n\n    await updateMfsRoot(context, newRootCid, opts);\n  }\n\n  return withTimeoutOption(mfsMkdir);\n};\n/**\n * @param {MfsContext} context\n * @param {string} childName\n * @param {{ cid: CID, node?: PBNode }} emptyDir\n * @param {{ cid?: CID, node?: PBNode }} parent\n * @param {{ name: string, cid: CID }[]} trail\n * @param {DefaultOptions} options\n */\n\n\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`);\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    // TODO vmx 2021-03-09: Remove the usage of size completely\n    size: 0,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  });\n  trail[trail.length - 1].cid = result.cid;\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  });\n};","map":{"version":3,"names":["errCode","require","log","exporter","createNode","toPathComponents","updateMfsRoot","updateTree","addLink","withMfsRoot","mergeOptions","bind","ignoreUndefined","withTimeoutOption","defaultOptions","parents","hashAlg","cidVersion","shardSplitThreshold","flush","module","exports","context","mfsMkdir","path","options","opts","Error","trim","substring","pathComponents","root","parent","trail","emptyDir","i","length","subPathComponents","slice","subPath","join","repo","blocks","type","push","name","cid","err","code","addEmptyDir","newRootCid","childName","result","node","parentCid","size"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/mkdir.js"],"sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst log = require('debug')('ipfs:mfs:mkdir')\nconst { exporter } = require('ipfs-unixfs-exporter')\nconst createNode = require('./utils/create-node')\nconst toPathComponents = require('./utils/to-path-components')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst updateTree = require('./utils/update-tree')\nconst addLink = require('./utils/add-link')\nconst withMfsRoot = require('./utils/with-mfs-root')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {object} DefaultOptions\n * @property {boolean} parents\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} flush\n * @property {number} [mode]\n * @property {MtimeLike} [mtime]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"mkdir\"]}\n   */\n  async function mfsMkdir (path, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options)\n\n    if (!path) {\n      throw new Error('no path given to Mkdir')\n    }\n\n    path = path.trim()\n\n    if (path === '/') {\n      if (opts.parents) {\n        return\n      }\n\n      throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n    }\n\n    log(`Creating ${path}`)\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH')\n    }\n\n    const root = await withMfsRoot(context, opts)\n    let parent\n    const trail = []\n    const emptyDir = await createNode(context, 'directory', opts)\n\n    // make sure the containing folder exists, creating it if necessary\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i)\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`\n\n      try {\n        parent = await exporter(subPath, context.repo.blocks)\n\n        if (parent.type !== 'file' && parent.type !== 'directory') {\n          throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n        }\n\n        if (i === pathComponents.length) {\n          if (opts.parents) {\n            return\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS')\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        })\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !opts.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND')\n          }\n\n          // add the intermediate directory\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts)\n        } else {\n          throw err\n        }\n      }\n    }\n\n    // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n\n    // update the tree from the leaf to the root\n    const newRootCid = await updateTree(context, trail, opts)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts)\n  }\n\n  return withTimeoutOption(mfsMkdir)\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} childName\n * @param {{ cid: CID, node?: PBNode }} emptyDir\n * @param {{ cid?: CID, node?: PBNode }} parent\n * @param {{ name: string, cid: CID }[]} trail\n * @param {DefaultOptions} options\n */\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`)\n\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    // TODO vmx 2021-03-09: Remove the usage of size completely\n    size: 0,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush,\n    shardSplitThreshold: options.shardSplitThreshold\n  })\n\n  trail[trail.length - 1].cid = result.cid\n\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}