{"ast":null,"code":"'use strict';\n\nconst {\n  CarBlockIterator\n} = require('@ipld/car/iterator');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst itPeekable = require('it-peekable');\n\nconst drain = require('it-drain');\n\nconst map = require('it-map');\n\nconst log = require('debug')('ipfs:components:dag:import');\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/dag/').ImportRootStatus} RootStatus\n */\n\n/**\n * @param {Object} config\n * @param {IPFSRepo} config.repo\n */\n\n\nmodule.exports = _ref => {\n  let {\n    repo\n  } = _ref;\n\n  /**\n   * @type {import('ipfs-core-types/src/dag').API[\"import\"]}\n   */\n  async function* dagImport(sources) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const release = await repo.gcLock.readLock();\n\n    try {\n      const abortOptions = {\n        signal: options.signal,\n        timeout: options.timeout\n      };\n      const peekable = itPeekable(sources);\n      const {\n        value,\n        done\n      } = await peekable.peek();\n\n      if (done) {\n        return;\n      }\n\n      if (value) {\n        // @ts-ignore\n        peekable.push(value);\n      }\n      /**\n       * @type {AsyncIterable<AsyncIterable<Uint8Array>> | Iterable<AsyncIterable<Uint8Array>>}\n       */\n\n\n      let cars;\n\n      if (value instanceof Uint8Array) {\n        // @ts-ignore\n        cars = [peekable];\n      } else {\n        // @ts-ignore\n        cars = peekable;\n      }\n\n      for await (const car of cars) {\n        const roots = await importCar(repo, abortOptions, car);\n\n        if (options.pinRoots !== false) {\n          // default=true\n          for (const cid of roots) {\n            let pinErrorMsg = '';\n\n            try {\n              // eslint-disable-line max-depth\n              if (await repo.blocks.has(cid)) {\n                // eslint-disable-line max-depth\n                log(`Pinning root ${cid}`);\n                await repo.pins.pinRecursively(cid);\n              } else {\n                pinErrorMsg = 'blockstore: block not found';\n              }\n            } catch (err) {\n              pinErrorMsg = err.message;\n            }\n\n            yield {\n              root: {\n                cid,\n                pinErrorMsg\n              }\n            };\n          }\n        }\n      }\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption(dagImport);\n};\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {Promise<CID[]>}\n */\n\n\nasync function importCar(repo, options, source) {\n  const reader = await CarBlockIterator.fromIterable(source);\n  const roots = await reader.getRoots();\n  await drain(repo.blocks.putMany(map(reader, _ref2 => {\n    let {\n      cid: key,\n      bytes: value\n    } = _ref2;\n    log(`Import block ${key}`);\n    return {\n      key,\n      value\n    };\n  }), {\n    signal: options.signal\n  }));\n  return roots;\n}","map":{"version":3,"names":["CarBlockIterator","require","withTimeoutOption","itPeekable","drain","map","log","module","exports","repo","dagImport","sources","options","release","gcLock","readLock","abortOptions","signal","timeout","peekable","value","done","peek","push","cars","Uint8Array","car","roots","importCar","pinRoots","cid","pinErrorMsg","blocks","has","pins","pinRecursively","err","message","root","source","reader","fromIterable","getRoots","putMany","key","bytes"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/dag/import.js"],"sourcesContent":["'use strict'\n\nconst { CarBlockIterator } = require('@ipld/car/iterator')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst itPeekable = require('it-peekable')\nconst drain = require('it-drain')\nconst map = require('it-map')\nconst log = require('debug')('ipfs:components:dag:import')\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/dag/').ImportRootStatus} RootStatus\n */\n\n/**\n * @param {Object} config\n * @param {IPFSRepo} config.repo\n */\nmodule.exports = ({ repo }) => {\n  /**\n   * @type {import('ipfs-core-types/src/dag').API[\"import\"]}\n   */\n  async function * dagImport (sources, options = {}) {\n    const release = await repo.gcLock.readLock()\n\n    try {\n      const abortOptions = { signal: options.signal, timeout: options.timeout }\n      const peekable = itPeekable(sources)\n\n      const { value, done } = await peekable.peek()\n\n      if (done) {\n        return\n      }\n\n      if (value) {\n        // @ts-ignore\n        peekable.push(value)\n      }\n\n      /**\n       * @type {AsyncIterable<AsyncIterable<Uint8Array>> | Iterable<AsyncIterable<Uint8Array>>}\n       */\n      let cars\n\n      if (value instanceof Uint8Array) {\n        // @ts-ignore\n        cars = [peekable]\n      } else {\n        // @ts-ignore\n        cars = peekable\n      }\n\n      for await (const car of cars) {\n        const roots = await importCar(repo, abortOptions, car)\n\n        if (options.pinRoots !== false) { // default=true\n          for (const cid of roots) {\n            let pinErrorMsg = ''\n\n            try { // eslint-disable-line max-depth\n              if (await repo.blocks.has(cid)) { // eslint-disable-line max-depth\n                log(`Pinning root ${cid}`)\n                await repo.pins.pinRecursively(cid)\n              } else {\n                pinErrorMsg = 'blockstore: block not found'\n              }\n            } catch (err) {\n              pinErrorMsg = err.message\n            }\n\n            yield { root: { cid, pinErrorMsg } }\n          }\n        }\n      }\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(dagImport)\n}\n\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {Promise<CID[]>}\n */\nasync function importCar (repo, options, source) {\n  const reader = await CarBlockIterator.fromIterable(source)\n  const roots = await reader.getRoots()\n\n  await drain(\n    repo.blocks.putMany(\n      map(reader, ({ cid: key, bytes: value }) => {\n        log(`Import block ${key}`)\n\n        return { key, value }\n      }),\n      { signal: options.signal }\n    )\n  )\n\n  return roots\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}