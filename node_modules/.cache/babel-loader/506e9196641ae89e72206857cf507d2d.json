{"ast":null,"code":"'use strict';\n\nconst connect = require('it-ws/client');\n\nconst withIs = require('class-is');\n\nconst toUri = require('multiaddr-to-uri');\n\nconst {\n  AbortError\n} = require('abortable-iterator');\n\nconst pDefer = require('p-defer');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:websockets');\nlog.error = debug('libp2p:websockets:error');\n\nconst env = require('ipfs-utils/src/env');\n\nconst createListener = require('./listener');\n\nconst toConnection = require('./socket-to-conn');\n\nconst filters = require('./filters');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @class WebSockets\n */\n\n\nclass WebSockets {\n  /**\n   * @class\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   * @param {(multiaddrs: Array<Multiaddr>) => Array<Multiaddr>} options.filter - override transport addresses filter\n   */\n  constructor(_ref) {\n    let {\n      upgrader,\n      filter\n    } = _ref;\n\n    if (!upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.');\n    }\n\n    this._upgrader = upgrader;\n    this._filter = filter;\n  }\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n\n\n  async dial(ma) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    log('dialing %s', ma);\n    const socket = await this._connect(ma, options);\n    const maConn = toConnection(socket, {\n      remoteAddr: ma,\n      signal: options.signal\n    });\n    log('new outbound connection %s', maConn.remoteAddr);\n    const conn = await this._upgrader.upgradeOutbound(maConn);\n    log('outbound connection %s upgraded', maConn.remoteAddr);\n    return conn;\n  }\n  /**\n   * @private\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - Used to abort dial requests\n   * @returns {Promise<WebSocket>} Resolves a extended duplex iterable on top of a WebSocket\n   */\n\n\n  async _connect(ma) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.signal && options.signal.aborted) {\n      throw new AbortError();\n    }\n\n    const cOpts = ma.toOptions();\n    log('dialing %s:%s', cOpts.host, cOpts.port);\n    const errorPromise = pDefer();\n\n    const errfn = err => {\n      const msg = `connection error: ${err.message}`;\n      log.error(msg);\n      errorPromise.reject(err);\n    };\n\n    const rawSocket = connect(toUri(ma), Object.assign({\n      binary: true\n    }, options));\n\n    if (rawSocket.socket.on) {\n      rawSocket.socket.on('error', errfn);\n    } else {\n      rawSocket.socket.onerror = errfn;\n    }\n\n    if (!options.signal) {\n      await Promise.race([rawSocket.connected(), errorPromise.promise]);\n      log('connected %s', ma);\n      return rawSocket;\n    } // Allow abort via signal during connect\n\n\n    let onAbort;\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError()); // FIXME: https://github.com/libp2p/js-libp2p-websockets/issues/121\n\n        setTimeout(() => {\n          rawSocket.close();\n        });\n      }; // Already aborted?\n\n\n      if (options.signal.aborted) return onAbort();\n      options.signal.addEventListener('abort', onAbort);\n    });\n\n    try {\n      await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);\n    } finally {\n      options.signal.removeEventListener('abort', onAbort);\n    }\n\n    log('connected %s', ma);\n    return rawSocket;\n  }\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   *\n   * @param {object} [options]\n   * @param {http.Server} [options.server] - A pre-created Node.js HTTP/S server.\n   * @param {function (Connection)} handler\n   * @returns {Listener} A Websockets listener\n   */\n\n\n  createListener() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let handler = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (typeof options === 'function') {\n      handler = options;\n      options = {};\n    }\n\n    return createListener({\n      handler,\n      upgrader: this._upgrader\n    }, options);\n  }\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n   * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n   *\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]} Valid Websockets multiaddrs\n   */\n\n\n  filter(multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n\n    if (this._filter) {\n      return this._filter(multiaddrs);\n    } // Browser\n\n\n    if (env.isBrowser || env.isWebWorker) {\n      return filters.dnsWss(multiaddrs);\n    }\n\n    return filters.all(multiaddrs);\n  }\n\n}\n\nmodule.exports = withIs(WebSockets, {\n  className: 'WebSockets',\n  symbolName: '@libp2p/js-libp2p-websockets/websockets'\n});","map":{"version":3,"names":["connect","require","withIs","toUri","AbortError","pDefer","debug","log","error","env","createListener","toConnection","filters","WebSockets","constructor","upgrader","filter","Error","_upgrader","_filter","dial","ma","options","socket","_connect","maConn","remoteAddr","signal","conn","upgradeOutbound","aborted","cOpts","toOptions","host","port","errorPromise","errfn","err","msg","message","reject","rawSocket","Object","assign","binary","on","onerror","Promise","race","connected","promise","onAbort","abort","resolve","setTimeout","close","addEventListener","removeEventListener","handler","multiaddrs","Array","isArray","isBrowser","isWebWorker","dnsWss","all","module","exports","className","symbolName"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-websockets/src/index.js"],"sourcesContent":["'use strict'\n\nconst connect = require('it-ws/client')\nconst withIs = require('class-is')\nconst toUri = require('multiaddr-to-uri')\nconst { AbortError } = require('abortable-iterator')\nconst pDefer = require('p-defer')\n\nconst debug = require('debug')\nconst log = debug('libp2p:websockets')\nlog.error = debug('libp2p:websockets:error')\nconst env = require('ipfs-utils/src/env')\n\nconst createListener = require('./listener')\nconst toConnection = require('./socket-to-conn')\nconst filters = require('./filters')\n\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @class WebSockets\n */\nclass WebSockets {\n  /**\n   * @class\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   * @param {(multiaddrs: Array<Multiaddr>) => Array<Multiaddr>} options.filter - override transport addresses filter\n   */\n  constructor ({ upgrader, filter }) {\n    if (!upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.')\n    }\n    this._upgrader = upgrader\n    this._filter = filter\n  }\n\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n  async dial (ma, options = {}) {\n    log('dialing %s', ma)\n\n    const socket = await this._connect(ma, options)\n    const maConn = toConnection(socket, { remoteAddr: ma, signal: options.signal })\n    log('new outbound connection %s', maConn.remoteAddr)\n\n    const conn = await this._upgrader.upgradeOutbound(maConn)\n    log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  /**\n   * @private\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - Used to abort dial requests\n   * @returns {Promise<WebSocket>} Resolves a extended duplex iterable on top of a WebSocket\n   */\n  async _connect (ma, options = {}) {\n    if (options.signal && options.signal.aborted) {\n      throw new AbortError()\n    }\n    const cOpts = ma.toOptions()\n    log('dialing %s:%s', cOpts.host, cOpts.port)\n\n    const errorPromise = pDefer()\n    const errfn = (err) => {\n      const msg = `connection error: ${err.message}`\n      log.error(msg)\n\n      errorPromise.reject(err)\n    }\n\n    const rawSocket = connect(toUri(ma), Object.assign({ binary: true }, options))\n\n    if (rawSocket.socket.on) {\n      rawSocket.socket.on('error', errfn)\n    } else {\n      rawSocket.socket.onerror = errfn\n    }\n\n    if (!options.signal) {\n      await Promise.race([rawSocket.connected(), errorPromise.promise])\n\n      log('connected %s', ma)\n      return rawSocket\n    }\n\n    // Allow abort via signal during connect\n    let onAbort\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError())\n        // FIXME: https://github.com/libp2p/js-libp2p-websockets/issues/121\n        setTimeout(() => {\n          rawSocket.close()\n        })\n      }\n\n      // Already aborted?\n      if (options.signal.aborted) return onAbort()\n      options.signal.addEventListener('abort', onAbort)\n    })\n\n    try {\n      await Promise.race([abort, errorPromise.promise, rawSocket.connected()])\n    } finally {\n      options.signal.removeEventListener('abort', onAbort)\n    }\n\n    log('connected %s', ma)\n    return rawSocket\n  }\n\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   *\n   * @param {object} [options]\n   * @param {http.Server} [options.server] - A pre-created Node.js HTTP/S server.\n   * @param {function (Connection)} handler\n   * @returns {Listener} A Websockets listener\n   */\n  createListener (options = {}, handler) {\n    if (typeof options === 'function') {\n      handler = options\n      options = {}\n    }\n\n    return createListener({ handler, upgrader: this._upgrader }, options)\n  }\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n   * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n   *\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]} Valid Websockets multiaddrs\n   */\n  filter (multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    if (this._filter) {\n      return this._filter(multiaddrs)\n    }\n\n    // Browser\n    if (env.isBrowser || env.isWebWorker) {\n      return filters.dnsWss(multiaddrs)\n    }\n\n    return filters.all(multiaddrs)\n  }\n}\n\nmodule.exports = withIs(WebSockets, {\n  className: 'WebSockets',\n  symbolName: '@libp2p/js-libp2p-websockets/websockets'\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}