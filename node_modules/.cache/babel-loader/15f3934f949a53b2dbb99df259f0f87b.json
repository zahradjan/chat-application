{"ast":null,"code":"'use strict';\n\nconst log = require('debug')('ipfs:components:peer:storage');\n\nconst createRepo = require('../runtime/repo-nodejs');\n\nconst getDefaultConfig = require('../runtime/config-nodejs');\n\nconst {\n  ERR_REPO_NOT_INITIALIZED\n} = require('ipfs-repo').errors;\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst PeerId = require('peer-id');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst configService = require('./config');\n\nconst {\n  NotEnabledError,\n  NotInitializedError\n} = require('../errors');\n\nconst createLibP2P = require('./libp2p');\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('libp2p-crypto').KeyType} KeyType\n * @typedef {import('libp2p/src/keychain')} Keychain\n */\n\n\nclass Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor(peerId, keychain, repo, print, isNew) {\n    this.print = print;\n    this.peerId = peerId;\n    this.keychain = keychain;\n    this.repo = repo;\n    this.print = print;\n    this.isNew = isNew;\n  }\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n   * @param {IPFSOptions} options\n   */\n\n\n  static async start(print, codecs, options) {\n    const {\n      repoAutoMigrate,\n      repo: inputRepo,\n      onMigrationProgress\n    } = options;\n    const repo = typeof inputRepo === 'string' || inputRepo == null ? createRepo(print, codecs, {\n      path: inputRepo,\n      autoMigrate: repoAutoMigrate,\n      onMigrationProgress: onMigrationProgress\n    }) : inputRepo;\n    const {\n      peerId,\n      keychain,\n      isNew\n    } = await loadRepo(print, repo, options); // TODO: throw error?\n    // @ts-ignore On start, keychain will always be available\n\n    return new Storage(peerId, keychain, repo, print, isNew);\n  }\n\n}\n\nmodule.exports = Storage;\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\n\nconst loadRepo = async (print, repo, options) => {\n  if (!repo.closed) {\n    return { ...(await configureRepo(repo, options)),\n      isNew: false\n    };\n  }\n\n  try {\n    await repo.open();\n    return { ...(await configureRepo(repo, options)),\n      isNew: false\n    };\n  } catch (err) {\n    if (err.code !== ERR_REPO_NOT_INITIALIZED) {\n      throw err;\n    }\n\n    if (options.init && options.init.allowNew === false) {\n      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it');\n    }\n\n    return { ...(await initRepo(print, repo, options)),\n      isNew: true\n    };\n  }\n};\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nconst initRepo = async (print, repo, options) => {\n  const initOptions = options.init || {}; // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n\n  const exists = await repo.exists();\n  log('repo exists?', exists);\n\n  if (exists === true) {\n    throw new Error('repo already exists');\n  } // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.\n\n\n  const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);\n  const identity = peerIdToIdentity(peerId);\n  log('peer identity: %s', identity.PeerID); // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n\n  const config = { ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),\n    Identity: identity\n  };\n  await repo.init(config); // 4. Open initialized repo.\n\n  await repo.open();\n  log('repo opened');\n  /** @type {import('./libp2p').KeychainConfig} */\n\n  const keychainConfig = {\n    pass: options.pass\n  };\n\n  try {\n    keychainConfig.dek = await repo.config.get('Keychain.DEK');\n  } catch (err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err;\n    }\n  } // Create libp2p for Keychain creation\n\n\n  const libp2p = await createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig\n  });\n\n  if (libp2p.keychain && libp2p.keychain.opts) {\n    await libp2p.loadKeychain();\n    await repo.config.set('Keychain', {\n      DEK: libp2p.keychain.opts.dek\n    });\n  }\n\n  return {\n    peerId,\n    keychain: libp2p.keychain\n  };\n};\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>|PeerId}\n */\n\n\nconst decodePeerId = peerId => {\n  log('using user-supplied private-key');\n  return typeof peerId === 'object' ? peerId : PeerId.createFromPrivKey(uint8ArrayFromString(peerId, 'base64pad'));\n};\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {Object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\n\n\nconst initPeerId = (print, _ref) => {\n  let {\n    algorithm = 'Ed25519',\n    bits = 2048\n  } = _ref;\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm);\n  return PeerId.create({\n    keyType: algorithm,\n    bits\n  });\n};\n/**\n * @param {PeerId} peerId\n */\n\n\nconst peerIdToIdentity = peerId => ({\n  PeerID: peerId.toB58String(),\n\n  /** @type {string} */\n  PrivKey: uint8ArrayToString(peerId.privKey.bytes, 'base64pad')\n});\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nconst configureRepo = async (repo, options) => {\n  const config = options.config;\n  const profiles = options.init && options.init.profiles || [];\n  const pass = options.pass;\n  const original = await repo.config.getAll();\n  const changed = mergeConfigs(applyProfiles(original, profiles), config);\n\n  if (original !== changed) {\n    await repo.config.replace(changed);\n  }\n\n  if (!changed.Identity || !changed.Identity.PrivKey) {\n    throw new NotInitializedError('No private key was found in the config, please intialize the repo');\n  }\n\n  const peerId = await PeerId.createFromPrivKey(changed.Identity.PrivKey);\n  const libp2p = await createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  });\n\n  if (libp2p.keychain) {\n    await libp2p.loadKeychain();\n  }\n\n  return {\n    peerId,\n    keychain: libp2p.keychain\n  };\n};\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\n\n\nconst mergeConfigs = (config, changes) => changes ? mergeOptions(config, changes) : config;\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\n\n\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configService.profiles[name];\n\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`);\n    }\n\n    log('applying profile %s', name);\n    return profile.transform(config);\n  }, config);\n};","map":{"version":3,"names":["log","require","createRepo","getDefaultConfig","ERR_REPO_NOT_INITIALIZED","errors","fromString","uint8ArrayFromString","toString","uint8ArrayToString","PeerId","mergeOptions","bind","ignoreUndefined","configService","NotEnabledError","NotInitializedError","createLibP2P","Storage","constructor","peerId","keychain","repo","print","isNew","start","codecs","options","repoAutoMigrate","inputRepo","onMigrationProgress","path","autoMigrate","loadRepo","module","exports","closed","configureRepo","open","err","code","init","allowNew","initRepo","initOptions","exists","Error","privateKey","decodePeerId","initPeerId","identity","peerIdToIdentity","PeerID","config","applyProfiles","profiles","Identity","keychainConfig","pass","dek","get","libp2p","undefined","multiaddrs","opts","loadKeychain","set","DEK","createFromPrivKey","algorithm","bits","create","keyType","toB58String","PrivKey","privKey","bytes","original","getAll","changed","mergeConfigs","replace","Keychain","changes","reduce","name","profile","transform"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/storage.js"],"sourcesContent":["'use strict'\n\nconst log = require('debug')('ipfs:components:peer:storage')\nconst createRepo = require('../runtime/repo-nodejs')\nconst getDefaultConfig = require('../runtime/config-nodejs')\nconst { ERR_REPO_NOT_INITIALIZED } = require('ipfs-repo').errors\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst PeerId = require('peer-id')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst configService = require('./config')\nconst { NotEnabledError, NotInitializedError } = require('../errors')\nconst createLibP2P = require('./libp2p')\n\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('libp2p-crypto').KeyType} KeyType\n * @typedef {import('libp2p/src/keychain')} Keychain\n */\n\nclass Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor (peerId, keychain, repo, print, isNew) {\n    this.print = print\n    this.peerId = peerId\n    this.keychain = keychain\n    this.repo = repo\n    this.print = print\n    this.isNew = isNew\n  }\n\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n   * @param {IPFSOptions} options\n   */\n  static async start (print, codecs, options) {\n    const { repoAutoMigrate, repo: inputRepo, onMigrationProgress } = options\n\n    const repo = (typeof inputRepo === 'string' || inputRepo == null)\n      ? createRepo(print, codecs, {\n        path: inputRepo,\n        autoMigrate: repoAutoMigrate,\n        onMigrationProgress: onMigrationProgress\n      })\n      : inputRepo\n\n    const { peerId, keychain, isNew } = await loadRepo(print, repo, options)\n\n    // TODO: throw error?\n    // @ts-ignore On start, keychain will always be available\n    return new Storage(peerId, keychain, repo, print, isNew)\n  }\n}\nmodule.exports = Storage\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\nconst loadRepo = async (print, repo, options) => {\n  if (!repo.closed) {\n    return { ...await configureRepo(repo, options), isNew: false }\n  }\n\n  try {\n    await repo.open()\n\n    return { ...await configureRepo(repo, options), isNew: false }\n  } catch (err) {\n    if (err.code !== ERR_REPO_NOT_INITIALIZED) {\n      throw err\n    }\n\n    if (options.init && options.init.allowNew === false) {\n      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it')\n    }\n\n    return { ...await initRepo(print, repo, options), isNew: true }\n  }\n}\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst initRepo = async (print, repo, options) => {\n  const initOptions = options.init || {}\n\n  // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n  const exists = await repo.exists()\n  log('repo exists?', exists)\n\n  if (exists === true) {\n    throw new Error('repo already exists')\n  }\n\n  // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.\n  const peerId = initOptions.privateKey\n    ? await decodePeerId(initOptions.privateKey)\n    : await initPeerId(print, initOptions)\n\n  const identity = peerIdToIdentity(peerId)\n\n  log('peer identity: %s', identity.PeerID)\n\n  // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n  const config = {\n    ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),\n    Identity: identity\n  }\n  await repo.init(config)\n\n  // 4. Open initialized repo.\n  await repo.open()\n\n  log('repo opened')\n\n  /** @type {import('./libp2p').KeychainConfig} */\n  const keychainConfig = {\n    pass: options.pass\n  }\n\n  try {\n    keychainConfig.dek = await repo.config.get('Keychain.DEK')\n  } catch (err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err\n    }\n  }\n\n  // Create libp2p for Keychain creation\n  const libp2p = await createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig\n  })\n\n  if (libp2p.keychain && libp2p.keychain.opts) {\n    await libp2p.loadKeychain()\n\n    await repo.config.set('Keychain', {\n      DEK: libp2p.keychain.opts.dek\n    })\n  }\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>|PeerId}\n */\nconst decodePeerId = (peerId) => {\n  log('using user-supplied private-key')\n  return typeof peerId === 'object'\n    ? peerId\n    : PeerId.createFromPrivKey(uint8ArrayFromString(peerId, 'base64pad'))\n}\n\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {Object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\nconst initPeerId = (print, { algorithm = 'Ed25519', bits = 2048 }) => {\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm)\n  return PeerId.create({ keyType: algorithm, bits })\n}\n\n/**\n * @param {PeerId} peerId\n */\nconst peerIdToIdentity = (peerId) => ({\n  PeerID: peerId.toB58String(),\n  /** @type {string} */\n  PrivKey: uint8ArrayToString(peerId.privKey.bytes, 'base64pad')\n})\n\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst configureRepo = async (repo, options) => {\n  const config = options.config\n  const profiles = (options.init && options.init.profiles) || []\n  const pass = options.pass\n  const original = await repo.config.getAll()\n  const changed = mergeConfigs(applyProfiles(original, profiles), config)\n\n  if (original !== changed) {\n    await repo.config.replace(changed)\n  }\n\n  if (!changed.Identity || !changed.Identity.PrivKey) {\n    throw new NotInitializedError('No private key was found in the config, please intialize the repo')\n  }\n\n  const peerId = await PeerId.createFromPrivKey(changed.Identity.PrivKey)\n  const libp2p = await createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  })\n\n  if (libp2p.keychain) {\n    await libp2p.loadKeychain()\n  }\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\nconst mergeConfigs = (config, changes) =>\n  changes ? mergeOptions(config, changes) : config\n\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configService.profiles[name]\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`)\n    }\n    log('applying profile %s', name)\n    return profile.transform(config)\n  }, config)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}