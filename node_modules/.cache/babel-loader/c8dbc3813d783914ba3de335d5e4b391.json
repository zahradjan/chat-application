{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst PeerId = require('peer-id');\n\nconst AddressBook = require('./address-book');\n\nconst KeyBook = require('./key-book');\n\nconst MetadataBook = require('./metadata-book');\n\nconst ProtoBook = require('./proto-book');\n\nconst {\n  codes: {\n    ERR_INVALID_PARAMETERS\n  }\n} = require('../errors');\n/**\n * @typedef {import('./address-book').Address} Address\n */\n\n/**\n * @extends {EventEmitter}\n *\n * @fires PeerStore#peer Emitted when a new peer is added.\n * @fires PeerStore#change:protocols Emitted when a known peer supports a different set of protocols.\n * @fires PeerStore#change:multiaddrs Emitted when a known peer has a different set of multiaddrs.\n * @fires PeerStore#change:pubkey Emitted emitted when a peer's public key is known.\n * @fires PeerStore#change:metadata Emitted when the known metadata of a peer change.\n */\n\n\nclass PeerStore extends EventEmitter {\n  /**\n   * Peer object\n   *\n   * @typedef {Object} Peer\n   * @property {PeerId} id peer's peer-id instance.\n   * @property {Address[]} addresses peer's addresses containing its multiaddrs and metadata.\n   * @property {string[]} protocols peer's supported protocols.\n   * @property {Map<string, Uint8Array>|undefined} metadata peer's metadata map.\n   */\n\n  /**\n   * Responsible for managing known peers, as well as their addresses, protocols and metadata.\n   *\n   * @param {object} options\n   * @param {PeerId} options.peerId\n   * @class\n   */\n  constructor(_ref) {\n    let {\n      peerId\n    } = _ref;\n    super();\n    this._peerId = peerId;\n    /**\n     * AddressBook containing a map of peerIdStr to Address.\n     */\n\n    this.addressBook = new AddressBook(this);\n    /**\n     * KeyBook containing a map of peerIdStr to their PeerId with public keys.\n     */\n\n    this.keyBook = new KeyBook(this);\n    /**\n     * MetadataBook containing a map of peerIdStr to their metadata Map.\n     */\n\n    this.metadataBook = new MetadataBook(this);\n    /**\n     * ProtoBook containing a map of peerIdStr to supported protocols.\n     */\n\n    this.protoBook = new ProtoBook(this);\n  }\n  /**\n   * Start the PeerStore.\n   */\n\n\n  start() {}\n  /**\n   * Stop the PeerStore.\n   */\n\n\n  stop() {}\n  /**\n   * Get all the stored information of every peer known.\n   *\n   * @returns {Map<string, Peer>}\n   */\n\n\n  get peers() {\n    const storedPeers = new Set([...this.addressBook.data.keys(), ...this.keyBook.data.keys(), ...this.protoBook.data.keys(), ...this.metadataBook.data.keys()]); // Remove self peer if present\n\n    this._peerId && storedPeers.delete(this._peerId.toB58String());\n    const peersData = new Map();\n    storedPeers.forEach(idStr => {\n      peersData.set(idStr, this.get(PeerId.createFromB58String(idStr)));\n    });\n    return peersData;\n  }\n  /**\n   * Delete the information of the given peer in every book.\n   *\n   * @param {PeerId} peerId\n   * @returns {boolean} true if found and removed\n   */\n\n\n  delete(peerId) {\n    const addressesDeleted = this.addressBook.delete(peerId);\n    const keyDeleted = this.keyBook.delete(peerId);\n    const protocolsDeleted = this.protoBook.delete(peerId);\n    const metadataDeleted = this.metadataBook.delete(peerId);\n    return addressesDeleted || keyDeleted || protocolsDeleted || metadataDeleted;\n  }\n  /**\n   * Get the stored information of a given peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Peer|undefined}\n   */\n\n\n  get(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const id = this.keyBook.data.get(peerId.toB58String());\n    const addresses = this.addressBook.get(peerId);\n    const metadata = this.metadataBook.get(peerId);\n    const protocols = this.protoBook.get(peerId);\n\n    if (!id && !addresses && !metadata && !protocols) {\n      return undefined;\n    }\n\n    return {\n      id: id || peerId,\n      addresses: addresses || [],\n      protocols: protocols || [],\n      metadata: metadata\n    };\n  }\n\n}\n\nmodule.exports = PeerStore;","map":{"version":3,"names":["errcode","require","EventEmitter","PeerId","AddressBook","KeyBook","MetadataBook","ProtoBook","codes","ERR_INVALID_PARAMETERS","PeerStore","constructor","peerId","_peerId","addressBook","keyBook","metadataBook","protoBook","start","stop","peers","storedPeers","Set","data","keys","delete","toB58String","peersData","Map","forEach","idStr","set","get","createFromB58String","addressesDeleted","keyDeleted","protocolsDeleted","metadataDeleted","isPeerId","Error","id","addresses","metadata","protocols","undefined","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/peer-store/index.js"],"sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\n\nconst { EventEmitter } = require('events')\nconst PeerId = require('peer-id')\n\nconst AddressBook = require('./address-book')\nconst KeyBook = require('./key-book')\nconst MetadataBook = require('./metadata-book')\nconst ProtoBook = require('./proto-book')\n\nconst {\n  codes: { ERR_INVALID_PARAMETERS }\n} = require('../errors')\n\n/**\n * @typedef {import('./address-book').Address} Address\n */\n\n/**\n * @extends {EventEmitter}\n *\n * @fires PeerStore#peer Emitted when a new peer is added.\n * @fires PeerStore#change:protocols Emitted when a known peer supports a different set of protocols.\n * @fires PeerStore#change:multiaddrs Emitted when a known peer has a different set of multiaddrs.\n * @fires PeerStore#change:pubkey Emitted emitted when a peer's public key is known.\n * @fires PeerStore#change:metadata Emitted when the known metadata of a peer change.\n */\nclass PeerStore extends EventEmitter {\n  /**\n   * Peer object\n   *\n   * @typedef {Object} Peer\n   * @property {PeerId} id peer's peer-id instance.\n   * @property {Address[]} addresses peer's addresses containing its multiaddrs and metadata.\n   * @property {string[]} protocols peer's supported protocols.\n   * @property {Map<string, Uint8Array>|undefined} metadata peer's metadata map.\n   */\n\n  /**\n   * Responsible for managing known peers, as well as their addresses, protocols and metadata.\n   *\n   * @param {object} options\n   * @param {PeerId} options.peerId\n   * @class\n   */\n  constructor ({ peerId }) {\n    super()\n\n    this._peerId = peerId\n\n    /**\n     * AddressBook containing a map of peerIdStr to Address.\n     */\n    this.addressBook = new AddressBook(this)\n\n    /**\n     * KeyBook containing a map of peerIdStr to their PeerId with public keys.\n     */\n    this.keyBook = new KeyBook(this)\n\n    /**\n     * MetadataBook containing a map of peerIdStr to their metadata Map.\n     */\n    this.metadataBook = new MetadataBook(this)\n\n    /**\n     * ProtoBook containing a map of peerIdStr to supported protocols.\n     */\n    this.protoBook = new ProtoBook(this)\n  }\n\n  /**\n   * Start the PeerStore.\n   */\n  start () {}\n\n  /**\n   * Stop the PeerStore.\n   */\n  stop () {}\n\n  /**\n   * Get all the stored information of every peer known.\n   *\n   * @returns {Map<string, Peer>}\n   */\n  get peers () {\n    const storedPeers = new Set([\n      ...this.addressBook.data.keys(),\n      ...this.keyBook.data.keys(),\n      ...this.protoBook.data.keys(),\n      ...this.metadataBook.data.keys()\n    ])\n\n    // Remove self peer if present\n    this._peerId && storedPeers.delete(this._peerId.toB58String())\n\n    const peersData = new Map()\n    storedPeers.forEach((idStr) => {\n      peersData.set(idStr, this.get(PeerId.createFromB58String(idStr)))\n    })\n\n    return peersData\n  }\n\n  /**\n   * Delete the information of the given peer in every book.\n   *\n   * @param {PeerId} peerId\n   * @returns {boolean} true if found and removed\n   */\n  delete (peerId) {\n    const addressesDeleted = this.addressBook.delete(peerId)\n    const keyDeleted = this.keyBook.delete(peerId)\n    const protocolsDeleted = this.protoBook.delete(peerId)\n    const metadataDeleted = this.metadataBook.delete(peerId)\n\n    return addressesDeleted || keyDeleted || protocolsDeleted || metadataDeleted\n  }\n\n  /**\n   * Get the stored information of a given peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Peer|undefined}\n   */\n  get (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const id = this.keyBook.data.get(peerId.toB58String())\n    const addresses = this.addressBook.get(peerId)\n    const metadata = this.metadataBook.get(peerId)\n    const protocols = this.protoBook.get(peerId)\n\n    if (!id && !addresses && !metadata && !protocols) {\n      return undefined\n    }\n\n    return {\n      id: id || peerId,\n      addresses: addresses || [],\n      protocols: protocols || [],\n      metadata: metadata\n    }\n  }\n}\n\nmodule.exports = PeerStore\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}