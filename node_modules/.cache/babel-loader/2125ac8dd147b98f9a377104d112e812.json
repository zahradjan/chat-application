{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst defer = require('p-defer');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p-delegated-peer-routing');\nlog.error = debug('libp2p-delegated-peer-routing:error');\nconst DEFAULT_TIMEOUT = 30e3; // 30 second default\n\nconst CONCURRENT_HTTP_REQUESTS = 4;\n\nclass DelegatedPeerRouting {\n  /**\n   * Create a new DelegatedPeerRouting instance.\n   *\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor(client) {\n    if (client == null) {\n      throw new Error('missing ipfs http client');\n    }\n\n    this._client = client; // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n\n    this._httpQueue = new PQueue({\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    });\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig();\n    log(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`);\n  }\n  /**\n   * Attempts to find the given peer\n   *\n   * @param {PeerID} id\n   * @param {object} options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  async findPeer(id) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let idStr = id;\n\n    if (PeerId.isPeerId(idStr)) {\n      idStr = id.toB58String();\n    }\n\n    log('findPeer starts: ' + id);\n    options.timeout = options.timeout || DEFAULT_TIMEOUT;\n\n    try {\n      return await this._httpQueue.add(async () => {\n        const {\n          addrs\n        } = await this._client.dht.findPeer(idStr, {\n          timeout: options.timeout\n        });\n        return {\n          id,\n          multiaddrs: addrs\n        };\n      });\n    } catch (err) {\n      if (err.message.includes('not found')) {\n        return undefined;\n      }\n\n      throw err;\n    } finally {\n      log('findPeer finished: ' + id);\n    }\n  }\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  async *getClosestPeers(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const keyStr = base58btc.encode(key).substring(1);\n    log('getClosestPeers starts:', keyStr);\n    options.timeout = options.timeout || DEFAULT_TIMEOUT;\n    const onStart = defer();\n    const onFinish = defer();\n\n    this._httpQueue.add(() => {\n      onStart.resolve();\n      return onFinish.promise;\n    });\n\n    try {\n      await onStart.promise;\n      const peers = new Map();\n\n      for await (const result of this._client.dht.query(keyStr, {\n        timeout: options.timeout\n      })) {\n        switch (result.type) {\n          case 1:\n            // Found Closer\n            // Track the addresses, so we can yield them when done\n            result.responses.forEach(response => {\n              peers.set(response.id, {\n                id: PeerId.parse(response.id),\n                multiaddrs: response.addrs\n              });\n            });\n            break;\n\n          case 2:\n            // Final Peer\n            yield peers.get(result.id.string) || {\n              id: PeerId.createFromCID(result.id),\n              multiaddrs: []\n            };\n            break;\n\n          default:\n            log('getClosestPeers unhandled response', result);\n        }\n      }\n    } catch (err) {\n      log.error('getClosestPeers errored:', err);\n      throw err;\n    } finally {\n      onFinish.resolve();\n      log('getClosestPeers finished:', keyStr);\n    }\n  }\n\n}\n\nmodule.exports = DelegatedPeerRouting;","map":{"version":3,"names":["PeerId","require","base58btc","default","PQueue","defer","debug","log","error","DEFAULT_TIMEOUT","CONCURRENT_HTTP_REQUESTS","DelegatedPeerRouting","constructor","client","Error","_client","_httpQueue","concurrency","protocol","host","port","getEndpointConfig","findPeer","id","options","idStr","isPeerId","toB58String","timeout","add","addrs","dht","multiaddrs","err","message","includes","undefined","getClosestPeers","key","keyStr","encode","substring","onStart","onFinish","resolve","promise","peers","Map","result","query","type","responses","forEach","response","set","parse","get","string","createFromCID","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-delegated-peer-routing/src/index.js"],"sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { base58btc } = require('multiformats/bases/base58')\nconst { default: PQueue } = require('p-queue')\nconst defer = require('p-defer')\nconst debug = require('debug')\n\nconst log = debug('libp2p-delegated-peer-routing')\nlog.error = debug('libp2p-delegated-peer-routing:error')\n\nconst DEFAULT_TIMEOUT = 30e3 // 30 second default\nconst CONCURRENT_HTTP_REQUESTS = 4\n\nclass DelegatedPeerRouting {\n  /**\n   * Create a new DelegatedPeerRouting instance.\n   *\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor (client) {\n    if (client == null) {\n      throw new Error('missing ipfs http client')\n    }\n\n    this._client = client\n\n    // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n    this._httpQueue = new PQueue({\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    })\n\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig()\n\n    log(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`)\n  }\n\n  /**\n   * Attempts to find the given peer\n   *\n   * @param {PeerID} id\n   * @param {object} options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async findPeer (id, options = {}) {\n    let idStr = id\n    if (PeerId.isPeerId(idStr)) {\n      idStr = id.toB58String()\n    }\n\n    log('findPeer starts: ' + id)\n\n    options.timeout = options.timeout || DEFAULT_TIMEOUT\n\n    try {\n      return await this._httpQueue.add(async () => {\n        const { addrs } = await this._client.dht.findPeer(idStr, {\n          timeout: options.timeout\n        })\n\n        return {\n          id,\n          multiaddrs: addrs\n        }\n      })\n    } catch (err) {\n      if (err.message.includes('not found')) {\n        return undefined\n      }\n\n      throw err\n    } finally {\n      log('findPeer finished: ' + id)\n    }\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async * getClosestPeers (key, options = {}) {\n    const keyStr = base58btc.encode(key).substring(1)\n\n    log('getClosestPeers starts:', keyStr)\n    options.timeout = options.timeout || DEFAULT_TIMEOUT\n\n    const onStart = defer()\n    const onFinish = defer()\n\n    this._httpQueue.add(() => {\n      onStart.resolve()\n      return onFinish.promise\n    })\n\n    try {\n      await onStart.promise\n\n      const peers = new Map()\n\n      for await (const result of this._client.dht.query(keyStr, {\n        timeout: options.timeout\n      })) {\n        switch (result.type) {\n          case 1: // Found Closer\n            // Track the addresses, so we can yield them when done\n            result.responses.forEach(response => {\n              peers.set(response.id, {\n                id: PeerId.parse(response.id),\n                multiaddrs: response.addrs\n              })\n            })\n            break\n          case 2: // Final Peer\n            yield peers.get(result.id.string) || {\n              id: PeerId.createFromCID(result.id),\n              multiaddrs: []\n            }\n            break\n          default:\n            log('getClosestPeers unhandled response', result)\n        }\n      }\n    } catch (err) {\n      log.error('getClosestPeers errored:', err)\n      throw err\n    } finally {\n      onFinish.resolve()\n      log('getClosestPeers finished:', keyStr)\n    }\n  }\n}\n\nmodule.exports = DelegatedPeerRouting\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}