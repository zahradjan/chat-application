{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"libp2p-crypto-keys\"] || ($protobuf.roots[\"libp2p-crypto-keys\"] = {});\n/**\n * KeyType enum.\n * @exports KeyType\n * @enum {number}\n * @property {number} RSA=0 RSA value\n * @property {number} Ed25519=1 Ed25519 value\n * @property {number} Secp256k1=2 Secp256k1 value\n */\n\n$root.KeyType = function () {\n  var valuesById = {},\n      values = Object.create(valuesById);\n  values[valuesById[0] = \"RSA\"] = 0;\n  values[valuesById[1] = \"Ed25519\"] = 1;\n  values[valuesById[2] = \"Secp256k1\"] = 2;\n  return values;\n}();\n\n$root.PublicKey = function () {\n  /**\n   * Properties of a PublicKey.\n   * @exports IPublicKey\n   * @interface IPublicKey\n   * @property {KeyType} Type PublicKey Type\n   * @property {Uint8Array} Data PublicKey Data\n   */\n\n  /**\n   * Constructs a new PublicKey.\n   * @exports PublicKey\n   * @classdesc Represents a PublicKey.\n   * @implements IPublicKey\n   * @constructor\n   * @param {IPublicKey=} [p] Properties to set\n   */\n  function PublicKey(p) {\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * PublicKey Type.\n   * @member {KeyType} Type\n   * @memberof PublicKey\n   * @instance\n   */\n\n\n  PublicKey.prototype.Type = 0;\n  /**\n   * PublicKey Data.\n   * @member {Uint8Array} Data\n   * @memberof PublicKey\n   * @instance\n   */\n\n  PublicKey.prototype.Data = $util.newBuffer([]);\n  /**\n   * Encodes the specified PublicKey message. Does not implicitly {@link PublicKey.verify|verify} messages.\n   * @function encode\n   * @memberof PublicKey\n   * @static\n   * @param {IPublicKey} m PublicKey message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  PublicKey.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    w.uint32(8).int32(m.Type);\n    w.uint32(18).bytes(m.Data);\n    return w;\n  };\n  /**\n   * Decodes a PublicKey message from the specified reader or buffer.\n   * @function decode\n   * @memberof PublicKey\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {PublicKey} PublicKey\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  PublicKey.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.PublicKey();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          m.Type = r.int32();\n          break;\n\n        case 2:\n          m.Data = r.bytes();\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    if (!m.hasOwnProperty(\"Type\")) throw $util.ProtocolError(\"missing required 'Type'\", {\n      instance: m\n    });\n    if (!m.hasOwnProperty(\"Data\")) throw $util.ProtocolError(\"missing required 'Data'\", {\n      instance: m\n    });\n    return m;\n  };\n  /**\n   * Creates a PublicKey message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof PublicKey\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {PublicKey} PublicKey\n   */\n\n\n  PublicKey.fromObject = function fromObject(d) {\n    if (d instanceof $root.PublicKey) return d;\n    var m = new $root.PublicKey();\n\n    switch (d.Type) {\n      case \"RSA\":\n      case 0:\n        m.Type = 0;\n        break;\n\n      case \"Ed25519\":\n      case 1:\n        m.Type = 1;\n        break;\n\n      case \"Secp256k1\":\n      case 2:\n        m.Type = 2;\n        break;\n    }\n\n    if (d.Data != null) {\n      if (typeof d.Data === \"string\") $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);else if (d.Data.length) m.Data = d.Data;\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from a PublicKey message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof PublicKey\n   * @static\n   * @param {PublicKey} m PublicKey\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  PublicKey.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.defaults) {\n      d.Type = o.enums === String ? \"RSA\" : 0;\n      if (o.bytes === String) d.Data = \"\";else {\n        d.Data = [];\n        if (o.bytes !== Array) d.Data = $util.newBuffer(d.Data);\n      }\n    }\n\n    if (m.Type != null && m.hasOwnProperty(\"Type\")) {\n      d.Type = o.enums === String ? $root.KeyType[m.Type] : m.Type;\n    }\n\n    if (m.Data != null && m.hasOwnProperty(\"Data\")) {\n      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n    }\n\n    return d;\n  };\n  /**\n   * Converts this PublicKey to JSON.\n   * @function toJSON\n   * @memberof PublicKey\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  PublicKey.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return PublicKey;\n}();\n\n$root.PrivateKey = function () {\n  /**\n   * Properties of a PrivateKey.\n   * @exports IPrivateKey\n   * @interface IPrivateKey\n   * @property {KeyType} Type PrivateKey Type\n   * @property {Uint8Array} Data PrivateKey Data\n   */\n\n  /**\n   * Constructs a new PrivateKey.\n   * @exports PrivateKey\n   * @classdesc Represents a PrivateKey.\n   * @implements IPrivateKey\n   * @constructor\n   * @param {IPrivateKey=} [p] Properties to set\n   */\n  function PrivateKey(p) {\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * PrivateKey Type.\n   * @member {KeyType} Type\n   * @memberof PrivateKey\n   * @instance\n   */\n\n\n  PrivateKey.prototype.Type = 0;\n  /**\n   * PrivateKey Data.\n   * @member {Uint8Array} Data\n   * @memberof PrivateKey\n   * @instance\n   */\n\n  PrivateKey.prototype.Data = $util.newBuffer([]);\n  /**\n   * Encodes the specified PrivateKey message. Does not implicitly {@link PrivateKey.verify|verify} messages.\n   * @function encode\n   * @memberof PrivateKey\n   * @static\n   * @param {IPrivateKey} m PrivateKey message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  PrivateKey.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    w.uint32(8).int32(m.Type);\n    w.uint32(18).bytes(m.Data);\n    return w;\n  };\n  /**\n   * Decodes a PrivateKey message from the specified reader or buffer.\n   * @function decode\n   * @memberof PrivateKey\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {PrivateKey} PrivateKey\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  PrivateKey.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.PrivateKey();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          m.Type = r.int32();\n          break;\n\n        case 2:\n          m.Data = r.bytes();\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    if (!m.hasOwnProperty(\"Type\")) throw $util.ProtocolError(\"missing required 'Type'\", {\n      instance: m\n    });\n    if (!m.hasOwnProperty(\"Data\")) throw $util.ProtocolError(\"missing required 'Data'\", {\n      instance: m\n    });\n    return m;\n  };\n  /**\n   * Creates a PrivateKey message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof PrivateKey\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {PrivateKey} PrivateKey\n   */\n\n\n  PrivateKey.fromObject = function fromObject(d) {\n    if (d instanceof $root.PrivateKey) return d;\n    var m = new $root.PrivateKey();\n\n    switch (d.Type) {\n      case \"RSA\":\n      case 0:\n        m.Type = 0;\n        break;\n\n      case \"Ed25519\":\n      case 1:\n        m.Type = 1;\n        break;\n\n      case \"Secp256k1\":\n      case 2:\n        m.Type = 2;\n        break;\n    }\n\n    if (d.Data != null) {\n      if (typeof d.Data === \"string\") $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);else if (d.Data.length) m.Data = d.Data;\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from a PrivateKey message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof PrivateKey\n   * @static\n   * @param {PrivateKey} m PrivateKey\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  PrivateKey.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.defaults) {\n      d.Type = o.enums === String ? \"RSA\" : 0;\n      if (o.bytes === String) d.Data = \"\";else {\n        d.Data = [];\n        if (o.bytes !== Array) d.Data = $util.newBuffer(d.Data);\n      }\n    }\n\n    if (m.Type != null && m.hasOwnProperty(\"Type\")) {\n      d.Type = o.enums === String ? $root.KeyType[m.Type] : m.Type;\n    }\n\n    if (m.Data != null && m.hasOwnProperty(\"Data\")) {\n      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n    }\n\n    return d;\n  };\n  /**\n   * Converts this PrivateKey to JSON.\n   * @function toJSON\n   * @memberof PrivateKey\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  PrivateKey.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return PrivateKey;\n}();\n\nmodule.exports = $root;","map":{"version":3,"names":["$protobuf","require","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","KeyType","valuesById","values","Object","create","PublicKey","p","ks","keys","i","length","prototype","Type","Data","newBuffer","encode","m","w","uint32","int32","bytes","decode","r","l","c","undefined","len","pos","t","skipType","hasOwnProperty","ProtocolError","instance","fromObject","d","base64","toObject","o","defaults","enums","String","Array","slice","call","toJSON","constructor","toJSONOptions","PrivateKey","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-delegated-content-routing/node_modules/libp2p-crypto/src/keys/keys.js"],"sourcesContent":["/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"libp2p-crypto-keys\"] || ($protobuf.roots[\"libp2p-crypto-keys\"] = {});\n\n/**\n * KeyType enum.\n * @exports KeyType\n * @enum {number}\n * @property {number} RSA=0 RSA value\n * @property {number} Ed25519=1 Ed25519 value\n * @property {number} Secp256k1=2 Secp256k1 value\n */\n$root.KeyType = (function() {\n    var valuesById = {}, values = Object.create(valuesById);\n    values[valuesById[0] = \"RSA\"] = 0;\n    values[valuesById[1] = \"Ed25519\"] = 1;\n    values[valuesById[2] = \"Secp256k1\"] = 2;\n    return values;\n})();\n\n$root.PublicKey = (function() {\n\n    /**\n     * Properties of a PublicKey.\n     * @exports IPublicKey\n     * @interface IPublicKey\n     * @property {KeyType} Type PublicKey Type\n     * @property {Uint8Array} Data PublicKey Data\n     */\n\n    /**\n     * Constructs a new PublicKey.\n     * @exports PublicKey\n     * @classdesc Represents a PublicKey.\n     * @implements IPublicKey\n     * @constructor\n     * @param {IPublicKey=} [p] Properties to set\n     */\n    function PublicKey(p) {\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * PublicKey Type.\n     * @member {KeyType} Type\n     * @memberof PublicKey\n     * @instance\n     */\n    PublicKey.prototype.Type = 0;\n\n    /**\n     * PublicKey Data.\n     * @member {Uint8Array} Data\n     * @memberof PublicKey\n     * @instance\n     */\n    PublicKey.prototype.Data = $util.newBuffer([]);\n\n    /**\n     * Encodes the specified PublicKey message. Does not implicitly {@link PublicKey.verify|verify} messages.\n     * @function encode\n     * @memberof PublicKey\n     * @static\n     * @param {IPublicKey} m PublicKey message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PublicKey.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        w.uint32(8).int32(m.Type);\n        w.uint32(18).bytes(m.Data);\n        return w;\n    };\n\n    /**\n     * Decodes a PublicKey message from the specified reader or buffer.\n     * @function decode\n     * @memberof PublicKey\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {PublicKey} PublicKey\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PublicKey.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.PublicKey();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.Type = r.int32();\n                break;\n            case 2:\n                m.Data = r.bytes();\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        if (!m.hasOwnProperty(\"Type\"))\n            throw $util.ProtocolError(\"missing required 'Type'\", { instance: m });\n        if (!m.hasOwnProperty(\"Data\"))\n            throw $util.ProtocolError(\"missing required 'Data'\", { instance: m });\n        return m;\n    };\n\n    /**\n     * Creates a PublicKey message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PublicKey\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {PublicKey} PublicKey\n     */\n    PublicKey.fromObject = function fromObject(d) {\n        if (d instanceof $root.PublicKey)\n            return d;\n        var m = new $root.PublicKey();\n        switch (d.Type) {\n        case \"RSA\":\n        case 0:\n            m.Type = 0;\n            break;\n        case \"Ed25519\":\n        case 1:\n            m.Type = 1;\n            break;\n        case \"Secp256k1\":\n        case 2:\n            m.Type = 2;\n            break;\n        }\n        if (d.Data != null) {\n            if (typeof d.Data === \"string\")\n                $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);\n            else if (d.Data.length)\n                m.Data = d.Data;\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from a PublicKey message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PublicKey\n     * @static\n     * @param {PublicKey} m PublicKey\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PublicKey.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.defaults) {\n            d.Type = o.enums === String ? \"RSA\" : 0;\n            if (o.bytes === String)\n                d.Data = \"\";\n            else {\n                d.Data = [];\n                if (o.bytes !== Array)\n                    d.Data = $util.newBuffer(d.Data);\n            }\n        }\n        if (m.Type != null && m.hasOwnProperty(\"Type\")) {\n            d.Type = o.enums === String ? $root.KeyType[m.Type] : m.Type;\n        }\n        if (m.Data != null && m.hasOwnProperty(\"Data\")) {\n            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n        }\n        return d;\n    };\n\n    /**\n     * Converts this PublicKey to JSON.\n     * @function toJSON\n     * @memberof PublicKey\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PublicKey.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PublicKey;\n})();\n\n$root.PrivateKey = (function() {\n\n    /**\n     * Properties of a PrivateKey.\n     * @exports IPrivateKey\n     * @interface IPrivateKey\n     * @property {KeyType} Type PrivateKey Type\n     * @property {Uint8Array} Data PrivateKey Data\n     */\n\n    /**\n     * Constructs a new PrivateKey.\n     * @exports PrivateKey\n     * @classdesc Represents a PrivateKey.\n     * @implements IPrivateKey\n     * @constructor\n     * @param {IPrivateKey=} [p] Properties to set\n     */\n    function PrivateKey(p) {\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * PrivateKey Type.\n     * @member {KeyType} Type\n     * @memberof PrivateKey\n     * @instance\n     */\n    PrivateKey.prototype.Type = 0;\n\n    /**\n     * PrivateKey Data.\n     * @member {Uint8Array} Data\n     * @memberof PrivateKey\n     * @instance\n     */\n    PrivateKey.prototype.Data = $util.newBuffer([]);\n\n    /**\n     * Encodes the specified PrivateKey message. Does not implicitly {@link PrivateKey.verify|verify} messages.\n     * @function encode\n     * @memberof PrivateKey\n     * @static\n     * @param {IPrivateKey} m PrivateKey message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PrivateKey.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        w.uint32(8).int32(m.Type);\n        w.uint32(18).bytes(m.Data);\n        return w;\n    };\n\n    /**\n     * Decodes a PrivateKey message from the specified reader or buffer.\n     * @function decode\n     * @memberof PrivateKey\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {PrivateKey} PrivateKey\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PrivateKey.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.PrivateKey();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.Type = r.int32();\n                break;\n            case 2:\n                m.Data = r.bytes();\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        if (!m.hasOwnProperty(\"Type\"))\n            throw $util.ProtocolError(\"missing required 'Type'\", { instance: m });\n        if (!m.hasOwnProperty(\"Data\"))\n            throw $util.ProtocolError(\"missing required 'Data'\", { instance: m });\n        return m;\n    };\n\n    /**\n     * Creates a PrivateKey message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PrivateKey\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {PrivateKey} PrivateKey\n     */\n    PrivateKey.fromObject = function fromObject(d) {\n        if (d instanceof $root.PrivateKey)\n            return d;\n        var m = new $root.PrivateKey();\n        switch (d.Type) {\n        case \"RSA\":\n        case 0:\n            m.Type = 0;\n            break;\n        case \"Ed25519\":\n        case 1:\n            m.Type = 1;\n            break;\n        case \"Secp256k1\":\n        case 2:\n            m.Type = 2;\n            break;\n        }\n        if (d.Data != null) {\n            if (typeof d.Data === \"string\")\n                $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);\n            else if (d.Data.length)\n                m.Data = d.Data;\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from a PrivateKey message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PrivateKey\n     * @static\n     * @param {PrivateKey} m PrivateKey\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PrivateKey.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.defaults) {\n            d.Type = o.enums === String ? \"RSA\" : 0;\n            if (o.bytes === String)\n                d.Data = \"\";\n            else {\n                d.Data = [];\n                if (o.bytes !== Array)\n                    d.Data = $util.newBuffer(d.Data);\n            }\n        }\n        if (m.Type != null && m.hasOwnProperty(\"Type\")) {\n            d.Type = o.enums === String ? $root.KeyType[m.Type] : m.Type;\n        }\n        if (m.Data != null && m.hasOwnProperty(\"Data\")) {\n            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n        }\n        return d;\n    };\n\n    /**\n     * Converts this PrivateKey to JSON.\n     * @function toJSON\n     * @memberof PrivateKey\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PrivateKey.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PrivateKey;\n})();\n\nmodule.exports = $root;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}