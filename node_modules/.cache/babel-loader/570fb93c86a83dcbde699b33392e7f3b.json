{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerId = require('peer-id');\n/**\n * @typedef {Object} AddressManagerOptions\n * @property {string[]} [listen = []] - list of multiaddrs string representation to listen.\n * @property {string[]} [announce = []] - list of multiaddrs string representation to announce.\n */\n\n/**\n * @fires AddressManager#change:addresses Emitted when a addresses change.\n */\n\n\nclass AddressManager extends EventEmitter {\n  /**\n   * Responsible for managing the peer addresses.\n   * Peers can specify their listen and announce addresses.\n   * The listen addresses will be used by the libp2p transports to listen for new connections,\n   * while the announce addresses will be used for the peer addresses' to other peers in the network.\n   *\n   * @class\n   * @param {PeerId} peerId - The Peer ID of the node\n   * @param {object} [options]\n   * @param {Array<string>} [options.listen = []] - list of multiaddrs string representation to listen.\n   * @param {Array<string>} [options.announce = []] - list of multiaddrs string representation to announce.\n   */\n  constructor(peerId) {\n    let {\n      listen = [],\n      announce = []\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.peerId = peerId;\n    this.listen = new Set(listen.map(ma => ma.toString()));\n    this.announce = new Set(announce.map(ma => ma.toString()));\n    this.observed = new Set();\n  }\n  /**\n   * Get peer listen multiaddrs.\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  getListenAddrs() {\n    return Array.from(this.listen).map(a => new Multiaddr(a));\n  }\n  /**\n   * Get peer announcing multiaddrs.\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  getAnnounceAddrs() {\n    return Array.from(this.announce).map(a => new Multiaddr(a));\n  }\n  /**\n   * Get observed multiaddrs.\n   *\n   * @returns {Array<Multiaddr>}\n   */\n\n\n  getObservedAddrs() {\n    return Array.from(this.observed).map(a => new Multiaddr(a));\n  }\n  /**\n   * Add peer observed addresses\n   *\n   * @param {string | Multiaddr} addr\n   */\n\n\n  addObservedAddr(addr) {\n    let ma = new Multiaddr(addr);\n    const remotePeer = ma.getPeerId(); // strip our peer id if it has been passed\n\n    if (remotePeer) {\n      const remotePeerId = PeerId.createFromB58String(remotePeer); // use same encoding for comparison\n\n      if (remotePeerId.equals(this.peerId)) {\n        ma = ma.decapsulate(new Multiaddr(`/p2p/${this.peerId}`));\n      }\n    }\n\n    const addrString = ma.toString(); // do not trigger the change:addresses event if we already know about this address\n\n    if (this.observed.has(addrString)) {\n      return;\n    }\n\n    this.observed.add(addrString);\n    this.emit('change:addresses');\n  }\n\n}\n\nmodule.exports = AddressManager;","map":{"version":3,"names":["EventEmitter","require","Multiaddr","PeerId","AddressManager","constructor","peerId","listen","announce","Set","map","ma","toString","observed","getListenAddrs","Array","from","a","getAnnounceAddrs","getObservedAddrs","addObservedAddr","addr","remotePeer","getPeerId","remotePeerId","createFromB58String","equals","decapsulate","addrString","has","add","emit","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/address-manager/index.js"],"sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst { Multiaddr } = require('multiaddr')\nconst PeerId = require('peer-id')\n\n/**\n * @typedef {Object} AddressManagerOptions\n * @property {string[]} [listen = []] - list of multiaddrs string representation to listen.\n * @property {string[]} [announce = []] - list of multiaddrs string representation to announce.\n */\n\n/**\n * @fires AddressManager#change:addresses Emitted when a addresses change.\n */\nclass AddressManager extends EventEmitter {\n  /**\n   * Responsible for managing the peer addresses.\n   * Peers can specify their listen and announce addresses.\n   * The listen addresses will be used by the libp2p transports to listen for new connections,\n   * while the announce addresses will be used for the peer addresses' to other peers in the network.\n   *\n   * @class\n   * @param {PeerId} peerId - The Peer ID of the node\n   * @param {object} [options]\n   * @param {Array<string>} [options.listen = []] - list of multiaddrs string representation to listen.\n   * @param {Array<string>} [options.announce = []] - list of multiaddrs string representation to announce.\n   */\n  constructor (peerId, { listen = [], announce = [] } = {}) {\n    super()\n\n    this.peerId = peerId\n    this.listen = new Set(listen.map(ma => ma.toString()))\n    this.announce = new Set(announce.map(ma => ma.toString()))\n    this.observed = new Set()\n  }\n\n  /**\n   * Get peer listen multiaddrs.\n   *\n   * @returns {Multiaddr[]}\n   */\n  getListenAddrs () {\n    return Array.from(this.listen).map((a) => new Multiaddr(a))\n  }\n\n  /**\n   * Get peer announcing multiaddrs.\n   *\n   * @returns {Multiaddr[]}\n   */\n  getAnnounceAddrs () {\n    return Array.from(this.announce).map((a) => new Multiaddr(a))\n  }\n\n  /**\n   * Get observed multiaddrs.\n   *\n   * @returns {Array<Multiaddr>}\n   */\n  getObservedAddrs () {\n    return Array.from(this.observed).map((a) => new Multiaddr(a))\n  }\n\n  /**\n   * Add peer observed addresses\n   *\n   * @param {string | Multiaddr} addr\n   */\n  addObservedAddr (addr) {\n    let ma = new Multiaddr(addr)\n    const remotePeer = ma.getPeerId()\n\n    // strip our peer id if it has been passed\n    if (remotePeer) {\n      const remotePeerId = PeerId.createFromB58String(remotePeer)\n\n      // use same encoding for comparison\n      if (remotePeerId.equals(this.peerId)) {\n        ma = ma.decapsulate(new Multiaddr(`/p2p/${this.peerId}`))\n      }\n    }\n\n    const addrString = ma.toString()\n\n    // do not trigger the change:addresses event if we already know about this address\n    if (this.observed.has(addrString)) {\n      return\n    }\n\n    this.observed.add(addrString)\n    this.emit('change:addresses')\n  }\n}\n\nmodule.exports = AddressManager\n"],"mappings":"AAAA;;AAEA,MAAM;EAAEA;AAAF,IAAmBC,OAAO,CAAC,QAAD,CAAhC;;AACA,MAAM;EAAEC;AAAF,IAAgBD,OAAO,CAAC,WAAD,CAA7B;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,SAAD,CAAtB;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMG,cAAN,SAA6BJ,YAA7B,CAA0C;EACxC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEK,WAAW,CAAEC,MAAF,EAA+C;IAAA,IAArC;MAAEC,MAAM,GAAG,EAAX;MAAeC,QAAQ,GAAG;IAA1B,CAAqC,uEAAJ,EAAI;IACxD;IAEA,KAAKF,MAAL,GAAcA,MAAd;IACA,KAAKC,MAAL,GAAc,IAAIE,GAAJ,CAAQF,MAAM,CAACG,GAAP,CAAWC,EAAE,IAAIA,EAAE,CAACC,QAAH,EAAjB,CAAR,CAAd;IACA,KAAKJ,QAAL,GAAgB,IAAIC,GAAJ,CAAQD,QAAQ,CAACE,GAAT,CAAaC,EAAE,IAAIA,EAAE,CAACC,QAAH,EAAnB,CAAR,CAAhB;IACA,KAAKC,QAAL,GAAgB,IAAIJ,GAAJ,EAAhB;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEK,cAAc,GAAI;IAChB,OAAOC,KAAK,CAACC,IAAN,CAAW,KAAKT,MAAhB,EAAwBG,GAAxB,CAA6BO,CAAD,IAAO,IAAIf,SAAJ,CAAce,CAAd,CAAnC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEC,gBAAgB,GAAI;IAClB,OAAOH,KAAK,CAACC,IAAN,CAAW,KAAKR,QAAhB,EAA0BE,GAA1B,CAA+BO,CAAD,IAAO,IAAIf,SAAJ,CAAce,CAAd,CAArC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEE,gBAAgB,GAAI;IAClB,OAAOJ,KAAK,CAACC,IAAN,CAAW,KAAKH,QAAhB,EAA0BH,GAA1B,CAA+BO,CAAD,IAAO,IAAIf,SAAJ,CAAce,CAAd,CAArC,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEG,eAAe,CAAEC,IAAF,EAAQ;IACrB,IAAIV,EAAE,GAAG,IAAIT,SAAJ,CAAcmB,IAAd,CAAT;IACA,MAAMC,UAAU,GAAGX,EAAE,CAACY,SAAH,EAAnB,CAFqB,CAIrB;;IACA,IAAID,UAAJ,EAAgB;MACd,MAAME,YAAY,GAAGrB,MAAM,CAACsB,mBAAP,CAA2BH,UAA3B,CAArB,CADc,CAGd;;MACA,IAAIE,YAAY,CAACE,MAAb,CAAoB,KAAKpB,MAAzB,CAAJ,EAAsC;QACpCK,EAAE,GAAGA,EAAE,CAACgB,WAAH,CAAe,IAAIzB,SAAJ,CAAe,QAAO,KAAKI,MAAO,EAAlC,CAAf,CAAL;MACD;IACF;;IAED,MAAMsB,UAAU,GAAGjB,EAAE,CAACC,QAAH,EAAnB,CAdqB,CAgBrB;;IACA,IAAI,KAAKC,QAAL,CAAcgB,GAAd,CAAkBD,UAAlB,CAAJ,EAAmC;MACjC;IACD;;IAED,KAAKf,QAAL,CAAciB,GAAd,CAAkBF,UAAlB;IACA,KAAKG,IAAL,CAAU,kBAAV;EACD;;AA7EuC;;AAgF1CC,MAAM,CAACC,OAAP,GAAiB7B,cAAjB"},"metadata":{},"sourceType":"script"}