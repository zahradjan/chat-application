{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst PeerId = require('peer-id');\n\nconst drain = require('it-drain');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst defer = require('p-defer');\n\nconst log = debug('libp2p-delegated-content-routing');\nlog.error = debug('libp2p-delegated-content-routing:error');\nconst DEFAULT_TIMEOUT = 30e3; // 30 second default\n\nconst CONCURRENT_HTTP_REQUESTS = 4;\n/**\n * @typedef {import('peer-id').PeerID} PeerID\n * @typedef {import('cids').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * An implementation of content routing, using a delegated peer.\n */\n\nclass DelegatedContentRouting {\n  /**\n   * Create a new DelegatedContentRouting instance.\n   *\n   * @param {PeerID} peerId - the id of the node that is using this routing.\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor(peerId, client) {\n    if (peerId == null) {\n      throw new Error('missing self peerId');\n    }\n\n    if (client == null) {\n      throw new Error('missing ipfs http client');\n    }\n\n    this._client = client;\n    this.peerId = peerId; // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n\n    const concurrency = {\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    };\n    this._httpQueue = new PQueue(concurrency); // sometimes refs requests take long time, they need separate queue\n    // to not suffocate regular business\n\n    this._httpQueueRefs = new PQueue(Object.assign({}, concurrency, {\n      concurrency: 2\n    }));\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig();\n    log(`enabled DelegatedContentRouting via ${protocol}://${host}:${port}`);\n  }\n  /**\n   * Search the dht for providers of the given CID.\n   *\n   * - call `findProviders` on the delegated node.\n   *\n   * @param {CID} key - The CID to find providers for\n   * @param {object} options - Options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @param {number} options.numProviders - How many providers to find, defaults to 20\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} - An async iterable of PeerId/Multiaddrs\n   */\n\n\n  async *findProviders(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    log(`findProviders starts: ${key}`);\n    options.timeout = options.timeout || DEFAULT_TIMEOUT;\n    let providers = 0;\n    const onStart = defer();\n    const onFinish = defer();\n\n    this._httpQueue.add(() => {\n      onStart.resolve();\n      return onFinish.promise;\n    });\n\n    try {\n      await onStart.promise;\n\n      for await (const {\n        id,\n        addrs\n      } of this._client.dht.findProvs(key, {\n        numProviders: options.numProviders,\n        timeout: options.timeout\n      })) {\n        yield {\n          id: PeerId.parse(id),\n          multiaddrs: addrs\n        };\n        providers++;\n      }\n    } catch (err) {\n      log.error('findProviders errored:', err);\n      throw err;\n    } finally {\n      onFinish.resolve();\n      log(`findProviders finished: ${key} found ${providers} providers`);\n    }\n  }\n  /**\n   * Announce to the network that the delegated node can provide the given key.\n   *\n   * Currently this uses the following hack\n   * - delegate is one of bootstrap nodes, so we are always connected to it\n   * - call block stat on the delegated node, so it fetches the content\n   * - call dht provide with the passed cid\n   *\n   * N.B. this must be called for every block in the dag you want provided otherwise\n   * the delegate will only be able to supply the root block of the dag when asked\n   * for the data by an interested peer.\n   *\n   * @param {CID} key - The delegate will publish a provider record for this CID\n   * @returns {Promise<void>}\n   */\n\n\n  async provide(key) {\n    log(`provide starts: ${key}`);\n    await this._httpQueueRefs.add(async () => {\n      await this._client.block.stat(key);\n      await drain(this._client.dht.provide(key));\n    });\n    log(`provide finished: ${key}`);\n  }\n\n}\n\nmodule.exports = DelegatedContentRouting;","map":{"version":3,"names":["debug","require","PeerId","drain","default","PQueue","defer","log","error","DEFAULT_TIMEOUT","CONCURRENT_HTTP_REQUESTS","DelegatedContentRouting","constructor","peerId","client","Error","_client","concurrency","_httpQueue","_httpQueueRefs","Object","assign","protocol","host","port","getEndpointConfig","findProviders","key","options","timeout","providers","onStart","onFinish","add","resolve","promise","id","addrs","dht","findProvs","numProviders","parse","multiaddrs","err","provide","block","stat","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-delegated-content-routing/src/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst PeerId = require('peer-id')\nconst drain = require('it-drain')\n\nconst { default: PQueue } = require('p-queue')\nconst defer = require('p-defer')\n\nconst log = debug('libp2p-delegated-content-routing')\nlog.error = debug('libp2p-delegated-content-routing:error')\n\nconst DEFAULT_TIMEOUT = 30e3 // 30 second default\nconst CONCURRENT_HTTP_REQUESTS = 4\n\n/**\n * @typedef {import('peer-id').PeerID} PeerID\n * @typedef {import('cids').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * An implementation of content routing, using a delegated peer.\n */\nclass DelegatedContentRouting {\n  /**\n   * Create a new DelegatedContentRouting instance.\n   *\n   * @param {PeerID} peerId - the id of the node that is using this routing.\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor (peerId, client) {\n    if (peerId == null) {\n      throw new Error('missing self peerId')\n    }\n\n    if (client == null) {\n      throw new Error('missing ipfs http client')\n    }\n\n    this._client = client\n    this.peerId = peerId\n\n    // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n    const concurrency = { concurrency: CONCURRENT_HTTP_REQUESTS }\n    this._httpQueue = new PQueue(concurrency)\n    // sometimes refs requests take long time, they need separate queue\n    // to not suffocate regular business\n    this._httpQueueRefs = new PQueue(Object.assign({}, concurrency, {\n      concurrency: 2\n    }))\n\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig()\n\n    log(`enabled DelegatedContentRouting via ${protocol}://${host}:${port}`)\n  }\n\n  /**\n   * Search the dht for providers of the given CID.\n   *\n   * - call `findProviders` on the delegated node.\n   *\n   * @param {CID} key - The CID to find providers for\n   * @param {object} options - Options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @param {number} options.numProviders - How many providers to find, defaults to 20\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} - An async iterable of PeerId/Multiaddrs\n   */\n  async * findProviders (key, options = {}) {\n    log(`findProviders starts: ${key}`)\n    options.timeout = options.timeout || DEFAULT_TIMEOUT\n\n    let providers = 0\n    const onStart = defer()\n    const onFinish = defer()\n\n    this._httpQueue.add(() => {\n      onStart.resolve()\n      return onFinish.promise\n    })\n\n    try {\n      await onStart.promise\n\n      for await (const { id, addrs } of this._client.dht.findProvs(key, {\n        numProviders: options.numProviders,\n        timeout: options.timeout\n      })) {\n        yield {\n          id: PeerId.parse(id),\n          multiaddrs: addrs\n        }\n        providers++\n      }\n    } catch (err) {\n      log.error('findProviders errored:', err)\n      throw err\n    } finally {\n      onFinish.resolve()\n      log(`findProviders finished: ${key} found ${providers} providers`)\n    }\n  }\n\n  /**\n   * Announce to the network that the delegated node can provide the given key.\n   *\n   * Currently this uses the following hack\n   * - delegate is one of bootstrap nodes, so we are always connected to it\n   * - call block stat on the delegated node, so it fetches the content\n   * - call dht provide with the passed cid\n   *\n   * N.B. this must be called for every block in the dag you want provided otherwise\n   * the delegate will only be able to supply the root block of the dag when asked\n   * for the data by an interested peer.\n   *\n   * @param {CID} key - The delegate will publish a provider record for this CID\n   * @returns {Promise<void>}\n   */\n  async provide (key) {\n    log(`provide starts: ${key}`)\n    await this._httpQueueRefs.add(async () => {\n      await this._client.block.stat(key)\n      await drain(this._client.dht.provide(key))\n    })\n    log(`provide finished: ${key}`)\n  }\n}\n\nmodule.exports = DelegatedContentRouting\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}