{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar _asyncGeneratorDelegate = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate.js\").default;\n\nvar _require = require('multiformats/cid'),\n    CID = _require.CID;\n\nvar _require2 = require('./pin'),\n    PinSet = _require2.ipfs.pin.Set; // @ts-ignore\n\n\nvar fnv1a = require('fnv1a');\n\nvar varint = require('varint');\n\nvar dagPb = require('@ipld/dag-pb');\n\nvar _require3 = require('./utils'),\n    DEFAULT_FANOUT = _require3.DEFAULT_FANOUT,\n    MAX_ITEMS = _require3.MAX_ITEMS,\n    EMPTY_KEY = _require3.EMPTY_KEY;\n\nvar _require4 = require('uint8arrays/concat'),\n    uint8ArrayConcat = _require4.concat;\n\nvar _require5 = require('uint8arrays/compare'),\n    uint8ArrayCompare = _require5.compare;\n\nvar _require6 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require6.toString;\n\nvar _require7 = require('uint8arrays/from-string'),\n    uint8ArrayFromString = _require7.fromString;\n\nvar _require8 = require('multiformats/hashes/sha2'),\n    sha256 = _require8.sha256;\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\n\n\nfunction readHeader(rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  var rootData = rootNode.Data;\n\n  if (!rootData) {\n    throw new Error('No data present');\n  }\n\n  var hdrLength = varint.decode(rootData);\n  var vBytes = varint.decode.bytes;\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n\n  var hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  var header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  });\n\n  if (header.version !== 1) {\n    throw new Error(\"Unsupported Set version: \".concat(header.version));\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n/**\n * @param {number} seed\n * @param {CID} key\n */\n\n\nfunction hash(seed, key) {\n  var buffer = new Uint8Array(4);\n  var dataView = new DataView(buffer.buffer);\n  dataView.setUint32(0, seed, true);\n  var encodedKey = uint8ArrayFromString(key.toString());\n  var data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength);\n  return fnv1a(uint8ArrayToString(data));\n}\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\n\n\nfunction walkItems(_x, _x2) {\n  return _walkItems.apply(this, arguments);\n}\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\n\n\nfunction _walkItems() {\n  _walkItems = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(blockstore, node) {\n    var pbh, idx, _iterator, _step, link, linkHash, buf, _node;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            pbh = readHeader(node);\n            idx = 0;\n            _iterator = _createForOfIteratorHelper(node.Links);\n            _context.prev = 3;\n\n            _iterator.s();\n\n          case 5:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 22;\n              break;\n            }\n\n            link = _step.value;\n\n            if (!(idx < pbh.header.fanout)) {\n              _context.next = 17;\n              break;\n            }\n\n            // the first pbh.header.fanout links are fanout bins\n            // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n            linkHash = link.Hash;\n\n            if (EMPTY_KEY.equals(linkHash)) {\n              _context.next = 15;\n              break;\n            }\n\n            _context.next = 12;\n            return _awaitAsyncGenerator(blockstore.get(linkHash));\n\n          case 12:\n            buf = _context.sent;\n            _node = dagPb.decode(buf);\n            return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(walkItems(blockstore, _node)), _awaitAsyncGenerator), \"t0\", 15);\n\n          case 15:\n            _context.next = 19;\n            break;\n\n          case 17:\n            _context.next = 19;\n            return link.Hash;\n\n          case 19:\n            idx++;\n\n          case 20:\n            _context.next = 5;\n            break;\n\n          case 22:\n            _context.next = 27;\n            break;\n\n          case 24:\n            _context.prev = 24;\n            _context.t1 = _context[\"catch\"](3);\n\n            _iterator.e(_context.t1);\n\n          case 27:\n            _context.prev = 27;\n\n            _iterator.f();\n\n            return _context.finish(27);\n\n          case 30:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3, 24, 27, 30]]);\n  }));\n  return _walkItems.apply(this, arguments);\n}\n\nfunction loadSet(_x3, _x4, _x5) {\n  return _loadSet.apply(this, arguments);\n}\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\n\n\nfunction _loadSet() {\n  _loadSet = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(blockstore, rootNode, name) {\n    var link, buf, node;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            link = rootNode.Links.find(function (l) {\n              return l.Name === name;\n            });\n\n            if (link) {\n              _context2.next = 3;\n              break;\n            }\n\n            throw new Error('No link found with name ' + name);\n\n          case 3:\n            _context2.next = 5;\n            return _awaitAsyncGenerator(blockstore.get(link.Hash));\n\n          case 5:\n            buf = _context2.sent;\n            node = dagPb.decode(buf);\n            return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(walkItems(blockstore, node)), _awaitAsyncGenerator), \"t0\", 8);\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadSet.apply(this, arguments);\n}\n\nfunction storeItems(blockstore, items) {\n  return storePins(items, 0);\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n\n  function storePins(_x6, _x7) {\n    return _storePins.apply(this, arguments);\n  }\n\n  function _storePins() {\n    _storePins = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(pins, depth) {\n      var pbHeader, header, headerBuf, fanoutLinks, i, nodes, rootLinks, rootData, bins, idx, _iterator2, _step2, bin, child, storeChild, _storeChild;\n\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _storeChild = function _storeChild3() {\n                _storeChild = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(child, binIdx) {\n                  var buf, digest, cid, size;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          buf = dagPb.encode(child);\n                          _context3.next = 3;\n                          return sha256.digest(buf);\n\n                        case 3:\n                          digest = _context3.sent;\n                          cid = CID.createV0(digest);\n                          _context3.next = 7;\n                          return blockstore.put(cid, buf);\n\n                        case 7:\n                          size = child.Links.reduce(function (acc, curr) {\n                            return acc + (curr.Tsize || 0);\n                          }, 0) + buf.length;\n                          fanoutLinks[binIdx] = {\n                            Name: '',\n                            Tsize: size,\n                            Hash: cid\n                          };\n\n                        case 9:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3);\n                }));\n                return _storeChild.apply(this, arguments);\n              };\n\n              storeChild = function _storeChild2(_x8, _x9) {\n                return _storeChild.apply(this, arguments);\n              };\n\n              pbHeader = PinSet.encode({\n                version: 1,\n                fanout: DEFAULT_FANOUT,\n                seed: depth\n              }).finish();\n              header = varint.encode(pbHeader.length);\n              headerBuf = uint8ArrayConcat([header, pbHeader]);\n              fanoutLinks = [];\n\n              for (i = 0; i < DEFAULT_FANOUT; i++) {\n                fanoutLinks.push({\n                  Name: '',\n                  Tsize: 1,\n                  Hash: EMPTY_KEY\n                });\n              }\n\n              if (!(pins.length <= MAX_ITEMS)) {\n                _context4.next = 14;\n                break;\n              }\n\n              nodes = pins.map(function (item) {\n                return {\n                  link: {\n                    Name: '',\n                    Tsize: 1,\n                    Hash: item.key\n                  },\n                  data: item.data || new Uint8Array()\n                };\n              }) // sorting makes any ordering of `pins` produce the same DAGNode\n              .sort(function (a, b) {\n                return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes);\n              });\n              rootLinks = fanoutLinks.concat(nodes.map(function (item) {\n                return item.link;\n              }));\n              rootData = uint8ArrayConcat([headerBuf].concat(_toConsumableArray(nodes.map(function (item) {\n                return item.data;\n              }))));\n              return _context4.abrupt(\"return\", {\n                Data: rootData,\n                Links: rootLinks\n              });\n\n            case 14:\n              // If the array of pins is > MAX_ITEMS, we:\n              //  - distribute the pins among `DEFAULT_FANOUT` bins\n              //    - create a DAGNode for each bin\n              //      - add each pin as a DAGLink to that bin\n              //  - create a root DAGNode\n              //    - add each bin as a DAGLink\n              //  - send that root DAGNode via callback\n              // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n              // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n              /** @type {Pin[][]} */\n              bins = pins.reduce(function (bins, pin) {\n                var n = hash(depth, pin.key) % DEFAULT_FANOUT; // @ts-ignore\n\n                bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n                return bins;\n              }, []);\n              idx = 0;\n              _iterator2 = _createForOfIteratorHelper(bins);\n              _context4.prev = 17;\n\n              _iterator2.s();\n\n            case 19:\n              if ((_step2 = _iterator2.n()).done) {\n                _context4.next = 29;\n                break;\n              }\n\n              bin = _step2.value;\n              _context4.next = 23;\n              return storePins(bin, depth + 1);\n\n            case 23:\n              child = _context4.sent;\n              _context4.next = 26;\n              return storeChild(child, idx);\n\n            case 26:\n              idx++;\n\n            case 27:\n              _context4.next = 19;\n              break;\n\n            case 29:\n              _context4.next = 34;\n              break;\n\n            case 31:\n              _context4.prev = 31;\n              _context4.t0 = _context4[\"catch\"](17);\n\n              _iterator2.e(_context4.t0);\n\n            case 34:\n              _context4.prev = 34;\n\n              _iterator2.f();\n\n              return _context4.finish(34);\n\n            case 37:\n              return _context4.abrupt(\"return\", {\n                Data: headerBuf,\n                Links: fanoutLinks\n              });\n\n            case 38:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, null, [[17, 31, 34, 37]]);\n    }));\n    return _storePins.apply(this, arguments);\n  }\n}\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\n\n\nfunction storeSet(_x10, _x11, _x12) {\n  return _storeSet.apply(this, arguments);\n}\n\nfunction _storeSet() {\n  _storeSet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(blockstore, type, cids) {\n    var rootNode, buf, digest, cid, size;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return storeItems(blockstore, cids.map(function (cid) {\n              return {\n                key: cid\n              };\n            }));\n\n          case 2:\n            rootNode = _context5.sent;\n            buf = dagPb.encode(rootNode);\n            _context5.next = 6;\n            return sha256.digest(buf);\n\n          case 6:\n            digest = _context5.sent;\n            cid = CID.createV0(digest);\n            _context5.next = 10;\n            return blockstore.put(cid, buf);\n\n          case 10:\n            size = rootNode.Links.reduce(function (acc, curr) {\n              return acc + curr.Tsize;\n            }, 0) + buf.length;\n            return _context5.abrupt(\"return\", {\n              Name: type,\n              Tsize: size,\n              Hash: cid\n            });\n\n          case 12:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _storeSet.apply(this, arguments);\n}\n\nmodule.exports = {\n  loadSet: loadSet,\n  storeSet: storeSet\n};","map":{"version":3,"names":["require","CID","PinSet","ipfs","pin","Set","fnv1a","varint","dagPb","DEFAULT_FANOUT","MAX_ITEMS","EMPTY_KEY","uint8ArrayConcat","concat","uint8ArrayCompare","compare","uint8ArrayToString","toString","uint8ArrayFromString","fromString","sha256","readHeader","rootNode","rootData","Data","Error","hdrLength","decode","vBytes","bytes","length","hdrSlice","slice","header","toObject","defaults","arrays","longs","Number","objects","version","fanout","Links","data","hash","seed","key","buffer","Uint8Array","dataView","DataView","setUint32","encodedKey","byteLength","walkItems","blockstore","node","pbh","idx","link","linkHash","Hash","equals","get","buf","loadSet","name","find","l","Name","storeItems","items","storePins","pins","depth","storeChild","child","binIdx","encode","digest","cid","createV0","put","size","reduce","acc","curr","Tsize","fanoutLinks","pbHeader","finish","headerBuf","i","push","nodes","map","item","sort","a","b","rootLinks","bins","n","bin","storeSet","type","cids","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-repo-migrations/migrations/migration-9/pin-set.js"],"sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst {\n  ipfs: {\n    pin: {\n      Set: PinSet\n    }\n  }\n} = require('./pin')\n\n// @ts-ignore\nconst fnv1a = require('fnv1a')\nconst varint = require('varint')\nconst dagPb = require('@ipld/dag-pb')\nconst { DEFAULT_FANOUT, MAX_ITEMS, EMPTY_KEY } = require('./utils')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst { compare: uint8ArrayCompare } = require('uint8arrays/compare')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { sha256 } = require('multiformats/hashes/sha2')\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\nfunction readHeader (rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data\n\n  if (!rootData) {\n    throw new Error('No data present')\n  }\n\n  const hdrLength = varint.decode(rootData)\n  const vBytes = varint.decode.bytes\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length')\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length')\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes)\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  })\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`)\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout')\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  }\n}\n\n/**\n * @param {number} seed\n * @param {CID} key\n */\nfunction hash (seed, key) {\n  const buffer = new Uint8Array(4)\n  const dataView = new DataView(buffer.buffer)\n  dataView.setUint32(0, seed, true)\n  const encodedKey = uint8ArrayFromString(key.toString())\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength)\n\n  return fnv1a(uint8ArrayToString(data))\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\nasync function * walkItems (blockstore, node) {\n  const pbh = readHeader(node)\n  let idx = 0\n\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      // the first pbh.header.fanout links are fanout bins\n      // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n      const linkHash = link.Hash\n\n      if (!EMPTY_KEY.equals(linkHash)) {\n        // walk the links of this fanout bin\n        const buf = await blockstore.get(linkHash)\n        const node = dagPb.decode(buf)\n\n        yield * walkItems(blockstore, node)\n      }\n    } else {\n      // otherwise, the link is a pin\n      yield link.Hash\n    }\n\n    idx++\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\nasync function * loadSet (blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name)\n\n  if (!link) {\n    throw new Error('No link found with name ' + name)\n  }\n\n  const buf = await blockstore.get(link.Hash)\n  const node = dagPb.decode(buf)\n\n  yield * walkItems(blockstore, node)\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\nfunction storeItems (blockstore, items) {\n  return storePins(items, 0)\n\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n  async function storePins (pins, depth) {\n    const pbHeader = PinSet.encode({\n      version: 1,\n      fanout: DEFAULT_FANOUT,\n      seed: depth\n    }).finish()\n\n    const header = varint.encode(pbHeader.length)\n    const headerBuf = uint8ArrayConcat([header, pbHeader])\n    const fanoutLinks = []\n\n    for (let i = 0; i < DEFAULT_FANOUT; i++) {\n      fanoutLinks.push({\n        Name: '',\n        Tsize: 1,\n        Hash: EMPTY_KEY\n      })\n    }\n\n    if (pins.length <= MAX_ITEMS) {\n      const nodes = pins\n        .map(item => {\n          return ({\n            link: {\n              Name: '',\n              Tsize: 1,\n              Hash: item.key\n            },\n            data: item.data || new Uint8Array()\n          })\n        })\n        // sorting makes any ordering of `pins` produce the same DAGNode\n        .sort((a, b) => {\n          return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes)\n        })\n\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link))\n      const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)])\n\n      return {\n        Data: rootData,\n        Links: rootLinks\n      }\n    } else {\n      // If the array of pins is > MAX_ITEMS, we:\n      //  - distribute the pins among `DEFAULT_FANOUT` bins\n      //    - create a DAGNode for each bin\n      //      - add each pin as a DAGLink to that bin\n      //  - create a root DAGNode\n      //    - add each bin as a DAGLink\n      //  - send that root DAGNode via callback\n      // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n      // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n      /** @type {Pin[][]} */\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % DEFAULT_FANOUT\n        // @ts-ignore\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin]\n        return bins\n      }, [])\n\n      let idx = 0\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1)\n\n        await storeChild(child, idx)\n\n        idx++\n      }\n\n      return {\n        Data: headerBuf,\n        Links: fanoutLinks\n      }\n    }\n\n    /**\n     * @param {PBNode} child\n     * @param {number} binIdx\n     */\n    async function storeChild (child, binIdx) {\n      const buf = dagPb.encode(child)\n      const digest = await sha256.digest(buf)\n      const cid = CID.createV0(digest)\n\n      await blockstore.put(cid, buf)\n\n      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length\n\n      fanoutLinks[binIdx] = {\n        Name: '',\n        Tsize: size,\n        Hash: cid\n      }\n    }\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\nasync function storeSet (blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid\n    }\n  }))\n  const buf = dagPb.encode(rootNode)\n  const digest = await sha256.digest(buf)\n  const cid = CID.createV0(digest)\n\n  await blockstore.put(cid, buf)\n\n  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length\n\n  return {\n    Name: type,\n    Tsize: size,\n    Hash: cid\n  }\n}\n\nmodule.exports = {\n  loadSet,\n  storeSet\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}