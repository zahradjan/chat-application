{"ast":null,"code":"'use strict';\n\nconst get = require('dlv');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst errCode = require('err-code');\n\nconst PubsubRouters = require('../runtime/libp2p-pubsub-routers-nodejs'); // @ts-ignore - no types\n\n\nconst DelegatedPeerRouter = require('libp2p-delegated-peer-routing'); // @ts-ignore - no types\n\n\nconst DelegatedContentRouter = require('libp2p-delegated-content-routing');\n\nconst {\n  create: ipfsHttpClient\n} = require('ipfs-http-client');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst pkgversion = require('../../package.json').version;\n/**\n * @typedef {object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {Object} KeychainConfig\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n *\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('libp2p')} LibP2P\n * @typedef {import('libp2p').Libp2pOptions & import('libp2p').CreateOptions} Libp2pOptions\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n */\n\n/**\n * @param {Object} config\n * @param {Repo} config.repo\n * @param {IPFSOptions|undefined} config.options\n * @param {PeerId} config.peerId\n * @param {Multiaddr[]|undefined} config.multiaddrs\n * @param {KeychainConfig|undefined} config.keychainConfig\n * @param {Partial<IPFSConfig>|undefined} config.config\n */\n\n\nmodule.exports = _ref => {\n  let {\n    options = {},\n    peerId,\n    multiaddrs = [],\n    repo,\n    keychainConfig = {},\n    config = {}\n  } = _ref;\n  const {\n    datastore,\n    keys\n  } = repo;\n  const libp2pOptions = getLibp2pOptions({\n    options,\n    config,\n    datastore,\n    keys,\n    keychainConfig,\n    peerId,\n    multiaddrs\n  });\n\n  if (typeof options.libp2p === 'function') {\n    return options.libp2p({\n      libp2pOptions,\n      options,\n      config,\n      datastore,\n      peerId\n    });\n  } // Required inline to reduce startup time\n\n\n  const Libp2p = require('libp2p');\n\n  return Libp2p.create(libp2pOptions);\n};\n/**\n * @param {Object} input\n * @param {IPFSOptions} input.options\n * @param {Partial<IPFSConfig>} input.config\n * @param {Repo['datastore']} input.datastore\n * @param {Repo['keys']} input.keys\n * @param {KeychainConfig} input.keychainConfig\n * @param {PeerId} input.peerId\n * @param {Multiaddr[]} input.multiaddrs\n * @returns {Libp2pOptions}\n */\n\n\nfunction getLibp2pOptions(_ref2) {\n  let {\n    options,\n    config,\n    datastore,\n    keys,\n    keychainConfig,\n    peerId,\n    multiaddrs\n  } = _ref2;\n\n  const getPubsubRouter = () => {\n    const router = get(config, 'Pubsub.Router') || 'gossipsub'; // @ts-ignore - `router` value is not constrained\n\n    if (!PubsubRouters[router]) {\n      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED');\n    } // @ts-ignore - `router` value is not constrained\n\n\n    return PubsubRouters[router];\n  };\n\n  const libp2pDefaults = {\n    datastore,\n    peerId: peerId,\n    modules: {}\n  };\n  const libp2pOptions = {\n    /**\n     * @type {Partial<Libp2pOptions[\"modules\"]>}\n     */\n    modules: {\n      pubsub: getPubsubRouter(),\n      contentRouting: [],\n      peerRouting: []\n    },\n    config: {\n      peerDiscovery: {\n        mdns: {\n          enabled: get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))\n        },\n        webRTCStar: {\n          enabled: get(options, 'config.Discovery.webRTCStar.Enabled', get(config, 'Discovery.webRTCStar.Enabled', true))\n        },\n        bootstrap: {\n          list: get(options, 'config.Bootstrap', get(config, 'Bootstrap', []))\n        }\n      },\n      relay: {\n        enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),\n        hop: {\n          enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),\n          active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))\n        }\n      },\n      dht: {\n        enabled: get(config, 'Routing.Type', 'none') !== 'none',\n        clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',\n        kBucketSize: get(options, 'dht.kBucketSize', 20)\n      },\n      pubsub: {\n        enabled: get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))\n      },\n      nat: {\n        enabled: !get(config, 'Swarm.DisableNatPortMap', false)\n      }\n    },\n    addresses: {\n      listen: multiaddrs.map(ma => ma.toString()),\n      announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', [])),\n      noAnnounce: get(options, 'addresses.noAnnounce', get(config, 'Addresses.NoAnnounce', []))\n    },\n    connectionManager: get(options, 'connectionManager', {\n      maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),\n      minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))\n    }),\n    keychain: {\n      datastore: keys,\n      ...keychainConfig\n    },\n    host: {\n      agentVersion: `js-ipfs/${pkgversion}`\n    }\n  }; // Required inline to reduce startup time\n  // Note: libp2p-nodejs gets replaced by libp2p-browser when webpacked/browserified\n\n  const getEnvLibp2pOptions = require('../runtime/libp2p-nodejs');\n  /** @type {import('libp2p').Libp2pOptions | undefined} */\n\n\n  let constructorOptions = get(options, 'libp2p', undefined);\n\n  if (typeof constructorOptions === 'function') {\n    constructorOptions = undefined;\n  } // Merge defaults with Node.js/browser/other environments options and configuration\n\n\n  const libp2pConfig = mergeOptions(libp2pDefaults, getEnvLibp2pOptions(), libp2pOptions, constructorOptions);\n  const bootstrapList = get(libp2pConfig, 'config.peerDiscovery.bootstrap.list', []);\n\n  if (bootstrapList.length > 0) {\n    libp2pConfig.modules.peerDiscovery.push(require('libp2p-bootstrap'));\n  } // Set up Delegate Routing based on the presence of Delegates in the config\n\n\n  const delegateHosts = get(options, 'config.Addresses.Delegates', get(config, 'Addresses.Delegates', []));\n\n  if (delegateHosts.length > 0) {\n    // Pick a random delegate host\n    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];\n    const delegateAddr = new Multiaddr(delegateString).toOptions();\n    const delegateApiOptions = {\n      host: delegateAddr.host,\n      // port is a string atm, so we need to convert for the check\n      // @ts-ignore - parseInt(input:string) => number\n      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',\n      port: delegateAddr.port\n    };\n    const delegateHttpClient = ipfsHttpClient(delegateApiOptions);\n    libp2pOptions.modules.contentRouting = libp2pOptions.modules.contentRouting || [];\n    libp2pOptions.modules.contentRouting.push(new DelegatedContentRouter(peerId, delegateHttpClient));\n    libp2pOptions.modules.peerRouting = libp2pOptions.modules.peerRouting || [];\n    libp2pOptions.modules.peerRouting.push(new DelegatedPeerRouter(delegateHttpClient));\n  }\n\n  return libp2pConfig;\n}","map":{"version":3,"names":["get","require","mergeOptions","bind","ignoreUndefined","errCode","PubsubRouters","DelegatedPeerRouter","DelegatedContentRouter","create","ipfsHttpClient","Multiaddr","pkgversion","version","module","exports","options","peerId","multiaddrs","repo","keychainConfig","config","datastore","keys","libp2pOptions","getLibp2pOptions","libp2p","Libp2p","getPubsubRouter","router","Error","libp2pDefaults","modules","pubsub","contentRouting","peerRouting","peerDiscovery","mdns","enabled","webRTCStar","bootstrap","list","relay","hop","active","dht","clientMode","kBucketSize","nat","addresses","listen","map","ma","toString","announce","noAnnounce","connectionManager","maxConnections","minConnections","keychain","host","agentVersion","getEnvLibp2pOptions","constructorOptions","undefined","libp2pConfig","bootstrapList","length","push","delegateHosts","delegateString","Math","floor","random","delegateAddr","toOptions","delegateApiOptions","protocol","parseInt","port","delegateHttpClient"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/libp2p.js"],"sourcesContent":["'use strict'\n\nconst get = require('dlv')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst errCode = require('err-code')\nconst PubsubRouters = require('../runtime/libp2p-pubsub-routers-nodejs')\n// @ts-ignore - no types\nconst DelegatedPeerRouter = require('libp2p-delegated-peer-routing')\n// @ts-ignore - no types\nconst DelegatedContentRouter = require('libp2p-delegated-content-routing')\nconst { create: ipfsHttpClient } = require('ipfs-http-client')\nconst { Multiaddr } = require('multiaddr')\nconst pkgversion = require('../../package.json').version\n\n/**\n * @typedef {object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {Object} KeychainConfig\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n *\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('libp2p')} LibP2P\n * @typedef {import('libp2p').Libp2pOptions & import('libp2p').CreateOptions} Libp2pOptions\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n */\n\n/**\n * @param {Object} config\n * @param {Repo} config.repo\n * @param {IPFSOptions|undefined} config.options\n * @param {PeerId} config.peerId\n * @param {Multiaddr[]|undefined} config.multiaddrs\n * @param {KeychainConfig|undefined} config.keychainConfig\n * @param {Partial<IPFSConfig>|undefined} config.config\n */\nmodule.exports = ({\n  options = {},\n  peerId,\n  multiaddrs = [],\n  repo,\n  keychainConfig = {},\n  config = {}\n}) => {\n  const { datastore, keys } = repo\n\n  const libp2pOptions = getLibp2pOptions({\n    options,\n    config,\n    datastore,\n    keys,\n    keychainConfig,\n    peerId,\n    multiaddrs\n  })\n\n  if (typeof options.libp2p === 'function') {\n    return options.libp2p({ libp2pOptions, options, config, datastore, peerId })\n  }\n\n  // Required inline to reduce startup time\n  const Libp2p = require('libp2p')\n\n  return Libp2p.create(libp2pOptions)\n}\n\n/**\n * @param {Object} input\n * @param {IPFSOptions} input.options\n * @param {Partial<IPFSConfig>} input.config\n * @param {Repo['datastore']} input.datastore\n * @param {Repo['keys']} input.keys\n * @param {KeychainConfig} input.keychainConfig\n * @param {PeerId} input.peerId\n * @param {Multiaddr[]} input.multiaddrs\n * @returns {Libp2pOptions}\n */\nfunction getLibp2pOptions ({ options, config, datastore, keys, keychainConfig, peerId, multiaddrs }) {\n  const getPubsubRouter = () => {\n    const router = get(config, 'Pubsub.Router') || 'gossipsub'\n\n    // @ts-ignore - `router` value is not constrained\n    if (!PubsubRouters[router]) {\n      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED')\n    }\n\n    // @ts-ignore - `router` value is not constrained\n    return PubsubRouters[router]\n  }\n\n  const libp2pDefaults = {\n    datastore,\n    peerId: peerId,\n    modules: {}\n  }\n\n  const libp2pOptions = {\n    /**\n     * @type {Partial<Libp2pOptions[\"modules\"]>}\n     */\n    modules: {\n      pubsub: getPubsubRouter(),\n      contentRouting: [],\n      peerRouting: []\n    },\n    config: {\n      peerDiscovery: {\n        mdns: {\n          enabled: get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))\n        },\n        webRTCStar: {\n          enabled: get(options, 'config.Discovery.webRTCStar.Enabled', get(config, 'Discovery.webRTCStar.Enabled', true))\n        },\n        bootstrap: {\n          list: get(options, 'config.Bootstrap', get(config, 'Bootstrap', []))\n        }\n      },\n      relay: {\n        enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),\n        hop: {\n          enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),\n          active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))\n        }\n      },\n      dht: {\n        enabled: get(config, 'Routing.Type', 'none') !== 'none',\n        clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',\n        kBucketSize: get(options, 'dht.kBucketSize', 20)\n      },\n      pubsub: {\n        enabled: get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))\n      },\n      nat: {\n        enabled: !get(config, 'Swarm.DisableNatPortMap', false)\n      }\n    },\n    addresses: {\n      listen: multiaddrs.map(ma => ma.toString()),\n      announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', [])),\n      noAnnounce: get(options, 'addresses.noAnnounce', get(config, 'Addresses.NoAnnounce', []))\n    },\n    connectionManager: get(options, 'connectionManager', {\n      maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),\n      minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))\n    }),\n    keychain: {\n      datastore: keys,\n      ...keychainConfig\n    },\n    host: {\n      agentVersion: `js-ipfs/${pkgversion}`\n    }\n  }\n\n  // Required inline to reduce startup time\n  // Note: libp2p-nodejs gets replaced by libp2p-browser when webpacked/browserified\n  const getEnvLibp2pOptions = require('../runtime/libp2p-nodejs')\n\n  /** @type {import('libp2p').Libp2pOptions | undefined} */\n  let constructorOptions = get(options, 'libp2p', undefined)\n\n  if (typeof constructorOptions === 'function') {\n    constructorOptions = undefined\n  }\n\n  // Merge defaults with Node.js/browser/other environments options and configuration\n  const libp2pConfig = mergeOptions(\n    libp2pDefaults,\n    getEnvLibp2pOptions(),\n    libp2pOptions,\n    constructorOptions\n  )\n\n  const bootstrapList = get(libp2pConfig, 'config.peerDiscovery.bootstrap.list', [])\n\n  if (bootstrapList.length > 0) {\n    libp2pConfig.modules.peerDiscovery.push(require('libp2p-bootstrap'))\n  }\n\n  // Set up Delegate Routing based on the presence of Delegates in the config\n  const delegateHosts = get(options, 'config.Addresses.Delegates',\n    get(config, 'Addresses.Delegates', [])\n  )\n\n  if (delegateHosts.length > 0) {\n    // Pick a random delegate host\n    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)]\n    const delegateAddr = new Multiaddr(delegateString).toOptions()\n    const delegateApiOptions = {\n      host: delegateAddr.host,\n      // port is a string atm, so we need to convert for the check\n      // @ts-ignore - parseInt(input:string) => number\n      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',\n      port: delegateAddr.port\n    }\n\n    const delegateHttpClient = ipfsHttpClient(delegateApiOptions)\n\n    libp2pOptions.modules.contentRouting = libp2pOptions.modules.contentRouting || []\n    libp2pOptions.modules.contentRouting.push(new DelegatedContentRouter(peerId, delegateHttpClient))\n\n    libp2pOptions.modules.peerRouting = libp2pOptions.modules.peerRouting || []\n    libp2pOptions.modules.peerRouting.push(new DelegatedPeerRouter(delegateHttpClient))\n  }\n\n  return libp2pConfig\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}