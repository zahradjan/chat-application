{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:webrtc-star');\nlog.error = debug('libp2p:webrtc-star:error');\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar errcode = require('err-code');\n\nvar withIs = require('class-is');\n\nvar _require2 = require('abortable-iterator'),\n    AbortError = _require2.AbortError;\n\nvar SimplePeer = require('libp2p-webrtc-peer');\n\nvar _require3 = require('ipfs-utils/src/supports'),\n    webrtcSupport = _require3.supportsWebRTCDataChannels;\n\nvar _require4 = require('multiaddr'),\n    Multiaddr = _require4.Multiaddr;\n\nvar mafmt = require('mafmt');\n\nvar PeerId = require('peer-id');\n\nvar _require5 = require('./constants'),\n    CODE_CIRCUIT = _require5.CODE_CIRCUIT;\n\nvar _createListener = require('./listener');\n\nvar toConnection = require('./socket-to-conn');\n\nvar _require6 = require('./utils'),\n    cleanMultiaddr = _require6.cleanMultiaddr,\n    cleanUrlSIO = _require6.cleanUrlSIO;\n\nfunction noop() {}\n/**\n * @class WebRTCStar\n */\n\n\nvar WebRTCStar = /*#__PURE__*/function () {\n  /**\n   * @class\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   */\n  function WebRTCStar() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, WebRTCStar);\n\n    if (!options.upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.');\n    }\n\n    this._upgrader = options.upgrader;\n    this.sioOptions = {\n      transports: ['websocket'],\n      'force new connection': true\n    };\n\n    if (options.wrtc) {\n      this.wrtc = options.wrtc;\n    } // Keep Signalling references\n\n\n    this.sigReferences = new Map(); // Discovery\n\n    this.discovery = new EventEmitter();\n    this.discovery.tag = 'webRTCStar';\n    this.discovery._isStarted = false;\n\n    this.discovery.start = function () {\n      _this.discovery._isStarted = true;\n    };\n\n    this.discovery.stop = function () {\n      _this.discovery._isStarted = false;\n    };\n\n    this._peerDiscovered = this._peerDiscovered.bind(this);\n  }\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} options\n   * @param {AbortSignal} options.signal - Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n\n\n  _createClass(WebRTCStar, [{\n    key: \"dial\",\n    value: function () {\n      var _dial = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ma) {\n        var options,\n            rawConn,\n            maConn,\n            conn,\n            _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                _context.next = 3;\n                return this._connect(ma, options);\n\n              case 3:\n                rawConn = _context.sent;\n                maConn = toConnection(rawConn, {\n                  remoteAddr: ma,\n                  signal: options.signal\n                });\n                log('new outbound connection %s', maConn.remoteAddr);\n                _context.next = 8;\n                return this._upgrader.upgradeOutbound(maConn);\n\n              case 8:\n                conn = _context.sent;\n                log('outbound connection %s upgraded', maConn.remoteAddr);\n                return _context.abrupt(\"return\", conn);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function dial(_x) {\n        return _dial.apply(this, arguments);\n      }\n\n      return dial;\n    }()\n    /**\n     * @private\n     * @param {Multiaddr} ma\n     * @param {object} options\n     * @param {AbortSignal} options.signal - Used to abort dial requests\n     * @returns {Promise<SimplePeer>} Resolves a SimplePeer Webrtc channel\n     */\n\n  }, {\n    key: \"_connect\",\n    value: function _connect(ma) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (options.signal && options.signal.aborted) {\n        throw new AbortError();\n      }\n\n      var spOptions = _objectSpread({\n        initiator: true,\n        trickle: false\n      }, options.spOptions || {}); // Use custom WebRTC implementation\n\n\n      if (this.wrtc) {\n        spOptions.wrtc = this.wrtc;\n      }\n\n      var cOpts = ma.toOptions();\n      var intentId = (~~(Math.random() * 1e9)).toString(36) + Date.now();\n      return new Promise(function (resolve, reject) {\n        var sio = _this2.sigReferences.get(cleanUrlSIO(ma));\n\n        if (!sio || !sio.listener) {\n          return reject(errcode(new Error('unknown signal server to use'), 'ERR_UNKNOWN_SIGNAL_SERVER'));\n        }\n\n        var sioClient = sio.listener.io;\n        var start = Date.now();\n        var connected;\n        log('dialing %s:%s', cOpts.host, cOpts.port);\n        var channel = new SimplePeer(spOptions);\n\n        var onError = function onError(err) {\n          if (!connected) {\n            var msg = \"connection error \".concat(cOpts.host, \":\").concat(cOpts.port, \": \").concat(err.message);\n            log.error(msg);\n            done(err);\n          }\n        };\n\n        var onTimeout = function onTimeout() {\n          log('connnection timeout %s:%s', cOpts.host, cOpts.port);\n          var err = errcode(new Error(\"connection timeout after \".concat(Date.now() - start, \"ms\")), 'ERR_CONNECT_TIMEOUT'); // Note: this will result in onError() being called\n\n          channel.emit('error', err);\n        };\n\n        var onConnect = function onConnect() {\n          connected = true;\n          log('connection opened %s:%s', cOpts.host, cOpts.port);\n          done(null);\n        };\n\n        var onAbort = function onAbort() {\n          log.error('connection aborted %s:%s', cOpts.host, cOpts.port);\n          channel.destroy();\n          done(new AbortError());\n        };\n\n        var done = function done(err) {\n          channel.removeListener('timeout', onTimeout);\n          channel.removeListener('connect', onConnect);\n          options.signal && options.signal.removeEventListener('abort', onAbort);\n          err ? reject(err) : resolve(channel);\n        };\n\n        channel.on('error', onError);\n        channel.once('timeout', onTimeout);\n        channel.once('connect', onConnect);\n        channel.on('close', function () {\n          channel.removeListener('error', onError);\n        });\n        options.signal && options.signal.addEventListener('abort', onAbort);\n        channel.on('signal', function (signal) {\n          sioClient.emit('ss-handshake', {\n            intentId: intentId,\n            srcMultiaddr: sio.signallingAddr.toString(),\n            dstMultiaddr: ma.toString(),\n            signal: signal\n          });\n        }); // NOTE: aegir segfaults if we do .once on the socket.io event emitter and we\n        // are clueless as to why.\n\n        sioClient.on('ws-handshake', function (offer) {\n          if (offer.intentId === intentId && offer.err) {\n            channel.destroy();\n            reject(errcode(offer.err instanceof Error ? offer.err : new Error(offer.err), 'ERR_SIGNALLING_FAILED'));\n          }\n\n          if (offer.intentId !== intentId || !offer.answer || channel.destroyed) {\n            return;\n          }\n\n          channel.signal(offer.signal);\n        });\n      });\n    }\n    /**\n     * Creates a WebrtcStar listener. The provided `handler` function will be called\n     * anytime a new incoming Connection has been successfully upgraded via\n     * `upgrader.upgradeInbound`.\n     *\n     * @param {object} [options] - simple-peer options for listener\n     * @param {function (Connection)} handler\n     * @returns {Listener} A WebrtcStar listener\n     */\n\n  }, {\n    key: \"createListener\",\n    value: function createListener() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var handler = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (!webrtcSupport && !this.wrtc) {\n        throw errcode(new Error('no WebRTC support'), 'ERR_NO_WEBRTC_SUPPORT');\n      }\n\n      if (typeof options === 'function') {\n        handler = options;\n        options = {};\n      }\n\n      handler = handler || noop;\n      return _createListener({\n        handler: handler,\n        upgrader: this._upgrader\n      }, this, options);\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid TCP addresses\n     *\n     * @param {Multiaddr[]} multiaddrs\n     * @returns {Multiaddr[]} Valid TCP multiaddrs\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(multiaddrs) {\n      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n      return multiaddrs.filter(function (ma) {\n        if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n          return false;\n        }\n\n        return mafmt.WebRTCStar.matches(ma);\n      });\n    }\n  }, {\n    key: \"_peerDiscovered\",\n    value: function _peerDiscovered(maStr) {\n      if (!this.discovery._isStarted) return;\n      log('Peer Discovered:', maStr);\n      maStr = cleanMultiaddr(maStr);\n      var ma = new Multiaddr(maStr);\n      var peerId = PeerId.createFromB58String(ma.getPeerId());\n      this.discovery.emit('peer', {\n        id: peerId,\n        multiaddrs: [ma]\n      });\n    }\n  }]);\n\n  return WebRTCStar;\n}();\n\nmodule.exports = withIs(WebRTCStar, {\n  className: 'WebRTCStar',\n  symbolName: '@libp2p/js-libp2p-webrtc-star/webrtcstar'\n});","map":{"version":3,"names":["debug","require","log","error","EventEmitter","errcode","withIs","AbortError","SimplePeer","webrtcSupport","supportsWebRTCDataChannels","Multiaddr","mafmt","PeerId","CODE_CIRCUIT","createListener","toConnection","cleanMultiaddr","cleanUrlSIO","noop","WebRTCStar","options","upgrader","Error","_upgrader","sioOptions","transports","wrtc","sigReferences","Map","discovery","tag","_isStarted","start","stop","_peerDiscovered","bind","ma","_connect","rawConn","maConn","remoteAddr","signal","upgradeOutbound","conn","aborted","spOptions","initiator","trickle","cOpts","toOptions","intentId","Math","random","toString","Date","now","Promise","resolve","reject","sio","get","listener","sioClient","io","connected","host","port","channel","onError","err","msg","message","done","onTimeout","emit","onConnect","onAbort","destroy","removeListener","removeEventListener","on","once","addEventListener","srcMultiaddr","signallingAddr","dstMultiaddr","offer","answer","destroyed","handler","multiaddrs","Array","isArray","filter","protoCodes","includes","matches","maStr","peerId","createFromB58String","getPeerId","id","module","exports","className","symbolName"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-webrtc-star/src/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:webrtc-star')\nlog.error = debug('libp2p:webrtc-star:error')\n\nconst { EventEmitter } = require('events')\nconst errcode = require('err-code')\nconst withIs = require('class-is')\n\nconst { AbortError } = require('abortable-iterator')\nconst SimplePeer = require('libp2p-webrtc-peer')\nconst { supportsWebRTCDataChannels: webrtcSupport } = require('ipfs-utils/src/supports')\n\nconst { Multiaddr } = require('multiaddr')\nconst mafmt = require('mafmt')\nconst PeerId = require('peer-id')\n\nconst { CODE_CIRCUIT } = require('./constants')\nconst createListener = require('./listener')\nconst toConnection = require('./socket-to-conn')\nconst { cleanMultiaddr, cleanUrlSIO } = require('./utils')\n\nfunction noop () { }\n\n/**\n * @class WebRTCStar\n */\nclass WebRTCStar {\n  /**\n   * @class\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   */\n  constructor (options = {}) {\n    if (!options.upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.')\n    }\n\n    this._upgrader = options.upgrader\n\n    this.sioOptions = {\n      transports: ['websocket'],\n      'force new connection': true\n    }\n\n    if (options.wrtc) {\n      this.wrtc = options.wrtc\n    }\n\n    // Keep Signalling references\n    this.sigReferences = new Map()\n\n    // Discovery\n    this.discovery = new EventEmitter()\n    this.discovery.tag = 'webRTCStar'\n    this.discovery._isStarted = false\n    this.discovery.start = () => {\n      this.discovery._isStarted = true\n    }\n    this.discovery.stop = () => {\n      this.discovery._isStarted = false\n    }\n    this._peerDiscovered = this._peerDiscovered.bind(this)\n  }\n\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} options\n   * @param {AbortSignal} options.signal - Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n  async dial (ma, options = {}) {\n    const rawConn = await this._connect(ma, options)\n    const maConn = toConnection(rawConn, { remoteAddr: ma, signal: options.signal })\n    log('new outbound connection %s', maConn.remoteAddr)\n    const conn = await this._upgrader.upgradeOutbound(maConn)\n    log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  /**\n   * @private\n   * @param {Multiaddr} ma\n   * @param {object} options\n   * @param {AbortSignal} options.signal - Used to abort dial requests\n   * @returns {Promise<SimplePeer>} Resolves a SimplePeer Webrtc channel\n   */\n  _connect (ma, options = {}) {\n    if (options.signal && options.signal.aborted) {\n      throw new AbortError()\n    }\n\n    const spOptions = {\n      initiator: true,\n      trickle: false,\n      ...options.spOptions || {}\n    }\n\n    // Use custom WebRTC implementation\n    if (this.wrtc) { spOptions.wrtc = this.wrtc }\n\n    const cOpts = ma.toOptions()\n    const intentId = (~~(Math.random() * 1e9)).toString(36) + Date.now()\n\n    return new Promise((resolve, reject) => {\n      const sio = this.sigReferences.get(cleanUrlSIO(ma))\n\n      if (!sio || !sio.listener) {\n        return reject(errcode(new Error('unknown signal server to use'), 'ERR_UNKNOWN_SIGNAL_SERVER'))\n      }\n\n      const sioClient = sio.listener.io\n\n      const start = Date.now()\n      let connected\n\n      log('dialing %s:%s', cOpts.host, cOpts.port)\n      const channel = new SimplePeer(spOptions)\n\n      const onError = (err) => {\n        if (!connected) {\n          const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err.message}`\n          log.error(msg)\n          done(err)\n        }\n      }\n\n      const onTimeout = () => {\n        log('connnection timeout %s:%s', cOpts.host, cOpts.port)\n        const err = errcode(new Error(`connection timeout after ${Date.now() - start}ms`), 'ERR_CONNECT_TIMEOUT')\n        // Note: this will result in onError() being called\n        channel.emit('error', err)\n      }\n\n      const onConnect = () => {\n        connected = true\n\n        log('connection opened %s:%s', cOpts.host, cOpts.port)\n        done(null)\n      }\n\n      const onAbort = () => {\n        log.error('connection aborted %s:%s', cOpts.host, cOpts.port)\n        channel.destroy()\n        done(new AbortError())\n      }\n\n      const done = (err) => {\n        channel.removeListener('timeout', onTimeout)\n        channel.removeListener('connect', onConnect)\n        options.signal && options.signal.removeEventListener('abort', onAbort)\n\n        err ? reject(err) : resolve(channel)\n      }\n\n      channel.on('error', onError)\n      channel.once('timeout', onTimeout)\n      channel.once('connect', onConnect)\n      channel.on('close', () => {\n        channel.removeListener('error', onError)\n      })\n      options.signal && options.signal.addEventListener('abort', onAbort)\n\n      channel.on('signal', (signal) => {\n        sioClient.emit('ss-handshake', {\n          intentId: intentId,\n          srcMultiaddr: sio.signallingAddr.toString(),\n          dstMultiaddr: ma.toString(),\n          signal: signal\n        })\n      })\n\n      // NOTE: aegir segfaults if we do .once on the socket.io event emitter and we\n      // are clueless as to why.\n      sioClient.on('ws-handshake', (offer) => {\n        if (offer.intentId === intentId && offer.err) {\n          channel.destroy()\n          reject(errcode(offer.err instanceof Error ? offer.err : new Error(offer.err), 'ERR_SIGNALLING_FAILED'))\n        }\n\n        if (offer.intentId !== intentId || !offer.answer || channel.destroyed) {\n          return\n        }\n\n        channel.signal(offer.signal)\n      })\n    })\n  }\n\n  /**\n   * Creates a WebrtcStar listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   *\n   * @param {object} [options] - simple-peer options for listener\n   * @param {function (Connection)} handler\n   * @returns {Listener} A WebrtcStar listener\n   */\n  createListener (options = {}, handler) {\n    if (!webrtcSupport && !this.wrtc) {\n      throw errcode(new Error('no WebRTC support'), 'ERR_NO_WEBRTC_SUPPORT')\n    }\n\n    if (typeof options === 'function') {\n      handler = options\n      options = {}\n    }\n\n    handler = handler || noop\n\n    return createListener({ handler, upgrader: this._upgrader }, this, options)\n  }\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid TCP addresses\n   *\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]} Valid TCP multiaddrs\n   */\n  filter (multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    return multiaddrs.filter((ma) => {\n      if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n        return false\n      }\n\n      return mafmt.WebRTCStar.matches(ma)\n    })\n  }\n\n  _peerDiscovered (maStr) {\n    if (!this.discovery._isStarted) return\n\n    log('Peer Discovered:', maStr)\n    maStr = cleanMultiaddr(maStr)\n\n    const ma = new Multiaddr(maStr)\n    const peerId = PeerId.createFromB58String(ma.getPeerId())\n\n    this.discovery.emit('peer', {\n      id: peerId,\n      multiaddrs: [ma]\n    })\n  }\n}\n\nmodule.exports = withIs(WebRTCStar, { className: 'WebRTCStar', symbolName: '@libp2p/js-libp2p-webrtc-star/webrtcstar' })\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}