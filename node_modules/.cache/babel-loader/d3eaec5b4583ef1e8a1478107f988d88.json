{"ast":null,"code":"'use strict';\n/**\n * Enum for Signature Policy\n * Details how message signatures are produced/consumed\n */\n\nvar SignaturePolicy = {\n  /**\n   * On the producing side:\n   * * Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n   *\n   * On the consuming side:\n   * * Enforce the fields to be present, reject otherwise.\n   * * Propagate only if the fields are valid and signature can be verified, reject otherwise.\n   */\n  StrictSign:\n  /** @type {'StrictSign'} */\n  'StrictSign',\n\n  /**\n   * On the producing side:\n   * * Build messages without the signature, key, from and seqno fields.\n   * * The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n   *\n   * On the consuming side:\n   * * Enforce the fields to be absent, reject otherwise.\n   * * Propagate only if the fields are absent, reject otherwise.\n   * * A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n   */\n  StrictNoSign:\n  /** @type {'StrictNoSign'} */\n  'StrictNoSign'\n};\nexports.SignaturePolicy = SignaturePolicy;\n/**\n * @typedef {SignaturePolicy[keyof SignaturePolicy]} SignaturePolicyType\n */","map":{"version":3,"names":["SignaturePolicy","StrictSign","StrictNoSign","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-interfaces/src/pubsub/signature-policy.js"],"sourcesContent":["'use strict'\n\n/**\n * Enum for Signature Policy\n * Details how message signatures are produced/consumed\n */\nconst SignaturePolicy = {\n  /**\n   * On the producing side:\n   * * Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n   *\n   * On the consuming side:\n   * * Enforce the fields to be present, reject otherwise.\n   * * Propagate only if the fields are valid and signature can be verified, reject otherwise.\n   */\n  StrictSign: /** @type {'StrictSign'} */ ('StrictSign'),\n  /**\n   * On the producing side:\n   * * Build messages without the signature, key, from and seqno fields.\n   * * The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n   *\n   * On the consuming side:\n   * * Enforce the fields to be absent, reject otherwise.\n   * * Propagate only if the fields are absent, reject otherwise.\n   * * A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n   */\n  StrictNoSign: /** @type {'StrictNoSign'} */ ('StrictNoSign')\n}\nexports.SignaturePolicy = SignaturePolicy\n\n/**\n * @typedef {SignaturePolicy[keyof SignaturePolicy]} SignaturePolicyType\n */\n"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;;AACA,IAAMA,eAAe,GAAG;EACtB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,UAAU;EAAE;EAA6B,YATnB;;EAUtB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,YAAY;EAAE;EAA+B;AApBvB,CAAxB;AAsBAC,OAAO,CAACH,eAAR,GAA0BA,eAA1B;AAEA;AACA;AACA"},"metadata":{},"sourceType":"script"}