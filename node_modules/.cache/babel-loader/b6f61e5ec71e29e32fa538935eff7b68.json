{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar EventEmitter = require('events');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:webrtc-star:listener');\nlog.error = debug('libp2p:webrtc-star:listener:error');\n\nvar errCode = require('err-code');\n\nvar io = require('socket.io-client');\n\nvar SimplePeer = require('libp2p-webrtc-peer');\n\nvar pDefer = require('p-defer');\n\nvar toConnection = require('./socket-to-conn');\n\nvar _require = require('./utils'),\n    cleanUrlSIO = _require.cleanUrlSIO;\n\nvar _require2 = require('./constants'),\n    CODE_P2P = _require2.CODE_P2P;\n\nvar sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true,\n  path: '/socket.io-next/' // This should be removed when socket.io@2 support is removed\n\n};\n\nmodule.exports = function (_ref, WebRTCStar) {\n  var handler = _ref.handler,\n      upgrader = _ref.upgrader;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var listener = new EventEmitter();\n  var listeningAddr;\n  var signallingUrl;\n  listener.__connections = [];\n  listener.__spChannels = new Map();\n  listener.__pendingIntents = new Map();\n\n  listener.listen = function (ma) {\n    // Should only be used if not already listening\n    if (listeningAddr) {\n      throw errCode(new Error('listener already in use'), 'ERR_ALREADY_LISTENING');\n    }\n\n    var defer = pDefer(); // Should be kept unmodified\n\n    listeningAddr = ma;\n    var signallingAddr;\n\n    if (!ma.protoCodes().includes(CODE_P2P) && upgrader.localPeer) {\n      signallingAddr = ma.encapsulate(\"/p2p/\".concat(upgrader.localPeer.toB58String()));\n    } else {\n      signallingAddr = ma;\n    }\n\n    listener.on('error', function () {\n      return defer.reject();\n    });\n    signallingUrl = cleanUrlSIO(ma);\n    log('Dialing to Signalling Server on: ' + signallingUrl);\n    listener.io = io.connect(signallingUrl, sioOptions);\n\n    var incomingDial = function incomingDial(offer) {\n      if (offer.answer || offer.err || !offer.intentId) {\n        return;\n      }\n\n      var intentId = offer.intentId;\n\n      var pendings = listener.__pendingIntents.get(intentId);\n\n      if (!pendings) {\n        pendings = [];\n\n        listener.__pendingIntents.set(intentId, pendings);\n      }\n\n      var channel = listener.__spChannels.get(intentId);\n\n      if (channel) {\n        channel.signal(offer.signal);\n        return;\n      } else if (offer.signal.type !== 'offer') {\n        pendings.push(offer);\n        return;\n      }\n\n      var spOptions = _objectSpread({\n        trickle: false\n      }, options); // Use custom WebRTC implementation\n\n\n      if (WebRTCStar.wrtc) {\n        spOptions.wrtc = WebRTCStar.wrtc;\n      }\n\n      channel = new SimplePeer(spOptions);\n\n      var onError = function onError(err) {\n        log.error('incoming connection errored', err);\n      };\n\n      channel.on('error', onError);\n      channel.once('close', function () {\n        channel.removeListener('error', onError);\n      });\n      channel.on('signal', function (signal) {\n        offer.signal = signal;\n        offer.answer = true;\n        listener.io.emit('ss-handshake', offer);\n      });\n      channel.signal(offer.signal);\n\n      var _iterator = _createForOfIteratorHelper(pendings),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pendingOffer = _step.value;\n          channel.signal(pendingOffer.signal);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      listener.__pendingIntents.set(intentId, []);\n\n      channel.once('connect', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var maConn, conn;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                maConn = toConnection(channel);\n                log('new inbound connection %s', maConn.remoteAddr);\n                _context.prev = 2;\n                _context.next = 5;\n                return upgrader.upgradeInbound(maConn);\n\n              case 5:\n                conn = _context.sent;\n                _context.next = 12;\n                break;\n\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context[\"catch\"](2);\n                log.error('inbound connection failed to upgrade', _context.t0);\n                return _context.abrupt(\"return\", maConn.close());\n\n              case 12:\n                if (!conn.remoteAddr) {\n                  try {\n                    conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(\"/p2p/\".concat(conn.remotePeer.toB58String()));\n                  } catch (err) {\n                    log.error('could not determine remote address', err);\n                  }\n                }\n\n                log('inbound connection %s upgraded', maConn.remoteAddr);\n                trackConn(listener, maConn, intentId);\n                listener.emit('connection', conn);\n                handler(conn);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 8]]);\n      })));\n\n      listener.__spChannels.set(intentId, channel);\n    };\n\n    listener.io.once('connect_error', function (err) {\n      return defer.reject(err);\n    });\n    listener.io.once('error', function (err) {\n      listener.emit('error', err);\n      listener.emit('close');\n    });\n    listener.io.on('ws-handshake', incomingDial);\n    listener.io.on('ws-peer', WebRTCStar._peerDiscovered);\n    listener.io.on('connect', function () {\n      listener.io.emit('ss-join', signallingAddr.toString());\n    });\n    listener.io.once('connect', function () {\n      listener.emit('listening');\n      defer.resolve();\n    }); // Store listen and signal reference addresses\n\n    WebRTCStar.sigReferences.set(signallingUrl, {\n      listener: listener,\n      signallingAddr: signallingAddr\n    });\n    return defer.promise;\n  };\n\n  listener.close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var ref;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            // Close listener\n            ref = WebRTCStar.sigReferences.get(signallingUrl);\n\n            if (ref && ref.listener.io) {\n              ref.listener.io.emit('ss-leave');\n              ref.listener.io.close();\n            }\n\n            _context2.next = 4;\n            return Promise.all(listener.__connections.map(function (maConn) {\n              return maConn.close();\n            }));\n\n          case 4:\n            listener.emit('close');\n            listener.removeAllListeners(); // Reset state\n\n            listeningAddr = undefined;\n            WebRTCStar.sigReferences.delete(signallingUrl);\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  listener.getAddrs = function () {\n    return [listeningAddr];\n  };\n\n  return listener;\n};\n\nfunction trackConn(listener, maConn, intentId) {\n  listener.__connections.push(maConn);\n\n  var untrackConn = function untrackConn() {\n    listener.__connections = listener.__connections.filter(function (c) {\n      return c !== maConn;\n    });\n\n    listener.__spChannels.delete(intentId);\n\n    listener.__pendingIntents.delete(intentId);\n  };\n\n  maConn.conn.once('close', untrackConn);\n}","map":{"version":3,"names":["EventEmitter","require","debug","log","error","errCode","io","SimplePeer","pDefer","toConnection","cleanUrlSIO","CODE_P2P","sioOptions","transports","path","module","exports","WebRTCStar","handler","upgrader","options","listener","listeningAddr","signallingUrl","__connections","__spChannels","Map","__pendingIntents","listen","ma","Error","defer","signallingAddr","protoCodes","includes","localPeer","encapsulate","toB58String","on","reject","connect","incomingDial","offer","answer","err","intentId","pendings","get","set","channel","signal","type","push","spOptions","trickle","wrtc","onError","once","removeListener","emit","pendingOffer","maConn","remoteAddr","upgradeInbound","conn","close","decapsulateCode","remotePeer","trackConn","_peerDiscovered","toString","resolve","sigReferences","promise","ref","Promise","all","map","removeAllListeners","undefined","delete","getAddrs","untrackConn","filter","c"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-webrtc-star/src/listener.js"],"sourcesContent":["'use strict'\n\nconst EventEmitter = require('events')\nconst debug = require('debug')\nconst log = debug('libp2p:webrtc-star:listener')\nlog.error = debug('libp2p:webrtc-star:listener:error')\n\nconst errCode = require('err-code')\nconst io = require('socket.io-client')\nconst SimplePeer = require('libp2p-webrtc-peer')\nconst pDefer = require('p-defer')\n\nconst toConnection = require('./socket-to-conn')\nconst { cleanUrlSIO } = require('./utils')\nconst { CODE_P2P } = require('./constants')\n\nconst sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true,\n  path: '/socket.io-next/' // This should be removed when socket.io@2 support is removed\n}\n\nmodule.exports = ({ handler, upgrader }, WebRTCStar, options = {}) => {\n  const listener = new EventEmitter()\n  let listeningAddr\n  let signallingUrl\n\n  listener.__connections = []\n  listener.__spChannels = new Map()\n  listener.__pendingIntents = new Map()\n  listener.listen = (ma) => {\n    // Should only be used if not already listening\n    if (listeningAddr) {\n      throw errCode(new Error('listener already in use'), 'ERR_ALREADY_LISTENING')\n    }\n\n    const defer = pDefer()\n\n    // Should be kept unmodified\n    listeningAddr = ma\n\n    let signallingAddr\n    if (!ma.protoCodes().includes(CODE_P2P) && upgrader.localPeer) {\n      signallingAddr = ma.encapsulate(`/p2p/${upgrader.localPeer.toB58String()}`)\n    } else {\n      signallingAddr = ma\n    }\n\n    listener.on('error', () => defer.reject())\n\n    signallingUrl = cleanUrlSIO(ma)\n\n    log('Dialing to Signalling Server on: ' + signallingUrl)\n    listener.io = io.connect(signallingUrl, sioOptions)\n\n    const incomingDial = (offer) => {\n      if (offer.answer || offer.err || !offer.intentId) {\n        return\n      }\n\n      const intentId = offer.intentId\n      let pendings = listener.__pendingIntents.get(intentId)\n      if (!pendings) {\n        pendings = []\n        listener.__pendingIntents.set(intentId, pendings)\n      }\n\n      let channel = listener.__spChannels.get(intentId)\n      if (channel) {\n        channel.signal(offer.signal)\n        return\n      } else if (offer.signal.type !== 'offer') {\n        pendings.push(offer)\n        return\n      }\n\n      const spOptions = {\n        trickle: false,\n        ...options\n      }\n\n      // Use custom WebRTC implementation\n      if (WebRTCStar.wrtc) { spOptions.wrtc = WebRTCStar.wrtc }\n\n      channel = new SimplePeer(spOptions)\n\n      const onError = (err) => {\n        log.error('incoming connection errored', err)\n      }\n\n      channel.on('error', onError)\n      channel.once('close', (...args) => {\n        channel.removeListener('error', onError)\n      })\n\n      channel.on('signal', (signal) => {\n        offer.signal = signal\n        offer.answer = true\n        listener.io.emit('ss-handshake', offer)\n      })\n\n      channel.signal(offer.signal)\n      for (const pendingOffer of pendings) {\n        channel.signal(pendingOffer.signal)\n      }\n      listener.__pendingIntents.set(intentId, [])\n\n      channel.once('connect', async () => {\n        const maConn = toConnection(channel)\n        log('new inbound connection %s', maConn.remoteAddr)\n\n        let conn\n        try {\n          conn = await upgrader.upgradeInbound(maConn)\n        } catch (err) {\n          log.error('inbound connection failed to upgrade', err)\n          return maConn.close()\n        }\n\n        if (!conn.remoteAddr) {\n          try {\n            conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toB58String()}`)\n          } catch (err) {\n            log.error('could not determine remote address', err)\n          }\n        }\n\n        log('inbound connection %s upgraded', maConn.remoteAddr)\n\n        trackConn(listener, maConn, intentId)\n\n        listener.emit('connection', conn)\n        handler(conn)\n      })\n      listener.__spChannels.set(intentId, channel)\n    }\n\n    listener.io.once('connect_error', (err) => defer.reject(err))\n    listener.io.once('error', (err) => {\n      listener.emit('error', err)\n      listener.emit('close')\n    })\n\n    listener.io.on('ws-handshake', incomingDial)\n    listener.io.on('ws-peer', WebRTCStar._peerDiscovered)\n\n    listener.io.on('connect', () => {\n      listener.io.emit('ss-join', signallingAddr.toString())\n    })\n\n    listener.io.once('connect', () => {\n      listener.emit('listening')\n      defer.resolve()\n    })\n\n    // Store listen and signal reference addresses\n    WebRTCStar.sigReferences.set(signallingUrl, {\n      listener,\n      signallingAddr\n    })\n\n    return defer.promise\n  }\n\n  listener.close = async () => {\n    // Close listener\n    const ref = WebRTCStar.sigReferences.get(signallingUrl)\n    if (ref && ref.listener.io) {\n      ref.listener.io.emit('ss-leave')\n      ref.listener.io.close()\n    }\n\n    await Promise.all(listener.__connections.map(maConn => maConn.close()))\n    listener.emit('close')\n    listener.removeAllListeners()\n\n    // Reset state\n    listeningAddr = undefined\n    WebRTCStar.sigReferences.delete(signallingUrl)\n  }\n\n  listener.getAddrs = () => {\n    return [listeningAddr]\n  }\n\n  return listener\n}\n\nfunction trackConn (listener, maConn, intentId) {\n  listener.__connections.push(maConn)\n\n  const untrackConn = () => {\n    listener.__connections = listener.__connections.filter(c => c !== maConn)\n    listener.__spChannels.delete(intentId)\n    listener.__pendingIntents.delete(intentId)\n  }\n\n  maConn.conn.once('close', untrackConn)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}