{"ast":null,"code":"'use strict'; // @ts-ignore\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar KBuck = require('k-bucket');\n\nvar _require = require('uint8arrays/xor'),\n    uint8ArrayXor = _require.xor;\n\nvar GENERATED_PREFIXES = require('./generated-prefix-list.json');\n\nvar _require2 = require('multiformats/hashes/sha2'),\n    sha256 = _require2.sha256;\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar utils = require('../utils');\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('libp2p:dht:routing-table'), {\n  error: debug('libp2p:dht:routing-table:error')\n}); // @ts-ignore\n\nvar length = require('it-length');\n/**\n * @typedef {object} KBucketPeer\n * @property {Uint8Array} id\n * @property {PeerId} peer\n *\n * @typedef {object} KBucket\n * @property {Uint8Array} id\n * @property {KBucketPeer[]} contacts\n * @property {boolean} dontSplit\n * @property {KBucket} left\n * @property {KBucket} right\n *\n * @typedef {object} KBucketTree\n * @property {KBucket} root\n * @property {Uint8Array} localNodeId\n * @property {(event: string, callback: Function) => void} on\n * @property {(key: Uint8Array, count: number) => KBucketPeer[]} closest\n * @property {(key: Uint8Array) => KBucketPeer} closestPeer\n * @property {(key: Uint8Array) => void} remove\n * @property {(peer: KBucketPeer) => void} add\n * @property {() => number} count\n * @property {() => Iterable<KBucket>} toIterable\n */\n\n/**\n * Cannot generate random KadIds longer than this + 1\n */\n\n\nvar MAX_COMMON_PREFIX_LENGTH = 15;\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\n\nvar RoutingTable = /*#__PURE__*/function () {\n  /**\n   * @param {import('../')} dht\n   * @param {object} [options]\n   * @param {number} [options.kBucketSize=20]\n   * @param {number} [options.refreshInterval=30000]\n   */\n  function RoutingTable(dht) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        kBucketSize = _ref.kBucketSize,\n        refreshInterval = _ref.refreshInterval;\n\n    _classCallCheck(this, RoutingTable);\n\n    this.peerId = dht.peerId;\n    this.dht = dht;\n    this._kBucketSize = kBucketSize || 20;\n    this._refreshInterval = refreshInterval || 30000;\n    /** @type {KBucketTree} */\n\n    this.kb = new KBuck({\n      numberOfNodesPerKBucket: this._kBucketSize,\n      numberOfNodesToPing: 1\n    });\n    /** @type {Date[]} */\n\n    this.commonPrefixLengthRefreshedAt = [];\n    this._refreshTable = this._refreshTable.bind(this);\n    this._onPing = this._onPing.bind(this);\n  }\n\n  _createClass(RoutingTable, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return utils.convertPeerId(this.peerId);\n\n              case 2:\n                this.kb.localNodeId = _context.sent;\n                this.kb.on('ping', this._onPing);\n                _context.next = 6;\n                return this._refreshTable(true);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this._refreshTimeoutId) {\n                  clearTimeout(this._refreshTimeoutId);\n                }\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * To speed lookups, we seed the table with random PeerIds. This means\n     * when we are asked to locate a peer on the network, we can find a KadId\n     * that is close to the requested peer ID and query that, then network\n     * peers will tell us who they know who is close to the fake ID\n     *\n     * @param {boolean} [force=false]\n     */\n\n  }, {\n    key: \"_refreshTable\",\n    value: function () {\n      var _refreshTable2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(force) {\n        var _this = this;\n\n        var prefixLength, refreshCpls;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                log('refreshing routing table');\n                prefixLength = this._maxCommonPrefix();\n                refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);\n                log(\"max common prefix length \".concat(prefixLength));\n                log(\"tracked CPLs [ \".concat(refreshCpls.map(function (date) {\n                  return \"\".concat(date.getFullYear(), \"-\").concat((date.getMonth() + 1).toString().padStart(2, '0'), \"-\").concat(date.getDate().toString().padStart(2, '0'), \" \").concat(date.getHours().toString().padStart(2, '0'), \":\").concat(date.getMinutes().toString().padStart(2, '0'), \":\").concat(date.getSeconds().toString().padStart(2, '0'));\n                }).join(', '), \" ]\"));\n                /**\n                 * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n                 * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n                 * is smaller.\n                 *\n                 * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n                 * before a very high max Cpl for which we do have peers in the network.\n                 *\n                 * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n                 * the programmer had paid more attention in the Math classes at university.\n                 *\n                 * So, please be patient and a doc explaining it will be published soon.\n                 *\n                 * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n                 */\n\n                _context4.next = 7;\n                return Promise.all(refreshCpls.map( /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(lastRefresh, index) {\n                    var lastCpl, n;\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            _context3.prev = 0;\n                            _context3.next = 3;\n                            return _this._refreshCommonPrefixLength(index, lastRefresh, force === true);\n\n                          case 3:\n                            if (!(_this._numPeersForCpl(prefixLength) === 0)) {\n                              _context3.next = 18;\n                              break;\n                            }\n\n                            lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);\n                            n = index + 1;\n\n                          case 6:\n                            if (!(n < lastCpl + 1)) {\n                              _context3.next = 18;\n                              break;\n                            }\n\n                            _context3.prev = 7;\n                            _context3.next = 10;\n                            return _this._refreshCommonPrefixLength(n, lastRefresh, force === true);\n\n                          case 10:\n                            _context3.next = 15;\n                            break;\n\n                          case 12:\n                            _context3.prev = 12;\n                            _context3.t0 = _context3[\"catch\"](7);\n                            log.error(_context3.t0);\n\n                          case 15:\n                            n++;\n                            _context3.next = 6;\n                            break;\n\n                          case 18:\n                            _context3.next = 23;\n                            break;\n\n                          case 20:\n                            _context3.prev = 20;\n                            _context3.t1 = _context3[\"catch\"](0);\n                            log.error(_context3.t1);\n\n                          case 23:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3, null, [[0, 20], [7, 12]]);\n                  }));\n\n                  return function (_x2, _x3) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }()));\n\n              case 7:\n                this._refreshTimeoutId = setTimeout(this._refreshTable, this._refreshInterval); // @ts-ignore\n\n                this._refreshTimeoutId.unref();\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _refreshTable(_x) {\n        return _refreshTable2.apply(this, arguments);\n      }\n\n      return _refreshTable;\n    }()\n    /**\n     * @param {number} cpl\n     * @param {Date} lastRefresh\n     * @param {boolean} force\n     */\n\n  }, {\n    key: \"_refreshCommonPrefixLength\",\n    value: function () {\n      var _refreshCommonPrefixLength2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(cpl, lastRefresh, force) {\n        var peerId, peers;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(!force && lastRefresh.getTime() > Date.now() - this._refreshInterval)) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                log(\"not running refresh for cpl \".concat(cpl, \" as time since last refresh not above interval\"));\n                return _context5.abrupt(\"return\");\n\n              case 3:\n                _context5.next = 5;\n                return this._generateRandomPeerId(cpl);\n\n              case 5:\n                peerId = _context5.sent;\n                log(\"starting refreshing cpl \".concat(cpl, \" with key \").concat(peerId.toB58String(), \" (routing table size was \").concat(this.kb.count(), \")\"));\n                _context5.next = 9;\n                return length(this.dht.getClosestPeers(peerId.toBytes(), {}));\n\n              case 9:\n                peers = _context5.sent;\n                log(\"found \".concat(peers, \" peers that were close to imaginary peer \").concat(peerId.toB58String()));\n                log(\"finished refreshing cpl \".concat(cpl, \" with key \").concat(peerId.toB58String(), \" (routing table size was \").concat(this.kb.count(), \")\"));\n\n              case 12:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _refreshCommonPrefixLength(_x4, _x5, _x6) {\n        return _refreshCommonPrefixLength2.apply(this, arguments);\n      }\n\n      return _refreshCommonPrefixLength;\n    }()\n    /**\n     * @param {number} maxCommonPrefix\n     */\n\n  }, {\n    key: \"_getTrackedCommonPrefixLengthsForRefresh\",\n    value: function _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {\n      if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n        maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;\n      }\n\n      var dates = [];\n\n      for (var i = 0; i <= maxCommonPrefix; i++) {\n        // defaults to the zero value if we haven't refreshed it yet.\n        dates[i] = this.commonPrefixLengthRefreshedAt[i] || new Date();\n      }\n\n      return dates;\n    }\n    /**\n     *\n     * @param {number} targetCommonPrefixLength\n     */\n\n  }, {\n    key: \"_generateRandomPeerId\",\n    value: function () {\n      var _generateRandomPeerId2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(targetCommonPrefixLength) {\n        var randomBytes, randomUint16, key;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                randomBytes = crypto.randomBytes(2);\n                randomUint16 = (randomBytes[1] << 8) + randomBytes[0];\n                _context6.next = 4;\n                return this._makePeerId(this.kb.localNodeId, randomUint16, targetCommonPrefixLength);\n\n              case 4:\n                key = _context6.sent;\n                return _context6.abrupt(\"return\", PeerId.createFromBytes(key));\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _generateRandomPeerId(_x7) {\n        return _generateRandomPeerId2.apply(this, arguments);\n      }\n\n      return _generateRandomPeerId;\n    }()\n    /**\n     * @param {Uint8Array} localKadId\n     * @param {number} randomPrefix\n     * @param {number} targetCommonPrefixLength\n     */\n\n  }, {\n    key: \"_makePeerId\",\n    value: function () {\n      var _makePeerId2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(localKadId, randomPrefix, targetCommonPrefixLength) {\n        var view, localPrefix, toggledLocalPrefix, mask, targetPrefix, keyPrefix, keyBuffer, keyView;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Cannot generate peer ID for common prefix length greater than \".concat(MAX_COMMON_PREFIX_LENGTH));\n\n              case 2:\n                view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);\n                localPrefix = view.getUint16(0, false); // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n                // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n                // to our randomly generated prefix.\n\n                toggledLocalPrefix = localPrefix ^ 0x8000 >> targetCommonPrefixLength; // Combine the toggled local prefix and the random bits at the correct offset\n                // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n\n                mask = 65535 << 16 - (targetCommonPrefixLength + 1);\n                targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask; // Convert to a known peer ID.\n\n                keyPrefix = GENERATED_PREFIXES[targetPrefix];\n                keyBuffer = new ArrayBuffer(34);\n                keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);\n                keyView.setUint8(0, sha256.code);\n                keyView.setUint8(1, 32);\n                keyView.setUint32(2, keyPrefix, false);\n                return _context7.abrupt(\"return\", new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength));\n\n              case 14:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function _makePeerId(_x8, _x9, _x10) {\n        return _makePeerId2.apply(this, arguments);\n      }\n\n      return _makePeerId;\n    }()\n    /**\n     * returns the maximum common prefix length between any peer in the table\n     * and the current peer\n     */\n\n  }, {\n    key: \"_maxCommonPrefix\",\n    value: function _maxCommonPrefix() {\n      if (!this.kb.localNodeId) {\n        return 0;\n      } // xor our KadId with every KadId in the k-bucket tree,\n      // return the longest id prefix that is the same\n\n\n      var prefixLength = 0;\n\n      var _iterator = _createForOfIteratorHelper(this._prefixLengths()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _length = _step.value;\n\n          if (_length > prefixLength) {\n            prefixLength = _length;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return prefixLength;\n    }\n    /**\n     * Returns the number of peers in the table with a given prefix length\n     *\n     * @param {number} prefixLength\n     */\n\n  }, {\n    key: \"_numPeersForCpl\",\n    value: function _numPeersForCpl(prefixLength) {\n      var count = 0;\n\n      var _iterator2 = _createForOfIteratorHelper(this._prefixLengths()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _length2 = _step2.value;\n\n          if (_length2 === prefixLength) {\n            count++;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return count;\n    }\n    /**\n     * Yields the common prefix length of every peer in the table\n     */\n\n  }, {\n    key: \"_prefixLengths\",\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime().mark(function _prefixLengths() {\n      var _iterator3, _step3, id, distance, leadingZeros, _iterator4, _step4, byte;\n\n      return _regeneratorRuntime().wrap(function _prefixLengths$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              _iterator3 = _createForOfIteratorHelper(this.kb.toIterable());\n              _context8.prev = 1;\n\n              _iterator3.s();\n\n            case 3:\n              if ((_step3 = _iterator3.n()).done) {\n                _context8.next = 31;\n                break;\n              }\n\n              id = _step3.value.id;\n              distance = uint8ArrayXor(this.kb.localNodeId, id);\n              leadingZeros = 0;\n              _iterator4 = _createForOfIteratorHelper(distance);\n              _context8.prev = 8;\n\n              _iterator4.s();\n\n            case 10:\n              if ((_step4 = _iterator4.n()).done) {\n                _context8.next = 19;\n                break;\n              }\n\n              byte = _step4.value;\n\n              if (!(byte === 0)) {\n                _context8.next = 16;\n                break;\n              }\n\n              leadingZeros++;\n              _context8.next = 17;\n              break;\n\n            case 16:\n              return _context8.abrupt(\"break\", 19);\n\n            case 17:\n              _context8.next = 10;\n              break;\n\n            case 19:\n              _context8.next = 24;\n              break;\n\n            case 21:\n              _context8.prev = 21;\n              _context8.t0 = _context8[\"catch\"](8);\n\n              _iterator4.e(_context8.t0);\n\n            case 24:\n              _context8.prev = 24;\n\n              _iterator4.f();\n\n              return _context8.finish(24);\n\n            case 27:\n              _context8.next = 29;\n              return leadingZeros;\n\n            case 29:\n              _context8.next = 3;\n              break;\n\n            case 31:\n              _context8.next = 36;\n              break;\n\n            case 33:\n              _context8.prev = 33;\n              _context8.t1 = _context8[\"catch\"](1);\n\n              _iterator3.e(_context8.t1);\n\n            case 36:\n              _context8.prev = 36;\n\n              _iterator3.f();\n\n              return _context8.finish(36);\n\n            case 39:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _prefixLengths, this, [[1, 33, 36, 39], [8, 21, 24, 27]]);\n    })\n    /**\n     * Called on the `ping` event from `k-bucket`.\n     * Currently this just removes the oldest contact from\n     * the list, without actually pinging the individual peers.\n     * This is the same as go does, but should probably\n     * be upgraded to actually ping the individual peers.\n     *\n     * @param {KBucketPeer[]} oldContacts\n     * @param {KBucketPeer} newContact\n     */\n\n  }, {\n    key: \"_onPing\",\n    value: function _onPing(oldContacts, newContact) {\n      // just use the first one (k-bucket sorts from oldest to newest)\n      var oldest = oldContacts[0];\n\n      if (oldest) {\n        // remove the oldest one\n        this.kb.remove(oldest.id);\n      } // add the new one\n\n\n      this.kb.add(newContact);\n    } // -- Public Interface\n\n    /**\n     * Amount of currently stored peers.\n     */\n\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.kb.count();\n    }\n    /**\n     * Find a specific peer by id.\n     *\n     * @param {PeerId} peer\n     */\n\n  }, {\n    key: \"find\",\n    value: function () {\n      var _find = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(peer) {\n        var key, closest;\n        return _regeneratorRuntime().wrap(function _callee8$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return utils.convertPeerId(peer);\n\n              case 2:\n                key = _context9.sent;\n                closest = this.closestPeer(key);\n\n                if (!(closest && peer.equals(closest))) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", closest);\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function find(_x11) {\n        return _find.apply(this, arguments);\n      }\n\n      return find;\n    }()\n    /**\n     * Retrieve the closest peers to the given key.\n     *\n     * @param {Uint8Array} key\n     */\n\n  }, {\n    key: \"closestPeer\",\n    value: function closestPeer(key) {\n      var res = this.closestPeers(key, 1);\n\n      if (res.length > 0) {\n        return res[0];\n      }\n    }\n    /**\n     * Retrieve the `count`-closest peers to the given key.\n     *\n     * @param {Uint8Array} key\n     * @param {number} count\n     */\n\n  }, {\n    key: \"closestPeers\",\n    value: function closestPeers(key, count) {\n      var closest = this.kb.closest(key, count);\n      return closest.map(function (p) {\n        return p.peer;\n      });\n    }\n    /**\n     * Add or update the routing table with the given peer.\n     *\n     * @param {PeerId} peer\n     */\n\n  }, {\n    key: \"add\",\n    value: function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(peer) {\n        var id;\n        return _regeneratorRuntime().wrap(function _callee9$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return utils.convertPeerId(peer);\n\n              case 2:\n                id = _context10.sent;\n                this.kb.add({\n                  id: id,\n                  peer: peer\n                });\n\n              case 4:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function add(_x12) {\n        return _add.apply(this, arguments);\n      }\n\n      return add;\n    }()\n    /**\n     * Remove a given peer from the table.\n     *\n     * @param {PeerId} peer\n     */\n\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(peer) {\n        var id;\n        return _regeneratorRuntime().wrap(function _callee10$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return utils.convertPeerId(peer);\n\n              case 2:\n                id = _context11.sent;\n                this.kb.remove(id);\n\n              case 4:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function remove(_x13) {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n  }]);\n\n  return RoutingTable;\n}();\n\nmodule.exports = RoutingTable;","map":{"version":3,"names":["KBuck","require","uint8ArrayXor","xor","GENERATED_PREFIXES","sha256","crypto","PeerId","utils","debug","log","Object","assign","error","length","MAX_COMMON_PREFIX_LENGTH","RoutingTable","dht","kBucketSize","refreshInterval","peerId","_kBucketSize","_refreshInterval","kb","numberOfNodesPerKBucket","numberOfNodesToPing","commonPrefixLengthRefreshedAt","_refreshTable","bind","_onPing","convertPeerId","localNodeId","on","_refreshTimeoutId","clearTimeout","force","prefixLength","_maxCommonPrefix","refreshCpls","_getTrackedCommonPrefixLengthsForRefresh","map","date","getFullYear","getMonth","toString","padStart","getDate","getHours","getMinutes","getSeconds","join","Promise","all","lastRefresh","index","_refreshCommonPrefixLength","_numPeersForCpl","lastCpl","Math","min","n","setTimeout","unref","cpl","getTime","Date","now","_generateRandomPeerId","toB58String","count","getClosestPeers","toBytes","peers","maxCommonPrefix","dates","i","targetCommonPrefixLength","randomBytes","randomUint16","_makePeerId","key","createFromBytes","localKadId","randomPrefix","Error","view","DataView","buffer","byteOffset","byteLength","localPrefix","getUint16","toggledLocalPrefix","mask","targetPrefix","keyPrefix","keyBuffer","ArrayBuffer","keyView","setUint8","code","setUint32","Uint8Array","_prefixLengths","toIterable","id","distance","leadingZeros","byte","oldContacts","newContact","oldest","remove","add","peer","closest","closestPeer","equals","res","closestPeers","p","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-kad-dht/src/routing-table/index.js"],"sourcesContent":["'use strict'\n\n// @ts-ignore\nconst KBuck = require('k-bucket')\nconst { xor: uint8ArrayXor } = require('uint8arrays/xor')\nconst GENERATED_PREFIXES = require('./generated-prefix-list.json')\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst utils = require('../utils')\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:dht:routing-table'), {\n  error: debug('libp2p:dht:routing-table:error')\n})\n// @ts-ignore\nconst length = require('it-length')\n\n/**\n * @typedef {object} KBucketPeer\n * @property {Uint8Array} id\n * @property {PeerId} peer\n *\n * @typedef {object} KBucket\n * @property {Uint8Array} id\n * @property {KBucketPeer[]} contacts\n * @property {boolean} dontSplit\n * @property {KBucket} left\n * @property {KBucket} right\n *\n * @typedef {object} KBucketTree\n * @property {KBucket} root\n * @property {Uint8Array} localNodeId\n * @property {(event: string, callback: Function) => void} on\n * @property {(key: Uint8Array, count: number) => KBucketPeer[]} closest\n * @property {(key: Uint8Array) => KBucketPeer} closestPeer\n * @property {(key: Uint8Array) => void} remove\n * @property {(peer: KBucketPeer) => void} add\n * @property {() => number} count\n * @property {() => Iterable<KBucket>} toIterable\n */\n\n/**\n * Cannot generate random KadIds longer than this + 1\n */\nconst MAX_COMMON_PREFIX_LENGTH = 15\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nclass RoutingTable {\n  /**\n   * @param {import('../')} dht\n   * @param {object} [options]\n   * @param {number} [options.kBucketSize=20]\n   * @param {number} [options.refreshInterval=30000]\n   */\n  constructor (dht, { kBucketSize, refreshInterval } = {}) {\n    this.peerId = dht.peerId\n    this.dht = dht\n    this._kBucketSize = kBucketSize || 20\n    this._refreshInterval = refreshInterval || 30000\n\n    /** @type {KBucketTree} */\n    this.kb = new KBuck({\n      numberOfNodesPerKBucket: this._kBucketSize,\n      numberOfNodesToPing: 1\n    })\n\n    /** @type {Date[]} */\n    this.commonPrefixLengthRefreshedAt = []\n\n    this._refreshTable = this._refreshTable.bind(this)\n    this._onPing = this._onPing.bind(this)\n  }\n\n  async start () {\n    this.kb.localNodeId = await utils.convertPeerId(this.peerId)\n    this.kb.on('ping', this._onPing)\n\n    await this._refreshTable(true)\n  }\n\n  async stop () {\n    if (this._refreshTimeoutId) {\n      clearTimeout(this._refreshTimeoutId)\n    }\n  }\n\n  /**\n   * To speed lookups, we seed the table with random PeerIds. This means\n   * when we are asked to locate a peer on the network, we can find a KadId\n   * that is close to the requested peer ID and query that, then network\n   * peers will tell us who they know who is close to the fake ID\n   *\n   * @param {boolean} [force=false]\n   */\n  async _refreshTable (force) {\n    log('refreshing routing table')\n\n    const prefixLength = this._maxCommonPrefix()\n    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength)\n\n    log(`max common prefix length ${prefixLength}`)\n    log(`tracked CPLs [ ${refreshCpls.map(date => `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`).join(', ')} ]`)\n\n    /**\n     * If we see a gap at a common prefix length in the Routing table, we ONLY refresh up until\n     * the maximum cpl we have in the Routing Table OR (2 * (Cpl+ 1) with the gap), whichever\n     * is smaller.\n     *\n     * This is to prevent refreshes for Cpls that have no peers in the network but happen to be\n     * before a very high max Cpl for which we do have peers in the network.\n     *\n     * The number of 2 * (Cpl + 1) can be proved and a proof would have been written here if\n     * the programmer had paid more attention in the Math classes at university.\n     *\n     * So, please be patient and a doc explaining it will be published soon.\n     *\n     * https://github.com/libp2p/go-libp2p-kad-dht/commit/2851c88acb0a3f86bcfe3cfd0f4604a03db801d8#diff-ad45f4ba97ffbc4083c2eb87a4420c1157057b233f048030d67c6b551855ccf6R219\n     */\n    await Promise.all(\n      refreshCpls.map(async (lastRefresh, index) => {\n        try {\n          await this._refreshCommonPrefixLength(index, lastRefresh, force === true)\n\n          if (this._numPeersForCpl(prefixLength) === 0) {\n            const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1)\n\n            for (let n = index + 1; n < lastCpl + 1; n++) {\n              try {\n                await this._refreshCommonPrefixLength(n, lastRefresh, force === true)\n              } catch (err) {\n                log.error(err)\n              }\n            }\n          }\n        } catch (err) {\n          log.error(err)\n        }\n      })\n    )\n\n    this._refreshTimeoutId = setTimeout(this._refreshTable, this._refreshInterval)\n    // @ts-ignore\n    this._refreshTimeoutId.unref()\n  }\n\n  /**\n   * @param {number} cpl\n   * @param {Date} lastRefresh\n   * @param {boolean} force\n   */\n  async _refreshCommonPrefixLength (cpl, lastRefresh, force) {\n    if (!force && lastRefresh.getTime() > (Date.now() - this._refreshInterval)) {\n      log(`not running refresh for cpl ${cpl} as time since last refresh not above interval`)\n      return\n    }\n\n    // gen a key for the query to refresh the cpl\n    const peerId = await this._generateRandomPeerId(cpl)\n\n    log(`starting refreshing cpl ${cpl} with key ${peerId.toB58String()} (routing table size was ${this.kb.count()})`)\n\n    const peers = await length(this.dht.getClosestPeers(peerId.toBytes(), {}))\n\n    log(`found ${peers} peers that were close to imaginary peer ${peerId.toB58String()}`)\n\n    log(`finished refreshing cpl ${cpl} with key ${peerId.toB58String()} (routing table size was ${this.kb.count()})`)\n  }\n\n  /**\n   * @param {number} maxCommonPrefix\n   */\n  _getTrackedCommonPrefixLengthsForRefresh (maxCommonPrefix) {\n    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {\n      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH\n    }\n\n    const dates = []\n\n    for (let i = 0; i <= maxCommonPrefix; i++) {\n      // defaults to the zero value if we haven't refreshed it yet.\n      dates[i] = this.commonPrefixLengthRefreshedAt[i] || new Date()\n    }\n\n    return dates\n  }\n\n  /**\n   *\n   * @param {number} targetCommonPrefixLength\n   */\n  async _generateRandomPeerId (targetCommonPrefixLength) {\n    const randomBytes = crypto.randomBytes(2)\n    const randomUint16 = (randomBytes[1] << 8) + randomBytes[0]\n\n    const key = await this._makePeerId(this.kb.localNodeId, randomUint16, targetCommonPrefixLength)\n\n    return PeerId.createFromBytes(key)\n  }\n\n  /**\n   * @param {Uint8Array} localKadId\n   * @param {number} randomPrefix\n   * @param {number} targetCommonPrefixLength\n   */\n  async _makePeerId (localKadId, randomPrefix, targetCommonPrefixLength) {\n    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {\n      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`)\n    }\n\n    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength)\n    const localPrefix = view.getUint16(0, false)\n\n    // For host with ID `L`, an ID `K` belongs to a bucket with ID `B` ONLY IF CommonPrefixLen(L,K) is EXACTLY B.\n    // Hence, to achieve a targetPrefix `T`, we must toggle the (T+1)th bit in L & then copy (T+1) bits from L\n    // to our randomly generated prefix.\n    const toggledLocalPrefix = localPrefix ^ (0x8000 >> targetCommonPrefixLength)\n\n    // Combine the toggled local prefix and the random bits at the correct offset\n    // such that ONLY the first `targetCommonPrefixLength` bits match the local ID.\n    const mask = 65535 << (16 - (targetCommonPrefixLength + 1))\n    const targetPrefix = (toggledLocalPrefix & mask) | (randomPrefix & ~mask)\n\n    // Convert to a known peer ID.\n    const keyPrefix = GENERATED_PREFIXES[targetPrefix]\n\n    const keyBuffer = new ArrayBuffer(34)\n    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength)\n    keyView.setUint8(0, sha256.code)\n    keyView.setUint8(1, 32)\n    keyView.setUint32(2, keyPrefix, false)\n\n    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength)\n  }\n\n  /**\n   * returns the maximum common prefix length between any peer in the table\n   * and the current peer\n   */\n  _maxCommonPrefix () {\n    if (!this.kb.localNodeId) {\n      return 0\n    }\n\n    // xor our KadId with every KadId in the k-bucket tree,\n    // return the longest id prefix that is the same\n    let prefixLength = 0\n\n    for (const length of this._prefixLengths()) {\n      if (length > prefixLength) {\n        prefixLength = length\n      }\n    }\n\n    return prefixLength\n  }\n\n  /**\n   * Returns the number of peers in the table with a given prefix length\n   *\n   * @param {number} prefixLength\n   */\n  _numPeersForCpl (prefixLength) {\n    let count = 0\n\n    for (const length of this._prefixLengths()) {\n      if (length === prefixLength) {\n        count++\n      }\n    }\n\n    return count\n  }\n\n  /**\n   * Yields the common prefix length of every peer in the table\n   */\n  * _prefixLengths () {\n    for (const { id } of this.kb.toIterable()) {\n      const distance = uint8ArrayXor(this.kb.localNodeId, id)\n      let leadingZeros = 0\n\n      for (const byte of distance) {\n        if (byte === 0) {\n          leadingZeros++\n        } else {\n          break\n        }\n      }\n\n      yield leadingZeros\n    }\n  }\n\n  /**\n   * Called on the `ping` event from `k-bucket`.\n   * Currently this just removes the oldest contact from\n   * the list, without actually pinging the individual peers.\n   * This is the same as go does, but should probably\n   * be upgraded to actually ping the individual peers.\n   *\n   * @param {KBucketPeer[]} oldContacts\n   * @param {KBucketPeer} newContact\n   */\n  _onPing (oldContacts, newContact) {\n    // just use the first one (k-bucket sorts from oldest to newest)\n    const oldest = oldContacts[0]\n\n    if (oldest) {\n      // remove the oldest one\n      this.kb.remove(oldest.id)\n    }\n\n    // add the new one\n    this.kb.add(newContact)\n  }\n\n  // -- Public Interface\n\n  /**\n   * Amount of currently stored peers.\n   */\n  get size () {\n    return this.kb.count()\n  }\n\n  /**\n   * Find a specific peer by id.\n   *\n   * @param {PeerId} peer\n   */\n  async find (peer) {\n    const key = await utils.convertPeerId(peer)\n    const closest = this.closestPeer(key)\n\n    if (closest && peer.equals(closest)) {\n      return closest\n    }\n  }\n\n  /**\n   * Retrieve the closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   */\n  closestPeer (key) {\n    const res = this.closestPeers(key, 1)\n\n    if (res.length > 0) {\n      return res[0]\n    }\n  }\n\n  /**\n   * Retrieve the `count`-closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   * @param {number} count\n   */\n  closestPeers (key, count) {\n    const closest = this.kb.closest(key, count)\n\n    return closest.map(p => p.peer)\n  }\n\n  /**\n   * Add or update the routing table with the given peer.\n   *\n   * @param {PeerId} peer\n   */\n  async add (peer) {\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.add({ id: id, peer: peer })\n  }\n\n  /**\n   * Remove a given peer from the table.\n   *\n   * @param {PeerId} peer\n   */\n  async remove (peer) {\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.remove(id)\n  }\n}\n\nmodule.exports = RoutingTable\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}