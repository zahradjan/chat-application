{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('libp2p:upgrader'), {\n  error: debug('libp2p:upgrader:err')\n});\n\nvar errCode = require('err-code'); // @ts-ignore multistream-select does not export types\n\n\nvar Multistream = require('multistream-select');\n\nvar _require = require('libp2p-interfaces/src/connection'),\n    Connection = _require.Connection;\n\nvar PeerId = require('peer-id');\n\nvar _require2 = require('it-pipe'),\n    pipe = _require2.pipe; // @ts-ignore mutable-proxy does not export types\n\n\nvar mutableProxy = require('mutable-proxy');\n\nvar _require3 = require('./errors'),\n    codes = _require3.codes;\n/**\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').Muxer} Muxer\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @typedef CryptoResult\n * @property {MultiaddrConnection} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\n\nvar Upgrader = /*#__PURE__*/function () {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {import('./metrics')} [options.metrics]\n   * @param {Map<string, Crypto>} [options.cryptos]\n   * @param {Map<string, MuxerFactory>} [options.muxers]\n   * @param {(connection: Connection) => void} options.onConnection - Called when a connection is upgraded\n   * @param {(connection: Connection) => void} options.onConnectionEnd\n   */\n  function Upgrader(_ref) {\n    var localPeer = _ref.localPeer,\n        metrics = _ref.metrics,\n        _ref$cryptos = _ref.cryptos,\n        cryptos = _ref$cryptos === void 0 ? new Map() : _ref$cryptos,\n        _ref$muxers = _ref.muxers,\n        muxers = _ref$muxers === void 0 ? new Map() : _ref$muxers,\n        _ref$onConnectionEnd = _ref.onConnectionEnd,\n        onConnectionEnd = _ref$onConnectionEnd === void 0 ? function () {} : _ref$onConnectionEnd,\n        _ref$onConnection = _ref.onConnection,\n        onConnection = _ref$onConnection === void 0 ? function () {} : _ref$onConnection;\n\n    _classCallCheck(this, Upgrader);\n\n    this.localPeer = localPeer;\n    this.metrics = metrics;\n    this.cryptos = cryptos;\n    this.muxers = muxers;\n    /** @type {import(\"./pnet\") | null} */\n\n    this.protector = null;\n    this.protocols = new Map();\n    this.onConnection = onConnection;\n    this.onConnectionEnd = onConnectionEnd;\n  }\n  /**\n   * Upgrades an inbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  _createClass(Upgrader, [{\n    key: \"upgradeInbound\",\n    value: function () {\n      var _upgradeInbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(maConn) {\n        var encryptedConn, remotePeer, upgradedConn, Muxer, cryptoProtocol, setPeer, proxyPeer, _mutableProxy, idString, protectedConn, _yield$this$_encryptI, _yield$this$_multiple;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.metrics) {\n                  _mutableProxy = mutableProxy();\n                  setPeer = _mutableProxy.setTarget;\n                  proxyPeer = _mutableProxy.proxy;\n                  idString = (Math.random() * 1e9).toString(36) + Date.now();\n                  setPeer({\n                    toB58String: function toB58String() {\n                      return idString;\n                    }\n                  });\n                  maConn = this.metrics.trackStream({\n                    stream: maConn,\n                    remotePeer: proxyPeer\n                  });\n                }\n\n                log('Starting the inbound connection upgrade'); // Protect\n\n                protectedConn = maConn;\n\n                if (!this.protector) {\n                  _context.next = 7;\n                  break;\n                }\n\n                _context.next = 6;\n                return this.protector.protect(maConn);\n\n              case 6:\n                protectedConn = _context.sent;\n\n              case 7:\n                _context.prev = 7;\n                _context.next = 10;\n                return this._encryptInbound(this.localPeer, protectedConn, this.cryptos);\n\n              case 10:\n                _yield$this$_encryptI = _context.sent;\n                encryptedConn = _yield$this$_encryptI.conn;\n                remotePeer = _yield$this$_encryptI.remotePeer;\n                cryptoProtocol = _yield$this$_encryptI.protocol;\n\n                if (!this.muxers.size) {\n                  _context.next = 22;\n                  break;\n                }\n\n                _context.next = 17;\n                return this._multiplexInbound(encryptedConn, this.muxers);\n\n              case 17:\n                _yield$this$_multiple = _context.sent;\n                upgradedConn = _yield$this$_multiple.stream;\n                Muxer = _yield$this$_multiple.Muxer;\n                _context.next = 23;\n                break;\n\n              case 22:\n                upgradedConn = encryptedConn;\n\n              case 23:\n                _context.next = 31;\n                break;\n\n              case 25:\n                _context.prev = 25;\n                _context.t0 = _context[\"catch\"](7);\n                log.error('Failed to upgrade inbound connection', _context.t0);\n                _context.next = 30;\n                return maConn.close(_context.t0);\n\n              case 30:\n                throw _context.t0;\n\n              case 31:\n                if (this.metrics) {\n                  this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n                  setPeer(remotePeer);\n                }\n\n                log('Successfully upgraded inbound connection');\n                return _context.abrupt(\"return\", this._createConnection({\n                  cryptoProtocol: cryptoProtocol,\n                  direction: 'inbound',\n                  maConn: maConn,\n                  upgradedConn: upgradedConn,\n                  Muxer: Muxer,\n                  remotePeer: remotePeer\n                }));\n\n              case 34:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 25]]);\n      }));\n\n      function upgradeInbound(_x) {\n        return _upgradeInbound.apply(this, arguments);\n      }\n\n      return upgradeInbound;\n    }()\n    /**\n     * Upgrades an outbound connection\n     *\n     * @async\n     * @param {MultiaddrConnection} maConn\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"upgradeOutbound\",\n    value: function () {\n      var _upgradeOutbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(maConn) {\n        var idStr, remotePeerId, encryptedConn, remotePeer, upgradedConn, cryptoProtocol, Muxer, setPeer, proxyPeer, _mutableProxy2, idString, protectedConn, _yield$this$_encryptO, _yield$this$_multiple2;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                idStr = maConn.remoteAddr.getPeerId();\n\n                if (idStr) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR);\n\n              case 3:\n                remotePeerId = PeerId.createFromB58String(idStr);\n\n                if (this.metrics) {\n                  _mutableProxy2 = mutableProxy();\n                  setPeer = _mutableProxy2.setTarget;\n                  proxyPeer = _mutableProxy2.proxy;\n                  idString = (Math.random() * 1e9).toString(36) + Date.now();\n                  setPeer({\n                    toB58String: function toB58String() {\n                      return idString;\n                    }\n                  });\n                  maConn = this.metrics.trackStream({\n                    stream: maConn,\n                    remotePeer: proxyPeer\n                  });\n                }\n\n                log('Starting the outbound connection upgrade'); // Protect\n\n                protectedConn = maConn;\n\n                if (!this.protector) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                _context2.next = 10;\n                return this.protector.protect(maConn);\n\n              case 10:\n                protectedConn = _context2.sent;\n\n              case 11:\n                _context2.prev = 11;\n                _context2.next = 14;\n                return this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos);\n\n              case 14:\n                _yield$this$_encryptO = _context2.sent;\n                encryptedConn = _yield$this$_encryptO.conn;\n                remotePeer = _yield$this$_encryptO.remotePeer;\n                cryptoProtocol = _yield$this$_encryptO.protocol;\n\n                if (!this.muxers.size) {\n                  _context2.next = 26;\n                  break;\n                }\n\n                _context2.next = 21;\n                return this._multiplexOutbound(encryptedConn, this.muxers);\n\n              case 21:\n                _yield$this$_multiple2 = _context2.sent;\n                upgradedConn = _yield$this$_multiple2.stream;\n                Muxer = _yield$this$_multiple2.Muxer;\n                _context2.next = 27;\n                break;\n\n              case 26:\n                upgradedConn = encryptedConn;\n\n              case 27:\n                _context2.next = 35;\n                break;\n\n              case 29:\n                _context2.prev = 29;\n                _context2.t0 = _context2[\"catch\"](11);\n                log.error('Failed to upgrade outbound connection', _context2.t0);\n                _context2.next = 34;\n                return maConn.close(_context2.t0);\n\n              case 34:\n                throw _context2.t0;\n\n              case 35:\n                if (this.metrics) {\n                  this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n                  setPeer(remotePeer);\n                }\n\n                log('Successfully upgraded outbound connection');\n                return _context2.abrupt(\"return\", this._createConnection({\n                  cryptoProtocol: cryptoProtocol,\n                  direction: 'outbound',\n                  maConn: maConn,\n                  upgradedConn: upgradedConn,\n                  Muxer: Muxer,\n                  remotePeer: remotePeer\n                }));\n\n              case 38:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[11, 29]]);\n      }));\n\n      function upgradeOutbound(_x2) {\n        return _upgradeOutbound.apply(this, arguments);\n      }\n\n      return upgradeOutbound;\n    }()\n    /**\n     * A convenience method for generating a new `Connection`\n     *\n     * @private\n     * @param {object} options\n     * @param {string} options.cryptoProtocol - The crypto protocol that was negotiated\n     * @param {'inbound' | 'outbound'} options.direction - One of ['inbound', 'outbound']\n     * @param {MultiaddrConnection} options.maConn - The transport layer connection\n     * @param {MuxedStream | MultiaddrConnection} options.upgradedConn - A duplex connection returned from multiplexer and/or crypto selection\n     * @param {MuxerFactory} [options.Muxer] - The muxer to be used for muxing\n     * @param {PeerId} options.remotePeer - The peer the connection is with\n     * @returns {Connection}\n     */\n\n  }, {\n    key: \"_createConnection\",\n    value: function _createConnection(_ref2) {\n      var _this = this;\n\n      var cryptoProtocol = _ref2.cryptoProtocol,\n          direction = _ref2.direction,\n          maConn = _ref2.maConn,\n          upgradedConn = _ref2.upgradedConn,\n          Muxer = _ref2.Muxer,\n          remotePeer = _ref2.remotePeer;\n\n      /** @type {import(\"libp2p-interfaces/src/stream-muxer/types\").Muxer} */\n      var muxer;\n      /** @type {import(\"libp2p-interfaces/src/connection/connection\").CreatedMuxedStream | undefined} */\n\n      var newStream;\n      /** @type {Connection} */\n\n      var connection; // eslint-disable-line prefer-const\n\n      if (Muxer) {\n        // Create the muxer\n        muxer = new Muxer({\n          // Run anytime a remote stream is created\n          onStream: function () {\n            var _onStream2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(muxedStream) {\n              var mss, _yield$mss$handle, stream, protocol;\n\n              return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      if (connection) {\n                        _context3.next = 2;\n                        break;\n                      }\n\n                      return _context3.abrupt(\"return\");\n\n                    case 2:\n                      mss = new Multistream.Listener(muxedStream);\n                      _context3.prev = 3;\n                      _context3.next = 6;\n                      return mss.handle(Array.from(_this.protocols.keys()));\n\n                    case 6:\n                      _yield$mss$handle = _context3.sent;\n                      stream = _yield$mss$handle.stream;\n                      protocol = _yield$mss$handle.protocol;\n                      log('%s: incoming stream opened on %s', direction, protocol);\n                      if (_this.metrics) _this.metrics.trackStream({\n                        stream: stream,\n                        remotePeer: remotePeer,\n                        protocol: protocol\n                      });\n                      connection.addStream(muxedStream, {\n                        protocol: protocol\n                      });\n\n                      _this._onStream({\n                        connection: connection,\n                        stream: _objectSpread(_objectSpread({}, muxedStream), stream),\n                        protocol: protocol\n                      });\n\n                      _context3.next = 18;\n                      break;\n\n                    case 15:\n                      _context3.prev = 15;\n                      _context3.t0 = _context3[\"catch\"](3);\n                      log.error(_context3.t0);\n\n                    case 18:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3, null, [[3, 15]]);\n            }));\n\n            function onStream(_x3) {\n              return _onStream2.apply(this, arguments);\n            }\n\n            return onStream;\n          }(),\n          // Run anytime a stream closes\n          onStreamEnd: function onStreamEnd(muxedStream) {\n            connection.removeStream(muxedStream.id);\n          }\n        });\n\n        newStream = /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(protocols) {\n            var muxedStream, mss, _yield$mss$select, stream, protocol;\n\n            return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    log('%s: starting new stream on %s', direction, protocols);\n                    muxedStream = muxer.newStream();\n                    mss = new Multistream.Dialer(muxedStream);\n                    _context4.prev = 3;\n                    _context4.next = 6;\n                    return mss.select(protocols);\n\n                  case 6:\n                    _yield$mss$select = _context4.sent;\n                    stream = _yield$mss$select.stream;\n                    protocol = _yield$mss$select.protocol;\n                    if (_this.metrics) _this.metrics.trackStream({\n                      stream: stream,\n                      remotePeer: remotePeer,\n                      protocol: protocol\n                    });\n                    return _context4.abrupt(\"return\", {\n                      stream: _objectSpread(_objectSpread({}, muxedStream), stream),\n                      protocol: protocol\n                    });\n\n                  case 13:\n                    _context4.prev = 13;\n                    _context4.t0 = _context4[\"catch\"](3);\n                    log.error('could not create new stream', _context4.t0);\n                    throw errCode(_context4.t0, codes.ERR_UNSUPPORTED_PROTOCOL);\n\n                  case 17:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4, null, [[3, 13]]);\n          }));\n\n          return function newStream(_x4) {\n            return _ref3.apply(this, arguments);\n          };\n        }(); // Pipe all data through the muxer\n\n\n        pipe(upgradedConn, muxer, upgradedConn).catch(log.error);\n      }\n\n      var _timeline = maConn.timeline;\n      maConn.timeline = new Proxy(_timeline, {\n        set: function set() {\n          if (connection && (arguments.length <= 1 ? undefined : arguments[1]) === 'close' && (arguments.length <= 2 ? undefined : arguments[2]) && !_timeline.close) {\n            // Wait for close to finish before notifying of the closure\n            _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n              return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                while (1) {\n                  switch (_context5.prev = _context5.next) {\n                    case 0:\n                      _context5.prev = 0;\n\n                      if (!(connection.stat.status === 'open')) {\n                        _context5.next = 4;\n                        break;\n                      }\n\n                      _context5.next = 4;\n                      return connection.close();\n\n                    case 4:\n                      _context5.next = 9;\n                      break;\n\n                    case 6:\n                      _context5.prev = 6;\n                      _context5.t0 = _context5[\"catch\"](0);\n                      log.error(_context5.t0);\n\n                    case 9:\n                      _context5.prev = 9;\n\n                      _this.onConnectionEnd(connection);\n\n                      return _context5.finish(9);\n\n                    case 12:\n                    case \"end\":\n                      return _context5.stop();\n                  }\n                }\n              }, _callee5, null, [[0, 6, 9, 12]]);\n            }))();\n          }\n\n          return Reflect.set.apply(Reflect, arguments);\n        }\n      });\n      maConn.timeline.upgraded = Date.now();\n\n      var errConnectionNotMultiplexed = function errConnectionNotMultiplexed() {\n        throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED');\n      }; // Create the connection\n\n\n      connection = new Connection({\n        localAddr: maConn.localAddr,\n        remoteAddr: maConn.remoteAddr,\n        localPeer: this.localPeer,\n        remotePeer: remotePeer,\n        stat: {\n          direction: direction,\n          // @ts-ignore\n          timeline: maConn.timeline,\n          multiplexer: Muxer && Muxer.multicodec,\n          encryption: cryptoProtocol\n        },\n        newStream: newStream || errConnectionNotMultiplexed,\n        getStreams: function getStreams() {\n          return muxer ? muxer.streams : errConnectionNotMultiplexed();\n        },\n        close: function () {\n          var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n            return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n              while (1) {\n                switch (_context6.prev = _context6.next) {\n                  case 0:\n                    _context6.next = 2;\n                    return maConn.close();\n\n                  case 2:\n                    // Ensure remaining streams are aborted\n                    if (muxer) {\n                      muxer.streams.map(function (stream) {\n                        return stream.abort();\n                      });\n                    }\n\n                  case 3:\n                  case \"end\":\n                    return _context6.stop();\n                }\n              }\n            }, _callee6);\n          }));\n\n          function close() {\n            return _close.apply(this, arguments);\n          }\n\n          return close;\n        }()\n      });\n      this.onConnection(connection);\n      return connection;\n    }\n    /**\n     * Routes incoming streams to the correct handler\n     *\n     * @private\n     * @param {object} options\n     * @param {Connection} options.connection - The connection the stream belongs to\n     * @param {MuxedStream} options.stream\n     * @param {string} options.protocol\n     */\n\n  }, {\n    key: \"_onStream\",\n    value: function _onStream(_ref5) {\n      var connection = _ref5.connection,\n          stream = _ref5.stream,\n          protocol = _ref5.protocol;\n      var handler = this.protocols.get(protocol);\n      handler({\n        connection: connection,\n        stream: stream,\n        protocol: protocol\n      });\n    }\n    /**\n     * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n     *\n     * @private\n     * @async\n     * @param {PeerId} localPeer - The initiators PeerId\n     * @param {*} connection\n     * @param {Map<string, Crypto>} cryptos\n     * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n     */\n\n  }, {\n    key: \"_encryptInbound\",\n    value: function () {\n      var _encryptInbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(localPeer, connection, cryptos) {\n        var mss, protocols, _yield$mss$handle2, stream, protocol, crypto;\n\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                mss = new Multistream.Listener(connection);\n                protocols = Array.from(cryptos.keys());\n                log('handling inbound crypto protocol selection', protocols);\n                _context7.prev = 3;\n                _context7.next = 6;\n                return mss.handle(protocols);\n\n              case 6:\n                _yield$mss$handle2 = _context7.sent;\n                stream = _yield$mss$handle2.stream;\n                protocol = _yield$mss$handle2.protocol;\n                crypto = cryptos.get(protocol);\n                log('encrypting inbound connection...');\n\n                if (crypto) {\n                  _context7.next = 13;\n                  break;\n                }\n\n                throw new Error(\"no crypto module found for \".concat(protocol));\n\n              case 13:\n                _context7.t0 = _objectSpread;\n                _context7.t1 = _objectSpread;\n                _context7.t2 = {};\n                _context7.next = 18;\n                return crypto.secureInbound(localPeer, stream);\n\n              case 18:\n                _context7.t3 = _context7.sent;\n                _context7.t4 = (0, _context7.t1)(_context7.t2, _context7.t3);\n                _context7.t5 = {};\n                _context7.t6 = {\n                  protocol: protocol\n                };\n                return _context7.abrupt(\"return\", (0, _context7.t0)(_context7.t4, _context7.t5, _context7.t6));\n\n              case 25:\n                _context7.prev = 25;\n                _context7.t7 = _context7[\"catch\"](3);\n                throw errCode(_context7.t7, codes.ERR_ENCRYPTION_FAILED);\n\n              case 28:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, null, [[3, 25]]);\n      }));\n\n      function _encryptInbound(_x5, _x6, _x7) {\n        return _encryptInbound2.apply(this, arguments);\n      }\n\n      return _encryptInbound;\n    }()\n    /**\n     * Attempts to encrypt the given `connection` with the provided `cryptos`.\n     * The first `Crypto` module to succeed will be used\n     *\n     * @private\n     * @async\n     * @param {PeerId} localPeer - The initiators PeerId\n     * @param {MultiaddrConnection} connection\n     * @param {PeerId} remotePeerId\n     * @param {Map<string, Crypto>} cryptos\n     * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n     */\n\n  }, {\n    key: \"_encryptOutbound\",\n    value: function () {\n      var _encryptOutbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(localPeer, connection, remotePeerId, cryptos) {\n        var mss, protocols, _yield$mss$select2, stream, protocol, crypto;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                mss = new Multistream.Dialer(connection);\n                protocols = Array.from(cryptos.keys());\n                log('selecting outbound crypto protocol', protocols);\n                _context8.prev = 3;\n                _context8.next = 6;\n                return mss.select(protocols);\n\n              case 6:\n                _yield$mss$select2 = _context8.sent;\n                stream = _yield$mss$select2.stream;\n                protocol = _yield$mss$select2.protocol;\n                crypto = cryptos.get(protocol);\n                log('encrypting outbound connection to %j', remotePeerId);\n\n                if (crypto) {\n                  _context8.next = 13;\n                  break;\n                }\n\n                throw new Error(\"no crypto module found for \".concat(protocol));\n\n              case 13:\n                _context8.t0 = _objectSpread;\n                _context8.t1 = _objectSpread;\n                _context8.t2 = {};\n                _context8.next = 18;\n                return crypto.secureOutbound(localPeer, stream, remotePeerId);\n\n              case 18:\n                _context8.t3 = _context8.sent;\n                _context8.t4 = (0, _context8.t1)(_context8.t2, _context8.t3);\n                _context8.t5 = {};\n                _context8.t6 = {\n                  protocol: protocol\n                };\n                return _context8.abrupt(\"return\", (0, _context8.t0)(_context8.t4, _context8.t5, _context8.t6));\n\n              case 25:\n                _context8.prev = 25;\n                _context8.t7 = _context8[\"catch\"](3);\n                throw errCode(_context8.t7, codes.ERR_ENCRYPTION_FAILED);\n\n              case 28:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, null, [[3, 25]]);\n      }));\n\n      function _encryptOutbound(_x8, _x9, _x10, _x11) {\n        return _encryptOutbound2.apply(this, arguments);\n      }\n\n      return _encryptOutbound;\n    }()\n    /**\n     * Selects one of the given muxers via multistream-select. That\n     * muxer will be used for all future streams on the connection.\n     *\n     * @private\n     * @async\n     * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n     * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n     * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n     */\n\n  }, {\n    key: \"_multiplexOutbound\",\n    value: function () {\n      var _multiplexOutbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(connection, muxers) {\n        var dialer, protocols, _yield$dialer$select, stream, protocol, Muxer;\n\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                dialer = new Multistream.Dialer(connection);\n                protocols = Array.from(muxers.keys());\n                log('outbound selecting muxer %s', protocols);\n                _context9.prev = 3;\n                _context9.next = 6;\n                return dialer.select(protocols);\n\n              case 6:\n                _yield$dialer$select = _context9.sent;\n                stream = _yield$dialer$select.stream;\n                protocol = _yield$dialer$select.protocol;\n                log('%s selected as muxer protocol', protocol);\n                Muxer = muxers.get(protocol);\n                return _context9.abrupt(\"return\", {\n                  stream: stream,\n                  Muxer: Muxer\n                });\n\n              case 14:\n                _context9.prev = 14;\n                _context9.t0 = _context9[\"catch\"](3);\n                throw errCode(_context9.t0, codes.ERR_MUXER_UNAVAILABLE);\n\n              case 17:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, null, [[3, 14]]);\n      }));\n\n      function _multiplexOutbound(_x12, _x13) {\n        return _multiplexOutbound2.apply(this, arguments);\n      }\n\n      return _multiplexOutbound;\n    }()\n    /**\n     * Registers support for one of the given muxers via multistream-select. The\n     * selected muxer will be used for all future streams on the connection.\n     *\n     * @private\n     * @async\n     * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n     * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n     * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n     */\n\n  }, {\n    key: \"_multiplexInbound\",\n    value: function () {\n      var _multiplexInbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(connection, muxers) {\n        var listener, protocols, _yield$listener$handl, stream, protocol, Muxer;\n\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                listener = new Multistream.Listener(connection);\n                protocols = Array.from(muxers.keys());\n                log('inbound handling muxers %s', protocols);\n                _context10.prev = 3;\n                _context10.next = 6;\n                return listener.handle(protocols);\n\n              case 6:\n                _yield$listener$handl = _context10.sent;\n                stream = _yield$listener$handl.stream;\n                protocol = _yield$listener$handl.protocol;\n                Muxer = muxers.get(protocol);\n                return _context10.abrupt(\"return\", {\n                  stream: stream,\n                  Muxer: Muxer\n                });\n\n              case 13:\n                _context10.prev = 13;\n                _context10.t0 = _context10[\"catch\"](3);\n                throw errCode(_context10.t0, codes.ERR_MUXER_UNAVAILABLE);\n\n              case 16:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, null, [[3, 13]]);\n      }));\n\n      function _multiplexInbound(_x14, _x15) {\n        return _multiplexInbound2.apply(this, arguments);\n      }\n\n      return _multiplexInbound;\n    }()\n  }]);\n\n  return Upgrader;\n}();\n\nmodule.exports = Upgrader;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errCode","Multistream","Connection","PeerId","pipe","mutableProxy","codes","Upgrader","localPeer","metrics","cryptos","Map","muxers","onConnectionEnd","onConnection","protector","protocols","maConn","setPeer","setTarget","proxyPeer","proxy","idString","Math","random","toString","Date","now","toB58String","trackStream","stream","remotePeer","protectedConn","protect","_encryptInbound","encryptedConn","conn","cryptoProtocol","protocol","size","_multiplexInbound","upgradedConn","Muxer","close","updatePlaceholder","_createConnection","direction","idStr","remoteAddr","getPeerId","Error","ERR_INVALID_MULTIADDR","remotePeerId","createFromB58String","_encryptOutbound","_multiplexOutbound","muxer","newStream","connection","onStream","muxedStream","mss","Listener","handle","Array","from","keys","addStream","_onStream","onStreamEnd","removeStream","id","Dialer","select","ERR_UNSUPPORTED_PROTOCOL","catch","_timeline","timeline","Proxy","set","stat","status","Reflect","upgraded","errConnectionNotMultiplexed","localAddr","multiplexer","multicodec","encryption","getStreams","streams","map","abort","handler","get","crypto","secureInbound","ERR_ENCRYPTION_FAILED","secureOutbound","dialer","ERR_MUXER_UNAVAILABLE","listener","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/upgrader.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:upgrader'), {\n  error: debug('libp2p:upgrader:err')\n})\nconst errCode = require('err-code')\n// @ts-ignore multistream-select does not export types\nconst Multistream = require('multistream-select')\nconst { Connection } = require('libp2p-interfaces/src/connection')\nconst PeerId = require('peer-id')\nconst { pipe } = require('it-pipe')\n// @ts-ignore mutable-proxy does not export types\nconst mutableProxy = require('mutable-proxy')\n\nconst { codes } = require('./errors')\n\n/**\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').Muxer} Muxer\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @typedef CryptoResult\n * @property {MultiaddrConnection} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {import('./metrics')} [options.metrics]\n   * @param {Map<string, Crypto>} [options.cryptos]\n   * @param {Map<string, MuxerFactory>} [options.muxers]\n   * @param {(connection: Connection) => void} options.onConnection - Called when a connection is upgraded\n   * @param {(connection: Connection) => void} options.onConnectionEnd\n   */\n  constructor ({\n    localPeer,\n    metrics,\n    cryptos = new Map(),\n    muxers = new Map(),\n    onConnectionEnd = () => {},\n    onConnection = () => {}\n  }) {\n    this.localPeer = localPeer\n    this.metrics = metrics\n    this.cryptos = cryptos\n    this.muxers = muxers\n    /** @type {import(\"./pnet\") | null} */\n    this.protector = null\n    this.protocols = new Map()\n    this.onConnection = onConnection\n    this.onConnectionEnd = onConnectionEnd\n  }\n\n  /**\n   * Upgrades an inbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeInbound (maConn) {\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let Muxer\n    let cryptoProtocol\n    let setPeer\n    let proxyPeer\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (Math.random() * 1e9).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the inbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos))\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexInbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (err) {\n      log.error('Failed to upgrade inbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded inbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'inbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * Upgrades an outbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeOutbound (maConn) {\n    const idStr = maConn.remoteAddr.getPeerId()\n    if (!idStr) {\n      throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR)\n    }\n\n    const remotePeerId = PeerId.createFromB58String(idStr)\n\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let cryptoProtocol\n    let Muxer\n    let setPeer\n    let proxyPeer\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (Math.random() * 1e9).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the outbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos))\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexOutbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (err) {\n      log.error('Failed to upgrade outbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded outbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {string} options.cryptoProtocol - The crypto protocol that was negotiated\n   * @param {'inbound' | 'outbound'} options.direction - One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} options.maConn - The transport layer connection\n   * @param {MuxedStream | MultiaddrConnection} options.upgradedConn - A duplex connection returned from multiplexer and/or crypto selection\n   * @param {MuxerFactory} [options.Muxer] - The muxer to be used for muxing\n   * @param {PeerId} options.remotePeer - The peer the connection is with\n   * @returns {Connection}\n   */\n  _createConnection ({\n    cryptoProtocol,\n    direction,\n    maConn,\n    upgradedConn,\n    Muxer,\n    remotePeer\n  }) {\n    /** @type {import(\"libp2p-interfaces/src/stream-muxer/types\").Muxer} */\n    let muxer\n    /** @type {import(\"libp2p-interfaces/src/connection/connection\").CreatedMuxedStream | undefined} */\n    let newStream\n    /** @type {Connection} */\n    let connection // eslint-disable-line prefer-const\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: async muxedStream => {\n          if (!connection) return\n          const mss = new Multistream.Listener(muxedStream)\n          try {\n            const { stream, protocol } = await mss.handle(Array.from(this.protocols.keys()))\n            log('%s: incoming stream opened on %s', direction, protocol)\n            if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n            connection.addStream(muxedStream, { protocol })\n            this._onStream({ connection, stream: { ...muxedStream, ...stream }, protocol })\n          } catch (err) {\n            log.error(err)\n          }\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id)\n        }\n      })\n\n      newStream = async (protocols) => {\n        log('%s: starting new stream on %s', direction, protocols)\n        const muxedStream = muxer.newStream()\n        const mss = new Multistream.Dialer(muxedStream)\n        try {\n          const { stream, protocol } = await mss.select(protocols)\n          if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n          return { stream: { ...muxedStream, ...stream }, protocol }\n        } catch (err) {\n          log.error('could not create new stream', err)\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL)\n        }\n      }\n\n      // Pipe all data through the muxer\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error)\n    }\n\n    const _timeline = maConn.timeline\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection && args[1] === 'close' && args[2] && !_timeline.close) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.stat.status === 'open') {\n                await connection.close()\n              }\n            } catch (err) {\n              log.error(err)\n            } finally {\n              this.onConnectionEnd(connection)\n            }\n          })()\n        }\n\n        return Reflect.set(...args)\n      }\n    })\n    maConn.timeline.upgraded = Date.now()\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED')\n    }\n\n    // Create the connection\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        // @ts-ignore\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed(),\n      close: async () => {\n        await maConn.close()\n        // Ensure remaining streams are aborted\n        if (muxer) {\n          muxer.streams.map(stream => stream.abort())\n        }\n      }\n    })\n\n    this.onConnection(connection)\n\n    return connection\n  }\n\n  /**\n   * Routes incoming streams to the correct handler\n   *\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection - The connection the stream belongs to\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   */\n  _onStream ({ connection, stream, protocol }) {\n    const handler = this.protocols.get(protocol)\n    handler({ connection, stream, protocol })\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptInbound (localPeer, connection, cryptos) {\n    const mss = new Multistream.Listener(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('handling inbound crypto protocol selection', protocols)\n\n    try {\n      const { stream, protocol } = await mss.handle(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting inbound connection...')\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      return {\n        ...await crypto.secureInbound(localPeer, stream),\n        protocol\n      }\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {MultiaddrConnection} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptOutbound (localPeer, connection, remotePeerId, cryptos) {\n    const mss = new Multistream.Dialer(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('selecting outbound crypto protocol', protocols)\n\n    try {\n      const { stream, protocol } = await mss.select(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting outbound connection to %j', remotePeerId)\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      return {\n        ...await crypto.secureOutbound(localPeer, stream, remotePeerId),\n        protocol\n      }\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n  async _multiplexOutbound (connection, muxers) {\n    const dialer = new Multistream.Dialer(connection)\n    const protocols = Array.from(muxers.keys())\n    log('outbound selecting muxer %s', protocols)\n    try {\n      const { stream, protocol } = await dialer.select(protocols)\n      log('%s selected as muxer protocol', protocol)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n  async _multiplexInbound (connection, muxers) {\n    const listener = new Multistream.Listener(connection)\n    const protocols = Array.from(muxers.keys())\n    log('inbound handling muxers %s', protocols)\n    try {\n      const { stream, protocol } = await listener.handle(protocols)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n}\n\nmodule.exports = Upgrader\n"],"mappings":"AAAA;;;;;;;;;;;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAMC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcJ,KAAK,CAAC,iBAAD,CAAnB,EAAwC;EAClDK,KAAK,EAAEL,KAAK,CAAC,qBAAD;AADsC,CAAxC,CAAZ;;AAGA,IAAMM,OAAO,GAAGL,OAAO,CAAC,UAAD,CAAvB,C,CACA;;;AACA,IAAMM,WAAW,GAAGN,OAAO,CAAC,oBAAD,CAA3B;;AACA,eAAuBA,OAAO,CAAC,kCAAD,CAA9B;AAAA,IAAQO,UAAR,YAAQA,UAAR;;AACA,IAAMC,MAAM,GAAGR,OAAO,CAAC,SAAD,CAAtB;;AACA,gBAAiBA,OAAO,CAAC,SAAD,CAAxB;AAAA,IAAQS,IAAR,aAAQA,IAAR,C,CACA;;;AACA,IAAMC,YAAY,GAAGV,OAAO,CAAC,eAAD,CAA5B;;AAEA,gBAAkBA,OAAO,CAAC,UAAD,CAAzB;AAAA,IAAQW,KAAR,aAAQA,KAAR;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;IAEMC,Q;EACJ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,wBAOG;IAAA,IANDC,SAMC,QANDA,SAMC;IAAA,IALDC,OAKC,QALDA,OAKC;IAAA,wBAJDC,OAIC;IAAA,IAJDA,OAIC,6BAJS,IAAIC,GAAJ,EAIT;IAAA,uBAHDC,MAGC;IAAA,IAHDA,MAGC,4BAHQ,IAAID,GAAJ,EAGR;IAAA,gCAFDE,eAEC;IAAA,IAFDA,eAEC,qCAFiB,YAAM,CAAE,CAEzB;IAAA,6BADDC,YACC;IAAA,IADDA,YACC,kCADc,YAAM,CAAE,CACtB;;IAAA;;IACD,KAAKN,SAAL,GAAiBA,SAAjB;IACA,KAAKC,OAAL,GAAeA,OAAf;IACA,KAAKC,OAAL,GAAeA,OAAf;IACA,KAAKE,MAAL,GAAcA,MAAd;IACA;;IACA,KAAKG,SAAL,GAAiB,IAAjB;IACA,KAAKC,SAAL,GAAiB,IAAIL,GAAJ,EAAjB;IACA,KAAKG,YAAL,GAAoBA,YAApB;IACA,KAAKD,eAAL,GAAuBA,eAAvB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;;;uFACE,iBAAsBI,MAAtB;QAAA;;QAAA;UAAA;YAAA;cAAA;gBASE,IAAI,KAAKR,OAAT,EAAkB;kBAAA,gBAC4BJ,YAAY,EADxC;kBACFa,OADE,iBACbC,SADa;kBACcC,SADd,iBACOC,KADP;kBAEVC,QAFU,GAEC,CAACC,IAAI,CAACC,MAAL,KAAgB,GAAjB,EAAsBC,QAAtB,CAA+B,EAA/B,IAAqCC,IAAI,CAACC,GAAL,EAFtC;kBAGhBT,OAAO,CAAC;oBAAEU,WAAW,EAAE;sBAAA,OAAMN,QAAN;oBAAA;kBAAf,CAAD,CAAP;kBACAL,MAAM,GAAG,KAAKR,OAAL,CAAaoB,WAAb,CAAyB;oBAAEC,MAAM,EAAEb,MAAV;oBAAkBc,UAAU,EAAEX;kBAA9B,CAAzB,CAAT;gBACD;;gBAEDxB,GAAG,CAAC,yCAAD,CAAH,CAhBF,CAkBE;;gBACIoC,aAnBN,GAmBsBf,MAnBtB;;gBAAA,KAoBM,KAAKF,SApBX;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAqB0B,KAAKA,SAAL,CAAekB,OAAf,CAAuBhB,MAAvB,CArB1B;;cAAA;gBAqBIe,aArBJ;;cAAA;gBAAA;gBAAA;gBAAA,OA8Bc,KAAKE,eAAL,CAAqB,KAAK1B,SAA1B,EAAqCwB,aAArC,EAAoD,KAAKtB,OAAzD,CA9Bd;;cAAA;gBAAA;gBA2BYyB,aA3BZ,yBA2BMC,IA3BN;gBA4BML,UA5BN,yBA4BMA,UA5BN;gBA6BgBM,cA7BhB,yBA6BMC,QA7BN;;gBAAA,KAiCQ,KAAK1B,MAAL,CAAY2B,IAjCpB;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAkC+C,KAAKC,iBAAL,CAAuBL,aAAvB,EAAsC,KAAKvB,MAA3C,CAlC/C;;cAAA;gBAAA;gBAkCiB6B,YAlCjB,yBAkCSX,MAlCT;gBAkC+BY,KAlC/B,yBAkC+BA,KAlC/B;gBAAA;gBAAA;;cAAA;gBAoCMD,YAAY,GAAGN,aAAf;;cApCN;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBAuCIvC,GAAG,CAACG,KAAJ,CAAU,sCAAV;gBAvCJ;gBAAA,OAwCUkB,MAAM,CAAC0B,KAAP,aAxCV;;cAAA;gBAAA;;cAAA;gBA4CE,IAAI,KAAKlC,OAAT,EAAkB;kBAChB,KAAKA,OAAL,CAAamC,iBAAb,CAA+BxB,SAA/B,EAA0CW,UAA1C;kBACAb,OAAO,CAACa,UAAD,CAAP;gBACD;;gBAEDnC,GAAG,CAAC,0CAAD,CAAH;gBAjDF,iCAmDS,KAAKiD,iBAAL,CAAuB;kBAC5BR,cAAc,EAAdA,cAD4B;kBAE5BS,SAAS,EAAE,SAFiB;kBAG5B7B,MAAM,EAANA,MAH4B;kBAI5BwB,YAAY,EAAZA,YAJ4B;kBAK5BC,KAAK,EAALA,KAL4B;kBAM5BX,UAAU,EAAVA;gBAN4B,CAAvB,CAnDT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IA6DA;AACF;AACA;AACA;AACA;AACA;AACA;;;;;wFACE,kBAAuBd,MAAvB;QAAA;;QAAA;UAAA;YAAA;cAAA;gBACQ8B,KADR,GACgB9B,MAAM,CAAC+B,UAAP,CAAkBC,SAAlB,EADhB;;gBAAA,IAEOF,KAFP;kBAAA;kBAAA;gBAAA;;gBAAA,MAGU/C,OAAO,CAAC,IAAIkD,KAAJ,CAAU,yCAAV,CAAD,EAAuD5C,KAAK,CAAC6C,qBAA7D,CAHjB;;cAAA;gBAMQC,YANR,GAMuBjD,MAAM,CAACkD,mBAAP,CAA2BN,KAA3B,CANvB;;gBAgBE,IAAI,KAAKtC,OAAT,EAAkB;kBAAA,iBAC4BJ,YAAY,EADxC;kBACFa,OADE,kBACbC,SADa;kBACcC,SADd,kBACOC,KADP;kBAEVC,QAFU,GAEC,CAACC,IAAI,CAACC,MAAL,KAAgB,GAAjB,EAAsBC,QAAtB,CAA+B,EAA/B,IAAqCC,IAAI,CAACC,GAAL,EAFtC;kBAGhBT,OAAO,CAAC;oBAAEU,WAAW,EAAE;sBAAA,OAAMN,QAAN;oBAAA;kBAAf,CAAD,CAAP;kBACAL,MAAM,GAAG,KAAKR,OAAL,CAAaoB,WAAb,CAAyB;oBAAEC,MAAM,EAAEb,MAAV;oBAAkBc,UAAU,EAAEX;kBAA9B,CAAzB,CAAT;gBACD;;gBAEDxB,GAAG,CAAC,0CAAD,CAAH,CAvBF,CAyBE;;gBACIoC,aA1BN,GA0BsBf,MA1BtB;;gBAAA,KA2BM,KAAKF,SA3BX;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OA4B0B,KAAKA,SAAL,CAAekB,OAAf,CAAuBhB,MAAvB,CA5B1B;;cAAA;gBA4BIe,aA5BJ;;cAAA;gBAAA;gBAAA;gBAAA,OAqCc,KAAKsB,gBAAL,CAAsB,KAAK9C,SAA3B,EAAsCwB,aAAtC,EAAqDoB,YAArD,EAAmE,KAAK1C,OAAxE,CArCd;;cAAA;gBAAA;gBAkCYyB,aAlCZ,yBAkCMC,IAlCN;gBAmCML,UAnCN,yBAmCMA,UAnCN;gBAoCgBM,cApChB,yBAoCMC,QApCN;;gBAAA,KAwCQ,KAAK1B,MAAL,CAAY2B,IAxCpB;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAyC+C,KAAKgB,kBAAL,CAAwBpB,aAAxB,EAAuC,KAAKvB,MAA5C,CAzC/C;;cAAA;gBAAA;gBAyCiB6B,YAzCjB,0BAyCSX,MAzCT;gBAyC+BY,KAzC/B,0BAyC+BA,KAzC/B;gBAAA;gBAAA;;cAAA;gBA2CMD,YAAY,GAAGN,aAAf;;cA3CN;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;gBA8CIvC,GAAG,CAACG,KAAJ,CAAU,uCAAV;gBA9CJ;gBAAA,OA+CUkB,MAAM,CAAC0B,KAAP,cA/CV;;cAAA;gBAAA;;cAAA;gBAmDE,IAAI,KAAKlC,OAAT,EAAkB;kBAChB,KAAKA,OAAL,CAAamC,iBAAb,CAA+BxB,SAA/B,EAA0CW,UAA1C;kBACAb,OAAO,CAACa,UAAD,CAAP;gBACD;;gBAEDnC,GAAG,CAAC,2CAAD,CAAH;gBAxDF,kCA0DS,KAAKiD,iBAAL,CAAuB;kBAC5BR,cAAc,EAAdA,cAD4B;kBAE5BS,SAAS,EAAE,UAFiB;kBAG5B7B,MAAM,EAANA,MAH4B;kBAI5BwB,YAAY,EAAZA,YAJ4B;kBAK5BC,KAAK,EAALA,KAL4B;kBAM5BX,UAAU,EAAVA;gBAN4B,CAAvB,CA1DT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAoEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,kCAOG;MAAA;;MAAA,IANDM,cAMC,SANDA,cAMC;MAAA,IALDS,SAKC,SALDA,SAKC;MAAA,IAJD7B,MAIC,SAJDA,MAIC;MAAA,IAHDwB,YAGC,SAHDA,YAGC;MAAA,IAFDC,KAEC,SAFDA,KAEC;MAAA,IADDX,UACC,SADDA,UACC;;MACD;MACA,IAAIyB,KAAJ;MACA;;MACA,IAAIC,SAAJ;MACA;;MACA,IAAIC,UAAJ,CANC,CAMc;;MAEf,IAAIhB,KAAJ,EAAW;QACT;QACAc,KAAK,GAAG,IAAId,KAAJ,CAAU;UAChB;UACAiB,QAAQ;YAAA,4EAAE,kBAAMC,WAAN;cAAA;;cAAA;gBAAA;kBAAA;oBAAA;sBAAA,IACHF,UADG;wBAAA;wBAAA;sBAAA;;sBAAA;;oBAAA;sBAEFG,GAFE,GAEI,IAAI5D,WAAW,CAAC6D,QAAhB,CAAyBF,WAAzB,CAFJ;sBAAA;sBAAA;sBAAA,OAI6BC,GAAG,CAACE,MAAJ,CAAWC,KAAK,CAACC,IAAN,CAAW,KAAI,CAACjD,SAAL,CAAekD,IAAf,EAAX,CAAX,CAJ7B;;oBAAA;sBAAA;sBAIEpC,MAJF,qBAIEA,MAJF;sBAIUQ,QAJV,qBAIUA,QAJV;sBAKN1C,GAAG,CAAC,kCAAD,EAAqCkD,SAArC,EAAgDR,QAAhD,CAAH;sBACA,IAAI,KAAI,CAAC7B,OAAT,EAAkB,KAAI,CAACA,OAAL,CAAaoB,WAAb,CAAyB;wBAAEC,MAAM,EAANA,MAAF;wBAAUC,UAAU,EAAVA,UAAV;wBAAsBO,QAAQ,EAARA;sBAAtB,CAAzB;sBAClBoB,UAAU,CAACS,SAAX,CAAqBP,WAArB,EAAkC;wBAAEtB,QAAQ,EAARA;sBAAF,CAAlC;;sBACA,KAAI,CAAC8B,SAAL,CAAe;wBAAEV,UAAU,EAAVA,UAAF;wBAAc5B,MAAM,kCAAO8B,WAAP,GAAuB9B,MAAvB,CAApB;wBAAqDQ,QAAQ,EAARA;sBAArD,CAAf;;sBARM;sBAAA;;oBAAA;sBAAA;sBAAA;sBAUN1C,GAAG,CAACG,KAAJ;;oBAVM;oBAAA;sBAAA;kBAAA;gBAAA;cAAA;YAAA,CAAF;;YAAA;cAAA;YAAA;;YAAA;UAAA,GAFQ;UAehB;UACAsE,WAAW,EAAE,qBAAAT,WAAW,EAAI;YAC1BF,UAAU,CAACY,YAAX,CAAwBV,WAAW,CAACW,EAApC;UACD;QAlBe,CAAV,CAAR;;QAqBAd,SAAS;UAAA,uEAAG,kBAAOzC,SAAP;YAAA;;YAAA;cAAA;gBAAA;kBAAA;oBACVpB,GAAG,CAAC,+BAAD,EAAkCkD,SAAlC,EAA6C9B,SAA7C,CAAH;oBACM4C,WAFI,GAEUJ,KAAK,CAACC,SAAN,EAFV;oBAGJI,GAHI,GAGE,IAAI5D,WAAW,CAACuE,MAAhB,CAAuBZ,WAAvB,CAHF;oBAAA;oBAAA;oBAAA,OAK2BC,GAAG,CAACY,MAAJ,CAAWzD,SAAX,CAL3B;;kBAAA;oBAAA;oBAKAc,MALA,qBAKAA,MALA;oBAKQQ,QALR,qBAKQA,QALR;oBAMR,IAAI,KAAI,CAAC7B,OAAT,EAAkB,KAAI,CAACA,OAAL,CAAaoB,WAAb,CAAyB;sBAAEC,MAAM,EAANA,MAAF;sBAAUC,UAAU,EAAVA,UAAV;sBAAsBO,QAAQ,EAARA;oBAAtB,CAAzB;oBANV,kCAOD;sBAAER,MAAM,kCAAO8B,WAAP,GAAuB9B,MAAvB,CAAR;sBAAyCQ,QAAQ,EAARA;oBAAzC,CAPC;;kBAAA;oBAAA;oBAAA;oBASR1C,GAAG,CAACG,KAAJ,CAAU,6BAAV;oBATQ,MAUFC,OAAO,eAAMM,KAAK,CAACoE,wBAAZ,CAVL;;kBAAA;kBAAA;oBAAA;gBAAA;cAAA;YAAA;UAAA,CAAH;;UAAA;YAAA;UAAA;QAAA,GAAT,CAvBS,CAqCT;;;QACAtE,IAAI,CAACqC,YAAD,EAAee,KAAf,EAAsBf,YAAtB,CAAJ,CAAwCkC,KAAxC,CAA8C/E,GAAG,CAACG,KAAlD;MACD;;MAED,IAAM6E,SAAS,GAAG3D,MAAM,CAAC4D,QAAzB;MACA5D,MAAM,CAAC4D,QAAP,GAAkB,IAAIC,KAAJ,CAAUF,SAAV,EAAqB;QACrCG,GAAG,EAAE,eAAa;UAChB,IAAIrB,UAAU,IAAI,uDAAY,OAA1B,0DAAgD,CAACkB,SAAS,CAACjC,KAA/D,EAAsE;YACpE;YACA,2DAAC;cAAA;gBAAA;kBAAA;oBAAA;sBAAA;;sBAAA,MAEOe,UAAU,CAACsB,IAAX,CAAgBC,MAAhB,KAA2B,MAFlC;wBAAA;wBAAA;sBAAA;;sBAAA;sBAAA,OAGWvB,UAAU,CAACf,KAAX,EAHX;;oBAAA;sBAAA;sBAAA;;oBAAA;sBAAA;sBAAA;sBAMG/C,GAAG,CAACG,KAAJ;;oBANH;sBAAA;;sBAQG,KAAI,CAACc,eAAL,CAAqB6C,UAArB;;sBARH;;oBAAA;oBAAA;sBAAA;kBAAA;gBAAA;cAAA;YAAA,CAAD;UAWD;;UAED,OAAOwB,OAAO,CAACH,GAAR,OAAAG,OAAO,YAAd;QACD;MAlBoC,CAArB,CAAlB;MAoBAjE,MAAM,CAAC4D,QAAP,CAAgBM,QAAhB,GAA2BzD,IAAI,CAACC,GAAL,EAA3B;;MAEA,IAAMyD,2BAA2B,GAAG,SAA9BA,2BAA8B,GAAM;QACxC,MAAMpF,OAAO,CAAC,IAAIkD,KAAJ,CAAU,+BAAV,CAAD,EAA6C,gCAA7C,CAAb;MACD,CAFD,CAxEC,CA4ED;;;MACAQ,UAAU,GAAG,IAAIxD,UAAJ,CAAe;QAC1BmF,SAAS,EAAEpE,MAAM,CAACoE,SADQ;QAE1BrC,UAAU,EAAE/B,MAAM,CAAC+B,UAFO;QAG1BxC,SAAS,EAAE,KAAKA,SAHU;QAI1BuB,UAAU,EAAEA,UAJc;QAK1BiD,IAAI,EAAE;UACJlC,SAAS,EAATA,SADI;UAEJ;UACA+B,QAAQ,EAAE5D,MAAM,CAAC4D,QAHb;UAIJS,WAAW,EAAE5C,KAAK,IAAIA,KAAK,CAAC6C,UAJxB;UAKJC,UAAU,EAAEnD;QALR,CALoB;QAY1BoB,SAAS,EAAEA,SAAS,IAAI2B,2BAZE;QAa1BK,UAAU,EAAE;UAAA,OAAMjC,KAAK,GAAGA,KAAK,CAACkC,OAAT,GAAmBN,2BAA2B,EAAzD;QAAA,CAbc;QAc1BzC,KAAK;UAAA,wEAAE;YAAA;cAAA;gBAAA;kBAAA;oBAAA;oBAAA,OACC1B,MAAM,CAAC0B,KAAP,EADD;;kBAAA;oBAEL;oBACA,IAAIa,KAAJ,EAAW;sBACTA,KAAK,CAACkC,OAAN,CAAcC,GAAd,CAAkB,UAAA7D,MAAM;wBAAA,OAAIA,MAAM,CAAC8D,KAAP,EAAJ;sBAAA,CAAxB;oBACD;;kBALI;kBAAA;oBAAA;gBAAA;cAAA;YAAA;UAAA,CAAF;;UAAA;YAAA;UAAA;;UAAA;QAAA;MAdqB,CAAf,CAAb;MAuBA,KAAK9E,YAAL,CAAkB4C,UAAlB;MAEA,OAAOA,UAAP;IACD;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,0BAA6C;MAAA,IAAhCA,UAAgC,SAAhCA,UAAgC;MAAA,IAApB5B,MAAoB,SAApBA,MAAoB;MAAA,IAAZQ,QAAY,SAAZA,QAAY;MAC3C,IAAMuD,OAAO,GAAG,KAAK7E,SAAL,CAAe8E,GAAf,CAAmBxD,QAAnB,CAAhB;MACAuD,OAAO,CAAC;QAAEnC,UAAU,EAAVA,UAAF;QAAc5B,MAAM,EAANA,MAAd;QAAsBQ,QAAQ,EAARA;MAAtB,CAAD,CAAP;IACD;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;wFACE,kBAAuB9B,SAAvB,EAAkCkD,UAAlC,EAA8ChD,OAA9C;QAAA;;QAAA;UAAA;YAAA;cAAA;gBACQmD,GADR,GACc,IAAI5D,WAAW,CAAC6D,QAAhB,CAAyBJ,UAAzB,CADd;gBAEQ1C,SAFR,GAEoBgD,KAAK,CAACC,IAAN,CAAWvD,OAAO,CAACwD,IAAR,EAAX,CAFpB;gBAGEtE,GAAG,CAAC,4CAAD,EAA+CoB,SAA/C,CAAH;gBAHF;gBAAA;gBAAA,OAMuC6C,GAAG,CAACE,MAAJ,CAAW/C,SAAX,CANvC;;cAAA;gBAAA;gBAMYc,MANZ,sBAMYA,MANZ;gBAMoBQ,QANpB,sBAMoBA,QANpB;gBAOUyD,MAPV,GAOmBrF,OAAO,CAACoF,GAAR,CAAYxD,QAAZ,CAPnB;gBAQI1C,GAAG,CAAC,kCAAD,CAAH;;gBARJ,IAUSmG,MAVT;kBAAA;kBAAA;gBAAA;;gBAAA,MAWY,IAAI7C,KAAJ,sCAAwCZ,QAAxC,EAXZ;;cAAA;gBAAA;gBAAA;gBAAA;gBAAA;gBAAA,OAeeyD,MAAM,CAACC,aAAP,CAAqBxF,SAArB,EAAgCsB,MAAhC,CAff;;cAAA;gBAAA;gBAAA;gBAAA;gBAAA;kBAgBMQ,QAAQ,EAARA;gBAhBN;gBAAA;;cAAA;gBAAA;gBAAA;gBAAA,MAmBUtC,OAAO,eAAMM,KAAK,CAAC2F,qBAAZ,CAnBjB;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAuBA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;yFACE,kBAAwBzF,SAAxB,EAAmCkD,UAAnC,EAA+CN,YAA/C,EAA6D1C,OAA7D;QAAA;;QAAA;UAAA;YAAA;cAAA;gBACQmD,GADR,GACc,IAAI5D,WAAW,CAACuE,MAAhB,CAAuBd,UAAvB,CADd;gBAEQ1C,SAFR,GAEoBgD,KAAK,CAACC,IAAN,CAAWvD,OAAO,CAACwD,IAAR,EAAX,CAFpB;gBAGEtE,GAAG,CAAC,oCAAD,EAAuCoB,SAAvC,CAAH;gBAHF;gBAAA;gBAAA,OAMuC6C,GAAG,CAACY,MAAJ,CAAWzD,SAAX,CANvC;;cAAA;gBAAA;gBAMYc,MANZ,sBAMYA,MANZ;gBAMoBQ,QANpB,sBAMoBA,QANpB;gBAOUyD,MAPV,GAOmBrF,OAAO,CAACoF,GAAR,CAAYxD,QAAZ,CAPnB;gBAQI1C,GAAG,CAAC,sCAAD,EAAyCwD,YAAzC,CAAH;;gBARJ,IAUS2C,MAVT;kBAAA;kBAAA;gBAAA;;gBAAA,MAWY,IAAI7C,KAAJ,sCAAwCZ,QAAxC,EAXZ;;cAAA;gBAAA;gBAAA;gBAAA;gBAAA;gBAAA,OAeeyD,MAAM,CAACG,cAAP,CAAsB1F,SAAtB,EAAiCsB,MAAjC,EAAyCsB,YAAzC,CAff;;cAAA;gBAAA;gBAAA;gBAAA;gBAAA;kBAgBMd,QAAQ,EAARA;gBAhBN;gBAAA;;cAAA;gBAAA;gBAAA;gBAAA,MAmBUtC,OAAO,eAAMM,KAAK,CAAC2F,qBAAZ,CAnBjB;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAuBA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;2FACE,kBAA0BvC,UAA1B,EAAsC9C,MAAtC;QAAA;;QAAA;UAAA;YAAA;cAAA;gBACQuF,MADR,GACiB,IAAIlG,WAAW,CAACuE,MAAhB,CAAuBd,UAAvB,CADjB;gBAEQ1C,SAFR,GAEoBgD,KAAK,CAACC,IAAN,CAAWrD,MAAM,CAACsD,IAAP,EAAX,CAFpB;gBAGEtE,GAAG,CAAC,6BAAD,EAAgCoB,SAAhC,CAAH;gBAHF;gBAAA;gBAAA,OAKuCmF,MAAM,CAAC1B,MAAP,CAAczD,SAAd,CALvC;;cAAA;gBAAA;gBAKYc,MALZ,wBAKYA,MALZ;gBAKoBQ,QALpB,wBAKoBA,QALpB;gBAMI1C,GAAG,CAAC,+BAAD,EAAkC0C,QAAlC,CAAH;gBACMI,KAPV,GAOkB9B,MAAM,CAACkF,GAAP,CAAWxD,QAAX,CAPlB;gBAAA,kCAQW;kBAAER,MAAM,EAANA,MAAF;kBAAUY,KAAK,EAALA;gBAAV,CARX;;cAAA;gBAAA;gBAAA;gBAAA,MAUU1C,OAAO,eAAMM,KAAK,CAAC8F,qBAAZ,CAVjB;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAcA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;0FACE,mBAAyB1C,UAAzB,EAAqC9C,MAArC;QAAA;;QAAA;UAAA;YAAA;cAAA;gBACQyF,QADR,GACmB,IAAIpG,WAAW,CAAC6D,QAAhB,CAAyBJ,UAAzB,CADnB;gBAEQ1C,SAFR,GAEoBgD,KAAK,CAACC,IAAN,CAAWrD,MAAM,CAACsD,IAAP,EAAX,CAFpB;gBAGEtE,GAAG,CAAC,4BAAD,EAA+BoB,SAA/B,CAAH;gBAHF;gBAAA;gBAAA,OAKuCqF,QAAQ,CAACtC,MAAT,CAAgB/C,SAAhB,CALvC;;cAAA;gBAAA;gBAKYc,MALZ,yBAKYA,MALZ;gBAKoBQ,QALpB,yBAKoBA,QALpB;gBAMUI,KANV,GAMkB9B,MAAM,CAACkF,GAAP,CAAWxD,QAAX,CANlB;gBAAA,mCAOW;kBAAER,MAAM,EAANA,MAAF;kBAAUY,KAAK,EAALA;gBAAV,CAPX;;cAAA;gBAAA;gBAAA;gBAAA,MASU1C,OAAO,gBAAMM,KAAK,CAAC8F,qBAAZ,CATjB;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;;;AAcFE,MAAM,CAACC,OAAP,GAAiBhG,QAAjB"},"metadata":{},"sourceType":"script"}