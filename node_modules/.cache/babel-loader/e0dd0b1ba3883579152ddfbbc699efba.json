{"ast":null,"code":"'use strict';\n\nvar _require = require('multiaddr'),\n    Multiaddr = _require.Multiaddr;\n/**\n * @typedef {import('./types').MatchesFunction} MatchesFunction\n * @typedef {import('./types').PartialMatchesFunction} PartialMatchesFunction\n * @typedef {import('./types').Mafmt} Mafmt\n */\n\n/*\n * Valid combinations\n */\n\n\nvar DNS4 = base('dns4');\nvar DNS6 = base('dns6');\nvar DNSADDR = base('dnsaddr');\nvar DNS = or(base('dns'), DNSADDR, DNS4, DNS6);\nvar IP = or(base('ip4'), base('ip6'));\nvar TCP = or(and(IP, base('tcp')), and(DNS, base('tcp')));\nvar UDP = and(IP, base('udp'));\nvar UTP = and(UDP, base('utp'));\nvar QUIC = and(UDP, base('quic'));\nvar WebSockets = or(and(TCP, base('ws')), and(DNS, base('ws')));\nvar WebSocketsSecure = or(and(TCP, base('wss')), and(DNS, base('wss')));\nvar HTTP = or(and(TCP, base('http')), and(IP, base('http')), and(DNS, base('http')));\nvar HTTPS = or(and(TCP, base('https')), and(IP, base('https')), and(DNS, base('https')));\nvar WebRTCStar = or(and(WebSockets, base('p2p-webrtc-star'), base('p2p')), and(WebSocketsSecure, base('p2p-webrtc-star'), base('p2p')), and(WebSockets, base('p2p-webrtc-star')), and(WebSocketsSecure, base('p2p-webrtc-star')));\nvar WebSocketStar = or(and(WebSockets, base('p2p-websocket-star'), base('p2p')), and(WebSocketsSecure, base('p2p-websocket-star'), base('p2p')), and(WebSockets, base('p2p-websocket-star')), and(WebSocketsSecure, base('p2p-websocket-star')));\nvar WebRTCDirect = or(and(HTTP, base('p2p-webrtc-direct'), base('p2p')), and(HTTPS, base('p2p-webrtc-direct'), base('p2p')), and(HTTP, base('p2p-webrtc-direct')), and(HTTPS, base('p2p-webrtc-direct')));\nvar Reliable = or(WebSockets, WebSocketsSecure, HTTP, HTTPS, WebRTCStar, WebRTCDirect, TCP, UTP, QUIC, DNS); // Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )\n\nvar Stardust = or(and(Reliable, base('p2p-stardust'), base('p2p')), and(Reliable, base('p2p-stardust')));\n\nvar _P2P = or(and(Reliable, base('p2p')), WebRTCStar, WebRTCDirect, base('p2p'));\n\nvar _Circuit = or(and(_P2P, base('p2p-circuit'), _P2P), and(_P2P, base('p2p-circuit')), and(base('p2p-circuit'), _P2P), and(Reliable, base('p2p-circuit')), and(base('p2p-circuit'), Reliable), base('p2p-circuit'));\n\nvar CircuitRecursive = function CircuitRecursive() {\n  return or(and(_Circuit, CircuitRecursive), _Circuit);\n};\n\nvar Circuit = CircuitRecursive();\nvar P2P = or(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);\nmodule.exports = {\n  DNS: DNS,\n  DNS4: DNS4,\n  DNS6: DNS6,\n  DNSADDR: DNSADDR,\n  IP: IP,\n  TCP: TCP,\n  UDP: UDP,\n  QUIC: QUIC,\n  UTP: UTP,\n  HTTP: HTTP,\n  HTTPS: HTTPS,\n  WebSockets: WebSockets,\n  WebSocketsSecure: WebSocketsSecure,\n  WebSocketStar: WebSocketStar,\n  WebRTCStar: WebRTCStar,\n  WebRTCDirect: WebRTCDirect,\n  Reliable: Reliable,\n  Stardust: Stardust,\n  Circuit: Circuit,\n  P2P: P2P,\n  IPFS: P2P\n};\n/*\n * Validation funcs\n */\n\n/**\n * @param {PartialMatchesFunction} partialMatch\n */\n\nfunction makeMatchesFunction(partialMatch) {\n  /**\n   * @type {MatchesFunction}\n   */\n  function matches(a) {\n    if (!Multiaddr.isMultiaddr(a)) {\n      try {\n        a = new Multiaddr(a);\n      } catch (err) {\n        // catch error\n        return false; // also if it's invalid it's propably not matching as well so return false\n      }\n    }\n\n    var out = partialMatch(a.protoNames());\n\n    if (out === null) {\n      return false;\n    }\n\n    if (out === true || out === false) {\n      return out;\n    }\n\n    return out.length === 0;\n  }\n\n  return matches;\n}\n/**\n * @param {Array<Mafmt | (() => Mafmt)>} args\n * @returns {Mafmt}\n */\n\n\nfunction and() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  /**\n   * @type {PartialMatchesFunction}\n   */\n  function partialMatch(a) {\n    if (a.length < args.length) {\n      return null;\n    }\n    /** @type {boolean | string[] | null} */\n\n\n    var out = a;\n    args.some(function (arg) {\n      out = typeof arg === 'function' ? arg().partialMatch(a) : arg.partialMatch(a);\n\n      if (Array.isArray(out)) {\n        a = out;\n      }\n\n      if (out === null) {\n        return true;\n      }\n\n      return false;\n    });\n    return out;\n  }\n\n  return {\n    toString: function toString() {\n      return '{ ' + args.join(' ') + ' }';\n    },\n    input: args,\n    matches: makeMatchesFunction(partialMatch),\n    partialMatch: partialMatch\n  };\n}\n/**\n * @param {Array<Mafmt | (() => Mafmt)>} args\n * @returns {Mafmt}\n */\n\n\nfunction or() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  /**\n   * @type {PartialMatchesFunction}\n   */\n  function partialMatch(a) {\n    var out = null;\n    args.some(function (arg) {\n      var res = typeof arg === 'function' ? arg().partialMatch(a) : arg.partialMatch(a);\n\n      if (res) {\n        out = res;\n        return true;\n      }\n\n      return false;\n    });\n    return out;\n  }\n\n  var result = {\n    toString: function toString() {\n      return '{ ' + args.join(' ') + ' }';\n    },\n    input: args,\n    matches: makeMatchesFunction(partialMatch),\n    partialMatch: partialMatch\n  };\n  return result;\n}\n/**\n * @param {string} n\n * @returns {Mafmt}\n */\n\n\nfunction base(n) {\n  var name = n;\n  /**\n   * @type {MatchesFunction}\n   */\n\n  function matches(a) {\n    var ma;\n\n    if (typeof a === 'string' || a instanceof Uint8Array) {\n      try {\n        ma = new Multiaddr(a);\n      } catch (err) {\n        // catch error\n        return false; // also if it's invalid it's probably not matching as well so return false\n      }\n    } else {\n      ma = a;\n    }\n\n    var pnames = ma.protoNames();\n\n    if (pnames.length === 1 && pnames[0] === name) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @type {PartialMatchesFunction}\n   */\n\n\n  function partialMatch(protos) {\n    if (protos.length === 0) {\n      return null;\n    }\n\n    if (protos[0] === name) {\n      return protos.slice(1);\n    }\n\n    return null;\n  }\n\n  return {\n    toString: function toString() {\n      return name;\n    },\n    matches: matches,\n    partialMatch: partialMatch\n  };\n}","map":{"version":3,"names":["require","Multiaddr","DNS4","base","DNS6","DNSADDR","DNS","or","IP","TCP","and","UDP","UTP","QUIC","WebSockets","WebSocketsSecure","HTTP","HTTPS","WebRTCStar","WebSocketStar","WebRTCDirect","Reliable","Stardust","_P2P","_Circuit","CircuitRecursive","Circuit","P2P","module","exports","IPFS","makeMatchesFunction","partialMatch","matches","a","isMultiaddr","err","out","protoNames","length","args","some","arg","Array","isArray","toString","join","input","res","result","n","name","ma","Uint8Array","pnames","protos","slice"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/mafmt/src/index.js"],"sourcesContent":["'use strict'\n\nconst { Multiaddr } = require('multiaddr')\n\n/**\n * @typedef {import('./types').MatchesFunction} MatchesFunction\n * @typedef {import('./types').PartialMatchesFunction} PartialMatchesFunction\n * @typedef {import('./types').Mafmt} Mafmt\n */\n\n/*\n * Valid combinations\n */\nconst DNS4 = base('dns4')\nconst DNS6 = base('dns6')\nconst DNSADDR = base('dnsaddr')\nconst DNS = or(\n  base('dns'),\n  DNSADDR,\n  DNS4,\n  DNS6\n)\n\nconst IP = or(base('ip4'), base('ip6'))\nconst TCP = or(\n  and(IP, base('tcp')),\n  and(DNS, base('tcp'))\n)\nconst UDP = and(IP, base('udp'))\nconst UTP = and(UDP, base('utp'))\n\nconst QUIC = and(UDP, base('quic'))\n\nconst WebSockets = or(\n  and(TCP, base('ws')),\n  and(DNS, base('ws'))\n)\n\nconst WebSocketsSecure = or(\n  and(TCP, base('wss')),\n  and(DNS, base('wss'))\n)\n\nconst HTTP = or(\n  and(TCP, base('http')),\n  and(IP, base('http')),\n  and(DNS, base('http'))\n)\n\nconst HTTPS = or(\n  and(TCP, base('https')),\n  and(IP, base('https')),\n  and(DNS, base('https'))\n)\n\nconst WebRTCStar = or(\n  and(WebSockets, base('p2p-webrtc-star'), base('p2p')),\n  and(WebSocketsSecure, base('p2p-webrtc-star'), base('p2p')),\n  and(WebSockets, base('p2p-webrtc-star')),\n  and(WebSocketsSecure, base('p2p-webrtc-star'))\n)\n\nconst WebSocketStar = or(\n  and(WebSockets, base('p2p-websocket-star'), base('p2p')),\n  and(WebSocketsSecure, base('p2p-websocket-star'), base('p2p')),\n  and(WebSockets, base('p2p-websocket-star')),\n  and(WebSocketsSecure, base('p2p-websocket-star'))\n)\n\nconst WebRTCDirect = or(\n  and(HTTP, base('p2p-webrtc-direct'), base('p2p')),\n  and(HTTPS, base('p2p-webrtc-direct'), base('p2p')),\n  and(HTTP, base('p2p-webrtc-direct')),\n  and(HTTPS, base('p2p-webrtc-direct'))\n)\n\nconst Reliable = or(\n  WebSockets,\n  WebSocketsSecure,\n  HTTP,\n  HTTPS,\n  WebRTCStar,\n  WebRTCDirect,\n  TCP,\n  UTP,\n  QUIC,\n  DNS\n)\n\n// Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )\nconst Stardust = or(\n  and(Reliable, base('p2p-stardust'), base('p2p')),\n  and(Reliable, base('p2p-stardust'))\n)\n\nconst _P2P = or(\n  and(Reliable, base('p2p')),\n  WebRTCStar,\n  WebRTCDirect,\n  base('p2p')\n)\n\nconst _Circuit = or(\n  and(_P2P, base('p2p-circuit'), _P2P),\n  and(_P2P, base('p2p-circuit')),\n  and(base('p2p-circuit'), _P2P),\n  and(Reliable, base('p2p-circuit')),\n  and(base('p2p-circuit'), Reliable),\n  base('p2p-circuit')\n)\n\nconst CircuitRecursive = () => or(\n  and(_Circuit, CircuitRecursive),\n  _Circuit\n)\n\nconst Circuit = CircuitRecursive()\n\nconst P2P = or(\n  and(Circuit, _P2P, Circuit),\n  and(_P2P, Circuit),\n  and(Circuit, _P2P),\n  Circuit,\n  _P2P\n)\n\nmodule.exports = {\n  DNS,\n  DNS4,\n  DNS6,\n  DNSADDR,\n  IP,\n  TCP,\n  UDP,\n  QUIC,\n  UTP,\n  HTTP,\n  HTTPS,\n  WebSockets,\n  WebSocketsSecure,\n  WebSocketStar,\n  WebRTCStar,\n  WebRTCDirect,\n  Reliable,\n  Stardust,\n  Circuit,\n  P2P,\n  IPFS: P2P\n}\n\n/*\n * Validation funcs\n */\n\n/**\n * @param {PartialMatchesFunction} partialMatch\n */\nfunction makeMatchesFunction (partialMatch) {\n  /**\n   * @type {MatchesFunction}\n   */\n  function matches (a) {\n    if (!Multiaddr.isMultiaddr(a)) {\n      try {\n        a = new Multiaddr(a)\n      } catch (err) { // catch error\n        return false // also if it's invalid it's propably not matching as well so return false\n      }\n    }\n    const out = partialMatch(a.protoNames())\n    if (out === null) {\n      return false\n    }\n\n    if (out === true || out === false) {\n      return out\n    }\n\n    return out.length === 0\n  }\n\n  return matches\n}\n\n/**\n * @param {Array<Mafmt | (() => Mafmt)>} args\n * @returns {Mafmt}\n */\nfunction and (...args) {\n  /**\n   * @type {PartialMatchesFunction}\n   */\n  function partialMatch (a) {\n    if (a.length < args.length) {\n      return null\n    }\n\n    /** @type {boolean | string[] | null} */\n    let out = a\n\n    args.some((arg) => {\n      out = typeof arg === 'function'\n        ? arg().partialMatch(a)\n        : arg.partialMatch(a)\n\n      if (Array.isArray(out)) {\n        a = out\n      }\n\n      if (out === null) {\n        return true\n      }\n\n      return false\n    })\n\n    return out\n  }\n\n  return {\n    toString: function () { return '{ ' + args.join(' ') + ' }' },\n    input: args,\n    matches: makeMatchesFunction(partialMatch),\n    partialMatch: partialMatch\n  }\n}\n\n/**\n * @param {Array<Mafmt | (() => Mafmt)>} args\n * @returns {Mafmt}\n */\nfunction or (...args) {\n  /**\n   * @type {PartialMatchesFunction}\n   */\n  function partialMatch (a) {\n    let out = null\n    args.some((arg) => {\n      const res = typeof arg === 'function'\n        ? arg().partialMatch(a)\n        : arg.partialMatch(a)\n      if (res) {\n        out = res\n        return true\n      }\n      return false\n    })\n\n    return out\n  }\n\n  const result = {\n    toString: function () { return '{ ' + args.join(' ') + ' }' },\n    input: args,\n    matches: makeMatchesFunction(partialMatch),\n    partialMatch: partialMatch\n  }\n\n  return result\n}\n\n/**\n * @param {string} n\n * @returns {Mafmt}\n */\nfunction base (n) {\n  const name = n\n\n  /**\n   * @type {MatchesFunction}\n   */\n  function matches (a) {\n    let ma\n\n    if (typeof a === 'string' || a instanceof Uint8Array) {\n      try {\n        ma = new Multiaddr(a)\n      } catch (err) { // catch error\n        return false // also if it's invalid it's probably not matching as well so return false\n      }\n    } else {\n      ma = a\n    }\n\n    const pnames = ma.protoNames()\n    if (pnames.length === 1 && pnames[0] === name) {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * @type {PartialMatchesFunction}\n   */\n  function partialMatch (protos) {\n    if (protos.length === 0) {\n      return null\n    }\n\n    if (protos[0] === name) {\n      return protos.slice(1)\n    }\n    return null\n  }\n\n  return {\n    toString: function () { return name },\n    matches: matches,\n    partialMatch: partialMatch\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}