{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar EventEmitter = require(\"eventemitter3\");\n\nvar p_timeout_1 = require(\"p-timeout\");\n\nvar priority_queue_1 = require(\"./priority-queue\"); // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\nvar empty = function empty() {};\n\nvar timeoutError = new p_timeout_1.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\n\nvar PQueue = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(PQueue, _EventEmitter);\n\n  var _super = _createSuper(PQueue);\n\n  function PQueue(options) {\n    var _this;\n\n    _classCallCheck(this, PQueue);\n\n    var _a, _b, _c, _d;\n\n    _this = _super.call(this);\n    _this._intervalCount = 0;\n    _this._intervalEnd = 0;\n    _this._pendingCount = 0;\n    _this._resolveEmpty = empty;\n    _this._resolveIdle = empty; // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\n    options = Object.assign({\n      carryoverConcurrencyCount: false,\n      intervalCap: Infinity,\n      interval: 0,\n      concurrency: Infinity,\n      autoStart: true,\n      queueClass: priority_queue_1.default\n    }, options);\n\n    if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n      throw new TypeError(\"Expected `intervalCap` to be a number from 1 and up, got `\".concat((_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '', \"` (\").concat(typeof options.intervalCap, \")\"));\n    }\n\n    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n      throw new TypeError(\"Expected `interval` to be a finite number >= 0, got `\".concat((_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : '', \"` (\").concat(typeof options.interval, \")\"));\n    }\n\n    _this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n    _this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n    _this._intervalCap = options.intervalCap;\n    _this._interval = options.interval;\n    _this._queue = new options.queueClass();\n    _this._queueClass = options.queueClass;\n    _this.concurrency = options.concurrency;\n    _this._timeout = options.timeout;\n    _this._throwOnTimeout = options.throwOnTimeout === true;\n    _this._isPaused = options.autoStart === false;\n    return _this;\n  }\n\n  _createClass(PQueue, [{\n    key: \"_doesIntervalAllowAnother\",\n    get: function get() {\n      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n  }, {\n    key: \"_doesConcurrentAllowAnother\",\n    get: function get() {\n      return this._pendingCount < this._concurrency;\n    }\n  }, {\n    key: \"_next\",\n    value: function _next() {\n      this._pendingCount--;\n\n      this._tryToStartAnother();\n\n      this.emit('next');\n    }\n  }, {\n    key: \"_resolvePromises\",\n    value: function _resolvePromises() {\n      this._resolveEmpty();\n\n      this._resolveEmpty = empty;\n\n      if (this._pendingCount === 0) {\n        this._resolveIdle();\n\n        this._resolveIdle = empty;\n        this.emit('idle');\n      }\n    }\n  }, {\n    key: \"_onResumeInterval\",\n    value: function _onResumeInterval() {\n      this._onInterval();\n\n      this._initializeIntervalIfNeeded();\n\n      this._timeoutId = undefined;\n    }\n  }, {\n    key: \"_isIntervalPaused\",\n    value: function _isIntervalPaused() {\n      var _this2 = this;\n\n      var now = Date.now();\n\n      if (this._intervalId === undefined) {\n        var delay = this._intervalEnd - now;\n\n        if (delay < 0) {\n          // Act as the interval was done\n          // We don't need to resume it here because it will be resumed on line 160\n          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        } else {\n          // Act as the interval is pending\n          if (this._timeoutId === undefined) {\n            this._timeoutId = setTimeout(function () {\n              _this2._onResumeInterval();\n            }, delay);\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_tryToStartAnother\",\n    value: function _tryToStartAnother() {\n      if (this._queue.size === 0) {\n        // We can clear the interval (\"pause\")\n        // Because we can redo it later (\"resume\")\n        if (this._intervalId) {\n          clearInterval(this._intervalId);\n        }\n\n        this._intervalId = undefined;\n\n        this._resolvePromises();\n\n        return false;\n      }\n\n      if (!this._isPaused) {\n        var canInitializeInterval = !this._isIntervalPaused();\n\n        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n          var job = this._queue.dequeue();\n\n          if (!job) {\n            return false;\n          }\n\n          this.emit('active');\n          job();\n\n          if (canInitializeInterval) {\n            this._initializeIntervalIfNeeded();\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_initializeIntervalIfNeeded\",\n    value: function _initializeIntervalIfNeeded() {\n      var _this3 = this;\n\n      if (this._isIntervalIgnored || this._intervalId !== undefined) {\n        return;\n      }\n\n      this._intervalId = setInterval(function () {\n        _this3._onInterval();\n      }, this._interval);\n      this._intervalEnd = Date.now() + this._interval;\n    }\n  }, {\n    key: \"_onInterval\",\n    value: function _onInterval() {\n      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n        clearInterval(this._intervalId);\n        this._intervalId = undefined;\n      }\n\n      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n\n      this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n\n  }, {\n    key: \"_processQueue\",\n    value: function _processQueue() {\n      // eslint-disable-next-line no-empty\n      while (this._tryToStartAnother()) {}\n    }\n  }, {\n    key: \"concurrency\",\n    get: function get() {\n      return this._concurrency;\n    },\n    set: function set(newConcurrency) {\n      if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n        throw new TypeError(\"Expected `concurrency` to be a number from 1 and up, got `\".concat(newConcurrency, \"` (\").concat(typeof newConcurrency, \")\"));\n      }\n\n      this._concurrency = newConcurrency;\n\n      this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n\n  }, {\n    key: \"add\",\n    value: function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(fn) {\n        var _this4 = this;\n\n        var options,\n            _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var run = /*#__PURE__*/function () {\n                    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                      var operation;\n                      return _regeneratorRuntime().wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              _this4._pendingCount++;\n                              _this4._intervalCount++;\n                              _context.prev = 2;\n                              operation = _this4._timeout === undefined && options.timeout === undefined ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === undefined ? _this4._timeout : options.timeout, function () {\n                                if (options.throwOnTimeout === undefined ? _this4._throwOnTimeout : options.throwOnTimeout) {\n                                  reject(timeoutError);\n                                }\n\n                                return undefined;\n                              });\n                              _context.t0 = resolve;\n                              _context.next = 7;\n                              return operation;\n\n                            case 7:\n                              _context.t1 = _context.sent;\n                              (0, _context.t0)(_context.t1);\n                              _context.next = 14;\n                              break;\n\n                            case 11:\n                              _context.prev = 11;\n                              _context.t2 = _context[\"catch\"](2);\n                              reject(_context.t2);\n\n                            case 14:\n                              _this4._next();\n\n                            case 15:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee, null, [[2, 11]]);\n                    }));\n\n                    return function run() {\n                      return _ref.apply(this, arguments);\n                    };\n                  }();\n\n                  _this4._queue.enqueue(run, options);\n\n                  _this4._tryToStartAnother();\n\n                  _this4.emit('add');\n                }));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function add(_x) {\n        return _add.apply(this, arguments);\n      }\n\n      return add;\n    }()\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n     @returns A promise that resolves when all functions are resolved.\n    */\n\n  }, {\n    key: \"addAll\",\n    value: function () {\n      var _addAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(functions, options) {\n        var _this5 = this;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", Promise.all(functions.map( /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(function_) {\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            return _context3.abrupt(\"return\", _this5.add(function_, options));\n\n                          case 1:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }));\n\n                  return function (_x4) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }())));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function addAll(_x2, _x3) {\n        return _addAll.apply(this, arguments);\n      }\n\n      return addAll;\n    }()\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (!this._isPaused) {\n        return this;\n      }\n\n      this._isPaused = false;\n\n      this._processQueue();\n\n      return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n     @returns A promise that settles when the queue becomes empty.\n    */\n\n  }, {\n    key: \"onEmpty\",\n    value: function () {\n      var _onEmpty = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _this6 = this;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(this._queue.size === 0)) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 2:\n                return _context5.abrupt(\"return\", new Promise(function (resolve) {\n                  var existingResolve = _this6._resolveEmpty;\n\n                  _this6._resolveEmpty = function () {\n                    existingResolve();\n                    resolve();\n                  };\n                }));\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function onEmpty() {\n        return _onEmpty.apply(this, arguments);\n      }\n\n      return onEmpty;\n    }()\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n     @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n\n  }, {\n    key: \"onIdle\",\n    value: function () {\n      var _onIdle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _this7 = this;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(this._pendingCount === 0 && this._queue.size === 0)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 2:\n                return _context6.abrupt(\"return\", new Promise(function (resolve) {\n                  var existingResolve = _this7._resolveIdle;\n\n                  _this7._resolveIdle = function () {\n                    existingResolve();\n                    resolve();\n                  };\n                }));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function onIdle() {\n        return _onIdle.apply(this, arguments);\n      }\n\n      return onIdle;\n    }()\n    /**\n    Size of the queue.\n    */\n\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n     For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n\n  }, {\n    key: \"sizeBy\",\n    value: function sizeBy(options) {\n      // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n      return this._queue.filter(options).length;\n    }\n    /**\n    Number of pending promises.\n    */\n\n  }, {\n    key: \"pending\",\n    get: function get() {\n      return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n\n  }, {\n    key: \"isPaused\",\n    get: function get() {\n      return this._isPaused;\n    }\n  }, {\n    key: \"timeout\",\n    get: function get() {\n      return this._timeout;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n    ,\n    set: function set(milliseconds) {\n      this._timeout = milliseconds;\n    }\n  }]);\n\n  return PQueue;\n}(EventEmitter);\n\nexports.default = PQueue;","map":{"version":3,"names":["Object","defineProperty","exports","value","EventEmitter","require","p_timeout_1","priority_queue_1","empty","timeoutError","TimeoutError","PQueue","options","_a","_b","_c","_d","_intervalCount","_intervalEnd","_pendingCount","_resolveEmpty","_resolveIdle","assign","carryoverConcurrencyCount","intervalCap","Infinity","interval","concurrency","autoStart","queueClass","default","TypeError","toString","undefined","Number","isFinite","_carryoverConcurrencyCount","_isIntervalIgnored","_intervalCap","_interval","_queue","_queueClass","_timeout","timeout","_throwOnTimeout","throwOnTimeout","_isPaused","_concurrency","_tryToStartAnother","emit","_onInterval","_initializeIntervalIfNeeded","_timeoutId","now","Date","_intervalId","delay","setTimeout","_onResumeInterval","size","clearInterval","_resolvePromises","canInitializeInterval","_isIntervalPaused","_doesIntervalAllowAnother","_doesConcurrentAllowAnother","job","dequeue","setInterval","_processQueue","newConcurrency","fn","Promise","resolve","reject","run","operation","_next","enqueue","functions","all","map","function_","add","existingResolve","filter","length","milliseconds"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/p-queue/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EventEmitter = require(\"eventemitter3\");\nconst p_timeout_1 = require(\"p-timeout\");\nconst priority_queue_1 = require(\"./priority-queue\");\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst empty = () => { };\nconst timeoutError = new p_timeout_1.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        this._intervalCount = 0;\n        this._intervalEnd = 0;\n        this._pendingCount = 0;\n        this._resolveEmpty = empty;\n        this._resolveIdle = empty;\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n        this._intervalCap = options.intervalCap;\n        this._interval = options.interval;\n        this._queue = new options.queueClass();\n        this._queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this._timeout = options.timeout;\n        this._throwOnTimeout = options.throwOnTimeout === true;\n        this._isPaused = options.autoStart === false;\n    }\n    get _doesIntervalAllowAnother() {\n        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n    get _doesConcurrentAllowAnother() {\n        return this._pendingCount < this._concurrency;\n    }\n    _next() {\n        this._pendingCount--;\n        this._tryToStartAnother();\n        this.emit('next');\n    }\n    _resolvePromises() {\n        this._resolveEmpty();\n        this._resolveEmpty = empty;\n        if (this._pendingCount === 0) {\n            this._resolveIdle();\n            this._resolveIdle = empty;\n            this.emit('idle');\n        }\n    }\n    _onResumeInterval() {\n        this._onInterval();\n        this._initializeIntervalIfNeeded();\n        this._timeoutId = undefined;\n    }\n    _isIntervalPaused() {\n        const now = Date.now();\n        if (this._intervalId === undefined) {\n            const delay = this._intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this._timeoutId === undefined) {\n                    this._timeoutId = setTimeout(() => {\n                        this._onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _tryToStartAnother() {\n        if (this._queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this._intervalId) {\n                clearInterval(this._intervalId);\n            }\n            this._intervalId = undefined;\n            this._resolvePromises();\n            return false;\n        }\n        if (!this._isPaused) {\n            const canInitializeInterval = !this._isIntervalPaused();\n            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n                const job = this._queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this._initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _initializeIntervalIfNeeded() {\n        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n            return;\n        }\n        this._intervalId = setInterval(() => {\n            this._onInterval();\n        }, this._interval);\n        this._intervalEnd = Date.now() + this._interval;\n    }\n    _onInterval() {\n        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n        }\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    _processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this._tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this._concurrency = newConcurrency;\n        this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n    async add(fn, options = {}) {\n        return new Promise((resolve, reject) => {\n            const run = async () => {\n                this._pendingCount++;\n                this._intervalCount++;\n                try {\n                    const operation = (this._timeout === undefined && options.timeout === undefined) ? fn() : p_timeout_1.default(Promise.resolve(fn()), (options.timeout === undefined ? this._timeout : options.timeout), () => {\n                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                            reject(timeoutError);\n                        }\n                        return undefined;\n                    });\n                    resolve(await operation);\n                }\n                catch (error) {\n                    reject(error);\n                }\n                this._next();\n            };\n            this._queue.enqueue(run, options);\n            this._tryToStartAnother();\n            this.emit('add');\n        });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n\n    @returns A promise that resolves when all functions are resolved.\n    */\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this._isPaused) {\n            return this;\n        }\n        this._isPaused = false;\n        this._processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveEmpty;\n            this._resolveEmpty = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this._pendingCount === 0 && this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveIdle;\n            this._resolveIdle = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    Size of the queue.\n    */\n    get size() {\n        return this._queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        return this._queue.filter(options).length;\n    }\n    /**\n    Number of pending promises.\n    */\n    get pending() {\n        return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this._isPaused;\n    }\n    get timeout() {\n        return this._timeout;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n    set timeout(milliseconds) {\n        this._timeout = milliseconds;\n    }\n}\nexports.default = PQueue;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}