{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst webcrypto = require('../webcrypto');\n\nconst {\n  base64urlToBuffer\n} = require('../util');\n\nconst validateCurveType = require('./validate-curve-type');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n};\n\nexports.generateEphmeralKeyPair = async function (curve) {\n  validateCurveType(Object.keys(bits), curve);\n  const pair = await webcrypto.get().subtle.generateKey({\n    name: 'ECDH',\n    namedCurve: curve\n  }, true, ['deriveBits']); // forcePrivate is used for testing only\n\n  const genSharedKey = async (theirPub, forcePrivate) => {\n    let privateKey;\n\n    if (forcePrivate) {\n      privateKey = await webcrypto.get().subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {\n        name: 'ECDH',\n        namedCurve: curve\n      }, false, ['deriveBits']);\n    } else {\n      privateKey = pair.privateKey;\n    }\n\n    const keys = [await webcrypto.get().subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {\n      name: 'ECDH',\n      namedCurve: curve\n    }, false, []), privateKey];\n    const buffer = await webcrypto.get().subtle.deriveBits({\n      name: 'ECDH',\n      namedCurve: curve,\n      public: keys[0]\n    }, keys[1], bits[curve]);\n    return new Uint8Array(buffer, buffer.byteOffset, buffer.byteLength);\n  };\n\n  const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey);\n  return {\n    key: marshalPublicKey(publicKey),\n    genSharedKey\n  };\n};\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}; // Marshal converts a jwk encodec ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\n\nfunction marshalPublicKey(jwk) {\n  const byteLen = curveLengths[jwk.crv];\n  return uint8ArrayConcat([Uint8Array.from([4]), // uncompressed point\n  base64urlToBuffer(jwk.x, byteLen), base64urlToBuffer(jwk.y, byteLen)], 1 + byteLen * 2);\n} // Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\n\n\nfunction unmarshalPublicKey(curve, key) {\n  const byteLen = curveLengths[curve];\n\n  if (uint8ArrayEquals(!key.slice(0, 1), Uint8Array.from([4]))) {\n    throw errcode(new Error('Cannot unmarshal public key - invalid key format'), 'ERR_INVALID_KEY_FORMAT');\n  }\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: uint8ArrayToString(key.slice(1, byteLen + 1), 'base64url'),\n    y: uint8ArrayToString(key.slice(1 + byteLen), 'base64url'),\n    ext: true\n  };\n}\n\nconst unmarshalPrivateKey = (curve, key) => ({ ...unmarshalPublicKey(curve, key.public),\n  d: uint8ArrayToString(key.private, 'base64url')\n});","map":{"version":3,"names":["errcode","require","webcrypto","base64urlToBuffer","validateCurveType","toString","uint8ArrayToString","concat","uint8ArrayConcat","equals","uint8ArrayEquals","bits","exports","generateEphmeralKeyPair","curve","Object","keys","pair","get","subtle","generateKey","name","namedCurve","genSharedKey","theirPub","forcePrivate","privateKey","importKey","unmarshalPrivateKey","unmarshalPublicKey","buffer","deriveBits","public","Uint8Array","byteOffset","byteLength","publicKey","exportKey","key","marshalPublicKey","curveLengths","jwk","byteLen","crv","from","x","y","slice","Error","kty","ext","d","private"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/peer-id/node_modules/libp2p-crypto/src/keys/ecdh-browser.js"],"sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst webcrypto = require('../webcrypto')\nconst { base64urlToBuffer } = require('../util')\nconst validateCurveType = require('./validate-curve-type')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\n\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n}\n\nexports.generateEphmeralKeyPair = async function (curve) {\n  validateCurveType(Object.keys(bits), curve)\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: curve\n    },\n    true,\n    ['deriveBits']\n  )\n\n  // forcePrivate is used for testing only\n  const genSharedKey = async (theirPub, forcePrivate) => {\n    let privateKey\n\n    if (forcePrivate) {\n      privateKey = await webcrypto.get().subtle.importKey(\n        'jwk',\n        unmarshalPrivateKey(curve, forcePrivate),\n        {\n          name: 'ECDH',\n          namedCurve: curve\n        },\n        false,\n        ['deriveBits']\n      )\n    } else {\n      privateKey = pair.privateKey\n    }\n\n    const keys = [\n      await webcrypto.get().subtle.importKey(\n        'jwk',\n        unmarshalPublicKey(curve, theirPub),\n        {\n          name: 'ECDH',\n          namedCurve: curve\n        },\n        false,\n        []\n      ),\n      privateKey\n    ]\n\n    const buffer = await webcrypto.get().subtle.deriveBits(\n      {\n        name: 'ECDH',\n        namedCurve: curve,\n        public: keys[0]\n      },\n      keys[1],\n      bits[curve]\n    )\n\n    return new Uint8Array(buffer, buffer.byteOffset, buffer.byteLength)\n  }\n\n  const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n\n  return {\n    key: marshalPublicKey(publicKey),\n    genSharedKey\n  }\n}\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}\n\n// Marshal converts a jwk encodec ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey (jwk) {\n  const byteLen = curveLengths[jwk.crv]\n\n  return uint8ArrayConcat([\n    Uint8Array.from([4]), // uncompressed point\n    base64urlToBuffer(jwk.x, byteLen),\n    base64urlToBuffer(jwk.y, byteLen)\n  ], 1 + byteLen * 2)\n}\n\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\nfunction unmarshalPublicKey (curve, key) {\n  const byteLen = curveLengths[curve]\n\n  if (uint8ArrayEquals(!key.slice(0, 1), Uint8Array.from([4]))) {\n    throw errcode(new Error('Cannot unmarshal public key - invalid key format'), 'ERR_INVALID_KEY_FORMAT')\n  }\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: uint8ArrayToString(key.slice(1, byteLen + 1), 'base64url'),\n    y: uint8ArrayToString(key.slice(1 + byteLen), 'base64url'),\n    ext: true\n  }\n}\n\nconst unmarshalPrivateKey = (curve, key) => ({\n  ...unmarshalPublicKey(curve, key.public),\n  d: uint8ArrayToString(key.private, 'base64url')\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}