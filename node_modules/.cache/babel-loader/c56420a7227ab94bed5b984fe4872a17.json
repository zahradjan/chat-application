{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar pMap = require('p-map');\n\nvar pDoWhilst = require('p-do-whilst');\n\nvar Entry = require('./entry');\n\nvar hasItems = function hasItems(arr) {\n  return arr && arr.length > 0;\n};\n\nvar EntryIO = /*#__PURE__*/function () {\n  function EntryIO() {\n    _classCallCheck(this, EntryIO);\n  }\n\n  _createClass(EntryIO, null, [{\n    key: \"fetchParallel\",\n    value: // Fetch log graphs in parallel\n    function () {\n      var _fetchParallel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(ipfs, hashes, _ref) {\n        var length, _ref$exclude, exclude, shouldExclude, timeout, concurrency, onProgressCallback, fetchOne, concatArrays, flatten, res;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                length = _ref.length, _ref$exclude = _ref.exclude, exclude = _ref$exclude === void 0 ? [] : _ref$exclude, shouldExclude = _ref.shouldExclude, timeout = _ref.timeout, concurrency = _ref.concurrency, onProgressCallback = _ref.onProgressCallback;\n\n                fetchOne = /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(hash) {\n                    return _regeneratorRuntime().wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            return _context.abrupt(\"return\", EntryIO.fetchAll(ipfs, hash, {\n                              length: length,\n                              exclude: exclude,\n                              shouldExclude: shouldExclude,\n                              timeout: timeout,\n                              onProgressCallback: onProgressCallback,\n                              concurrency: concurrency\n                            }));\n\n                          case 1:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function fetchOne(_x4) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }();\n\n                concatArrays = function concatArrays(arr1, arr2) {\n                  return arr1.concat(arr2);\n                };\n\n                flatten = function flatten(arr) {\n                  return arr.reduce(concatArrays, []);\n                };\n\n                _context2.next = 6;\n                return pMap(hashes, fetchOne, {\n                  concurrency: Math.max(concurrency || hashes.length, 1)\n                });\n\n              case 6:\n                res = _context2.sent;\n                return _context2.abrupt(\"return\", flatten(res));\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function fetchParallel(_x, _x2, _x3) {\n        return _fetchParallel.apply(this, arguments);\n      }\n\n      return fetchParallel;\n    }()\n    /**\n     * Fetch log entries\n     *\n     * @param {IPFS} [ipfs] An IPFS instance\n     * @param {string} [hash] Multihash of the entry to fetch\n     * @param {string} [parent] Parent of the node to be fetched\n     * @param {Object} [all] Entries to skip\n     * @param {Number} [amount=-1] How many entries to fetch\n     * @param {Number} [depth=0] Current depth of the recursion\n     * @param {function(entry)} shouldExclude A function that can be passed to determine whether a specific hash should be excluded, ie. not fetched. The function should return true to indicate exclusion, otherwise return false.\n     * @param {function(entry)} onProgressCallback Called when an entry was fetched\n     * @returns {Promise<Array<Entry>>}\n     */\n\n  }, {\n    key: \"fetchAll\",\n    value: function () {\n      var _fetchAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(ipfs, hashes) {\n        var _ref3,\n            _ref3$length,\n            length,\n            _ref3$exclude,\n            exclude,\n            shouldExclude,\n            timeout,\n            onProgressCallback,\n            onStartProgressCallback,\n            _ref3$concurrency,\n            concurrency,\n            _ref3$delay,\n            delay,\n            result,\n            cache,\n            loadingCache,\n            loadingQueue,\n            running,\n            maxClock,\n            minClock,\n            loadingQueueHasMore,\n            addToLoadingQueue,\n            getNextFromQueue,\n            addToExcludeCache,\n            fetchEntry,\n            _processQueue,\n            _args6 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _ref3 = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : {}, _ref3$length = _ref3.length, length = _ref3$length === void 0 ? -1 : _ref3$length, _ref3$exclude = _ref3.exclude, exclude = _ref3$exclude === void 0 ? [] : _ref3$exclude, shouldExclude = _ref3.shouldExclude, timeout = _ref3.timeout, onProgressCallback = _ref3.onProgressCallback, onStartProgressCallback = _ref3.onStartProgressCallback, _ref3$concurrency = _ref3.concurrency, concurrency = _ref3$concurrency === void 0 ? 32 : _ref3$concurrency, _ref3$delay = _ref3.delay, delay = _ref3$delay === void 0 ? 0 : _ref3$delay;\n                result = [];\n                cache = {};\n                loadingCache = {};\n                loadingQueue = Array.isArray(hashes) ? {\n                  0: hashes.slice()\n                } : {\n                  0: [hashes]\n                };\n                running = 0; // keep track of how many entries are being fetched at any time\n\n                maxClock = 0; // keep track of the latest clock time during load\n\n                minClock = 0; // keep track of the minimum clock time during load\n\n                shouldExclude = shouldExclude || function () {\n                  return false;\n                }; // default fn returns false to not exclude any hash\n                // Does the loading queue have more to process?\n\n\n                loadingQueueHasMore = function loadingQueueHasMore() {\n                  return Object.values(loadingQueue).find(hasItems) !== undefined;\n                }; // Add a multihash to the loading queue\n\n\n                addToLoadingQueue = function addToLoadingQueue(e, idx) {\n                  if (!loadingCache[e] && !shouldExclude(e)) {\n                    if (!loadingQueue[idx]) loadingQueue[idx] = [];\n\n                    if (!loadingQueue[idx].includes(e)) {\n                      loadingQueue[idx].push(e);\n                    }\n\n                    loadingCache[e] = true;\n                  }\n                }; // Get the next items to process from the loading queue\n\n\n                getNextFromQueue = function getNextFromQueue() {\n                  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n                  var getNext = function getNext(res, key, idx) {\n                    var nextItems = loadingQueue[key];\n\n                    while (nextItems.length > 0 && res.length < length) {\n                      var hash = nextItems.shift();\n                      res.push(hash);\n                    }\n\n                    if (nextItems.length === 0) {\n                      delete loadingQueue[key];\n                    }\n\n                    return res;\n                  };\n\n                  return Object.keys(loadingQueue).reduce(getNext, []);\n                }; // Add entries that we don't need to fetch to the \"cache\"\n\n\n                addToExcludeCache = function addToExcludeCache(e) {\n                  cache[e.hash || e] = true;\n                }; // Fetch one entry and add it to the results\n\n\n                fetchEntry = /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(hash) {\n                    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            if (!(!hash || cache[hash] || shouldExclude(hash))) {\n                              _context4.next = 2;\n                              break;\n                            }\n\n                            return _context4.abrupt(\"return\");\n\n                          case 2:\n                            return _context4.abrupt(\"return\", new Promise( /*#__PURE__*/function () {\n                              var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(resolve, reject) {\n                                var timer, addToResults, entry, sleep;\n                                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                                  while (1) {\n                                    switch (_context3.prev = _context3.next) {\n                                      case 0:\n                                        // Resolve the promise after a timeout (if given) in order to\n                                        // not get stuck loading a block that is unreachable\n                                        timer = timeout && timeout > 0 ? setTimeout(function () {\n                                          console.warn(\"Warning: Couldn't fetch entry '\".concat(hash, \"', request timed out (\").concat(timeout, \"ms)\"));\n                                          resolve();\n                                        }, timeout) : null;\n\n                                        addToResults = function addToResults(entry) {\n                                          if (Entry.isEntry(entry) && !cache[entry.hash] && !shouldExclude(entry.hash)) {\n                                            var ts = entry.clock.time; // Update min/max clocks\n\n                                            maxClock = Math.max(maxClock, ts);\n                                            minClock = result.length > 0 ? Math.min(result[result.length - 1].clock.time, minClock) : maxClock;\n                                            var isLater = result.length >= length && ts >= minClock;\n\n                                            var calculateIndex = function calculateIndex(idx) {\n                                              return maxClock - ts + (idx + 1) * idx;\n                                            }; // Add the entry to the results if\n                                            // 1) we're fetching all entries\n                                            // 2) results is not filled yet\n                                            // the clock of the entry is later than current known minimum clock time\n\n\n                                            if ((length < 0 || result.length < length || isLater) && !shouldExclude(entry.hash) && !cache[entry.hash]) {\n                                              result.push(entry);\n                                              cache[entry.hash] = true;\n\n                                              if (onProgressCallback) {\n                                                onProgressCallback(entry);\n                                              }\n                                            }\n\n                                            if (length < 0) {\n                                              // If we're fetching all entries (length === -1), adds nexts and refs to the queue\n                                              entry.next.forEach(addToLoadingQueue);\n                                              if (entry.refs) entry.refs.forEach(addToLoadingQueue);\n                                            } else {\n                                              // If we're fetching entries up to certain length,\n                                              // fetch the next if result is filled up, to make sure we \"check\"\n                                              // the next entry if its clock is later than what we have in the result\n                                              if (result.length < length || ts > minClock || ts === minClock && !cache[entry.hash] && !shouldExclude(entry.hash)) {\n                                                entry.next.forEach(function (e) {\n                                                  return addToLoadingQueue(e, calculateIndex(0));\n                                                });\n                                              }\n\n                                              if (entry.refs && result.length + entry.refs.length <= length) {\n                                                entry.refs.forEach(function (e, i) {\n                                                  return addToLoadingQueue(e, calculateIndex(i));\n                                                });\n                                              }\n                                            }\n                                          }\n                                        };\n\n                                        if (onStartProgressCallback) {\n                                          onStartProgressCallback(hash, null, 0, result.length);\n                                        }\n\n                                        _context3.prev = 3;\n                                        _context3.next = 6;\n                                        return Entry.fromMultihash(ipfs, hash);\n\n                                      case 6:\n                                        entry = _context3.sent;\n\n                                        if (!(delay > 0)) {\n                                          _context3.next = 11;\n                                          break;\n                                        }\n\n                                        sleep = function sleep() {\n                                          var ms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                                          return new Promise(function (resolve) {\n                                            return setTimeout(resolve, ms);\n                                          });\n                                        };\n\n                                        _context3.next = 11;\n                                        return sleep(delay);\n\n                                      case 11:\n                                        // Add it to the results\n                                        addToResults(entry);\n                                        resolve();\n                                        _context3.next = 18;\n                                        break;\n\n                                      case 15:\n                                        _context3.prev = 15;\n                                        _context3.t0 = _context3[\"catch\"](3);\n                                        reject(_context3.t0);\n\n                                      case 18:\n                                        _context3.prev = 18;\n                                        clearTimeout(timer);\n                                        return _context3.finish(18);\n\n                                      case 21:\n                                      case \"end\":\n                                        return _context3.stop();\n                                    }\n                                  }\n                                }, _callee3, null, [[3, 15, 18, 21]]);\n                              }));\n\n                              return function (_x8, _x9) {\n                                return _ref5.apply(this, arguments);\n                              };\n                            }()));\n\n                          case 3:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n\n                  return function fetchEntry(_x7) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }(); // One loop of processing the loading queue\n\n\n                _processQueue = /*#__PURE__*/function () {\n                  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n                    var nexts;\n                    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            if (!(running < concurrency)) {\n                              _context5.next = 6;\n                              break;\n                            }\n\n                            nexts = getNextFromQueue(concurrency);\n                            running += nexts.length;\n                            _context5.next = 5;\n                            return pMap(nexts, fetchEntry, {\n                              concurrency: concurrency\n                            });\n\n                          case 5:\n                            running -= nexts.length;\n\n                          case 6:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5);\n                  }));\n\n                  return function _processQueue() {\n                    return _ref6.apply(this, arguments);\n                  };\n                }(); // Add entries to exclude from processing to the cache before we start\n\n\n                exclude.forEach(addToExcludeCache); // Fetch entries\n\n                _context6.next = 18;\n                return pDoWhilst(_processQueue, loadingQueueHasMore);\n\n              case 18:\n                return _context6.abrupt(\"return\", result);\n\n              case 19:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function fetchAll(_x5, _x6) {\n        return _fetchAll.apply(this, arguments);\n      }\n\n      return fetchAll;\n    }()\n  }]);\n\n  return EntryIO;\n}();\n\nmodule.exports = EntryIO;","map":{"version":3,"names":["pMap","require","pDoWhilst","Entry","hasItems","arr","length","EntryIO","ipfs","hashes","exclude","shouldExclude","timeout","concurrency","onProgressCallback","fetchOne","hash","fetchAll","concatArrays","arr1","arr2","concat","flatten","reduce","Math","max","res","onStartProgressCallback","delay","result","cache","loadingCache","loadingQueue","Array","isArray","slice","running","maxClock","minClock","loadingQueueHasMore","Object","values","find","undefined","addToLoadingQueue","e","idx","includes","push","getNextFromQueue","getNext","key","nextItems","shift","keys","addToExcludeCache","fetchEntry","Promise","resolve","reject","timer","setTimeout","console","warn","addToResults","entry","isEntry","ts","clock","time","min","isLater","calculateIndex","next","forEach","refs","i","fromMultihash","sleep","ms","clearTimeout","_processQueue","nexts","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-log/src/entry-io.js"],"sourcesContent":["'use strict'\n\nconst pMap = require('p-map')\nconst pDoWhilst = require('p-do-whilst')\nconst Entry = require('./entry')\n\nconst hasItems = arr => arr && arr.length > 0\n\nclass EntryIO {\n  // Fetch log graphs in parallel\n  static async fetchParallel (ipfs, hashes, { length, exclude = [], shouldExclude, timeout, concurrency, onProgressCallback }) {\n    const fetchOne = async (hash) => EntryIO.fetchAll(ipfs, hash, { length, exclude, shouldExclude, timeout, onProgressCallback, concurrency })\n    const concatArrays = (arr1, arr2) => arr1.concat(arr2)\n    const flatten = (arr) => arr.reduce(concatArrays, [])\n    const res = await pMap(hashes, fetchOne, { concurrency: Math.max(concurrency || hashes.length, 1) })\n    return flatten(res)\n  }\n\n  /**\n   * Fetch log entries\n   *\n   * @param {IPFS} [ipfs] An IPFS instance\n   * @param {string} [hash] Multihash of the entry to fetch\n   * @param {string} [parent] Parent of the node to be fetched\n   * @param {Object} [all] Entries to skip\n   * @param {Number} [amount=-1] How many entries to fetch\n   * @param {Number} [depth=0] Current depth of the recursion\n   * @param {function(entry)} shouldExclude A function that can be passed to determine whether a specific hash should be excluded, ie. not fetched. The function should return true to indicate exclusion, otherwise return false.\n   * @param {function(entry)} onProgressCallback Called when an entry was fetched\n   * @returns {Promise<Array<Entry>>}\n   */\n  static async fetchAll (ipfs, hashes, { length = -1, exclude = [], shouldExclude, timeout, onProgressCallback, onStartProgressCallback, concurrency = 32, delay = 0 } = {}) {\n    const result = []\n    const cache = {}\n    const loadingCache = {}\n    const loadingQueue = Array.isArray(hashes)\n      ? { 0: hashes.slice() }\n      : { 0: [hashes] }\n    let running = 0 // keep track of how many entries are being fetched at any time\n    let maxClock = 0 // keep track of the latest clock time during load\n    let minClock = 0 // keep track of the minimum clock time during load\n    shouldExclude = shouldExclude || (() => false) // default fn returns false to not exclude any hash\n\n    // Does the loading queue have more to process?\n    const loadingQueueHasMore = () => Object.values(loadingQueue).find(hasItems) !== undefined\n\n    // Add a multihash to the loading queue\n    const addToLoadingQueue = (e, idx) => {\n      if (!loadingCache[e] && !shouldExclude(e)) {\n        if (!loadingQueue[idx]) loadingQueue[idx] = []\n        if (!loadingQueue[idx].includes(e)) {\n          loadingQueue[idx].push(e)\n        }\n        loadingCache[e] = true\n      }\n    }\n\n    // Get the next items to process from the loading queue\n    const getNextFromQueue = (length = 1) => {\n      const getNext = (res, key, idx) => {\n        const nextItems = loadingQueue[key]\n        while (nextItems.length > 0 && res.length < length) {\n          const hash = nextItems.shift()\n          res.push(hash)\n        }\n        if (nextItems.length === 0) {\n          delete loadingQueue[key]\n        }\n        return res\n      }\n      return Object.keys(loadingQueue).reduce(getNext, [])\n    }\n\n    // Add entries that we don't need to fetch to the \"cache\"\n    const addToExcludeCache = e => { cache[e.hash || e] = true }\n\n    // Fetch one entry and add it to the results\n    const fetchEntry = async (hash) => {\n      if (!hash || cache[hash] || shouldExclude(hash)) {\n        return\n      }\n\n      /* eslint-disable no-async-promise-executor */\n      return new Promise(async (resolve, reject) => {\n        // Resolve the promise after a timeout (if given) in order to\n        // not get stuck loading a block that is unreachable\n        const timer = timeout && timeout > 0\n          ? setTimeout(() => {\n              console.warn(`Warning: Couldn't fetch entry '${hash}', request timed out (${timeout}ms)`)\n              resolve()\n            }, timeout)\n          : null\n\n        const addToResults = (entry) => {\n          if (Entry.isEntry(entry) && !cache[entry.hash] && !shouldExclude(entry.hash)) {\n            const ts = entry.clock.time\n\n            // Update min/max clocks\n            maxClock = Math.max(maxClock, ts)\n            minClock = result.length > 0\n              ? Math.min(result[result.length - 1].clock.time, minClock)\n              : maxClock\n\n            const isLater = (result.length >= length && ts >= minClock)\n            const calculateIndex = (idx) => maxClock - ts + ((idx + 1) * idx)\n\n            // Add the entry to the results if\n            // 1) we're fetching all entries\n            // 2) results is not filled yet\n            // the clock of the entry is later than current known minimum clock time\n            if ((length < 0 || result.length < length || isLater) && !shouldExclude(entry.hash) && !cache[entry.hash]) {\n              result.push(entry)\n              cache[entry.hash] = true\n\n              if (onProgressCallback) {\n                onProgressCallback(entry)\n              }\n            }\n\n            if (length < 0) {\n              // If we're fetching all entries (length === -1), adds nexts and refs to the queue\n              entry.next.forEach(addToLoadingQueue)\n              if (entry.refs) entry.refs.forEach(addToLoadingQueue)\n            } else {\n              // If we're fetching entries up to certain length,\n              // fetch the next if result is filled up, to make sure we \"check\"\n              // the next entry if its clock is later than what we have in the result\n              if (result.length < length || ts > minClock || (ts === minClock && !cache[entry.hash] && !shouldExclude(entry.hash))) {\n                entry.next.forEach(e => addToLoadingQueue(e, calculateIndex(0)))\n              }\n              if (entry.refs && (result.length + entry.refs.length <= length)) {\n                entry.refs.forEach((e, i) => addToLoadingQueue(e, calculateIndex(i)))\n              }\n            }\n          }\n        }\n\n        if (onStartProgressCallback) {\n          onStartProgressCallback(hash, null, 0, result.length)\n        }\n\n        try {\n          // Load the entry\n          const entry = await Entry.fromMultihash(ipfs, hash)\n          // Simulate network latency (for debugging purposes)\n          if (delay > 0) {\n            const sleep = (ms = 0) => new Promise(resolve => setTimeout(resolve, ms))\n            await sleep(delay)\n          }\n          // Add it to the results\n          addToResults(entry)\n          resolve()\n        } catch (e) {\n          reject(e)\n        } finally {\n          clearTimeout(timer)\n        }\n      })\n    }\n\n    // One loop of processing the loading queue\n    const _processQueue = async () => {\n      if (running < concurrency) {\n        const nexts = getNextFromQueue(concurrency)\n        running += nexts.length\n        await pMap(nexts, fetchEntry, { concurrency })\n        running -= nexts.length\n      }\n    }\n\n    // Add entries to exclude from processing to the cache before we start\n    exclude.forEach(addToExcludeCache)\n\n    // Fetch entries\n    await pDoWhilst(_processQueue, loadingQueueHasMore)\n\n    return result\n  }\n}\n\nmodule.exports = EntryIO\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}