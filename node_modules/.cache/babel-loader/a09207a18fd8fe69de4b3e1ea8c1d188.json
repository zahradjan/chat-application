{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar errCode = require('err-code');\n\nvar _require = require('uint8arrays/concat'),\n    uint8arraysConcat = _require.concat;\n\nvar _require2 = require('uint8arrays/from-string'),\n    uint8arraysFromString = _require2.fromString; // @ts-ignore libp2p-crypto does not support types\n\n\nvar cryptoKeys = require('libp2p-crypto/src/keys');\n\nvar PeerId = require('peer-id');\n\nvar varint = require('varint');\n\nvar _require3 = require('uint8arrays/equals'),\n    uint8arraysEquals = _require3.equals;\n\nvar _require4 = require('../../errors'),\n    codes = _require4.codes;\n\nvar _require5 = require('./envelope'),\n    Protobuf = _require5.Envelope;\n/**\n * @typedef {import('libp2p-interfaces/src/record/types').Record} Record\n */\n\n\nvar Envelope = /*#__PURE__*/function () {\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   *\n   * @class\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {Uint8Array} params.payloadType\n   * @param {Uint8Array} params.payload - marshaled record\n   * @param {Uint8Array} params.signature - signature of the domain string :: type hint :: payload.\n   */\n  function Envelope(_ref) {\n    var peerId = _ref.peerId,\n        payloadType = _ref.payloadType,\n        payload = _ref.payload,\n        signature = _ref.signature;\n\n    _classCallCheck(this, Envelope);\n\n    this.peerId = peerId;\n    this.payloadType = payloadType;\n    this.payload = payload;\n    this.signature = signature; // Cache\n\n    this._marshal = undefined;\n  }\n  /**\n   * Marshal the envelope content.\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  _createClass(Envelope, [{\n    key: \"marshal\",\n    value: function marshal() {\n      if (this._marshal) {\n        return this._marshal;\n      }\n\n      var publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey);\n      this._marshal = Protobuf.encode({\n        publicKey: publicKey,\n        payloadType: this.payloadType,\n        payload: this.payload,\n        signature: this.signature\n      }).finish();\n      return this._marshal;\n    }\n    /**\n     * Verifies if the other Envelope is identical to this one.\n     *\n     * @param {Envelope} other\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) && uint8arraysEquals(this.payloadType, other.payloadType) && uint8arraysEquals(this.payload, other.payload) && uint8arraysEquals(this.signature, other.signature);\n    }\n    /**\n     * Validate envelope data signature for the given domain.\n     *\n     * @param {string} domain\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate(domain) {\n      var signData = formatSignaturePayload(domain, this.payloadType, this.payload);\n      return this.peerId.pubKey.verify(signData, this.signature);\n    }\n  }]);\n\n  return Envelope;\n}();\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature.\n *\n * @param {string} domain\n * @param {Uint8Array} payloadType\n * @param {Uint8Array} payload\n * @returns {Uint8Array}\n */\n\n\nvar formatSignaturePayload = function formatSignaturePayload(domain, payloadType, payload) {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n  var domainUint8Array = uint8arraysFromString(domain);\n  var domainLength = varint.encode(domainUint8Array.byteLength);\n  var payloadTypeLength = varint.encode(payloadType.length);\n  var payloadLength = varint.encode(payload.length);\n  return uint8arraysConcat([new Uint8Array(domainLength), domainUint8Array, new Uint8Array(payloadTypeLength), payloadType, new Uint8Array(payloadLength), payload]);\n};\n/**\n * Unmarshal a serialized Envelope protobuf message.\n *\n * @param {Uint8Array} data\n * @returns {Promise<Envelope>}\n */\n\n\nEnvelope.createFromProtobuf = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data) {\n    var envelopeData, peerId;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            envelopeData = Protobuf.decode(data);\n            _context.next = 3;\n            return PeerId.createFromPubKey(envelopeData.publicKey);\n\n          case 3:\n            peerId = _context.sent;\n            return _context.abrupt(\"return\", new Envelope({\n              peerId: peerId,\n              payloadType: envelopeData.payloadType,\n              payload: envelopeData.payload,\n              signature: envelopeData.signature\n            }));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n * and signs it with the given peerId's private key.\n *\n * @async\n * @param {Record} record\n * @param {PeerId} peerId\n * @returns {Promise<Envelope>}\n */\n\n\nEnvelope.seal = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(record, peerId) {\n    var domain, payloadType, payload, signData, signature;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            domain = record.domain;\n            payloadType = record.codec;\n            payload = record.marshal();\n            signData = formatSignaturePayload(domain, payloadType, payload);\n            _context2.next = 6;\n            return peerId.privKey.sign(signData);\n\n          case 6:\n            signature = _context2.sent;\n            return _context2.abrupt(\"return\", new Envelope({\n              peerId: peerId,\n              payloadType: payloadType,\n              payload: payload,\n              signature: signature\n            }));\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x2, _x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Open and certify a given marshalled envelope.\n * Data is unmarshalled and the signature validated for the given domain.\n *\n * @param {Uint8Array} data\n * @param {string} domain\n * @returns {Promise<Envelope>}\n */\n\n\nEnvelope.openAndCertify = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(data, domain) {\n    var envelope, valid;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return Envelope.createFromProtobuf(data);\n\n          case 2:\n            envelope = _context3.sent;\n            _context3.next = 5;\n            return envelope.validate(domain);\n\n          case 5:\n            valid = _context3.sent;\n\n            if (valid) {\n              _context3.next = 8;\n              break;\n            }\n\n            throw errCode(new Error('envelope signature is not valid for the given domain'), codes.ERR_SIGNATURE_NOT_VALID);\n\n          case 8:\n            return _context3.abrupt(\"return\", envelope);\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x4, _x5) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nmodule.exports = Envelope;","map":{"version":3,"names":["errCode","require","uint8arraysConcat","concat","uint8arraysFromString","fromString","cryptoKeys","PeerId","varint","uint8arraysEquals","equals","codes","Protobuf","Envelope","peerId","payloadType","payload","signature","_marshal","undefined","publicKey","marshalPublicKey","pubKey","encode","finish","other","bytes","domain","signData","formatSignaturePayload","verify","domainUint8Array","domainLength","byteLength","payloadTypeLength","length","payloadLength","Uint8Array","createFromProtobuf","data","envelopeData","decode","createFromPubKey","seal","record","codec","marshal","privKey","sign","openAndCertify","envelope","validate","valid","Error","ERR_SIGNATURE_NOT_VALID","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/record/envelope/index.js"],"sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst { concat: uint8arraysConcat } = require('uint8arrays/concat')\nconst { fromString: uint8arraysFromString } = require('uint8arrays/from-string')\n// @ts-ignore libp2p-crypto does not support types\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst PeerId = require('peer-id')\nconst varint = require('varint')\nconst { equals: uint8arraysEquals } = require('uint8arrays/equals')\n\nconst { codes } = require('../../errors')\nconst { Envelope: Protobuf } = require('./envelope')\n\n/**\n * @typedef {import('libp2p-interfaces/src/record/types').Record} Record\n */\n\nclass Envelope {\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   *\n   * @class\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {Uint8Array} params.payloadType\n   * @param {Uint8Array} params.payload - marshaled record\n   * @param {Uint8Array} params.signature - signature of the domain string :: type hint :: payload.\n   */\n  constructor ({ peerId, payloadType, payload, signature }) {\n    this.peerId = peerId\n    this.payloadType = payloadType\n    this.payload = payload\n    this.signature = signature\n\n    // Cache\n    this._marshal = undefined\n  }\n\n  /**\n   * Marshal the envelope content.\n   *\n   * @returns {Uint8Array}\n   */\n  marshal () {\n    if (this._marshal) {\n      return this._marshal\n    }\n\n    const publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey)\n\n    this._marshal = Protobuf.encode({\n      publicKey: publicKey,\n      payloadType: this.payloadType,\n      payload: this.payload,\n      signature: this.signature\n    }).finish()\n\n    return this._marshal\n  }\n\n  /**\n   * Verifies if the other Envelope is identical to this one.\n   *\n   * @param {Envelope} other\n   * @returns {boolean}\n   */\n  equals (other) {\n    return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) &&\n      uint8arraysEquals(this.payloadType, other.payloadType) &&\n      uint8arraysEquals(this.payload, other.payload) &&\n      uint8arraysEquals(this.signature, other.signature)\n  }\n\n  /**\n   * Validate envelope data signature for the given domain.\n   *\n   * @param {string} domain\n   * @returns {Promise<boolean>}\n   */\n  validate (domain) {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload)\n\n    return this.peerId.pubKey.verify(signData, this.signature)\n  }\n}\n\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature.\n *\n * @param {string} domain\n * @param {Uint8Array} payloadType\n * @param {Uint8Array} payload\n * @returns {Uint8Array}\n */\nconst formatSignaturePayload = (domain, payloadType, payload) => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n\n  const domainUint8Array = uint8arraysFromString(domain)\n  const domainLength = varint.encode(domainUint8Array.byteLength)\n  const payloadTypeLength = varint.encode(payloadType.length)\n  const payloadLength = varint.encode(payload.length)\n\n  return uint8arraysConcat([\n    new Uint8Array(domainLength),\n    domainUint8Array,\n    new Uint8Array(payloadTypeLength),\n    payloadType,\n    new Uint8Array(payloadLength),\n    payload\n  ])\n}\n\n/**\n * Unmarshal a serialized Envelope protobuf message.\n *\n * @param {Uint8Array} data\n * @returns {Promise<Envelope>}\n */\nEnvelope.createFromProtobuf = async (data) => {\n  const envelopeData = Protobuf.decode(data)\n  const peerId = await PeerId.createFromPubKey(envelopeData.publicKey)\n\n  return new Envelope({\n    peerId,\n    payloadType: envelopeData.payloadType,\n    payload: envelopeData.payload,\n    signature: envelopeData.signature\n  })\n}\n\n/**\n * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n * and signs it with the given peerId's private key.\n *\n * @async\n * @param {Record} record\n * @param {PeerId} peerId\n * @returns {Promise<Envelope>}\n */\nEnvelope.seal = async (record, peerId) => {\n  const domain = record.domain\n  const payloadType = record.codec\n  const payload = record.marshal()\n\n  const signData = formatSignaturePayload(domain, payloadType, payload)\n  const signature = await peerId.privKey.sign(signData)\n\n  return new Envelope({\n    peerId,\n    payloadType,\n    payload,\n    signature\n  })\n}\n\n/**\n * Open and certify a given marshalled envelope.\n * Data is unmarshalled and the signature validated for the given domain.\n *\n * @param {Uint8Array} data\n * @param {string} domain\n * @returns {Promise<Envelope>}\n */\nEnvelope.openAndCertify = async (data, domain) => {\n  const envelope = await Envelope.createFromProtobuf(data)\n  const valid = await envelope.validate(domain)\n\n  if (!valid) {\n    throw errCode(new Error('envelope signature is not valid for the given domain'), codes.ERR_SIGNATURE_NOT_VALID)\n  }\n\n  return envelope\n}\n\nmodule.exports = Envelope\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}