{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p'), {\n  error: debug('libp2p:err')\n});\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst errCode = require('err-code');\n\nconst PeerId = require('peer-id');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerRouting = require('./peer-routing');\n\nconst ContentRouting = require('./content-routing');\n\nconst getPeer = require('./get-peer');\n\nconst {\n  validate: validateConfig\n} = require('./config');\n\nconst {\n  codes,\n  messages\n} = require('./errors');\n\nconst AddressManager = require('./address-manager');\n\nconst ConnectionManager = require('./connection-manager');\n\nconst Circuit = require('./circuit/transport');\n\nconst Relay = require('./circuit');\n\nconst Dialer = require('./dialer');\n\nconst Keychain = require('./keychain');\n\nconst Metrics = require('./metrics');\n\nconst TransportManager = require('./transport-manager');\n\nconst Upgrader = require('./upgrader');\n\nconst PeerStore = require('./peer-store');\n\nconst PubsubAdapter = require('./pubsub-adapter');\n\nconst PersistentPeerStore = require('./peer-store/persistent');\n\nconst Registrar = require('./registrar');\n\nconst ping = require('./ping');\n\nconst IdentifyService = require('./identify');\n\nconst NatManager = require('./nat-manager');\n\nconst {\n  updateSelfPeerRecord\n} = require('./record/utils');\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n * @typedef {import('libp2p-interfaces/src/peer-discovery/types').PeerDiscoveryFactory} PeerDiscoveryFactory\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/pubsub')} Pubsub\n * @typedef {import('libp2p-interfaces/src/pubsub').PubsubOptions} PubsubOptions\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('./pnet')} Protector\n */\n\n/**\n * @typedef {Object} HandlerProps\n * @property {Connection} connection\n * @property {MuxedStream} stream\n * @property {string} protocol\n *\n * @typedef {Object} RandomWalkOptions\n * @property {boolean} [enabled = false]\n * @property {number} [queriesPerPeriod = 1]\n * @property {number} [interval = 300e3]\n * @property {number} [timeout = 10e3]\n *\n * @typedef {Object} DhtOptions\n * @property {boolean} [enabled = false]\n * @property {number} [kBucketSize = 20]\n * @property {RandomWalkOptions} [randomWalk]\n * @property {boolean} [clientMode]\n * @property {import('libp2p-interfaces/src/types').DhtSelectors} [selectors]\n * @property {import('libp2p-interfaces/src/types').DhtValidators} [validators]\n *\n * @typedef {Object} KeychainOptions\n * @property {Datastore} [datastore]\n *\n * @typedef {Object} PeerStoreOptions\n * @property {boolean} persistence\n *\n * @typedef {Object} PubsubLocalOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} MetricsOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} RelayOptions\n * @property {boolean} [enabled = true]\n * @property {import('./circuit').RelayAdvertiseOptions} [advertise]\n * @property {import('./circuit').HopOptions} [hop]\n * @property {import('./circuit').AutoRelayOptions} [autoRelay]\n *\n * @typedef {Object} Libp2pConfig\n * @property {DhtOptions} [dht] dht module options\n * @property {import('./nat-manager').NatManagerOptions} [nat]\n * @property {Record<string, Object|boolean>} [peerDiscovery]\n * @property {PubsubLocalOptions & PubsubOptions} [pubsub] pubsub module options\n * @property {RelayOptions} [relay]\n * @property {Record<string, Object>} [transport] transport options indexed by transport key\n *\n * @typedef {Object} Libp2pModules\n * @property {TransportFactory[]} transport\n * @property {MuxerFactory[]} streamMuxer\n * @property {Crypto[]} connEncryption\n * @property {PeerDiscoveryFactory[]} [peerDiscovery]\n * @property {PeerRoutingModule[]} [peerRouting]\n * @property {ContentRoutingModule[]} [contentRouting]\n * @property {Object} [dht]\n * @property {{new(...args: any[]): Pubsub}} [pubsub]\n * @property {Protector} [connProtector]\n *\n * @typedef {Object} Libp2pOptions\n * @property {Libp2pModules} modules libp2p modules to use\n * @property {import('./address-manager').AddressManagerOptions} [addresses]\n * @property {import('./connection-manager').ConnectionManagerOptions} [connectionManager]\n * @property {Datastore} [datastore]\n * @property {import('./dialer').DialerOptions} [dialer]\n * @property {import('./identify/index').HostProperties} [host] libp2p host\n * @property {KeychainOptions & import('./keychain/index').KeychainOptions} [keychain]\n * @property {MetricsOptions & import('./metrics').MetricsOptions} [metrics]\n * @property {import('./peer-routing').PeerRoutingOptions} [peerRouting]\n * @property {PeerStoreOptions & import('./peer-store/persistent').PersistentPeerStoreOptions} [peerStore]\n * @property {import('./transport-manager').TransportManagerOptions} [transportManager]\n * @property {Libp2pConfig} [config]\n *\n * @typedef {Object} constructorOptions\n * @property {PeerId} peerId\n *\n * @typedef {Object} CreateOptions\n * @property {PeerId} [peerId]\n *\n * @extends {EventEmitter}\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\n\n\nclass Libp2p extends EventEmitter {\n  /**\n   * Like `new Libp2p(options)` except it will create a `PeerId`\n   * instance if one is not provided in options.\n   *\n   * @param {Libp2pOptions & CreateOptions} options - Libp2p configuration options\n   * @returns {Promise<Libp2p>}\n   */\n  static async create(options) {\n    if (options.peerId) {\n      // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n      return new Libp2p(options);\n    }\n\n    const peerId = await PeerId.create();\n    options.peerId = peerId; // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n\n    return new Libp2p(options);\n  }\n  /**\n   * Libp2p node.\n   *\n   * @class\n   * @param {Libp2pOptions & constructorOptions} _options\n   */\n\n\n  constructor(_options) {\n    super(); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    this._options = validateConfig(_options);\n    /** @type {PeerId} */\n\n    this.peerId = this._options.peerId;\n    this.datastore = this._options.datastore;\n    this.peerStore = this.datastore && this._options.peerStore.persistence ? new PersistentPeerStore({\n      peerId: this.peerId,\n      datastore: this.datastore,\n      ...this._options.peerStore\n    }) : new PeerStore({\n      peerId: this.peerId\n    }); // Addresses {listen, announce, noAnnounce}\n\n    this.addresses = this._options.addresses;\n    this.addressManager = new AddressManager(this.peerId, this._options.addresses); // when addresses change, update our peer record\n\n    this.addressManager.on('change:addresses', () => {\n      updateSelfPeerRecord(this).catch(err => {\n        log.error('Error updating self peer record', err);\n      });\n    });\n    this._modules = this._options.modules;\n    this._config = this._options.config;\n    this._transport = []; // Transport instances/references\n\n    this._discovery = new Map(); // Discovery service instances/references\n    // Create the Connection Manager\n\n    this.connectionManager = new ConnectionManager(this, {\n      autoDial: this._config.peerDiscovery.autoDial,\n      ...this._options.connectionManager\n    }); // Create Metrics\n\n    if (this._options.metrics.enabled) {\n      this.metrics = new Metrics({ ...this._options.metrics,\n        connectionManager: this.connectionManager\n      });\n    } // Create keychain\n\n\n    if (this._options.keychain && this._options.keychain.datastore) {\n      log('creating keychain');\n      const keychainOpts = Keychain.generateOptions();\n      this.keychain = new Keychain(this._options.keychain.datastore, { ...keychainOpts,\n        ...this._options.keychain\n      });\n      log('keychain constructed');\n    } // Setup the Upgrader\n\n\n    this.upgrader = new Upgrader({\n      localPeer: this.peerId,\n      metrics: this.metrics,\n      onConnection: connection => this.connectionManager.onConnect(connection),\n      onConnectionEnd: connection => this.connectionManager.onDisconnect(connection)\n    }); // Setup the transport manager\n\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader,\n      faultTolerance: this._options.transportManager.faultTolerance\n    }); // Create the Nat Manager\n\n    this.natManager = new NatManager({\n      peerId: this.peerId,\n      addressManager: this.addressManager,\n      transportManager: this.transportManager,\n      // @ts-ignore Nat typedef is not understood as Object\n      ...this._options.config.nat\n    }); // Create the Registrar\n\n    this.registrar = new Registrar({\n      peerStore: this.peerStore,\n      connectionManager: this.connectionManager\n    });\n    this.handle = this.handle.bind(this);\n    this.registrar.handle = this.handle; // Attach crypto channels\n\n    if (!this._modules.connEncryption || !this._modules.connEncryption.length) {\n      throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED);\n    }\n\n    const cryptos = this._modules.connEncryption;\n    cryptos.forEach(crypto => {\n      this.upgrader.cryptos.set(crypto.protocol, crypto);\n    });\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      peerStore: this.peerStore,\n      ...this._options.dialer\n    });\n\n    this._modules.transport.forEach(Transport => {\n      const key = Transport.prototype[Symbol.toStringTag];\n      const transportOptions = this._config.transport[key];\n      this.transportManager.add(key, Transport, transportOptions);\n    });\n\n    if (this._config.relay.enabled) {\n      // @ts-ignore Circuit prototype\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);\n      this.relay = new Relay(this);\n    } // Attach stream multiplexers\n\n\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer;\n      muxers.forEach(muxer => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer);\n      }); // Add the identify service since we can multiplex\n\n      this.identifyService = new IdentifyService({\n        libp2p: this\n      });\n      this.handle(Object.values(IdentifyService.getProtocolStr(this)), this.identifyService.handleMessage);\n    } // Attach private network protector\n\n\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector;\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {\n      // eslint-disable-line no-undef\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (this._modules.dht) {\n      const DHT = this._modules.dht; // @ts-ignore Object is not constructable\n\n      this._dht = new DHT({\n        libp2p: this,\n        dialer: this.dialer,\n        peerId: this.peerId,\n        peerStore: this.peerStore,\n        registrar: this.registrar,\n        datastore: this.datastore,\n        ...this._config.dht\n      });\n    } // Create pubsub if provided\n\n\n    if (this._modules.pubsub) {\n      const Pubsub = this._modules.pubsub; // using pubsub adapter with *DEPRECATED* handlers functionality\n\n      /** @type {Pubsub} */\n\n      this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub);\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    this.peerRouting = new PeerRouting(this);\n    this.contentRouting = new ContentRouting(this); // Mount default protocols\n\n    ping.mount(this);\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this);\n  }\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   *\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {boolean}\n   */\n\n\n  emit(eventName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    // TODO: do we still need this?\n    // @ts-ignore _events does not exist in libp2p\n    if (eventName === 'error' && !this._events.error) {\n      log.error(args);\n      return false;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async start() {\n    log('libp2p is starting');\n\n    try {\n      await this._onStarting();\n      await this._onDidStart();\n      log('libp2p has started');\n    } catch (err) {\n      this.emit('error', err);\n      log.error('An error occurred starting libp2p', err);\n      await this.stop();\n      throw err;\n    }\n  }\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n\n\n  async stop() {\n    log('libp2p is stopping');\n\n    try {\n      this._isStarted = false;\n      this.relay && this.relay.stop();\n      this.peerRouting.stop();\n\n      for (const service of this._discovery.values()) {\n        service.removeListener('peer', this._onDiscoveryPeer);\n      }\n\n      await Promise.all(Array.from(this._discovery.values(), s => s.stop()));\n      this._discovery = new Map();\n      await this.peerStore.stop();\n      await this.connectionManager.stop();\n      await Promise.all([this.pubsub && this.pubsub.stop(), this._dht && this._dht.stop(), this.metrics && this.metrics.stop()]);\n      await this.natManager.stop();\n      await this.transportManager.close();\n      ping.unmount(this);\n      this.dialer.destroy();\n    } catch (err) {\n      if (err) {\n        log.error(err);\n        this.emit('error', err);\n      }\n    }\n\n    log('libp2p has stopped');\n  }\n  /**\n   * Load keychain keys from the datastore.\n   * Imports the private key as 'self', if needed.\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n\n\n  async loadKeychain() {\n    if (!this.keychain) {\n      return;\n    }\n\n    try {\n      await this.keychain.findKeyByName('self');\n    } catch (err) {\n      await this.keychain.importPeer('self', this.peerId);\n    }\n  }\n\n  isStarted() {\n    return this._isStarted;\n  }\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   *\n   * @returns {Map<string, Connection[]>}\n   */\n\n\n  get connections() {\n    return this.connectionManager.connections;\n  }\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n\n\n  dial(peer, options) {\n    return this._dial(peer, options);\n  }\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async dialProtocol(peer, protocols, options) {\n    if (!protocols || !protocols.length) {\n      throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);\n    }\n\n    const connection = await this._dial(peer, options);\n    return connection.newStream(protocols);\n  }\n  /**\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @returns {Promise<Connection>}\n   */\n\n\n  async _dial(peer, options) {\n    const {\n      id,\n      multiaddrs\n    } = getPeer(peer);\n\n    if (id.equals(this.peerId)) {\n      throw errCode(new Error('Cannot dial self'), codes.ERR_DIALED_SELF);\n    }\n\n    let connection = this.connectionManager.get(id);\n\n    if (!connection) {\n      connection = await this.dialer.connectToPeer(peer, options);\n    } else if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs);\n    }\n\n    return connection;\n  }\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  get multiaddrs() {\n    let addrs = this.addressManager.getAnnounceAddrs().map(ma => ma.toString());\n\n    if (!addrs.length) {\n      // no configured announce addrs, add configured listen addresses\n      addrs = this.transportManager.getAddrs().map(ma => ma.toString());\n    }\n\n    addrs = addrs.concat(this.addressManager.getObservedAddrs().map(ma => ma.toString()));\n    const announceFilter = this._options.addresses.announceFilter; // dedupe multiaddrs\n\n    const addrSet = new Set(addrs); // Create advertising list\n\n    return announceFilter(Array.from(addrSet).map(str => new Multiaddr(str)));\n  }\n  /**\n   * Disconnects all connections to the given `peer`\n   *\n   * @param {PeerId|Multiaddr|string} peer - the peer to close connections to\n   * @returns {Promise<void>}\n   */\n\n\n  async hangUp(peer) {\n    const {\n      id\n    } = getPeer(peer);\n    const connections = this.connectionManager.connections.get(id.toB58String());\n\n    if (!connections) {\n      return;\n    }\n\n    await Promise.all(connections.map(connection => {\n      return connection.close();\n    }));\n  }\n  /**\n   * Pings the given peer in order to obtain the operation latency.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to ping\n   * @returns {Promise<number>}\n   */\n\n\n  ping(peer) {\n    const {\n      id,\n      multiaddrs\n    } = getPeer(peer); // If received multiaddr, ping it\n\n    if (multiaddrs) {\n      return ping(this, multiaddrs[0]);\n    }\n\n    return ping(this, id);\n  }\n  /**\n   * Registers the `handler` for each protocol\n   *\n   * @param {string[]|string} protocols\n   * @param {(props: HandlerProps) => void} handler\n   */\n\n\n  handle(protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler);\n    }); // Add new protocols to self protocols in the Protobook\n\n    this.peerStore.protoBook.add(this.peerId, protocols);\n  }\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @param {string[]|string} protocols\n   */\n\n\n  unhandle(protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol);\n    }); // Remove protocols from self protocols in the Protobook\n\n    this.peerStore.protoBook.remove(this.peerId, protocols);\n  }\n\n  async _onStarting() {\n    // Listen on the provided transports for the provided addresses\n    const addrs = this.addressManager.getListenAddrs();\n    await this.transportManager.listen(addrs); // Manage your NATs\n\n    this.natManager.start(); // Start PeerStore\n\n    await this.peerStore.start();\n\n    if (this._config.pubsub.enabled) {\n      this.pubsub && this.pubsub.start();\n    } // DHT subsystem\n\n\n    if (this._config.dht.enabled) {\n      this._dht && this._dht.start(); // TODO: this should be modified once random-walk is used as\n      // the other discovery modules\n\n      this._dht.on('peer', this._onDiscoveryPeer);\n    } // Start metrics if present\n\n\n    this.metrics && this.metrics.start();\n  }\n  /**\n   * Called when libp2p has started and before it returns\n   *\n   * @private\n   */\n\n\n  async _onDidStart() {\n    this._isStarted = true;\n    this.peerStore.on('peer', peerId => {\n      this.emit('peer:discovery', peerId);\n\n      this._maybeConnect(peerId);\n    }); // Once we start, emit any peers we may have already discovered\n    // TODO: this should be removed, as we already discovered these peers in the past\n\n    for (const peer of this.peerStore.peers.values()) {\n      this.emit('peer:discovery', peer.id);\n    }\n\n    this.connectionManager.start(); // Peer discovery\n\n    await this._setupPeerDiscovery(); // Relay\n\n    this.relay && this.relay.start();\n    this.peerRouting.start();\n  }\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   *\n   * @private\n   * @param {{ id: PeerId, multiaddrs: Multiaddr[], protocols: string[] }} peer\n   */\n\n\n  _onDiscoveryPeer(peer) {\n    if (peer.id.toB58String() === this.peerId.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF));\n      return;\n    }\n\n    peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs);\n    peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols);\n  }\n  /**\n   * Will dial to the given `peerId` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minConnections.\n   *\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  async _maybeConnect(peerId) {\n    // If auto dialing is on and we have no connection to the peer, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {\n      const minConnections = this._options.connectionManager.minConnections || 0;\n\n      if (minConnections > this.connectionManager.size) {\n        log('connecting to discovered peer %s', peerId.toB58String());\n\n        try {\n          await this.dialer.connectToPeer(peerId);\n        } catch (err) {\n          log.error(`could not connect to discovered peer ${peerId.toB58String()} with ${err}`);\n        }\n      }\n    }\n  }\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n\n\n  async _setupPeerDiscovery() {\n    /**\n     * @param {PeerDiscoveryFactory} DiscoveryService\n     */\n    const setupService = DiscoveryService => {\n      let config = {\n        enabled: true // on by default\n\n      };\n\n      if (DiscoveryService.tag && this._config.peerDiscovery && this._config.peerDiscovery[DiscoveryService.tag]) {\n        // @ts-ignore PeerDiscovery not understood as an Object for spread\n        config = { ...config,\n          ...this._config.peerDiscovery[DiscoveryService.tag]\n        };\n      }\n\n      if (config.enabled && !this._discovery.has(DiscoveryService.tag)) {\n        // not already added\n        let discoveryService;\n\n        if (typeof DiscoveryService === 'function') {\n          // @ts-ignore DiscoveryService has no constructor type inferred\n          discoveryService = new DiscoveryService(Object.assign({}, config, {\n            peerId: this.peerId,\n            libp2p: this\n          }));\n        } else {\n          discoveryService = DiscoveryService;\n        }\n\n        discoveryService.on('peer', this._onDiscoveryPeer);\n\n        this._discovery.set(DiscoveryService.tag, discoveryService);\n      }\n    }; // Discovery modules\n\n\n    for (const DiscoveryService of this._modules.peerDiscovery || []) {\n      setupService(DiscoveryService);\n    } // Transport modules with discovery\n\n\n    for (const Transport of this.transportManager.getTransports()) {\n      // @ts-ignore Transport interface does not include discovery\n      if (Transport.discovery) {\n        // @ts-ignore Transport interface does not include discovery\n        setupService(Transport.discovery);\n      }\n    }\n\n    await Promise.all(Array.from(this._discovery.values(), d => d.start()));\n  }\n\n}\n\nmodule.exports = Libp2p;","map":{"version":3,"names":["debug","require","log","Object","assign","error","EventEmitter","errCode","PeerId","Multiaddr","PeerRouting","ContentRouting","getPeer","validate","validateConfig","codes","messages","AddressManager","ConnectionManager","Circuit","Relay","Dialer","Keychain","Metrics","TransportManager","Upgrader","PeerStore","PubsubAdapter","PersistentPeerStore","Registrar","ping","IdentifyService","NatManager","updateSelfPeerRecord","Libp2p","create","options","peerId","constructor","_options","datastore","peerStore","persistence","addresses","addressManager","on","catch","err","_modules","modules","_config","config","_transport","_discovery","Map","connectionManager","autoDial","peerDiscovery","metrics","enabled","keychain","keychainOpts","generateOptions","upgrader","localPeer","onConnection","connection","onConnect","onConnectionEnd","onDisconnect","transportManager","libp2p","faultTolerance","natManager","nat","registrar","handle","bind","connEncryption","length","Error","CONN_ENCRYPTION_REQUIRED","cryptos","forEach","crypto","set","protocol","dialer","transport","Transport","key","prototype","Symbol","toStringTag","transportOptions","add","relay","streamMuxer","muxers","muxer","multicodec","identifyService","values","getProtocolStr","handleMessage","connProtector","protector","globalThis","process","undefined","env","LIBP2P_FORCE_PNET","dht","DHT","_dht","pubsub","Pubsub","peerRouting","contentRouting","mount","_onDiscoveryPeer","emit","eventName","args","_events","start","_onStarting","_onDidStart","stop","_isStarted","service","removeListener","Promise","all","Array","from","s","close","unmount","destroy","loadKeychain","findKeyByName","importPeer","isStarted","connections","dial","peer","_dial","dialProtocol","protocols","ERR_INVALID_PROTOCOLS_FOR_STREAM","newStream","id","multiaddrs","equals","ERR_DIALED_SELF","get","connectToPeer","addressBook","addrs","getAnnounceAddrs","map","ma","toString","getAddrs","concat","getObservedAddrs","announceFilter","addrSet","Set","str","hangUp","toB58String","handler","isArray","protoBook","unhandle","delete","remove","getListenAddrs","listen","_maybeConnect","peers","_setupPeerDiscovery","ERR_DISCOVERED_SELF","minConnections","size","setupService","DiscoveryService","tag","has","discoveryService","getTransports","discovery","d","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p'), {\n  error: debug('libp2p:err')\n})\nconst { EventEmitter } = require('events')\n\nconst errCode = require('err-code')\nconst PeerId = require('peer-id')\nconst { Multiaddr } = require('multiaddr')\n\nconst PeerRouting = require('./peer-routing')\nconst ContentRouting = require('./content-routing')\nconst getPeer = require('./get-peer')\nconst { validate: validateConfig } = require('./config')\nconst { codes, messages } = require('./errors')\n\nconst AddressManager = require('./address-manager')\nconst ConnectionManager = require('./connection-manager')\nconst Circuit = require('./circuit/transport')\nconst Relay = require('./circuit')\nconst Dialer = require('./dialer')\nconst Keychain = require('./keychain')\nconst Metrics = require('./metrics')\nconst TransportManager = require('./transport-manager')\nconst Upgrader = require('./upgrader')\nconst PeerStore = require('./peer-store')\nconst PubsubAdapter = require('./pubsub-adapter')\nconst PersistentPeerStore = require('./peer-store/persistent')\nconst Registrar = require('./registrar')\nconst ping = require('./ping')\nconst IdentifyService = require('./identify')\nconst NatManager = require('./nat-manager')\nconst { updateSelfPeerRecord } = require('./record/utils')\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n * @typedef {import('libp2p-interfaces/src/peer-discovery/types').PeerDiscoveryFactory} PeerDiscoveryFactory\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/pubsub')} Pubsub\n * @typedef {import('libp2p-interfaces/src/pubsub').PubsubOptions} PubsubOptions\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('./pnet')} Protector\n */\n\n/**\n * @typedef {Object} HandlerProps\n * @property {Connection} connection\n * @property {MuxedStream} stream\n * @property {string} protocol\n *\n * @typedef {Object} RandomWalkOptions\n * @property {boolean} [enabled = false]\n * @property {number} [queriesPerPeriod = 1]\n * @property {number} [interval = 300e3]\n * @property {number} [timeout = 10e3]\n *\n * @typedef {Object} DhtOptions\n * @property {boolean} [enabled = false]\n * @property {number} [kBucketSize = 20]\n * @property {RandomWalkOptions} [randomWalk]\n * @property {boolean} [clientMode]\n * @property {import('libp2p-interfaces/src/types').DhtSelectors} [selectors]\n * @property {import('libp2p-interfaces/src/types').DhtValidators} [validators]\n *\n * @typedef {Object} KeychainOptions\n * @property {Datastore} [datastore]\n *\n * @typedef {Object} PeerStoreOptions\n * @property {boolean} persistence\n *\n * @typedef {Object} PubsubLocalOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} MetricsOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} RelayOptions\n * @property {boolean} [enabled = true]\n * @property {import('./circuit').RelayAdvertiseOptions} [advertise]\n * @property {import('./circuit').HopOptions} [hop]\n * @property {import('./circuit').AutoRelayOptions} [autoRelay]\n *\n * @typedef {Object} Libp2pConfig\n * @property {DhtOptions} [dht] dht module options\n * @property {import('./nat-manager').NatManagerOptions} [nat]\n * @property {Record<string, Object|boolean>} [peerDiscovery]\n * @property {PubsubLocalOptions & PubsubOptions} [pubsub] pubsub module options\n * @property {RelayOptions} [relay]\n * @property {Record<string, Object>} [transport] transport options indexed by transport key\n *\n * @typedef {Object} Libp2pModules\n * @property {TransportFactory[]} transport\n * @property {MuxerFactory[]} streamMuxer\n * @property {Crypto[]} connEncryption\n * @property {PeerDiscoveryFactory[]} [peerDiscovery]\n * @property {PeerRoutingModule[]} [peerRouting]\n * @property {ContentRoutingModule[]} [contentRouting]\n * @property {Object} [dht]\n * @property {{new(...args: any[]): Pubsub}} [pubsub]\n * @property {Protector} [connProtector]\n *\n * @typedef {Object} Libp2pOptions\n * @property {Libp2pModules} modules libp2p modules to use\n * @property {import('./address-manager').AddressManagerOptions} [addresses]\n * @property {import('./connection-manager').ConnectionManagerOptions} [connectionManager]\n * @property {Datastore} [datastore]\n * @property {import('./dialer').DialerOptions} [dialer]\n * @property {import('./identify/index').HostProperties} [host] libp2p host\n * @property {KeychainOptions & import('./keychain/index').KeychainOptions} [keychain]\n * @property {MetricsOptions & import('./metrics').MetricsOptions} [metrics]\n * @property {import('./peer-routing').PeerRoutingOptions} [peerRouting]\n * @property {PeerStoreOptions & import('./peer-store/persistent').PersistentPeerStoreOptions} [peerStore]\n * @property {import('./transport-manager').TransportManagerOptions} [transportManager]\n * @property {Libp2pConfig} [config]\n *\n * @typedef {Object} constructorOptions\n * @property {PeerId} peerId\n *\n * @typedef {Object} CreateOptions\n * @property {PeerId} [peerId]\n *\n * @extends {EventEmitter}\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\nclass Libp2p extends EventEmitter {\n  /**\n   * Like `new Libp2p(options)` except it will create a `PeerId`\n   * instance if one is not provided in options.\n   *\n   * @param {Libp2pOptions & CreateOptions} options - Libp2p configuration options\n   * @returns {Promise<Libp2p>}\n   */\n  static async create (options) {\n    if (options.peerId) {\n      // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n      return new Libp2p(options)\n    }\n\n    const peerId = await PeerId.create()\n\n    options.peerId = peerId\n    // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n    return new Libp2p(options)\n  }\n\n  /**\n   * Libp2p node.\n   *\n   * @class\n   * @param {Libp2pOptions & constructorOptions} _options\n   */\n  constructor (_options) {\n    super()\n    // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n    this._options = validateConfig(_options)\n\n    /** @type {PeerId} */\n    this.peerId = this._options.peerId\n    this.datastore = this._options.datastore\n\n    this.peerStore = (this.datastore && this._options.peerStore.persistence)\n      ? new PersistentPeerStore({\n        peerId: this.peerId,\n        datastore: this.datastore,\n        ...this._options.peerStore\n      })\n      : new PeerStore({ peerId: this.peerId })\n\n    // Addresses {listen, announce, noAnnounce}\n    this.addresses = this._options.addresses\n    this.addressManager = new AddressManager(this.peerId, this._options.addresses)\n\n    // when addresses change, update our peer record\n    this.addressManager.on('change:addresses', () => {\n      updateSelfPeerRecord(this).catch(err => {\n        log.error('Error updating self peer record', err)\n      })\n    })\n\n    this._modules = this._options.modules\n    this._config = this._options.config\n    this._transport = [] // Transport instances/references\n    this._discovery = new Map() // Discovery service instances/references\n\n    // Create the Connection Manager\n    this.connectionManager = new ConnectionManager(this, {\n      autoDial: this._config.peerDiscovery.autoDial,\n      ...this._options.connectionManager\n    })\n\n    // Create Metrics\n    if (this._options.metrics.enabled) {\n      this.metrics = new Metrics({\n        ...this._options.metrics,\n        connectionManager: this.connectionManager\n      })\n    }\n\n    // Create keychain\n    if (this._options.keychain && this._options.keychain.datastore) {\n      log('creating keychain')\n\n      const keychainOpts = Keychain.generateOptions()\n\n      this.keychain = new Keychain(this._options.keychain.datastore, {\n        ...keychainOpts,\n        ...this._options.keychain\n      })\n\n      log('keychain constructed')\n    }\n\n    // Setup the Upgrader\n    this.upgrader = new Upgrader({\n      localPeer: this.peerId,\n      metrics: this.metrics,\n      onConnection: (connection) => this.connectionManager.onConnect(connection),\n      onConnectionEnd: (connection) => this.connectionManager.onDisconnect(connection)\n    })\n\n    // Setup the transport manager\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader,\n      faultTolerance: this._options.transportManager.faultTolerance\n    })\n\n    // Create the Nat Manager\n    this.natManager = new NatManager({\n      peerId: this.peerId,\n      addressManager: this.addressManager,\n      transportManager: this.transportManager,\n      // @ts-ignore Nat typedef is not understood as Object\n      ...this._options.config.nat\n    })\n\n    // Create the Registrar\n    this.registrar = new Registrar({\n      peerStore: this.peerStore,\n      connectionManager: this.connectionManager\n    })\n\n    this.handle = this.handle.bind(this)\n    this.registrar.handle = this.handle\n\n    // Attach crypto channels\n    if (!this._modules.connEncryption || !this._modules.connEncryption.length) {\n      throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED)\n    }\n    const cryptos = this._modules.connEncryption\n    cryptos.forEach((crypto) => {\n      this.upgrader.cryptos.set(crypto.protocol, crypto)\n    })\n\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      peerStore: this.peerStore,\n      ...this._options.dialer\n    })\n\n    this._modules.transport.forEach((Transport) => {\n      const key = Transport.prototype[Symbol.toStringTag]\n      const transportOptions = this._config.transport[key]\n      this.transportManager.add(key, Transport, transportOptions)\n    })\n\n    if (this._config.relay.enabled) {\n      // @ts-ignore Circuit prototype\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit)\n      this.relay = new Relay(this)\n    }\n\n    // Attach stream multiplexers\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer\n      muxers.forEach((muxer) => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer)\n      })\n\n      // Add the identify service since we can multiplex\n      this.identifyService = new IdentifyService({ libp2p: this })\n      this.handle(Object.values(IdentifyService.getProtocolStr(this)), this.identifyService.handleMessage)\n    }\n\n    // Attach private network protector\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) { // eslint-disable-line no-undef\n      throw new Error('Private network is enforced, but no protector was provided')\n    }\n\n    // dht provided components (peerRouting, contentRouting, dht)\n    if (this._modules.dht) {\n      const DHT = this._modules.dht\n      // @ts-ignore Object is not constructable\n      this._dht = new DHT({\n        libp2p: this,\n        dialer: this.dialer,\n        peerId: this.peerId,\n        peerStore: this.peerStore,\n        registrar: this.registrar,\n        datastore: this.datastore,\n        ...this._config.dht\n      })\n    }\n\n    // Create pubsub if provided\n    if (this._modules.pubsub) {\n      const Pubsub = this._modules.pubsub\n      // using pubsub adapter with *DEPRECATED* handlers functionality\n      /** @type {Pubsub} */\n      this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub)\n    }\n\n    // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n    this.peerRouting = new PeerRouting(this)\n    this.contentRouting = new ContentRouting(this)\n\n    // Mount default protocols\n    ping.mount(this)\n\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this)\n  }\n\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   *\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {boolean}\n   */\n  emit (eventName, ...args) {\n    // TODO: do we still need this?\n    // @ts-ignore _events does not exist in libp2p\n    if (eventName === 'error' && !this._events.error) {\n      log.error(args)\n      return false\n    } else {\n      return super.emit(eventName, ...args)\n    }\n  }\n\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n  async start () {\n    log('libp2p is starting')\n\n    try {\n      await this._onStarting()\n      await this._onDidStart()\n      log('libp2p has started')\n    } catch (err) {\n      this.emit('error', err)\n      log.error('An error occurred starting libp2p', err)\n      await this.stop()\n      throw err\n    }\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n  async stop () {\n    log('libp2p is stopping')\n\n    try {\n      this._isStarted = false\n\n      this.relay && this.relay.stop()\n      this.peerRouting.stop()\n\n      for (const service of this._discovery.values()) {\n        service.removeListener('peer', this._onDiscoveryPeer)\n      }\n\n      await Promise.all(Array.from(this._discovery.values(), s => s.stop()))\n\n      this._discovery = new Map()\n\n      await this.peerStore.stop()\n      await this.connectionManager.stop()\n\n      await Promise.all([\n        this.pubsub && this.pubsub.stop(),\n        this._dht && this._dht.stop(),\n        this.metrics && this.metrics.stop()\n      ])\n\n      await this.natManager.stop()\n      await this.transportManager.close()\n\n      ping.unmount(this)\n      this.dialer.destroy()\n    } catch (err) {\n      if (err) {\n        log.error(err)\n        this.emit('error', err)\n      }\n    }\n    log('libp2p has stopped')\n  }\n\n  /**\n   * Load keychain keys from the datastore.\n   * Imports the private key as 'self', if needed.\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n  async loadKeychain () {\n    if (!this.keychain) {\n      return\n    }\n\n    try {\n      await this.keychain.findKeyByName('self')\n    } catch (err) {\n      await this.keychain.importPeer('self', this.peerId)\n    }\n  }\n\n  isStarted () {\n    return this._isStarted\n  }\n\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   *\n   * @returns {Map<string, Connection[]>}\n   */\n  get connections () {\n    return this.connectionManager.connections\n  }\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  dial (peer, options) {\n    return this._dial(peer, options)\n  }\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async dialProtocol (peer, protocols, options) {\n    if (!protocols || !protocols.length) {\n      throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM)\n    }\n\n    const connection = await this._dial(peer, options)\n    return connection.newStream(protocols)\n  }\n\n  /**\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @returns {Promise<Connection>}\n   */\n  async _dial (peer, options) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    if (id.equals(this.peerId)) {\n      throw errCode(new Error('Cannot dial self'), codes.ERR_DIALED_SELF)\n    }\n\n    let connection = this.connectionManager.get(id)\n\n    if (!connection) {\n      connection = await this.dialer.connectToPeer(peer, options)\n    } else if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    return connection\n  }\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @returns {Multiaddr[]}\n   */\n  get multiaddrs () {\n    let addrs = this.addressManager.getAnnounceAddrs().map(ma => ma.toString())\n\n    if (!addrs.length) {\n      // no configured announce addrs, add configured listen addresses\n      addrs = this.transportManager.getAddrs().map(ma => ma.toString())\n    }\n\n    addrs = addrs.concat(this.addressManager.getObservedAddrs().map(ma => ma.toString()))\n\n    const announceFilter = this._options.addresses.announceFilter\n\n    // dedupe multiaddrs\n    const addrSet = new Set(addrs)\n\n    // Create advertising list\n    return announceFilter(Array.from(addrSet).map(str => new Multiaddr(str)))\n  }\n\n  /**\n   * Disconnects all connections to the given `peer`\n   *\n   * @param {PeerId|Multiaddr|string} peer - the peer to close connections to\n   * @returns {Promise<void>}\n   */\n  async hangUp (peer) {\n    const { id } = getPeer(peer)\n\n    const connections = this.connectionManager.connections.get(id.toB58String())\n\n    if (!connections) {\n      return\n    }\n\n    await Promise.all(\n      connections.map(connection => {\n        return connection.close()\n      })\n    )\n  }\n\n  /**\n   * Pings the given peer in order to obtain the operation latency.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to ping\n   * @returns {Promise<number>}\n   */\n  ping (peer) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    // If received multiaddr, ping it\n    if (multiaddrs) {\n      return ping(this, multiaddrs[0])\n    }\n\n    return ping(this, id)\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   *\n   * @param {string[]|string} protocols\n   * @param {(props: HandlerProps) => void} handler\n   */\n  handle (protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler)\n    })\n\n    // Add new protocols to self protocols in the Protobook\n    this.peerStore.protoBook.add(this.peerId, protocols)\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @param {string[]|string} protocols\n   */\n  unhandle (protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol)\n    })\n\n    // Remove protocols from self protocols in the Protobook\n    this.peerStore.protoBook.remove(this.peerId, protocols)\n  }\n\n  async _onStarting () {\n    // Listen on the provided transports for the provided addresses\n    const addrs = this.addressManager.getListenAddrs()\n    await this.transportManager.listen(addrs)\n\n    // Manage your NATs\n    this.natManager.start()\n\n    // Start PeerStore\n    await this.peerStore.start()\n\n    if (this._config.pubsub.enabled) {\n      this.pubsub && this.pubsub.start()\n    }\n\n    // DHT subsystem\n    if (this._config.dht.enabled) {\n      this._dht && this._dht.start()\n\n      // TODO: this should be modified once random-walk is used as\n      // the other discovery modules\n      this._dht.on('peer', this._onDiscoveryPeer)\n    }\n\n    // Start metrics if present\n    this.metrics && this.metrics.start()\n  }\n\n  /**\n   * Called when libp2p has started and before it returns\n   *\n   * @private\n   */\n  async _onDidStart () {\n    this._isStarted = true\n\n    this.peerStore.on('peer', peerId => {\n      this.emit('peer:discovery', peerId)\n      this._maybeConnect(peerId)\n    })\n\n    // Once we start, emit any peers we may have already discovered\n    // TODO: this should be removed, as we already discovered these peers in the past\n    for (const peer of this.peerStore.peers.values()) {\n      this.emit('peer:discovery', peer.id)\n    }\n\n    this.connectionManager.start()\n\n    // Peer discovery\n    await this._setupPeerDiscovery()\n\n    // Relay\n    this.relay && this.relay.start()\n\n    this.peerRouting.start()\n  }\n\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   *\n   * @private\n   * @param {{ id: PeerId, multiaddrs: Multiaddr[], protocols: string[] }} peer\n   */\n  _onDiscoveryPeer (peer) {\n    if (peer.id.toB58String() === this.peerId.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF))\n      return\n    }\n\n    peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs)\n    peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols)\n  }\n\n  /**\n   * Will dial to the given `peerId` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minConnections.\n   *\n   * @private\n   * @param {PeerId} peerId\n   */\n  async _maybeConnect (peerId) {\n    // If auto dialing is on and we have no connection to the peer, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {\n      const minConnections = this._options.connectionManager.minConnections || 0\n      if (minConnections > this.connectionManager.size) {\n        log('connecting to discovered peer %s', peerId.toB58String())\n        try {\n          await this.dialer.connectToPeer(peerId)\n        } catch (err) {\n          log.error(`could not connect to discovered peer ${peerId.toB58String()} with ${err}`)\n        }\n      }\n    }\n  }\n\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n  async _setupPeerDiscovery () {\n    /**\n     * @param {PeerDiscoveryFactory} DiscoveryService\n     */\n    const setupService = (DiscoveryService) => {\n      let config = {\n        enabled: true // on by default\n      }\n\n      if (DiscoveryService.tag &&\n        this._config.peerDiscovery &&\n        this._config.peerDiscovery[DiscoveryService.tag]) {\n        // @ts-ignore PeerDiscovery not understood as an Object for spread\n        config = { ...config, ...this._config.peerDiscovery[DiscoveryService.tag] }\n      }\n\n      if (config.enabled &&\n        !this._discovery.has(DiscoveryService.tag)) { // not already added\n        let discoveryService\n\n        if (typeof DiscoveryService === 'function') {\n          // @ts-ignore DiscoveryService has no constructor type inferred\n          discoveryService = new DiscoveryService(Object.assign({}, config, {\n            peerId: this.peerId,\n            libp2p: this\n          }))\n        } else {\n          discoveryService = DiscoveryService\n        }\n\n        discoveryService.on('peer', this._onDiscoveryPeer)\n        this._discovery.set(DiscoveryService.tag, discoveryService)\n      }\n    }\n\n    // Discovery modules\n    for (const DiscoveryService of this._modules.peerDiscovery || []) {\n      setupService(DiscoveryService)\n    }\n\n    // Transport modules with discovery\n    for (const Transport of this.transportManager.getTransports()) {\n      // @ts-ignore Transport interface does not include discovery\n      if (Transport.discovery) {\n        // @ts-ignore Transport interface does not include discovery\n        setupService(Transport.discovery)\n      }\n    }\n\n    await Promise.all(Array.from(this._discovery.values(), d => d.start()))\n  }\n}\n\nmodule.exports = Libp2p\n"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcJ,KAAK,CAAC,QAAD,CAAnB,EAA+B;EACzCK,KAAK,EAAEL,KAAK,CAAC,YAAD;AAD6B,CAA/B,CAAZ;;AAGA,MAAM;EAAEM;AAAF,IAAmBL,OAAO,CAAC,QAAD,CAAhC;;AAEA,MAAMM,OAAO,GAAGN,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMO,MAAM,GAAGP,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAM;EAAEQ;AAAF,IAAgBR,OAAO,CAAC,WAAD,CAA7B;;AAEA,MAAMS,WAAW,GAAGT,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAMU,cAAc,GAAGV,OAAO,CAAC,mBAAD,CAA9B;;AACA,MAAMW,OAAO,GAAGX,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAM;EAAEY,QAAQ,EAAEC;AAAZ,IAA+Bb,OAAO,CAAC,UAAD,CAA5C;;AACA,MAAM;EAAEc,KAAF;EAASC;AAAT,IAAsBf,OAAO,CAAC,UAAD,CAAnC;;AAEA,MAAMgB,cAAc,GAAGhB,OAAO,CAAC,mBAAD,CAA9B;;AACA,MAAMiB,iBAAiB,GAAGjB,OAAO,CAAC,sBAAD,CAAjC;;AACA,MAAMkB,OAAO,GAAGlB,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMmB,KAAK,GAAGnB,OAAO,CAAC,WAAD,CAArB;;AACA,MAAMoB,MAAM,GAAGpB,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMqB,QAAQ,GAAGrB,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMsB,OAAO,GAAGtB,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMuB,gBAAgB,GAAGvB,OAAO,CAAC,qBAAD,CAAhC;;AACA,MAAMwB,QAAQ,GAAGxB,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMyB,SAAS,GAAGzB,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAM0B,aAAa,GAAG1B,OAAO,CAAC,kBAAD,CAA7B;;AACA,MAAM2B,mBAAmB,GAAG3B,OAAO,CAAC,yBAAD,CAAnC;;AACA,MAAM4B,SAAS,GAAG5B,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAM6B,IAAI,GAAG7B,OAAO,CAAC,QAAD,CAApB;;AACA,MAAM8B,eAAe,GAAG9B,OAAO,CAAC,YAAD,CAA/B;;AACA,MAAM+B,UAAU,GAAG/B,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAM;EAAEgC;AAAF,IAA2BhC,OAAO,CAAC,gBAAD,CAAxC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMiC,MAAN,SAAqB5B,YAArB,CAAkC;EAChC;AACF;AACA;AACA;AACA;AACA;AACA;EACqB,aAAN6B,MAAM,CAAEC,OAAF,EAAW;IAC5B,IAAIA,OAAO,CAACC,MAAZ,EAAoB;MAClB;MACA,OAAO,IAAIH,MAAJ,CAAWE,OAAX,CAAP;IACD;;IAED,MAAMC,MAAM,GAAG,MAAM7B,MAAM,CAAC2B,MAAP,EAArB;IAEAC,OAAO,CAACC,MAAR,GAAiBA,MAAjB,CAR4B,CAS5B;;IACA,OAAO,IAAIH,MAAJ,CAAWE,OAAX,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEE,WAAW,CAAEC,QAAF,EAAY;IACrB,QADqB,CAErB;IACA;;IACA,KAAKA,QAAL,GAAgBzB,cAAc,CAACyB,QAAD,CAA9B;IAEA;;IACA,KAAKF,MAAL,GAAc,KAAKE,QAAL,CAAcF,M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"},"metadata":{},"sourceType":"script"}