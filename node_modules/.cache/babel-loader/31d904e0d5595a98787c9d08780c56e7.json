{"ast":null,"code":"'use strict';\n\nconst {\n  io\n} = require('./utils');\n\nconst AccessController = require('./access-controller-interface');\n\nconst type = 'ipfs';\n\nclass IPFSAccessController extends AccessController {\n  constructor(ipfs, options) {\n    super();\n    this._ipfs = ipfs;\n    this._write = Array.from(options.write || []);\n  } // Returns the type of the access controller\n\n\n  static get type() {\n    return type;\n  } // Return a Set of keys that have `access` capability\n\n\n  get write() {\n    return this._write;\n  }\n\n  async canAppend(entry, identityProvider) {\n    // Allow if access list contain the writer's publicKey or is '*'\n    const key = entry.identity.id;\n\n    if (this.write.includes(key) || this.write.includes('*')) {\n      // check identity is valid\n      return identityProvider.verifyIdentity(entry.identity);\n    }\n\n    return false;\n  }\n\n  async load(address) {\n    // Transform '/ipfs/QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'\n    // to 'QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'\n    if (address.indexOf('/ipfs') === 0) {\n      address = address.split('/')[2];\n    }\n\n    try {\n      this._write = await io.read(this._ipfs, address);\n    } catch (e) {\n      console.log('IPFSAccessController.load ERROR:', e);\n    }\n  }\n\n  async save() {\n    let cid;\n\n    try {\n      cid = await io.write(this._ipfs, 'dag-cbor', {\n        write: JSON.stringify(this.write, null, 2)\n      });\n    } catch (e) {\n      console.log('IPFSAccessController.save ERROR:', e);\n    } // return the manifest data\n\n\n    return {\n      address: cid\n    };\n  }\n\n  static async create(orbitdb) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options = { ...options,\n      ...{\n        write: options.write || [orbitdb.identity.id]\n      }\n    };\n    return new IPFSAccessController(orbitdb._ipfs, options);\n  }\n\n}\n\nmodule.exports = IPFSAccessController;","map":{"version":3,"names":["io","require","AccessController","type","IPFSAccessController","constructor","ipfs","options","_ipfs","_write","Array","from","write","canAppend","entry","identityProvider","key","identity","id","includes","verifyIdentity","load","address","indexOf","split","read","e","console","log","save","cid","JSON","stringify","create","orbitdb","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-access-controllers/src/ipfs-access-controller.js"],"sourcesContent":["'use strict'\nconst { io } = require('./utils')\nconst AccessController = require('./access-controller-interface')\nconst type = 'ipfs'\n\nclass IPFSAccessController extends AccessController {\n  constructor (ipfs, options) {\n    super()\n    this._ipfs = ipfs\n    this._write = Array.from(options.write || [])\n  }\n\n  // Returns the type of the access controller\n  static get type () { return type }\n\n  // Return a Set of keys that have `access` capability\n  get write () {\n    return this._write\n  }\n\n  async canAppend (entry, identityProvider) {\n    // Allow if access list contain the writer's publicKey or is '*'\n    const key = entry.identity.id\n    if (this.write.includes(key) || this.write.includes('*')) {\n      // check identity is valid\n      return identityProvider.verifyIdentity(entry.identity)\n    }\n    return false\n  }\n\n  async load (address) {\n    // Transform '/ipfs/QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'\n    // to 'QmPFtHi3cmfZerxtH9ySLdzpg1yFhocYDZgEZywdUXHxFU'\n    if (address.indexOf('/ipfs') === 0) { address = address.split('/')[2] }\n\n    try {\n      this._write = await io.read(this._ipfs, address)\n    } catch (e) {\n      console.log('IPFSAccessController.load ERROR:', e)\n    }\n  }\n\n  async save () {\n    let cid\n    try {\n      cid = await io.write(this._ipfs, 'dag-cbor', { write: JSON.stringify(this.write, null, 2) })\n    } catch (e) {\n      console.log('IPFSAccessController.save ERROR:', e)\n    }\n    // return the manifest data\n    return { address: cid }\n  }\n\n  static async create (orbitdb, options = {}) {\n    options = { ...options, ...{ write: options.write || [orbitdb.identity.id] } }\n    return new IPFSAccessController(orbitdb._ipfs, options)\n  }\n}\n\nmodule.exports = IPFSAccessController\n"],"mappings":"AAAA;;AACA,MAAM;EAAEA;AAAF,IAASC,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,+BAAD,CAAhC;;AACA,MAAME,IAAI,GAAG,MAAb;;AAEA,MAAMC,oBAAN,SAAmCF,gBAAnC,CAAoD;EAClDG,WAAW,CAAEC,IAAF,EAAQC,OAAR,EAAiB;IAC1B;IACA,KAAKC,KAAL,GAAaF,IAAb;IACA,KAAKG,MAAL,GAAcC,KAAK,CAACC,IAAN,CAAWJ,OAAO,CAACK,KAAR,IAAiB,EAA5B,CAAd;EACD,CALiD,CAOlD;;;EACe,WAAJT,IAAI,GAAI;IAAE,OAAOA,IAAP;EAAa,CARgB,CAUlD;;;EACS,IAALS,KAAK,GAAI;IACX,OAAO,KAAKH,MAAZ;EACD;;EAEc,MAATI,SAAS,CAAEC,KAAF,EAASC,gBAAT,EAA2B;IACxC;IACA,MAAMC,GAAG,GAAGF,KAAK,CAACG,QAAN,CAAeC,EAA3B;;IACA,IAAI,KAAKN,KAAL,CAAWO,QAAX,CAAoBH,GAApB,KAA4B,KAAKJ,KAAL,CAAWO,QAAX,CAAoB,GAApB,CAAhC,EAA0D;MACxD;MACA,OAAOJ,gBAAgB,CAACK,cAAjB,CAAgCN,KAAK,CAACG,QAAtC,CAAP;IACD;;IACD,OAAO,KAAP;EACD;;EAES,MAAJI,IAAI,CAAEC,OAAF,EAAW;IACnB;IACA;IACA,IAAIA,OAAO,CAACC,OAAR,CAAgB,OAAhB,MAA6B,CAAjC,EAAoC;MAAED,OAAO,GAAGA,OAAO,CAACE,KAAR,CAAc,GAAd,EAAmB,CAAnB,CAAV;IAAiC;;IAEvE,IAAI;MACF,KAAKf,MAAL,GAAc,MAAMT,EAAE,CAACyB,IAAH,CAAQ,KAAKjB,KAAb,EAAoBc,OAApB,CAApB;IACD,CAFD,CAEE,OAAOI,CAAP,EAAU;MACVC,OAAO,CAACC,GAAR,CAAY,kCAAZ,EAAgDF,CAAhD;IACD;EACF;;EAES,MAAJG,IAAI,GAAI;IACZ,IAAIC,GAAJ;;IACA,IAAI;MACFA,GAAG,GAAG,MAAM9B,EAAE,CAACY,KAAH,CAAS,KAAKJ,KAAd,EAAqB,UAArB,EAAiC;QAAEI,KAAK,EAAEmB,IAAI,CAACC,SAAL,CAAe,KAAKpB,KAApB,EAA2B,IAA3B,EAAiC,CAAjC;MAAT,CAAjC,CAAZ;IACD,CAFD,CAEE,OAAOc,CAAP,EAAU;MACVC,OAAO,CAACC,GAAR,CAAY,kCAAZ,EAAgDF,CAAhD;IACD,CANW,CAOZ;;;IACA,OAAO;MAAEJ,OAAO,EAAEQ;IAAX,CAAP;EACD;;EAEkB,aAANG,MAAM,CAAEC,OAAF,EAAyB;IAAA,IAAd3B,OAAc,uEAAJ,EAAI;IAC1CA,OAAO,GAAG,EAAE,GAAGA,OAAL;MAAc,GAAG;QAAEK,KAAK,EAAEL,OAAO,CAACK,KAAR,IAAiB,CAACsB,OAAO,CAACjB,QAAR,CAAiBC,EAAlB;MAA1B;IAAjB,CAAV;IACA,OAAO,IAAId,oBAAJ,CAAyB8B,OAAO,CAAC1B,KAAjC,EAAwCD,OAAxC,CAAP;EACD;;AAnDiD;;AAsDpD4B,MAAM,CAACC,OAAP,GAAiBhC,oBAAjB"},"metadata":{},"sourceType":"script"}