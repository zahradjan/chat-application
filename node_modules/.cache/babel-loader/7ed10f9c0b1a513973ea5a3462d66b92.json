{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Heartbeat = void 0;\n\nconst constants = __importStar(require(\"./constants\"));\n\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\n\nconst utils_1 = require(\"./utils\"); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\n\nclass Heartbeat {\n  /**\n   * @param {Object} gossipsub\n   * @constructor\n   */\n  constructor(gossipsub) {\n    this.gossipsub = gossipsub;\n  }\n\n  start() {\n    if (this._heartbeatTimer) {\n      return;\n    }\n\n    const heartbeat = this._heartbeat.bind(this);\n\n    const timeout = setTimeout(() => {\n      heartbeat();\n\n      this._heartbeatTimer.runPeriodically(heartbeat, this.gossipsub._options.heartbeatInterval);\n    }, constants.GossipsubHeartbeatInitialDelay);\n    this._heartbeatTimer = {\n      _intervalId: undefined,\n      runPeriodically: (fn, period) => {\n        this._heartbeatTimer._intervalId = setInterval(fn, period);\n      },\n      cancel: () => {\n        clearTimeout(timeout);\n        clearInterval(this._heartbeatTimer._intervalId);\n      }\n    };\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   * @override\n   * @returns {void}\n   */\n\n\n  stop() {\n    if (!this._heartbeatTimer) {\n      return;\n    }\n\n    this._heartbeatTimer.cancel();\n\n    this._heartbeatTimer = null;\n  }\n  /**\n   * Maintains the mesh and fanout maps in gossipsub.\n   *\n   * @returns {void}\n   */\n\n\n  _heartbeat() {\n    const {\n      D,\n      Dlo,\n      Dhi,\n      Dscore,\n      Dout,\n      fanoutTTL\n    } = this.gossipsub._options;\n    this.gossipsub.heartbeatTicks++; // cache scores throught the heartbeat\n\n    const scores = new Map();\n\n    const getScore = id => {\n      let s = scores.get(id);\n\n      if (s === undefined) {\n        s = this.gossipsub.score.score(id);\n        scores.set(id, s);\n      }\n\n      return s;\n    }; // peer id => topic[]\n\n\n    const tograft = new Map(); // peer id => topic[]\n\n    const toprune = new Map(); // peer id => don't px\n\n    const noPX = new Map(); // clean up expired backoffs\n\n    this.gossipsub._clearBackoff(); // clean up peerhave/iasked counters\n\n\n    this.gossipsub.peerhave.clear();\n    this.gossipsub.iasked.clear(); // apply IWANT request penalties\n\n    this.gossipsub._applyIwantPenalties(); // ensure direct peers are connected\n\n\n    this.gossipsub._directConnect(); // maintain the mesh for topics we have joined\n\n\n    this.gossipsub.mesh.forEach((peers, topic) => {\n      // prune/graft helper functions (defined per topic)\n      const prunePeer = id => {\n        this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic); // update peer score\n\n        this.gossipsub.score.prune(id, topic); // add prune backoff record\n\n        this.gossipsub._addBackoff(id, topic); // remove peer from mesh\n\n\n        peers.delete(id); // add to toprune\n\n        const topics = toprune.get(id);\n\n        if (!topics) {\n          toprune.set(id, [topic]);\n        } else {\n          topics.push(topic);\n        }\n      };\n\n      const graftPeer = id => {\n        this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', id, topic); // update peer score\n\n        this.gossipsub.score.graft(id, topic); // add peer to mesh\n\n        peers.add(id); // add to tograft\n\n        const topics = tograft.get(id);\n\n        if (!topics) {\n          tograft.set(id, [topic]);\n        } else {\n          topics.push(topic);\n        }\n      }; // drop all peers with negative score, without PX\n\n\n      peers.forEach(id => {\n        const score = getScore(id);\n\n        if (score < 0) {\n          this.gossipsub.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);\n          prunePeer(id);\n          noPX.set(id, true);\n        }\n      }); // do we have enough peers?\n\n      if (peers.size < Dlo) {\n        const backoff = this.gossipsub.backoff.get(topic);\n        const ineed = D - peers.size;\n        const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, id => {\n          // filter out mesh peers, direct peers, peers we are backing off, peers with negative score\n          return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;\n        });\n        peersSet.forEach(graftPeer);\n      } // do we have to many peers?\n\n\n      if (peers.size > Dhi) {\n        let peersArray = Array.from(peers); // sort by score\n\n        peersArray.sort((a, b) => getScore(b) - getScore(a)); // We keep the first D_score peers by score and the remaining up to D randomly\n        // under the constraint that we keep D_out peers in the mesh (if we have that many)\n\n        peersArray = peersArray.slice(0, Dscore).concat(utils_1.shuffle(peersArray.slice(Dscore))); // count the outbound peers we are keeping\n\n        let outbound = 0;\n        peersArray.slice(0, D).forEach(p => {\n          if (this.gossipsub.outbound.get(p)) {\n            outbound++;\n          }\n        }); // if it's less than D_out, bubble up some outbound peers from the random selection\n\n        if (outbound < Dout) {\n          const rotate = i => {\n            // rotate the peersArray to the right and put the ith peer in the front\n            const p = peersArray[i];\n\n            for (let j = i; j > 0; j--) {\n              peersArray[j] = peersArray[j - 1];\n            }\n\n            peersArray[0] = p;\n          }; // first bubble up all outbound peers already in the selection to the front\n\n\n          if (outbound > 0) {\n            let ihave = outbound;\n\n            for (let i = 1; i < D && ihave > 0; i++) {\n              if (this.gossipsub.outbound.get(peersArray[i])) {\n                rotate(i);\n                ihave--;\n              }\n            }\n          } // now bubble up enough outbound peers outside the selection to the front\n\n\n          let ineed = D - outbound;\n\n          for (let i = D; i < peersArray.length && ineed > 0; i++) {\n            if (this.gossipsub.outbound.get(peersArray[i])) {\n              rotate(i);\n              ineed--;\n            }\n          }\n        } // prune the excess peers\n\n\n        peersArray.slice(D).forEach(prunePeer);\n      } // do we have enough outbound peers?\n\n\n      if (peers.size >= Dlo) {\n        // count the outbound peers we have\n        let outbound = 0;\n        peers.forEach(p => {\n          if (this.gossipsub.outbound.get(p)) {\n            outbound++;\n          }\n        }); // if it's less than D_out, select some peers with outbound connections and graft them\n\n        if (outbound < Dout) {\n          const ineed = Dout - outbound;\n          const backoff = this.gossipsub.backoff.get(topic);\n          get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, id => {\n            // filter our current mesh peers, direct peers, peers we are backing off, peers with negative score\n            return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;\n          }).forEach(graftPeer);\n        }\n      } // should we try to improve the mesh with opportunistic grafting?\n\n\n      if (this.gossipsub.heartbeatTicks % constants.GossipsubOpportunisticGraftTicks === 0 && peers.size > 1) {\n        // Opportunistic grafting works as follows: we check the median score of peers in the\n        // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n        // random with score over the median.\n        // The intention is to (slowly) improve an underperforming mesh by introducing good\n        // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n        // situations where we are stuck with poor peers and also recover from churn of good peers.\n        // now compute the median peer score in the mesh\n        const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));\n        const medianIndex = Math.floor(peers.size / 2);\n        const medianScore = getScore(peersList[medianIndex]); // if the median score is below the threshold, select a better peer (if any) and GRAFT\n\n        if (medianScore < this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {\n          const backoff = this.gossipsub.backoff.get(topic);\n          const peersToGraft = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, constants.GossipsubOpportunisticGraftPeers, id => {\n            // filter out current mesh peers, direct peers, peers we are backing off, peers below or at threshold\n            return peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) > medianScore;\n          });\n          peersToGraft.forEach(id => {\n            this.gossipsub.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);\n            graftPeer(id);\n          });\n        }\n      } // 2nd arg are mesh peers excluded from gossip. We have already pushed\n      // messages to them, so its redundant to gossip IHAVEs.\n\n\n      this.gossipsub._emitGossip(topic, peers);\n    }); // expire fanout for topics we haven't published to in a while\n\n    const now = this.gossipsub._now();\n\n    this.gossipsub.lastpub.forEach((lastpb, topic) => {\n      if (lastpb + fanoutTTL < now) {\n        this.gossipsub.fanout.delete(topic);\n        this.gossipsub.lastpub.delete(topic);\n      }\n    }); // maintain our fanout for topics we are publishing but we have not joined\n\n    this.gossipsub.fanout.forEach((fanoutPeers, topic) => {\n      // checks whether our peers are still in the topic and have a score above the publish threshold\n      const topicPeers = this.gossipsub.topics.get(topic);\n      fanoutPeers.forEach(id => {\n        if (!topicPeers.has(id) || getScore(id) < this.gossipsub._options.scoreThresholds.publishThreshold) {\n          fanoutPeers.delete(id);\n        }\n      }); // do we need more peers?\n\n      if (fanoutPeers.size < D) {\n        const ineed = D - fanoutPeers.size;\n        const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, id => {\n          // filter out existing fanout peers, direct peers, and peers with score above the publish threshold\n          return !fanoutPeers.has(id) && !this.gossipsub.direct.has(id) && getScore(id) >= this.gossipsub._options.scoreThresholds.publishThreshold;\n        });\n        peersSet.forEach(id => {\n          fanoutPeers.add(id);\n        });\n      } // 2nd arg are fanout peers excluded from gossip.\n      // We have already pushed messages to them, so its redundant to gossip IHAVEs\n\n\n      this.gossipsub._emitGossip(topic, fanoutPeers);\n    }); // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n\n    this.gossipsub._sendGraftPrune(tograft, toprune, noPX); // flush pending gossip that wasn't piggybacked above\n\n\n    this.gossipsub._flush(); // advance the message history window\n\n\n    this.gossipsub.messageCache.shift();\n    this.gossipsub.emit('gossipsub:heartbeat');\n  }\n\n}\n\nexports.Heartbeat = Heartbeat;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","exports","Heartbeat","constants","require","get_gossip_peers_1","utils_1","constructor","gossipsub","start","_heartbeatTimer","heartbeat","_heartbeat","bind","timeout","setTimeout","runPeriodically","_options","heartbeatInterval","GossipsubHeartbeatInitialDelay","_intervalId","fn","period","setInterval","cancel","clearTimeout","clearInterval","stop","D","Dlo","Dhi","Dscore","Dout","fanoutTTL","heartbeatTicks","scores","Map","getScore","id","s","score","set","tograft","toprune","noPX","_clearBackoff","peerhave","clear","iasked","_applyIwantPenalties","_directConnect","mesh","forEach","peers","topic","prunePeer","log","prune","_addBackoff","delete","topics","push","graftPeer","graft","add","size","backoff","ineed","peersSet","getGossipPeers","has","direct","peersArray","Array","from","sort","a","b","slice","concat","shuffle","outbound","p","rotate","i","j","ihave","length","GossipsubOpportunisticGraftTicks","peersList","medianIndex","Math","floor","medianScore","scoreThresholds","opportunisticGraftThreshold","peersToGraft","GossipsubOpportunisticGraftPeers","_emitGossip","now","_now","lastpub","lastpb","fanout","fanoutPeers","topicPeers","publishThreshold","_sendGraftPrune","_flush","messageCache","shift","emit"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-gossipsub/src/heartbeat.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Heartbeat = void 0;\nconst constants = __importStar(require(\"./constants\"));\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\nconst utils_1 = require(\"./utils\");\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\nclass Heartbeat {\n    /**\n     * @param {Object} gossipsub\n     * @constructor\n     */\n    constructor(gossipsub) {\n        this.gossipsub = gossipsub;\n    }\n    start() {\n        if (this._heartbeatTimer) {\n            return;\n        }\n        const heartbeat = this._heartbeat.bind(this);\n        const timeout = setTimeout(() => {\n            heartbeat();\n            this._heartbeatTimer.runPeriodically(heartbeat, this.gossipsub._options.heartbeatInterval);\n        }, constants.GossipsubHeartbeatInitialDelay);\n        this._heartbeatTimer = {\n            _intervalId: undefined,\n            runPeriodically: (fn, period) => {\n                this._heartbeatTimer._intervalId = setInterval(fn, period);\n            },\n            cancel: () => {\n                clearTimeout(timeout);\n                clearInterval(this._heartbeatTimer._intervalId);\n            }\n        };\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n    stop() {\n        if (!this._heartbeatTimer) {\n            return;\n        }\n        this._heartbeatTimer.cancel();\n        this._heartbeatTimer = null;\n    }\n    /**\n     * Maintains the mesh and fanout maps in gossipsub.\n     *\n     * @returns {void}\n     */\n    _heartbeat() {\n        const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.gossipsub._options;\n        this.gossipsub.heartbeatTicks++;\n        // cache scores throught the heartbeat\n        const scores = new Map();\n        const getScore = (id) => {\n            let s = scores.get(id);\n            if (s === undefined) {\n                s = this.gossipsub.score.score(id);\n                scores.set(id, s);\n            }\n            return s;\n        };\n        // peer id => topic[]\n        const tograft = new Map();\n        // peer id => topic[]\n        const toprune = new Map();\n        // peer id => don't px\n        const noPX = new Map();\n        // clean up expired backoffs\n        this.gossipsub._clearBackoff();\n        // clean up peerhave/iasked counters\n        this.gossipsub.peerhave.clear();\n        this.gossipsub.iasked.clear();\n        // apply IWANT request penalties\n        this.gossipsub._applyIwantPenalties();\n        // ensure direct peers are connected\n        this.gossipsub._directConnect();\n        // maintain the mesh for topics we have joined\n        this.gossipsub.mesh.forEach((peers, topic) => {\n            // prune/graft helper functions (defined per topic)\n            const prunePeer = (id) => {\n                this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic);\n                // update peer score\n                this.gossipsub.score.prune(id, topic);\n                // add prune backoff record\n                this.gossipsub._addBackoff(id, topic);\n                // remove peer from mesh\n                peers.delete(id);\n                // add to toprune\n                const topics = toprune.get(id);\n                if (!topics) {\n                    toprune.set(id, [topic]);\n                }\n                else {\n                    topics.push(topic);\n                }\n            };\n            const graftPeer = (id) => {\n                this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', id, topic);\n                // update peer score\n                this.gossipsub.score.graft(id, topic);\n                // add peer to mesh\n                peers.add(id);\n                // add to tograft\n                const topics = tograft.get(id);\n                if (!topics) {\n                    tograft.set(id, [topic]);\n                }\n                else {\n                    topics.push(topic);\n                }\n            };\n            // drop all peers with negative score, without PX\n            peers.forEach(id => {\n                const score = getScore(id);\n                if (score < 0) {\n                    this.gossipsub.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);\n                    prunePeer(id);\n                    noPX.set(id, true);\n                }\n            });\n            // do we have enough peers?\n            if (peers.size < Dlo) {\n                const backoff = this.gossipsub.backoff.get(topic);\n                const ineed = D - peers.size;\n                const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, id => {\n                    // filter out mesh peers, direct peers, peers we are backing off, peers with negative score\n                    return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;\n                });\n                peersSet.forEach(graftPeer);\n            }\n            // do we have to many peers?\n            if (peers.size > Dhi) {\n                let peersArray = Array.from(peers);\n                // sort by score\n                peersArray.sort((a, b) => getScore(b) - getScore(a));\n                // We keep the first D_score peers by score and the remaining up to D randomly\n                // under the constraint that we keep D_out peers in the mesh (if we have that many)\n                peersArray = peersArray.slice(0, Dscore).concat(utils_1.shuffle(peersArray.slice(Dscore)));\n                // count the outbound peers we are keeping\n                let outbound = 0;\n                peersArray.slice(0, D).forEach(p => {\n                    if (this.gossipsub.outbound.get(p)) {\n                        outbound++;\n                    }\n                });\n                // if it's less than D_out, bubble up some outbound peers from the random selection\n                if (outbound < Dout) {\n                    const rotate = (i) => {\n                        // rotate the peersArray to the right and put the ith peer in the front\n                        const p = peersArray[i];\n                        for (let j = i; j > 0; j--) {\n                            peersArray[j] = peersArray[j - 1];\n                        }\n                        peersArray[0] = p;\n                    };\n                    // first bubble up all outbound peers already in the selection to the front\n                    if (outbound > 0) {\n                        let ihave = outbound;\n                        for (let i = 1; i < D && ihave > 0; i++) {\n                            if (this.gossipsub.outbound.get(peersArray[i])) {\n                                rotate(i);\n                                ihave--;\n                            }\n                        }\n                    }\n                    // now bubble up enough outbound peers outside the selection to the front\n                    let ineed = D - outbound;\n                    for (let i = D; i < peersArray.length && ineed > 0; i++) {\n                        if (this.gossipsub.outbound.get(peersArray[i])) {\n                            rotate(i);\n                            ineed--;\n                        }\n                    }\n                }\n                // prune the excess peers\n                peersArray.slice(D).forEach(prunePeer);\n            }\n            // do we have enough outbound peers?\n            if (peers.size >= Dlo) {\n                // count the outbound peers we have\n                let outbound = 0;\n                peers.forEach(p => {\n                    if (this.gossipsub.outbound.get(p)) {\n                        outbound++;\n                    }\n                });\n                // if it's less than D_out, select some peers with outbound connections and graft them\n                if (outbound < Dout) {\n                    const ineed = Dout - outbound;\n                    const backoff = this.gossipsub.backoff.get(topic);\n                    get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {\n                        // filter our current mesh peers, direct peers, peers we are backing off, peers with negative score\n                        return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;\n                    }).forEach(graftPeer);\n                }\n            }\n            // should we try to improve the mesh with opportunistic grafting?\n            if (this.gossipsub.heartbeatTicks % constants.GossipsubOpportunisticGraftTicks === 0 && peers.size > 1) {\n                // Opportunistic grafting works as follows: we check the median score of peers in the\n                // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n                // random with score over the median.\n                // The intention is to (slowly) improve an underperforming mesh by introducing good\n                // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n                // situations where we are stuck with poor peers and also recover from churn of good peers.\n                // now compute the median peer score in the mesh\n                const peersList = Array.from(peers)\n                    .sort((a, b) => getScore(a) - getScore(b));\n                const medianIndex = Math.floor(peers.size / 2);\n                const medianScore = getScore(peersList[medianIndex]);\n                // if the median score is below the threshold, select a better peer (if any) and GRAFT\n                if (medianScore < this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {\n                    const backoff = this.gossipsub.backoff.get(topic);\n                    const peersToGraft = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, constants.GossipsubOpportunisticGraftPeers, (id) => {\n                        // filter out current mesh peers, direct peers, peers we are backing off, peers below or at threshold\n                        return peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) > medianScore;\n                    });\n                    peersToGraft.forEach(id => {\n                        this.gossipsub.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);\n                        graftPeer(id);\n                    });\n                }\n            }\n            // 2nd arg are mesh peers excluded from gossip. We have already pushed\n            // messages to them, so its redundant to gossip IHAVEs.\n            this.gossipsub._emitGossip(topic, peers);\n        });\n        // expire fanout for topics we haven't published to in a while\n        const now = this.gossipsub._now();\n        this.gossipsub.lastpub.forEach((lastpb, topic) => {\n            if ((lastpb + fanoutTTL) < now) {\n                this.gossipsub.fanout.delete(topic);\n                this.gossipsub.lastpub.delete(topic);\n            }\n        });\n        // maintain our fanout for topics we are publishing but we have not joined\n        this.gossipsub.fanout.forEach((fanoutPeers, topic) => {\n            // checks whether our peers are still in the topic and have a score above the publish threshold\n            const topicPeers = this.gossipsub.topics.get(topic);\n            fanoutPeers.forEach(id => {\n                if (!topicPeers.has(id) ||\n                    getScore(id) < this.gossipsub._options.scoreThresholds.publishThreshold) {\n                    fanoutPeers.delete(id);\n                }\n            });\n            // do we need more peers?\n            if (fanoutPeers.size < D) {\n                const ineed = D - fanoutPeers.size;\n                const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {\n                    // filter out existing fanout peers, direct peers, and peers with score above the publish threshold\n                    return !fanoutPeers.has(id) &&\n                        !this.gossipsub.direct.has(id) &&\n                        getScore(id) >= this.gossipsub._options.scoreThresholds.publishThreshold;\n                });\n                peersSet.forEach(id => {\n                    fanoutPeers.add(id);\n                });\n            }\n            // 2nd arg are fanout peers excluded from gossip.\n            // We have already pushed messages to them, so its redundant to gossip IHAVEs\n            this.gossipsub._emitGossip(topic, fanoutPeers);\n        });\n        // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n        this.gossipsub._sendGraftPrune(tograft, toprune, noPX);\n        // flush pending gossip that wasn't piggybacked above\n        this.gossipsub._flush();\n        // advance the message history window\n        this.gossipsub.messageCache.shift();\n        this.gossipsub.emit('gossipsub:heartbeat');\n    }\n}\nexports.Heartbeat = Heartbeat;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}