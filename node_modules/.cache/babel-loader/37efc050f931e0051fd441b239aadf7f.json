{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar _asyncGeneratorDelegate = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate.js\").default;\n\nvar dagPb = require('@ipld/dag-pb');\n\nvar _require = require('interface-datastore'),\n    Errors = _require.Errors;\n\nvar ERR_NOT_FOUND = Errors.notFoundError().code;\n\nvar toCIDAndPath = require('ipfs-core-utils/src/to-cid-and-path');\n\nvar _require2 = require('multiformats/cid'),\n    CID = _require2.CID; // @ts-expect-error no types\n\n\nvar TimeoutController = require('timeout-abort-controller');\n\nvar _require3 = require('any-signal'),\n    anySignal = _require3.anySignal;\n\nvar Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\n\nmodule.exports = function (_ref) {\n  var repo = _ref.repo,\n      codecs = _ref.codecs,\n      resolve = _ref.resolve,\n      preload = _ref.preload;\n\n  /**\n   * @type {import('ipfs-core-types/src/refs').API[\"refs\"]}\n   */\n  function refs(_x) {\n    return _refs.apply(this, arguments);\n  }\n\n  function _refs() {\n    _refs = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ipfsPath) {\n      var options,\n          controller,\n          rawPaths,\n          paths,\n          _iterator3,\n          _step3,\n          path,\n          _args = arguments;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n              if (!(options.maxDepth === 0)) {\n                _context.next = 3;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 3:\n              if (!(options.edges && options.format && options.format !== Format.default)) {\n                _context.next = 5;\n                break;\n              }\n\n              throw new Error('Cannot set edges to true and also specify format');\n\n            case 5:\n              options.format = options.edges ? Format.edges : options.format;\n\n              if (typeof options.maxDepth !== 'number') {\n                options.maxDepth = options.recursive ? Infinity : 1;\n              }\n\n              if (options.timeout) {\n                controller = new TimeoutController(options.timeout);\n                options.signal = anySignal([options.signal, controller.signal]);\n              }\n              /** @type {(string|CID)[]} */\n\n\n              rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n              paths = rawPaths.map(function (p) {\n                return getFullPath(preload, p, options);\n              });\n              _iterator3 = _createForOfIteratorHelper(paths);\n              _context.prev = 11;\n\n              _iterator3.s();\n\n            case 13:\n              if ((_step3 = _iterator3.n()).done) {\n                _context.next = 25;\n                break;\n              }\n\n              path = _step3.value;\n              _context.prev = 15;\n              return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(refsStream(resolve, repo, codecs, path, options)), _awaitAsyncGenerator), \"t0\", 17);\n\n            case 17:\n              _context.next = 23;\n              break;\n\n            case 19:\n              _context.prev = 19;\n              _context.t1 = _context[\"catch\"](15);\n              _context.next = 23;\n              return {\n                ref: '',\n                err: _context.t1.message\n              };\n\n            case 23:\n              _context.next = 13;\n              break;\n\n            case 25:\n              _context.next = 30;\n              break;\n\n            case 27:\n              _context.prev = 27;\n              _context.t2 = _context[\"catch\"](11);\n\n              _iterator3.e(_context.t2);\n\n            case 30:\n              _context.prev = 30;\n\n              _iterator3.f();\n\n              return _context.finish(30);\n\n            case 33:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[11, 27, 30, 33], [15, 19]]);\n    }));\n    return _refs.apply(this, arguments);\n  }\n\n  return refs;\n};\n\nmodule.exports.Format = Format;\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\nfunction getFullPath(preload, ipfsPath, options) {\n  var _toCIDAndPath = toCIDAndPath(ipfsPath),\n      cid = _toCIDAndPath.cid,\n      path = _toCIDAndPath.path;\n\n  if (options.preload !== false) {\n    preload(cid);\n  }\n\n  return \"/ipfs/\".concat(cid).concat(path || '');\n}\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\n\nfunction refsStream(_x2, _x3, _x4, _x5, _x6) {\n  return _refsStream.apply(this, arguments);\n}\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\n\n\nfunction _refsStream() {\n  _refsStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(resolve, repo, codecs, path, options) {\n    var resPath, _toCIDAndPath2, cid, maxDepth, unique, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, obj;\n\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return _awaitAsyncGenerator(resolve(path, options));\n\n          case 2:\n            resPath = _context2.sent;\n            _toCIDAndPath2 = toCIDAndPath(resPath), cid = _toCIDAndPath2.cid;\n            maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;\n            unique = options.unique || false; // Traverse the DAG, converting it into a stream\n\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context2.prev = 8;\n            _iterator = _asyncIterator(objectStream(repo, codecs, cid, maxDepth, unique, options));\n\n          case 10:\n            _context2.next = 12;\n            return _awaitAsyncGenerator(_iterator.next());\n\n          case 12:\n            if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n              _context2.next = 23;\n              break;\n            }\n\n            obj = _step.value;\n\n            if (obj.parent) {\n              _context2.next = 16;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 20);\n\n          case 16:\n            if (!obj.isDuplicate) {\n              _context2.next = 18;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 20);\n\n          case 18:\n            _context2.next = 20;\n            return {\n              ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n            };\n\n          case 20:\n            _iteratorAbruptCompletion = false;\n            _context2.next = 10;\n            break;\n\n          case 23:\n            _context2.next = 29;\n            break;\n\n          case 25:\n            _context2.prev = 25;\n            _context2.t0 = _context2[\"catch\"](8);\n            _didIteratorError = true;\n            _iteratorError = _context2.t0;\n\n          case 29:\n            _context2.prev = 29;\n            _context2.prev = 30;\n\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context2.next = 34;\n              break;\n            }\n\n            _context2.next = 34;\n            return _awaitAsyncGenerator(_iterator.return());\n\n          case 34:\n            _context2.prev = 34;\n\n            if (!_didIteratorError) {\n              _context2.next = 37;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 37:\n            return _context2.finish(34);\n\n          case 38:\n            return _context2.finish(29);\n\n          case 39:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[8, 25, 29, 39], [30,, 34, 38]]);\n  }));\n  return _refsStream.apply(this, arguments);\n}\n\nfunction formatLink(srcCid, dstCid) {\n  var linkName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Format.default;\n  var out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n}\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n * @param {AbortOptions} options\n */\n\n\nfunction objectStream(_x7, _x8, _x9, _x10, _x11, _x12) {\n  return _objectStream.apply(this, arguments);\n}\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} cid\n * @param {AbortOptions} options\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\n\n\nfunction _objectStream() {\n  _objectStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(repo, codecs, rootCid, maxDepth, uniqueOnly, options) {\n    var seen, traverseLevel, _traverseLevel;\n\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _traverseLevel = function _traverseLevel3() {\n              _traverseLevel = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(parent, depth) {\n                var nextLevelDepth, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, link;\n\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        nextLevelDepth = depth + 1; // Check the depth\n\n                        if (!(nextLevelDepth > maxDepth)) {\n                          _context3.next = 3;\n                          break;\n                        }\n\n                        return _context3.abrupt(\"return\");\n\n                      case 3:\n                        _context3.prev = 3;\n                        // Look at each link, parent and the new depth\n                        _iteratorAbruptCompletion2 = false;\n                        _didIteratorError2 = false;\n                        _context3.prev = 6;\n                        _iterator2 = _asyncIterator(getLinks(repo, codecs, parent.cid, options));\n\n                      case 8:\n                        _context3.next = 10;\n                        return _awaitAsyncGenerator(_iterator2.next());\n\n                      case 10:\n                        if (!(_iteratorAbruptCompletion2 = !(_step2 = _context3.sent).done)) {\n                          _context3.next = 19;\n                          break;\n                        }\n\n                        link = _step2.value;\n                        _context3.next = 14;\n                        return {\n                          parent: parent,\n                          node: link,\n                          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n                        };\n\n                      case 14:\n                        if (uniqueOnly) {\n                          seen.add(link.cid.toString());\n                        }\n\n                        return _context3.delegateYield(_asyncGeneratorDelegate(_asyncIterator(traverseLevel(link, nextLevelDepth)), _awaitAsyncGenerator), \"t0\", 16);\n\n                      case 16:\n                        _iteratorAbruptCompletion2 = false;\n                        _context3.next = 8;\n                        break;\n\n                      case 19:\n                        _context3.next = 25;\n                        break;\n\n                      case 21:\n                        _context3.prev = 21;\n                        _context3.t1 = _context3[\"catch\"](6);\n                        _didIteratorError2 = true;\n                        _iteratorError2 = _context3.t1;\n\n                      case 25:\n                        _context3.prev = 25;\n                        _context3.prev = 26;\n\n                        if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                          _context3.next = 30;\n                          break;\n                        }\n\n                        _context3.next = 30;\n                        return _awaitAsyncGenerator(_iterator2.return());\n\n                      case 30:\n                        _context3.prev = 30;\n\n                        if (!_didIteratorError2) {\n                          _context3.next = 33;\n                          break;\n                        }\n\n                        throw _iteratorError2;\n\n                      case 33:\n                        return _context3.finish(30);\n\n                      case 34:\n                        return _context3.finish(25);\n\n                      case 35:\n                        _context3.next = 41;\n                        break;\n\n                      case 37:\n                        _context3.prev = 37;\n                        _context3.t2 = _context3[\"catch\"](3);\n\n                        if (_context3.t2.code === ERR_NOT_FOUND) {\n                          _context3.t2.message = \"Could not find object with CID: \".concat(parent.cid);\n                        }\n\n                        throw _context3.t2;\n\n                      case 41:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3, null, [[3, 37], [6, 21, 25, 35], [26,, 30, 34]]);\n              }));\n              return _traverseLevel.apply(this, arguments);\n            };\n\n            traverseLevel = function _traverseLevel2(_x17, _x18) {\n              return _traverseLevel.apply(this, arguments);\n            };\n\n            // eslint-disable-line require-await\n            seen = new Set();\n            /**\n             * @param {Node} parent\n             * @param {number} depth\n             * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n             */\n\n            return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(traverseLevel({\n              cid: rootCid\n            }, 0)), _awaitAsyncGenerator), \"t0\", 4);\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _objectStream.apply(this, arguments);\n}\n\nfunction getLinks(_x13, _x14, _x15, _x16) {\n  return _getLinks.apply(this, arguments);\n}\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\n\n\nfunction _getLinks() {\n  _getLinks = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(repo, codecs, cid, options) {\n    var block, codec, value, isDagPb, base, _iterator4, _step4, _step4$value, name, _cid, match, index;\n\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return _awaitAsyncGenerator(repo.blocks.get(cid, options));\n\n          case 2:\n            block = _context5.sent;\n            _context5.next = 5;\n            return _awaitAsyncGenerator(codecs.getCodec(cid.code));\n\n          case 5:\n            codec = _context5.sent;\n            value = codec.decode(block);\n            isDagPb = cid.code === dagPb.code;\n            /** @type {Array<string|number>} */\n\n            base = [];\n            _iterator4 = _createForOfIteratorHelper(links(value, base));\n            _context5.prev = 10;\n\n            _iterator4.s();\n\n          case 12:\n            if ((_step4 = _iterator4.n()).done) {\n              _context5.next = 26;\n              break;\n            }\n\n            _step4$value = _slicedToArray(_step4.value, 2), name = _step4$value[0], _cid = _step4$value[1];\n\n            if (!isDagPb) {\n              _context5.next = 22;\n              break;\n            }\n\n            match = name.match(/^Links\\/(\\d+)\\/Hash$/);\n\n            if (!match) {\n              _context5.next = 22;\n              break;\n            }\n\n            index = Number(match[1]);\n\n            if (!(index < value.Links.length)) {\n              _context5.next = 22;\n              break;\n            }\n\n            _context5.next = 21;\n            return {\n              name: value.Links[index].Name,\n              cid: _cid\n            };\n\n          case 21:\n            return _context5.abrupt(\"continue\", 24);\n\n          case 22:\n            _context5.next = 24;\n            return {\n              name: name,\n              cid: _cid\n            };\n\n          case 24:\n            _context5.next = 12;\n            break;\n\n          case 26:\n            _context5.next = 31;\n            break;\n\n          case 28:\n            _context5.prev = 28;\n            _context5.t0 = _context5[\"catch\"](10);\n\n            _iterator4.e(_context5.t0);\n\n          case 31:\n            _context5.prev = 31;\n\n            _iterator4.f();\n\n            return _context5.finish(31);\n\n          case 34:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[10, 28, 31, 34]]);\n  }));\n  return _getLinks.apply(this, arguments);\n}\n\nvar links = /*#__PURE__*/_regeneratorRuntime().mark(function links(source, base) {\n  var _i, _Object$entries, _Object$entries$_i, key, value, path, _iterator5, _step5, _step5$value, index, element, elementPath, cid, _cid2;\n\n  return _regeneratorRuntime().wrap(function links$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          if (!(source == null)) {\n            _context6.next = 2;\n            break;\n          }\n\n          return _context6.abrupt(\"return\");\n\n        case 2:\n          if (!(source instanceof Uint8Array)) {\n            _context6.next = 4;\n            break;\n          }\n\n          return _context6.abrupt(\"return\");\n\n        case 4:\n          _i = 0, _Object$entries = Object.entries(source);\n\n        case 5:\n          if (!(_i < _Object$entries.length)) {\n            _context6.next = 46;\n            break;\n          }\n\n          _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];\n          path = [].concat(_toConsumableArray(base), [key]);\n\n          if (!(value != null && typeof value === 'object')) {\n            _context6.next = 43;\n            break;\n          }\n\n          if (!Array.isArray(value)) {\n            _context6.next = 36;\n            break;\n          }\n\n          _iterator5 = _createForOfIteratorHelper(value.entries());\n          _context6.prev = 11;\n\n          _iterator5.s();\n\n        case 13:\n          if ((_step5 = _iterator5.n()).done) {\n            _context6.next = 26;\n            break;\n          }\n\n          _step5$value = _slicedToArray(_step5.value, 2), index = _step5$value[0], element = _step5$value[1];\n          elementPath = [].concat(_toConsumableArray(path), [index]);\n          cid = CID.asCID(element); // eslint-disable-next-line max-depth\n\n          if (!cid) {\n            _context6.next = 22;\n            break;\n          }\n\n          _context6.next = 20;\n          return [elementPath.join('/'), cid];\n\n        case 20:\n          _context6.next = 24;\n          break;\n\n        case 22:\n          if (!(typeof element === 'object')) {\n            _context6.next = 24;\n            break;\n          }\n\n          return _context6.delegateYield(links(element, elementPath), \"t0\", 24);\n\n        case 24:\n          _context6.next = 13;\n          break;\n\n        case 26:\n          _context6.next = 31;\n          break;\n\n        case 28:\n          _context6.prev = 28;\n          _context6.t1 = _context6[\"catch\"](11);\n\n          _iterator5.e(_context6.t1);\n\n        case 31:\n          _context6.prev = 31;\n\n          _iterator5.f();\n\n          return _context6.finish(31);\n\n        case 34:\n          _context6.next = 43;\n          break;\n\n        case 36:\n          _cid2 = CID.asCID(value);\n\n          if (!_cid2) {\n            _context6.next = 42;\n            break;\n          }\n\n          _context6.next = 40;\n          return [path.join('/'), _cid2];\n\n        case 40:\n          _context6.next = 43;\n          break;\n\n        case 42:\n          return _context6.delegateYield(links(value, path), \"t2\", 43);\n\n        case 43:\n          _i++;\n          _context6.next = 5;\n          break;\n\n        case 46:\n          return _context6.abrupt(\"return\", []);\n\n        case 47:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, links, null, [[11, 28, 31, 34]]);\n});","map":{"version":3,"names":["dagPb","require","Errors","ERR_NOT_FOUND","notFoundError","code","toCIDAndPath","CID","TimeoutController","anySignal","Format","default","edges","module","exports","repo","codecs","resolve","preload","refs","ipfsPath","options","maxDepth","format","Error","recursive","Infinity","timeout","controller","signal","rawPaths","Array","isArray","paths","map","p","getFullPath","path","refsStream","ref","err","message","cid","resPath","unique","objectStream","obj","parent","isDuplicate","formatLink","node","name","srcCid","dstCid","linkName","out","replace","toString","rootCid","uniqueOnly","traverseLevel","depth","nextLevelDepth","getLinks","link","seen","has","add","Set","blocks","get","block","getCodec","codec","value","decode","isDagPb","base","links","match","index","Number","Links","length","Name","source","Uint8Array","Object","entries","key","element","elementPath","asCID","join"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/refs/index.js"],"sourcesContent":["'use strict'\n\nconst dagPb = require('@ipld/dag-pb')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst toCIDAndPath = require('ipfs-core-utils/src/to-cid-and-path')\nconst { CID } = require('multiformats/cid')\n// @ts-expect-error no types\nconst TimeoutController = require('timeout-abort-controller')\nconst { anySignal } = require('any-signal')\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n}\n\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n *\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\nmodule.exports = function ({ repo, codecs, resolve, preload }) {\n  /**\n   * @type {import('ipfs-core-types/src/refs').API[\"refs\"]}\n   */\n  async function * refs (ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format')\n    }\n\n    options.format = options.edges ? Format.edges : options.format\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1\n    }\n\n    if (options.timeout) {\n      const controller = new TimeoutController(options.timeout)\n\n      options.signal = anySignal([options.signal, controller.signal])\n    }\n\n    /** @type {(string|CID)[]} */\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath]\n\n    const paths = rawPaths.map(p => getFullPath(preload, p, options))\n\n    for (const path of paths) {\n      try {\n        yield * refsStream(resolve, repo, codecs, path, options)\n      } catch (err) {\n        yield {\n          ref: '',\n          err: err.message\n        }\n      }\n    }\n  }\n\n  return refs\n}\n\nmodule.exports.Format = Format\n\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nfunction getFullPath (preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCIDAndPath(ipfsPath)\n\n  if (options.preload !== false) {\n    preload(cid)\n  }\n\n  return `/ipfs/${cid}${path || ''}`\n}\n\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nasync function * refsStream (resolve, repo, codecs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path, options)\n  const {\n    cid\n  } = toCIDAndPath(resPath)\n\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity\n  const unique = options.unique || false\n\n  // Traverse the DAG, converting it into a stream\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique, options)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue\n    }\n\n    // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n    if (obj.isDuplicate) {\n      continue\n    }\n\n    // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    }\n  }\n}\n\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\nfunction formatLink (srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString())\n  out = out.replace(/<dst>/g, dstCid.toString())\n  out = out.replace(/<linkname>/g, linkName)\n  return out\n}\n\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n * @param {AbortOptions} options\n */\nasync function * objectStream (repo, codecs, rootCid, maxDepth, uniqueOnly, options) { // eslint-disable-line require-await\n  const seen = new Set()\n\n  /**\n   * @param {Node} parent\n   * @param {number} depth\n   * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n   */\n  async function * traverseLevel (parent, depth) {\n    const nextLevelDepth = depth + 1\n\n    // Check the depth\n    if (nextLevelDepth > maxDepth) {\n      return\n    }\n\n    // Get this object's links\n    try {\n      // Look at each link, parent and the new depth\n      for await (const link of getLinks(repo, codecs, parent.cid, options)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        }\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString())\n        }\n\n        yield * traverseLevel(link, nextLevelDepth)\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`\n      }\n\n      throw err\n    }\n  }\n\n  yield * traverseLevel({ cid: rootCid }, 0)\n}\n\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} cid\n * @param {AbortOptions} options\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\nasync function * getLinks (repo, codecs, cid, options) {\n  const block = await repo.blocks.get(cid, options)\n  const codec = await codecs.getCodec(cid.code)\n  const value = codec.decode(block)\n  const isDagPb = cid.code === dagPb.code\n  /** @type {Array<string|number>} */\n  const base = []\n\n  for (const [name, cid] of links(value, base)) {\n    // special case for dag-pb - use the name of the link\n    // instead of the path within the object\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/)\n\n      if (match) {\n        const index = Number(match[1])\n\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          }\n\n          continue\n        }\n      }\n    }\n\n    yield {\n      name,\n      cid\n    }\n  }\n}\n\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nconst links = function * (source, base) {\n  if (source == null) {\n    return\n  }\n\n  if (source instanceof Uint8Array) {\n    return\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key]\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index]\n          const cid = CID.asCID(element)\n\n          // eslint-disable-next-line max-depth\n          if (cid) {\n            yield [elementPath.join('/'), cid]\n          } else if (typeof element === 'object') {\n            yield * links(element, elementPath)\n          }\n        }\n      } else {\n        const cid = CID.asCID(value)\n\n        if (cid) {\n          yield [path.join('/'), cid]\n        } else {\n          yield * links(value, path)\n        }\n      }\n    }\n  }\n\n  // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n  return []\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}