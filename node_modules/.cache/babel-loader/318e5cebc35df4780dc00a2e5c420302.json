{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst PeerId = require('peer-id');\n\nconst crypto = require('libp2p-crypto');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst c = require('../constants');\n\nconst Message = require('../message');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {import('../index')} dht\n */\n\n\nmodule.exports = dht => {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   */\n  const findPeerLocal = async peer => {\n    dht._log(`findPeerLocal ${peer.toB58String()}`);\n\n    const p = await dht.routingTable.find(peer);\n    /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n\n    const peerData = p && dht.peerStore.get(p);\n\n    if (peerData) {\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map(address => address.multiaddr)\n      };\n    }\n  };\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n\n\n  const getValueSingle = async (peer, key) => {\n    // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0);\n    return dht.network.sendRequest(peer, msg);\n  };\n  /**\n   * Find close peers for a given peer\n   *\n   * @param {Uint8Array} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}\n   * @private\n   */\n\n\n  const closerPeersSingle = async (key, peer) => {\n    dht._log(`closerPeersSingle ${uint8ArrayToString(key, 'base32')} from ${peer.toB58String()}`);\n\n    const msg = await dht.peerRouting._findPeerSingle(peer, new PeerId(key));\n    return msg.closerPeers.filter(peerData => !dht._isSelf(peerData.id)).map(peerData => {\n      dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs);\n      return peerData;\n    });\n  };\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  const getPublicKeyFromNode = async peer => {\n    const pkKey = utils.keyForPublicKey(peer);\n    const msg = await getValueSingle(peer, pkKey);\n\n    if (!msg.record || !msg.record.value) {\n      throw errcode(new Error(`Node not responding with its public key: ${peer.toB58String()}`), 'ERR_INVALID_RECORD');\n    }\n\n    const recPeer = await PeerId.createFromPubKey(msg.record.value); // compare hashes of the pub key\n\n    if (!recPeer.equals(peer)) {\n      throw errcode(new Error('public key does not match id'), 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n    }\n\n    return recPeer.pubKey;\n  };\n\n  return {\n    /**\n     * Ask peer `peer` if they know where the peer with id `target` is.\n     *\n     * @param {PeerId} peer\n     * @param {PeerId} target\n     * @returns {Promise<Message>}\n     * @private\n     */\n    async _findPeerSingle(peer, target) {\n      // eslint-disable-line require-await\n      dht._log('findPeerSingle %s', peer.toB58String());\n\n      const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);\n      return dht.network.sendRequest(peer, msg);\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     *\n     * @param {PeerId} id\n     * @param {Object} [options] - findPeer options\n     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async findPeer(id) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        timeout: 60000\n      };\n      options.timeout = options.timeout || c.minute;\n\n      dht._log('findPeer %s', id.toB58String()); // Try to find locally\n\n\n      const pi = await findPeerLocal(id); // already got it\n\n      if (pi != null) {\n        dht._log('found local');\n\n        return pi;\n      }\n\n      const key = await utils.convertPeerId(id);\n      const peers = dht.routingTable.closestPeers(key, dht.kBucketSize);\n\n      if (peers.length === 0) {\n        throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED');\n      } // sanity check\n\n\n      const match = peers.find(p => p.isEqual(id));\n\n      if (match) {\n        /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n        const peer = dht.peerStore.get(id);\n\n        if (peer) {\n          dht._log('found in peerStore');\n\n          return {\n            id: peer.id,\n            multiaddrs: peer.addresses.map(address => address.multiaddr)\n          };\n        }\n      } // query the network\n\n\n      const query = new Query(dht, id.id, () => {\n        /**\n         * There is no distinction between the disjoint paths, so there are no per-path\n         * variables in dht scope. Just return the actual query function.\n         *\n         * @param {PeerId} peer\n         */\n        const queryFn = async peer => {\n          const msg = await this._findPeerSingle(peer, id);\n          const match = msg.closerPeers.find(p => p.id.isEqual(id)); // found it\n\n          if (match) {\n            return {\n              peer: match,\n              queryComplete: true\n            };\n          }\n\n          return {\n            closerPeers: msg.closerPeers\n          };\n        };\n\n        return queryFn;\n      });\n      let result;\n\n      try {\n        result = await pTimeout(query.run(peers), options.timeout);\n      } finally {\n        query.stop();\n      }\n\n      let success = false;\n      result.paths.forEach(result => {\n        if (result.success && result.peer) {\n          success = true;\n          dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs);\n        }\n      });\n\n      dht._log('findPeer %s: %s', id.toB58String(), success);\n\n      if (!success) {\n        throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND');\n      }\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n\n\n      const peerData = dht.peerStore.get(id);\n\n      if (!peerData) {\n        throw errcode(new Error('No peer found in peer store'), 'ERR_NOT_FOUND');\n      }\n\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map(address => address.multiaddr)\n      };\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     *\n     * @param {Uint8Array} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow=false] - shallow query\n     * @returns {AsyncIterable<PeerId>}\n     */\n    async *getClosestPeers(key) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shallow: false\n      };\n\n      dht._log('getClosestPeers to %b', key);\n\n      const id = await utils.convertBuffer(key);\n      const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize);\n      const q = new Query(dht, key, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async peer => {\n          const closer = await closerPeersSingle(key, peer);\n          return {\n            closerPeers: closer,\n            pathComplete: options.shallow ? true : undefined\n          };\n        };\n      });\n      const res = await q.run(tablePeers);\n\n      if (!res || !res.finalSet) {\n        return [];\n      }\n\n      const sorted = await utils.sortClosestPeers(Array.from(res.finalSet), id);\n\n      for (const pId of sorted.slice(0, dht.kBucketSize)) {\n        yield pId;\n      }\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     *\n     * @param {PeerId} peer\n     */\n    async getPublicKey(peer) {\n      dht._log('getPublicKey %s', peer.toB58String()); // local check\n\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n\n\n      const peerData = dht.peerStore.get(peer);\n\n      if (peerData && peerData.id.pubKey) {\n        dht._log('getPublicKey: found local copy');\n\n        return peerData.id.pubKey;\n      } // try the node directly\n\n\n      let pk;\n\n      try {\n        pk = await getPublicKeyFromNode(peer);\n      } catch (err) {\n        // try dht directly\n        const pkKey = utils.keyForPublicKey(peer);\n        const value = await dht.get(pkKey);\n        pk = crypto.keys.unmarshalPublicKey(value);\n      }\n\n      const peerId = new PeerId(peer.id, undefined, pk);\n      const addrs = (peerData && peerData.addresses || []).map(address => address.multiaddr);\n      dht.peerStore.addressBook.add(peerId, addrs);\n      dht.peerStore.keyBook.set(peerId, pk);\n      return pk;\n    }\n\n  };\n};","map":{"version":3,"names":["errcode","require","pTimeout","PeerId","crypto","toString","uint8ArrayToString","c","Message","Query","utils","module","exports","dht","findPeerLocal","peer","_log","toB58String","p","routingTable","find","peerData","peerStore","get","id","multiaddrs","addresses","map","address","multiaddr","getValueSingle","key","msg","TYPES","GET_VALUE","network","sendRequest","closerPeersSingle","peerRouting","_findPeerSingle","closerPeers","filter","_isSelf","addressBook","add","getPublicKeyFromNode","pkKey","keyForPublicKey","record","value","Error","recPeer","createFromPubKey","equals","pubKey","target","FIND_NODE","findPeer","options","timeout","minute","pi","convertPeerId","peers","closestPeers","kBucketSize","length","match","isEqual","query","queryFn","queryComplete","result","run","stop","success","paths","forEach","getClosestPeers","shallow","convertBuffer","tablePeers","q","closer","pathComplete","undefined","res","finalSet","sorted","sortClosestPeers","Array","from","pId","slice","getPublicKey","pk","err","keys","unmarshalPublicKey","peerId","addrs","keyBook","set"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-kad-dht/src/peer-routing/index.js"],"sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\n\nconst PeerId = require('peer-id')\nconst crypto = require('libp2p-crypto')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst c = require('../constants')\nconst Message = require('../message')\nconst Query = require('../query')\n\nconst utils = require('../utils')\n\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {import('../index')} dht\n */\nmodule.exports = (dht) => {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   */\n  const findPeerLocal = async (peer) => {\n    dht._log(`findPeerLocal ${peer.toB58String()}`)\n    const p = await dht.routingTable.find(peer)\n\n    /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n    const peerData = p && dht.peerStore.get(p)\n\n    if (peerData) {\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n      }\n    }\n  }\n\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n  const getValueSingle = async (peer, key) => { // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0)\n    return dht.network.sendRequest(peer, msg)\n  }\n\n  /**\n   * Find close peers for a given peer\n   *\n   * @param {Uint8Array} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}\n   * @private\n   */\n\n  const closerPeersSingle = async (key, peer) => {\n    dht._log(`closerPeersSingle ${uint8ArrayToString(key, 'base32')} from ${peer.toB58String()}`)\n    const msg = await dht.peerRouting._findPeerSingle(peer, new PeerId(key))\n\n    return msg.closerPeers\n      .filter((peerData) => !dht._isSelf(peerData.id))\n      .map((peerData) => {\n        dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs)\n\n        return peerData\n      })\n  }\n\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   */\n  const getPublicKeyFromNode = async (peer) => {\n    const pkKey = utils.keyForPublicKey(peer)\n    const msg = await getValueSingle(peer, pkKey)\n\n    if (!msg.record || !msg.record.value) {\n      throw errcode(new Error(`Node not responding with its public key: ${peer.toB58String()}`), 'ERR_INVALID_RECORD')\n    }\n\n    const recPeer = await PeerId.createFromPubKey(msg.record.value)\n\n    // compare hashes of the pub key\n    if (!recPeer.equals(peer)) {\n      throw errcode(new Error('public key does not match id'), 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID')\n    }\n\n    return recPeer.pubKey\n  }\n\n  return {\n  /**\n   * Ask peer `peer` if they know where the peer with id `target` is.\n   *\n   * @param {PeerId} peer\n   * @param {PeerId} target\n   * @returns {Promise<Message>}\n   * @private\n   */\n    async _findPeerSingle (peer, target) { // eslint-disable-line require-await\n      dht._log('findPeerSingle %s', peer.toB58String())\n      const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0)\n\n      return dht.network.sendRequest(peer, msg)\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     *\n     * @param {PeerId} id\n     * @param {Object} [options] - findPeer options\n     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async findPeer (id, options = { timeout: 60000 }) {\n      options.timeout = options.timeout || c.minute\n      dht._log('findPeer %s', id.toB58String())\n\n      // Try to find locally\n      const pi = await findPeerLocal(id)\n\n      // already got it\n      if (pi != null) {\n        dht._log('found local')\n        return pi\n      }\n\n      const key = await utils.convertPeerId(id)\n      const peers = dht.routingTable.closestPeers(key, dht.kBucketSize)\n\n      if (peers.length === 0) {\n        throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED')\n      }\n\n      // sanity check\n      const match = peers.find((p) => p.isEqual(id))\n      if (match) {\n        /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n        const peer = dht.peerStore.get(id)\n\n        if (peer) {\n          dht._log('found in peerStore')\n          return {\n            id: peer.id,\n            multiaddrs: peer.addresses.map((address) => address.multiaddr)\n          }\n        }\n      }\n\n      // query the network\n      const query = new Query(dht, id.id, () => {\n        /**\n         * There is no distinction between the disjoint paths, so there are no per-path\n         * variables in dht scope. Just return the actual query function.\n         *\n         * @param {PeerId} peer\n         */\n        const queryFn = async (peer) => {\n          const msg = await this._findPeerSingle(peer, id)\n          const match = msg.closerPeers.find((p) => p.id.isEqual(id))\n\n          // found it\n          if (match) {\n            return {\n              peer: match,\n              queryComplete: true\n            }\n          }\n\n          return {\n            closerPeers: msg.closerPeers\n          }\n        }\n\n        return queryFn\n      })\n\n      let result\n      try {\n        result = await pTimeout(query.run(peers), options.timeout)\n      } finally {\n        query.stop()\n      }\n\n      let success = false\n      result.paths.forEach((result) => {\n        if (result.success && result.peer) {\n          success = true\n          dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs)\n        }\n      })\n      dht._log('findPeer %s: %s', id.toB58String(), success)\n\n      if (!success) {\n        throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND')\n      }\n\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n      const peerData = dht.peerStore.get(id)\n\n      if (!peerData) {\n        throw errcode(new Error('No peer found in peer store'), 'ERR_NOT_FOUND')\n      }\n\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n      }\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     *\n     * @param {Uint8Array} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow=false] - shallow query\n     * @returns {AsyncIterable<PeerId>}\n     */\n    async * getClosestPeers (key, options = { shallow: false }) {\n      dht._log('getClosestPeers to %b', key)\n\n      const id = await utils.convertBuffer(key)\n      const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize)\n\n      const q = new Query(dht, key, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async (peer) => {\n          const closer = await closerPeersSingle(key, peer)\n\n          return {\n            closerPeers: closer,\n            pathComplete: options.shallow ? true : undefined\n          }\n        }\n      })\n\n      const res = await q.run(tablePeers)\n      if (!res || !res.finalSet) {\n        return []\n      }\n\n      const sorted = await utils.sortClosestPeers(Array.from(res.finalSet), id)\n\n      for (const pId of sorted.slice(0, dht.kBucketSize)) {\n        yield pId\n      }\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     *\n     * @param {PeerId} peer\n     */\n    async getPublicKey (peer) {\n      dht._log('getPublicKey %s', peer.toB58String())\n\n      // local check\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n      const peerData = dht.peerStore.get(peer)\n\n      if (peerData && peerData.id.pubKey) {\n        dht._log('getPublicKey: found local copy')\n        return peerData.id.pubKey\n      }\n\n      // try the node directly\n      let pk\n\n      try {\n        pk = await getPublicKeyFromNode(peer)\n      } catch (err) {\n        // try dht directly\n        const pkKey = utils.keyForPublicKey(peer)\n        const value = await dht.get(pkKey)\n        pk = crypto.keys.unmarshalPublicKey(value)\n      }\n\n      const peerId = new PeerId(peer.id, undefined, pk)\n      const addrs = ((peerData && peerData.addresses) || []).map((address) => address.multiaddr)\n      dht.peerStore.addressBook.add(peerId, addrs)\n      dht.peerStore.keyBook.set(peerId, pk)\n\n      return pk\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}