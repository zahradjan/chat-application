{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar crypto = require('libp2p-crypto');\n\nvar Buffer = require('safe-buffer/').Buffer;\n\nmodule.exports = {\n  verify: function () {\n    var _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(signature, publicKey, data) {\n      var isValid, res, pubKey;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (signature) {\n                _context.next = 2;\n                break;\n              }\n\n              throw new Error('No signature given');\n\n            case 2:\n              if (publicKey) {\n                _context.next = 4;\n                break;\n              }\n\n              throw new Error('Given publicKey was undefined');\n\n            case 4:\n              if (data) {\n                _context.next = 6;\n                break;\n              }\n\n              throw new Error('Given input data was undefined');\n\n            case 6:\n              if (!Buffer.isBuffer(data)) {\n                data = Buffer.from(data);\n              }\n\n              isValid = function isValid(key, msg, sig) {\n                return new Promise(function (resolve, reject) {\n                  key.verify(msg, sig, function (err, valid) {\n                    if (!err) {\n                      resolve(valid);\n                    }\n\n                    reject(valid);\n                  });\n                });\n              };\n\n              res = false;\n              _context.prev = 9;\n              pubKey = crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(Buffer.from(publicKey, 'hex'));\n              _context.next = 13;\n              return isValid(pubKey, data, Buffer.from(signature, 'hex'));\n\n            case 13:\n              res = _context.sent;\n              _context.next = 18;\n              break;\n\n            case 16:\n              _context.prev = 16;\n              _context.t0 = _context[\"catch\"](9);\n\n            case 18:\n              return _context.abrupt(\"return\", Promise.resolve(res));\n\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[9, 16]]);\n    }));\n\n    function verify(_x, _x2, _x3) {\n      return _verify.apply(this, arguments);\n    }\n\n    return verify;\n  }()\n};","map":{"version":3,"names":["crypto","require","Buffer","module","exports","verify","signature","publicKey","data","Error","isBuffer","from","isValid","key","msg","sig","Promise","resolve","reject","err","valid","res","pubKey","keys","supportedKeys","secp256k1","unmarshalSecp256k1PublicKey"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/orbit-db-keystore/src/verifiers/verifierv1.js"],"sourcesContent":["'use strict'\nconst crypto = require('libp2p-crypto')\nconst Buffer = require('safe-buffer/').Buffer\n\nmodule.exports = {\n  verify: async (signature, publicKey, data) => {\n    if (!signature) {\n      throw new Error('No signature given')\n    }\n    if (!publicKey) {\n      throw new Error('Given publicKey was undefined')\n    }\n    if (!data) {\n      throw new Error('Given input data was undefined')\n    }\n\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data)\n    }\n\n    const isValid = (key, msg, sig) => new Promise((resolve, reject) => {\n      key.verify(msg, sig, (err, valid) => {\n        if (!err) {\n          resolve(valid)\n        }\n        reject(valid)\n      })\n    })\n\n    let res = false\n    try {\n      const pubKey = crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(Buffer.from(publicKey, 'hex'))\n      res = await isValid(pubKey, data, Buffer.from(signature, 'hex'))\n    } catch (e) {\n      // Catch error: sig length wrong\n    }\n    return Promise.resolve(res)\n  }\n}\n"],"mappings":"AAAA;;;;;;AACA,IAAMA,MAAM,GAAGC,OAAO,CAAC,eAAD,CAAtB;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,cAAD,CAAP,CAAwBC,MAAvC;;AAEAC,MAAM,CAACC,OAAP,GAAiB;EACfC,MAAM;IAAA,yEAAE,iBAAOC,SAAP,EAAkBC,SAAlB,EAA6BC,IAA7B;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA,IACDF,SADC;gBAAA;gBAAA;cAAA;;cAAA,MAEE,IAAIG,KAAJ,CAAU,oBAAV,CAFF;;YAAA;cAAA,IAIDF,SAJC;gBAAA;gBAAA;cAAA;;cAAA,MAKE,IAAIE,KAAJ,CAAU,+BAAV,CALF;;YAAA;cAAA,IAODD,IAPC;gBAAA;gBAAA;cAAA;;cAAA,MAQE,IAAIC,KAAJ,CAAU,gCAAV,CARF;;YAAA;cAWN,IAAI,CAACP,MAAM,CAACQ,QAAP,CAAgBF,IAAhB,CAAL,EAA4B;gBAC1BA,IAAI,GAAGN,MAAM,CAACS,IAAP,CAAYH,IAAZ,CAAP;cACD;;cAEKI,OAfA,GAeU,SAAVA,OAAU,CAACC,GAAD,EAAMC,GAAN,EAAWC,GAAX;gBAAA,OAAmB,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;kBAClEL,GAAG,CAACR,MAAJ,CAAWS,GAAX,EAAgBC,GAAhB,EAAqB,UAACI,GAAD,EAAMC,KAAN,EAAgB;oBACnC,IAAI,CAACD,GAAL,EAAU;sBACRF,OAAO,CAACG,KAAD,CAAP;oBACD;;oBACDF,MAAM,CAACE,KAAD,CAAN;kBACD,CALD;gBAMD,CAPkC,CAAnB;cAAA,CAfV;;cAwBFC,GAxBE,GAwBI,KAxBJ;cAAA;cA0BEC,MA1BF,GA0BWtB,MAAM,CAACuB,IAAP,CAAYC,aAAZ,CAA0BC,SAA1B,CAAoCC,2BAApC,CAAgExB,MAAM,CAACS,IAAP,CAAYJ,SAAZ,EAAuB,KAAvB,CAAhE,CA1BX;cAAA;cAAA,OA2BQK,OAAO,CAACU,MAAD,EAASd,IAAT,EAAeN,MAAM,CAACS,IAAP,CAAYL,SAAZ,EAAuB,KAAvB,CAAf,CA3Bf;;YAAA;cA2BJe,GA3BI;cAAA;cAAA;;YAAA;cAAA;cAAA;;YAAA;cAAA,iCA+BCL,OAAO,CAACC,OAAR,CAAgBI,GAAhB,CA/BD;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAAF;;IAAA;MAAA;IAAA;;IAAA;EAAA;AADS,CAAjB"},"metadata":{},"sourceType":"script"}