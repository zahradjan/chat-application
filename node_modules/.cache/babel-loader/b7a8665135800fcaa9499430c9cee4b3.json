{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar debug = require('debug');\n\nvar log = Object.assign(debug('libp2p:keychain'), {\n  error: debug('libp2p:keychain:err')\n});\n\nvar sanitize = require('sanitize-filename');\n\nvar mergeOptions = require('merge-options');\n\nvar crypto = require('libp2p-crypto');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar CMS = require('./cms');\n\nvar errcode = require('err-code');\n\nvar _require2 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require2.toString;\n\nvar _require3 = require('uint8arrays/from-string'),\n    uint8ArrayFromString = _require3.fromString; // @ts-ignore node-forge sha512 types not exported\n\n\nrequire('node-forge/lib/sha512');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @typedef {Object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {Object} KeychainOptions\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n */\n\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\n\nvar keyPrefix = '/pkcs8/';\nvar infoPrefix = '/info/';\nvar privates = new WeakMap(); // NIST SP 800-132\n\nvar NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n};\nvar defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n};\n/**\n * @param {string} name\n */\n\nfunction validateKeyName(name) {\n  if (!name) return false;\n  if (typeof name !== 'string') return false;\n  return name === sanitize(name.trim());\n}\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {string|Error} err - The error\n * @returns {Promise<never>}\n * @private\n */\n\n\nfunction throwDelayed(_x) {\n  return _throwDelayed.apply(this, arguments);\n}\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {Key}\n * @private\n */\n\n\nfunction _throwDelayed() {\n  _throwDelayed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(err) {\n    var min, max, delay;\n    return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            min = 200;\n            max = 1000;\n            delay = Math.random() * (max - min) + min;\n            _context12.next = 5;\n            return new Promise(function (resolve) {\n              return setTimeout(resolve, delay);\n            });\n\n          case 5:\n            throw err;\n\n          case 6:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12);\n  }));\n  return _throwDelayed.apply(this, arguments);\n}\n\nfunction DsName(name) {\n  return new Key(keyPrefix + name);\n}\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {Key}\n * @private\n */\n\n\nfunction DsInfoName(name) {\n  return new Key(infoPrefix + name);\n}\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\n\n\nvar Keychain = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {Datastore} store - where the key are.\n   * @param {KeychainOptions} options\n   * @class\n   */\n  function Keychain(store, options) {\n    _classCallCheck(this, Keychain);\n\n    if (!store) {\n      throw new Error('store is required');\n    }\n\n    this.store = store;\n    this.opts = mergeOptions(defaultOptions, options); // Enforce NIST SP 800-132\n\n    if (this.opts.pass && this.opts.pass.length < 20) {\n      throw new Error('pass must be least 20 characters');\n    }\n\n    if (this.opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(\"dek.keyLength must be least \".concat(NIST.minKeyLength, \" bytes\"));\n    }\n\n    if (this.opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(\"dek.saltLength must be least \".concat(NIST.minSaltLength, \" bytes\"));\n    }\n\n    if (this.opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(\"dek.iterationCount must be least \".concat(NIST.minIterationCount));\n    }\n\n    var dek = this.opts.pass ? crypto.pbkdf2(this.opts.pass, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : '';\n    privates.set(this, {\n      dek: dek\n    });\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n\n\n  _createClass(Keychain, [{\n    key: \"cms\",\n    get: function get() {\n      return new CMS(this, privates.get(this).dek);\n    }\n    /**\n     * Generates the options for a keychain.  A random salt is produced.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"createKey\",\n    value:\n    /**\n     * Create a new key.\n     *\n     * @param {string} name - The local key name; cannot already exist.\n     * @param {string} type - One of the key types; 'rsa'.\n     * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only.\n     * @returns {Promise<KeyInfo>}\n     */\n    function () {\n      var _createKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(name, type) {\n        var size,\n            self,\n            dsname,\n            exists,\n            keyInfo,\n            keypair,\n            kid,\n            dek,\n            pem,\n            batch,\n            _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                size = _args.length > 2 && _args[2] !== undefined ? _args[2] : 2048;\n                self = this;\n\n                if (!(!validateKeyName(name) || name === 'self')) {\n                  _context.next = 4;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 4:\n                if (!(typeof type !== 'string')) {\n                  _context.next = 6;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key type '\".concat(type, \"'\")), 'ERR_INVALID_KEY_TYPE')));\n\n              case 6:\n                dsname = DsName(name);\n                _context.next = 9;\n                return self.store.has(dsname);\n\n              case 9:\n                exists = _context.sent;\n\n                if (!exists) {\n                  _context.next = 12;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS')));\n\n              case 12:\n                _context.t0 = type.toLowerCase();\n                _context.next = _context.t0 === 'rsa' ? 15 : 18;\n                break;\n\n              case 15:\n                if (!(!Number.isSafeInteger(size) || size < 2048)) {\n                  _context.next = 17;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid RSA key size \".concat(size)), 'ERR_INVALID_KEY_SIZE')));\n\n              case 17:\n                return _context.abrupt(\"break\", 19);\n\n              case 18:\n                return _context.abrupt(\"break\", 19);\n\n              case 19:\n                _context.prev = 19;\n                _context.next = 22;\n                return crypto.keys.generateKeyPair(type, size);\n\n              case 22:\n                keypair = _context.sent;\n                _context.next = 25;\n                return keypair.id();\n\n              case 25:\n                kid = _context.sent;\n\n                /** @type {string} */\n                dek = privates.get(this).dek;\n                _context.next = 29;\n                return keypair.export(dek);\n\n              case 29:\n                pem = _context.sent;\n                keyInfo = {\n                  name: name,\n                  id: kid\n                };\n                batch = self.store.batch();\n                batch.put(dsname, uint8ArrayFromString(pem));\n                batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n                _context.next = 36;\n                return batch.commit();\n\n              case 36:\n                _context.next = 41;\n                break;\n\n              case 38:\n                _context.prev = 38;\n                _context.t1 = _context[\"catch\"](19);\n                return _context.abrupt(\"return\", throwDelayed(_context.t1));\n\n              case 41:\n                return _context.abrupt(\"return\", keyInfo);\n\n              case 42:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[19, 38]]);\n      }));\n\n      function createKey(_x2, _x3) {\n        return _createKey.apply(this, arguments);\n      }\n\n      return createKey;\n    }()\n    /**\n     * List all the keys.\n     *\n     * @returns {Promise<KeyInfo[]>}\n     */\n\n  }, {\n    key: \"listKeys\",\n    value: function () {\n      var _listKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var self, query, info, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, value;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                self = this;\n                query = {\n                  prefix: infoPrefix\n                };\n                info = [];\n                _iteratorAbruptCompletion = false;\n                _didIteratorError = false;\n                _context2.prev = 5;\n                _iterator = _asyncIterator(self.store.query(query));\n\n              case 7:\n                _context2.next = 9;\n                return _iterator.next();\n\n              case 9:\n                if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                value = _step.value;\n                info.push(JSON.parse(uint8ArrayToString(value.value)));\n\n              case 12:\n                _iteratorAbruptCompletion = false;\n                _context2.next = 7;\n                break;\n\n              case 15:\n                _context2.next = 21;\n                break;\n\n              case 17:\n                _context2.prev = 17;\n                _context2.t0 = _context2[\"catch\"](5);\n                _didIteratorError = true;\n                _iteratorError = _context2.t0;\n\n              case 21:\n                _context2.prev = 21;\n                _context2.prev = 22;\n\n                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                  _context2.next = 26;\n                  break;\n                }\n\n                _context2.next = 26;\n                return _iterator.return();\n\n              case 26:\n                _context2.prev = 26;\n\n                if (!_didIteratorError) {\n                  _context2.next = 29;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 29:\n                return _context2.finish(26);\n\n              case 30:\n                return _context2.finish(21);\n\n              case 31:\n                return _context2.abrupt(\"return\", info);\n\n              case 32:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[5, 17, 21, 31], [22,, 26, 30]]);\n      }));\n\n      function listKeys() {\n        return _listKeys.apply(this, arguments);\n      }\n\n      return listKeys;\n    }()\n    /**\n     * Find a key by it's id.\n     *\n     * @param {string} id - The universally unique key identifier.\n     * @returns {Promise<KeyInfo|undefined>}\n     */\n\n  }, {\n    key: \"findKeyById\",\n    value: function () {\n      var _findKeyById = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(id) {\n        var keys;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return this.listKeys();\n\n              case 3:\n                keys = _context3.sent;\n                return _context3.abrupt(\"return\", keys.find(function (k) {\n                  return k.id === id;\n                }));\n\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](0);\n                return _context3.abrupt(\"return\", throwDelayed(_context3.t0));\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 7]]);\n      }));\n\n      function findKeyById(_x4) {\n        return _findKeyById.apply(this, arguments);\n      }\n\n      return findKeyById;\n    }()\n    /**\n     * Find a key by it's name.\n     *\n     * @param {string} name - The local key name.\n     * @returns {Promise<KeyInfo>}\n     */\n\n  }, {\n    key: \"findKeyByName\",\n    value: function () {\n      var _findKeyByName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(name) {\n        var dsname, res;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (validateKeyName(name)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 2:\n                dsname = DsInfoName(name);\n                _context4.prev = 3;\n                _context4.next = 6;\n                return this.store.get(dsname);\n\n              case 6:\n                res = _context4.sent;\n                return _context4.abrupt(\"return\", JSON.parse(uint8ArrayToString(res)));\n\n              case 10:\n                _context4.prev = 10;\n                _context4.t0 = _context4[\"catch\"](3);\n                return _context4.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' does not exist. \").concat(_context4.t0.message)), 'ERR_KEY_NOT_FOUND')));\n\n              case 13:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[3, 10]]);\n      }));\n\n      function findKeyByName(_x5) {\n        return _findKeyByName.apply(this, arguments);\n      }\n\n      return findKeyByName;\n    }()\n    /**\n     * Remove an existing key.\n     *\n     * @param {string} name - The local key name; must already exist.\n     * @returns {Promise<KeyInfo>}\n     */\n\n  }, {\n    key: \"removeKey\",\n    value: function () {\n      var _removeKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(name) {\n        var self, dsname, keyInfo, batch;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                self = this;\n\n                if (!(!validateKeyName(name) || name === 'self')) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 3:\n                dsname = DsName(name);\n                _context5.next = 6;\n                return self.findKeyByName(name);\n\n              case 6:\n                keyInfo = _context5.sent;\n                batch = self.store.batch();\n                batch.delete(dsname);\n                batch.delete(DsInfoName(name));\n                _context5.next = 12;\n                return batch.commit();\n\n              case 12:\n                return _context5.abrupt(\"return\", keyInfo);\n\n              case 13:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function removeKey(_x6) {\n        return _removeKey.apply(this, arguments);\n      }\n\n      return removeKey;\n    }()\n    /**\n     * Rename a key\n     *\n     * @param {string} oldName - The old local key name; must already exist.\n     * @param {string} newName - The new local key name; must not already exist.\n     * @returns {Promise<KeyInfo>}\n     */\n\n  }, {\n    key: \"renameKey\",\n    value: function () {\n      var _renameKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(oldName, newName) {\n        var self, oldDsname, newDsname, oldInfoName, newInfoName, exists, pem, res, keyInfo, batch;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                self = this;\n\n                if (!(!validateKeyName(oldName) || oldName === 'self')) {\n                  _context6.next = 3;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid old key name '\".concat(oldName, \"'\")), 'ERR_OLD_KEY_NAME_INVALID')));\n\n              case 3:\n                if (!(!validateKeyName(newName) || newName === 'self')) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid new key name '\".concat(newName, \"'\")), 'ERR_NEW_KEY_NAME_INVALID')));\n\n              case 5:\n                oldDsname = DsName(oldName);\n                newDsname = DsName(newName);\n                oldInfoName = DsInfoName(oldName);\n                newInfoName = DsInfoName(newName);\n                _context6.next = 11;\n                return self.store.has(newDsname);\n\n              case 11:\n                exists = _context6.sent;\n\n                if (!exists) {\n                  _context6.next = 14;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(newName, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS')));\n\n              case 14:\n                _context6.prev = 14;\n                _context6.next = 17;\n                return self.store.get(oldDsname);\n\n              case 17:\n                pem = _context6.sent;\n                _context6.next = 20;\n                return self.store.get(oldInfoName);\n\n              case 20:\n                res = _context6.sent;\n                keyInfo = JSON.parse(uint8ArrayToString(res));\n                keyInfo.name = newName;\n                batch = self.store.batch();\n                batch.put(newDsname, pem);\n                batch.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)));\n                batch.delete(oldDsname);\n                batch.delete(oldInfoName);\n                _context6.next = 30;\n                return batch.commit();\n\n              case 30:\n                return _context6.abrupt(\"return\", keyInfo);\n\n              case 33:\n                _context6.prev = 33;\n                _context6.t0 = _context6[\"catch\"](14);\n                return _context6.abrupt(\"return\", throwDelayed(_context6.t0));\n\n              case 36:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[14, 33]]);\n      }));\n\n      function renameKey(_x7, _x8) {\n        return _renameKey.apply(this, arguments);\n      }\n\n      return renameKey;\n    }()\n    /**\n     * Export an existing key as a PEM encrypted PKCS #8 string\n     *\n     * @param {string} name - The local key name; must already exist.\n     * @param {string} password - The password\n     * @returns {Promise<string>}\n     */\n\n  }, {\n    key: \"exportKey\",\n    value: function () {\n      var _exportKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(name, password) {\n        var dsname, res, pem, dek, privateKey;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (validateKeyName(name)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 2:\n                if (password) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", throwDelayed(errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED')));\n\n              case 4:\n                dsname = DsName(name);\n                _context7.prev = 5;\n                _context7.next = 8;\n                return this.store.get(dsname);\n\n              case 8:\n                res = _context7.sent;\n                pem = uint8ArrayToString(res);\n                /** @type {string} */\n\n                dek = privates.get(this).dek;\n                _context7.next = 13;\n                return crypto.keys.import(pem, dek);\n\n              case 13:\n                privateKey = _context7.sent;\n                return _context7.abrupt(\"return\", privateKey.export(password));\n\n              case 17:\n                _context7.prev = 17;\n                _context7.t0 = _context7[\"catch\"](5);\n                return _context7.abrupt(\"return\", throwDelayed(_context7.t0));\n\n              case 20:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[5, 17]]);\n      }));\n\n      function exportKey(_x9, _x10) {\n        return _exportKey.apply(this, arguments);\n      }\n\n      return exportKey;\n    }()\n    /**\n     * Import a new key from a PEM encoded PKCS #8 string\n     *\n     * @param {string} name - The local key name; must not already exist.\n     * @param {string} pem - The PEM encoded PKCS #8 string\n     * @param {string} password - The password.\n     * @returns {Promise<KeyInfo>}\n     */\n\n  }, {\n    key: \"importKey\",\n    value: function () {\n      var _importKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(name, pem, password) {\n        var self, dsname, exists, privateKey, kid, dek, keyInfo, batch;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                self = this;\n\n                if (!(!validateKeyName(name) || name === 'self')) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 3:\n                if (pem) {\n                  _context8.next = 5;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", throwDelayed(errcode(new Error('PEM encoded key is required'), 'ERR_PEM_REQUIRED')));\n\n              case 5:\n                dsname = DsName(name);\n                _context8.next = 8;\n                return self.store.has(dsname);\n\n              case 8:\n                exists = _context8.sent;\n\n                if (!exists) {\n                  _context8.next = 11;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS')));\n\n              case 11:\n                _context8.prev = 11;\n                _context8.next = 14;\n                return crypto.keys.import(pem, password);\n\n              case 14:\n                privateKey = _context8.sent;\n                _context8.next = 20;\n                break;\n\n              case 17:\n                _context8.prev = 17;\n                _context8.t0 = _context8[\"catch\"](11);\n                return _context8.abrupt(\"return\", throwDelayed(errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY')));\n\n              case 20:\n                _context8.prev = 20;\n                _context8.next = 23;\n                return privateKey.id();\n\n              case 23:\n                kid = _context8.sent;\n\n                /** @type {string} */\n                dek = privates.get(this).dek;\n                _context8.next = 27;\n                return privateKey.export(dek);\n\n              case 27:\n                pem = _context8.sent;\n                _context8.next = 33;\n                break;\n\n              case 30:\n                _context8.prev = 30;\n                _context8.t1 = _context8[\"catch\"](20);\n                return _context8.abrupt(\"return\", throwDelayed(_context8.t1));\n\n              case 33:\n                keyInfo = {\n                  name: name,\n                  id: kid\n                };\n                batch = self.store.batch();\n                batch.put(dsname, uint8ArrayFromString(pem));\n                batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n                _context8.next = 39;\n                return batch.commit();\n\n              case 39:\n                return _context8.abrupt(\"return\", keyInfo);\n\n              case 40:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[11, 17], [20, 30]]);\n      }));\n\n      function importKey(_x11, _x12, _x13) {\n        return _importKey.apply(this, arguments);\n      }\n\n      return importKey;\n    }()\n    /**\n     * Import a peer key\n     *\n     * @param {string} name - The local key name; must not already exist.\n     * @param {PeerId} peer - The PEM encoded PKCS #8 string\n     * @returns {Promise<KeyInfo>}\n     */\n\n  }, {\n    key: \"importPeer\",\n    value: function () {\n      var _importPeer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(name, peer) {\n        var self, privateKey, dsname, exists, kid, dek, pem, keyInfo, batch;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                self = this;\n\n                if (validateKeyName(name)) {\n                  _context9.next = 3;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 3:\n                if (!(!peer || !peer.privKey)) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", throwDelayed(errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY')));\n\n              case 5:\n                privateKey = peer.privKey;\n                dsname = DsName(name);\n                _context9.next = 9;\n                return self.store.has(dsname);\n\n              case 9:\n                exists = _context9.sent;\n\n                if (!exists) {\n                  _context9.next = 12;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS')));\n\n              case 12:\n                _context9.prev = 12;\n                _context9.next = 15;\n                return privateKey.id();\n\n              case 15:\n                kid = _context9.sent;\n\n                /** @type {string} */\n                dek = privates.get(this).dek;\n                _context9.next = 19;\n                return privateKey.export(dek);\n\n              case 19:\n                pem = _context9.sent;\n                keyInfo = {\n                  name: name,\n                  id: kid\n                };\n                batch = self.store.batch();\n                batch.put(dsname, uint8ArrayFromString(pem));\n                batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n                _context9.next = 26;\n                return batch.commit();\n\n              case 26:\n                return _context9.abrupt(\"return\", keyInfo);\n\n              case 29:\n                _context9.prev = 29;\n                _context9.t0 = _context9[\"catch\"](12);\n                return _context9.abrupt(\"return\", throwDelayed(_context9.t0));\n\n              case 32:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[12, 29]]);\n      }));\n\n      function importPeer(_x14, _x15) {\n        return _importPeer.apply(this, arguments);\n      }\n\n      return importPeer;\n    }()\n    /**\n     * Gets the private key as PEM encoded PKCS #8 string.\n     *\n     * @param {string} name\n     * @returns {Promise<string>}\n     */\n\n  }, {\n    key: \"_getPrivateKey\",\n    value: function () {\n      var _getPrivateKey2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(name) {\n        var dsname, res;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (validateKeyName(name)) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 2:\n                _context10.prev = 2;\n                dsname = DsName(name);\n                _context10.next = 6;\n                return this.store.get(dsname);\n\n              case 6:\n                res = _context10.sent;\n                return _context10.abrupt(\"return\", uint8ArrayToString(res));\n\n              case 10:\n                _context10.prev = 10;\n                _context10.t0 = _context10[\"catch\"](2);\n                return _context10.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' does not exist. \").concat(_context10.t0.message)), 'ERR_KEY_NOT_FOUND')));\n\n              case 13:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[2, 10]]);\n      }));\n\n      function _getPrivateKey(_x16) {\n        return _getPrivateKey2.apply(this, arguments);\n      }\n\n      return _getPrivateKey;\n    }()\n    /**\n     * Rotate keychain password and re-encrypt all assosciated keys\n     *\n     * @param {string} oldPass - The old local keychain password\n     * @param {string} newPass - The new local keychain password\n     */\n\n  }, {\n    key: \"rotateKeychainPass\",\n    value: function () {\n      var _rotateKeychainPass = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(oldPass, newPass) {\n        var oldDek, newDek, keys, _iterator2, _step2, key, res, pem, privateKey, password, keyAsPEM, batch, keyInfo;\n\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!(typeof oldPass !== 'string')) {\n                  _context11.next = 2;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid old pass type '\".concat(typeof oldPass, \"'\")), 'ERR_INVALID_OLD_PASS_TYPE')));\n\n              case 2:\n                if (!(typeof newPass !== 'string')) {\n                  _context11.next = 4;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid new pass type '\".concat(typeof newPass, \"'\")), 'ERR_INVALID_NEW_PASS_TYPE')));\n\n              case 4:\n                if (!(newPass.length < 20)) {\n                  _context11.next = 6;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid pass length \".concat(newPass.length)), 'ERR_INVALID_PASS_LENGTH')));\n\n              case 6:\n                log('recreating keychain');\n                oldDek = privates.get(this).dek;\n                this.opts.pass = newPass;\n                newDek = newPass ? crypto.pbkdf2(newPass, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : '';\n                privates.set(this, {\n                  dek: newDek\n                });\n                _context11.next = 13;\n                return this.listKeys();\n\n              case 13:\n                keys = _context11.sent;\n                _iterator2 = _createForOfIteratorHelper(keys);\n                _context11.prev = 15;\n\n                _iterator2.s();\n\n              case 17:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context11.next = 38;\n                  break;\n                }\n\n                key = _step2.value;\n                _context11.next = 21;\n                return this.store.get(DsName(key.name));\n\n              case 21:\n                res = _context11.sent;\n                pem = uint8ArrayToString(res);\n                _context11.next = 25;\n                return crypto.keys.import(pem, oldDek);\n\n              case 25:\n                privateKey = _context11.sent;\n                password = newDek.toString();\n                _context11.next = 29;\n                return privateKey.export(password);\n\n              case 29:\n                keyAsPEM = _context11.sent;\n                // Update stored key\n                batch = this.store.batch();\n                keyInfo = {\n                  name: key.name,\n                  id: key.id\n                };\n                batch.put(DsName(key.name), uint8ArrayFromString(keyAsPEM));\n                batch.put(DsInfoName(key.name), uint8ArrayFromString(JSON.stringify(keyInfo)));\n                _context11.next = 36;\n                return batch.commit();\n\n              case 36:\n                _context11.next = 17;\n                break;\n\n              case 38:\n                _context11.next = 43;\n                break;\n\n              case 40:\n                _context11.prev = 40;\n                _context11.t0 = _context11[\"catch\"](15);\n\n                _iterator2.e(_context11.t0);\n\n              case 43:\n                _context11.prev = 43;\n\n                _iterator2.f();\n\n                return _context11.finish(43);\n\n              case 46:\n                log('keychain reconstructed');\n\n              case 47:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[15, 40, 43, 46]]);\n      }));\n\n      function rotateKeychainPass(_x17, _x18) {\n        return _rotateKeychainPass.apply(this, arguments);\n      }\n\n      return rotateKeychainPass;\n    }()\n  }], [{\n    key: \"generateOptions\",\n    value: function generateOptions() {\n      var options = Object.assign({}, defaultOptions);\n      var saltLength = Math.ceil(NIST.minSaltLength / 3) * 3; // no base64 padding\n\n      options.dek.salt = uint8ArrayToString(crypto.randomBytes(saltLength), 'base64');\n      return options;\n    }\n    /**\n     * Gets an object that can encrypt/decrypt protected data.\n     * The default options for a keychain.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"options\",\n    get: function get() {\n      return defaultOptions;\n    }\n  }]);\n\n  return Keychain;\n}();\n\nmodule.exports = Keychain;","map":{"version":3,"names":["debug","require","log","Object","assign","error","sanitize","mergeOptions","crypto","Key","CMS","errcode","uint8ArrayToString","toString","uint8ArrayFromString","fromString","keyPrefix","infoPrefix","privates","WeakMap","NIST","minKeyLength","minSaltLength","minIterationCount","defaultOptions","dek","keyLength","iterationCount","salt","hash","validateKeyName","name","trim","throwDelayed","err","min","max","delay","Math","random","Promise","resolve","setTimeout","DsName","DsInfoName","Keychain","store","options","Error","opts","pass","length","pbkdf2","set","get","type","size","self","dsname","has","exists","toLowerCase","Number","isSafeInteger","keys","generateKeyPair","keypair","id","kid","export","pem","keyInfo","batch","put","JSON","stringify","commit","query","prefix","info","value","push","parse","listKeys","find","k","res","message","findKeyByName","delete","oldName","newName","oldDsname","newDsname","oldInfoName","newInfoName","password","import","privateKey","peer","privKey","oldPass","newPass","oldDek","newDek","key","keyAsPEM","saltLength","ceil","randomBytes","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/keychain/index.js"],"sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict'\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:keychain'), {\n  error: debug('libp2p:keychain:err')\n})\nconst sanitize = require('sanitize-filename')\nconst mergeOptions = require('merge-options')\nconst crypto = require('libp2p-crypto')\nconst { Key } = require('interface-datastore')\nconst CMS = require('./cms')\nconst errcode = require('err-code')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\n\n// @ts-ignore node-forge sha512 types not exported\nrequire('node-forge/lib/sha512')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('interface-datastore').Datastore} Datastore\n */\n\n/**\n * @typedef {Object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {Object} KeychainOptions\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n */\n\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\nconst keyPrefix = '/pkcs8/'\nconst infoPrefix = '/info/'\nconst privates = new WeakMap()\n\n// NIST SP 800-132\nconst NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n}\n\nconst defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n}\n\n/**\n * @param {string} name\n */\nfunction validateKeyName (name) {\n  if (!name) return false\n  if (typeof name !== 'string') return false\n  return name === sanitize(name.trim())\n}\n\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {string|Error} err - The error\n * @returns {Promise<never>}\n * @private\n */\nasync function throwDelayed (err) {\n  const min = 200\n  const max = 1000\n  const delay = Math.random() * (max - min) + min\n\n  await new Promise(resolve => setTimeout(resolve, delay))\n  throw err\n}\n\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {Key}\n * @private\n */\nfunction DsName (name) {\n  return new Key(keyPrefix + name)\n}\n\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {Key}\n * @private\n */\nfunction DsInfoName (name) {\n  return new Key(infoPrefix + name)\n}\n\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\nclass Keychain {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {Datastore} store - where the key are.\n   * @param {KeychainOptions} options\n   * @class\n   */\n  constructor (store, options) {\n    if (!store) {\n      throw new Error('store is required')\n    }\n    this.store = store\n\n    this.opts = mergeOptions(defaultOptions, options)\n\n    // Enforce NIST SP 800-132\n    if (this.opts.pass && this.opts.pass.length < 20) {\n      throw new Error('pass must be least 20 characters')\n    }\n    if (this.opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`)\n    }\n    if (this.opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`)\n    }\n    if (this.opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`)\n    }\n\n    const dek = this.opts.pass\n      ? crypto.pbkdf2(\n        this.opts.pass,\n        this.opts.dek.salt,\n        this.opts.dek.iterationCount,\n        this.opts.dek.keyLength,\n        this.opts.dek.hash)\n      : ''\n\n    privates.set(this, { dek })\n  }\n\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n  get cms () {\n    return new CMS(this, privates.get(this).dek)\n  }\n\n  /**\n   * Generates the options for a keychain.  A random salt is produced.\n   *\n   * @returns {Object}\n   */\n  static generateOptions () {\n    const options = Object.assign({}, defaultOptions)\n    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3 // no base64 padding\n    options.dek.salt = uint8ArrayToString(crypto.randomBytes(saltLength), 'base64')\n    return options\n  }\n\n  /**\n   * Gets an object that can encrypt/decrypt protected data.\n   * The default options for a keychain.\n   *\n   * @returns {Object}\n   */\n  static get options () {\n    return defaultOptions\n  }\n\n  /**\n   * Create a new key.\n   *\n   * @param {string} name - The local key name; cannot already exist.\n   * @param {string} type - One of the key types; 'rsa'.\n   * @param {number} [size = 2048] - The key size in bits. Used for rsa keys only.\n   * @returns {Promise<KeyInfo>}\n   */\n  async createKey (name, type, size = 2048) {\n    const self = this\n\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    if (typeof type !== 'string') {\n      return throwDelayed(errcode(new Error(`Invalid key type '${type}'`), 'ERR_INVALID_KEY_TYPE'))\n    }\n\n    const dsname = DsName(name)\n    const exists = await self.store.has(dsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    switch (type.toLowerCase()) {\n      case 'rsa':\n        if (!Number.isSafeInteger(size) || size < 2048) {\n          return throwDelayed(errcode(new Error(`Invalid RSA key size ${size}`), 'ERR_INVALID_KEY_SIZE'))\n        }\n        break\n      default:\n        break\n    }\n\n    let keyInfo\n    try {\n      // @ts-ignore Differences between several crypto return types need to be fixed in libp2p-crypto\n      const keypair = await crypto.keys.generateKeyPair(type, size)\n      const kid = await keypair.id()\n      /** @type {string} */\n      const dek = privates.get(this).dek\n      const pem = await keypair.export(dek)\n      keyInfo = {\n        name: name,\n        id: kid\n      }\n      const batch = self.store.batch()\n      batch.put(dsname, uint8ArrayFromString(pem))\n      batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n\n      await batch.commit()\n    } catch (err) {\n      return throwDelayed(err)\n    }\n\n    return keyInfo\n  }\n\n  /**\n   * List all the keys.\n   *\n   * @returns {Promise<KeyInfo[]>}\n   */\n  async listKeys () {\n    const self = this\n    const query = {\n      prefix: infoPrefix\n    }\n\n    const info = []\n    for await (const value of self.store.query(query)) {\n      info.push(JSON.parse(uint8ArrayToString(value.value)))\n    }\n\n    return info\n  }\n\n  /**\n   * Find a key by it's id.\n   *\n   * @param {string} id - The universally unique key identifier.\n   * @returns {Promise<KeyInfo|undefined>}\n   */\n  async findKeyById (id) {\n    try {\n      const keys = await this.listKeys()\n      return keys.find((k) => k.id === id)\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Find a key by it's name.\n   *\n   * @param {string} name - The local key name.\n   * @returns {Promise<KeyInfo>}\n   */\n  async findKeyByName (name) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    const dsname = DsInfoName(name)\n    try {\n      const res = await this.store.get(dsname)\n      return JSON.parse(uint8ArrayToString(res))\n    } catch (err) {\n      return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))\n    }\n  }\n\n  /**\n   * Remove an existing key.\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n  async removeKey (name) {\n    const self = this\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    const dsname = DsName(name)\n    const keyInfo = await self.findKeyByName(name)\n    const batch = self.store.batch()\n    batch.delete(dsname)\n    batch.delete(DsInfoName(name))\n    await batch.commit()\n    return keyInfo\n  }\n\n  /**\n   * Rename a key\n   *\n   * @param {string} oldName - The old local key name; must already exist.\n   * @param {string} newName - The new local key name; must not already exist.\n   * @returns {Promise<KeyInfo>}\n   */\n  async renameKey (oldName, newName) {\n    const self = this\n    if (!validateKeyName(oldName) || oldName === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid old key name '${oldName}'`), 'ERR_OLD_KEY_NAME_INVALID'))\n    }\n    if (!validateKeyName(newName) || newName === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid new key name '${newName}'`), 'ERR_NEW_KEY_NAME_INVALID'))\n    }\n    const oldDsname = DsName(oldName)\n    const newDsname = DsName(newName)\n    const oldInfoName = DsInfoName(oldName)\n    const newInfoName = DsInfoName(newName)\n\n    const exists = await self.store.has(newDsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${newName}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    try {\n      const pem = await self.store.get(oldDsname)\n      const res = await self.store.get(oldInfoName)\n\n      const keyInfo = JSON.parse(uint8ArrayToString(res))\n      keyInfo.name = newName\n      const batch = self.store.batch()\n      batch.put(newDsname, pem)\n      batch.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)))\n      batch.delete(oldDsname)\n      batch.delete(oldInfoName)\n      await batch.commit()\n      return keyInfo\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Export an existing key as a PEM encrypted PKCS #8 string\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @param {string} password - The password\n   * @returns {Promise<string>}\n   */\n  async exportKey (name, password) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!password) {\n      return throwDelayed(errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED'))\n    }\n\n    const dsname = DsName(name)\n    try {\n      const res = await this.store.get(dsname)\n      const pem = uint8ArrayToString(res)\n      /** @type {string} */\n      const dek = privates.get(this).dek\n      const privateKey = await crypto.keys.import(pem, dek)\n      return privateKey.export(password)\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Import a new key from a PEM encoded PKCS #8 string\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {string} pem - The PEM encoded PKCS #8 string\n   * @param {string} password - The password.\n   * @returns {Promise<KeyInfo>}\n   */\n  async importKey (name, pem, password) {\n    const self = this\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!pem) {\n      return throwDelayed(errcode(new Error('PEM encoded key is required'), 'ERR_PEM_REQUIRED'))\n    }\n    const dsname = DsName(name)\n    const exists = await self.store.has(dsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    let privateKey\n    try {\n      privateKey = await crypto.keys.import(pem, password)\n    } catch (err) {\n      return throwDelayed(errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY'))\n    }\n\n    let kid\n    try {\n      kid = await privateKey.id()\n      /** @type {string} */\n      const dek = privates.get(this).dek\n      pem = await privateKey.export(dek)\n    } catch (err) {\n      return throwDelayed(err)\n    }\n\n    const keyInfo = {\n      name: name,\n      id: kid\n    }\n    const batch = self.store.batch()\n    batch.put(dsname, uint8ArrayFromString(pem))\n    batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n    await batch.commit()\n\n    return keyInfo\n  }\n\n  /**\n   * Import a peer key\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {PeerId} peer - The PEM encoded PKCS #8 string\n   * @returns {Promise<KeyInfo>}\n   */\n  async importPeer (name, peer) {\n    const self = this\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!peer || !peer.privKey) {\n      return throwDelayed(errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY'))\n    }\n\n    const privateKey = peer.privKey\n    const dsname = DsName(name)\n    const exists = await self.store.has(dsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    try {\n      const kid = await privateKey.id()\n      /** @type {string} */\n      const dek = privates.get(this).dek\n      const pem = await privateKey.export(dek)\n      const keyInfo = {\n        name: name,\n        id: kid\n      }\n      const batch = self.store.batch()\n      batch.put(dsname, uint8ArrayFromString(pem))\n      batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n      await batch.commit()\n      return keyInfo\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Gets the private key as PEM encoded PKCS #8 string.\n   *\n   * @param {string} name\n   * @returns {Promise<string>}\n   */\n  async _getPrivateKey (name) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    try {\n      const dsname = DsName(name)\n      const res = await this.store.get(dsname)\n      return uint8ArrayToString(res)\n    } catch (err) {\n      return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))\n    }\n  }\n\n  /**\n   * Rotate keychain password and re-encrypt all assosciated keys\n   *\n   * @param {string} oldPass - The old local keychain password\n   * @param {string} newPass - The new local keychain password\n   */\n  async rotateKeychainPass (oldPass, newPass) {\n    if (typeof oldPass !== 'string') {\n      return throwDelayed(errcode(new Error(`Invalid old pass type '${typeof oldPass}'`), 'ERR_INVALID_OLD_PASS_TYPE'))\n    }\n    if (typeof newPass !== 'string') {\n      return throwDelayed(errcode(new Error(`Invalid new pass type '${typeof newPass}'`), 'ERR_INVALID_NEW_PASS_TYPE'))\n    }\n    if (newPass.length < 20) {\n      return throwDelayed(errcode(new Error(`Invalid pass length ${newPass.length}`), 'ERR_INVALID_PASS_LENGTH'))\n    }\n    log('recreating keychain')\n    const oldDek = privates.get(this).dek\n    this.opts.pass = newPass\n    const newDek = newPass\n      ? crypto.pbkdf2(\n        newPass,\n        this.opts.dek.salt,\n        this.opts.dek.iterationCount,\n        this.opts.dek.keyLength,\n        this.opts.dek.hash)\n      : ''\n    privates.set(this, { dek: newDek })\n    const keys = await this.listKeys()\n    for (const key of keys) {\n      const res = await this.store.get(DsName(key.name))\n      const pem = uint8ArrayToString(res)\n      const privateKey = await crypto.keys.import(pem, oldDek)\n      const password = newDek.toString()\n      const keyAsPEM = await privateKey.export(password)\n\n      // Update stored key\n      const batch = this.store.batch()\n      const keyInfo = {\n        name: key.name,\n        id: key.id\n      }\n      batch.put(DsName(key.name), uint8ArrayFromString(keyAsPEM))\n      batch.put(DsInfoName(key.name), uint8ArrayFromString(JSON.stringify(keyInfo)))\n      await batch.commit()\n    }\n    log('keychain reconstructed')\n  }\n}\n\nmodule.exports = Keychain\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}