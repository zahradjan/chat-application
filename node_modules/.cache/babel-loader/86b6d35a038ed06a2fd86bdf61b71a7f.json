{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _toConsumableArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar pMap = require('p-map');\n\nvar GSet = require('./g-set');\n\nvar Entry = require('./entry');\n\nvar LogIO = require('./log-io');\n\nvar LogError = require('./log-errors');\n\nvar Clock = require('./lamport-clock');\n\nvar Sorting = require('./log-sorting');\n\nvar LastWriteWins = Sorting.LastWriteWins,\n    NoZeroes = Sorting.NoZeroes;\n\nvar AccessController = require('./default-access-controller');\n\nvar _require = require('./utils'),\n    isDefined = _require.isDefined,\n    findUniques = _require.findUniques;\n\nvar EntryIndex = require('./entry-index');\n\nvar randomId = function randomId() {\n  return new Date().getTime().toString();\n};\n\nvar getHash = function getHash(e) {\n  return e.hash;\n};\n\nvar flatMap = function flatMap(res, acc) {\n  return res.concat(acc);\n};\n\nvar getNextPointers = function getNextPointers(entry) {\n  return entry.next;\n};\n\nvar maxClockTimeReducer = function maxClockTimeReducer(res, acc) {\n  return Math.max(res, acc.clock.time);\n};\n\nvar uniqueEntriesReducer = function uniqueEntriesReducer(res, acc) {\n  res[acc.hash] = acc;\n  return res;\n};\n/**\n * @description\n * Log implements a G-Set CRDT and adds ordering.\n *\n * From:\n * \"A comprehensive study of Convergent and Commutative Replicated Data Types\"\n * https://hal.inria.fr/inria-00555588\n */\n\n\nvar Log = /*#__PURE__*/function (_GSet) {\n  _inherits(Log, _GSet);\n\n  var _super = _createSuper(Log);\n\n  /**\n   * Create a new Log instance\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Object} identity Identity (https://github.com/orbitdb/orbit-db-identity-provider/blob/master/src/identity.js)\n   * @param {Object} options\n   * @param {string} options.logId ID of the log\n   * @param {Object} options.access AccessController (./default-access-controller)\n   * @param {Array<Entry>} options.entries An Array of Entries from which to create the log\n   * @param {Array<Entry>} options.heads Set the heads of the log\n   * @param {Clock} options.clock Set the clock of the log\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Log} The log instance\n   */\n  function Log(ipfs, identity) {\n    var _this;\n\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        logId = _ref.logId,\n        access = _ref.access,\n        entries = _ref.entries,\n        heads = _ref.heads,\n        clock = _ref.clock,\n        sortFn = _ref.sortFn,\n        concurrency = _ref.concurrency;\n\n    _classCallCheck(this, Log);\n\n    if (!isDefined(ipfs)) {\n      throw LogError.IPFSNotDefinedError();\n    }\n\n    if (!isDefined(identity)) {\n      throw new Error('Identity is required');\n    }\n\n    if (!isDefined(access)) {\n      access = new AccessController();\n    }\n\n    if (isDefined(entries) && !Array.isArray(entries)) {\n      throw new Error('\\'entries\\' argument must be an array of Entry instances');\n    }\n\n    if (isDefined(heads) && !Array.isArray(heads)) {\n      throw new Error('\\'heads\\' argument must be an array');\n    }\n\n    if (!isDefined(sortFn)) {\n      sortFn = LastWriteWins;\n    }\n\n    _this = _super.call(this);\n    _this._sortFn = NoZeroes(sortFn);\n    _this._storage = ipfs;\n    _this._id = logId || randomId(); // Access Controller\n\n    _this._access = access; // Identity\n\n    _this._identity = identity; // Add entries to the internal cache\n\n    var uniqueEntries = (entries || []).reduce(uniqueEntriesReducer, {});\n    _this._entryIndex = new EntryIndex(uniqueEntries);\n    entries = Object.values(uniqueEntries) || []; // Set heads if not passed as an argument\n\n    heads = heads || Log.findHeads(entries);\n    _this._headsIndex = heads.reduce(uniqueEntriesReducer, {}); // Index of all next pointers in this log\n\n    _this._nextsIndex = {};\n\n    var addToNextsIndex = function addToNextsIndex(e) {\n      return e.next.forEach(function (a) {\n        return _this._nextsIndex[a] = e.hash;\n      });\n    };\n\n    entries.forEach(addToNextsIndex); // Set the length, we calculate the length manually internally\n\n    _this._length = entries.length; // Set the clock\n\n    var maxTime = Math.max(clock ? clock.time : 0, _this.heads.reduce(maxClockTimeReducer, 0)); // Take the given key as the clock id is it's a Key instance,\n    // otherwise if key was given, take whatever it is,\n    // and if it was null, take the given id as the clock id\n\n    _this._clock = new Clock(_this._identity.publicKey, maxTime);\n    _this.joinConcurrency = concurrency || 16;\n    return _this;\n  }\n  /**\n   * Returns the ID of the log.\n   * @returns {string}\n   */\n\n\n  _createClass(Log, [{\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * Returns the clock of the log.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"clock\",\n    get: function get() {\n      return this._clock;\n    }\n    /**\n     * Returns the length of the log.\n     * @return {number} Length\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._length;\n    }\n    /**\n     * Returns the values in the log.\n     * @returns {Array<Entry>}\n     */\n\n  }, {\n    key: \"values\",\n    get: function get() {\n      return Object.values(this.traverse(this.heads)).reverse();\n    }\n    /**\n     * Returns an array of heads as hashes.\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"heads\",\n    get: function get() {\n      return Object.values(this._headsIndex).sort(this._sortFn).reverse();\n    }\n    /**\n     * Returns an array of Entry objects that reference entries which\n     * are not in the log currently.\n     * @returns {Array<Entry>}\n     */\n\n  }, {\n    key: \"tails\",\n    get: function get() {\n      return Log.findTails(this.values);\n    }\n    /**\n     * Returns an array of hashes that are referenced by entries which\n     * are not in the log currently.\n     * @returns {Array<string>} Array of hashes\n     */\n\n  }, {\n    key: \"tailHashes\",\n    get: function get() {\n      return Log.findTailHashes(this.values);\n    }\n    /**\n     * Set the identity for the log\n     * @param {Identity} [identity] The identity to be set\n     */\n\n  }, {\n    key: \"setIdentity\",\n    value: function setIdentity(identity) {\n      this._identity = identity; // Find the latest clock from the heads\n\n      var time = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0));\n      this._clock = new Clock(this._identity.publicKey, time);\n    }\n    /**\n     * Find an entry.\n     * @param {string} [hash] The hashes of the entry\n     * @returns {Entry|undefined}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(hash) {\n      return this._entryIndex.get(hash);\n    }\n    /**\n     * Checks if a entry is part of the log\n     * @param {string} hash The hash of the entry\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(entry) {\n      return this._entryIndex.get(entry.hash || entry) !== undefined;\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(rootEntries) {\n      var _this2 = this;\n\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n      var endHash = arguments.length > 2 ? arguments[2] : undefined;\n      // Sort the given given root entries and use as the starting stack\n      var stack = rootEntries.sort(this._sortFn).reverse(); // Cache for checking if we've processed an entry already\n\n      var traversed = {}; // End result\n\n      var result = {};\n      var count = 0; // Named function for getting an entry from the log\n\n      var getEntry = function getEntry(e) {\n        return _this2.get(e);\n      }; // Add an entry to the stack and traversed nodes index\n\n\n      var addToStack = function addToStack(entry) {\n        // If we've already processed the entry, don't add it to the stack\n        if (!entry || traversed[entry.hash]) {\n          return;\n        } // Add the entry in front of the stack and sort\n\n\n        stack = [entry].concat(_toConsumableArray(stack)).sort(_this2._sortFn).reverse(); // Add to the cache of processed entries\n\n        traversed[entry.hash] = true;\n      };\n\n      var addEntry = function addEntry(rootEntry) {\n        result[rootEntry.hash] = rootEntry;\n        traversed[rootEntry.hash] = true;\n        count++;\n      }; // Start traversal\n      // Process stack until it's empty (traversed the full log)\n      // or when we have the requested amount of entries\n      // If requested entry amount is -1, traverse all\n\n\n      while (stack.length > 0 && (count < amount || amount < 0)) {\n        // eslint-disable-line no-unmodified-loop-condition\n        // Get the next element from the stack\n        var entry = stack.shift(); // Add to the result\n\n        addEntry(entry); // If it is the specified end hash, break out of the while loop\n\n        if (endHash && endHash === entry.hash) break; // Add entry's next references to the stack\n\n        var entries = entry.next.map(getEntry);\n        var defined = entries.filter(isDefined);\n        defined.forEach(addToStack);\n      }\n\n      stack = [];\n      traversed = {}; // End result\n\n      return result;\n    }\n    /**\n     * Append an entry to the log.\n     * @param {Entry} entry Entry to add\n     * @return {Log} New Log containing the appended value\n     */\n\n  }, {\n    key: \"append\",\n    value: function () {\n      var _append = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data) {\n        var _this3 = this;\n\n        var pointerCount,\n            pin,\n            newTime,\n            all,\n            getEveryPow2,\n            references,\n            nexts,\n            isNext,\n            refs,\n            entry,\n            canAppend,\n            _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                pointerCount = _args.length > 1 && _args[1] !== undefined ? _args[1] : 1;\n                pin = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;\n                // Update the clock (find the latest clock)\n                newTime = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0)) + 1;\n                this._clock = new Clock(this.clock.id, newTime);\n                all = Object.values(this.traverse(this.heads, Math.max(pointerCount, this.heads.length))); // If pointer count is 4, returns 2\n                // If pointer count is 8, returns 3 references\n                // If pointer count is 512, returns 9 references\n                // If pointer count is 2048, returns 11 references\n\n                getEveryPow2 = function getEveryPow2(maxDistance) {\n                  var entries = new Set();\n\n                  for (var i = 1; i <= maxDistance; i *= 2) {\n                    var index = Math.min(i - 1, all.length - 1);\n                    entries.add(all[index]);\n                  }\n\n                  return entries;\n                };\n\n                references = getEveryPow2(Math.min(pointerCount, all.length)); // Always include the last known reference\n\n                if (all.length < pointerCount && all[all.length - 1]) {\n                  references.add(all[all.length - 1]);\n                } // Create the next pointers from heads\n\n\n                nexts = Object.keys(this.heads.reverse().reduce(uniqueEntriesReducer, {}));\n\n                isNext = function isNext(e) {\n                  return !nexts.includes(e);\n                }; // Delete the heads from the refs\n\n\n                refs = Array.from(references).map(getHash).filter(isNext); // @TODO: Split Entry.create into creating object, checking permission, signing and then posting to IPFS\n                // Create the entry and add it to the internal cache\n\n                _context.next = 13;\n                return Entry.create(this._storage, this._identity, this.id, data, nexts, this.clock, refs, pin);\n\n              case 13:\n                entry = _context.sent;\n                _context.next = 16;\n                return this._access.canAppend(entry, this._identity.provider);\n\n              case 16:\n                canAppend = _context.sent;\n\n                if (canAppend) {\n                  _context.next = 19;\n                  break;\n                }\n\n                throw new Error(\"Could not append entry, key \\\"\".concat(this._identity.id, \"\\\" is not allowed to write to the log\"));\n\n              case 19:\n                this._entryIndex.set(entry.hash, entry);\n\n                nexts.forEach(function (e) {\n                  return _this3._nextsIndex[e] = entry.hash;\n                });\n                this._headsIndex = {};\n                this._headsIndex[entry.hash] = entry; // Update the length\n\n                this._length++;\n                return _context.abrupt(\"return\", entry);\n\n              case 25:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function append(_x) {\n        return _append.apply(this, arguments);\n      }\n\n      return append;\n    }()\n    /*\n     * Creates a javscript iterator over log entries\n     *\n     * @param {Object} options\n     * @param {string|Array} options.gt Beginning hash of the iterator, non-inclusive\n     * @param {string|Array} options.gte Beginning hash of the iterator, inclusive\n     * @param {string|Array} options.lt Ending hash of the iterator, non-inclusive\n     * @param {string|Array} options.lte Ending hash of the iterator, inclusive\n     * @param {amount} options.amount Number of entried to return to / from the gte / lte hash\n     * @returns {Symbol.Iterator} Iterator object containing log entries\n     *\n     * @examples\n     *\n     * (async () => {\n     *   log1 = new Log(ipfs, testIdentity, { logId: 'X' })\n     *\n     *   for (let i = 0; i <= 100; i++) {\n     *     await log1.append('entry' + i)\n     *   }\n     *\n     *   let it = log1.iterator({\n     *     lte: 'zdpuApFd5XAPkCTmSx7qWQmQzvtdJPtx2K5p9to6ytCS79bfk',\n     *     amount: 10\n     *   })\n     *\n     *   [...it].length // 10\n     * })()\n     *\n     *\n     */\n\n  }, {\n    key: \"iterator\",\n    value: function iterator() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$gt = _ref2.gt,\n          gt = _ref2$gt === void 0 ? undefined : _ref2$gt,\n          _ref2$gte = _ref2.gte,\n          gte = _ref2$gte === void 0 ? undefined : _ref2$gte,\n          _ref2$lt = _ref2.lt,\n          lt = _ref2$lt === void 0 ? undefined : _ref2$lt,\n          _ref2$lte = _ref2.lte,\n          lte = _ref2$lte === void 0 ? undefined : _ref2$lte,\n          _ref2$amount = _ref2.amount,\n          amount = _ref2$amount === void 0 ? -1 : _ref2$amount;\n\n      if (amount === 0) return /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      })();\n      if (typeof lte === 'string') lte = [this.get(lte)];\n      if (typeof lt === 'string') lt = [this.get(this.get(lt).next[0])];\n      if (lte && !Array.isArray(lte)) throw LogError.LtOrLteMustBeStringOrArray();\n      if (lt && !Array.isArray(lt)) throw LogError.LtOrLteMustBeStringOrArray();\n      var start = (lte || lt || this.heads).filter(isDefined);\n      var endHash = gte ? this.get(gte).hash : gt ? this.get(gt).hash : null;\n      var count = endHash ? -1 : amount || -1;\n      var entries = this.traverse(start, count, endHash);\n      var entryValues = Object.values(entries); // Strip off last entry if gt is non-inclusive\n\n      if (gt) entryValues.pop(); // Deal with the amount argument working backwards from gt/gte\n\n      if ((gt || gte) && amount > -1) {\n        entryValues = entryValues.slice(entryValues.length - amount, entryValues.length);\n      }\n\n      return /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var i;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.t0 = _regeneratorRuntime().keys(entryValues);\n\n              case 1:\n                if ((_context3.t1 = _context3.t0()).done) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                i = _context3.t1.value;\n                _context3.next = 5;\n                return entryValues[i];\n\n              case 5:\n                _context3.next = 1;\n                break;\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      })();\n    }\n    /**\n     * Join two logs.\n     *\n     * Joins another log into this one.\n     *\n     * @param {Log} log Log to join with this Log\n     * @param {number} [size=-1] Max size of the joined log\n     * @returns {Promise<Log>} This Log instance\n     * @example\n     * await log1.join(log2)\n     */\n\n  }, {\n    key: \"join\",\n    value: function () {\n      var _join = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(log) {\n        var _this4 = this;\n\n        var size,\n            newItems,\n            identityProvider,\n            permitted,\n            verify,\n            entriesToJoin,\n            addToNextsIndex,\n            notReferencedByNewItems,\n            notInCurrentNexts,\n            nextsFromNewItems,\n            mergedHeads,\n            tmp,\n            maxClock,\n            _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                size = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : -1;\n\n                if (isDefined(log)) {\n                  _context7.next = 3;\n                  break;\n                }\n\n                throw LogError.LogNotDefinedError();\n\n              case 3:\n                if (Log.isLog(log)) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                throw LogError.NotALogError();\n\n              case 5:\n                if (!(this.id !== log.id)) {\n                  _context7.next = 7;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\");\n\n              case 7:\n                // Get the difference of the logs\n                newItems = Log.difference(log, this);\n                identityProvider = this._identity.provider; // Verify if entries are allowed to be added to the log and throws if\n                // there's an invalid entry\n\n                permitted = /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(entry) {\n                    var canAppend;\n                    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            _context4.next = 2;\n                            return _this4._access.canAppend(entry, identityProvider);\n\n                          case 2:\n                            canAppend = _context4.sent;\n\n                            if (canAppend) {\n                              _context4.next = 5;\n                              break;\n                            }\n\n                            throw new Error(\"Could not append entry, key \\\"\".concat(entry.identity.id, \"\\\" is not allowed to write to the log\"));\n\n                          case 5:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n\n                  return function permitted(_x3) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }(); // Verify signature for each entry and throws if there's an invalid signature\n\n\n                verify = /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(entry) {\n                    var isValid, publicKey;\n                    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            _context5.next = 2;\n                            return Entry.verify(identityProvider, entry);\n\n                          case 2:\n                            isValid = _context5.sent;\n                            publicKey = entry.identity ? entry.identity.publicKey : entry.key;\n\n                            if (isValid) {\n                              _context5.next = 6;\n                              break;\n                            }\n\n                            throw new Error(\"Could not validate signature \\\"\".concat(entry.sig, \"\\\" for entry \\\"\").concat(entry.hash, \"\\\" and key \\\"\").concat(publicKey, \"\\\"\"));\n\n                          case 6:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5);\n                  }));\n\n                  return function verify(_x4) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }();\n\n                entriesToJoin = Object.values(newItems);\n                _context7.next = 14;\n                return pMap(entriesToJoin, /*#__PURE__*/function () {\n                  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(e) {\n                    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            _context6.next = 2;\n                            return permitted(e);\n\n                          case 2:\n                            _context6.next = 4;\n                            return verify(e);\n\n                          case 4:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6);\n                  }));\n\n                  return function (_x5) {\n                    return _ref5.apply(this, arguments);\n                  };\n                }(), {\n                  concurrency: this.joinConcurrency\n                });\n\n              case 14:\n                // Update the internal next pointers index\n                addToNextsIndex = function addToNextsIndex(e) {\n                  var entry = _this4.get(e.hash);\n\n                  if (!entry) _this4._length++;\n                  /* istanbul ignore else */\n\n                  e.next.forEach(function (a) {\n                    return _this4._nextsIndex[a] = e.hash;\n                  });\n                };\n\n                Object.values(newItems).forEach(addToNextsIndex); // Update the internal entry index\n\n                this._entryIndex.add(newItems); // Merge the heads\n\n\n                notReferencedByNewItems = function notReferencedByNewItems(e) {\n                  return !nextsFromNewItems.find(function (a) {\n                    return a === e.hash;\n                  });\n                };\n\n                notInCurrentNexts = function notInCurrentNexts(e) {\n                  return !_this4._nextsIndex[e.hash];\n                };\n\n                nextsFromNewItems = Object.values(newItems).map(getNextPointers).reduce(flatMap, []);\n                mergedHeads = Log.findHeads(Object.values(Object.assign({}, this._headsIndex, log._headsIndex))).filter(notReferencedByNewItems).filter(notInCurrentNexts).reduce(uniqueEntriesReducer, {});\n                this._headsIndex = mergedHeads; // Slice to the requested size\n\n                if (size > -1) {\n                  tmp = this.values;\n                  tmp = tmp.slice(-size);\n                  this._entryIndex = null;\n                  this._entryIndex = new EntryIndex(tmp.reduce(uniqueEntriesReducer, {}));\n                  this._headsIndex = Log.findHeads(tmp).reduce(uniqueEntriesReducer, {});\n                  this._length = this._entryIndex.length;\n                } // Find the latest clock from the heads\n\n\n                maxClock = Object.values(this._headsIndex).reduce(maxClockTimeReducer, 0);\n                this._clock = new Clock(this.clock.id, Math.max(this.clock.time, maxClock));\n                return _context7.abrupt(\"return\", this);\n\n              case 26:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function join(_x2) {\n        return _join.apply(this, arguments);\n      }\n\n      return join;\n    }()\n    /**\n     * Get the log in JSON format.\n     * @returns {Object} An object with the id and heads properties\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        id: this.id,\n        heads: this.heads.sort(this._sortFn) // default sorting\n        .reverse() // we want the latest as the first element\n        .map(getHash) // return only the head hashes\n\n      };\n    }\n    /**\n     * Get the log in JSON format as a snapshot.\n     * @returns {Object} An object with the id, heads and value properties\n     */\n\n  }, {\n    key: \"toSnapshot\",\n    value: function toSnapshot() {\n      return {\n        id: this.id,\n        heads: this.heads,\n        values: this.values\n      };\n    }\n    /**\n     * Get the log as a Buffer.\n     * @returns {Buffer}\n     */\n\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      return Buffer.from(JSON.stringify(this.toJSON()));\n    }\n    /**\n     * Returns the log entries as a formatted string.\n     * @returns {string}\n     * @example\n     * two\n     * └─one\n     *   └─three\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(payloadMapper) {\n      var _this5 = this;\n\n      return this.values.slice().reverse().map(function (e, idx) {\n        var parents = Entry.findChildren(e, _this5.values);\n        var len = parents.length;\n        var padding = new Array(Math.max(len - 1, 0));\n        padding = len > 1 ? padding.fill('  ') : padding;\n        padding = len > 0 ? padding.concat(['└─']) : padding;\n        /* istanbul ignore next */\n\n        return padding.join('') + (payloadMapper ? payloadMapper(e.payload) : e.payload);\n      }).join('\\n');\n    }\n    /**\n     * Check whether an object is a Log instance.\n     * @param {Object} log An object to check\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"toMultihash\",\n    value:\n    /**\n     * Get the log's multihash.\n     * @returns {Promise<string>} Multihash of the Log as Base58 encoded string.\n     */\n    function toMultihash() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          format = _ref6.format;\n\n      return LogIO.toMultihash(this._storage, this, {\n        format: format\n      });\n    }\n    /**\n     * Create a log from a hashes.\n     * @param {IPFS} ipfs An IPFS instance\n     * @param {Identity} identity The identity instance\n     * @param {string} hash The log hash\n     * @param {Object} options\n     * @param {AccessController} options.access The access controller instance\n     * @param {number} options.length How many items to include in the log\n     * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n     * @param {function(hash, entry, parent, depth)} options.onProgressCallback\n     * @param {Function} options.sortFn The sort function - by default LastWriteWins\n     * @returns {Promise<Log>}\n     */\n\n  }], [{\n    key: \"isLog\",\n    value: function isLog(log) {\n      return log.id !== undefined && log.heads !== undefined && log._entryIndex !== undefined;\n    }\n  }, {\n    key: \"fromMultihash\",\n    value: function () {\n      var _fromMultihash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(ipfs, identity, hash) {\n        var _ref7,\n            access,\n            _ref7$length,\n            length,\n            _ref7$exclude,\n            exclude,\n            shouldExclude,\n            timeout,\n            concurrency,\n            sortFn,\n            onProgressCallback,\n            _yield$LogIO$fromMult,\n            logId,\n            entries,\n            heads,\n            _args8 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _ref7 = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : {}, access = _ref7.access, _ref7$length = _ref7.length, length = _ref7$length === void 0 ? -1 : _ref7$length, _ref7$exclude = _ref7.exclude, exclude = _ref7$exclude === void 0 ? [] : _ref7$exclude, shouldExclude = _ref7.shouldExclude, timeout = _ref7.timeout, concurrency = _ref7.concurrency, sortFn = _ref7.sortFn, onProgressCallback = _ref7.onProgressCallback;\n                _context8.next = 3;\n                return LogIO.fromMultihash(ipfs, hash, {\n                  length: length,\n                  exclude: exclude,\n                  shouldExclude: shouldExclude,\n                  timeout: timeout,\n                  onProgressCallback: onProgressCallback,\n                  concurrency: concurrency,\n                  sortFn: sortFn\n                });\n\n              case 3:\n                _yield$LogIO$fromMult = _context8.sent;\n                logId = _yield$LogIO$fromMult.logId;\n                entries = _yield$LogIO$fromMult.entries;\n                heads = _yield$LogIO$fromMult.heads;\n                return _context8.abrupt(\"return\", new Log(ipfs, identity, {\n                  logId: logId,\n                  access: access,\n                  entries: entries,\n                  heads: heads,\n                  sortFn: sortFn\n                }));\n\n              case 8:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function fromMultihash(_x6, _x7, _x8) {\n        return _fromMultihash.apply(this, arguments);\n      }\n\n      return fromMultihash;\n    }()\n    /**\n     * Create a log from a single entry's hash.\n     * @param {IPFS} ipfs An IPFS instance\n     * @param {Identity} identity The identity instance\n     * @param {string} hash The entry's hash\n     * @param {Object} options\n     * @param {string} options.logId The ID of the log\n     * @param {AccessController} options.access The access controller instance\n     * @param {number} options.length How many entries to include in the log\n     * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n     * @param {function(hash, entry, parent, depth)} options.onProgressCallback\n     * @param {Function} options.sortFn The sort function - by default LastWriteWins\n     * @return {Promise<Log>} New Log\n     */\n\n  }, {\n    key: \"fromEntryHash\",\n    value: function () {\n      var _fromEntryHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(ipfs, identity, hash) {\n        var _ref8,\n            logId,\n            access,\n            _ref8$length,\n            length,\n            _ref8$exclude,\n            exclude,\n            shouldExclude,\n            timeout,\n            concurrency,\n            sortFn,\n            onProgressCallback,\n            _yield$LogIO$fromEntr,\n            entries,\n            _args9 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _ref8 = _args9.length > 3 && _args9[3] !== undefined ? _args9[3] : {}, logId = _ref8.logId, access = _ref8.access, _ref8$length = _ref8.length, length = _ref8$length === void 0 ? -1 : _ref8$length, _ref8$exclude = _ref8.exclude, exclude = _ref8$exclude === void 0 ? [] : _ref8$exclude, shouldExclude = _ref8.shouldExclude, timeout = _ref8.timeout, concurrency = _ref8.concurrency, sortFn = _ref8.sortFn, onProgressCallback = _ref8.onProgressCallback;\n                _context9.next = 3;\n                return LogIO.fromEntryHash(ipfs, hash, {\n                  length: length,\n                  exclude: exclude,\n                  shouldExclude: shouldExclude,\n                  timeout: timeout,\n                  concurrency: concurrency,\n                  onProgressCallback: onProgressCallback\n                });\n\n              case 3:\n                _yield$LogIO$fromEntr = _context9.sent;\n                entries = _yield$LogIO$fromEntr.entries;\n                return _context9.abrupt(\"return\", new Log(ipfs, identity, {\n                  logId: logId,\n                  access: access,\n                  entries: entries,\n                  sortFn: sortFn\n                }));\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n\n      function fromEntryHash(_x9, _x10, _x11) {\n        return _fromEntryHash.apply(this, arguments);\n      }\n\n      return fromEntryHash;\n    }()\n    /**\n     * Create a log from a Log Snapshot JSON.\n     * @param {IPFS} ipfs An IPFS instance\n     * @param {Identity} identity The identity instance\n     * @param {Object} json Log snapshot as JSON object\n     * @param {Object} options\n     * @param {AccessController} options.access The access controller instance\n     * @param {number} options.length How many entries to include in the log\n     * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]\n     * @param {Function} options.sortFn The sort function - by default LastWriteWins\n     * @return {Promise<Log>} New Log\n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function () {\n      var _fromJSON = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(ipfs, identity, json) {\n        var _ref9,\n            access,\n            _ref9$length,\n            length,\n            timeout,\n            sortFn,\n            onProgressCallback,\n            _yield$LogIO$fromJSON,\n            logId,\n            entries,\n            _args10 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _ref9 = _args10.length > 3 && _args10[3] !== undefined ? _args10[3] : {}, access = _ref9.access, _ref9$length = _ref9.length, length = _ref9$length === void 0 ? -1 : _ref9$length, timeout = _ref9.timeout, sortFn = _ref9.sortFn, onProgressCallback = _ref9.onProgressCallback;\n                _context10.next = 3;\n                return LogIO.fromJSON(ipfs, json, {\n                  length: length,\n                  timeout: timeout,\n                  onProgressCallback: onProgressCallback\n                });\n\n              case 3:\n                _yield$LogIO$fromJSON = _context10.sent;\n                logId = _yield$LogIO$fromJSON.logId;\n                entries = _yield$LogIO$fromJSON.entries;\n                return _context10.abrupt(\"return\", new Log(ipfs, identity, {\n                  logId: logId,\n                  access: access,\n                  entries: entries,\n                  sortFn: sortFn\n                }));\n\n              case 7:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }));\n\n      function fromJSON(_x12, _x13, _x14) {\n        return _fromJSON.apply(this, arguments);\n      }\n\n      return fromJSON;\n    }()\n    /**\n     * Create a new log from an Entry instance.\n     * @param {IPFS} ipfs An IPFS instance\n     * @param {Identity} identity The identity instance\n     * @param {Entry|Array<Entry>} sourceEntries An Entry or an array of entries to fetch a log from\n     * @param {Object} options\n     * @param {AccessController} options.access The access controller instance\n     * @param {number} options.length How many entries to include. Default: infinite.\n     * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n     * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]\n     * @param {Function} options.sortFn The sort function - by default LastWriteWins\n     * @return {Promise<Log>} New Log\n     */\n\n  }, {\n    key: \"fromEntry\",\n    value: function () {\n      var _fromEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(ipfs, identity, sourceEntries) {\n        var _ref10,\n            access,\n            _ref10$length,\n            length,\n            _ref10$exclude,\n            exclude,\n            timeout,\n            concurrency,\n            sortFn,\n            onProgressCallback,\n            _yield$LogIO$fromEntr2,\n            logId,\n            entries,\n            _args11 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _ref10 = _args11.length > 3 && _args11[3] !== undefined ? _args11[3] : {}, access = _ref10.access, _ref10$length = _ref10.length, length = _ref10$length === void 0 ? -1 : _ref10$length, _ref10$exclude = _ref10.exclude, exclude = _ref10$exclude === void 0 ? [] : _ref10$exclude, timeout = _ref10.timeout, concurrency = _ref10.concurrency, sortFn = _ref10.sortFn, onProgressCallback = _ref10.onProgressCallback;\n                _context11.next = 3;\n                return LogIO.fromEntry(ipfs, sourceEntries, {\n                  length: length,\n                  exclude: exclude,\n                  timeout: timeout,\n                  concurrency: concurrency,\n                  onProgressCallback: onProgressCallback\n                });\n\n              case 3:\n                _yield$LogIO$fromEntr2 = _context11.sent;\n                logId = _yield$LogIO$fromEntr2.logId;\n                entries = _yield$LogIO$fromEntr2.entries;\n                return _context11.abrupt(\"return\", new Log(ipfs, identity, {\n                  logId: logId,\n                  access: access,\n                  entries: entries,\n                  sortFn: sortFn\n                }));\n\n              case 7:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11);\n      }));\n\n      function fromEntry(_x15, _x16, _x17) {\n        return _fromEntry.apply(this, arguments);\n      }\n\n      return fromEntry;\n    }()\n    /**\n     * Find heads from a collection of entries.\n     *\n     * Finds entries that are the heads of this collection,\n     * ie. entries that are not referenced by other entries.\n     *\n     * @param {Array<Entry>} entries Entries to search heads from\n     * @returns {Array<Entry>}\n     */\n\n  }, {\n    key: \"findHeads\",\n    value: function findHeads(entries) {\n      var indexReducer = function indexReducer(res, entry, idx, arr) {\n        var addToResult = function addToResult(e) {\n          return res[e] = entry.hash;\n        };\n\n        entry.next.forEach(addToResult);\n        return res;\n      };\n\n      var items = entries.reduce(indexReducer, {});\n\n      var exists = function exists(e) {\n        return items[e.hash] === undefined;\n      };\n\n      var compareIds = function compareIds(a, b) {\n        return a.clock.id > b.clock.id;\n      };\n\n      return entries.filter(exists).sort(compareIds);\n    } // Find entries that point to another entry that is not in the\n    // input array\n\n  }, {\n    key: \"findTails\",\n    value: function findTails(entries) {\n      // Reverse index { next -> entry }\n      var reverseIndex = {}; // Null index containing entries that have no parents (nexts)\n\n      var nullIndex = []; // Hashes for all entries for quick lookups\n\n      var hashes = {}; // Hashes of all next entries\n\n      var nexts = [];\n\n      var addToIndex = function addToIndex(e) {\n        if (e.next.length === 0) {\n          nullIndex.push(e);\n        }\n\n        var addToReverseIndex = function addToReverseIndex(a) {\n          /* istanbul ignore else */\n          if (!reverseIndex[a]) reverseIndex[a] = [];\n          reverseIndex[a].push(e);\n        }; // Add all entries and their parents to the reverse index\n\n\n        e.next.forEach(addToReverseIndex); // Get all next references\n\n        nexts = nexts.concat(e.next); // Get the hashes of input entries\n\n        hashes[e.hash] = true;\n      }; // Create our indices\n\n\n      entries.forEach(addToIndex);\n\n      var addUniques = function addUniques(res, entries, idx, arr) {\n        return res.concat(findUniques(entries, 'hash'));\n      };\n\n      var exists = function exists(e) {\n        return hashes[e] === undefined;\n      };\n\n      var findFromReverseIndex = function findFromReverseIndex(e) {\n        return reverseIndex[e];\n      }; // Drop hashes that are not in the input entries\n\n\n      var tails = nexts // For every hash in nexts:\n      .filter(exists) // Remove undefineds and nulls\n      .map(findFromReverseIndex) // Get the Entry from the reverse index\n      .reduce(addUniques, []) // Flatten the result and take only uniques\n      .concat(nullIndex); // Combine with tails the have no next refs (ie. first-in-their-chain)\n\n      return findUniques(tails, 'hash').sort(Entry.compare);\n    } // Find the hashes to entries that are not in a collection\n    // but referenced by other entries\n\n  }, {\n    key: \"findTailHashes\",\n    value: function findTailHashes(entries) {\n      var hashes = {};\n\n      var addToIndex = function addToIndex(e) {\n        return hashes[e.hash] = true;\n      };\n\n      var reduceTailHashes = function reduceTailHashes(res, entry, idx, arr) {\n        var addToResult = function addToResult(e) {\n          /* istanbul ignore else */\n          if (hashes[e] === undefined) {\n            res.splice(0, 0, e);\n          }\n        };\n\n        entry.next.reverse().forEach(addToResult);\n        return res;\n      };\n\n      entries.forEach(addToIndex);\n      return entries.reduce(reduceTailHashes, []);\n    }\n  }, {\n    key: \"difference\",\n    value: function difference(a, b) {\n      var stack = Object.keys(a._headsIndex);\n      var traversed = {};\n      var res = {};\n\n      var pushToStack = function pushToStack(hash) {\n        if (!traversed[hash] && !b.get(hash)) {\n          stack.push(hash);\n          traversed[hash] = true;\n        }\n      };\n\n      while (stack.length > 0) {\n        var hash = stack.shift();\n        var entry = a.get(hash);\n\n        if (entry && !b.get(hash) && entry.id === b.id) {\n          res[entry.hash] = entry;\n          traversed[entry.hash] = true;\n          entry.next.concat(entry.refs).forEach(pushToStack);\n        }\n      }\n\n      return res;\n    }\n  }]);\n\n  return Log;\n}(GSet);\n\nmodule.exports = Log;\nmodule.exports.Sorting = Sorting;\nmodule.exports.Entry = Entry;\nmodule.exports.AccessController = AccessController;","map":{"version":3,"names":["pMap","require","GSet","Entry","LogIO","LogError","Clock","Sorting","LastWriteWins","NoZeroes","AccessController","isDefined","findUniques","EntryIndex","randomId","Date","getTime","toString","getHash","e","hash","flatMap","res","acc","concat","getNextPointers","entry","next","maxClockTimeReducer","Math","max","clock","time","uniqueEntriesReducer","Log","ipfs","identity","logId","access","entries","heads","sortFn","concurrency","IPFSNotDefinedError","Error","Array","isArray","_sortFn","_storage","_id","_access","_identity","uniqueEntries","reduce","_entryIndex","Object","values","findHeads","_headsIndex","_nextsIndex","addToNextsIndex","forEach","a","_length","length","maxTime","_clock","publicKey","joinConcurrency","traverse","reverse","sort","findTails","findTailHashes","get","undefined","rootEntries","amount","endHash","stack","traversed","result","count","getEntry","addToStack","addEntry","rootEntry","shift","map","defined","filter","data","pointerCount","pin","newTime","id","all","getEveryPow2","maxDistance","Set","i","index","min","add","references","nexts","keys","isNext","includes","refs","from","create","canAppend","provider","set","gt","gte","lt","lte","LtOrLteMustBeStringOrArray","start","entryValues","pop","slice","log","size","LogNotDefinedError","isLog","NotALogError","newItems","difference","identityProvider","permitted","verify","isValid","key","sig","entriesToJoin","notReferencedByNewItems","nextsFromNewItems","find","notInCurrentNexts","mergedHeads","assign","tmp","maxClock","Buffer","JSON","stringify","toJSON","payloadMapper","idx","parents","findChildren","len","padding","fill","join","payload","format","toMultihash","exclude","shouldExclude","timeout","onProgressCallback","fromMultihash","fromEntryHash","json","fromJSON","sourceEntries","fromEntry","indexReducer","arr","addToResult","items","exists","compareIds","b","reverseIndex","nullIndex","hashes","addToIndex","push","addToReverseIndex","addUniques","findFromReverseIndex","tails","compare","reduceTailHashes","splice","pushToStack","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-log/src/log.js"],"sourcesContent":["'use strict'\n\nconst pMap = require('p-map')\nconst GSet = require('./g-set')\nconst Entry = require('./entry')\nconst LogIO = require('./log-io')\nconst LogError = require('./log-errors')\nconst Clock = require('./lamport-clock')\nconst Sorting = require('./log-sorting')\nconst { LastWriteWins, NoZeroes } = Sorting\nconst AccessController = require('./default-access-controller')\nconst { isDefined, findUniques } = require('./utils')\nconst EntryIndex = require('./entry-index')\nconst randomId = () => new Date().getTime().toString()\nconst getHash = e => e.hash\nconst flatMap = (res, acc) => res.concat(acc)\nconst getNextPointers = entry => entry.next\nconst maxClockTimeReducer = (res, acc) => Math.max(res, acc.clock.time)\nconst uniqueEntriesReducer = (res, acc) => {\n  res[acc.hash] = acc\n  return res\n}\n\n/**\n * @description\n * Log implements a G-Set CRDT and adds ordering.\n *\n * From:\n * \"A comprehensive study of Convergent and Commutative Replicated Data Types\"\n * https://hal.inria.fr/inria-00555588\n */\nclass Log extends GSet {\n  /**\n   * Create a new Log instance\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Object} identity Identity (https://github.com/orbitdb/orbit-db-identity-provider/blob/master/src/identity.js)\n   * @param {Object} options\n   * @param {string} options.logId ID of the log\n   * @param {Object} options.access AccessController (./default-access-controller)\n   * @param {Array<Entry>} options.entries An Array of Entries from which to create the log\n   * @param {Array<Entry>} options.heads Set the heads of the log\n   * @param {Clock} options.clock Set the clock of the log\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Log} The log instance\n   */\n  constructor (ipfs, identity, { logId, access, entries, heads, clock, sortFn, concurrency } = {}) {\n    if (!isDefined(ipfs)) {\n      throw LogError.IPFSNotDefinedError()\n    }\n\n    if (!isDefined(identity)) {\n      throw new Error('Identity is required')\n    }\n\n    if (!isDefined(access)) {\n      access = new AccessController()\n    }\n\n    if (isDefined(entries) && !Array.isArray(entries)) {\n      throw new Error('\\'entries\\' argument must be an array of Entry instances')\n    }\n\n    if (isDefined(heads) && !Array.isArray(heads)) {\n      throw new Error('\\'heads\\' argument must be an array')\n    }\n\n    if (!isDefined(sortFn)) {\n      sortFn = LastWriteWins\n    }\n\n    super()\n\n    this._sortFn = NoZeroes(sortFn)\n\n    this._storage = ipfs\n    this._id = logId || randomId()\n\n    // Access Controller\n    this._access = access\n    // Identity\n    this._identity = identity\n\n    // Add entries to the internal cache\n    const uniqueEntries = (entries || []).reduce(uniqueEntriesReducer, {})\n    this._entryIndex = new EntryIndex(uniqueEntries)\n    entries = Object.values(uniqueEntries) || []\n\n    // Set heads if not passed as an argument\n    heads = heads || Log.findHeads(entries)\n    this._headsIndex = heads.reduce(uniqueEntriesReducer, {})\n\n    // Index of all next pointers in this log\n    this._nextsIndex = {}\n    const addToNextsIndex = e => e.next.forEach(a => (this._nextsIndex[a] = e.hash))\n    entries.forEach(addToNextsIndex)\n\n    // Set the length, we calculate the length manually internally\n    this._length = entries.length\n\n    // Set the clock\n    const maxTime = Math.max(clock ? clock.time : 0, this.heads.reduce(maxClockTimeReducer, 0))\n    // Take the given key as the clock id is it's a Key instance,\n    // otherwise if key was given, take whatever it is,\n    // and if it was null, take the given id as the clock id\n    this._clock = new Clock(this._identity.publicKey, maxTime)\n\n    this.joinConcurrency = concurrency || 16\n  }\n\n  /**\n   * Returns the ID of the log.\n   * @returns {string}\n   */\n  get id () {\n    return this._id\n  }\n\n  /**\n   * Returns the clock of the log.\n   * @returns {string}\n   */\n  get clock () {\n    return this._clock\n  }\n\n  /**\n   * Returns the length of the log.\n   * @return {number} Length\n   */\n  get length () {\n    return this._length\n  }\n\n  /**\n   * Returns the values in the log.\n   * @returns {Array<Entry>}\n   */\n  get values () {\n    return Object.values(this.traverse(this.heads)).reverse()\n  }\n\n  /**\n   * Returns an array of heads as hashes.\n   * @returns {Array<string>}\n   */\n  get heads () {\n    return Object.values(this._headsIndex).sort(this._sortFn).reverse()\n  }\n\n  /**\n   * Returns an array of Entry objects that reference entries which\n   * are not in the log currently.\n   * @returns {Array<Entry>}\n   */\n  get tails () {\n    return Log.findTails(this.values)\n  }\n\n  /**\n   * Returns an array of hashes that are referenced by entries which\n   * are not in the log currently.\n   * @returns {Array<string>} Array of hashes\n   */\n  get tailHashes () {\n    return Log.findTailHashes(this.values)\n  }\n\n  /**\n   * Set the identity for the log\n   * @param {Identity} [identity] The identity to be set\n   */\n  setIdentity (identity) {\n    this._identity = identity\n    // Find the latest clock from the heads\n    const time = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0))\n    this._clock = new Clock(this._identity.publicKey, time)\n  }\n\n  /**\n   * Find an entry.\n   * @param {string} [hash] The hashes of the entry\n   * @returns {Entry|undefined}\n   */\n  get (hash) {\n    return this._entryIndex.get(hash)\n  }\n\n  /**\n   * Checks if a entry is part of the log\n   * @param {string} hash The hash of the entry\n   * @returns {boolean}\n   */\n  has (entry) {\n    return this._entryIndex.get(entry.hash || entry) !== undefined\n  }\n\n  traverse (rootEntries, amount = -1, endHash) {\n    // Sort the given given root entries and use as the starting stack\n    let stack = rootEntries.sort(this._sortFn).reverse()\n\n    // Cache for checking if we've processed an entry already\n    let traversed = {}\n    // End result\n    const result = {}\n    let count = 0\n    // Named function for getting an entry from the log\n    const getEntry = e => this.get(e)\n\n    // Add an entry to the stack and traversed nodes index\n    const addToStack = entry => {\n      // If we've already processed the entry, don't add it to the stack\n      if (!entry || traversed[entry.hash]) {\n        return\n      }\n\n      // Add the entry in front of the stack and sort\n      stack = [entry, ...stack]\n        .sort(this._sortFn)\n        .reverse()\n      // Add to the cache of processed entries\n      traversed[entry.hash] = true\n    }\n\n    const addEntry = rootEntry => {\n      result[rootEntry.hash] = rootEntry\n      traversed[rootEntry.hash] = true\n      count++\n    }\n\n    // Start traversal\n    // Process stack until it's empty (traversed the full log)\n    // or when we have the requested amount of entries\n    // If requested entry amount is -1, traverse all\n    while (stack.length > 0 && (count < amount || amount < 0)) { // eslint-disable-line no-unmodified-loop-condition\n      // Get the next element from the stack\n      const entry = stack.shift()\n      // Add to the result\n      addEntry(entry)\n      // If it is the specified end hash, break out of the while loop\n      if (endHash && endHash === entry.hash) break\n\n      // Add entry's next references to the stack\n      const entries = entry.next.map(getEntry)\n      const defined = entries.filter(isDefined)\n      defined.forEach(addToStack)\n    }\n\n    stack = []\n    traversed = {}\n    // End result\n    return result\n  }\n\n  /**\n   * Append an entry to the log.\n   * @param {Entry} entry Entry to add\n   * @return {Log} New Log containing the appended value\n   */\n  async append (data, pointerCount = 1, pin = false) {\n    // Update the clock (find the latest clock)\n    const newTime = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0)) + 1\n    this._clock = new Clock(this.clock.id, newTime)\n\n    const all = Object.values(this.traverse(this.heads, Math.max(pointerCount, this.heads.length)))\n\n    // If pointer count is 4, returns 2\n    // If pointer count is 8, returns 3 references\n    // If pointer count is 512, returns 9 references\n    // If pointer count is 2048, returns 11 references\n    const getEveryPow2 = (maxDistance) => {\n      const entries = new Set()\n      for (let i = 1; i <= maxDistance; i *= 2) {\n        const index = Math.min(i - 1, all.length - 1)\n        entries.add(all[index])\n      }\n      return entries\n    }\n    const references = getEveryPow2(Math.min(pointerCount, all.length))\n\n    // Always include the last known reference\n    if (all.length < pointerCount && all[all.length - 1]) {\n      references.add(all[all.length - 1])\n    }\n\n    // Create the next pointers from heads\n    const nexts = Object.keys(this.heads.reverse().reduce(uniqueEntriesReducer, {}))\n    const isNext = e => !nexts.includes(e)\n    // Delete the heads from the refs\n    const refs = Array.from(references).map(getHash).filter(isNext)\n    // @TODO: Split Entry.create into creating object, checking permission, signing and then posting to IPFS\n    // Create the entry and add it to the internal cache\n    const entry = await Entry.create(\n      this._storage,\n      this._identity,\n      this.id,\n      data,\n      nexts,\n      this.clock,\n      refs,\n      pin\n    )\n\n    const canAppend = await this._access.canAppend(entry, this._identity.provider)\n    if (!canAppend) {\n      throw new Error(`Could not append entry, key \"${this._identity.id}\" is not allowed to write to the log`)\n    }\n\n    this._entryIndex.set(entry.hash, entry)\n    nexts.forEach(e => (this._nextsIndex[e] = entry.hash))\n    this._headsIndex = {}\n    this._headsIndex[entry.hash] = entry\n    // Update the length\n    this._length++\n    return entry\n  }\n\n  /*\n   * Creates a javscript iterator over log entries\n   *\n   * @param {Object} options\n   * @param {string|Array} options.gt Beginning hash of the iterator, non-inclusive\n   * @param {string|Array} options.gte Beginning hash of the iterator, inclusive\n   * @param {string|Array} options.lt Ending hash of the iterator, non-inclusive\n   * @param {string|Array} options.lte Ending hash of the iterator, inclusive\n   * @param {amount} options.amount Number of entried to return to / from the gte / lte hash\n   * @returns {Symbol.Iterator} Iterator object containing log entries\n   *\n   * @examples\n   *\n   * (async () => {\n   *   log1 = new Log(ipfs, testIdentity, { logId: 'X' })\n   *\n   *   for (let i = 0; i <= 100; i++) {\n   *     await log1.append('entry' + i)\n   *   }\n   *\n   *   let it = log1.iterator({\n   *     lte: 'zdpuApFd5XAPkCTmSx7qWQmQzvtdJPtx2K5p9to6ytCS79bfk',\n   *     amount: 10\n   *   })\n   *\n   *   [...it].length // 10\n   * })()\n   *\n   *\n   */\n  iterator ({ gt = undefined, gte = undefined, lt = undefined, lte = undefined, amount = -1 } =\n  {}) {\n    if (amount === 0) return (function * () {})()\n    if (typeof lte === 'string') lte = [this.get(lte)]\n    if (typeof lt === 'string') lt = [this.get(this.get(lt).next[0])]\n\n    if (lte && !Array.isArray(lte)) throw LogError.LtOrLteMustBeStringOrArray()\n    if (lt && !Array.isArray(lt)) throw LogError.LtOrLteMustBeStringOrArray()\n\n    const start = (lte || (lt || this.heads)).filter(isDefined)\n    const endHash = gte ? this.get(gte).hash : gt ? this.get(gt).hash : null\n    const count = endHash ? -1 : amount || -1\n\n    const entries = this.traverse(start, count, endHash)\n    let entryValues = Object.values(entries)\n\n    // Strip off last entry if gt is non-inclusive\n    if (gt) entryValues.pop()\n\n    // Deal with the amount argument working backwards from gt/gte\n    if ((gt || gte) && amount > -1) {\n      entryValues = entryValues.slice(entryValues.length - amount, entryValues.length)\n    }\n\n    return (function * () {\n      for (const i in entryValues) {\n        yield entryValues[i]\n      }\n    })()\n  }\n\n  /**\n   * Join two logs.\n   *\n   * Joins another log into this one.\n   *\n   * @param {Log} log Log to join with this Log\n   * @param {number} [size=-1] Max size of the joined log\n   * @returns {Promise<Log>} This Log instance\n   * @example\n   * await log1.join(log2)\n   */\n  async join (log, size = -1) {\n    if (!isDefined(log)) throw LogError.LogNotDefinedError()\n    if (!Log.isLog(log)) throw LogError.NotALogError()\n    if (this.id !== log.id) return\n\n    // Get the difference of the logs\n    const newItems = Log.difference(log, this)\n\n    const identityProvider = this._identity.provider\n    // Verify if entries are allowed to be added to the log and throws if\n    // there's an invalid entry\n    const permitted = async (entry) => {\n      const canAppend = await this._access.canAppend(entry, identityProvider)\n      if (!canAppend) {\n        throw new Error(`Could not append entry, key \"${entry.identity.id}\" is not allowed to write to the log`)\n      }\n    }\n\n    // Verify signature for each entry and throws if there's an invalid signature\n    const verify = async (entry) => {\n      const isValid = await Entry.verify(identityProvider, entry)\n      const publicKey = entry.identity ? entry.identity.publicKey : entry.key\n      if (!isValid) throw new Error(`Could not validate signature \"${entry.sig}\" for entry \"${entry.hash}\" and key \"${publicKey}\"`)\n    }\n\n    const entriesToJoin = Object.values(newItems)\n    await pMap(entriesToJoin, async e => {\n      await permitted(e)\n      await verify(e)\n    }, { concurrency: this.joinConcurrency })\n\n    // Update the internal next pointers index\n    const addToNextsIndex = e => {\n      const entry = this.get(e.hash)\n      if (!entry) this._length++ /* istanbul ignore else */\n      e.next.forEach(a => (this._nextsIndex[a] = e.hash))\n    }\n    Object.values(newItems).forEach(addToNextsIndex)\n\n    // Update the internal entry index\n    this._entryIndex.add(newItems)\n\n    // Merge the heads\n    const notReferencedByNewItems = e => !nextsFromNewItems.find(a => a === e.hash)\n    const notInCurrentNexts = e => !this._nextsIndex[e.hash]\n    const nextsFromNewItems = Object.values(newItems).map(getNextPointers).reduce(flatMap, [])\n    const mergedHeads = Log.findHeads(Object.values(Object.assign({}, this._headsIndex, log._headsIndex)))\n      .filter(notReferencedByNewItems)\n      .filter(notInCurrentNexts)\n      .reduce(uniqueEntriesReducer, {})\n\n    this._headsIndex = mergedHeads\n\n    // Slice to the requested size\n    if (size > -1) {\n      let tmp = this.values\n      tmp = tmp.slice(-size)\n      this._entryIndex = null\n      this._entryIndex = new EntryIndex(tmp.reduce(uniqueEntriesReducer, {}))\n      this._headsIndex = Log.findHeads(tmp).reduce(uniqueEntriesReducer, {})\n      this._length = this._entryIndex.length\n    }\n\n    // Find the latest clock from the heads\n    const maxClock = Object.values(this._headsIndex).reduce(maxClockTimeReducer, 0)\n    this._clock = new Clock(this.clock.id, Math.max(this.clock.time, maxClock))\n    return this\n  }\n\n  /**\n   * Get the log in JSON format.\n   * @returns {Object} An object with the id and heads properties\n   */\n  toJSON () {\n    return {\n      id: this.id,\n      heads: this.heads\n        .sort(this._sortFn) // default sorting\n        .reverse() // we want the latest as the first element\n        .map(getHash) // return only the head hashes\n    }\n  }\n\n  /**\n   * Get the log in JSON format as a snapshot.\n   * @returns {Object} An object with the id, heads and value properties\n   */\n  toSnapshot () {\n    return {\n      id: this.id,\n      heads: this.heads,\n      values: this.values\n    }\n  }\n\n  /**\n   * Get the log as a Buffer.\n   * @returns {Buffer}\n   */\n  toBuffer () {\n    return Buffer.from(JSON.stringify(this.toJSON()))\n  }\n\n  /**\n   * Returns the log entries as a formatted string.\n   * @returns {string}\n   * @example\n   * two\n   * └─one\n   *   └─three\n   */\n  toString (payloadMapper) {\n    return this.values\n      .slice()\n      .reverse()\n      .map((e, idx) => {\n        const parents = Entry.findChildren(e, this.values)\n        const len = parents.length\n        let padding = new Array(Math.max(len - 1, 0))\n        padding = len > 1 ? padding.fill('  ') : padding\n        padding = len > 0 ? padding.concat(['└─']) : padding\n        /* istanbul ignore next */\n        return padding.join('') + (payloadMapper ? payloadMapper(e.payload) : e.payload)\n      })\n      .join('\\n')\n  }\n\n  /**\n   * Check whether an object is a Log instance.\n   * @param {Object} log An object to check\n   * @returns {boolean}\n   */\n  static isLog (log) {\n    return log.id !== undefined &&\n      log.heads !== undefined &&\n      log._entryIndex !== undefined\n  }\n\n  /**\n   * Get the log's multihash.\n   * @returns {Promise<string>} Multihash of the Log as Base58 encoded string.\n   */\n  toMultihash ({ format } = {}) {\n    return LogIO.toMultihash(this._storage, this, { format })\n  }\n\n  /**\n   * Create a log from a hashes.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {string} hash The log hash\n   * @param {Object} options\n   * @param {AccessController} options.access The access controller instance\n   * @param {number} options.length How many items to include in the log\n   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n   * @param {function(hash, entry, parent, depth)} options.onProgressCallback\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @returns {Promise<Log>}\n   */\n  static async fromMultihash (ipfs, identity, hash,\n    { access, length = -1, exclude = [], shouldExclude, timeout, concurrency, sortFn, onProgressCallback } = {}) {\n    // TODO: need to verify the entries with 'key'\n    const { logId, entries, heads } = await LogIO.fromMultihash(ipfs, hash,\n      { length, exclude, shouldExclude, timeout, onProgressCallback, concurrency, sortFn })\n    return new Log(ipfs, identity, { logId, access, entries, heads, sortFn })\n  }\n\n  /**\n   * Create a log from a single entry's hash.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {string} hash The entry's hash\n   * @param {Object} options\n   * @param {string} options.logId The ID of the log\n   * @param {AccessController} options.access The access controller instance\n   * @param {number} options.length How many entries to include in the log\n   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n   * @param {function(hash, entry, parent, depth)} options.onProgressCallback\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Promise<Log>} New Log\n   */\n  static async fromEntryHash (ipfs, identity, hash,\n    { logId, access, length = -1, exclude = [], shouldExclude, timeout, concurrency, sortFn, onProgressCallback } = {}) {\n    // TODO: need to verify the entries with 'key'\n    const { entries } = await LogIO.fromEntryHash(ipfs, hash,\n      { length, exclude, shouldExclude, timeout, concurrency, onProgressCallback })\n    return new Log(ipfs, identity, { logId, access, entries, sortFn })\n  }\n\n  /**\n   * Create a log from a Log Snapshot JSON.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {Object} json Log snapshot as JSON object\n   * @param {Object} options\n   * @param {AccessController} options.access The access controller instance\n   * @param {number} options.length How many entries to include in the log\n   * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Promise<Log>} New Log\n   */\n  static async fromJSON (ipfs, identity, json,\n    { access, length = -1, timeout, sortFn, onProgressCallback } = {}) {\n    // TODO: need to verify the entries with 'key'\n    const { logId, entries } = await LogIO.fromJSON(ipfs, json,\n      { length, timeout, onProgressCallback })\n    return new Log(ipfs, identity, { logId, access, entries, sortFn })\n  }\n\n  /**\n   * Create a new log from an Entry instance.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {Entry|Array<Entry>} sourceEntries An Entry or an array of entries to fetch a log from\n   * @param {Object} options\n   * @param {AccessController} options.access The access controller instance\n   * @param {number} options.length How many entries to include. Default: infinite.\n   * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n   * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Promise<Log>} New Log\n   */\n  static async fromEntry (ipfs, identity, sourceEntries,\n    { access, length = -1, exclude = [], timeout, concurrency, sortFn, onProgressCallback } = {}) {\n    // TODO: need to verify the entries with 'key'\n    const { logId, entries } = await LogIO.fromEntry(ipfs, sourceEntries,\n      { length, exclude, timeout, concurrency, onProgressCallback })\n    return new Log(ipfs, identity, { logId, access, entries, sortFn })\n  }\n\n  /**\n   * Find heads from a collection of entries.\n   *\n   * Finds entries that are the heads of this collection,\n   * ie. entries that are not referenced by other entries.\n   *\n   * @param {Array<Entry>} entries Entries to search heads from\n   * @returns {Array<Entry>}\n   */\n  static findHeads (entries) {\n    const indexReducer = (res, entry, idx, arr) => {\n      const addToResult = e => (res[e] = entry.hash)\n      entry.next.forEach(addToResult)\n      return res\n    }\n\n    const items = entries.reduce(indexReducer, {})\n\n    const exists = e => items[e.hash] === undefined\n    const compareIds = (a, b) => a.clock.id > b.clock.id\n\n    return entries.filter(exists).sort(compareIds)\n  }\n\n  // Find entries that point to another entry that is not in the\n  // input array\n  static findTails (entries) {\n    // Reverse index { next -> entry }\n    const reverseIndex = {}\n    // Null index containing entries that have no parents (nexts)\n    const nullIndex = []\n    // Hashes for all entries for quick lookups\n    const hashes = {}\n    // Hashes of all next entries\n    let nexts = []\n\n    const addToIndex = (e) => {\n      if (e.next.length === 0) {\n        nullIndex.push(e)\n      }\n      const addToReverseIndex = (a) => {\n        /* istanbul ignore else */\n        if (!reverseIndex[a]) reverseIndex[a] = []\n        reverseIndex[a].push(e)\n      }\n\n      // Add all entries and their parents to the reverse index\n      e.next.forEach(addToReverseIndex)\n      // Get all next references\n      nexts = nexts.concat(e.next)\n      // Get the hashes of input entries\n      hashes[e.hash] = true\n    }\n\n    // Create our indices\n    entries.forEach(addToIndex)\n\n    const addUniques = (res, entries, idx, arr) => res.concat(findUniques(entries, 'hash'))\n    const exists = e => hashes[e] === undefined\n    const findFromReverseIndex = e => reverseIndex[e]\n\n    // Drop hashes that are not in the input entries\n    const tails = nexts // For every hash in nexts:\n      .filter(exists) // Remove undefineds and nulls\n      .map(findFromReverseIndex) // Get the Entry from the reverse index\n      .reduce(addUniques, []) // Flatten the result and take only uniques\n      .concat(nullIndex) // Combine with tails the have no next refs (ie. first-in-their-chain)\n\n    return findUniques(tails, 'hash').sort(Entry.compare)\n  }\n\n  // Find the hashes to entries that are not in a collection\n  // but referenced by other entries\n  static findTailHashes (entries) {\n    const hashes = {}\n    const addToIndex = e => (hashes[e.hash] = true)\n    const reduceTailHashes = (res, entry, idx, arr) => {\n      const addToResult = (e) => {\n        /* istanbul ignore else */\n        if (hashes[e] === undefined) {\n          res.splice(0, 0, e)\n        }\n      }\n      entry.next.reverse().forEach(addToResult)\n      return res\n    }\n\n    entries.forEach(addToIndex)\n    return entries.reduce(reduceTailHashes, [])\n  }\n\n  static difference (a, b) {\n    const stack = Object.keys(a._headsIndex)\n    const traversed = {}\n    const res = {}\n\n    const pushToStack = hash => {\n      if (!traversed[hash] && !b.get(hash)) {\n        stack.push(hash)\n        traversed[hash] = true\n      }\n    }\n\n    while (stack.length > 0) {\n      const hash = stack.shift()\n      const entry = a.get(hash)\n      if (entry && !b.get(hash) && entry.id === b.id) {\n        res[entry.hash] = entry\n        traversed[entry.hash] = true\n        entry.next.concat(entry.refs).forEach(pushToStack)\n      }\n    }\n    return res\n  }\n}\n\nmodule.exports = Log\nmodule.exports.Sorting = Sorting\nmodule.exports.Entry = Entry\nmodule.exports.AccessController = AccessController\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}