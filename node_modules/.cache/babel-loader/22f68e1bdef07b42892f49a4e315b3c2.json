{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar _asyncGeneratorDelegate = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate.js\").default;\n\nvar _require = require('../../utils'),\n    resolvePath = _require.resolvePath;\n\nvar withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nvar _require2 = require('ipfs-core-utils/src/pins/normalise-input'),\n    normaliseInput = _require2.normaliseInput;\n\nvar _require3 = require('ipfs-repo'),\n    PinTypes = _require3.PinTypes;\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\n\nmodule.exports = function (_ref2) {\n  var repo = _ref2.repo,\n      codecs = _ref2.codecs;\n\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"addAll\"]}\n   */\n  function addAll(_x) {\n    return _addAll.apply(this, arguments);\n  }\n\n  function _addAll() {\n    _addAll = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source) {\n      var options,\n          pinAdd,\n          lock,\n          release,\n          _args2 = arguments;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n\n              /**\n               * @returns {AsyncIterable<CID>}\n               */\n              pinAdd = /*#__PURE__*/function () {\n                var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                  var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, path, recursive, metadata, _yield$_awaitAsyncGen, cid, _yield$_awaitAsyncGen2, reason;\n\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _iteratorAbruptCompletion = false;\n                          _didIteratorError = false;\n                          _context.prev = 2;\n                          _iterator = _asyncIterator(normaliseInput(source));\n\n                        case 4:\n                          _context.next = 6;\n                          return _awaitAsyncGenerator(_iterator.next());\n\n                        case 6:\n                          if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                            _context.next = 30;\n                            break;\n                          }\n\n                          _step$value = _step.value, path = _step$value.path, recursive = _step$value.recursive, metadata = _step$value.metadata;\n                          _context.next = 10;\n                          return _awaitAsyncGenerator(resolvePath(repo, codecs, path));\n\n                        case 10:\n                          _yield$_awaitAsyncGen = _context.sent;\n                          cid = _yield$_awaitAsyncGen.cid;\n                          _context.next = 14;\n                          return _awaitAsyncGenerator(repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]));\n\n                        case 14:\n                          _yield$_awaitAsyncGen2 = _context.sent;\n                          reason = _yield$_awaitAsyncGen2.reason;\n\n                          if (!(reason === 'recursive' && !recursive)) {\n                            _context.next = 18;\n                            break;\n                          }\n\n                          throw new Error(\"\".concat(cid, \" already pinned recursively\"));\n\n                        case 18:\n                          if (!recursive) {\n                            _context.next = 23;\n                            break;\n                          }\n\n                          _context.next = 21;\n                          return _awaitAsyncGenerator(repo.pins.pinRecursively(cid, {\n                            metadata: metadata\n                          }));\n\n                        case 21:\n                          _context.next = 25;\n                          break;\n\n                        case 23:\n                          _context.next = 25;\n                          return _awaitAsyncGenerator(repo.pins.pinDirectly(cid, {\n                            metadata: metadata\n                          }));\n\n                        case 25:\n                          _context.next = 27;\n                          return cid;\n\n                        case 27:\n                          _iteratorAbruptCompletion = false;\n                          _context.next = 4;\n                          break;\n\n                        case 30:\n                          _context.next = 36;\n                          break;\n\n                        case 32:\n                          _context.prev = 32;\n                          _context.t0 = _context[\"catch\"](2);\n                          _didIteratorError = true;\n                          _iteratorError = _context.t0;\n\n                        case 36:\n                          _context.prev = 36;\n                          _context.prev = 37;\n\n                          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                            _context.next = 41;\n                            break;\n                          }\n\n                          _context.next = 41;\n                          return _awaitAsyncGenerator(_iterator.return());\n\n                        case 41:\n                          _context.prev = 41;\n\n                          if (!_didIteratorError) {\n                            _context.next = 44;\n                            break;\n                          }\n\n                          throw _iteratorError;\n\n                        case 44:\n                          return _context.finish(41);\n\n                        case 45:\n                          return _context.finish(36);\n\n                        case 46:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee, null, [[2, 32, 36, 46], [37,, 41, 45]]);\n                }));\n\n                return function pinAdd() {\n                  return _ref.apply(this, arguments);\n                };\n              }(); // When adding a file, we take a lock that gets released after pinning\n              // is complete, so don't take a second lock here\n\n\n              lock = Boolean(options.lock);\n\n              if (lock) {\n                _context2.next = 6;\n                break;\n              }\n\n              return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pinAdd()), _awaitAsyncGenerator), \"t0\", 5);\n\n            case 5:\n              return _context2.abrupt(\"return\");\n\n            case 6:\n              _context2.next = 8;\n              return _awaitAsyncGenerator(repo.gcLock.readLock());\n\n            case 8:\n              release = _context2.sent;\n              _context2.prev = 9;\n              return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pinAdd()), _awaitAsyncGenerator), \"t1\", 11);\n\n            case 11:\n              _context2.prev = 11;\n              release();\n              return _context2.finish(11);\n\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[9,, 11, 14]]);\n    }));\n    return _addAll.apply(this, arguments);\n  }\n\n  return withTimeoutOption(addAll);\n};","map":{"version":3,"names":["require","resolvePath","withTimeoutOption","normaliseInput","PinTypes","module","exports","repo","codecs","addAll","source","options","pinAdd","path","recursive","metadata","cid","pins","isPinnedWithType","direct","reason","Error","pinRecursively","pinDirectly","lock","Boolean","gcLock","readLock","release"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/pin/add-all.js"],"sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { resolvePath } = require('../../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { normaliseInput } = require('ipfs-core-utils/src/pins/normalise-input')\nconst { PinTypes } = require('ipfs-repo')\n\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nmodule.exports = ({ repo, codecs }) => {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"addAll\"]}\n   */\n  async function * addAll (source, options = {}) {\n    /**\n     * @returns {AsyncIterable<CID>}\n     */\n    const pinAdd = async function * () {\n      for await (const { path, recursive, metadata } of normaliseInput(source)) {\n        const { cid } = await resolvePath(repo, codecs, path)\n\n        // verify that each hash can be pinned\n        const { reason } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct])\n\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(`${cid} already pinned recursively`)\n        }\n\n        if (recursive) {\n          await repo.pins.pinRecursively(cid, { metadata })\n        } else {\n          await repo.pins.pinDirectly(cid, { metadata })\n        }\n\n        yield cid\n      }\n    }\n\n    // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n    const lock = Boolean(options.lock)\n\n    if (!lock) {\n      yield * pinAdd()\n      return\n    }\n\n    const release = await repo.gcLock.readLock()\n\n    try {\n      yield * pinAdd()\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(addAll)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}