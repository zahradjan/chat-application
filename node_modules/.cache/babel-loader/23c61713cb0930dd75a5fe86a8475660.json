{"ast":null,"code":"/* eslint-disable no-unreachable */\n'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar isIpfs = require('is-ipfs');\n\nvar _require = require('multiformats/cid'),\n    CID = _require.CID;\n\nvar Key = require('interface-datastore').Key;\n\nvar errCode = require('err-code');\n\nvar withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nvar toCidAndPath = require('ipfs-core-utils/src/to-cid-and-path');\n\nvar dagPb = require('@ipld/dag-pb');\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\n\nvar ERR_BAD_PATH = 'ERR_BAD_PATH';\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {string | CID} pathStr - An ipfs-path, or ipns-path or a cid\n * @returns {string} - ipfs-path or ipns-path\n * @throws on an invalid @param pathStr\n */\n\nvar normalizePath = function normalizePath(pathStr) {\n  var cid = CID.asCID(pathStr);\n\n  if (cid) {\n    return \"/ipfs/\".concat(pathStr);\n  }\n\n  var str = pathStr.toString();\n\n  try {\n    return \"/ipfs/\".concat(CID.parse(str));\n  } catch (_unused) {}\n\n  if (isIpfs.path(str)) {\n    return str;\n  } else {\n    throw errCode(new Error(\"invalid path: \".concat(pathStr)), ERR_BAD_PATH);\n  }\n}; // TODO: do we need both normalizePath and normalizeCidPath?\n// TODO: don't forget ipfs-core-utils/src/to-cid-and-path\n\n/**\n * @param {Uint8Array|CID|string} path\n */\n\n\nvar normalizeCidPath = function normalizeCidPath(path) {\n  if (path instanceof Uint8Array) {\n    return CID.decode(path).toString();\n  }\n\n  path = path.toString();\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n};\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID | string | Uint8Array} ipfsPath - A CID or IPFS path\n * @param {{ path?: string, signal?: AbortSignal }} [options] - Optional options passed directly to dag.resolve\n * @returns {Promise<{ cid: CID, remainderPath: string}>}\n */\n\n\nvar resolvePath = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(repo, codecs, ipfsPath) {\n    var options,\n        _toCidAndPath,\n        cid,\n        path,\n        lastCid,\n        lastRemainderPath,\n        _iteratorAbruptCompletion,\n        _didIteratorError,\n        _iteratorError,\n        _iterator,\n        _step,\n        _step$value,\n        value,\n        remainderPath,\n        _args = arguments;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n            _toCidAndPath = toCidAndPath(ipfsPath), cid = _toCidAndPath.cid, path = _toCidAndPath.path;\n\n            if (path) {\n              options.path = path;\n            }\n\n            lastCid = cid;\n            lastRemainderPath = options.path || '';\n\n            if (lastRemainderPath.startsWith('/')) {\n              lastRemainderPath = lastRemainderPath.substring(1);\n            }\n\n            if (!options.path) {\n              _context.next = 45;\n              break;\n            }\n\n            _context.prev = 7;\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 10;\n            _iterator = _asyncIterator(resolve(cid, options.path, codecs, repo, {\n              signal: options.signal\n            }));\n\n          case 12:\n            _context.next = 14;\n            return _iterator.next();\n\n          case 14:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 23;\n              break;\n            }\n\n            _step$value = _step.value, value = _step$value.value, remainderPath = _step$value.remainderPath;\n\n            if (CID.asCID(value)) {\n              _context.next = 18;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 23);\n\n          case 18:\n            lastRemainderPath = remainderPath;\n            lastCid = value;\n\n          case 20:\n            _iteratorAbruptCompletion = false;\n            _context.next = 12;\n            break;\n\n          case 23:\n            _context.next = 29;\n            break;\n\n          case 25:\n            _context.prev = 25;\n            _context.t0 = _context[\"catch\"](10);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n\n          case 29:\n            _context.prev = 29;\n            _context.prev = 30;\n\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 34;\n              break;\n            }\n\n            _context.next = 34;\n            return _iterator.return();\n\n          case 34:\n            _context.prev = 34;\n\n            if (!_didIteratorError) {\n              _context.next = 37;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 37:\n            return _context.finish(34);\n\n          case 38:\n            return _context.finish(29);\n\n          case 39:\n            _context.next = 45;\n            break;\n\n          case 41:\n            _context.prev = 41;\n            _context.t1 = _context[\"catch\"](7);\n\n            // TODO: add error codes to IPLD\n            if (_context.t1.message.startsWith('Object has no property')) {\n              _context.t1.message = \"no link named \\\"\".concat(lastRemainderPath.split('/')[0], \"\\\" under \").concat(lastCid);\n              _context.t1.code = 'ERR_NO_LINK';\n            }\n\n            throw _context.t1;\n\n          case 45:\n            return _context.abrupt(\"return\", {\n              cid: lastCid,\n              remainderPath: lastRemainderPath || ''\n            });\n\n          case 46:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[7, 41], [10, 25, 29, 39], [30,, 34, 38]]);\n  }));\n\n  return function resolvePath(_x6, _x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n *\n * @param {UnixFSEntry} file\n */\n\n\nvar mapFile = function mapFile(file) {\n  if (file.type !== 'file' && file.type !== 'directory' && file.type !== 'raw') {\n    // file.type === object | identity not supported yet\n    throw new Error(\"Unknown node type '\".concat(file.type, \"'\"));\n  }\n  /** @type {import('ipfs-core-types/src/root').IPFSEntry} */\n\n\n  var output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    type: 'file'\n  };\n\n  if (file.type === 'directory') {\n    // @ts-ignore - TS type can't be changed from File to Directory\n    output.type = 'dir';\n  }\n\n  if (file.type === 'file') {\n    output.size = file.unixfs.fileSize();\n  }\n\n  if (file.type === 'file' || file.type === 'directory') {\n    output.mode = file.unixfs.mode;\n\n    if (file.unixfs.mtime !== undefined) {\n      output.mtime = file.unixfs.mtime;\n    }\n  }\n\n  return output;\n};\n\nvar withTimeout = withTimeoutOption(\n/*#__PURE__*/\n\n/**\n * @template T\n * @param {Promise<T>|T} promise\n * @param {AbortOptions} [_options]\n * @returns {Promise<T>}\n */\nfunction () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(promise, _options) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return promise;\n\n          case 2:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x9, _x10) {\n    return _ref3.apply(this, arguments);\n  };\n}());\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {AbortOptions} [options]\n */\n\nvar resolve = /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(cid, path, codecs, repo, options) {\n    var load, parts, value, lastCid, _loop, _ret;\n\n    return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            /**\n             * @param {CID} cid\n             */\n            load = /*#__PURE__*/function () {\n              var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(cid) {\n                var codec, block;\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.next = 2;\n                        return codecs.getCodec(cid.code);\n\n                      case 2:\n                        codec = _context3.sent;\n                        _context3.next = 5;\n                        return repo.blocks.get(cid, options);\n\n                      case 5:\n                        block = _context3.sent;\n                        return _context3.abrupt(\"return\", codec.decode(block));\n\n                      case 7:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3);\n              }));\n\n              return function load(_x11) {\n                return _ref4.apply(this, arguments);\n              };\n            }();\n\n            parts = path.split('/').filter(Boolean);\n            _context5.next = 4;\n            return _awaitAsyncGenerator(load(cid));\n\n          case 4:\n            value = _context5.sent;\n            lastCid = cid;\n\n            if (parts.length) {\n              _context5.next = 9;\n              break;\n            }\n\n            _context5.next = 9;\n            return {\n              value: value,\n              remainderPath: ''\n            };\n\n          case 9:\n            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n              var key, link;\n              return _regeneratorRuntime().wrap(function _loop$(_context4) {\n                while (1) {\n                  switch (_context4.prev = _context4.next) {\n                    case 0:\n                      key = parts.shift();\n\n                      if (key) {\n                        _context4.next = 3;\n                        break;\n                      }\n\n                      throw errCode(new Error(\"Could not resolve path \\\"\".concat(path, \"\\\"\")), 'ERR_INVALID_PATH');\n\n                    case 3:\n                      if (!(cid.code === dagPb.code && Array.isArray(value.Links))) {\n                        _context4.next = 13;\n                        break;\n                      }\n\n                      link = value.Links.find(function (\n                      /** @type {PBLink} */\n                      l) {\n                        return l.Name === key;\n                      });\n\n                      if (!link) {\n                        _context4.next = 13;\n                        break;\n                      }\n\n                      _context4.next = 8;\n                      return {\n                        value: link.Hash,\n                        remainderPath: parts.join('/')\n                      };\n\n                    case 8:\n                      _context4.next = 10;\n                      return _awaitAsyncGenerator(load(link.Hash));\n\n                    case 10:\n                      value = _context4.sent;\n                      lastCid = link.Hash;\n                      return _context4.abrupt(\"return\", \"continue\");\n\n                    case 13:\n                      if (!Object.prototype.hasOwnProperty.call(value, key)) {\n                        _context4.next = 19;\n                        break;\n                      }\n\n                      value = value[key];\n                      _context4.next = 17;\n                      return {\n                        value: value,\n                        remainderPath: parts.join('/')\n                      };\n\n                    case 17:\n                      _context4.next = 20;\n                      break;\n\n                    case 19:\n                      throw errCode(new Error(\"no link named \\\"\".concat(key, \"\\\" under \").concat(lastCid)), 'ERR_NO_LINK');\n\n                    case 20:\n                      if (!CID.asCID(value)) {\n                        _context4.next = 25;\n                        break;\n                      }\n\n                      lastCid = value;\n                      _context4.next = 24;\n                      return _awaitAsyncGenerator(load(value));\n\n                    case 24:\n                      value = _context4.sent;\n\n                    case 25:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }\n              }, _loop);\n            });\n\n          case 10:\n            if (!parts.length) {\n              _context5.next = 17;\n              break;\n            }\n\n            return _context5.delegateYield(_loop(), \"t0\", 12);\n\n          case 12:\n            _ret = _context5.t0;\n\n            if (!(_ret === \"continue\")) {\n              _context5.next = 15;\n              break;\n            }\n\n            return _context5.abrupt(\"continue\", 10);\n\n          case 15:\n            _context5.next = 10;\n            break;\n\n          case 17:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function resolve(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = {\n  normalizePath: normalizePath,\n  normalizeCidPath: normalizeCidPath,\n  resolvePath: resolvePath,\n  mapFile: mapFile,\n  withTimeout: withTimeout,\n  resolve: resolve,\n  OFFLINE_ERROR: 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.',\n  MFS_ROOT_KEY: new Key('/local/filesroot'),\n  MFS_MAX_CHUNK_SIZE: 262144,\n  MFS_MAX_LINKS: 174\n};","map":{"version":3,"names":["isIpfs","require","CID","Key","errCode","withTimeoutOption","toCidAndPath","dagPb","ERR_BAD_PATH","normalizePath","pathStr","cid","asCID","str","toString","parse","path","Error","normalizeCidPath","Uint8Array","decode","indexOf","substring","length","charAt","resolvePath","repo","codecs","ipfsPath","options","lastCid","lastRemainderPath","startsWith","resolve","signal","value","remainderPath","message","split","code","mapFile","file","type","output","name","size","unixfs","fileSize","mode","mtime","undefined","withTimeout","promise","_options","load","getCodec","codec","blocks","get","block","parts","filter","Boolean","key","shift","Array","isArray","Links","link","find","l","Name","Hash","join","Object","prototype","hasOwnProperty","call","module","exports","OFFLINE_ERROR","MFS_ROOT_KEY","MFS_MAX_CHUNK_SIZE","MFS_MAX_LINKS"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/utils.js"],"sourcesContent":["/* eslint-disable no-unreachable */\n'use strict'\n\nconst isIpfs = require('is-ipfs')\nconst { CID } = require('multiformats/cid')\nconst Key = require('interface-datastore').Key\nconst errCode = require('err-code')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst toCidAndPath = require('ipfs-core-utils/src/to-cid-and-path')\nconst dagPb = require('@ipld/dag-pb')\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('@ipld/dag-pb').PBLink} PBLink\n */\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH'\n\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {string | CID} pathStr - An ipfs-path, or ipns-path or a cid\n * @returns {string} - ipfs-path or ipns-path\n * @throws on an invalid @param pathStr\n */\nconst normalizePath = (pathStr) => {\n  const cid = CID.asCID(pathStr)\n\n  if (cid) {\n    return `/ipfs/${pathStr}`\n  }\n\n  const str = pathStr.toString()\n\n  try {\n    return `/ipfs/${CID.parse(str)}`\n  } catch {}\n\n  if (isIpfs.path(str)) {\n    return str\n  } else {\n    throw errCode(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH)\n  }\n}\n\n// TODO: do we need both normalizePath and normalizeCidPath?\n// TODO: don't forget ipfs-core-utils/src/to-cid-and-path\n/**\n * @param {Uint8Array|CID|string} path\n */\nconst normalizeCidPath = (path) => {\n  if (path instanceof Uint8Array) {\n    return CID.decode(path).toString()\n  }\n\n  path = path.toString()\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length)\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1)\n  }\n\n  return path\n}\n\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID | string | Uint8Array} ipfsPath - A CID or IPFS path\n * @param {{ path?: string, signal?: AbortSignal }} [options] - Optional options passed directly to dag.resolve\n * @returns {Promise<{ cid: CID, remainderPath: string}>}\n */\nconst resolvePath = async function (repo, codecs, ipfsPath, options = {}) {\n  const {\n    cid,\n    path\n  } = toCidAndPath(ipfsPath)\n\n  if (path) {\n    options.path = path\n  }\n\n  let lastCid = cid\n  let lastRemainderPath = options.path || ''\n\n  if (lastRemainderPath.startsWith('/')) {\n    lastRemainderPath = lastRemainderPath.substring(1)\n  }\n\n  if (options.path) {\n    try {\n      for await (const { value, remainderPath } of resolve(cid, options.path, codecs, repo, {\n        signal: options.signal\n      })) {\n        if (!CID.asCID(value)) {\n          break\n        }\n\n        lastRemainderPath = remainderPath\n        lastCid = value\n      }\n    } catch (err) {\n      // TODO: add error codes to IPLD\n      if (err.message.startsWith('Object has no property')) {\n        err.message = `no link named \"${lastRemainderPath.split('/')[0]}\" under ${lastCid}`\n        err.code = 'ERR_NO_LINK'\n      }\n      throw err\n    }\n  }\n\n  return {\n    cid: lastCid,\n    remainderPath: lastRemainderPath || ''\n  }\n}\n\n/**\n * @typedef {import('ipfs-unixfs-exporter').UnixFSEntry} UnixFSEntry\n *\n * @param {UnixFSEntry} file\n */\nconst mapFile = (file) => {\n  if (file.type !== 'file' && file.type !== 'directory' && file.type !== 'raw') {\n    // file.type === object | identity not supported yet\n    throw new Error(`Unknown node type '${file.type}'`)\n  }\n\n  /** @type {import('ipfs-core-types/src/root').IPFSEntry} */\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    type: 'file'\n  }\n\n  if (file.type === 'directory') {\n    // @ts-ignore - TS type can't be changed from File to Directory\n    output.type = 'dir'\n  }\n\n  if (file.type === 'file') {\n    output.size = file.unixfs.fileSize()\n  }\n\n  if (file.type === 'file' || file.type === 'directory') {\n    output.mode = file.unixfs.mode\n\n    if (file.unixfs.mtime !== undefined) {\n      output.mtime = file.unixfs.mtime\n    }\n  }\n\n  return output\n}\n\nconst withTimeout = withTimeoutOption(\n  /**\n   * @template T\n   * @param {Promise<T>|T} promise\n   * @param {AbortOptions} [_options]\n   * @returns {Promise<T>}\n   */\n  async (promise, _options) => await promise\n)\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {AbortOptions} [options]\n */\nconst resolve = async function * (cid, path, codecs, repo, options) {\n  /**\n   * @param {CID} cid\n   */\n  const load = async (cid) => {\n    const codec = await codecs.getCodec(cid.code)\n    const block = await repo.blocks.get(cid, options)\n\n    return codec.decode(block)\n  }\n\n  const parts = path.split('/').filter(Boolean)\n  let value = await load(cid)\n  let lastCid = cid\n\n  if (!parts.length) {\n    yield {\n      value,\n      remainderPath: ''\n    }\n  }\n\n  // End iteration if there isn't a CID to follow any more\n  while (parts.length) {\n    const key = parts.shift()\n\n    if (!key) {\n      throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH')\n    }\n\n    // special case for dag-pb, use the link name as the path segment\n    if (cid.code === dagPb.code && Array.isArray(value.Links)) {\n      const link = value.Links.find((/** @type {PBLink} */ l) => l.Name === key)\n\n      if (link) {\n        yield {\n          value: link.Hash,\n          remainderPath: parts.join('/')\n        }\n\n        value = await load(link.Hash)\n        lastCid = link.Hash\n\n        continue\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key]\n\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      }\n    } else {\n      throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK')\n    }\n\n    if (CID.asCID(value)) {\n      lastCid = value\n      value = await load(value)\n    }\n  }\n}\n\nmodule.exports = {\n  normalizePath,\n  normalizeCidPath,\n  resolvePath,\n  mapFile,\n  withTimeout,\n  resolve,\n\n  OFFLINE_ERROR: 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.',\n  MFS_ROOT_KEY: new Key('/local/filesroot'),\n  MFS_MAX_CHUNK_SIZE: 262144,\n  MFS_MAX_LINKS: 174\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}