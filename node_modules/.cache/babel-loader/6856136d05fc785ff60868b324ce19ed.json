{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _asyncGeneratorDelegate = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar log = require('debug')('ipfs:mfs:write');\n\nvar _require = require('ipfs-unixfs-importer'),\n    importer = _require.importer;\n\nvar _require2 = require('@ipld/dag-pb'),\n    decode = _require2.decode;\n\nvar _require3 = require('multiformats/hashes/sha2'),\n    sha256 = _require3.sha256,\n    sha512 = _require3.sha512;\n\nvar stat = require('./stat');\n\nvar mkdir = require('./mkdir');\n\nvar addLink = require('./utils/add-link');\n\nvar mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nvar createLock = require('./utils/create-lock');\n\nvar toAsyncIterator = require('./utils/to-async-iterator');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar toPathComponents = require('./utils/to-path-components');\n\nvar toTrail = require('./utils/to-trail');\n\nvar updateTree = require('./utils/update-tree');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar errCode = require('err-code');\n\nvar _require4 = require('../../utils'),\n    MFS_MAX_CHUNK_SIZE = _require4.MFS_MAX_CHUNK_SIZE;\n\nvar last = require('it-last');\n\nvar withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nvar _require5 = require('ipfs-unixfs'),\n    parseMode = _require5.parseMode,\n    parseMtime = _require5.parseMtime;\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {import('./utils/to-mfs-path').FilePath} FilePath\n * @typedef {import('./utils/to-mfs-path').MfsPath} MfsPath\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n *\n * @typedef {object} DefaultOptions\n * @property {number} offset\n * @property {number} length\n * @property {boolean} create\n * @property {boolean} truncate\n * @property {boolean} rawLeaves\n * @property {boolean} reduceSingleLeafToSelf\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} parents\n * @property {import('ipfs-core-types/src/root').AddProgressFn} progress\n * @property {'trickle' | 'balanced'} strategy\n * @property {boolean} flush\n * @property {'raw' | 'file'} leafType\n * @property {number} shardSplitThreshold\n * @property {MtimeLike} [mtime]\n * @property {number} [mode]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nvar defaultOptions = {\n  offset: 0,\n  // the offset in the file to begin writing\n  length: Infinity,\n  // how many bytes from the incoming buffer to write\n  create: false,\n  // whether to create the file if it does not exist\n  truncate: false,\n  // whether to truncate the file first\n  rawLeaves: false,\n  reduceSingleLeafToSelf: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  parents: false,\n  // whether to create intermediate directories if they do not exist\n  progress: function progress(bytes, path) {},\n  strategy: 'trickle',\n  flush: true,\n  leafType: 'raw',\n  shardSplitThreshold: 1000\n};\n/**\n * @param {MfsContext} context\n */\n\nmodule.exports = function (context) {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"write\"]}\n   */\n  function mfsWrite(_x4, _x5) {\n    return _mfsWrite.apply(this, arguments);\n  }\n\n  function _mfsWrite() {\n    _mfsWrite = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path, content) {\n      var opts,\n          options,\n          source,\n          destination,\n          parent,\n          _args2 = arguments;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              opts = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n\n              /** @type {DefaultOptions} */\n              options = mergeOptions(defaultOptions, opts);\n              /** @type {AsyncIterable<Uint8Array>} */\n\n              log('Reading source, destination and parent');\n              _context2.next = 5;\n              return createLock().readLock( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return toAsyncIterator(content);\n\n                      case 2:\n                        source = _context.sent;\n                        _context.next = 5;\n                        return toMfsPath(context, path, options);\n\n                      case 5:\n                        destination = _context.sent;\n                        _context.next = 8;\n                        return toMfsPath(context, destination.mfsDirectory, options);\n\n                      case 8:\n                        parent = _context.sent;\n\n                      case 9:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              })))();\n\n            case 5:\n              log('Read source, destination and parent'); // @ts-ignore - parent may be undefined\n\n              if (!(!options.parents && !parent.exists)) {\n                _context2.next = 8;\n                break;\n              }\n\n              throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST');\n\n            case 8:\n              if (!(source == null)) {\n                _context2.next = 10;\n                break;\n              }\n\n              throw errCode(new Error('could not create source'), 'ERR_NO_SOURCE');\n\n            case 10:\n              if (!(destination == null)) {\n                _context2.next = 12;\n                break;\n              }\n\n              throw errCode(new Error('could not create destination'), 'ERR_NO_DESTINATION');\n\n            case 12:\n              if (!(!options.create && !destination.exists)) {\n                _context2.next = 14;\n                break;\n              }\n\n              throw errCode(new Error('file does not exist'), 'ERR_NO_EXIST');\n\n            case 14:\n              if (!(destination.entryType !== 'file')) {\n                _context2.next = 16;\n                break;\n              }\n\n              throw errCode(new Error('not a file'), 'ERR_NOT_A_FILE');\n\n            case 16:\n              return _context2.abrupt(\"return\", updateOrImport(context, path, source, destination, options));\n\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return _mfsWrite.apply(this, arguments);\n  }\n\n  return withTimeoutOption(mfsWrite);\n};\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {AsyncIterable<Uint8Array>} source\n * @param {FilePath} destination\n * @param {DefaultOptions} options\n */\n\n\nvar updateOrImport = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(context, path, source, destination, options) {\n    var child;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return write(context, source, destination, options);\n\n          case 2:\n            child = _context4.sent;\n            _context4.next = 5;\n            return createLock().writeLock( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n              var pathComponents, fileName, parentExists, updatedPath, trail, parent, parentBlock, parentNode, result, newRootCid;\n              return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      pathComponents = toPathComponents(path);\n                      fileName = pathComponents.pop();\n\n                      if (!(fileName == null)) {\n                        _context3.next = 4;\n                        break;\n                      }\n\n                      throw errCode(new Error('source does not exist'), 'ERR_NO_EXIST');\n\n                    case 4:\n                      parentExists = false;\n                      _context3.prev = 5;\n                      _context3.next = 8;\n                      return stat(context)(\"/\".concat(pathComponents.join('/')), options);\n\n                    case 8:\n                      parentExists = true;\n                      _context3.next = 15;\n                      break;\n\n                    case 11:\n                      _context3.prev = 11;\n                      _context3.t0 = _context3[\"catch\"](5);\n\n                      if (!(_context3.t0.code !== 'ERR_NOT_FOUND')) {\n                        _context3.next = 15;\n                        break;\n                      }\n\n                      throw _context3.t0;\n\n                    case 15:\n                      if (parentExists) {\n                        _context3.next = 18;\n                        break;\n                      }\n\n                      _context3.next = 18;\n                      return mkdir(context)(\"/\".concat(pathComponents.join('/')), options);\n\n                    case 18:\n                      _context3.next = 20;\n                      return toMfsPath(context, path, options);\n\n                    case 20:\n                      updatedPath = _context3.sent;\n                      _context3.next = 23;\n                      return toTrail(context, updatedPath.mfsDirectory);\n\n                    case 23:\n                      trail = _context3.sent;\n                      parent = trail[trail.length - 1];\n\n                      if (parent) {\n                        _context3.next = 27;\n                        break;\n                      }\n\n                      throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST');\n\n                    case 27:\n                      if (!(!parent.type || !parent.type.includes('directory'))) {\n                        _context3.next = 29;\n                        break;\n                      }\n\n                      throw errCode(new Error(\"cannot write to \".concat(parent.name, \": Not a directory\")), 'ERR_NOT_A_DIRECTORY');\n\n                    case 29:\n                      _context3.next = 31;\n                      return context.repo.blocks.get(parent.cid);\n\n                    case 31:\n                      parentBlock = _context3.sent;\n                      parentNode = decode(parentBlock);\n                      _context3.next = 35;\n                      return addLink(context, {\n                        parent: parentNode,\n                        name: fileName,\n                        cid: child.cid,\n                        size: child.size,\n                        flush: options.flush,\n                        shardSplitThreshold: options.shardSplitThreshold,\n                        hashAlg: options.hashAlg,\n                        cidVersion: options.cidVersion\n                      });\n\n                    case 35:\n                      result = _context3.sent;\n                      parent.cid = result.cid; // update the tree with the new child\n\n                      _context3.next = 39;\n                      return updateTree(context, trail, options);\n\n                    case 39:\n                      newRootCid = _context3.sent;\n                      _context3.next = 42;\n                      return updateMfsRoot(context, newRootCid, options);\n\n                    case 42:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3, null, [[5, 11]]);\n            })))();\n\n          case 5:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function updateOrImport(_x6, _x7, _x8, _x9, _x10) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n/**\n * @param {MfsContext} context\n * @param {AsyncIterable<Uint8Array>} source\n * @param {FilePath} destination\n * @param {DefaultOptions} options\n */\n\n\nvar write = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(context, source, destination, options) {\n    var sources, extra, content, mode, mtime, hasher, result;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (destination.exists) {\n              log(\"Overwriting file \".concat(destination.cid, \" offset \").concat(options.offset, \" length \").concat(options.length));\n            } else {\n              log(\"Writing file offset \".concat(options.offset, \" length \").concat(options.length));\n            }\n            /** @type {Array<() => AsyncIterable<Uint8Array>>} */\n\n\n            sources = []; // pad start of file if necessary\n\n            if (options.offset > 0) {\n              if (destination.unixfs) {\n                log(\"Writing first \".concat(options.offset, \" bytes of original file\"));\n                sources.push(function () {\n                  return destination.content({\n                    offset: 0,\n                    length: options.offset\n                  });\n                });\n\n                if (destination.unixfs.fileSize() < options.offset) {\n                  extra = options.offset - destination.unixfs.fileSize();\n                  log(\"Writing zeros for extra \".concat(extra, \" bytes\"));\n                  sources.push(asyncZeroes(extra));\n                }\n              } else {\n                log(\"Writing zeros for first \".concat(options.offset, \" bytes\"));\n                sources.push(asyncZeroes(options.offset));\n              }\n            }\n\n            sources.push(limitAsyncStreamBytes(source, options.length));\n            content = countBytesStreamed(catAsyncIterators(sources), function (bytesWritten) {\n              if (destination.unixfs && !options.truncate) {\n                // if we've done reading from the new source and we are not going\n                // to truncate the file, add the end of the existing file to the output\n                var fileSize = destination.unixfs.fileSize();\n\n                if (fileSize > bytesWritten) {\n                  log(\"Writing last \".concat(fileSize - bytesWritten, \" of \").concat(fileSize, \" bytes from original file starting at offset \").concat(bytesWritten));\n                  return destination.content({\n                    offset: bytesWritten\n                  });\n                } else {\n                  log('Not writing last bytes from original file');\n                }\n              }\n\n              return _defineProperty({}, Symbol.asyncIterator, _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n                return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                  while (1) {\n                    switch (_context5.prev = _context5.next) {\n                      case 0:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }\n                }, _callee5);\n              })));\n            });\n            /** @type {number | undefined} */\n\n            if (options.mode !== undefined && options.mode !== null) {\n              mode = parseMode(options.mode);\n            } else if (destination && destination.unixfs) {\n              mode = destination.unixfs.mode;\n            }\n            /** @type {import('ipfs-unixfs').Mtime | undefined} */\n\n\n            if (options.mtime != null) {\n              mtime = parseMtime(options.mtime);\n            } else if (destination && destination.unixfs) {\n              mtime = destination.unixfs.mtime;\n            }\n\n            _context6.t0 = options.hashAlg;\n            _context6.next = _context6.t0 === 'sha2-256' ? 10 : _context6.t0 === 'sha2-512' ? 12 : 14;\n            break;\n\n          case 10:\n            hasher = sha256;\n            return _context6.abrupt(\"break\", 15);\n\n          case 12:\n            hasher = sha512;\n            return _context6.abrupt(\"break\", 15);\n\n          case 14:\n            throw new Error(\"TODO vmx 2021-03-31: Proper error message for unsupported hash algorithms like \".concat(options.hashAlg));\n\n          case 15:\n            _context6.next = 17;\n            return last(importer([{\n              content: content,\n              // persist mode & mtime if set previously\n              mode: mode,\n              mtime: mtime\n            }], context.repo.blocks, {\n              progress: options.progress,\n              hasher: hasher,\n              cidVersion: options.cidVersion,\n              strategy: options.strategy,\n              rawLeaves: options.rawLeaves,\n              reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,\n              leafType: options.leafType\n            }));\n\n          case 17:\n            result = _context6.sent;\n\n            if (result) {\n              _context6.next = 20;\n              break;\n            }\n\n            throw errCode(new Error(\"cannot write to \".concat(parent.name)), 'ERR_COULD_NOT_WRITE');\n\n          case 20:\n            log(\"Wrote \".concat(result.cid));\n            return _context6.abrupt(\"return\", {\n              cid: result.cid,\n              size: result.size\n            });\n\n          case 22:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function write(_x11, _x12, _x13, _x14) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n/**\n * @param {AsyncIterable<Uint8Array>} stream\n * @param {number} limit\n */\n\n\nvar limitAsyncStreamBytes = function limitAsyncStreamBytes(stream, limit) {\n  return /*#__PURE__*/function () {\n    var _limitAsyncStreamBytes2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n      var emitted, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, buf;\n\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              emitted = 0;\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context7.prev = 3;\n              _iterator = _asyncIterator(stream);\n\n            case 5:\n              _context7.next = 7;\n              return _awaitAsyncGenerator(_iterator.next());\n\n            case 7:\n              if (!(_iteratorAbruptCompletion = !(_step = _context7.sent).done)) {\n                _context7.next = 19;\n                break;\n              }\n\n              buf = _step.value;\n              emitted += buf.length;\n\n              if (!(emitted > limit)) {\n                _context7.next = 14;\n                break;\n              }\n\n              _context7.next = 13;\n              return buf.slice(0, limit - emitted);\n\n            case 13:\n              return _context7.abrupt(\"return\");\n\n            case 14:\n              _context7.next = 16;\n              return buf;\n\n            case 16:\n              _iteratorAbruptCompletion = false;\n              _context7.next = 5;\n              break;\n\n            case 19:\n              _context7.next = 25;\n              break;\n\n            case 21:\n              _context7.prev = 21;\n              _context7.t0 = _context7[\"catch\"](3);\n              _didIteratorError = true;\n              _iteratorError = _context7.t0;\n\n            case 25:\n              _context7.prev = 25;\n              _context7.prev = 26;\n\n              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                _context7.next = 30;\n                break;\n              }\n\n              _context7.next = 30;\n              return _awaitAsyncGenerator(_iterator.return());\n\n            case 30:\n              _context7.prev = 30;\n\n              if (!_didIteratorError) {\n                _context7.next = 33;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 33:\n              return _context7.finish(30);\n\n            case 34:\n              return _context7.finish(25);\n\n            case 35:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7, null, [[3, 21, 25, 35], [26,, 30, 34]]);\n    }));\n\n    function _limitAsyncStreamBytes() {\n      return _limitAsyncStreamBytes2.apply(this, arguments);\n    }\n\n    return _limitAsyncStreamBytes;\n  }();\n};\n/**\n * @param {number} count\n * @param {number} chunkSize\n */\n\n\nvar asyncZeroes = function asyncZeroes(count) {\n  var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MFS_MAX_CHUNK_SIZE;\n  var buf = new Uint8Array(chunkSize);\n\n  function _asyncZeroes() {\n    return _asyncZeroes2.apply(this, arguments);\n  }\n\n  function _asyncZeroes2() {\n    _asyncZeroes2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n      return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!true) {\n                _context8.next = 5;\n                break;\n              }\n\n              _context8.next = 3;\n              return buf.slice();\n\n            case 3:\n              _context8.next = 0;\n              break;\n\n            case 5:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n    return _asyncZeroes2.apply(this, arguments);\n  }\n\n  return limitAsyncStreamBytes(_asyncZeroes(), count);\n};\n/**\n * @param {Array<() => AsyncIterable<Uint8Array>>} sources\n */\n\n\nvar catAsyncIterators = /*#__PURE__*/function () {\n  var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(sources) {\n    var i;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < sources.length)) {\n              _context9.next = 6;\n              break;\n            }\n\n            return _context9.delegateYield(_asyncGeneratorDelegate(_asyncIterator(sources[i]()), _awaitAsyncGenerator), \"t0\", 3);\n\n          case 3:\n            i++;\n            _context9.next = 1;\n            break;\n\n          case 6:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n\n  return function catAsyncIterators(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * @param {AsyncIterable<Uint8Array>} source\n * @param {(count: number) => AsyncIterable<Uint8Array>} notify\n */\n\n\nvar countBytesStreamed = /*#__PURE__*/function () {\n  var _ref3 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(source, notify) {\n    var wrote, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, buf, _iteratorAbruptCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _buf;\n\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            wrote = 0;\n            _iteratorAbruptCompletion2 = false;\n            _didIteratorError2 = false;\n            _context10.prev = 3;\n            _iterator2 = _asyncIterator(source);\n\n          case 5:\n            _context10.next = 7;\n            return _awaitAsyncGenerator(_iterator2.next());\n\n          case 7:\n            if (!(_iteratorAbruptCompletion2 = !(_step2 = _context10.sent).done)) {\n              _context10.next = 15;\n              break;\n            }\n\n            buf = _step2.value;\n            wrote += buf.length;\n            _context10.next = 12;\n            return buf;\n\n          case 12:\n            _iteratorAbruptCompletion2 = false;\n            _context10.next = 5;\n            break;\n\n          case 15:\n            _context10.next = 21;\n            break;\n\n          case 17:\n            _context10.prev = 17;\n            _context10.t0 = _context10[\"catch\"](3);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context10.t0;\n\n          case 21:\n            _context10.prev = 21;\n            _context10.prev = 22;\n\n            if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n              _context10.next = 26;\n              break;\n            }\n\n            _context10.next = 26;\n            return _awaitAsyncGenerator(_iterator2.return());\n\n          case 26:\n            _context10.prev = 26;\n\n            if (!_didIteratorError2) {\n              _context10.next = 29;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 29:\n            return _context10.finish(26);\n\n          case 30:\n            return _context10.finish(21);\n\n          case 31:\n            _iteratorAbruptCompletion3 = false;\n            _didIteratorError3 = false;\n            _context10.prev = 33;\n            _iterator3 = _asyncIterator(notify(wrote));\n\n          case 35:\n            _context10.next = 37;\n            return _awaitAsyncGenerator(_iterator3.next());\n\n          case 37:\n            if (!(_iteratorAbruptCompletion3 = !(_step3 = _context10.sent).done)) {\n              _context10.next = 45;\n              break;\n            }\n\n            _buf = _step3.value;\n            wrote += _buf.length;\n            _context10.next = 42;\n            return _buf;\n\n          case 42:\n            _iteratorAbruptCompletion3 = false;\n            _context10.next = 35;\n            break;\n\n          case 45:\n            _context10.next = 51;\n            break;\n\n          case 47:\n            _context10.prev = 47;\n            _context10.t1 = _context10[\"catch\"](33);\n            _didIteratorError3 = true;\n            _iteratorError3 = _context10.t1;\n\n          case 51:\n            _context10.prev = 51;\n            _context10.prev = 52;\n\n            if (!(_iteratorAbruptCompletion3 && _iterator3.return != null)) {\n              _context10.next = 56;\n              break;\n            }\n\n            _context10.next = 56;\n            return _awaitAsyncGenerator(_iterator3.return());\n\n          case 56:\n            _context10.prev = 56;\n\n            if (!_didIteratorError3) {\n              _context10.next = 59;\n              break;\n            }\n\n            throw _iteratorError3;\n\n          case 59:\n            return _context10.finish(56);\n\n          case 60:\n            return _context10.finish(51);\n\n          case 61:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10, null, [[3, 17, 21, 31], [22,, 26, 30], [33, 47, 51, 61], [52,, 56, 60]]);\n  }));\n\n  return function countBytesStreamed(_x2, _x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["log","require","importer","decode","sha256","sha512","stat","mkdir","addLink","mergeOptions","bind","ignoreUndefined","createLock","toAsyncIterator","toMfsPath","toPathComponents","toTrail","updateTree","updateMfsRoot","errCode","MFS_MAX_CHUNK_SIZE","last","withTimeoutOption","parseMode","parseMtime","defaultOptions","offset","length","Infinity","create","truncate","rawLeaves","reduceSingleLeafToSelf","cidVersion","hashAlg","parents","progress","bytes","path","strategy","flush","leafType","shardSplitThreshold","module","exports","context","mfsWrite","content","opts","options","readLock","source","destination","mfsDirectory","parent","exists","Error","entryType","updateOrImport","write","child","writeLock","pathComponents","fileName","pop","parentExists","join","code","updatedPath","trail","type","includes","name","repo","blocks","get","cid","parentBlock","parentNode","size","result","newRootCid","sources","unixfs","push","fileSize","extra","asyncZeroes","limitAsyncStreamBytes","countBytesStreamed","catAsyncIterators","bytesWritten","Symbol","asyncIterator","mode","undefined","mtime","hasher","stream","limit","emitted","buf","slice","_limitAsyncStreamBytes","count","chunkSize","Uint8Array","_asyncZeroes","i","notify","wrote"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/files/write.js"],"sourcesContent":["'use strict'\n\nconst log = require('debug')('ipfs:mfs:write')\nconst { importer } = require('ipfs-unixfs-importer')\nconst {\n  decode\n// @ts-ignore - TODO vmx 2021-03-31\n} = require('@ipld/dag-pb')\nconst { sha256, sha512 } = require('multiformats/hashes/sha2')\nconst stat = require('./stat')\nconst mkdir = require('./mkdir')\nconst addLink = require('./utils/add-link')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst createLock = require('./utils/create-lock')\nconst toAsyncIterator = require('./utils/to-async-iterator')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst toPathComponents = require('./utils/to-path-components')\nconst toTrail = require('./utils/to-trail')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst errCode = require('err-code')\nconst {\n  MFS_MAX_CHUNK_SIZE\n} = require('../../utils')\nconst last = require('it-last')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst {\n  parseMode,\n  parseMtime\n} = require('ipfs-unixfs')\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('ipfs-unixfs').MtimeLike} MtimeLike\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {import('./utils/to-mfs-path').FilePath} FilePath\n * @typedef {import('./utils/to-mfs-path').MfsPath} MfsPath\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n *\n * @typedef {object} DefaultOptions\n * @property {number} offset\n * @property {number} length\n * @property {boolean} create\n * @property {boolean} truncate\n * @property {boolean} rawLeaves\n * @property {boolean} reduceSingleLeafToSelf\n * @property {CIDVersion} cidVersion\n * @property {string} hashAlg\n * @property {boolean} parents\n * @property {import('ipfs-core-types/src/root').AddProgressFn} progress\n * @property {'trickle' | 'balanced'} strategy\n * @property {boolean} flush\n * @property {'raw' | 'file'} leafType\n * @property {number} shardSplitThreshold\n * @property {MtimeLike} [mtime]\n * @property {number} [mode]\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  offset: 0, // the offset in the file to begin writing\n  length: Infinity, // how many bytes from the incoming buffer to write\n  create: false, // whether to create the file if it does not exist\n  truncate: false, // whether to truncate the file first\n  rawLeaves: false,\n  reduceSingleLeafToSelf: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  parents: false, // whether to create intermediate directories if they do not exist\n  progress: (bytes, path) => {},\n  strategy: 'trickle',\n  flush: true,\n  leafType: 'raw',\n  shardSplitThreshold: 1000\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"write\"]}\n   */\n  async function mfsWrite (path, content, opts = {}) {\n    /** @type {DefaultOptions} */\n    const options = mergeOptions(defaultOptions, opts)\n\n    /** @type {AsyncIterable<Uint8Array>} */\n    let source\n    /** @type {MfsPath} */\n    let destination\n    /** @type {MfsPath} */\n    let parent\n    log('Reading source, destination and parent')\n    await createLock().readLock(async () => {\n      source = await toAsyncIterator(content)\n      destination = await toMfsPath(context, path, options)\n      parent = await toMfsPath(context, destination.mfsDirectory, options)\n    })()\n    log('Read source, destination and parent')\n    // @ts-ignore - parent may be undefined\n    if (!options.parents && !parent.exists) {\n      throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST')\n    }\n\n    // @ts-ignore\n    if (source == null) {\n      throw errCode(new Error('could not create source'), 'ERR_NO_SOURCE')\n    }\n\n    // @ts-ignore\n    if (destination == null) {\n      throw errCode(new Error('could not create destination'), 'ERR_NO_DESTINATION')\n    }\n\n    if (!options.create && !destination.exists) {\n      throw errCode(new Error('file does not exist'), 'ERR_NO_EXIST')\n    }\n\n    if (destination.entryType !== 'file') {\n      throw errCode(new Error('not a file'), 'ERR_NOT_A_FILE')\n    }\n\n    return updateOrImport(context, path, source, destination, options)\n  }\n\n  return withTimeoutOption(mfsWrite)\n}\n\n/**\n * @param {MfsContext} context\n * @param {string} path\n * @param {AsyncIterable<Uint8Array>} source\n * @param {FilePath} destination\n * @param {DefaultOptions} options\n */\nconst updateOrImport = async (context, path, source, destination, options) => {\n  const child = await write(context, source, destination, options)\n\n  // The slow bit is done, now add or replace the DAGLink in the containing directory\n  // re-reading the path to the containing folder in case it has changed in the interim\n  await createLock().writeLock(async () => {\n    const pathComponents = toPathComponents(path)\n    const fileName = pathComponents.pop()\n\n    if (fileName == null) {\n      throw errCode(new Error('source does not exist'), 'ERR_NO_EXIST')\n    }\n\n    let parentExists = false\n\n    try {\n      await stat(context)(`/${pathComponents.join('/')}`, options)\n      parentExists = true\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err\n      }\n    }\n\n    if (!parentExists) {\n      await mkdir(context)(`/${pathComponents.join('/')}`, options)\n    }\n\n    // get an updated mfs path in case the root changed while we were writing\n    const updatedPath = await toMfsPath(context, path, options)\n    const trail = await toTrail(context, updatedPath.mfsDirectory)\n    const parent = trail[trail.length - 1]\n\n    if (!parent) {\n      throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST')\n    }\n\n    if (!parent.type || !parent.type.includes('directory')) {\n      throw errCode(new Error(`cannot write to ${parent.name}: Not a directory`), 'ERR_NOT_A_DIRECTORY')\n    }\n\n    const parentBlock = await context.repo.blocks.get(parent.cid)\n    const parentNode = decode(parentBlock)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: fileName,\n      cid: child.cid,\n      size: child.size,\n      flush: options.flush,\n      shardSplitThreshold: options.shardSplitThreshold,\n      hashAlg: options.hashAlg,\n      cidVersion: options.cidVersion\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, options)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, options)\n  })()\n}\n\n/**\n * @param {MfsContext} context\n * @param {AsyncIterable<Uint8Array>} source\n * @param {FilePath} destination\n * @param {DefaultOptions} options\n */\nconst write = async (context, source, destination, options) => {\n  if (destination.exists) {\n    log(`Overwriting file ${destination.cid} offset ${options.offset} length ${options.length}`)\n  } else {\n    log(`Writing file offset ${options.offset} length ${options.length}`)\n  }\n\n  /** @type {Array<() => AsyncIterable<Uint8Array>>} */\n  const sources = []\n\n  // pad start of file if necessary\n  if (options.offset > 0) {\n    if (destination.unixfs) {\n      log(`Writing first ${options.offset} bytes of original file`)\n\n      sources.push(\n        () => {\n          return destination.content({\n            offset: 0,\n            length: options.offset\n          })\n        }\n      )\n\n      if (destination.unixfs.fileSize() < options.offset) {\n        const extra = options.offset - destination.unixfs.fileSize()\n\n        log(`Writing zeros for extra ${extra} bytes`)\n        sources.push(\n          asyncZeroes(extra)\n        )\n      }\n    } else {\n      log(`Writing zeros for first ${options.offset} bytes`)\n      sources.push(\n        asyncZeroes(options.offset)\n      )\n    }\n  }\n\n  sources.push(\n    limitAsyncStreamBytes(source, options.length)\n  )\n\n  const content = countBytesStreamed(catAsyncIterators(sources), (bytesWritten) => {\n    if (destination.unixfs && !options.truncate) {\n      // if we've done reading from the new source and we are not going\n      // to truncate the file, add the end of the existing file to the output\n      const fileSize = destination.unixfs.fileSize()\n\n      if (fileSize > bytesWritten) {\n        log(`Writing last ${fileSize - bytesWritten} of ${fileSize} bytes from original file starting at offset ${bytesWritten}`)\n\n        return destination.content({\n          offset: bytesWritten\n        })\n      } else {\n        log('Not writing last bytes from original file')\n      }\n    }\n\n    return {\n      [Symbol.asyncIterator]: async function * () {}\n    }\n  })\n\n  /** @type {number | undefined} */\n  let mode\n\n  if (options.mode !== undefined && options.mode !== null) {\n    mode = parseMode(options.mode)\n  } else if (destination && destination.unixfs) {\n    mode = destination.unixfs.mode\n  }\n\n  /** @type {import('ipfs-unixfs').Mtime | undefined} */\n  let mtime\n\n  if (options.mtime != null) {\n    mtime = parseMtime(options.mtime)\n  } else if (destination && destination.unixfs) {\n    mtime = destination.unixfs.mtime\n  }\n\n  let hasher\n  switch (options.hashAlg) {\n    case 'sha2-256':\n      hasher = sha256\n      break\n    case 'sha2-512':\n      hasher = sha512\n      break\n    default:\n      throw new Error(`TODO vmx 2021-03-31: Proper error message for unsupported hash algorithms like ${options.hashAlg}`)\n  }\n\n  const result = await last(importer([{\n    content: content,\n\n    // persist mode & mtime if set previously\n    mode,\n    mtime\n  }], context.repo.blocks, {\n    progress: options.progress,\n    hasher,\n    cidVersion: options.cidVersion,\n    strategy: options.strategy,\n    rawLeaves: options.rawLeaves,\n    reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,\n    leafType: options.leafType\n  }))\n\n  if (!result) {\n    throw errCode(new Error(`cannot write to ${parent.name}`), 'ERR_COULD_NOT_WRITE')\n  }\n\n  log(`Wrote ${result.cid}`)\n\n  return {\n    cid: result.cid,\n    size: result.size\n  }\n}\n\n/**\n * @param {AsyncIterable<Uint8Array>} stream\n * @param {number} limit\n */\nconst limitAsyncStreamBytes = (stream, limit) => {\n  return async function * _limitAsyncStreamBytes () {\n    let emitted = 0\n\n    for await (const buf of stream) {\n      emitted += buf.length\n\n      if (emitted > limit) {\n        yield buf.slice(0, limit - emitted)\n\n        return\n      }\n\n      yield buf\n    }\n  }\n}\n\n/**\n * @param {number} count\n * @param {number} chunkSize\n */\nconst asyncZeroes = (count, chunkSize = MFS_MAX_CHUNK_SIZE) => {\n  const buf = new Uint8Array(chunkSize)\n\n  async function * _asyncZeroes () {\n    while (true) {\n      yield buf.slice()\n    }\n  }\n\n  return limitAsyncStreamBytes(_asyncZeroes(), count)\n}\n\n/**\n * @param {Array<() => AsyncIterable<Uint8Array>>} sources\n */\nconst catAsyncIterators = async function * (sources) { // eslint-disable-line require-await\n  for (let i = 0; i < sources.length; i++) {\n    yield * sources[i]()\n  }\n}\n\n/**\n * @param {AsyncIterable<Uint8Array>} source\n * @param {(count: number) => AsyncIterable<Uint8Array>} notify\n */\nconst countBytesStreamed = async function * (source, notify) {\n  let wrote = 0\n\n  for await (const buf of source) {\n    wrote += buf.length\n\n    yield buf\n  }\n\n  for await (const buf of notify(wrote)) {\n    wrote += buf.length\n\n    yield buf\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}