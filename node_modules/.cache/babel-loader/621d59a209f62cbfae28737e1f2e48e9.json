{"ast":null,"code":"'use strict';\n\nconst {\n  default: Queue\n} = require('p-queue');\n/**\n * @typedef {import('peer-id')} PeerId\n */\n\n\nclass WorkerQueue {\n  /**\n   * Creates a new WorkerQueue.\n   *\n   * @param {import('../index')} dht\n   * @param {import('./run')} run\n   * @param {import('./path')} path\n   * @param {Function & {error: Function}} log\n   */\n  constructor(dht, run, path, log) {\n    this.dht = dht;\n    this.run = run;\n    this.path = path;\n    this.log = log;\n    this.concurrency = this.dht.concurrency;\n    this.queue = this.setupQueue(); // a container for resolve/reject functions that will be populated\n    // when execute() is called\n\n    /** @type {{ resolve: (result?: any) => void, reject: (err: Error) => void} | null} */\n\n    this.execution = null;\n    /** @type {Set<PeerId>} */\n\n    this.queuedPeerIds = new Set();\n  }\n  /**\n   * Create the underlying async queue.\n   *\n   * @returns {Queue}\n   */\n\n\n  setupQueue() {\n    const q = new Queue({\n      concurrency: this.concurrency\n    }); // When all peers in the queue have been processed, stop the worker\n\n    q.on('idle', () => {\n      if (this.path.peersToQuery && !this.path.peersToQuery.length) {\n        this.log('queue:drain');\n        this.stop();\n      }\n    }); // When a space opens up in the queue, add some more peers\n\n    q.on('next', () => {\n      if (!this.running) {\n        return;\n      }\n\n      if (q.pending < this.concurrency) {\n        this.fill();\n      }\n    });\n    return q;\n  }\n  /**\n   * Stop the worker, optionally providing an error to pass to the worker's\n   * callback.\n   *\n   * @param {Error} [err]\n   */\n\n\n  stop(err) {\n    if (!this.running) {\n      return;\n    }\n\n    this.running = false;\n    this.queue.clear();\n    this.log('worker:stop, %d workers still running', this.run.workers.filter(w => w.running).length);\n\n    if (this.execution) {\n      if (err) {\n        this.execution.reject(err);\n      } else {\n        this.execution.resolve();\n      }\n    }\n  }\n  /**\n   * Use the queue from async to keep `concurrency` amount items running\n   * per path.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async execute() {\n    this.running = true; // store the promise resolution functions to be resolved at end of queue\n\n    this.execution = null;\n    const execPromise = new Promise((resolve, reject) => {\n      this.execution = {\n        resolve,\n        reject\n      };\n    }); // start queue\n\n    this.fill(); // await completion\n\n    await execPromise;\n  }\n  /**\n   * Add peers to the worker queue until there are enough to satisfy the\n   * worker queue concurrency.\n   * Note that we don't want to take any more than those required to satisfy\n   * concurrency from the peers-to-query queue, because we always want to\n   * query the closest peers to the key first, and new peers are continuously\n   * being added to the peers-to-query queue.\n   */\n\n\n  fill() {\n    if (!this.path.peersToQuery) {\n      return;\n    } // Note:\n    // - queue.pending: number of items that are currently running\n    // - queue.size: the number of items that are waiting to be run\n\n\n    while (this.queue.pending + this.queue.size < this.concurrency && this.path.peersToQuery.length > 0) {\n      const peer = this.path.peersToQuery.dequeue(); // store the peer id so we can potentially abort early\n\n      this.queuedPeerIds.add(peer);\n      this.queue.add(() => {\n        return this.processNext(peer).catch(err => {\n          this.log.error('queue', err);\n          this.stop(err);\n        }).finally(() => {\n          this.queuedPeerIds.delete(peer);\n        });\n      });\n    }\n  }\n  /**\n   * Process the next peer in the queue\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async processNext(peer) {\n    if (!this.running) {\n      return;\n    } // The paths must be disjoint, meaning that no two paths in the Query may\n    // traverse the same peer\n\n\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return;\n    } // Check if we've queried enough peers already\n\n\n    let continueQuerying, continueQueryingError;\n\n    try {\n      continueQuerying = await this.run.continueQuerying(this);\n    } catch (err) {\n      continueQueryingError = err;\n    } // Abort and ignore any error if we're no longer running\n\n\n    if (!this.running) {\n      return;\n    }\n\n    if (continueQueryingError) {\n      throw continueQueryingError;\n    } // No peer we're querying is closer, stop the queue\n    // This will cause queries that may potentially result in\n    // closer nodes to be ended, but it reduces overall query time\n\n\n    if (!continueQuerying) {\n      this.stop();\n      return;\n    } // Check if another path has queried this peer in the mean time\n\n\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return;\n    }\n\n    this.run.peersSeen.add(peer.toB58String()); // Execute the query on the next peer\n\n    this.log('queue:work');\n    let state, execError;\n\n    try {\n      state = await this.execQuery(peer);\n    } catch (err) {\n      execError = err;\n    } // Abort and ignore any error if we're no longer running\n\n\n    if (!this.running) {\n      return;\n    }\n\n    this.log('queue:work:done', execError, state);\n\n    if (execError) {\n      throw execError;\n    } // If query is complete, stop all workers.\n    // Note: run.stop() calls stop() on all the workers, which kills the\n    // queue and resolves execution\n\n\n    if (state && state.queryComplete) {\n      this.log('query:complete');\n      this.run.stop();\n      return;\n    } // If path is complete, just stop this worker.\n    // Note: this.stop() kills the queue and resolves execution\n\n\n    if (state && state.pathComplete) {\n      this.stop();\n    }\n  }\n  /**\n   * Execute a query on the next peer.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async execQuery(peer) {\n    let res, queryError;\n\n    try {\n      res = await this.path.queryFunc(peer);\n    } catch (err) {\n      queryError = err;\n    } // Abort and ignore any error if we're no longer running\n\n\n    if (!this.running) {\n      return;\n    }\n\n    if (queryError) {\n      this.run.errors.push(queryError);\n      return;\n    } // Add the peer to the closest peers we have successfully queried\n\n\n    this.run.peersQueried && (await this.run.peersQueried.add(peer));\n\n    if (!res) {\n      return;\n    } // If the query indicates that this path or the whole query is complete\n    // set the path result and bail out\n\n\n    if (res.pathComplete || res.queryComplete) {\n      this.path.res = res;\n      return {\n        pathComplete: res.pathComplete,\n        queryComplete: res.queryComplete\n      };\n    } // If there are closer peers to query, add them to the queue\n\n\n    if (res.closerPeers && res.closerPeers.length > 0) {\n      /**\n       * @param {import('../').PeerData} closer\n       */\n      const queryCloser = async closer => {\n        // don't add ourselves\n        if (this.dht._isSelf(closer.id)) {\n          return;\n        }\n\n        this.dht._peerDiscovered(closer.id, closer.multiaddrs);\n\n        await this.path.addPeerToQuery(closer.id);\n      };\n\n      await Promise.all(res.closerPeers.map(queryCloser));\n    }\n  }\n\n}\n\nmodule.exports = WorkerQueue;","map":{"version":3,"names":["default","Queue","require","WorkerQueue","constructor","dht","run","path","log","concurrency","queue","setupQueue","execution","queuedPeerIds","Set","q","on","peersToQuery","length","stop","running","pending","fill","err","clear","workers","filter","w","reject","resolve","execute","execPromise","Promise","size","peer","dequeue","add","processNext","catch","error","finally","delete","peersSeen","has","toB58String","continueQuerying","continueQueryingError","state","execError","execQuery","queryComplete","pathComplete","res","queryError","queryFunc","errors","push","peersQueried","closerPeers","queryCloser","closer","_isSelf","id","_peerDiscovered","multiaddrs","addPeerToQuery","all","map","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-kad-dht/src/query/worker-queue.js"],"sourcesContent":["'use strict'\n\nconst { default: Queue } = require('p-queue')\n\n/**\n * @typedef {import('peer-id')} PeerId\n */\n\nclass WorkerQueue {\n  /**\n   * Creates a new WorkerQueue.\n   *\n   * @param {import('../index')} dht\n   * @param {import('./run')} run\n   * @param {import('./path')} path\n   * @param {Function & {error: Function}} log\n   */\n  constructor (dht, run, path, log) {\n    this.dht = dht\n    this.run = run\n    this.path = path\n    this.log = log\n\n    this.concurrency = this.dht.concurrency\n    this.queue = this.setupQueue()\n    // a container for resolve/reject functions that will be populated\n    // when execute() is called\n\n    /** @type {{ resolve: (result?: any) => void, reject: (err: Error) => void} | null} */\n    this.execution = null\n\n    /** @type {Set<PeerId>} */\n    this.queuedPeerIds = new Set()\n  }\n\n  /**\n   * Create the underlying async queue.\n   *\n   * @returns {Queue}\n   */\n  setupQueue () {\n    const q = new Queue({\n      concurrency: this.concurrency\n    })\n\n    // When all peers in the queue have been processed, stop the worker\n    q.on('idle', () => {\n      if (this.path.peersToQuery && !this.path.peersToQuery.length) {\n        this.log('queue:drain')\n        this.stop()\n      }\n    })\n\n    // When a space opens up in the queue, add some more peers\n    q.on('next', () => {\n      if (!this.running) {\n        return\n      }\n\n      if (q.pending < this.concurrency) {\n        this.fill()\n      }\n    })\n\n    return q\n  }\n\n  /**\n   * Stop the worker, optionally providing an error to pass to the worker's\n   * callback.\n   *\n   * @param {Error} [err]\n   */\n  stop (err) {\n    if (!this.running) {\n      return\n    }\n\n    this.running = false\n    this.queue.clear()\n    this.log('worker:stop, %d workers still running', this.run.workers.filter(w => w.running).length)\n\n    if (this.execution) {\n      if (err) {\n        this.execution.reject(err)\n      } else {\n        this.execution.resolve()\n      }\n    }\n  }\n\n  /**\n   * Use the queue from async to keep `concurrency` amount items running\n   * per path.\n   *\n   * @returns {Promise<void>}\n   */\n  async execute () {\n    this.running = true\n    // store the promise resolution functions to be resolved at end of queue\n    this.execution = null\n    const execPromise = new Promise((resolve, reject) => {\n      this.execution = {\n        resolve, reject\n      }\n    })\n    // start queue\n    this.fill()\n    // await completion\n    await execPromise\n  }\n\n  /**\n   * Add peers to the worker queue until there are enough to satisfy the\n   * worker queue concurrency.\n   * Note that we don't want to take any more than those required to satisfy\n   * concurrency from the peers-to-query queue, because we always want to\n   * query the closest peers to the key first, and new peers are continuously\n   * being added to the peers-to-query queue.\n   */\n  fill () {\n    if (!this.path.peersToQuery) {\n      return\n    }\n\n    // Note:\n    // - queue.pending: number of items that are currently running\n    // - queue.size: the number of items that are waiting to be run\n    while (this.queue.pending + this.queue.size < this.concurrency && this.path.peersToQuery.length > 0) {\n      const peer = this.path.peersToQuery.dequeue()\n\n      // store the peer id so we can potentially abort early\n      this.queuedPeerIds.add(peer)\n\n      this.queue.add(\n        () => {\n          return this.processNext(peer)\n            .catch(err => {\n              this.log.error('queue', err)\n              this.stop(err)\n            })\n            .finally(() => {\n              this.queuedPeerIds.delete(peer)\n            })\n        }\n      )\n    }\n  }\n\n  /**\n   * Process the next peer in the queue\n   *\n   * @param {PeerId} peer\n   */\n  async processNext (peer) {\n    if (!this.running) {\n      return\n    }\n\n    // The paths must be disjoint, meaning that no two paths in the Query may\n    // traverse the same peer\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return\n    }\n\n    // Check if we've queried enough peers already\n    let continueQuerying, continueQueryingError\n    try {\n      continueQuerying = await this.run.continueQuerying(this)\n    } catch (err) {\n      continueQueryingError = err\n    }\n\n    // Abort and ignore any error if we're no longer running\n    if (!this.running) {\n      return\n    }\n\n    if (continueQueryingError) {\n      throw continueQueryingError\n    }\n\n    // No peer we're querying is closer, stop the queue\n    // This will cause queries that may potentially result in\n    // closer nodes to be ended, but it reduces overall query time\n    if (!continueQuerying) {\n      this.stop()\n      return\n    }\n\n    // Check if another path has queried this peer in the mean time\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return\n    }\n    this.run.peersSeen.add(peer.toB58String())\n\n    // Execute the query on the next peer\n    this.log('queue:work')\n    let state, execError\n    try {\n      state = await this.execQuery(peer)\n    } catch (err) {\n      execError = err\n    }\n\n    // Abort and ignore any error if we're no longer running\n    if (!this.running) {\n      return\n    }\n\n    this.log('queue:work:done', execError, state)\n\n    if (execError) {\n      throw execError\n    }\n\n    // If query is complete, stop all workers.\n    // Note: run.stop() calls stop() on all the workers, which kills the\n    // queue and resolves execution\n    if (state && state.queryComplete) {\n      this.log('query:complete')\n      this.run.stop()\n      return\n    }\n\n    // If path is complete, just stop this worker.\n    // Note: this.stop() kills the queue and resolves execution\n    if (state && state.pathComplete) {\n      this.stop()\n    }\n  }\n\n  /**\n   * Execute a query on the next peer.\n   *\n   * @param {PeerId} peer\n   */\n  async execQuery (peer) {\n    let res, queryError\n    try {\n      res = await this.path.queryFunc(peer)\n    } catch (err) {\n      queryError = err\n    }\n\n    // Abort and ignore any error if we're no longer running\n    if (!this.running) {\n      return\n    }\n\n    if (queryError) {\n      this.run.errors.push(queryError)\n      return\n    }\n\n    // Add the peer to the closest peers we have successfully queried\n    this.run.peersQueried && await this.run.peersQueried.add(peer)\n\n    if (!res) {\n      return\n    }\n\n    // If the query indicates that this path or the whole query is complete\n    // set the path result and bail out\n    if (res.pathComplete || res.queryComplete) {\n      this.path.res = res\n\n      return {\n        pathComplete: res.pathComplete,\n        queryComplete: res.queryComplete\n      }\n    }\n\n    // If there are closer peers to query, add them to the queue\n    if (res.closerPeers && res.closerPeers.length > 0) {\n      /**\n       * @param {import('../').PeerData} closer\n       */\n      const queryCloser = async (closer) => {\n        // don't add ourselves\n        if (this.dht._isSelf(closer.id)) {\n          return\n        }\n\n        this.dht._peerDiscovered(closer.id, closer.multiaddrs)\n        await this.path.addPeerToQuery(closer.id)\n      }\n\n      await Promise.all(res.closerPeers.map(queryCloser))\n    }\n  }\n}\n\nmodule.exports = WorkerQueue\n"],"mappings":"AAAA;;AAEA,MAAM;EAAEA,OAAO,EAAEC;AAAX,IAAqBC,OAAO,CAAC,SAAD,CAAlC;AAEA;AACA;AACA;;;AAEA,MAAMC,WAAN,CAAkB;EAChB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAW,CAAEC,GAAF,EAAOC,GAAP,EAAYC,IAAZ,EAAkBC,GAAlB,EAAuB;IAChC,KAAKH,GAAL,GAAWA,GAAX;IACA,KAAKC,GAAL,GAAWA,GAAX;IACA,KAAKC,IAAL,GAAYA,IAAZ;IACA,KAAKC,GAAL,GAAWA,GAAX;IAEA,KAAKC,WAAL,GAAmB,KAAKJ,GAAL,CAASI,WAA5B;IACA,KAAKC,KAAL,GAAa,KAAKC,UAAL,EAAb,CAPgC,CAQhC;IACA;;IAEA;;IACA,KAAKC,SAAL,GAAiB,IAAjB;IAEA;;IACA,KAAKC,aAAL,GAAqB,IAAIC,GAAJ,EAArB;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEH,UAAU,GAAI;IACZ,MAAMI,CAAC,GAAG,IAAId,KAAJ,CAAU;MAClBQ,WAAW,EAAE,KAAKA;IADA,CAAV,CAAV,CADY,CAKZ;;IACAM,CAAC,CAACC,EAAF,CAAK,MAAL,EAAa,MAAM;MACjB,IAAI,KAAKT,IAAL,CAAUU,YAAV,IAA0B,CAAC,KAAKV,IAAL,CAAUU,YAAV,CAAuBC,MAAtD,EAA8D;QAC5D,KAAKV,GAAL,CAAS,aAAT;QACA,KAAKW,IAAL;MACD;IACF,CALD,EANY,CAaZ;;IACAJ,CAAC,CAACC,EAAF,CAAK,MAAL,EAAa,MAAM;MACjB,IAAI,CAAC,KAAKI,OAAV,EAAmB;QACjB;MACD;;MAED,IAAIL,CAAC,CAACM,OAAF,GAAY,KAAKZ,WAArB,EAAkC;QAChC,KAAKa,IAAL;MACD;IACF,CARD;IAUA,OAAOP,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEI,IAAI,CAAEI,GAAF,EAAO;IACT,IAAI,CAAC,KAAKH,OAAV,EAAmB;MACjB;IACD;;IAED,KAAKA,OAAL,GAAe,KAAf;IACA,KAAKV,KAAL,CAAWc,KAAX;IACA,KAAKhB,GAAL,CAAS,uCAAT,EAAkD,KAAKF,GAAL,CAASmB,OAAT,CAAiBC,MAAjB,CAAwBC,CAAC,IAAIA,CAAC,CAACP,OAA/B,EAAwCF,MAA1F;;IAEA,IAAI,KAAKN,SAAT,EAAoB;MAClB,IAAIW,GAAJ,EAAS;QACP,KAAKX,SAAL,CAAegB,MAAf,CAAsBL,GAAtB;MACD,CAFD,MAEO;QACL,KAAKX,SAAL,CAAeiB,OAAf;MACD;IACF;EACF;EAED;AACF;AACA;AACA;AACA;AACA;;;EACe,MAAPC,OAAO,GAAI;IACf,KAAKV,OAAL,GAAe,IAAf,CADe,CAEf;;IACA,KAAKR,SAAL,GAAiB,IAAjB;IACA,MAAMmB,WAAW,GAAG,IAAIC,OAAJ,CAAY,CAACH,OAAD,EAAUD,MAAV,KAAqB;MACnD,KAAKhB,SAAL,GAAiB;QACfiB,OADe;QACND;MADM,CAAjB;IAGD,CAJmB,CAApB,CAJe,CASf;;IACA,KAAKN,IAAL,GAVe,CAWf;;IACA,MAAMS,WAAN;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACET,IAAI,GAAI;IACN,IAAI,CAAC,KAAKf,IAAL,CAAUU,YAAf,EAA6B;MAC3B;IACD,CAHK,CAKN;IACA;IACA;;;IACA,OAAO,KAAKP,KAAL,CAAWW,OAAX,GAAqB,KAAKX,KAAL,CAAWuB,IAAhC,GAAuC,KAAKxB,WAA5C,IAA2D,KAAKF,IAAL,CAAUU,YAAV,CAAuBC,MAAvB,GAAgC,CAAlG,EAAqG;MACnG,MAAMgB,IAAI,GAAG,KAAK3B,IAAL,CAAUU,YAAV,CAAuBkB,OAAvB,EAAb,CADmG,CAGnG;;MACA,KAAKtB,aAAL,CAAmBuB,GAAnB,CAAuBF,IAAvB;MAEA,KAAKxB,KAAL,CAAW0B,GAAX,CACE,MAAM;QACJ,OAAO,KAAKC,WAAL,CAAiBH,IAAjB,EACJI,KADI,CACEf,GAAG,IAAI;UACZ,KAAKf,GAAL,CAAS+B,KAAT,CAAe,OAAf,EAAwBhB,GAAxB;UACA,KAAKJ,IAAL,CAAUI,GAAV;QACD,CAJI,EAKJiB,OALI,CAKI,MAAM;UACb,KAAK3B,aAAL,CAAmB4B,MAAnB,CAA0BP,IAA1B;QACD,CAPI,CAAP;MAQD,CAVH;IAYD;EACF;EAED;AACF;AACA;AACA;AACA;;;EACmB,MAAXG,WAAW,CAAEH,IAAF,EAAQ;IACvB,IAAI,CAAC,KAAKd,OAAV,EAAmB;MACjB;IACD,CAHsB,CAKvB;IACA;;;IACA,IAAI,KAAKd,GAAL,CAASoC,SAAT,CAAmBC,GAAnB,CAAuBT,IAAI,CAACU,WAAL,EAAvB,CAAJ,EAAgD;MAC9C;IACD,CATsB,CAWvB;;;IACA,IAAIC,gBAAJ,EAAsBC,qBAAtB;;IACA,IAAI;MACFD,gBAAgB,GAAG,MAAM,KAAKvC,GAAL,CAASuC,gBAAT,CAA0B,IAA1B,CAAzB;IACD,CAFD,CAEE,OAAOtB,GAAP,EAAY;MACZuB,qBAAqB,GAAGvB,GAAxB;IACD,CAjBsB,CAmBvB;;;IACA,IAAI,CAAC,KAAKH,OAAV,EAAmB;MACjB;IACD;;IAED,IAAI0B,qBAAJ,EAA2B;MACzB,MAAMA,qBAAN;IACD,CA1BsB,CA4BvB;IACA;IACA;;;IACA,IAAI,CAACD,gBAAL,EAAuB;MACrB,KAAK1B,IAAL;MACA;IACD,CAlCsB,CAoCvB;;;IACA,IAAI,KAAKb,GAAL,CAASoC,SAAT,CAAmBC,GAAnB,CAAuBT,IAAI,CAACU,WAAL,EAAvB,CAAJ,EAAgD;MAC9C;IACD;;IACD,KAAKtC,GAAL,CAASoC,SAAT,CAAmBN,GAAnB,CAAuBF,IAAI,CAACU,WAAL,EAAvB,EAxCuB,CA0CvB;;IACA,KAAKpC,GAAL,CAAS,YAAT;IACA,IAAIuC,KAAJ,EAAWC,SAAX;;IACA,IAAI;MACFD,KAAK,GAAG,MAAM,KAAKE,SAAL,CAAef,IAAf,CAAd;IACD,CAFD,CAEE,OAAOX,GAAP,EAAY;MACZyB,SAAS,GAAGzB,GAAZ;IACD,CAjDsB,CAmDvB;;;IACA,IAAI,CAAC,KAAKH,OAAV,EAAmB;MACjB;IACD;;IAED,KAAKZ,GAAL,CAAS,iBAAT,EAA4BwC,SAA5B,EAAuCD,KAAvC;;IAEA,IAAIC,SAAJ,EAAe;MACb,MAAMA,SAAN;IACD,CA5DsB,CA8DvB;IACA;IACA;;;IACA,IAAID,KAAK,IAAIA,KAAK,CAACG,aAAnB,EAAkC;MAChC,KAAK1C,GAAL,CAAS,gBAAT;MACA,KAAKF,GAAL,CAASa,IAAT;MACA;IACD,CArEsB,CAuEvB;IACA;;;IACA,IAAI4B,KAAK,IAAIA,KAAK,CAACI,YAAnB,EAAiC;MAC/B,KAAKhC,IAAL;IACD;EACF;EAED;AACF;AACA;AACA;AACA;;;EACiB,MAAT8B,SAAS,CAAEf,IAAF,EAAQ;IACrB,IAAIkB,GAAJ,EAASC,UAAT;;IACA,IAAI;MACFD,GAAG,GAAG,MAAM,KAAK7C,IAAL,CAAU+C,SAAV,CAAoBpB,IAApB,CAAZ;IACD,CAFD,CAEE,OAAOX,GAAP,EAAY;MACZ8B,UAAU,GAAG9B,GAAb;IACD,CANoB,CAQrB;;;IACA,IAAI,CAAC,KAAKH,OAAV,EAAmB;MACjB;IACD;;IAED,IAAIiC,UAAJ,EAAgB;MACd,KAAK/C,GAAL,CAASiD,MAAT,CAAgBC,IAAhB,CAAqBH,UAArB;MACA;IACD,CAhBoB,CAkBrB;;;IACA,KAAK/C,GAAL,CAASmD,YAAT,KAAyB,MAAM,KAAKnD,GAAL,CAASmD,YAAT,CAAsBrB,GAAtB,CAA0BF,IAA1B,CAA/B;;IAEA,IAAI,CAACkB,GAAL,EAAU;MACR;IACD,CAvBoB,CAyBrB;IACA;;;IACA,IAAIA,GAAG,CAACD,YAAJ,IAAoBC,GAAG,CAACF,aAA5B,EAA2C;MACzC,KAAK3C,IAAL,CAAU6C,GAAV,GAAgBA,GAAhB;MAEA,OAAO;QACLD,YAAY,EAAEC,GAAG,CAACD,YADb;QAELD,aAAa,EAAEE,GAAG,CAACF;MAFd,CAAP;IAID,CAlCoB,CAoCrB;;;IACA,IAAIE,GAAG,CAACM,WAAJ,IAAmBN,GAAG,CAACM,WAAJ,CAAgBxC,MAAhB,GAAyB,CAAhD,EAAmD;MACjD;AACN;AACA;MACM,MAAMyC,WAAW,GAAG,MAAOC,MAAP,IAAkB;QACpC;QACA,IAAI,KAAKvD,GAAL,CAASwD,OAAT,CAAiBD,MAAM,CAACE,EAAxB,CAAJ,EAAiC;UAC/B;QACD;;QAED,KAAKzD,GAAL,CAAS0D,eAAT,CAAyBH,MAAM,CAACE,EAAhC,EAAoCF,MAAM,CAACI,UAA3C;;QACA,MAAM,KAAKzD,IAAL,CAAU0D,cAAV,CAAyBL,MAAM,CAACE,EAAhC,CAAN;MACD,CARD;;MAUA,MAAM9B,OAAO,CAACkC,GAAR,CAAYd,GAAG,CAACM,WAAJ,CAAgBS,GAAhB,CAAoBR,WAApB,CAAZ,CAAN;IACD;EACF;;AA1Re;;AA6RlBS,MAAM,CAACC,OAAP,GAAiBlE,WAAjB"},"metadata":{},"sourceType":"script"}