{"ast":null,"code":"\"use strict\";\n/*! noble-secp256k1 - MIT License (c) Paul Miller (paulmillr.com) */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.SignResult = exports.Signature = exports.Point = exports.CURVE = void 0;\nconst CURVE = {\n  a: 0n,\n  b: 7n,\n  P: 2n ** 256n - 2n ** 32n - 977n,\n  n: 2n ** 256n - 432420386565659656852420866394968145599n,\n  h: 1n,\n  Gx: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,\n  Gy: 32670510020758816978083085130507043184471273380659243275938904335757337482424n,\n  beta: 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501een\n};\nexports.CURVE = CURVE;\n\nfunction weistrass(x) {\n  const {\n    a,\n    b\n  } = CURVE;\n  return mod(x ** 3n + a * x + b);\n}\n\nconst USE_ENDOMORPHISM = CURVE.a === 0n;\n\nclass JacobianPoint {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  static fromAffine(p) {\n    if (!(p instanceof Point)) {\n      throw new TypeError('JacobianPoint#fromAffine: expected Point');\n    }\n\n    return new JacobianPoint(p.x, p.y, 1n);\n  }\n\n  static toAffineBatch(points) {\n    const toInv = invertBatch(points.map(p => p.z));\n    return points.map((p, i) => p.toAffine(toInv[i]));\n  }\n\n  static normalizeZ(points) {\n    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n  }\n\n  equals(other) {\n    const a = this;\n    const b = other;\n    const az2 = mod(a.z * a.z);\n    const az3 = mod(a.z * az2);\n    const bz2 = mod(b.z * b.z);\n    const bz3 = mod(b.z * bz2);\n    return mod(a.x * bz2) === mod(az2 * b.x) && mod(a.y * bz3) === mod(az3 * b.y);\n  }\n\n  negate() {\n    return new JacobianPoint(this.x, mod(-this.y), this.z);\n  }\n\n  double() {\n    const X1 = this.x;\n    const Y1 = this.y;\n    const Z1 = this.z;\n    const A = mod(X1 ** 2n);\n    const B = mod(Y1 ** 2n);\n    const C = mod(B ** 2n);\n    const D = mod(2n * (mod(mod((X1 + B) ** 2n)) - A - C));\n    const E = mod(3n * A);\n    const F = mod(E ** 2n);\n    const X3 = mod(F - 2n * D);\n    const Y3 = mod(E * (D - X3) - 8n * C);\n    const Z3 = mod(2n * Y1 * Z1);\n    return new JacobianPoint(X3, Y3, Z3);\n  }\n\n  add(other) {\n    if (!(other instanceof JacobianPoint)) {\n      throw new TypeError('JacobianPoint#add: expected JacobianPoint');\n    }\n\n    const X1 = this.x;\n    const Y1 = this.y;\n    const Z1 = this.z;\n    const X2 = other.x;\n    const Y2 = other.y;\n    const Z2 = other.z;\n    if (X2 === 0n || Y2 === 0n) return this;\n    if (X1 === 0n || Y1 === 0n) return other;\n    const Z1Z1 = mod(Z1 ** 2n);\n    const Z2Z2 = mod(Z2 ** 2n);\n    const U1 = mod(X1 * Z2Z2);\n    const U2 = mod(X2 * Z1Z1);\n    const S1 = mod(Y1 * Z2 * Z2Z2);\n    const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n    const H = mod(U2 - U1);\n    const r = mod(S2 - S1);\n\n    if (H === 0n) {\n      if (r === 0n) {\n        return this.double();\n      } else {\n        return JacobianPoint.ZERO;\n      }\n    }\n\n    const HH = mod(H ** 2n);\n    const HHH = mod(H * HH);\n    const V = mod(U1 * HH);\n    const X3 = mod(r ** 2n - HHH - 2n * V);\n    const Y3 = mod(r * (V - X3) - S1 * HHH);\n    const Z3 = mod(Z1 * Z2 * H);\n    return new JacobianPoint(X3, Y3, Z3);\n  }\n\n  subtract(other) {\n    return this.add(other.negate());\n  }\n\n  multiplyUnsafe(scalar) {\n    if (!isValidScalar(scalar)) throw new TypeError('Point#multiply: expected valid scalar');\n    let n = mod(BigInt(scalar), CURVE.n);\n\n    if (!USE_ENDOMORPHISM) {\n      let p = JacobianPoint.ZERO;\n      let d = this;\n\n      while (n > 0n) {\n        if (n & 1n) p = p.add(d);\n        d = d.double();\n        n >>= 1n;\n      }\n\n      return p;\n    }\n\n    let [k1neg, k1, k2neg, k2] = splitScalarEndo(n);\n    let k1p = JacobianPoint.ZERO;\n    let k2p = JacobianPoint.ZERO;\n    let d = this;\n\n    while (k1 > 0n || k2 > 0n) {\n      if (k1 & 1n) k1p = k1p.add(d);\n      if (k2 & 1n) k2p = k2p.add(d);\n      d = d.double();\n      k1 >>= 1n;\n      k2 >>= 1n;\n    }\n\n    if (k1neg) k1p = k1p.negate();\n    if (k2neg) k2p = k2p.negate();\n    k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n    return k1p.add(k2p);\n  }\n\n  precomputeWindow(W) {\n    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n    let points = [];\n    let p = this;\n    let base = p;\n\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n\n      for (let i = 1; i < 2 ** (W - 1); i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n\n      p = base.double();\n    }\n\n    return points;\n  }\n\n  wNAF(n, affinePoint) {\n    if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n\n    if (256 % W) {\n      throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n    }\n\n    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n\n    if (!precomputes) {\n      precomputes = this.precomputeWindow(W);\n\n      if (affinePoint && W !== 1) {\n        precomputes = JacobianPoint.normalizeZ(precomputes);\n        pointPrecomputes.set(affinePoint, precomputes);\n      }\n    }\n\n    let p = JacobianPoint.ZERO;\n    let f = JacobianPoint.ZERO;\n    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n    const windowSize = 2 ** (W - 1);\n    const mask = BigInt(2 ** W - 1);\n    const maxNumber = 2 ** W;\n    const shiftBy = BigInt(W);\n\n    for (let window = 0; window < windows; window++) {\n      const offset = window * windowSize;\n      let wbits = Number(n & mask);\n      n >>= shiftBy;\n\n      if (wbits > windowSize) {\n        wbits -= maxNumber;\n        n += 1n;\n      }\n\n      if (wbits === 0) {\n        f = f.add(window % 2 ? precomputes[offset].negate() : precomputes[offset]);\n      } else {\n        const cached = precomputes[offset + Math.abs(wbits) - 1];\n        p = p.add(wbits < 0 ? cached.negate() : cached);\n      }\n    }\n\n    return [p, f];\n  }\n\n  multiply(scalar, affinePoint) {\n    if (!isValidScalar(scalar)) throw new TypeError('Point#multiply: expected valid scalar');\n    let n = mod(BigInt(scalar), CURVE.n);\n    let point;\n    let fake;\n\n    if (USE_ENDOMORPHISM) {\n      const [k1neg, k1, k2neg, k2] = splitScalarEndo(n);\n      let k1p, k2p, f1p, f2p;\n      [k1p, f1p] = this.wNAF(k1, affinePoint);\n      [k2p, f2p] = this.wNAF(k2, affinePoint);\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n      [point, fake] = [k1p.add(k2p), f1p.add(f2p)];\n    } else {\n      [point, fake] = this.wNAF(n, affinePoint);\n    }\n\n    return JacobianPoint.normalizeZ([point, fake])[0];\n  }\n\n  toAffine() {\n    let invZ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : invert(this.z);\n    const invZ2 = invZ ** 2n;\n    const x = mod(this.x * invZ2);\n    const y = mod(this.y * invZ2 * invZ);\n    return new Point(x, y);\n  }\n\n}\n\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, 1n);\nJacobianPoint.ZERO = new JacobianPoint(0n, 1n, 0n);\nconst pointPrecomputes = new WeakMap();\n\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  _setWindowSize(windowSize) {\n    this._WINDOW_SIZE = windowSize;\n    pointPrecomputes.delete(this);\n  }\n\n  static fromCompressedHex(bytes) {\n    const isShort = bytes.length === 32;\n    const x = bytesToNumber(isShort ? bytes : bytes.slice(1));\n    const y2 = weistrass(x);\n    let y = sqrtMod(y2);\n    const isYOdd = (y & 1n) === 1n;\n\n    if (isShort) {\n      if (isYOdd) y = mod(-y);\n    } else {\n      const isFirstByteOdd = (bytes[0] & 1) === 1;\n      if (isFirstByteOdd !== isYOdd) y = mod(-y);\n    }\n\n    const point = new Point(x, y);\n    point.assertValidity();\n    return point;\n  }\n\n  static fromUncompressedHex(bytes) {\n    const x = bytesToNumber(bytes.slice(1, 33));\n    const y = bytesToNumber(bytes.slice(33));\n    const point = new Point(x, y);\n    point.assertValidity();\n    return point;\n  }\n\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex);\n    const header = bytes[0];\n\n    if (bytes.length === 32 || bytes.length === 33 && (header === 0x02 || header === 0x03)) {\n      return this.fromCompressedHex(bytes);\n    }\n\n    if (bytes.length === 65 && header === 0x04) return this.fromUncompressedHex(bytes);\n    throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${bytes.length}`);\n  }\n\n  static fromPrivateKey(privateKey) {\n    return Point.BASE.multiply(normalizePrivateKey(privateKey));\n  }\n\n  static fromSignature(msgHash, signature, recovery) {\n    let h = msgHash instanceof Uint8Array ? bytesToNumber(msgHash) : hexToNumber(msgHash);\n    const sig = normalizeSignature(signature);\n    const {\n      r,\n      s\n    } = sig;\n\n    if (recovery !== 0 && recovery !== 1) {\n      throw new Error('Cannot recover signature: invalid yParity bit');\n    }\n\n    const prefix = 2 + (recovery & 1);\n    const P_ = Point.fromHex(`0${prefix}${pad64(r)}`);\n    const sP = JacobianPoint.fromAffine(P_).multiplyUnsafe(s);\n    const hG = JacobianPoint.BASE.multiply(h);\n    const rinv = invert(r, CURVE.n);\n    const Q = sP.subtract(hG).multiplyUnsafe(rinv);\n    const point = Q.toAffine();\n    point.assertValidity();\n    return point;\n  }\n\n  toRawBytes() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return hexToBytes(this.toHex(isCompressed));\n  }\n\n  toHex() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const x = pad64(this.x);\n\n    if (isCompressed) {\n      return `${this.y & 1n ? '03' : '02'}${x}`;\n    } else {\n      return `04${x}${pad64(this.y)}`;\n    }\n  }\n\n  toHexX() {\n    return this.toHex(true).slice(2);\n  }\n\n  toRawX() {\n    return this.toRawBytes(true).slice(1);\n  }\n\n  assertValidity() {\n    const msg = 'Point is not on elliptic curve';\n    const {\n      P\n    } = CURVE;\n    const {\n      x,\n      y\n    } = this;\n    if (x === 0n || y === 0n || x >= P || y >= P) throw new Error(msg);\n    const left = mod(y * y);\n    const right = weistrass(x);\n    if ((left - right) % P !== 0n) throw new Error(msg);\n  }\n\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n\n  negate() {\n    return new Point(this.x, mod(-this.y));\n  }\n\n  double() {\n    return JacobianPoint.fromAffine(this).double().toAffine();\n  }\n\n  add(other) {\n    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n  }\n\n  subtract(other) {\n    return this.add(other.negate());\n  }\n\n  multiply(scalar) {\n    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n  }\n\n}\n\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(0n, 0n);\n\nfunction sliceDer(s) {\n  return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\n\nclass Signature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n  }\n\n  static fromCompact(hex) {\n    if (typeof hex !== 'string' && !(hex instanceof Uint8Array)) {\n      throw new TypeError(`Signature.fromCompact: Expected string or Uint8Array`);\n    }\n\n    const str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;\n    if (str.length !== 128) throw new Error('Signature.fromCompact: Expected 64-byte hex');\n    const sig = new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    sig.assertValidity();\n    return sig;\n  }\n\n  static fromDER(hex) {\n    const fn = 'Signature.fromDER';\n\n    if (typeof hex !== 'string' && !(hex instanceof Uint8Array)) {\n      throw new TypeError(`${fn}: Expected string or Uint8Array`);\n    }\n\n    const str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;\n    const length = parseByte(str.slice(2, 4));\n\n    if (str.slice(0, 2) !== '30' || length !== str.length - 4 || str.slice(4, 6) !== '02') {\n      throw new Error(`${fn}: Invalid signature ${str}`);\n    }\n\n    const rLen = parseByte(str.slice(6, 8));\n    const rEnd = 8 + rLen;\n    const rr = str.slice(8, rEnd);\n\n    if (rr.startsWith('00') && parseByte(rr.slice(2, 4)) <= 0x7f) {\n      throw new Error(`${fn}: Invalid r with trailing length`);\n    }\n\n    const r = hexToNumber(rr);\n    const separator = str.slice(rEnd, rEnd + 2);\n\n    if (separator !== '02') {\n      throw new Error(`${fn}: Invalid r-s separator`);\n    }\n\n    const sLen = parseByte(str.slice(rEnd + 2, rEnd + 4));\n    const diff = length - sLen - rLen - 10;\n\n    if (diff > 0 || diff === -4) {\n      throw new Error(`${fn}: Invalid total length`);\n    }\n\n    if (sLen > length - rLen - 4) {\n      throw new Error(`${fn}: Invalid s`);\n    }\n\n    const sStart = rEnd + 4;\n    const ss = str.slice(sStart, sStart + sLen);\n\n    if (ss.startsWith('00') && parseByte(ss.slice(2, 4)) <= 0x7f) {\n      throw new Error(`${fn}: Invalid s with trailing length`);\n    }\n\n    const s = hexToNumber(ss);\n    const sig = new Signature(r, s);\n    sig.assertValidity();\n    return sig;\n  }\n\n  static fromHex(hex) {\n    return this.fromDER(hex);\n  }\n\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');\n    if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');\n  }\n\n  toDERRawBytes() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return hexToBytes(this.toDERHex(isCompressed));\n  }\n\n  toDERHex() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const sHex = sliceDer(numberToHex(this.s));\n    if (isCompressed) return sHex;\n    const rHex = sliceDer(numberToHex(this.r));\n    const rLen = numberToHex(rHex.length / 2);\n    const sLen = numberToHex(sHex.length / 2);\n    const length = numberToHex(rHex.length / 2 + sHex.length / 2 + 4);\n    return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n  }\n\n  toRawBytes() {\n    return this.toDERRawBytes();\n  }\n\n  toHex() {\n    return this.toDERHex();\n  }\n\n  toCompactRawBytes() {\n    return hexToBytes(this.toCompactHex());\n  }\n\n  toCompactHex() {\n    return pad64(this.r) + pad64(this.s);\n  }\n\n}\n\nexports.Signature = Signature;\nexports.SignResult = Signature;\n\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n\n  return result;\n}\n\nfunction bytesToHex(uint8a) {\n  let hex = '';\n\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += uint8a[i].toString(16).padStart(2, '0');\n  }\n\n  return hex;\n}\n\nfunction pad64(num) {\n  return num.toString(16).padStart(64, '0');\n}\n\nfunction pad32b(num) {\n  return hexToBytes(pad64(num));\n}\n\nfunction numberToHex(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n  }\n\n  return BigInt(`0x${hex}`);\n}\n\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    array[i] = Number.parseInt(hex.slice(j, j + 2), 16);\n  }\n\n  return array;\n}\n\nfunction ensureBytes(hex) {\n  return hex instanceof Uint8Array ? hex : hexToBytes(hex);\n}\n\nfunction bytesToNumber(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\n\nfunction parseByte(str) {\n  return Number.parseInt(str, 16) * 2;\n}\n\nfunction isValidScalar(num) {\n  if (typeof num === 'bigint' && num > 0n) return true;\n  if (typeof num === 'number' && num > 0 && Number.isSafeInteger(num)) return true;\n  return false;\n}\n\nfunction mod(a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const result = a % b;\n  return result >= 0 ? result : b + result;\n}\n\nfunction pow2(x, power) {\n  const {\n    P\n  } = CURVE;\n  let res = x;\n\n  while (power-- > 0n) {\n    res *= res;\n    res %= P;\n  }\n\n  return res;\n}\n\nfunction sqrtMod(x) {\n  const {\n    P\n  } = CURVE;\n  const b2 = x * x * x % P;\n  const b3 = b2 * b2 * x % P;\n  const b6 = pow2(b3, 3n) * b3 % P;\n  const b9 = pow2(b6, 3n) * b3 % P;\n  const b11 = pow2(b9, 2n) * b2 % P;\n  const b22 = pow2(b11, 11n) * b11 % P;\n  const b44 = pow2(b22, 22n) * b22 % P;\n  const b88 = pow2(b44, 44n) * b44 % P;\n  const b176 = pow2(b88, 88n) * b88 % P;\n  const b220 = pow2(b176, 44n) * b44 % P;\n  const b223 = pow2(b220, 3n) * b3 % P;\n  const t1 = pow2(b223, 23n) * b22 % P;\n  const t2 = pow2(t1, 6n) * b2 % P;\n  return pow2(t2, 2n);\n}\n\nfunction invert(number) {\n  let modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n\n  if (number === 0n || modulo <= 0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n\n  let a = mod(number, modulo);\n  let b = modulo;\n  let [x, y, u, v] = [0n, 1n, 1n, 0n];\n\n  while (a !== 0n) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    [b, a] = [a, r];\n    [x, y] = [u, v];\n    [u, v] = [m, n];\n  }\n\n  const gcd = b;\n  if (gcd !== 1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction invertBatch(nums) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const len = nums.length;\n  const scratch = new Array(len);\n  let acc = 1n;\n\n  for (let i = 0; i < len; i++) {\n    if (nums[i] === 0n) continue;\n    scratch[i] = acc;\n    acc = mod(acc * nums[i], n);\n  }\n\n  acc = invert(acc, n);\n\n  for (let i = len - 1; i >= 0; i--) {\n    if (nums[i] === 0n) continue;\n    const tmp = mod(acc * nums[i], n);\n    nums[i] = mod(acc * scratch[i], n);\n    acc = tmp;\n  }\n\n  return nums;\n}\n\nconst divNearest = (a, b) => (a + b / 2n) / b;\n\nconst POW_2_128 = 2n ** 128n;\n\nfunction splitScalarEndo(k) {\n  const {\n    n\n  } = CURVE;\n  const a1 = 0x3086d221a7d46bcde86c90e49284eb15n;\n  const b1 = -0xe4437ed6010e88286f547fa90abfe4c3n;\n  const a2 = 0x114ca50f7a8e2f3f657c1108d9d44cfd8n;\n  const b2 = a1;\n  const c1 = divNearest(b2 * k, n);\n  const c2 = divNearest(-b1 * k, n);\n  let k1 = mod(k - c1 * a1 - c2 * a2, n);\n  let k2 = mod(-c1 * b1 - c2 * b2, n);\n  const k1neg = k1 > POW_2_128;\n  const k2neg = k2 > POW_2_128;\n  if (k1neg) k1 = n - k1;\n  if (k2neg) k2 = n - k2;\n  if (k1 > POW_2_128 || k2 > POW_2_128) throw new Error('splitScalarEndo: Endomorphism failed');\n  return [k1neg, k1, k2neg, k2];\n}\n\nfunction truncateHash(hash) {\n  if (typeof hash !== 'string') hash = bytesToHex(hash);\n  let msg = hexToNumber(hash || '0');\n  const byteLength = hash.length / 2;\n  const delta = byteLength * 8 - 256;\n\n  if (delta > 0) {\n    msg = msg >> BigInt(delta);\n  }\n\n  if (msg >= CURVE.n) {\n    msg -= CURVE.n;\n  }\n\n  return msg;\n}\n\nfunction _abc6979(msgHash, privateKey) {\n  if (msgHash == null) throw new Error(`sign: expected valid msgHash, not \"${msgHash}\"`);\n  const num = typeof msgHash === 'string' ? hexToNumber(msgHash) : bytesToNumber(msgHash);\n  const h1 = pad32b(num);\n  const h1n = bytesToNumber(h1);\n  const x = pad32b(privateKey);\n  let v = new Uint8Array(32).fill(1);\n  let k = new Uint8Array(32).fill(0);\n  const b0 = Uint8Array.from([0x00]);\n  const b1 = Uint8Array.from([0x01]);\n  return [h1, h1n, x, v, k, b0, b1];\n}\n\nasync function getQRSrfc6979(msgHash, privateKey) {\n  const privKey = normalizePrivateKey(privateKey);\n\n  let [h1, h1n, x, v, k, b0, b1] = _abc6979(msgHash, privKey);\n\n  const hmac = exports.utils.hmacSha256;\n  k = await hmac(k, v, b0, x, h1);\n  v = await hmac(k, v);\n  k = await hmac(k, v, b1, x, h1);\n  v = await hmac(k, v);\n\n  for (let i = 0; i < 1000; i++) {\n    v = await hmac(k, v);\n    let qrs = calcQRSFromK(v, h1n, privKey);\n    if (qrs) return qrs;\n    k = await hmac(k, v, b0);\n    v = await hmac(k, v);\n  }\n\n  throw new TypeError('secp256k1: Tried 1,000 k values for sign(), all were invalid');\n}\n\nfunction getQRSrfc6979Sync(msgHash, privateKey) {\n  const privKey = normalizePrivateKey(privateKey);\n\n  let [h1, h1n, x, v, k, b0, b1] = _abc6979(msgHash, privKey);\n\n  const hmac = exports.utils.hmacSha256Sync;\n  if (!hmac) throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\n  k = hmac(k, v, b0, x, h1);\n  if (k instanceof Promise) throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\n  v = hmac(k, v);\n  k = hmac(k, v, b1, x, h1);\n  v = hmac(k, v);\n\n  for (let i = 0; i < 1000; i++) {\n    v = hmac(k, v);\n    let qrs = calcQRSFromK(v, h1n, privKey);\n    if (qrs) return qrs;\n    k = hmac(k, v, b0);\n    v = hmac(k, v);\n  }\n\n  throw new TypeError('secp256k1: Tried 1,000 k values for sign(), all were invalid');\n}\n\nfunction isWithinCurveOrder(num) {\n  return 0 < num && num < CURVE.n;\n}\n\nfunction calcQRSFromK(v, msg, priv) {\n  const k = bytesToNumber(v);\n  if (!isWithinCurveOrder(k)) return;\n  const max = CURVE.n;\n  const q = Point.BASE.multiply(k);\n  const r = mod(q.x, max);\n  const s = mod(invert(k, max) * (msg + r * priv), max);\n  if (r === 0n || s === 0n) return;\n  return [q, r, s];\n}\n\nfunction normalizePrivateKey(key) {\n  let num;\n\n  if (typeof key === 'bigint') {\n    num = key;\n  } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n    num = BigInt(key);\n  } else if (typeof key === 'string') {\n    if (key.length !== 64) throw new Error('Expected 32 bytes of private key');\n    num = hexToNumber(key);\n  } else if (key instanceof Uint8Array) {\n    if (key.length !== 32) throw new Error('Expected 32 bytes of private key');\n    num = bytesToNumber(key);\n  } else {\n    throw new TypeError('Expected valid private key');\n  }\n\n  if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');\n  return num;\n}\n\nfunction normalizePublicKey(publicKey) {\n  if (publicKey instanceof Point) {\n    publicKey.assertValidity();\n    return publicKey;\n  } else {\n    return Point.fromHex(publicKey);\n  }\n}\n\nfunction normalizeSignature(signature) {\n  if (signature instanceof Signature) {\n    signature.assertValidity();\n    return signature;\n  } else {\n    return Signature.fromDER(signature);\n  }\n}\n\nfunction getPublicKey(privateKey) {\n  let isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const point = Point.fromPrivateKey(privateKey);\n\n  if (typeof privateKey === 'string') {\n    return point.toHex(isCompressed);\n  }\n\n  return point.toRawBytes(isCompressed);\n}\n\nexports.getPublicKey = getPublicKey;\n\nfunction recoverPublicKey(msgHash, signature, recovery) {\n  const point = Point.fromSignature(msgHash, signature, recovery);\n  return typeof msgHash === 'string' ? point.toHex() : point.toRawBytes();\n}\n\nexports.recoverPublicKey = recoverPublicKey;\n\nfunction isPub(item) {\n  const arr = item instanceof Uint8Array;\n  const str = typeof item === 'string';\n  const len = (arr || str) && item.length;\n  if (arr) return len === 33 || len === 65;\n  if (str) return len === 66 || len === 130;\n  if (item instanceof Point) return true;\n  return false;\n}\n\nfunction getSharedSecret(privateA, publicB) {\n  let isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (isPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');\n  if (!isPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');\n  const b = normalizePublicKey(publicB);\n  b.assertValidity();\n  const shared = b.multiply(normalizePrivateKey(privateA));\n  return typeof privateA === 'string' ? shared.toHex(isCompressed) : shared.toRawBytes(isCompressed);\n}\n\nexports.getSharedSecret = getSharedSecret;\n\nfunction QRSToSig(qrs, opts) {\n  let str = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const [q, r, s] = qrs;\n  let {\n    canonical,\n    der,\n    recovered\n  } = opts;\n  let recovery = (q.x === r ? 0 : 2) | Number(q.y & 1n);\n  let adjustedS = s;\n  const HIGH_NUMBER = CURVE.n >> 1n;\n\n  if (s > HIGH_NUMBER && canonical) {\n    adjustedS = CURVE.n - s;\n    recovery ^= 1;\n  }\n\n  const sig = new Signature(r, adjustedS);\n  sig.assertValidity();\n  const hex = der === false ? sig.toCompactHex() : sig.toDERHex();\n  const hashed = str ? hex : hexToBytes(hex);\n  return recovered ? [hashed, recovery] : hashed;\n}\n\nasync function sign(msgHash, privKey) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return QRSToSig(await getQRSrfc6979(msgHash, privKey), opts, typeof msgHash === 'string');\n}\n\nexports.sign = sign;\n\nfunction signSync(msgHash, privKey) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return QRSToSig(getQRSrfc6979Sync(msgHash, privKey), opts, typeof msgHash === 'string');\n}\n\nexports.signSync = signSync;\n\nfunction verify(signature, msgHash, publicKey) {\n  const {\n    n\n  } = CURVE;\n  let sig;\n\n  try {\n    sig = normalizeSignature(signature);\n  } catch (error) {\n    return false;\n  }\n\n  const {\n    r,\n    s\n  } = sig;\n  const h = truncateHash(msgHash);\n  if (h === 0n) return false;\n  const pubKey = JacobianPoint.fromAffine(normalizePublicKey(publicKey));\n  const s1 = invert(s, n);\n  const u1 = mod(h * s1, n);\n  const u2 = mod(r * s1, n);\n  const Ghs1 = JacobianPoint.BASE.multiply(u1);\n  const Prs1 = pubKey.multiplyUnsafe(u2);\n  const R = Ghs1.add(Prs1).toAffine();\n  const v = mod(R.x, n);\n  return v === r;\n}\n\nexports.verify = verify;\n\nasync function taggedHash(tag) {\n  const tagB = new Uint8Array(tag.split('').map(c => c.charCodeAt(0)));\n  const tagH = await exports.utils.sha256(tagB);\n\n  for (var _len2 = arguments.length, messages = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    messages[_key2 - 1] = arguments[_key2];\n  }\n\n  const h = await exports.utils.sha256(concatBytes(tagH, tagH, ...messages));\n  return bytesToNumber(h);\n}\n\nasync function createChallenge(x, P, message) {\n  const rx = pad32b(x);\n  const t = await taggedHash('BIP0340/challenge', rx, P.toRawX(), message);\n  return mod(t, CURVE.n);\n}\n\nfunction hasEvenY(point) {\n  return mod(point.y, 2n) === 0n;\n}\n\nclass SchnorrSignature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    if (r <= 0n || s <= 0n || r >= CURVE.P || s >= CURVE.n) throw new Error('Invalid signature');\n  }\n\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex);\n\n    if (bytes.length !== 64) {\n      throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n    }\n\n    const r = bytesToNumber(bytes.slice(0, 32));\n    const s = bytesToNumber(bytes.slice(32));\n    return new SchnorrSignature(r, s);\n  }\n\n  toHex() {\n    return pad64(this.r) + pad64(this.s);\n  }\n\n  toRawBytes() {\n    return hexToBytes(this.toHex());\n  }\n\n}\n\nfunction schnorrGetPublicKey(privateKey) {\n  const P = Point.fromPrivateKey(privateKey);\n  return typeof privateKey === 'string' ? P.toHexX() : P.toRawX();\n}\n\nasync function schnorrSign(msgHash, privateKey) {\n  let auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.utils.randomBytes();\n  if (msgHash == null) throw new TypeError(`sign: Expected valid message, not \"${msgHash}\"`);\n  if (!privateKey) privateKey = 0n;\n  const {\n    n\n  } = CURVE;\n  const m = ensureBytes(msgHash);\n  const d0 = normalizePrivateKey(privateKey);\n  const rand = ensureBytes(auxRand);\n  if (rand.length !== 32) throw new TypeError('sign: Expected 32 bytes of aux randomness');\n  const P = Point.fromPrivateKey(d0);\n  const d = hasEvenY(P) ? d0 : n - d0;\n  const t0h = await taggedHash('BIP0340/aux', rand);\n  const t = d ^ t0h;\n  const k0h = await taggedHash('BIP0340/nonce', pad32b(t), P.toRawX(), m);\n  const k0 = mod(k0h, n);\n  if (k0 === 0n) throw new Error('sign: Creation of signature failed. k is zero');\n  const R = Point.fromPrivateKey(k0);\n  const k = hasEvenY(R) ? k0 : n - k0;\n  const e = await createChallenge(R.x, P, m);\n  const sig = new SchnorrSignature(R.x, mod(k + e * d, n));\n  const isValid = await schnorrVerify(sig.toRawBytes(), m, P.toRawX());\n  if (!isValid) throw new Error('sign: Invalid signature produced');\n  return typeof msgHash === 'string' ? sig.toHex() : sig.toRawBytes();\n}\n\nasync function schnorrVerify(signature, msgHash, publicKey) {\n  const sig = signature instanceof SchnorrSignature ? signature : SchnorrSignature.fromHex(signature);\n  const m = typeof msgHash === 'string' ? hexToBytes(msgHash) : msgHash;\n  const P = normalizePublicKey(publicKey);\n  const e = await createChallenge(sig.r, P, m);\n  const sG = Point.fromPrivateKey(sig.s);\n  const eP = P.multiply(e);\n  const R = sG.subtract(eP);\n  if (R.equals(Point.BASE) || !hasEvenY(R) || R.x !== sig.r) return false;\n  return true;\n}\n\nexports.schnorr = {\n  Signature: SchnorrSignature,\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify\n};\n\nPoint.BASE._setWindowSize(8);\n\nconst crypto = (() => {\n  const webCrypto = typeof self === 'object' && 'crypto' in self ? self.crypto : undefined;\n  const nodeRequire = typeof module !== 'undefined' && typeof require === 'function';\n  return {\n    node: nodeRequire && !webCrypto ? require('crypto') : undefined,\n    web: webCrypto\n  };\n})();\n\nexports.utils = {\n  isValidPrivateKey(privateKey) {\n    try {\n      normalizePrivateKey(privateKey);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  },\n\n  randomBytes: function () {\n    let bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      const {\n        randomBytes\n      } = crypto.node;\n      return new Uint8Array(randomBytes(bytesLength).buffer);\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: () => {\n    let i = 8;\n\n    while (i--) {\n      const b32 = exports.utils.randomBytes(32);\n      const num = bytesToNumber(b32);\n      if (isWithinCurveOrder(num) && num !== 1n) return b32;\n    }\n\n    throw new Error('Valid private key was not found in 8 iterations. PRNG is broken');\n  },\n  sha256: async message => {\n    if (crypto.web) {\n      const buffer = await crypto.web.subtle.digest('SHA-256', message.buffer);\n      return new Uint8Array(buffer);\n    } else if (crypto.node) {\n      const {\n        createHash\n      } = crypto.node;\n      return Uint8Array.from(createHash('sha256').update(message).digest());\n    } else {\n      throw new Error(\"The environment doesn't have sha256 function\");\n    }\n  },\n  hmacSha256: async function (key) {\n    for (var _len3 = arguments.length, messages = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      messages[_key3 - 1] = arguments[_key3];\n    }\n\n    if (crypto.web) {\n      const ckey = await crypto.web.subtle.importKey('raw', key, {\n        name: 'HMAC',\n        hash: {\n          name: 'SHA-256'\n        }\n      }, false, ['sign']);\n      const message = concatBytes(...messages);\n      const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n      return new Uint8Array(buffer);\n    } else if (crypto.node) {\n      const {\n        createHmac\n      } = crypto.node;\n      const hash = createHmac('sha256', key);\n\n      for (let message of messages) {\n        hash.update(message);\n      }\n\n      return Uint8Array.from(hash.digest());\n    } else {\n      throw new Error(\"The environment doesn't have hmac-sha256 function\");\n    }\n  },\n  sha256Sync: undefined,\n  hmacSha256Sync: undefined,\n\n  precompute() {\n    let windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n    const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n\n    cached._setWindowSize(windowSize);\n\n    cached.multiply(3n);\n    return cached;\n  }\n\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","utils","schnorr","verify","signSync","sign","getSharedSecret","recoverPublicKey","getPublicKey","SignResult","Signature","Point","CURVE","a","b","P","n","h","Gx","Gy","beta","weistrass","x","mod","USE_ENDOMORPHISM","JacobianPoint","constructor","y","z","fromAffine","p","TypeError","toAffineBatch","points","toInv","invertBatch","map","i","toAffine","normalizeZ","equals","other","az2","az3","bz2","bz3","negate","double","X1","Y1","Z1","A","B","C","D","E","F","X3","Y3","Z3","add","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","H","r","ZERO","HH","HHH","V","subtract","multiplyUnsafe","scalar","isValidScalar","BigInt","d","k1neg","k1","k2neg","k2","splitScalarEndo","k1p","k2p","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","BASE","_WINDOW_SIZE","Error","precomputes","pointPrecomputes","get","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","cached","Math","abs","multiply","point","fake","f1p","f2p","invZ","invert","invZ2","WeakMap","_setWindowSize","delete","fromCompressedHex","bytes","isShort","length","bytesToNumber","slice","y2","sqrtMod","isYOdd","isFirstByteOdd","assertValidity","fromUncompressedHex","fromHex","hex","ensureBytes","header","fromPrivateKey","privateKey","normalizePrivateKey","fromSignature","msgHash","signature","recovery","Uint8Array","hexToNumber","sig","normalizeSignature","s","prefix","P_","pad64","sP","hG","rinv","Q","toRawBytes","isCompressed","hexToBytes","toHex","toHexX","toRawX","msg","left","right","sliceDer","parseInt","fromCompact","str","bytesToHex","fromDER","fn","parseByte","rLen","rEnd","rr","startsWith","separator","sLen","diff","sStart","ss","isWithinCurveOrder","toDERRawBytes","toDERHex","sHex","numberToHex","rHex","toCompactRawBytes","toCompactHex","concatBytes","arrays","reduce","arr","result","pad","uint8a","toString","padStart","num","pad32b","array","j","isSafeInteger","pow2","power","res","b2","b3","b6","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","number","modulo","u","v","q","m","gcd","nums","len","scratch","Array","acc","tmp","divNearest","POW_2_128","k","a1","b1","a2","c1","c2","truncateHash","hash","byteLength","delta","_abc6979","h1","h1n","fill","b0","from","getQRSrfc6979","privKey","hmac","hmacSha256","qrs","calcQRSFromK","getQRSrfc6979Sync","hmacSha256Sync","Promise","priv","max","key","normalizePublicKey","publicKey","isPub","item","privateA","publicB","shared","QRSToSig","opts","canonical","der","recovered","adjustedS","HIGH_NUMBER","hashed","error","pubKey","s1","u1","u2","Ghs1","Prs1","R","taggedHash","tag","tagB","split","c","charCodeAt","tagH","sha256","messages","createChallenge","message","rx","t","hasEvenY","SchnorrSignature","schnorrGetPublicKey","schnorrSign","auxRand","randomBytes","d0","rand","t0h","k0h","k0","e","isValid","schnorrVerify","sG","eP","crypto","webCrypto","self","undefined","nodeRequire","module","require","node","web","isValidPrivateKey","bytesLength","getRandomValues","buffer","randomPrivateKey","b32","subtle","digest","createHash","update","ckey","importKey","name","createHmac","sha256Sync","precompute"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/noble-secp256k1/index.js"],"sourcesContent":["\"use strict\";\n/*! noble-secp256k1 - MIT License (c) Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.SignResult = exports.Signature = exports.Point = exports.CURVE = void 0;\nconst CURVE = {\n    a: 0n,\n    b: 7n,\n    P: 2n ** 256n - 2n ** 32n - 977n,\n    n: 2n ** 256n - 432420386565659656852420866394968145599n,\n    h: 1n,\n    Gx: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,\n    Gy: 32670510020758816978083085130507043184471273380659243275938904335757337482424n,\n    beta: 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501een,\n};\nexports.CURVE = CURVE;\nfunction weistrass(x) {\n    const { a, b } = CURVE;\n    return mod(x ** 3n + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === 0n;\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        return new JacobianPoint(p.x, p.y, 1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        const a = this;\n        const b = other;\n        const az2 = mod(a.z * a.z);\n        const az3 = mod(a.z * az2);\n        const bz2 = mod(b.z * b.z);\n        const bz3 = mod(b.z * bz2);\n        return mod(a.x * bz2) === mod(az2 * b.x) && mod(a.y * bz3) === mod(az3 * b.y);\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const A = mod(X1 ** 2n);\n        const B = mod(Y1 ** 2n);\n        const C = mod(B ** 2n);\n        const D = mod(2n * (mod(mod((X1 + B) ** 2n)) - A - C));\n        const E = mod(3n * A);\n        const F = mod(E ** 2n);\n        const X3 = mod(F - 2n * D);\n        const Y3 = mod(E * (D - X3) - 8n * C);\n        const Z3 = mod(2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        if (!(other instanceof JacobianPoint)) {\n            throw new TypeError('JacobianPoint#add: expected JacobianPoint');\n        }\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const X2 = other.x;\n        const Y2 = other.y;\n        const Z2 = other.z;\n        if (X2 === 0n || Y2 === 0n)\n            return this;\n        if (X1 === 0n || Y1 === 0n)\n            return other;\n        const Z1Z1 = mod(Z1 ** 2n);\n        const Z2Z2 = mod(Z2 ** 2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(Y1 * Z2 * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === 0n) {\n            if (r === 0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H ** 2n);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r ** 2n - HHH - 2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        if (!isValidScalar(scalar))\n            throw new TypeError('Point#multiply: expected valid scalar');\n        let n = mod(BigInt(scalar), CURVE.n);\n        if (!USE_ENDOMORPHISM) {\n            let p = JacobianPoint.ZERO;\n            let d = this;\n            while (n > 0n) {\n                if (n & 1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= 1n;\n            }\n            return p;\n        }\n        let [k1neg, k1, k2neg, k2] = splitScalarEndo(n);\n        let k1p = JacobianPoint.ZERO;\n        let k2p = JacobianPoint.ZERO;\n        let d = this;\n        while (k1 > 0n || k2 > 0n) {\n            if (k1 & 1n)\n                k1p = k1p.add(d);\n            if (k2 & 1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= 1n;\n            k2 >>= 1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        let points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.ZERO;\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += 1n;\n            }\n            if (wbits === 0) {\n                f = f.add(window % 2 ? precomputes[offset].negate() : precomputes[offset]);\n            }\n            else {\n                const cached = precomputes[offset + Math.abs(wbits) - 1];\n                p = p.add(wbits < 0 ? cached.negate() : cached);\n            }\n        }\n        return [p, f];\n    }\n    multiply(scalar, affinePoint) {\n        if (!isValidScalar(scalar))\n            throw new TypeError('Point#multiply: expected valid scalar');\n        let n = mod(BigInt(scalar), CURVE.n);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const [k1neg, k1, k2neg, k2] = splitScalarEndo(n);\n            let k1p, k2p, f1p, f2p;\n            [k1p, f1p] = this.wNAF(k1, affinePoint);\n            [k2p, f2p] = this.wNAF(k2, affinePoint);\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n            [point, fake] = [k1p.add(k2p), f1p.add(f2p)];\n        }\n        else {\n            [point, fake] = this.wNAF(n, affinePoint);\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const invZ2 = invZ ** 2n;\n        const x = mod(this.x * invZ2);\n        const y = mod(this.y * invZ2 * invZ);\n        return new Point(x, y);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, 1n);\nJacobianPoint.ZERO = new JacobianPoint(0n, 1n, 0n);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.slice(1));\n        const y2 = weistrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & 1n) === 1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.slice(1, 33));\n        const y = bytesToNumber(bytes.slice(33));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const header = bytes[0];\n        if (bytes.length === 32 || (bytes.length === 33 && (header === 0x02 || header === 0x03))) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (bytes.length === 65 && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${bytes.length}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        let h = msgHash instanceof Uint8Array ? bytesToNumber(msgHash) : hexToNumber(msgHash);\n        const sig = normalizeSignature(signature);\n        const { r, s } = sig;\n        if (recovery !== 0 && recovery !== 1) {\n            throw new Error('Cannot recover signature: invalid yParity bit');\n        }\n        const prefix = 2 + (recovery & 1);\n        const P_ = Point.fromHex(`0${prefix}${pad64(r)}`);\n        const sP = JacobianPoint.fromAffine(P_).multiplyUnsafe(s);\n        const hG = JacobianPoint.BASE.multiply(h);\n        const rinv = invert(r, CURVE.n);\n        const Q = sP.subtract(hG).multiplyUnsafe(rinv);\n        const point = Q.toAffine();\n        point.assertValidity();\n        return point;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = pad64(this.x);\n        if (isCompressed) {\n            return `${this.y & 1n ? '03' : '02'}${x}`;\n        }\n        else {\n            return `04${x}${pad64(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { P } = CURVE;\n        const { x, y } = this;\n        if (x === 0n || y === 0n || x >= P || y >= P)\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weistrass(x);\n        if ((left - right) % P !== 0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(0n, 0n);\nfunction sliceDer(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n    }\n    static fromCompact(hex) {\n        if (typeof hex !== 'string' && !(hex instanceof Uint8Array)) {\n            throw new TypeError(`Signature.fromCompact: Expected string or Uint8Array`);\n        }\n        const str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error('Signature.fromCompact: Expected 64-byte hex');\n        const sig = new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n        sig.assertValidity();\n        return sig;\n    }\n    static fromDER(hex) {\n        const fn = 'Signature.fromDER';\n        if (typeof hex !== 'string' && !(hex instanceof Uint8Array)) {\n            throw new TypeError(`${fn}: Expected string or Uint8Array`);\n        }\n        const str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;\n        const length = parseByte(str.slice(2, 4));\n        if (str.slice(0, 2) !== '30' || length !== str.length - 4 || str.slice(4, 6) !== '02') {\n            throw new Error(`${fn}: Invalid signature ${str}`);\n        }\n        const rLen = parseByte(str.slice(6, 8));\n        const rEnd = 8 + rLen;\n        const rr = str.slice(8, rEnd);\n        if (rr.startsWith('00') && parseByte(rr.slice(2, 4)) <= 0x7f) {\n            throw new Error(`${fn}: Invalid r with trailing length`);\n        }\n        const r = hexToNumber(rr);\n        const separator = str.slice(rEnd, rEnd + 2);\n        if (separator !== '02') {\n            throw new Error(`${fn}: Invalid r-s separator`);\n        }\n        const sLen = parseByte(str.slice(rEnd + 2, rEnd + 4));\n        const diff = length - sLen - rLen - 10;\n        if (diff > 0 || diff === -4) {\n            throw new Error(`${fn}: Invalid total length`);\n        }\n        if (sLen > length - rLen - 4) {\n            throw new Error(`${fn}: Invalid s`);\n        }\n        const sStart = rEnd + 4;\n        const ss = str.slice(sStart, sStart + sLen);\n        if (ss.startsWith('00') && parseByte(ss.slice(2, 4)) <= 0x7f) {\n            throw new Error(`${fn}: Invalid s with trailing length`);\n        }\n        const s = hexToNumber(ss);\n        const sig = new Signature(r, s);\n        sig.assertValidity();\n        return sig;\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    toDERRawBytes(isCompressed = false) {\n        return hexToBytes(this.toDERHex(isCompressed));\n    }\n    toDERHex(isCompressed = false) {\n        const sHex = sliceDer(numberToHex(this.s));\n        if (isCompressed)\n            return sHex;\n        const rHex = sliceDer(numberToHex(this.r));\n        const rLen = numberToHex(rHex.length / 2);\n        const sLen = numberToHex(sHex.length / 2);\n        const length = numberToHex(rHex.length / 2 + sHex.length / 2 + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return pad64(this.r) + pad64(this.s);\n    }\n}\nexports.Signature = Signature;\nexports.SignResult = Signature;\nfunction concatBytes(...arrays) {\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction bytesToHex(uint8a) {\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += uint8a[i].toString(16).padStart(2, '0');\n    }\n    return hex;\n}\nfunction pad64(num) {\n    return num.toString(16).padStart(64, '0');\n}\nfunction pad32b(num) {\n    return hexToBytes(pad64(num));\n}\nfunction numberToHex(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        array[i] = Number.parseInt(hex.slice(j, j + 2), 16);\n    }\n    return array;\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? hex : hexToBytes(hex);\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction parseByte(str) {\n    return Number.parseInt(str, 16) * 2;\n}\nfunction isValidScalar(num) {\n    if (typeof num === 'bigint' && num > 0n)\n        return true;\n    if (typeof num === 'number' && num > 0 && Number.isSafeInteger(num))\n        return true;\n    return false;\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= 0 ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > 0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, 3n) * b3) % P;\n    const b9 = (pow2(b6, 3n) * b3) % P;\n    const b11 = (pow2(b9, 2n) * b2) % P;\n    const b22 = (pow2(b11, 11n) * b11) % P;\n    const b44 = (pow2(b22, 22n) * b22) % P;\n    const b88 = (pow2(b44, 44n) * b44) % P;\n    const b176 = (pow2(b88, 88n) * b88) % P;\n    const b220 = (pow2(b176, 44n) * b44) % P;\n    const b223 = (pow2(b220, 3n) * b3) % P;\n    const t1 = (pow2(b223, 23n) * b22) % P;\n    const t2 = (pow2(t1, 6n) * b2) % P;\n    return pow2(t2, 2n);\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === 0n || modulo <= 0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let [x, y, u, v] = [0n, 1n, 1n, 0n];\n    while (a !== 0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        [b, a] = [a, r];\n        [x, y] = [u, v];\n        [u, v] = [m, n];\n    }\n    const gcd = b;\n    if (gcd !== 1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, n = CURVE.P) {\n    const len = nums.length;\n    const scratch = new Array(len);\n    let acc = 1n;\n    for (let i = 0; i < len; i++) {\n        if (nums[i] === 0n)\n            continue;\n        scratch[i] = acc;\n        acc = mod(acc * nums[i], n);\n    }\n    acc = invert(acc, n);\n    for (let i = len - 1; i >= 0; i--) {\n        if (nums[i] === 0n)\n            continue;\n        const tmp = mod(acc * nums[i], n);\n        nums[i] = mod(acc * scratch[i], n);\n        acc = tmp;\n    }\n    return nums;\n}\nconst divNearest = (a, b) => (a + b / 2n) / b;\nconst POW_2_128 = 2n ** 128n;\nfunction splitScalarEndo(k) {\n    const { n } = CURVE;\n    const a1 = 0x3086d221a7d46bcde86c90e49284eb15n;\n    const b1 = -0xe4437ed6010e88286f547fa90abfe4c3n;\n    const a2 = 0x114ca50f7a8e2f3f657c1108d9d44cfd8n;\n    const b2 = a1;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\n    const k1neg = k1 > POW_2_128;\n    const k2neg = k2 > POW_2_128;\n    if (k1neg)\n        k1 = n - k1;\n    if (k2neg)\n        k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128)\n        throw new Error('splitScalarEndo: Endomorphism failed');\n    return [k1neg, k1, k2neg, k2];\n}\nfunction truncateHash(hash) {\n    if (typeof hash !== 'string')\n        hash = bytesToHex(hash);\n    let msg = hexToNumber(hash || '0');\n    const byteLength = hash.length / 2;\n    const delta = byteLength * 8 - 256;\n    if (delta > 0) {\n        msg = msg >> BigInt(delta);\n    }\n    if (msg >= CURVE.n) {\n        msg -= CURVE.n;\n    }\n    return msg;\n}\nfunction _abc6979(msgHash, privateKey) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid msgHash, not \"${msgHash}\"`);\n    const num = typeof msgHash === 'string' ? hexToNumber(msgHash) : bytesToNumber(msgHash);\n    const h1 = pad32b(num);\n    const h1n = bytesToNumber(h1);\n    const x = pad32b(privateKey);\n    let v = new Uint8Array(32).fill(1);\n    let k = new Uint8Array(32).fill(0);\n    const b0 = Uint8Array.from([0x00]);\n    const b1 = Uint8Array.from([0x01]);\n    return [h1, h1n, x, v, k, b0, b1];\n}\nasync function getQRSrfc6979(msgHash, privateKey) {\n    const privKey = normalizePrivateKey(privateKey);\n    let [h1, h1n, x, v, k, b0, b1] = _abc6979(msgHash, privKey);\n    const hmac = exports.utils.hmacSha256;\n    k = await hmac(k, v, b0, x, h1);\n    v = await hmac(k, v);\n    k = await hmac(k, v, b1, x, h1);\n    v = await hmac(k, v);\n    for (let i = 0; i < 1000; i++) {\n        v = await hmac(k, v);\n        let qrs = calcQRSFromK(v, h1n, privKey);\n        if (qrs)\n            return qrs;\n        k = await hmac(k, v, b0);\n        v = await hmac(k, v);\n    }\n    throw new TypeError('secp256k1: Tried 1,000 k values for sign(), all were invalid');\n}\nfunction getQRSrfc6979Sync(msgHash, privateKey) {\n    const privKey = normalizePrivateKey(privateKey);\n    let [h1, h1n, x, v, k, b0, b1] = _abc6979(msgHash, privKey);\n    const hmac = exports.utils.hmacSha256Sync;\n    if (!hmac)\n        throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\n    k = hmac(k, v, b0, x, h1);\n    if (k instanceof Promise)\n        throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\n    v = hmac(k, v);\n    k = hmac(k, v, b1, x, h1);\n    v = hmac(k, v);\n    for (let i = 0; i < 1000; i++) {\n        v = hmac(k, v);\n        let qrs = calcQRSFromK(v, h1n, privKey);\n        if (qrs)\n            return qrs;\n        k = hmac(k, v, b0);\n        v = hmac(k, v);\n    }\n    throw new TypeError('secp256k1: Tried 1,000 k values for sign(), all were invalid');\n}\nfunction isWithinCurveOrder(num) {\n    return 0 < num && num < CURVE.n;\n}\nfunction calcQRSFromK(v, msg, priv) {\n    const k = bytesToNumber(v);\n    if (!isWithinCurveOrder(k))\n        return;\n    const max = CURVE.n;\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, max);\n    const s = mod(invert(k, max) * (msg + r * priv), max);\n    if (r === 0n || s === 0n)\n        return;\n    return [q, r, s];\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 64)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== 32)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    else {\n        return Signature.fromDER(signature);\n    }\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n    const point = Point.fromPrivateKey(privateKey);\n    if (typeof privateKey === 'string') {\n        return point.toHex(isCompressed);\n    }\n    return point.toRawBytes(isCompressed);\n}\nexports.getPublicKey = getPublicKey;\nfunction recoverPublicKey(msgHash, signature, recovery) {\n    const point = Point.fromSignature(msgHash, signature, recovery);\n    return typeof msgHash === 'string' ? point.toHex() : point.toRawBytes();\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction isPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === 33 || len === 65;\n    if (str)\n        return len === 66 || len === 130;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    const shared = b.multiply(normalizePrivateKey(privateA));\n    return typeof privateA === 'string'\n        ? shared.toHex(isCompressed)\n        : shared.toRawBytes(isCompressed);\n}\nexports.getSharedSecret = getSharedSecret;\nfunction QRSToSig(qrs, opts, str = false) {\n    const [q, r, s] = qrs;\n    let { canonical, der, recovered } = opts;\n    let recovery = (q.x === r ? 0 : 2) | Number(q.y & 1n);\n    let adjustedS = s;\n    const HIGH_NUMBER = CURVE.n >> 1n;\n    if (s > HIGH_NUMBER && canonical) {\n        adjustedS = CURVE.n - s;\n        recovery ^= 1;\n    }\n    const sig = new Signature(r, adjustedS);\n    sig.assertValidity();\n    const hex = der === false ? sig.toCompactHex() : sig.toDERHex();\n    const hashed = str ? hex : hexToBytes(hex);\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    return QRSToSig(await getQRSrfc6979(msgHash, privKey), opts, typeof msgHash === 'string');\n}\nexports.sign = sign;\nfunction signSync(msgHash, privKey, opts = {}) {\n    return QRSToSig(getQRSrfc6979Sync(msgHash, privKey), opts, typeof msgHash === 'string');\n}\nexports.signSync = signSync;\nfunction verify(signature, msgHash, publicKey) {\n    const { n } = CURVE;\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    const h = truncateHash(msgHash);\n    if (h === 0n)\n        return false;\n    const pubKey = JacobianPoint.fromAffine(normalizePublicKey(publicKey));\n    const s1 = invert(s, n);\n    const u1 = mod(h * s1, n);\n    const u2 = mod(r * s1, n);\n    const Ghs1 = JacobianPoint.BASE.multiply(u1);\n    const Prs1 = pubKey.multiplyUnsafe(u2);\n    const R = Ghs1.add(Prs1).toAffine();\n    const v = mod(R.x, n);\n    return v === r;\n}\nexports.verify = verify;\nasync function taggedHash(tag, ...messages) {\n    const tagB = new Uint8Array(tag.split('').map((c) => c.charCodeAt(0)));\n    const tagH = await exports.utils.sha256(tagB);\n    const h = await exports.utils.sha256(concatBytes(tagH, tagH, ...messages));\n    return bytesToNumber(h);\n}\nasync function createChallenge(x, P, message) {\n    const rx = pad32b(x);\n    const t = await taggedHash('BIP0340/challenge', rx, P.toRawX(), message);\n    return mod(t, CURVE.n);\n}\nfunction hasEvenY(point) {\n    return mod(point.y, 2n) === 0n;\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        if (r <= 0n || s <= 0n || r >= CURVE.P || s >= CURVE.n)\n            throw new Error('Invalid signature');\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64) {\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        }\n        const r = bytesToNumber(bytes.slice(0, 32));\n        const s = bytesToNumber(bytes.slice(32));\n        return new SchnorrSignature(r, s);\n    }\n    toHex() {\n        return pad64(this.r) + pad64(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    const P = Point.fromPrivateKey(privateKey);\n    return typeof privateKey === 'string' ? P.toHexX() : P.toRawX();\n}\nasync function schnorrSign(msgHash, privateKey, auxRand = exports.utils.randomBytes()) {\n    if (msgHash == null)\n        throw new TypeError(`sign: Expected valid message, not \"${msgHash}\"`);\n    if (!privateKey)\n        privateKey = 0n;\n    const { n } = CURVE;\n    const m = ensureBytes(msgHash);\n    const d0 = normalizePrivateKey(privateKey);\n    const rand = ensureBytes(auxRand);\n    if (rand.length !== 32)\n        throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    const P = Point.fromPrivateKey(d0);\n    const d = hasEvenY(P) ? d0 : n - d0;\n    const t0h = await taggedHash('BIP0340/aux', rand);\n    const t = d ^ t0h;\n    const k0h = await taggedHash('BIP0340/nonce', pad32b(t), P.toRawX(), m);\n    const k0 = mod(k0h, n);\n    if (k0 === 0n)\n        throw new Error('sign: Creation of signature failed. k is zero');\n    const R = Point.fromPrivateKey(k0);\n    const k = hasEvenY(R) ? k0 : n - k0;\n    const e = await createChallenge(R.x, P, m);\n    const sig = new SchnorrSignature(R.x, mod(k + e * d, n));\n    const isValid = await schnorrVerify(sig.toRawBytes(), m, P.toRawX());\n    if (!isValid)\n        throw new Error('sign: Invalid signature produced');\n    return typeof msgHash === 'string' ? sig.toHex() : sig.toRawBytes();\n}\nasync function schnorrVerify(signature, msgHash, publicKey) {\n    const sig = signature instanceof SchnorrSignature ? signature : SchnorrSignature.fromHex(signature);\n    const m = typeof msgHash === 'string' ? hexToBytes(msgHash) : msgHash;\n    const P = normalizePublicKey(publicKey);\n    const e = await createChallenge(sig.r, P, m);\n    const sG = Point.fromPrivateKey(sig.s);\n    const eP = P.multiply(e);\n    const R = sG.subtract(eP);\n    if (R.equals(Point.BASE) || !hasEvenY(R) || R.x !== sig.r)\n        return false;\n    return true;\n}\nexports.schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = (() => {\n    const webCrypto = typeof self === 'object' && 'crypto' in self ? self.crypto : undefined;\n    const nodeRequire = typeof module !== 'undefined' && typeof require === 'function';\n    return {\n        node: nodeRequire && !webCrypto ? require('crypto') : undefined,\n        web: webCrypto,\n    };\n})();\nexports.utils = {\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        let i = 8;\n        while (i--) {\n            const b32 = exports.utils.randomBytes(32);\n            const num = bytesToNumber(b32);\n            if (isWithinCurveOrder(num) && num !== 1n)\n                return b32;\n        }\n        throw new Error('Valid private key was not found in 8 iterations. PRNG is broken');\n    },\n    sha256: async (message) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            return Uint8Array.from(createHash('sha256').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            for (let message of messages) {\n                hash.update(message);\n            }\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(3n);\n        return cached;\n    },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}