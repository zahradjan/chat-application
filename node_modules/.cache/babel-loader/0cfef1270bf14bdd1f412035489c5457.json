{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar debug = require('debug');\n\nvar PeerId = require('peer-id');\n\nvar drain = require('it-drain');\n\nvar _require = require('p-queue'),\n    PQueue = _require.default;\n\nvar defer = require('p-defer');\n\nvar log = debug('libp2p-delegated-content-routing');\nlog.error = debug('libp2p-delegated-content-routing:error');\nvar DEFAULT_TIMEOUT = 30e3; // 30 second default\n\nvar CONCURRENT_HTTP_REQUESTS = 4;\n/**\n * @typedef {import('peer-id').PeerID} PeerID\n * @typedef {import('cids').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * An implementation of content routing, using a delegated peer.\n */\n\nvar DelegatedContentRouting = /*#__PURE__*/function () {\n  /**\n   * Create a new DelegatedContentRouting instance.\n   *\n   * @param {PeerID} peerId - the id of the node that is using this routing.\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  function DelegatedContentRouting(peerId, client) {\n    _classCallCheck(this, DelegatedContentRouting);\n\n    if (peerId == null) {\n      throw new Error('missing self peerId');\n    }\n\n    if (client == null) {\n      throw new Error('missing ipfs http client');\n    }\n\n    this._client = client;\n    this.peerId = peerId; // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n\n    var concurrency = {\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    };\n    this._httpQueue = new PQueue(concurrency); // sometimes refs requests take long time, they need separate queue\n    // to not suffocate regular business\n\n    this._httpQueueRefs = new PQueue(Object.assign({}, concurrency, {\n      concurrency: 2\n    }));\n\n    var _client$getEndpointCo = client.getEndpointConfig(),\n        protocol = _client$getEndpointCo.protocol,\n        host = _client$getEndpointCo.host,\n        port = _client$getEndpointCo.port;\n\n    log(\"enabled DelegatedContentRouting via \".concat(protocol, \"://\").concat(host, \":\").concat(port));\n  }\n  /**\n   * Search the dht for providers of the given CID.\n   *\n   * - call `findProviders` on the delegated node.\n   *\n   * @param {CID} key - The CID to find providers for\n   * @param {object} options - Options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @param {number} options.numProviders - How many providers to find, defaults to 20\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} - An async iterable of PeerId/Multiaddrs\n   */\n\n\n  _createClass(DelegatedContentRouting, [{\n    key: \"findProviders\",\n    value: function findProviders(key) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var providers, onStart, onFinish, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, id, addrs;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                log(\"findProviders starts: \".concat(key));\n                options.timeout = options.timeout || DEFAULT_TIMEOUT;\n                providers = 0;\n                onStart = defer();\n                onFinish = defer();\n\n                _this._httpQueue.add(function () {\n                  onStart.resolve();\n                  return onFinish.promise;\n                });\n\n                _context.prev = 6;\n                _context.next = 9;\n                return _awaitAsyncGenerator(onStart.promise);\n\n              case 9:\n                _iteratorAbruptCompletion = false;\n                _didIteratorError = false;\n                _context.prev = 11;\n                _iterator = _asyncIterator(_this._client.dht.findProvs(key, {\n                  numProviders: options.numProviders,\n                  timeout: options.timeout\n                }));\n\n              case 13:\n                _context.next = 15;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 15:\n                if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                  _context.next = 23;\n                  break;\n                }\n\n                _step$value = _step.value, id = _step$value.id, addrs = _step$value.addrs;\n                _context.next = 19;\n                return {\n                  id: PeerId.parse(id),\n                  multiaddrs: addrs\n                };\n\n              case 19:\n                providers++;\n\n              case 20:\n                _iteratorAbruptCompletion = false;\n                _context.next = 13;\n                break;\n\n              case 23:\n                _context.next = 29;\n                break;\n\n              case 25:\n                _context.prev = 25;\n                _context.t0 = _context[\"catch\"](11);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 29:\n                _context.prev = 29;\n                _context.prev = 30;\n\n                if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                  _context.next = 34;\n                  break;\n                }\n\n                _context.next = 34;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 34:\n                _context.prev = 34;\n\n                if (!_didIteratorError) {\n                  _context.next = 37;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 37:\n                return _context.finish(34);\n\n              case 38:\n                return _context.finish(29);\n\n              case 39:\n                _context.next = 45;\n                break;\n\n              case 41:\n                _context.prev = 41;\n                _context.t1 = _context[\"catch\"](6);\n                log.error('findProviders errored:', _context.t1);\n                throw _context.t1;\n\n              case 45:\n                _context.prev = 45;\n                onFinish.resolve();\n                log(\"findProviders finished: \".concat(key, \" found \").concat(providers, \" providers\"));\n                return _context.finish(45);\n\n              case 49:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[6, 41, 45, 49], [11, 25, 29, 39], [30,, 34, 38]]);\n      }))();\n    }\n    /**\n     * Announce to the network that the delegated node can provide the given key.\n     *\n     * Currently this uses the following hack\n     * - delegate is one of bootstrap nodes, so we are always connected to it\n     * - call block stat on the delegated node, so it fetches the content\n     * - call dht provide with the passed cid\n     *\n     * N.B. this must be called for every block in the dag you want provided otherwise\n     * the delegate will only be able to supply the root block of the dag when asked\n     * for the data by an interested peer.\n     *\n     * @param {CID} key - The delegate will publish a provider record for this CID\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"provide\",\n    value: function () {\n      var _provide = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key) {\n        var _this2 = this;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                log(\"provide starts: \".concat(key));\n                _context3.next = 3;\n                return this._httpQueueRefs.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          _context2.next = 2;\n                          return _this2._client.block.stat(key);\n\n                        case 2:\n                          _context2.next = 4;\n                          return drain(_this2._client.dht.provide(key));\n\n                        case 4:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2);\n                })));\n\n              case 3:\n                log(\"provide finished: \".concat(key));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function provide(_x) {\n        return _provide.apply(this, arguments);\n      }\n\n      return provide;\n    }()\n  }]);\n\n  return DelegatedContentRouting;\n}();\n\nmodule.exports = DelegatedContentRouting;","map":{"version":3,"names":["debug","require","PeerId","drain","PQueue","default","defer","log","error","DEFAULT_TIMEOUT","CONCURRENT_HTTP_REQUESTS","DelegatedContentRouting","peerId","client","Error","_client","concurrency","_httpQueue","_httpQueueRefs","Object","assign","getEndpointConfig","protocol","host","port","key","options","timeout","providers","onStart","onFinish","add","resolve","promise","dht","findProvs","numProviders","id","addrs","parse","multiaddrs","block","stat","provide","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-delegated-content-routing/src/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst PeerId = require('peer-id')\nconst drain = require('it-drain')\n\nconst { default: PQueue } = require('p-queue')\nconst defer = require('p-defer')\n\nconst log = debug('libp2p-delegated-content-routing')\nlog.error = debug('libp2p-delegated-content-routing:error')\n\nconst DEFAULT_TIMEOUT = 30e3 // 30 second default\nconst CONCURRENT_HTTP_REQUESTS = 4\n\n/**\n * @typedef {import('peer-id').PeerID} PeerID\n * @typedef {import('cids').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * An implementation of content routing, using a delegated peer.\n */\nclass DelegatedContentRouting {\n  /**\n   * Create a new DelegatedContentRouting instance.\n   *\n   * @param {PeerID} peerId - the id of the node that is using this routing.\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor (peerId, client) {\n    if (peerId == null) {\n      throw new Error('missing self peerId')\n    }\n\n    if (client == null) {\n      throw new Error('missing ipfs http client')\n    }\n\n    this._client = client\n    this.peerId = peerId\n\n    // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n    const concurrency = { concurrency: CONCURRENT_HTTP_REQUESTS }\n    this._httpQueue = new PQueue(concurrency)\n    // sometimes refs requests take long time, they need separate queue\n    // to not suffocate regular business\n    this._httpQueueRefs = new PQueue(Object.assign({}, concurrency, {\n      concurrency: 2\n    }))\n\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig()\n\n    log(`enabled DelegatedContentRouting via ${protocol}://${host}:${port}`)\n  }\n\n  /**\n   * Search the dht for providers of the given CID.\n   *\n   * - call `findProviders` on the delegated node.\n   *\n   * @param {CID} key - The CID to find providers for\n   * @param {object} options - Options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @param {number} options.numProviders - How many providers to find, defaults to 20\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} - An async iterable of PeerId/Multiaddrs\n   */\n  async * findProviders (key, options = {}) {\n    log(`findProviders starts: ${key}`)\n    options.timeout = options.timeout || DEFAULT_TIMEOUT\n\n    let providers = 0\n    const onStart = defer()\n    const onFinish = defer()\n\n    this._httpQueue.add(() => {\n      onStart.resolve()\n      return onFinish.promise\n    })\n\n    try {\n      await onStart.promise\n\n      for await (const { id, addrs } of this._client.dht.findProvs(key, {\n        numProviders: options.numProviders,\n        timeout: options.timeout\n      })) {\n        yield {\n          id: PeerId.parse(id),\n          multiaddrs: addrs\n        }\n        providers++\n      }\n    } catch (err) {\n      log.error('findProviders errored:', err)\n      throw err\n    } finally {\n      onFinish.resolve()\n      log(`findProviders finished: ${key} found ${providers} providers`)\n    }\n  }\n\n  /**\n   * Announce to the network that the delegated node can provide the given key.\n   *\n   * Currently this uses the following hack\n   * - delegate is one of bootstrap nodes, so we are always connected to it\n   * - call block stat on the delegated node, so it fetches the content\n   * - call dht provide with the passed cid\n   *\n   * N.B. this must be called for every block in the dag you want provided otherwise\n   * the delegate will only be able to supply the root block of the dag when asked\n   * for the data by an interested peer.\n   *\n   * @param {CID} key - The delegate will publish a provider record for this CID\n   * @returns {Promise<void>}\n   */\n  async provide (key) {\n    log(`provide starts: ${key}`)\n    await this._httpQueueRefs.add(async () => {\n      await this._client.block.stat(key)\n      await drain(this._client.dht.provide(key))\n    })\n    log(`provide finished: ${key}`)\n  }\n}\n\nmodule.exports = DelegatedContentRouting\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}