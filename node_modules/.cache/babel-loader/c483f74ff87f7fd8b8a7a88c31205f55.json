{"ast":null,"code":"'use strict';\n\nconst filter = require('it-filter');\n\nconst pushable = require('it-pushable');\n\nconst drain = require('it-drain');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst errCode = require('err-code');\n\nconst {\n  identity\n} = require('multiformats/hashes/identity');\n/**\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} DatastoreOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n *\n * @param {Blockstore} blockstore\n */\n\n\nmodule.exports = createIdStore;\n/**\n * @param {Blockstore} store\n * @returns {Blockstore}\n */\n\nfunction createIdStore(store) {\n  return {\n    open() {\n      return store.open();\n    },\n\n    close() {\n      return store.close();\n    },\n\n    query(query, options) {\n      return store.query(query, options);\n    },\n\n    queryKeys(query, options) {\n      return store.queryKeys(query, options);\n    },\n\n    async get(cid, options) {\n      const extracted = extractContents(cid);\n\n      if (extracted.isIdentity) {\n        return Promise.resolve(extracted.digest);\n      }\n\n      return store.get(cid, options);\n    },\n\n    async *getMany(cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options);\n      }\n    },\n\n    async put(cid, buf, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return;\n      }\n\n      await store.put(cid, buf, options);\n    },\n\n    async *putMany(pairs, options) {\n      // in order to return all blocks. we're going to assemble a seperate iterable\n      // return rather than return the resolves of store.putMany using the same\n      // process used by blockstore.putMany\n      const output = pushable(); // process.nextTick runs on the microtask queue, setImmediate runs on the next\n      // event loop iteration so is slower. Use process.nextTick if it is available.\n\n      const runner = process && process.nextTick ? process.nextTick : setImmediate;\n      runner(async () => {\n        try {\n          await drain(store.putMany(async function* () {\n            for await (const {\n              key,\n              value\n            } of pairs) {\n              if (!extractContents(key).isIdentity) {\n                yield {\n                  key,\n                  value\n                };\n              } // if non identity blocks successfully write, blocks are included in output\n\n\n              output.push({\n                key,\n                value\n              });\n            }\n          }()));\n          output.end();\n        } catch (err) {\n          output.end(err);\n        }\n      });\n      yield* output;\n    },\n\n    has(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return Promise.resolve(true);\n      }\n\n      return store.has(cid, options);\n    },\n\n    delete(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return Promise.resolve();\n      }\n\n      return store.delete(cid, options);\n    },\n\n    deleteMany(cids, options) {\n      return store.deleteMany(filter(cids, cid => !extractContents(cid).isIdentity), options);\n    },\n\n    batch() {\n      const batch = store.batch();\n      return {\n        put(cid, buf) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n\n          if (isIdentity) {\n            return;\n          }\n\n          batch.put(cid, buf);\n        },\n\n        delete(cid) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n\n          if (isIdentity) {\n            return;\n          }\n\n          batch.delete(cid);\n        },\n\n        commit: options => {\n          return batch.commit(options);\n        }\n      };\n    }\n\n  };\n}\n/**\n * @param {CID} k\n * @returns {{ isIdentity: false } | { isIdentity: true, digest: Uint8Array}}\n */\n\n\nfunction extractContents(k) {\n  const cid = CID.asCID(k);\n\n  if (cid == null) {\n    throw errCode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n  }\n\n  if (cid.multihash.code !== identity.code) {\n    return {\n      isIdentity: false\n    };\n  }\n\n  return {\n    isIdentity: true,\n    digest: cid.multihash.digest\n  };\n}","map":{"version":3,"names":["filter","require","pushable","drain","CID","errCode","identity","module","exports","createIdStore","store","open","close","query","options","queryKeys","get","cid","extracted","extractContents","isIdentity","Promise","resolve","digest","getMany","cids","put","buf","putMany","pairs","output","runner","process","nextTick","setImmediate","key","value","push","end","err","has","delete","deleteMany","batch","commit","k","asCID","Error","multihash","code"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-repo/src/idstore.js"],"sourcesContent":["'use strict'\n\nconst filter = require('it-filter')\nconst pushable = require('it-pushable')\nconst drain = require('it-drain')\nconst { CID } = require('multiformats/cid')\nconst errCode = require('err-code')\nconst { identity } = require('multiformats/hashes/identity')\n\n/**\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} DatastoreOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n *\n * @param {Blockstore} blockstore\n */\nmodule.exports = createIdStore\n\n/**\n * @param {Blockstore} store\n * @returns {Blockstore}\n */\nfunction createIdStore (store) {\n  return {\n    open () {\n      return store.open()\n    },\n\n    close () {\n      return store.close()\n    },\n\n    query (query, options) {\n      return store.query(query, options)\n    },\n\n    queryKeys (query, options) {\n      return store.queryKeys(query, options)\n    },\n\n    async get (cid, options) {\n      const extracted = extractContents(cid)\n      if (extracted.isIdentity) {\n        return Promise.resolve(extracted.digest)\n      }\n      return store.get(cid, options)\n    },\n\n    async * getMany (cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options)\n      }\n    },\n\n    async put (cid, buf, options) {\n      const { isIdentity } = extractContents(cid)\n\n      if (isIdentity) {\n        return\n      }\n\n      await store.put(cid, buf, options)\n    },\n\n    async * putMany (pairs, options) {\n      // in order to return all blocks. we're going to assemble a seperate iterable\n      // return rather than return the resolves of store.putMany using the same\n      // process used by blockstore.putMany\n      const output = pushable()\n\n      // process.nextTick runs on the microtask queue, setImmediate runs on the next\n      // event loop iteration so is slower. Use process.nextTick if it is available.\n      const runner = process && process.nextTick ? process.nextTick : setImmediate\n\n      runner(async () => {\n        try {\n          await drain(store.putMany(async function * () {\n            for await (const { key, value } of pairs) {\n              if (!extractContents(key).isIdentity) {\n                yield { key, value }\n              }\n\n              // if non identity blocks successfully write, blocks are included in output\n              output.push({ key, value })\n            }\n          }()))\n\n          output.end()\n        } catch (err) {\n          output.end(err)\n        }\n      })\n\n      yield * output\n    },\n\n    has (cid, options) {\n      const { isIdentity } = extractContents(cid)\n      if (isIdentity) {\n        return Promise.resolve(true)\n      }\n      return store.has(cid, options)\n    },\n\n    delete (cid, options) {\n      const { isIdentity } = extractContents(cid)\n      if (isIdentity) {\n        return Promise.resolve()\n      }\n      return store.delete(cid, options)\n    },\n\n    deleteMany (cids, options) {\n      return store.deleteMany(filter(cids, (cid) => !extractContents(cid).isIdentity), options)\n    },\n\n    batch () {\n      const batch = store.batch()\n\n      return {\n        put (cid, buf) {\n          const { isIdentity } = extractContents(cid)\n\n          if (isIdentity) {\n            return\n          }\n\n          batch.put(cid, buf)\n        },\n        delete (cid) {\n          const { isIdentity } = extractContents(cid)\n\n          if (isIdentity) {\n            return\n          }\n\n          batch.delete(cid)\n        },\n        commit: (options) => {\n          return batch.commit(options)\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {CID} k\n * @returns {{ isIdentity: false } | { isIdentity: true, digest: Uint8Array}}\n */\nfunction extractContents (k) {\n  const cid = CID.asCID(k)\n\n  if (cid == null) {\n    throw errCode(new Error('Not a valid cid'), 'ERR_INVALID_CID')\n  }\n\n  if (cid.multihash.code !== identity.code) {\n    return {\n      isIdentity: false\n    }\n  }\n\n  return {\n    isIdentity: true,\n    digest: cid.multihash.digest\n  }\n}\n"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,aAAD,CAAxB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,UAAD,CAArB;;AACA,MAAM;EAAEG;AAAF,IAAUH,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;EAAEK;AAAF,IAAeL,OAAO,CAAC,8BAAD,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AACAM,MAAM,CAACC,OAAP,GAAiBC,aAAjB;AAEA;AACA;AACA;AACA;;AACA,SAASA,aAAT,CAAwBC,KAAxB,EAA+B;EAC7B,OAAO;IACLC,IAAI,GAAI;MACN,OAAOD,KAAK,CAACC,IAAN,EAAP;IACD,CAHI;;IAKLC,KAAK,GAAI;MACP,OAAOF,KAAK,CAACE,KAAN,EAAP;IACD,CAPI;;IASLC,KAAK,CAAEA,KAAF,EAASC,OAAT,EAAkB;MACrB,OAAOJ,KAAK,CAACG,KAAN,CAAYA,KAAZ,EAAmBC,OAAnB,CAAP;IACD,CAXI;;IAaLC,SAAS,CAAEF,KAAF,EAASC,OAAT,EAAkB;MACzB,OAAOJ,KAAK,CAACK,SAAN,CAAgBF,KAAhB,EAAuBC,OAAvB,CAAP;IACD,CAfI;;IAiBL,MAAME,GAAN,CAAWC,GAAX,EAAgBH,OAAhB,EAAyB;MACvB,MAAMI,SAAS,GAAGC,eAAe,CAACF,GAAD,CAAjC;;MACA,IAAIC,SAAS,CAACE,UAAd,EAA0B;QACxB,OAAOC,OAAO,CAACC,OAAR,CAAgBJ,SAAS,CAACK,MAA1B,CAAP;MACD;;MACD,OAAOb,KAAK,CAACM,GAAN,CAAUC,GAAV,EAAeH,OAAf,CAAP;IACD,CAvBI;;IAyBL,OAAQU,OAAR,CAAiBC,IAAjB,EAAuBX,OAAvB,EAAgC;MAC9B,WAAW,MAAMG,GAAjB,IAAwBQ,IAAxB,EAA8B;QAC5B,MAAM,KAAKT,GAAL,CAASC,GAAT,EAAcH,OAAd,CAAN;MACD;IACF,CA7BI;;IA+BL,MAAMY,GAAN,CAAWT,GAAX,EAAgBU,GAAhB,EAAqBb,OAArB,EAA8B;MAC5B,MAAM;QAAEM;MAAF,IAAiBD,eAAe,CAACF,GAAD,CAAtC;;MAEA,IAAIG,UAAJ,EAAgB;QACd;MACD;;MAED,MAAMV,KAAK,CAACgB,GAAN,CAAUT,GAAV,EAAeU,GAAf,EAAoBb,OAApB,CAAN;IACD,CAvCI;;IAyCL,OAAQc,OAAR,CAAiBC,KAAjB,EAAwBf,OAAxB,EAAiC;MAC/B;MACA;MACA;MACA,MAAMgB,MAAM,GAAG5B,QAAQ,EAAvB,CAJ+B,CAM/B;MACA;;MACA,MAAM6B,MAAM,GAAGC,OAAO,IAAIA,OAAO,CAACC,QAAnB,GAA8BD,OAAO,CAACC,QAAtC,GAAiDC,YAAhE;MAEAH,MAAM,CAAC,YAAY;QACjB,IAAI;UACF,MAAM5B,KAAK,CAACO,KAAK,CAACkB,OAAN,CAAc,mBAAoB;YAC5C,WAAW,MAAM;cAAEO,GAAF;cAAOC;YAAP,CAAjB,IAAmCP,KAAnC,EAA0C;cACxC,IAAI,CAACV,eAAe,CAACgB,GAAD,CAAf,CAAqBf,UAA1B,EAAsC;gBACpC,MAAM;kBAAEe,GAAF;kBAAOC;gBAAP,CAAN;cACD,CAHuC,CAKxC;;;cACAN,MAAM,CAACO,IAAP,CAAY;gBAAEF,GAAF;gBAAOC;cAAP,CAAZ;YACD;UACF,CATyB,EAAd,CAAD,CAAX;UAWAN,MAAM,CAACQ,GAAP;QACD,CAbD,CAaE,OAAOC,GAAP,EAAY;UACZT,MAAM,CAACQ,GAAP,CAAWC,GAAX;QACD;MACF,CAjBK,CAAN;MAmBA,OAAQT,MAAR;IACD,CAvEI;;IAyELU,GAAG,CAAEvB,GAAF,EAAOH,OAAP,EAAgB;MACjB,MAAM;QAAEM;MAAF,IAAiBD,eAAe,CAACF,GAAD,CAAtC;;MACA,IAAIG,UAAJ,EAAgB;QACd,OAAOC,OAAO,CAACC,OAAR,CAAgB,IAAhB,CAAP;MACD;;MACD,OAAOZ,KAAK,CAAC8B,GAAN,CAAUvB,GAAV,EAAeH,OAAf,CAAP;IACD,CA/EI;;IAiFL2B,MAAM,CAAExB,GAAF,EAAOH,OAAP,EAAgB;MACpB,MAAM;QAAEM;MAAF,IAAiBD,eAAe,CAACF,GAAD,CAAtC;;MACA,IAAIG,UAAJ,EAAgB;QACd,OAAOC,OAAO,CAACC,OAAR,EAAP;MACD;;MACD,OAAOZ,KAAK,CAAC+B,MAAN,CAAaxB,GAAb,EAAkBH,OAAlB,CAAP;IACD,CAvFI;;IAyFL4B,UAAU,CAAEjB,IAAF,EAAQX,OAAR,EAAiB;MACzB,OAAOJ,KAAK,CAACgC,UAAN,CAAiB1C,MAAM,CAACyB,IAAD,EAAQR,GAAD,IAAS,CAACE,eAAe,CAACF,GAAD,CAAf,CAAqBG,UAAtC,CAAvB,EAA0EN,OAA1E,CAAP;IACD,CA3FI;;IA6FL6B,KAAK,GAAI;MACP,MAAMA,KAAK,GAAGjC,KAAK,CAACiC,KAAN,EAAd;MAEA,OAAO;QACLjB,GAAG,CAAET,GAAF,EAAOU,GAAP,EAAY;UACb,MAAM;YAAEP;UAAF,IAAiBD,eAAe,CAACF,GAAD,CAAtC;;UAEA,IAAIG,UAAJ,EAAgB;YACd;UACD;;UAEDuB,KAAK,CAACjB,GAAN,CAAUT,GAAV,EAAeU,GAAf;QACD,CATI;;QAULc,MAAM,CAAExB,GAAF,EAAO;UACX,MAAM;YAAEG;UAAF,IAAiBD,eAAe,CAACF,GAAD,CAAtC;;UAEA,IAAIG,UAAJ,EAAgB;YACd;UACD;;UAEDuB,KAAK,CAACF,MAAN,CAAaxB,GAAb;QACD,CAlBI;;QAmBL2B,MAAM,EAAG9B,OAAD,IAAa;UACnB,OAAO6B,KAAK,CAACC,MAAN,CAAa9B,OAAb,CAAP;QACD;MArBI,CAAP;IAuBD;;EAvHI,CAAP;AAyHD;AAED;AACA;AACA;AACA;;;AACA,SAASK,eAAT,CAA0B0B,CAA1B,EAA6B;EAC3B,MAAM5B,GAAG,GAAGb,GAAG,CAAC0C,KAAJ,CAAUD,CAAV,CAAZ;;EAEA,IAAI5B,GAAG,IAAI,IAAX,EAAiB;IACf,MAAMZ,OAAO,CAAC,IAAI0C,KAAJ,CAAU,iBAAV,CAAD,EAA+B,iBAA/B,CAAb;EACD;;EAED,IAAI9B,GAAG,CAAC+B,SAAJ,CAAcC,IAAd,KAAuB3C,QAAQ,CAAC2C,IAApC,EAA0C;IACxC,OAAO;MACL7B,UAAU,EAAE;IADP,CAAP;EAGD;;EAED,OAAO;IACLA,UAAU,EAAE,IADP;IAELG,MAAM,EAAEN,GAAG,CAAC+B,SAAJ,CAAczB;EAFjB,CAAP;AAID"},"metadata":{},"sourceType":"script"}