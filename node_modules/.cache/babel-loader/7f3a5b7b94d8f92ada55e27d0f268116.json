{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _assertThisInitialized = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar debug = require('debug');\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar errcode = require('err-code');\n\nvar _require2 = require('it-pipe'),\n    pipe = _require2.pipe;\n\nvar _require3 = require('p-queue'),\n    Queue = _require3.default;\n\nvar MulticodecTopology = require('../topology/multicodec-topology');\n\nvar _require4 = require('./errors'),\n    codes = _require4.codes;\n\nvar _require5 = require('./message/rpc'),\n    RPC = _require5.RPC;\n\nvar PeerStreams = require('./peer-streams');\n\nvar _require6 = require('./signature-policy'),\n    SignaturePolicy = _require6.SignaturePolicy;\n\nvar utils = require('./utils');\n\nvar _require7 = require('./message/sign'),\n    signMessage = _require7.signMessage,\n    verifySignature = _require7.verifySignature;\n/**\n * @typedef {any} Libp2p\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('bl')} BufferList\n * @typedef {import('../stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('../connection/connection')} Connection\n * @typedef {import('./signature-policy').SignaturePolicyType} SignaturePolicyType\n * @typedef {import('./message/rpc').IRPC} IRPC\n * @typedef {import('./message/rpc').RPC.SubOpts} RPCSubOpts\n * @typedef {import('./message/rpc').RPC.Message} RPCMessage\n */\n\n/**\n * @typedef {Object} InMessage\n * @property {string} [from]\n * @property {string} receivedFrom\n * @property {string[]} topicIDs\n * @property {Uint8Array} [seqno]\n * @property {Uint8Array} data\n * @property {Uint8Array} [signature]\n * @property {Uint8Array} [key]\n *\n * @typedef {Object} PubsubProperties\n * @property {string} debugName - log namespace\n * @property {Array<string>|string} multicodecs - protocol identificers to connect\n * @property {Libp2p} libp2p\n *\n * @typedef {Object} PubsubOptions\n * @property {SignaturePolicyType} [globalSignaturePolicy = SignaturePolicy.StrictSign] - defines how signatures should be handled\n * @property {boolean} [canRelayMessage = false] - if can relay messages not subscribed\n * @property {boolean} [emitSelf = false] - if publish should emit to self, if subscribed\n * @property {number} [messageProcessingConcurrency = 10] - handle this many incoming pubsub messages concurrently\n */\n\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n * and specifies the API that pubsub routers should have.\n */\n\n\nvar PubsubBaseProtocol = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(PubsubBaseProtocol, _EventEmitter);\n\n  var _super = _createSuper(PubsubBaseProtocol);\n\n  /**\n   * @param {PubsubProperties & PubsubOptions} props\n   * @abstract\n   */\n  function PubsubBaseProtocol(_ref) {\n    var _this;\n\n    var debugName = _ref.debugName,\n        multicodecs = _ref.multicodecs,\n        libp2p = _ref.libp2p,\n        _ref$globalSignatureP = _ref.globalSignaturePolicy,\n        globalSignaturePolicy = _ref$globalSignatureP === void 0 ? SignaturePolicy.StrictSign : _ref$globalSignatureP,\n        _ref$canRelayMessage = _ref.canRelayMessage,\n        canRelayMessage = _ref$canRelayMessage === void 0 ? false : _ref$canRelayMessage,\n        _ref$emitSelf = _ref.emitSelf,\n        emitSelf = _ref$emitSelf === void 0 ? false : _ref$emitSelf,\n        _ref$messageProcessin = _ref.messageProcessingConcurrency,\n        messageProcessingConcurrency = _ref$messageProcessin === void 0 ? 10 : _ref$messageProcessin;\n\n    _classCallCheck(this, PubsubBaseProtocol);\n\n    if (typeof debugName !== 'string') {\n      throw new Error('a debugname `string` is required');\n    }\n\n    if (!multicodecs) {\n      throw new Error('multicodecs are required');\n    }\n\n    if (!libp2p) {\n      throw new Error('libp2p is required');\n    }\n\n    _this = _super.call(this);\n    _this.log = Object.assign(debug(debugName), {\n      err: debug(\"\".concat(debugName, \":error\"))\n    });\n    /**\n     * @type {Array<string>}\n     */\n\n    _this.multicodecs = utils.ensureArray(multicodecs);\n    _this._libp2p = libp2p;\n    _this.registrar = libp2p.registrar;\n    /**\n     * @type {PeerId}\n     */\n\n    _this.peerId = libp2p.peerId;\n    _this.started = false;\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    _this.topics = new Map();\n    /**\n     * List of our subscriptions\n     *\n     * @type {Set<string>}\n     */\n\n    _this.subscriptions = new Set();\n    /**\n     * Map of peer streams\n     *\n     * @type {Map<string, import('./peer-streams')>}\n     */\n\n    _this.peers = new Map(); // validate signature policy\n\n    if (!SignaturePolicy[globalSignaturePolicy]) {\n      throw errcode(new Error('Invalid global signature policy'), codes.ERR_INVALID_SIGNATURE_POLICY);\n    }\n    /**\n     * The signature policy to follow by default\n     *\n     * @type {string}\n     */\n\n\n    _this.globalSignaturePolicy = globalSignaturePolicy;\n    /**\n     * If router can relay received messages, even if not subscribed\n     *\n     * @type {boolean}\n     */\n\n    _this.canRelayMessage = canRelayMessage;\n    /**\n     * if publish should emit to self, if subscribed\n     *\n     * @type {boolean}\n     */\n\n    _this.emitSelf = emitSelf;\n    /**\n     * Topic validator function\n     *\n     * @typedef {function(string, InMessage): Promise<void>} validator\n     */\n\n    /**\n     * Topic validator map\n     *\n     * Keyed by topic\n     * Topic validators are functions with the following input:\n     *\n     * @type {Map<string, validator>}\n     */\n\n    _this.topicValidators = new Map();\n    /**\n     * @type {Queue}\n     */\n\n    _this.queue = new Queue({\n      concurrency: messageProcessingConcurrency\n    });\n    _this._registrarId = undefined;\n    _this._onIncomingStream = _this._onIncomingStream.bind(_assertThisInitialized(_this));\n    _this._onPeerConnected = _this._onPeerConnected.bind(_assertThisInitialized(_this));\n    _this._onPeerDisconnected = _this._onPeerDisconnected.bind(_assertThisInitialized(_this));\n    return _this;\n  } // LIFECYCLE METHODS\n\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   *\n   * @returns {void}\n   */\n\n\n  _createClass(PubsubBaseProtocol, [{\n    key: \"start\",\n    value: function start() {\n      if (this.started) {\n        return;\n      }\n\n      this.log('starting'); // Incoming streams\n      // Called after a peer dials us\n\n      this.registrar.handle(this.multicodecs, this._onIncomingStream); // register protocol with topology\n      // Topology callbacks called on connection manager changes\n\n      var topology = new MulticodecTopology({\n        multicodecs: this.multicodecs,\n        handlers: {\n          onConnect: this._onPeerConnected,\n          onDisconnect: this._onPeerDisconnected\n        }\n      });\n      this._registrarId = this.registrar.register(topology);\n      this.log('started');\n      this.started = true;\n    }\n    /**\n     * Unregister the pubsub protocol and the streams with other peers will be closed.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this.started) {\n        return;\n      } // unregister protocol and handlers\n\n\n      this.registrar.unregister(this._registrarId);\n      this.log('stopping');\n      this.peers.forEach(function (peerStreams) {\n        return peerStreams.close();\n      });\n      this.peers = new Map();\n      this.subscriptions = new Set();\n      this.started = false;\n      this.log('stopped');\n    }\n    /**\n     * On an inbound stream opened.\n     *\n     * @protected\n     * @param {Object} props\n     * @param {string} props.protocol\n     * @param {MuxedStream} props.stream\n     * @param {Connection} props.connection - connection\n     */\n\n  }, {\n    key: \"_onIncomingStream\",\n    value: function _onIncomingStream(_ref2) {\n      var protocol = _ref2.protocol,\n          stream = _ref2.stream,\n          connection = _ref2.connection;\n      var peerId = connection.remotePeer;\n      var idB58Str = peerId.toB58String();\n\n      var peer = this._addPeer(peerId, protocol);\n\n      var inboundStream = peer.attachInboundStream(stream);\n\n      this._processMessages(idB58Str, inboundStream, peer);\n    }\n    /**\n     * Registrar notifies an established connection with pubsub protocol.\n     *\n     * @protected\n     * @param {PeerId} peerId - remote peer-id\n     * @param {Connection} conn - connection to the peer\n     */\n\n  }, {\n    key: \"_onPeerConnected\",\n    value: function () {\n      var _onPeerConnected2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(peerId, conn) {\n        var idB58Str, _yield$conn$newStream, stream, protocol, peer;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                idB58Str = peerId.toB58String();\n                this.log('connected', idB58Str);\n                _context.prev = 2;\n                _context.next = 5;\n                return conn.newStream(this.multicodecs);\n\n              case 5:\n                _yield$conn$newStream = _context.sent;\n                stream = _yield$conn$newStream.stream;\n                protocol = _yield$conn$newStream.protocol;\n                peer = this._addPeer(peerId, protocol);\n                _context.next = 11;\n                return peer.attachOutboundStream(stream);\n\n              case 11:\n                _context.next = 16;\n                break;\n\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](2);\n                this.log.err(_context.t0);\n\n              case 16:\n                // Immediately send my own subscriptions to the newly established conn\n                this._sendSubscriptions(idB58Str, Array.from(this.subscriptions), true);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 13]]);\n      }));\n\n      function _onPeerConnected(_x, _x2) {\n        return _onPeerConnected2.apply(this, arguments);\n      }\n\n      return _onPeerConnected;\n    }()\n    /**\n     * Registrar notifies a closing connection with pubsub protocol.\n     *\n     * @protected\n     * @param {PeerId} peerId - peerId\n     * @param {Error} [err] - error for connection end\n     */\n\n  }, {\n    key: \"_onPeerDisconnected\",\n    value: function _onPeerDisconnected(peerId, err) {\n      var idB58Str = peerId.toB58String();\n      this.log('connection ended', idB58Str, err ? err.message : '');\n\n      this._removePeer(peerId);\n    }\n    /**\n     * Notifies the router that a peer has been connected\n     *\n     * @protected\n     * @param {PeerId} peerId\n     * @param {string} protocol\n     * @returns {PeerStreams}\n     */\n\n  }, {\n    key: \"_addPeer\",\n    value: function _addPeer(peerId, protocol) {\n      var _this2 = this;\n\n      var id = peerId.toB58String();\n      var existing = this.peers.get(id); // If peer streams already exists, do nothing\n\n      if (existing) {\n        return existing;\n      } // else create a new peer streams\n\n\n      this.log('new peer', id);\n      var peerStreams = new PeerStreams({\n        id: peerId,\n        protocol: protocol\n      });\n      this.peers.set(id, peerStreams);\n      peerStreams.once('close', function () {\n        return _this2._removePeer(peerId);\n      });\n      return peerStreams;\n    }\n    /**\n     * Notifies the router that a peer has been disconnected.\n     *\n     * @protected\n     * @param {PeerId} peerId\n     * @returns {PeerStreams | undefined}\n     */\n\n  }, {\n    key: \"_removePeer\",\n    value: function _removePeer(peerId) {\n      if (!peerId) return;\n      var id = peerId.toB58String();\n      var peerStreams = this.peers.get(id);\n      if (!peerStreams) return; // close peer streams\n\n      peerStreams.removeAllListeners();\n      peerStreams.close(); // delete peer streams\n\n      this.log('delete peer', id);\n      this.peers.delete(id); // remove peer from topics map\n\n      var _iterator2 = _createForOfIteratorHelper(this.topics.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var peers = _step2.value;\n          peers.delete(id);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return peerStreams;\n    } // MESSAGE METHODS\n\n    /**\n     * Responsible for processing each RPC message received by other peers.\n     *\n     * @param {string} idB58Str - peer id string in base58\n     * @param {AsyncIterable<Uint8Array|BufferList>} stream - inbound stream\n     * @param {PeerStreams} peerStreams - PubSub peer\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_processMessages\",\n    value: function () {\n      var _processMessages2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(idB58Str, stream, peerStreams) {\n        var _this3 = this;\n\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                _context4.next = 3;\n                return pipe(stream, /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(source) {\n                    var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;\n\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            _iteratorAbruptCompletion = false;\n                            _didIteratorError = false;\n                            _context3.prev = 2;\n\n                            _loop = function _loop() {\n                              var data = _step.value;\n                              var rpcBytes = data instanceof Uint8Array ? data : data.slice();\n\n                              var rpcMsg = _this3._decodeRpc(rpcBytes) // Since _processRpc may be overridden entirely in unsafe ways,\n                              // the simplest/safest option here is to wrap in a function and capture all errors\n                              // to prevent a top-level unhandled exception\n                              // This processing of rpc messages should happen without awaiting full validation/execution of prior messages\n                              ;\n\n                              _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                                return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                                  while (1) {\n                                    switch (_context2.prev = _context2.next) {\n                                      case 0:\n                                        _context2.prev = 0;\n                                        _context2.next = 3;\n                                        return _this3._processRpc(idB58Str, peerStreams, rpcMsg);\n\n                                      case 3:\n                                        _context2.next = 8;\n                                        break;\n\n                                      case 5:\n                                        _context2.prev = 5;\n                                        _context2.t0 = _context2[\"catch\"](0);\n\n                                        _this3.log.err(_context2.t0);\n\n                                      case 8:\n                                      case \"end\":\n                                        return _context2.stop();\n                                    }\n                                  }\n                                }, _callee2, null, [[0, 5]]);\n                              }))();\n                            };\n\n                            _iterator = _asyncIterator(source);\n\n                          case 5:\n                            _context3.next = 7;\n                            return _iterator.next();\n\n                          case 7:\n                            if (!(_iteratorAbruptCompletion = !(_step = _context3.sent).done)) {\n                              _context3.next = 12;\n                              break;\n                            }\n\n                            _loop();\n\n                          case 9:\n                            _iteratorAbruptCompletion = false;\n                            _context3.next = 5;\n                            break;\n\n                          case 12:\n                            _context3.next = 18;\n                            break;\n\n                          case 14:\n                            _context3.prev = 14;\n                            _context3.t0 = _context3[\"catch\"](2);\n                            _didIteratorError = true;\n                            _iteratorError = _context3.t0;\n\n                          case 18:\n                            _context3.prev = 18;\n                            _context3.prev = 19;\n\n                            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                              _context3.next = 23;\n                              break;\n                            }\n\n                            _context3.next = 23;\n                            return _iterator.return();\n\n                          case 23:\n                            _context3.prev = 23;\n\n                            if (!_didIteratorError) {\n                              _context3.next = 26;\n                              break;\n                            }\n\n                            throw _iteratorError;\n\n                          case 26:\n                            return _context3.finish(23);\n\n                          case 27:\n                            return _context3.finish(18);\n\n                          case 28:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3, null, [[2, 14, 18, 28], [19,, 23, 27]]);\n                  }));\n\n                  return function (_x6) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }());\n\n              case 3:\n                _context4.next = 8;\n                break;\n\n              case 5:\n                _context4.prev = 5;\n                _context4.t0 = _context4[\"catch\"](0);\n\n                this._onPeerDisconnected(peerStreams.id, _context4.t0);\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 5]]);\n      }));\n\n      function _processMessages(_x3, _x4, _x5) {\n        return _processMessages2.apply(this, arguments);\n      }\n\n      return _processMessages;\n    }()\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @param {string} idB58Str\n     * @param {PeerStreams} peerStreams\n     * @param {RPC} rpc\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: \"_processRpc\",\n    value: function () {\n      var _processRpc2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(idB58Str, peerStreams, rpc) {\n        var _this4 = this;\n\n        var subs, msgs;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this.log('rpc from', idB58Str);\n                subs = rpc.subscriptions;\n                msgs = rpc.msgs;\n\n                if (subs.length) {\n                  // update peer subscriptions\n                  subs.forEach(function (subOpt) {\n                    _this4._processRpcSubOpt(idB58Str, subOpt);\n                  });\n                  this.emit('pubsub:subscription-change', peerStreams.id, subs);\n                }\n\n                if (this._acceptFrom(idB58Str)) {\n                  _context6.next = 7;\n                  break;\n                }\n\n                this.log('received message from unacceptable peer %s', idB58Str);\n                return _context6.abrupt(\"return\", false);\n\n              case 7:\n                if (msgs.length) {\n                  this.queue.addAll(msgs.map(function (message) {\n                    return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n                      var msg;\n                      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                        while (1) {\n                          switch (_context5.prev = _context5.next) {\n                            case 0:\n                              if (_this4.canRelayMessage || message.topicIDs && message.topicIDs.some(function (topic) {\n                                return _this4.subscriptions.has(topic);\n                              })) {\n                                _context5.next = 3;\n                                break;\n                              }\n\n                              _this4.log('received message we didn\\'t subscribe to. Dropping.');\n\n                              return _context5.abrupt(\"return\");\n\n                            case 3:\n                              _context5.prev = 3;\n                              msg = utils.normalizeInRpcMessage(message, idB58Str);\n                              _context5.next = 7;\n                              return _this4._processRpcMessage(msg);\n\n                            case 7:\n                              _context5.next = 12;\n                              break;\n\n                            case 9:\n                              _context5.prev = 9;\n                              _context5.t0 = _context5[\"catch\"](3);\n\n                              _this4.log.err(_context5.t0);\n\n                            case 12:\n                            case \"end\":\n                              return _context5.stop();\n                          }\n                        }\n                      }, _callee5, null, [[3, 9]]);\n                    }));\n                  }));\n                }\n\n                return _context6.abrupt(\"return\", true);\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _processRpc(_x7, _x8, _x9) {\n        return _processRpc2.apply(this, arguments);\n      }\n\n      return _processRpc;\n    }()\n    /**\n     * Handles a subscription change from a peer\n     *\n     * @param {string} id\n     * @param {RPC.ISubOpts} subOpt\n     */\n\n  }, {\n    key: \"_processRpcSubOpt\",\n    value: function _processRpcSubOpt(id, subOpt) {\n      var t = subOpt.topicID;\n\n      if (!t) {\n        return;\n      }\n\n      var topicSet = this.topics.get(t);\n\n      if (!topicSet) {\n        topicSet = new Set();\n        this.topics.set(t, topicSet);\n      }\n\n      if (subOpt.subscribe) {\n        // subscribe peer to new topic\n        topicSet.add(id);\n      } else {\n        // unsubscribe from existing topic\n        topicSet.delete(id);\n      }\n    }\n    /**\n     * Handles an message from a peer\n     *\n     * @param {InMessage} msg\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_processRpcMessage\",\n    value: function () {\n      var _processRpcMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(msg) {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(this.peerId.toB58String() === msg.from && !this.emitSelf)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\");\n\n              case 2:\n                _context7.prev = 2;\n                _context7.next = 5;\n                return this.validate(msg);\n\n              case 5:\n                _context7.next = 11;\n                break;\n\n              case 7:\n                _context7.prev = 7;\n                _context7.t0 = _context7[\"catch\"](2);\n                this.log('Message is invalid, dropping it. %O', _context7.t0);\n                return _context7.abrupt(\"return\");\n\n              case 11:\n                // Emit to self\n                this._emitMessage(msg);\n\n                return _context7.abrupt(\"return\", this._publish(utils.normalizeOutRpcMessage(msg)));\n\n              case 13:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[2, 7]]);\n      }));\n\n      function _processRpcMessage(_x10) {\n        return _processRpcMessage2.apply(this, arguments);\n      }\n\n      return _processRpcMessage;\n    }()\n    /**\n     * Emit a message from a peer\n     *\n     * @param {InMessage} message\n     */\n\n  }, {\n    key: \"_emitMessage\",\n    value: function _emitMessage(message) {\n      var _this5 = this;\n\n      message.topicIDs.forEach(function (topic) {\n        if (_this5.subscriptions.has(topic)) {\n          _this5.emit(topic, message);\n        }\n      });\n    }\n    /**\n     * The default msgID implementation\n     * Child class can override this.\n     *\n     * @param {InMessage} msg - the message object\n     * @returns {Promise<Uint8Array> | Uint8Array} message id as bytes\n     */\n\n  }, {\n    key: \"getMsgId\",\n    value: function getMsgId(msg) {\n      var signaturePolicy = this.globalSignaturePolicy;\n\n      switch (signaturePolicy) {\n        case SignaturePolicy.StrictSign:\n          // @ts-ignore seqno is optional in protobuf definition but it will exist\n          return utils.msgId(msg.from, msg.seqno);\n\n        case SignaturePolicy.StrictNoSign:\n          return utils.noSignMsgId(msg.data);\n\n        default:\n          throw errcode(new Error('Cannot get message id: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);\n      }\n    }\n    /**\n     * Whether to accept a message from a peer\n     * Override to create a graylist\n     *\n     * @param {string} id\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"_acceptFrom\",\n    value: function _acceptFrom(id) {\n      return true;\n    }\n    /**\n     * Decode Uint8Array into an RPC object.\n     * This can be override to use a custom router protobuf.\n     *\n     * @param {Uint8Array} bytes\n     * @returns {RPC}\n     */\n\n  }, {\n    key: \"_decodeRpc\",\n    value: function _decodeRpc(bytes) {\n      return RPC.decode(bytes);\n    }\n    /**\n     * Encode RPC object into a Uint8Array.\n     * This can be override to use a custom router protobuf.\n     *\n     * @param {IRPC} rpc\n     * @returns {Uint8Array}\n     */\n\n  }, {\n    key: \"_encodeRpc\",\n    value: function _encodeRpc(rpc) {\n      return RPC.encode(rpc).finish();\n    }\n    /**\n     * Send an rpc object to a peer\n     *\n     * @param {string} id - peer id\n     * @param {IRPC} rpc\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_sendRpc\",\n    value: function _sendRpc(id, rpc) {\n      var peerStreams = this.peers.get(id);\n\n      if (!peerStreams || !peerStreams.isWritable) {\n        var msg = \"Cannot send RPC to \".concat(id, \" as there is no open stream to it available\");\n        this.log.err(msg);\n        return;\n      }\n\n      peerStreams.write(this._encodeRpc(rpc));\n    }\n    /**\n     * Send subscroptions to a peer\n     *\n     * @param {string} id - peer id\n     * @param {string[]} topics\n     * @param {boolean} subscribe - set to false for unsubscriptions\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_sendSubscriptions\",\n    value: function _sendSubscriptions(id, topics, subscribe) {\n      return this._sendRpc(id, {\n        subscriptions: topics.map(function (t) {\n          return {\n            topicID: t,\n            subscribe: subscribe\n          };\n        })\n      });\n    }\n    /**\n     * Validates the given message. The signature will be checked for authenticity.\n     * Throws an error on invalid messages\n     *\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"validate\",\n    value: function () {\n      var _validate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(message) {\n        var signaturePolicy, _iterator3, _step3, topic, validatorFn;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                // eslint-disable-line require-await\n                signaturePolicy = this.globalSignaturePolicy;\n                _context8.t0 = signaturePolicy;\n                _context8.next = _context8.t0 === SignaturePolicy.StrictNoSign ? 4 : _context8.t0 === SignaturePolicy.StrictSign ? 13 : 22;\n                break;\n\n              case 4:\n                if (!message.from) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                throw errcode(new Error('StrictNoSigning: from should not be present'), codes.ERR_UNEXPECTED_FROM);\n\n              case 6:\n                if (!message.signature) {\n                  _context8.next = 8;\n                  break;\n                }\n\n                throw errcode(new Error('StrictNoSigning: signature should not be present'), codes.ERR_UNEXPECTED_SIGNATURE);\n\n              case 8:\n                if (!message.key) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                throw errcode(new Error('StrictNoSigning: key should not be present'), codes.ERR_UNEXPECTED_KEY);\n\n              case 10:\n                if (!message.seqno) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                throw errcode(new Error('StrictNoSigning: seqno should not be present'), codes.ERR_UNEXPECTED_SEQNO);\n\n              case 12:\n                return _context8.abrupt(\"break\", 23);\n\n              case 13:\n                if (message.signature) {\n                  _context8.next = 15;\n                  break;\n                }\n\n                throw errcode(new Error('StrictSigning: Signing required and no signature was present'), codes.ERR_MISSING_SIGNATURE);\n\n              case 15:\n                if (message.seqno) {\n                  _context8.next = 17;\n                  break;\n                }\n\n                throw errcode(new Error('StrictSigning: Signing required and no seqno was present'), codes.ERR_MISSING_SEQNO);\n\n              case 17:\n                _context8.next = 19;\n                return verifySignature(message);\n\n              case 19:\n                if (_context8.sent) {\n                  _context8.next = 21;\n                  break;\n                }\n\n                throw errcode(new Error('StrictSigning: Invalid message signature'), codes.ERR_INVALID_SIGNATURE);\n\n              case 21:\n                return _context8.abrupt(\"break\", 23);\n\n              case 22:\n                throw errcode(new Error('Cannot validate message: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);\n\n              case 23:\n                _iterator3 = _createForOfIteratorHelper(message.topicIDs);\n                _context8.prev = 24;\n\n                _iterator3.s();\n\n              case 26:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context8.next = 34;\n                  break;\n                }\n\n                topic = _step3.value;\n                validatorFn = this.topicValidators.get(topic);\n\n                if (!validatorFn) {\n                  _context8.next = 32;\n                  break;\n                }\n\n                _context8.next = 32;\n                return validatorFn(topic, message);\n\n              case 32:\n                _context8.next = 26;\n                break;\n\n              case 34:\n                _context8.next = 39;\n                break;\n\n              case 36:\n                _context8.prev = 36;\n                _context8.t1 = _context8[\"catch\"](24);\n\n                _iterator3.e(_context8.t1);\n\n              case 39:\n                _context8.prev = 39;\n\n                _iterator3.f();\n\n                return _context8.finish(39);\n\n              case 42:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[24, 36, 39, 42]]);\n      }));\n\n      function validate(_x11) {\n        return _validate.apply(this, arguments);\n      }\n\n      return validate;\n    }()\n    /**\n     * Normalizes the message and signs it, if signing is enabled.\n     * Should be used by the routers to create the message to send.\n     *\n     * @protected\n     * @param {InMessage} message\n     * @returns {Promise<InMessage>}\n     */\n\n  }, {\n    key: \"_buildMessage\",\n    value: function _buildMessage(message) {\n      var signaturePolicy = this.globalSignaturePolicy;\n\n      switch (signaturePolicy) {\n        case SignaturePolicy.StrictSign:\n          message.from = this.peerId.toB58String();\n          message.seqno = utils.randomSeqno();\n          return signMessage(this.peerId, message);\n\n        case SignaturePolicy.StrictNoSign:\n          return Promise.resolve(message);\n\n        default:\n          throw errcode(new Error('Cannot build message: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);\n      }\n    } // API METHODS\n\n    /**\n     * Get a list of the peer-ids that are subscribed to one topic.\n     *\n     * @param {string} topic\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"getSubscribers\",\n    value: function getSubscribers(topic) {\n      if (!this.started) {\n        throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET');\n      }\n\n      if (!topic || typeof topic !== 'string') {\n        throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC');\n      }\n\n      var peersInTopic = this.topics.get(topic);\n\n      if (!peersInTopic) {\n        return [];\n      }\n\n      return Array.from(peersInTopic);\n    }\n    /**\n     * Publishes messages to all subscribed peers\n     *\n     * @param {string} topic\n     * @param {Uint8Array} message\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"publish\",\n    value: function () {\n      var _publish2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(topic, message) {\n        var from, msgObject, outMsg, msg;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (this.started) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                throw new Error('Pubsub has not started');\n\n              case 2:\n                this.log('publish', topic, message);\n                from = this.peerId.toB58String();\n                msgObject = {\n                  receivedFrom: from,\n                  data: message,\n                  topicIDs: [topic]\n                }; // ensure that the message follows the signature policy\n\n                _context9.next = 7;\n                return this._buildMessage(msgObject);\n\n              case 7:\n                outMsg = _context9.sent;\n                // @ts-ignore different type as from is converted\n                msg = utils.normalizeInRpcMessage(outMsg); // Emit to self if I'm interested and emitSelf enabled\n\n                this.emitSelf && this._emitMessage(msg); // send to all the other peers\n\n                _context9.next = 12;\n                return this._publish(msg);\n\n              case 12:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function publish(_x12, _x13) {\n        return _publish2.apply(this, arguments);\n      }\n\n      return publish;\n    }()\n    /**\n     * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n     *\n     * @abstract\n     * @param {InMessage|RPCMessage} message\n     * @returns {Promise<void>}\n     *\n     */\n\n  }, {\n    key: \"_publish\",\n    value: function _publish(message) {\n      throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Subscribes to a given topic.\n     *\n     * @abstract\n     * @param {string} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(topic) {\n      var _this6 = this;\n\n      if (!this.started) {\n        throw new Error('Pubsub has not started');\n      }\n\n      if (!this.subscriptions.has(topic)) {\n        this.subscriptions.add(topic);\n        this.peers.forEach(function (_, id) {\n          return _this6._sendSubscriptions(id, [topic], true);\n        });\n      }\n    }\n    /**\n     * Unsubscribe from the given topic.\n     *\n     * @param {string} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(topic) {\n      var _this7 = this;\n\n      if (!this.started) {\n        throw new Error('Pubsub is not started');\n      }\n\n      if (this.subscriptions.has(topic) && this.listenerCount(topic) === 0) {\n        this.subscriptions.delete(topic);\n        this.peers.forEach(function (_, id) {\n          return _this7._sendSubscriptions(id, [topic], false);\n        });\n      }\n    }\n    /**\n     * Get the list of topics which the peer is subscribed to.\n     *\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"getTopics\",\n    value: function getTopics() {\n      if (!this.started) {\n        throw new Error('Pubsub is not started');\n      }\n\n      return Array.from(this.subscriptions);\n    }\n  }]);\n\n  return PubsubBaseProtocol;\n}(EventEmitter);\n\nPubsubBaseProtocol.utils = utils;\nPubsubBaseProtocol.SignaturePolicy = SignaturePolicy;\nmodule.exports = PubsubBaseProtocol;","map":{"version":3,"names":["debug","require","EventEmitter","errcode","pipe","Queue","default","MulticodecTopology","codes","RPC","PeerStreams","SignaturePolicy","utils","signMessage","verifySignature","PubsubBaseProtocol","debugName","multicodecs","libp2p","globalSignaturePolicy","StrictSign","canRelayMessage","emitSelf","messageProcessingConcurrency","Error","log","Object","assign","err","ensureArray","_libp2p","registrar","peerId","started","topics","Map","subscriptions","Set","peers","ERR_INVALID_SIGNATURE_POLICY","topicValidators","queue","concurrency","_registrarId","undefined","_onIncomingStream","bind","_onPeerConnected","_onPeerDisconnected","handle","topology","handlers","onConnect","onDisconnect","register","unregister","forEach","peerStreams","close","protocol","stream","connection","remotePeer","idB58Str","toB58String","peer","_addPeer","inboundStream","attachInboundStream","_processMessages","conn","newStream","attachOutboundStream","_sendSubscriptions","Array","from","message","_removePeer","id","existing","get","set","once","removeAllListeners","delete","values","source","data","rpcBytes","Uint8Array","slice","rpcMsg","_decodeRpc","_processRpc","rpc","subs","msgs","length","subOpt","_processRpcSubOpt","emit","_acceptFrom","addAll","map","topicIDs","some","topic","has","msg","normalizeInRpcMessage","_processRpcMessage","t","topicID","topicSet","subscribe","add","validate","_emitMessage","_publish","normalizeOutRpcMessage","signaturePolicy","msgId","seqno","StrictNoSign","noSignMsgId","ERR_UNHANDLED_SIGNATURE_POLICY","bytes","decode","encode","finish","isWritable","write","_encodeRpc","_sendRpc","ERR_UNEXPECTED_FROM","signature","ERR_UNEXPECTED_SIGNATURE","key","ERR_UNEXPECTED_KEY","ERR_UNEXPECTED_SEQNO","ERR_MISSING_SIGNATURE","ERR_MISSING_SEQNO","ERR_INVALID_SIGNATURE","validatorFn","randomSeqno","Promise","resolve","peersInTopic","msgObject","receivedFrom","_buildMessage","outMsg","_","listenerCount","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-interfaces/src/pubsub/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst { EventEmitter } = require('events')\nconst errcode = require('err-code')\n\nconst { pipe } = require('it-pipe')\nconst { default: Queue } = require('p-queue')\n\nconst MulticodecTopology = require('../topology/multicodec-topology')\nconst { codes } = require('./errors')\n\nconst { RPC } = require('./message/rpc')\nconst PeerStreams = require('./peer-streams')\nconst { SignaturePolicy } = require('./signature-policy')\nconst utils = require('./utils')\n\nconst {\n  signMessage,\n  verifySignature\n} = require('./message/sign')\n\n/**\n * @typedef {any} Libp2p\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('bl')} BufferList\n * @typedef {import('../stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('../connection/connection')} Connection\n * @typedef {import('./signature-policy').SignaturePolicyType} SignaturePolicyType\n * @typedef {import('./message/rpc').IRPC} IRPC\n * @typedef {import('./message/rpc').RPC.SubOpts} RPCSubOpts\n * @typedef {import('./message/rpc').RPC.Message} RPCMessage\n */\n\n/**\n * @typedef {Object} InMessage\n * @property {string} [from]\n * @property {string} receivedFrom\n * @property {string[]} topicIDs\n * @property {Uint8Array} [seqno]\n * @property {Uint8Array} data\n * @property {Uint8Array} [signature]\n * @property {Uint8Array} [key]\n *\n * @typedef {Object} PubsubProperties\n * @property {string} debugName - log namespace\n * @property {Array<string>|string} multicodecs - protocol identificers to connect\n * @property {Libp2p} libp2p\n *\n * @typedef {Object} PubsubOptions\n * @property {SignaturePolicyType} [globalSignaturePolicy = SignaturePolicy.StrictSign] - defines how signatures should be handled\n * @property {boolean} [canRelayMessage = false] - if can relay messages not subscribed\n * @property {boolean} [emitSelf = false] - if publish should emit to self, if subscribed\n * @property {number} [messageProcessingConcurrency = 10] - handle this many incoming pubsub messages concurrently\n */\n\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n * and specifies the API that pubsub routers should have.\n */\nclass PubsubBaseProtocol extends EventEmitter {\n  /**\n   * @param {PubsubProperties & PubsubOptions} props\n   * @abstract\n   */\n  constructor ({\n    debugName,\n    multicodecs,\n    libp2p,\n    globalSignaturePolicy = SignaturePolicy.StrictSign,\n    canRelayMessage = false,\n    emitSelf = false,\n    messageProcessingConcurrency = 10\n  }) {\n    if (typeof debugName !== 'string') {\n      throw new Error('a debugname `string` is required')\n    }\n\n    if (!multicodecs) {\n      throw new Error('multicodecs are required')\n    }\n\n    if (!libp2p) {\n      throw new Error('libp2p is required')\n    }\n\n    super()\n\n    this.log = Object.assign(debug(debugName), {\n      err: debug(`${debugName}:error`)\n    })\n\n    /**\n     * @type {Array<string>}\n     */\n    this.multicodecs = utils.ensureArray(multicodecs)\n    this._libp2p = libp2p\n    this.registrar = libp2p.registrar\n    /**\n     * @type {PeerId}\n     */\n    this.peerId = libp2p.peerId\n\n    this.started = false\n\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Set<string>>}\n     */\n    this.topics = new Map()\n\n    /**\n     * List of our subscriptions\n     *\n     * @type {Set<string>}\n     */\n    this.subscriptions = new Set()\n\n    /**\n     * Map of peer streams\n     *\n     * @type {Map<string, import('./peer-streams')>}\n     */\n    this.peers = new Map()\n\n    // validate signature policy\n    if (!SignaturePolicy[globalSignaturePolicy]) {\n      throw errcode(new Error('Invalid global signature policy'), codes.ERR_INVALID_SIGNATURE_POLICY)\n    }\n\n    /**\n     * The signature policy to follow by default\n     *\n     * @type {string}\n     */\n    this.globalSignaturePolicy = globalSignaturePolicy\n\n    /**\n     * If router can relay received messages, even if not subscribed\n     *\n     * @type {boolean}\n     */\n    this.canRelayMessage = canRelayMessage\n\n    /**\n     * if publish should emit to self, if subscribed\n     *\n     * @type {boolean}\n     */\n    this.emitSelf = emitSelf\n\n    /**\n     * Topic validator function\n     *\n     * @typedef {function(string, InMessage): Promise<void>} validator\n     */\n    /**\n     * Topic validator map\n     *\n     * Keyed by topic\n     * Topic validators are functions with the following input:\n     *\n     * @type {Map<string, validator>}\n     */\n    this.topicValidators = new Map()\n\n    /**\n     * @type {Queue}\n     */\n    this.queue = new Queue({ concurrency: messageProcessingConcurrency })\n\n    this._registrarId = undefined\n    this._onIncomingStream = this._onIncomingStream.bind(this)\n    this._onPeerConnected = this._onPeerConnected.bind(this)\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this)\n  }\n\n  // LIFECYCLE METHODS\n\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   *\n   * @returns {void}\n   */\n  start () {\n    if (this.started) {\n      return\n    }\n    this.log('starting')\n\n    // Incoming streams\n    // Called after a peer dials us\n    this.registrar.handle(this.multicodecs, this._onIncomingStream)\n\n    // register protocol with topology\n    // Topology callbacks called on connection manager changes\n    const topology = new MulticodecTopology({\n      multicodecs: this.multicodecs,\n      handlers: {\n        onConnect: this._onPeerConnected,\n        onDisconnect: this._onPeerDisconnected\n      }\n    })\n    this._registrarId = this.registrar.register(topology)\n\n    this.log('started')\n    this.started = true\n  }\n\n  /**\n   * Unregister the pubsub protocol and the streams with other peers will be closed.\n   *\n   * @returns {void}\n   */\n  stop () {\n    if (!this.started) {\n      return\n    }\n\n    // unregister protocol and handlers\n    this.registrar.unregister(this._registrarId)\n\n    this.log('stopping')\n    this.peers.forEach((peerStreams) => peerStreams.close())\n\n    this.peers = new Map()\n    this.subscriptions = new Set()\n    this.started = false\n    this.log('stopped')\n  }\n\n  /**\n   * On an inbound stream opened.\n   *\n   * @protected\n   * @param {Object} props\n   * @param {string} props.protocol\n   * @param {MuxedStream} props.stream\n   * @param {Connection} props.connection - connection\n   */\n  _onIncomingStream ({ protocol, stream, connection }) {\n    const peerId = connection.remotePeer\n    const idB58Str = peerId.toB58String()\n    const peer = this._addPeer(peerId, protocol)\n    const inboundStream = peer.attachInboundStream(stream)\n\n    this._processMessages(idB58Str, inboundStream, peer)\n  }\n\n  /**\n   * Registrar notifies an established connection with pubsub protocol.\n   *\n   * @protected\n   * @param {PeerId} peerId - remote peer-id\n   * @param {Connection} conn - connection to the peer\n   */\n  async _onPeerConnected (peerId, conn) {\n    const idB58Str = peerId.toB58String()\n    this.log('connected', idB58Str)\n\n    try {\n      const { stream, protocol } = await conn.newStream(this.multicodecs)\n      const peer = this._addPeer(peerId, protocol)\n      await peer.attachOutboundStream(stream)\n    } catch (err) {\n      this.log.err(err)\n    }\n\n    // Immediately send my own subscriptions to the newly established conn\n    this._sendSubscriptions(idB58Str, Array.from(this.subscriptions), true)\n  }\n\n  /**\n   * Registrar notifies a closing connection with pubsub protocol.\n   *\n   * @protected\n   * @param {PeerId} peerId - peerId\n   * @param {Error} [err] - error for connection end\n   */\n  _onPeerDisconnected (peerId, err) {\n    const idB58Str = peerId.toB58String()\n\n    this.log('connection ended', idB58Str, err ? err.message : '')\n    this._removePeer(peerId)\n  }\n\n  /**\n   * Notifies the router that a peer has been connected\n   *\n   * @protected\n   * @param {PeerId} peerId\n   * @param {string} protocol\n   * @returns {PeerStreams}\n   */\n  _addPeer (peerId, protocol) {\n    const id = peerId.toB58String()\n    const existing = this.peers.get(id)\n\n    // If peer streams already exists, do nothing\n    if (existing) {\n      return existing\n    }\n\n    // else create a new peer streams\n    this.log('new peer', id)\n\n    const peerStreams = new PeerStreams({\n      id: peerId,\n      protocol\n    })\n\n    this.peers.set(id, peerStreams)\n    peerStreams.once('close', () => this._removePeer(peerId))\n\n    return peerStreams\n  }\n\n  /**\n   * Notifies the router that a peer has been disconnected.\n   *\n   * @protected\n   * @param {PeerId} peerId\n   * @returns {PeerStreams | undefined}\n   */\n  _removePeer (peerId) {\n    if (!peerId) return\n    const id = peerId.toB58String()\n    const peerStreams = this.peers.get(id)\n    if (!peerStreams) return\n\n    // close peer streams\n    peerStreams.removeAllListeners()\n    peerStreams.close()\n\n    // delete peer streams\n    this.log('delete peer', id)\n    this.peers.delete(id)\n\n    // remove peer from topics map\n    for (const peers of this.topics.values()) {\n      peers.delete(id)\n    }\n\n    return peerStreams\n  }\n\n  // MESSAGE METHODS\n\n  /**\n   * Responsible for processing each RPC message received by other peers.\n   *\n   * @param {string} idB58Str - peer id string in base58\n   * @param {AsyncIterable<Uint8Array|BufferList>} stream - inbound stream\n   * @param {PeerStreams} peerStreams - PubSub peer\n   * @returns {Promise<void>}\n   */\n  async _processMessages (idB58Str, stream, peerStreams) {\n    try {\n      await pipe(\n        stream,\n        async (source) => {\n          for await (const data of source) {\n            const rpcBytes = data instanceof Uint8Array ? data : data.slice()\n            const rpcMsg = this._decodeRpc(rpcBytes)\n\n            // Since _processRpc may be overridden entirely in unsafe ways,\n            // the simplest/safest option here is to wrap in a function and capture all errors\n            // to prevent a top-level unhandled exception\n            // This processing of rpc messages should happen without awaiting full validation/execution of prior messages\n            ;(async () => {\n              try {\n                await this._processRpc(idB58Str, peerStreams, rpcMsg)\n              } catch (err) {\n                this.log.err(err)\n              }\n            })()\n          }\n        }\n      )\n    } catch (err) {\n      this._onPeerDisconnected(peerStreams.id, err)\n    }\n  }\n\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @param {string} idB58Str\n   * @param {PeerStreams} peerStreams\n   * @param {RPC} rpc\n   * @returns {Promise<boolean>}\n   */\n  async _processRpc (idB58Str, peerStreams, rpc) {\n    this.log('rpc from', idB58Str)\n    const subs = rpc.subscriptions\n    const msgs = rpc.msgs\n\n    if (subs.length) {\n      // update peer subscriptions\n      subs.forEach((subOpt) => {\n        this._processRpcSubOpt(idB58Str, subOpt)\n      })\n      this.emit('pubsub:subscription-change', peerStreams.id, subs)\n    }\n\n    if (!this._acceptFrom(idB58Str)) {\n      this.log('received message from unacceptable peer %s', idB58Str)\n      return false\n    }\n\n    if (msgs.length) {\n      this.queue.addAll(msgs.map(message => async () => {\n        if (!(this.canRelayMessage || (message.topicIDs && message.topicIDs.some((topic) => this.subscriptions.has(topic))))) {\n          this.log('received message we didn\\'t subscribe to. Dropping.')\n          return\n        }\n\n        try {\n          const msg = utils.normalizeInRpcMessage(message, idB58Str)\n\n          await this._processRpcMessage(msg)\n        } catch (err) {\n          this.log.err(err)\n        }\n      }))\n    }\n    return true\n  }\n\n  /**\n   * Handles a subscription change from a peer\n   *\n   * @param {string} id\n   * @param {RPC.ISubOpts} subOpt\n   */\n  _processRpcSubOpt (id, subOpt) {\n    const t = subOpt.topicID\n\n    if (!t) {\n      return\n    }\n\n    let topicSet = this.topics.get(t)\n    if (!topicSet) {\n      topicSet = new Set()\n      this.topics.set(t, topicSet)\n    }\n\n    if (subOpt.subscribe) {\n      // subscribe peer to new topic\n      topicSet.add(id)\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(id)\n    }\n  }\n\n  /**\n   * Handles an message from a peer\n   *\n   * @param {InMessage} msg\n   * @returns {Promise<void>}\n   */\n  async _processRpcMessage (msg) {\n    if (this.peerId.toB58String() === msg.from && !this.emitSelf) {\n      return\n    }\n\n    // Ensure the message is valid before processing it\n    try {\n      await this.validate(msg)\n    } catch (err) {\n      this.log('Message is invalid, dropping it. %O', err)\n      return\n    }\n\n    // Emit to self\n    this._emitMessage(msg)\n\n    return this._publish(utils.normalizeOutRpcMessage(msg))\n  }\n\n  /**\n   * Emit a message from a peer\n   *\n   * @param {InMessage} message\n   */\n  _emitMessage (message) {\n    message.topicIDs.forEach((topic) => {\n      if (this.subscriptions.has(topic)) {\n        this.emit(topic, message)\n      }\n    })\n  }\n\n  /**\n   * The default msgID implementation\n   * Child class can override this.\n   *\n   * @param {InMessage} msg - the message object\n   * @returns {Promise<Uint8Array> | Uint8Array} message id as bytes\n   */\n  getMsgId (msg) {\n    const signaturePolicy = this.globalSignaturePolicy\n    switch (signaturePolicy) {\n      case SignaturePolicy.StrictSign:\n        // @ts-ignore seqno is optional in protobuf definition but it will exist\n        return utils.msgId(msg.from, msg.seqno)\n      case SignaturePolicy.StrictNoSign:\n        return utils.noSignMsgId(msg.data)\n      default:\n        throw errcode(new Error('Cannot get message id: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY)\n    }\n  }\n\n  /**\n   * Whether to accept a message from a peer\n   * Override to create a graylist\n   *\n   * @param {string} id\n   * @returns {boolean}\n   */\n  _acceptFrom (id) {\n    return true\n  }\n\n  /**\n   * Decode Uint8Array into an RPC object.\n   * This can be override to use a custom router protobuf.\n   *\n   * @param {Uint8Array} bytes\n   * @returns {RPC}\n   */\n  _decodeRpc (bytes) {\n    return RPC.decode(bytes)\n  }\n\n  /**\n   * Encode RPC object into a Uint8Array.\n   * This can be override to use a custom router protobuf.\n   *\n   * @param {IRPC} rpc\n   * @returns {Uint8Array}\n   */\n  _encodeRpc (rpc) {\n    return RPC.encode(rpc).finish()\n  }\n\n  /**\n   * Send an rpc object to a peer\n   *\n   * @param {string} id - peer id\n   * @param {IRPC} rpc\n   * @returns {void}\n   */\n  _sendRpc (id, rpc) {\n    const peerStreams = this.peers.get(id)\n    if (!peerStreams || !peerStreams.isWritable) {\n      const msg = `Cannot send RPC to ${id} as there is no open stream to it available`\n\n      this.log.err(msg)\n      return\n    }\n    peerStreams.write(this._encodeRpc(rpc))\n  }\n\n  /**\n   * Send subscroptions to a peer\n   *\n   * @param {string} id - peer id\n   * @param {string[]} topics\n   * @param {boolean} subscribe - set to false for unsubscriptions\n   * @returns {void}\n   */\n  _sendSubscriptions (id, topics, subscribe) {\n    return this._sendRpc(id, {\n      subscriptions: topics.map(t => ({ topicID: t, subscribe: subscribe }))\n    })\n  }\n\n  /**\n   * Validates the given message. The signature will be checked for authenticity.\n   * Throws an error on invalid messages\n   *\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n  async validate (message) { // eslint-disable-line require-await\n    const signaturePolicy = this.globalSignaturePolicy\n    switch (signaturePolicy) {\n      case SignaturePolicy.StrictNoSign:\n        if (message.from) {\n          throw errcode(new Error('StrictNoSigning: from should not be present'), codes.ERR_UNEXPECTED_FROM)\n        }\n        if (message.signature) {\n          throw errcode(new Error('StrictNoSigning: signature should not be present'), codes.ERR_UNEXPECTED_SIGNATURE)\n        }\n        if (message.key) {\n          throw errcode(new Error('StrictNoSigning: key should not be present'), codes.ERR_UNEXPECTED_KEY)\n        }\n        if (message.seqno) {\n          throw errcode(new Error('StrictNoSigning: seqno should not be present'), codes.ERR_UNEXPECTED_SEQNO)\n        }\n        break\n      case SignaturePolicy.StrictSign:\n        if (!message.signature) {\n          throw errcode(new Error('StrictSigning: Signing required and no signature was present'), codes.ERR_MISSING_SIGNATURE)\n        }\n        if (!message.seqno) {\n          throw errcode(new Error('StrictSigning: Signing required and no seqno was present'), codes.ERR_MISSING_SEQNO)\n        }\n        if (!(await verifySignature(message))) {\n          throw errcode(new Error('StrictSigning: Invalid message signature'), codes.ERR_INVALID_SIGNATURE)\n        }\n        break\n      default:\n        throw errcode(new Error('Cannot validate message: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY)\n    }\n\n    for (const topic of message.topicIDs) {\n      const validatorFn = this.topicValidators.get(topic)\n      if (validatorFn) {\n        await validatorFn(topic, message)\n      }\n    }\n  }\n\n  /**\n   * Normalizes the message and signs it, if signing is enabled.\n   * Should be used by the routers to create the message to send.\n   *\n   * @protected\n   * @param {InMessage} message\n   * @returns {Promise<InMessage>}\n   */\n  _buildMessage (message) {\n    const signaturePolicy = this.globalSignaturePolicy\n    switch (signaturePolicy) {\n      case SignaturePolicy.StrictSign:\n        message.from = this.peerId.toB58String()\n        message.seqno = utils.randomSeqno()\n        return signMessage(this.peerId, message)\n      case SignaturePolicy.StrictNoSign:\n        return Promise.resolve(message)\n      default:\n        throw errcode(new Error('Cannot build message: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY)\n    }\n  }\n\n  // API METHODS\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   *\n   * @param {string} topic\n   * @returns {Array<string>}\n   */\n  getSubscribers (topic) {\n    if (!this.started) {\n      throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET')\n    }\n\n    if (!topic || typeof topic !== 'string') {\n      throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC')\n    }\n\n    const peersInTopic = this.topics.get(topic)\n    if (!peersInTopic) {\n      return []\n    }\n    return Array.from(peersInTopic)\n  }\n\n  /**\n   * Publishes messages to all subscribed peers\n   *\n   * @param {string} topic\n   * @param {Uint8Array} message\n   * @returns {Promise<void>}\n   */\n  async publish (topic, message) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started')\n    }\n\n    this.log('publish', topic, message)\n\n    const from = this.peerId.toB58String()\n    const msgObject = {\n      receivedFrom: from,\n      data: message,\n      topicIDs: [topic]\n    }\n\n    // ensure that the message follows the signature policy\n    const outMsg = await this._buildMessage(msgObject)\n    // @ts-ignore different type as from is converted\n    const msg = utils.normalizeInRpcMessage(outMsg)\n\n    // Emit to self if I'm interested and emitSelf enabled\n    this.emitSelf && this._emitMessage(msg)\n\n    // send to all the other peers\n    await this._publish(msg)\n  }\n\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n   *\n   * @abstract\n   * @param {InMessage|RPCMessage} message\n   * @returns {Promise<void>}\n   *\n   */\n  _publish (message) {\n    throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Subscribes to a given topic.\n   *\n   * @abstract\n   * @param {string} topic\n   * @returns {void}\n   */\n  subscribe (topic) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started')\n    }\n\n    if (!this.subscriptions.has(topic)) {\n      this.subscriptions.add(topic)\n      this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], true))\n    }\n  }\n\n  /**\n   * Unsubscribe from the given topic.\n   *\n   * @param {string} topic\n   * @returns {void}\n   */\n  unsubscribe (topic) {\n    if (!this.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    if (this.subscriptions.has(topic) && this.listenerCount(topic) === 0) {\n      this.subscriptions.delete(topic)\n      this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], false))\n    }\n  }\n\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   *\n   * @returns {Array<string>}\n   */\n  getTopics () {\n    if (!this.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    return Array.from(this.subscriptions)\n  }\n}\n\nPubsubBaseProtocol.utils = utils\nPubsubBaseProtocol.SignaturePolicy = SignaturePolicy\n\nmodule.exports = PubsubBaseProtocol\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}