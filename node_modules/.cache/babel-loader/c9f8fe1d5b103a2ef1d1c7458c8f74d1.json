{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeScore = void 0;\n\nfunction computeScore(peer, pstats, params, peerIPs) {\n  let score = 0; // topic stores\n\n  Object.entries(pstats.topics).forEach(_ref => {\n    let [topic, tstats] = _ref;\n    // the topic parameters\n    const topicParams = params.topics[topic];\n\n    if (!topicParams) {\n      // we are not scoring this topic\n      return;\n    }\n\n    let topicScore = 0; // P1: time in Mesh\n\n    if (tstats.inMesh) {\n      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;\n\n      if (p1 > topicParams.timeInMeshCap) {\n        p1 = topicParams.timeInMeshCap;\n      }\n\n      topicScore += p1 * topicParams.timeInMeshWeight;\n    } // P2: first message deliveries\n\n\n    const p2 = tstats.firstMessageDeliveries;\n    topicScore += p2 * topicParams.firstMessageDeliveriesWeight; // P3: mesh message deliveries\n\n    if (tstats.meshMessageDeliveriesActive) {\n      if (tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {\n        const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;\n        const p3 = deficit * deficit;\n        topicScore += p3 * topicParams.meshMessageDeliveriesWeight;\n      }\n    } // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n\n\n    const p3b = tstats.meshFailurePenalty;\n    topicScore += p3b * topicParams.meshFailurePenaltyWeight; // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;\n    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight; // update score, mixing with topic weight\n\n    score += topicScore * topicParams.topicWeight;\n  }); // apply the topic score cap, if any\n\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap;\n  } // P5: application-specific score\n\n\n  const p5 = params.appSpecificScore(peer);\n  score += p5 * params.appSpecificWeight; // P6: IP colocation factor\n\n  pstats.ips.forEach(ip => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return;\n    } // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n\n\n    const peersInIP = peerIPs.get(ip);\n    const numPeersInIP = peersInIP ? peersInIP.size : 0;\n\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold;\n      const p6 = surplus * surplus;\n      score += p6 * params.IPColocationFactorWeight;\n    }\n  }); // P7: behavioural pattern penalty\n\n  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;\n  score += p7 * params.behaviourPenaltyWeight;\n  return score;\n}\n\nexports.computeScore = computeScore;","map":{"version":3,"names":["Object","defineProperty","exports","value","computeScore","peer","pstats","params","peerIPs","score","entries","topics","forEach","topic","tstats","topicParams","topicScore","inMesh","p1","meshTime","timeInMeshQuantum","timeInMeshCap","timeInMeshWeight","p2","firstMessageDeliveries","firstMessageDeliveriesWeight","meshMessageDeliveriesActive","meshMessageDeliveries","meshMessageDeliveriesThreshold","deficit","p3","meshMessageDeliveriesWeight","p3b","meshFailurePenalty","meshFailurePenaltyWeight","p4","invalidMessageDeliveries","invalidMessageDeliveriesWeight","topicWeight","topicScoreCap","p5","appSpecificScore","appSpecificWeight","ips","ip","IPColocationFactorWhitelist","has","peersInIP","get","numPeersInIP","size","IPColocationFactorThreshold","surplus","p6","IPColocationFactorWeight","p7","behaviourPenalty","behaviourPenaltyWeight"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-gossipsub/src/score/compute-score.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeScore = void 0;\nfunction computeScore(peer, pstats, params, peerIPs) {\n    let score = 0;\n    // topic stores\n    Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n        // the topic parameters\n        const topicParams = params.topics[topic];\n        if (!topicParams) {\n            // we are not scoring this topic\n            return;\n        }\n        let topicScore = 0;\n        // P1: time in Mesh\n        if (tstats.inMesh) {\n            let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;\n            if (p1 > topicParams.timeInMeshCap) {\n                p1 = topicParams.timeInMeshCap;\n            }\n            topicScore += p1 * topicParams.timeInMeshWeight;\n        }\n        // P2: first message deliveries\n        const p2 = tstats.firstMessageDeliveries;\n        topicScore += p2 * topicParams.firstMessageDeliveriesWeight;\n        // P3: mesh message deliveries\n        if (tstats.meshMessageDeliveriesActive) {\n            if (tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {\n                const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;\n                const p3 = deficit * deficit;\n                topicScore += p3 * topicParams.meshMessageDeliveriesWeight;\n            }\n        }\n        // P3b:\n        // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n        const p3b = tstats.meshFailurePenalty;\n        topicScore += p3b * topicParams.meshFailurePenaltyWeight;\n        // P4: invalid messages\n        // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n        const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;\n        topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;\n        // update score, mixing with topic weight\n        score += topicScore * topicParams.topicWeight;\n    });\n    // apply the topic score cap, if any\n    if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n        score = params.topicScoreCap;\n    }\n    // P5: application-specific score\n    const p5 = params.appSpecificScore(peer);\n    score += p5 * params.appSpecificWeight;\n    // P6: IP colocation factor\n    pstats.ips.forEach(ip => {\n        if (params.IPColocationFactorWhitelist.has(ip)) {\n            return;\n        }\n        // P6 has a cliff (IPColocationFactorThreshold)\n        // It's only applied if at least that many peers are connected to us from that source IP addr.\n        // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n        const peersInIP = peerIPs.get(ip);\n        const numPeersInIP = peersInIP ? peersInIP.size : 0;\n        if (numPeersInIP > params.IPColocationFactorThreshold) {\n            const surplus = numPeersInIP - params.IPColocationFactorThreshold;\n            const p6 = surplus * surplus;\n            score += p6 * params.IPColocationFactorWeight;\n        }\n    });\n    // P7: behavioural pattern penalty\n    const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;\n    score += p7 * params.behaviourPenaltyWeight;\n    return score;\n}\nexports.computeScore = computeScore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}