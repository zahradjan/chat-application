{"ast":null,"code":"/* eslint-disable no-unreachable */\n'use strict'; // @ts-ignore\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _awaitAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\nvar TimeoutController = require('timeout-abort-controller');\n\nvar _require = require('any-signal'),\n    anySignal = _require.anySignal;\n\nvar _require2 = require('parse-duration'),\n    parseDuration = _require2.default;\n\nvar _require3 = require('./errors'),\n    TimeoutError = _require3.TimeoutError;\n/**\n * @template {any[]} Args\n * @template {Promise<any> | AsyncIterable<any>} R - The return type of `fn`\n * @param {(...args:Args) => R} fn\n * @param {number} [optionsArgIndex]\n * @returns {(...args:Args) => R}\n */\n\n\nfunction withTimeoutOption(fn, optionsArgIndex) {\n  // eslint-disable-next-line\n  return (\n    /** @returns {R} */\n    function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];\n      if (!options || !options.timeout) return fn.apply(void 0, args);\n      var timeout = typeof options.timeout === 'string' ? parseDuration(options.timeout) : options.timeout;\n      var controller = new TimeoutController(timeout);\n      options.signal = anySignal([options.signal, controller.signal]);\n      var fnRes = fn.apply(void 0, args); // eslint-disable-next-line promise/param-names\n\n      var timeoutPromise = new Promise(function (_resolve, reject) {\n        controller.signal.addEventListener('abort', function () {\n          reject(new TimeoutError());\n        });\n      });\n      var start = Date.now();\n\n      var maybeThrowTimeoutError = function maybeThrowTimeoutError() {\n        if (controller.signal.aborted) {\n          throw new TimeoutError();\n        }\n\n        var timeTaken = Date.now() - start; // if we have starved the event loop by adding microtasks, we could have\n        // timed out already but the TimeoutController will never know because it's\n        // setTimeout will not fire until we stop adding microtasks\n\n        if (timeTaken > timeout) {\n          controller.abort();\n          throw new TimeoutError();\n        }\n      }; // @ts-ignore\n\n\n      if (fnRes[Symbol.asyncIterator]) {\n        // @ts-ignore\n        return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          var it, _yield$_awaitAsyncGen, value, done;\n\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  // @ts-ignore\n                  it = fnRes[Symbol.asyncIterator]();\n                  _context.prev = 1;\n\n                case 2:\n                  if (!true) {\n                    _context.next = 15;\n                    break;\n                  }\n\n                  _context.next = 5;\n                  return _awaitAsyncGenerator(Promise.race([it.next(), timeoutPromise]));\n\n                case 5:\n                  _yield$_awaitAsyncGen = _context.sent;\n                  value = _yield$_awaitAsyncGen.value;\n                  done = _yield$_awaitAsyncGen.done;\n\n                  if (!done) {\n                    _context.next = 10;\n                    break;\n                  }\n\n                  return _context.abrupt(\"break\", 15);\n\n                case 10:\n                  maybeThrowTimeoutError();\n                  _context.next = 13;\n                  return value;\n\n                case 13:\n                  _context.next = 2;\n                  break;\n\n                case 15:\n                  _context.next = 21;\n                  break;\n\n                case 17:\n                  _context.prev = 17;\n                  _context.t0 = _context[\"catch\"](1);\n                  maybeThrowTimeoutError();\n                  throw _context.t0;\n\n                case 21:\n                  _context.prev = 21;\n                  controller.clear();\n\n                  if (it.return) {\n                    it.return();\n                  }\n\n                  return _context.finish(21);\n\n                case 25:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[1, 17, 21, 25]]);\n        }))();\n      } // @ts-ignore\n\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var res;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return Promise.race([fnRes, timeoutPromise]);\n\n              case 3:\n                res = _context2.sent;\n                maybeThrowTimeoutError();\n                return _context2.abrupt(\"return\", res);\n\n              case 8:\n                _context2.prev = 8;\n                _context2.t0 = _context2[\"catch\"](0);\n                maybeThrowTimeoutError();\n                throw _context2.t0;\n\n              case 12:\n                _context2.prev = 12;\n                controller.clear();\n                return _context2.finish(12);\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[0, 8, 12, 15]]);\n      }))();\n    }\n  );\n}\n\nmodule.exports = withTimeoutOption;","map":{"version":3,"names":["TimeoutController","require","anySignal","parseDuration","default","TimeoutError","withTimeoutOption","fn","optionsArgIndex","args","options","length","timeout","controller","signal","fnRes","timeoutPromise","Promise","_resolve","reject","addEventListener","start","Date","now","maybeThrowTimeoutError","aborted","timeTaken","abort","Symbol","asyncIterator","it","race","next","value","done","clear","return","res","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core-utils/src/with-timeout-option.js"],"sourcesContent":["/* eslint-disable no-unreachable */\n'use strict'\n\n// @ts-ignore\nconst TimeoutController = require('timeout-abort-controller')\nconst { anySignal } = require('any-signal')\nconst { default: parseDuration } = require('parse-duration')\nconst { TimeoutError } = require('./errors')\n\n/**\n * @template {any[]} Args\n * @template {Promise<any> | AsyncIterable<any>} R - The return type of `fn`\n * @param {(...args:Args) => R} fn\n * @param {number} [optionsArgIndex]\n * @returns {(...args:Args) => R}\n */\nfunction withTimeoutOption (fn, optionsArgIndex) {\n  // eslint-disable-next-line\n  return /** @returns {R} */(/** @type {Args} */...args) => {\n    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex]\n    if (!options || !options.timeout) return fn(...args)\n\n    const timeout = typeof options.timeout === 'string'\n      ? parseDuration(options.timeout)\n      : options.timeout\n\n    const controller = new TimeoutController(timeout)\n\n    options.signal = anySignal([options.signal, controller.signal])\n\n    const fnRes = fn(...args)\n    // eslint-disable-next-line promise/param-names\n    const timeoutPromise = new Promise((_resolve, reject) => {\n      controller.signal.addEventListener('abort', () => {\n        reject(new TimeoutError())\n      })\n    })\n\n    const start = Date.now()\n\n    const maybeThrowTimeoutError = () => {\n      if (controller.signal.aborted) {\n        throw new TimeoutError()\n      }\n\n      const timeTaken = Date.now() - start\n\n      // if we have starved the event loop by adding microtasks, we could have\n      // timed out already but the TimeoutController will never know because it's\n      // setTimeout will not fire until we stop adding microtasks\n      if (timeTaken > timeout) {\n        controller.abort()\n        throw new TimeoutError()\n      }\n    }\n\n    // @ts-ignore\n    if (fnRes[Symbol.asyncIterator]) {\n      // @ts-ignore\n      return (async function * () {\n        // @ts-ignore\n        const it = fnRes[Symbol.asyncIterator]()\n\n        try {\n          while (true) {\n            const { value, done } = await Promise.race([it.next(), timeoutPromise])\n\n            if (done) {\n              break\n            }\n\n            maybeThrowTimeoutError()\n\n            yield value\n          }\n        } catch (err) {\n          maybeThrowTimeoutError()\n\n          throw err\n        } finally {\n          controller.clear()\n\n          if (it.return) {\n            it.return()\n          }\n        }\n      })()\n    }\n\n    // @ts-ignore\n    return (async () => {\n      try {\n        const res = await Promise.race([fnRes, timeoutPromise])\n\n        maybeThrowTimeoutError()\n\n        return res\n      } catch (err) {\n        maybeThrowTimeoutError()\n\n        throw err\n      } finally {\n        controller.clear()\n      }\n    })()\n  }\n}\n\nmodule.exports = withTimeoutOption\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}