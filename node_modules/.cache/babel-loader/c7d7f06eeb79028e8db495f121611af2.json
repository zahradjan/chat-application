{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require('ipfs-bitswap'),\n    createBitswap = _require.createBitswap;\n\nvar createLibP2P = require('./libp2p');\n\nvar _require2 = require('multiaddr'),\n    Multiaddr = _require2.Multiaddr;\n\nvar errCode = require('err-code');\n\nvar BlockStorage = require('../block-storage');\n/**\n * @typedef {Object} Online\n * @property {libp2p} libp2p\n * @property {Bitswap} bitswap\n *\n * @typedef {Object} Options\n * @property {PeerId} options.peerId\n * @property {Repo} options.repo\n * @property {Print} options.print\n * @property {IPFSOptions} options.options\n *\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('../types').Print} Print\n * @typedef {import('libp2p')} libp2p\n * @typedef {import('ipfs-bitswap').IPFSBitswap} Bitswap\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n\nvar Network = /*#__PURE__*/function () {\n  /**\n   * @param {PeerId} peerId\n   * @param {libp2p} libp2p\n   * @param {Bitswap} bitswap\n   * @param {Repo} repo\n   * @param {BlockStorage} blockstore\n   */\n  function Network(peerId, libp2p, bitswap, repo, blockstore) {\n    _classCallCheck(this, Network);\n\n    this.peerId = peerId;\n    this.libp2p = libp2p;\n    this.bitswap = bitswap;\n    this.repo = repo;\n    this.blockstore = blockstore;\n  }\n  /**\n   * @param {Options} options\n   */\n\n\n  _createClass(Network, null, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {\n        var peerId, repo, print, options, config, libp2p, _iterator, _step, ma, bitswap, blockstore;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                peerId = _ref.peerId, repo = _ref.repo, print = _ref.print, options = _ref.options;\n\n                if (!repo.closed) {\n                  _context.next = 4;\n                  break;\n                }\n\n                _context.next = 4;\n                return repo.open();\n\n              case 4:\n                _context.next = 6;\n                return repo.config.getAll();\n\n              case 6:\n                config = _context.sent;\n                _context.next = 9;\n                return createLibP2P({\n                  options: options,\n                  repo: repo,\n                  peerId: peerId,\n                  multiaddrs: readAddrs(peerId, config),\n                  config: config,\n                  keychainConfig: undefined\n                });\n\n              case 9:\n                libp2p = _context.sent;\n\n                if (!libp2p.keychain) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _context.next = 13;\n                return libp2p.loadKeychain();\n\n              case 13:\n                _context.next = 15;\n                return libp2p.start();\n\n              case 15:\n                _iterator = _createForOfIteratorHelper(libp2p.multiaddrs);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    ma = _step.value;\n                    print(\"Swarm listening on \".concat(ma, \"/p2p/\").concat(peerId.toB58String()));\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                bitswap = createBitswap(libp2p, repo.blocks, {\n                  statsEnabled: true\n                });\n                _context.next = 20;\n                return bitswap.start();\n\n              case 20:\n                blockstore = new BlockStorage(repo.blocks, bitswap);\n                repo.blocks = blockstore; // @ts-ignore private field\n\n                repo.pins.blockstore = blockstore;\n                return _context.abrupt(\"return\", new Network(peerId, libp2p, bitswap, repo, blockstore));\n\n              case 24:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function start(_x) {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * @param {Network} network\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(network) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                network.repo.blocks = network.blockstore.unwrap(); // @ts-ignore private field\n\n                network.repo.pins.blockstore = network.blockstore.unwrap();\n                _context2.next = 4;\n                return Promise.all([network.bitswap.stop(), network.libp2p.stop()]);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function stop(_x2) {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n  }]);\n\n  return Network;\n}();\n\nmodule.exports = Network;\n/**\n * @param {PeerId} peerId\n * @param {IPFSConfig} config\n */\n\nvar readAddrs = function readAddrs(peerId, config) {\n  var peerIdStr = peerId.toB58String();\n  /** @type {Multiaddr[]} */\n\n  var addrs = [];\n  var swarm = config.Addresses && config.Addresses.Swarm || [];\n\n  var _iterator2 = _createForOfIteratorHelper(swarm),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var addr = _step2.value;\n      var ma = new Multiaddr(addr); // Temporary error for users migrating using websocket-star multiaddrs for listenning on libp2p\n      // websocket-star support was removed from ipfs and libp2p\n\n      if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {\n        throw errCode(new Error('websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779'), 'ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED');\n      } // multiaddrs that go via a signalling server or other intermediary (e.g. stardust,\n      // webrtc-star) can have the intermediary's peer ID in the address, so append our\n      // peer ID to the end of it\n\n\n      var maId = ma.getPeerId();\n\n      if (maId && maId !== peerIdStr) {\n        ma = ma.encapsulate(\"/p2p/\".concat(peerIdStr));\n      }\n\n      addrs.push(ma);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return addrs;\n};\n\nvar WEBSOCKET_STAR_PROTO_CODE = 479;","map":{"version":3,"names":["require","createBitswap","createLibP2P","Multiaddr","errCode","BlockStorage","Network","peerId","libp2p","bitswap","repo","blockstore","print","options","closed","open","config","getAll","multiaddrs","readAddrs","keychainConfig","undefined","keychain","loadKeychain","start","ma","toB58String","blocks","statsEnabled","pins","network","unwrap","Promise","all","stop","module","exports","peerIdStr","addrs","swarm","Addresses","Swarm","addr","protoCodes","includes","WEBSOCKET_STAR_PROTO_CODE","Error","maId","getPeerId","encapsulate","push"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/network.js"],"sourcesContent":["'use strict'\n\nconst { createBitswap } = require('ipfs-bitswap')\nconst createLibP2P = require('./libp2p')\nconst { Multiaddr } = require('multiaddr')\nconst errCode = require('err-code')\nconst BlockStorage = require('../block-storage')\n\n/**\n * @typedef {Object} Online\n * @property {libp2p} libp2p\n * @property {Bitswap} bitswap\n *\n * @typedef {Object} Options\n * @property {PeerId} options.peerId\n * @property {Repo} options.repo\n * @property {Print} options.print\n * @property {IPFSOptions} options.options\n *\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('../types').Print} Print\n * @typedef {import('libp2p')} libp2p\n * @typedef {import('ipfs-bitswap').IPFSBitswap} Bitswap\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\nclass Network {\n  /**\n   * @param {PeerId} peerId\n   * @param {libp2p} libp2p\n   * @param {Bitswap} bitswap\n   * @param {Repo} repo\n   * @param {BlockStorage} blockstore\n   */\n  constructor (peerId, libp2p, bitswap, repo, blockstore) {\n    this.peerId = peerId\n    this.libp2p = libp2p\n    this.bitswap = bitswap\n    this.repo = repo\n    this.blockstore = blockstore\n  }\n\n  /**\n   * @param {Options} options\n   */\n  static async start ({ peerId, repo, print, options }) {\n    // Need to ensure that repo is open as it could have been closed between\n    // `init` and `start`.\n    if (repo.closed) {\n      await repo.open()\n    }\n\n    /** @type {IPFSConfig} */\n    const config = await repo.config.getAll()\n\n    const libp2p = await createLibP2P({\n      options,\n      repo,\n      peerId,\n      multiaddrs: readAddrs(peerId, config),\n      config,\n      keychainConfig: undefined\n    })\n\n    if (libp2p.keychain) {\n      await libp2p.loadKeychain()\n    }\n\n    await libp2p.start()\n\n    for (const ma of libp2p.multiaddrs) {\n      print(`Swarm listening on ${ma}/p2p/${peerId.toB58String()}`)\n    }\n\n    const bitswap = createBitswap(libp2p, repo.blocks, { statsEnabled: true })\n    await bitswap.start()\n\n    const blockstore = new BlockStorage(repo.blocks, bitswap)\n    repo.blocks = blockstore\n    // @ts-ignore private field\n    repo.pins.blockstore = blockstore\n\n    return new Network(peerId, libp2p, bitswap, repo, blockstore)\n  }\n\n  /**\n   * @param {Network} network\n   */\n  static async stop (network) {\n    network.repo.blocks = network.blockstore.unwrap()\n    // @ts-ignore private field\n    network.repo.pins.blockstore = network.blockstore.unwrap()\n\n    await Promise.all([\n      network.bitswap.stop(),\n      network.libp2p.stop()\n    ])\n  }\n}\nmodule.exports = Network\n\n/**\n * @param {PeerId} peerId\n * @param {IPFSConfig} config\n */\nconst readAddrs = (peerId, config) => {\n  const peerIdStr = peerId.toB58String()\n  /** @type {Multiaddr[]} */\n  const addrs = []\n  const swarm = (config.Addresses && config.Addresses.Swarm) || []\n  for (const addr of swarm) {\n    let ma = new Multiaddr(addr)\n\n    // Temporary error for users migrating using websocket-star multiaddrs for listenning on libp2p\n    // websocket-star support was removed from ipfs and libp2p\n    if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {\n      throw errCode(new Error('websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779'), 'ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED')\n    }\n\n    // multiaddrs that go via a signalling server or other intermediary (e.g. stardust,\n    // webrtc-star) can have the intermediary's peer ID in the address, so append our\n    // peer ID to the end of it\n    const maId = ma.getPeerId()\n    if (maId && maId !== peerIdStr) {\n      ma = ma.encapsulate(`/p2p/${peerIdStr}`)\n    }\n\n    addrs.push(ma)\n  }\n\n  return addrs\n}\n\nconst WEBSOCKET_STAR_PROTO_CODE = 479\n"],"mappings":"AAAA;;;;;;;;;;;;AAEA,eAA0BA,OAAO,CAAC,cAAD,CAAjC;AAAA,IAAQC,aAAR,YAAQA,aAAR;;AACA,IAAMC,YAAY,GAAGF,OAAO,CAAC,UAAD,CAA5B;;AACA,gBAAsBA,OAAO,CAAC,WAAD,CAA7B;AAAA,IAAQG,SAAR,aAAQA,SAAR;;AACA,IAAMC,OAAO,GAAGJ,OAAO,CAAC,UAAD,CAAvB;;AACA,IAAMK,YAAY,GAAGL,OAAO,CAAC,kBAAD,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IAEMM,O;EACJ;AACF;AACA;AACA;AACA;AACA;AACA;EACE,iBAAaC,MAAb,EAAqBC,MAArB,EAA6BC,OAA7B,EAAsCC,IAAtC,EAA4CC,UAA5C,EAAwD;IAAA;;IACtD,KAAKJ,MAAL,GAAcA,MAAd;IACA,KAAKC,MAAL,GAAcA,MAAd;IACA,KAAKC,OAAL,GAAeA,OAAf;IACA,KAAKC,IAAL,GAAYA,IAAZ;IACA,KAAKC,UAAL,GAAkBA,UAAlB;EACD;EAED;AACF;AACA;;;;;;8EACE;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAsBJ,MAAtB,QAAsBA,MAAtB,EAA8BG,IAA9B,QAA8BA,IAA9B,EAAoCE,KAApC,QAAoCA,KAApC,EAA2CC,OAA3C,QAA2CA,OAA3C;;gBAAA,KAGMH,IAAI,CAACI,MAHX;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAIUJ,IAAI,CAACK,IAAL,EAJV;;cAAA;gBAAA;gBAAA,OAQuBL,IAAI,CAACM,MAAL,CAAYC,MAAZ,EARvB;;cAAA;gBAQQD,MARR;gBAAA;gBAAA,OAUuBd,YAAY,CAAC;kBAChCW,OAAO,EAAPA,OADgC;kBAEhCH,IAAI,EAAJA,IAFgC;kBAGhCH,MAAM,EAANA,MAHgC;kBAIhCW,UAAU,EAAEC,SAAS,CAACZ,MAAD,EAASS,MAAT,CAJW;kBAKhCA,MAAM,EAANA,MALgC;kBAMhCI,cAAc,EAAEC;gBANgB,CAAD,CAVnC;;cAAA;gBAUQb,MAVR;;gBAAA,KAmBMA,MAAM,CAACc,QAnBb;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAoBUd,MAAM,CAACe,YAAP,EApBV;;cAAA;gBAAA;gBAAA,OAuBQf,MAAM,CAACgB,KAAP,EAvBR;;cAAA;gBAAA,uCAyBmBhB,MAAM,CAACU,UAzB1B;;gBAAA;kBAyBE,oDAAoC;oBAAzBO,EAAyB;oBAClCb,KAAK,8BAAuBa,EAAvB,kBAAiClB,MAAM,CAACmB,WAAP,EAAjC,EAAL;kBACD;gBA3BH;kBAAA;gBAAA;kBAAA;gBAAA;;gBA6BQjB,OA7BR,GA6BkBR,aAAa,CAACO,MAAD,EAASE,IAAI,CAACiB,MAAd,EAAsB;kBAAEC,YAAY,EAAE;gBAAhB,CAAtB,CA7B/B;gBAAA;gBAAA,OA8BQnB,OAAO,CAACe,KAAR,EA9BR;;cAAA;gBAgCQb,UAhCR,GAgCqB,IAAIN,YAAJ,CAAiBK,IAAI,CAACiB,MAAtB,EAA8BlB,OAA9B,CAhCrB;gBAiCEC,IAAI,CAACiB,MAAL,GAAchB,UAAd,CAjCF,CAkCE;;gBACAD,IAAI,CAACmB,IAAL,CAAUlB,UAAV,GAAuBA,UAAvB;gBAnCF,iCAqCS,IAAIL,OAAJ,CAAYC,MAAZ,EAAoBC,MAApB,EAA4BC,OAA5B,EAAqCC,IAArC,EAA2CC,UAA3C,CArCT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;IAwCA;AACF;AACA;;;;;6EACE,kBAAmBmB,OAAnB;QAAA;UAAA;YAAA;cAAA;gBACEA,OAAO,CAACpB,IAAR,CAAaiB,MAAb,GAAsBG,OAAO,CAACnB,UAAR,CAAmBoB,MAAnB,EAAtB,CADF,CAEE;;gBACAD,OAAO,CAACpB,IAAR,CAAamB,IAAb,CAAkBlB,UAAlB,GAA+BmB,OAAO,CAACnB,UAAR,CAAmBoB,MAAnB,EAA/B;gBAHF;gBAAA,OAKQC,OAAO,CAACC,GAAR,CAAY,CAChBH,OAAO,CAACrB,OAAR,CAAgByB,IAAhB,EADgB,EAEhBJ,OAAO,CAACtB,MAAR,CAAe0B,IAAf,EAFgB,CAAZ,CALR;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;;;AAWFC,MAAM,CAACC,OAAP,GAAiB9B,OAAjB;AAEA;AACA;AACA;AACA;;AACA,IAAMa,SAAS,GAAG,SAAZA,SAAY,CAACZ,MAAD,EAASS,MAAT,EAAoB;EACpC,IAAMqB,SAAS,GAAG9B,MAAM,CAACmB,WAAP,EAAlB;EACA;;EACA,IAAMY,KAAK,GAAG,EAAd;EACA,IAAMC,KAAK,GAAIvB,MAAM,CAACwB,SAAP,IAAoBxB,MAAM,CAACwB,SAAP,CAAiBC,KAAtC,IAAgD,EAA9D;;EAJoC,4CAKjBF,KALiB;EAAA;;EAAA;IAKpC,uDAA0B;MAAA,IAAfG,IAAe;MACxB,IAAIjB,EAAE,GAAG,IAAItB,SAAJ,CAAcuC,IAAd,CAAT,CADwB,CAGxB;MACA;;MACA,IAAIjB,EAAE,CAACkB,UAAH,GAAgBC,QAAhB,CAAyBC,yBAAzB,CAAJ,EAAyD;QACvD,MAAMzC,OAAO,CAAC,IAAI0C,KAAJ,CAAU,mGAAV,CAAD,EAAiH,6CAAjH,CAAb;MACD,CAPuB,CASxB;MACA;MACA;;;MACA,IAAMC,IAAI,GAAGtB,EAAE,CAACuB,SAAH,EAAb;;MACA,IAAID,IAAI,IAAIA,IAAI,KAAKV,SAArB,EAAgC;QAC9BZ,EAAE,GAAGA,EAAE,CAACwB,WAAH,gBAAuBZ,SAAvB,EAAL;MACD;;MAEDC,KAAK,CAACY,IAAN,CAAWzB,EAAX;IACD;EAvBmC;IAAA;EAAA;IAAA;EAAA;;EAyBpC,OAAOa,KAAP;AACD,CA1BD;;AA4BA,IAAMO,yBAAyB,GAAG,GAAlC"},"metadata":{},"sourceType":"script"}