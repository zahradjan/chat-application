{"ast":null,"code":"'use strict';\n\nconst lp = require('it-length-prefixed');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');\n\nconst Message = require('./types/message');\n\nconst CONSTANTS = require('./constants');\n\nconst logger = require('./utils').logger;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n *\n * @typedef {Object} Provider\n * @property {PeerId} id\n * @property {Multiaddr[]} multiaddrs\n *\n * @typedef {Object} Stream\n * @property {AsyncIterable<Uint8Array>} source\n * @property {(output:AsyncIterable<Uint8Array>) => Promise<void>} sink\n */\n\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0';\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0';\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0';\n\nclass Network {\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {import('./bitswap')} bitswap\n   * @param {import('./stats')} stats\n   * @param {Object} [options]\n   * @param {boolean} [options.b100Only]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  constructor(libp2p, bitswap, stats) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this._log = logger(libp2p.peerId, 'network');\n    this._libp2p = libp2p;\n    this._bitswap = bitswap;\n    this._protocols = [BITSWAP100];\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this._protocols.unshift(BITSWAP110);\n\n      this._protocols.unshift(BITSWAP120);\n    }\n\n    this._stats = stats;\n    this._running = false; // bind event listeners\n\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n    this._hashers = options.hashers || {};\n  }\n\n  start() {\n    this._running = true;\n\n    this._libp2p.handle(this._protocols, this._onConnection); // register protocol with topology\n\n\n    const topology = new MulticodecTopology({\n      multicodecs: this._protocols,\n      handlers: {\n        onConnect: this._onPeerConnect,\n        onDisconnect: this._onPeerDisconnect\n      }\n    });\n    this._registrarId = this._libp2p.registrar.register(topology); // All existing connections are like new ones for us\n\n    for (const peer of this._libp2p.peerStore.peers.values()) {\n      const conn = this._libp2p.connectionManager.get(peer.id);\n\n      conn && this._onPeerConnect(conn.remotePeer);\n    }\n  }\n\n  stop() {\n    this._running = false; // Unhandle both, libp2p doesn't care if it's not already handled\n\n    this._libp2p.unhandle(this._protocols); // unregister protocol and handlers\n\n\n    if (this._registrarId != null) {\n      this._libp2p.registrar.unregister(this._registrarId);\n    }\n  }\n  /**\n   * Handles both types of incoming bitswap messages\n   *\n   * @private\n   * @param {object} connection\n   * @param {string} connection.protocol - The protocol the stream is running\n   * @param {MuxedStream} connection.stream - A duplex iterable stream\n   * @param {Connection} connection.connection - A libp2p Connection\n   */\n\n\n  async _onConnection(_ref) {\n    let {\n      protocol,\n      stream,\n      connection\n    } = _ref;\n\n    if (!this._running) {\n      return;\n    }\n\n    this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String());\n\n    try {\n      await pipe(stream, lp.decode(),\n      /**\n       * @param {AsyncIterable<Uint8Array>} source\n       */\n      async source => {\n        for await (const data of source) {\n          try {\n            const message = await Message.deserialize(data.slice(), this._hashers);\n            await this._bitswap._receiveMessage(connection.remotePeer, message);\n          } catch (err) {\n            this._bitswap._receiveError(err);\n\n            break;\n          }\n        }\n      });\n    } catch (err) {\n      this._log(err);\n    }\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerConnect(peerId) {\n    this._bitswap._onPeerConnected(peerId);\n  }\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  _onPeerDisconnect(peerId) {\n    this._bitswap._onPeerDisconnected(peerId);\n  }\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {number} maxProviders\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {AsyncIterable<Provider>}\n   */\n\n\n  findProviders(cid, maxProviders) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this._libp2p.contentRouting.findProviders(cid, {\n      timeout: CONSTANTS.providerRequestTimeout,\n      maxNumProviders: maxProviders\n    });\n  }\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async findAndConnect(cid, options) {\n    const connectAttempts = [];\n\n    for await (const provider of this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options)) {\n      this._log(`connecting to provider ${provider.id}`);\n\n      connectAttempts.push(this.connectTo(provider.id, options).catch(err => {\n        // Prevent unhandled promise rejection\n        this._log.error(err);\n      }));\n    }\n\n    await Promise.all(connectAttempts);\n  }\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async provide(cid, options) {\n    // @ts-expect-error - contentRouting takes no options\n    await this._libp2p.contentRouting.provide(cid, options);\n  }\n  /**\n   * Connect to the given peer\n   * Send the given msg (instance of Message) to the given peer\n   *\n   * @param {PeerId} peer\n   * @param {Message} msg\n   */\n\n\n  async sendMessage(peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running');\n    const stringId = peer.toB58String();\n\n    this._log('sendMessage to %s', stringId, msg);\n\n    const connection = await this._libp2p.dial(peer);\n    const {\n      stream,\n      protocol\n    } = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100]);\n    /** @type {Uint8Array} */\n\n    let serialized;\n\n    switch (protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100();\n        break;\n\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110();\n        break;\n\n      default:\n        throw new Error('Unknown protocol: ' + protocol);\n    } // Note: Don't wait for writeMessage() to complete\n\n\n    writeMessage(stream, serialized, this._log);\n\n    this._updateSentStats(peer, msg.blocks);\n  }\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n\n\n  async connectTo(peer, options) {\n    // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running');\n    }\n\n    return this._libp2p.dial(peer, options);\n  }\n  /**\n   * @private\n   * @param {PeerId} peer\n   * @param {Map<string, Uint8Array>} blocks\n   */\n\n\n  _updateSentStats(peer, blocks) {\n    const peerId = peer.toB58String();\n\n    if (this._stats) {\n      for (const block of blocks.values()) {\n        this._stats.push(peerId, 'dataSent', block.length);\n      }\n\n      this._stats.push(peerId, 'blocksSent', blocks.size);\n    }\n  }\n\n}\n/**\n *\n * @param {MuxedStream} stream\n * @param {Uint8Array} msg\n * @param {*} log\n */\n\n\nasync function writeMessage(stream, msg, log) {\n  try {\n    await pipe([msg], lp.encode(), stream);\n  } catch (err) {\n    log(err);\n  }\n}\n\nmodule.exports = Network;","map":{"version":3,"names":["lp","require","pipe","MulticodecTopology","Message","CONSTANTS","logger","BITSWAP100","BITSWAP110","BITSWAP120","Network","constructor","libp2p","bitswap","stats","options","_log","peerId","_libp2p","_bitswap","_protocols","b100Only","unshift","_stats","_running","_onPeerConnect","bind","_onPeerDisconnect","_onConnection","_hashers","hashers","start","handle","topology","multicodecs","handlers","onConnect","onDisconnect","_registrarId","registrar","register","peer","peerStore","peers","values","conn","connectionManager","get","id","remotePeer","stop","unhandle","unregister","protocol","stream","connection","toB58String","decode","source","data","message","deserialize","slice","_receiveMessage","err","_receiveError","_onPeerConnected","_onPeerDisconnected","findProviders","cid","maxProviders","contentRouting","timeout","providerRequestTimeout","maxNumProviders","findAndConnect","connectAttempts","provider","maxProvidersPerRequest","push","connectTo","catch","error","Promise","all","provide","sendMessage","msg","Error","stringId","dial","newStream","serialized","serializeToBitswap100","serializeToBitswap110","writeMessage","_updateSentStats","blocks","block","length","size","log","encode","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-bitswap/src/network.js"],"sourcesContent":["'use strict'\n\nconst lp = require('it-length-prefixed')\nconst { pipe } = require('it-pipe')\n\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology')\n\nconst Message = require('./types/message')\nconst CONSTANTS = require('./constants')\nconst logger = require('./utils').logger\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n *\n * @typedef {Object} Provider\n * @property {PeerId} id\n * @property {Multiaddr[]} multiaddrs\n *\n * @typedef {Object} Stream\n * @property {AsyncIterable<Uint8Array>} source\n * @property {(output:AsyncIterable<Uint8Array>) => Promise<void>} sink\n */\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0'\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0'\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0'\n\nclass Network {\n  /**\n   * @param {import('libp2p')} libp2p\n   * @param {import('./bitswap')} bitswap\n   * @param {import('./stats')} stats\n   * @param {Object} [options]\n   * @param {boolean} [options.b100Only]\n   * @param {Record<number, MultihashHasher>} [options.hashers]\n   */\n  constructor (libp2p, bitswap, stats, options = {}) {\n    this._log = logger(libp2p.peerId, 'network')\n    this._libp2p = libp2p\n    this._bitswap = bitswap\n    this._protocols = [BITSWAP100]\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this._protocols.unshift(BITSWAP110)\n      this._protocols.unshift(BITSWAP120)\n    }\n\n    this._stats = stats\n    this._running = false\n\n    // bind event listeners\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)\n    this._onConnection = this._onConnection.bind(this)\n    this._hashers = options.hashers || {}\n  }\n\n  start () {\n    this._running = true\n    this._libp2p.handle(this._protocols, this._onConnection)\n\n    // register protocol with topology\n    const topology = new MulticodecTopology({\n      multicodecs: this._protocols,\n      handlers: {\n        onConnect: this._onPeerConnect,\n        onDisconnect: this._onPeerDisconnect\n      }\n    })\n    this._registrarId = this._libp2p.registrar.register(topology)\n\n    // All existing connections are like new ones for us\n    for (const peer of this._libp2p.peerStore.peers.values()) {\n      const conn = this._libp2p.connectionManager.get(peer.id)\n\n      conn && this._onPeerConnect(conn.remotePeer)\n    }\n  }\n\n  stop () {\n    this._running = false\n\n    // Unhandle both, libp2p doesn't care if it's not already handled\n    this._libp2p.unhandle(this._protocols)\n\n    // unregister protocol and handlers\n    if (this._registrarId != null) {\n      this._libp2p.registrar.unregister(this._registrarId)\n    }\n  }\n\n  /**\n   * Handles both types of incoming bitswap messages\n   *\n   * @private\n   * @param {object} connection\n   * @param {string} connection.protocol - The protocol the stream is running\n   * @param {MuxedStream} connection.stream - A duplex iterable stream\n   * @param {Connection} connection.connection - A libp2p Connection\n   */\n  async _onConnection ({ protocol, stream, connection }) {\n    if (!this._running) { return }\n    this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String())\n\n    try {\n      await pipe(\n        stream,\n        lp.decode(),\n        /**\n         * @param {AsyncIterable<Uint8Array>} source\n         */\n        async (source) => {\n          for await (const data of source) {\n            try {\n              const message = await Message.deserialize(data.slice(), this._hashers)\n              await this._bitswap._receiveMessage(connection.remotePeer, message)\n            } catch (err) {\n              this._bitswap._receiveError(err)\n              break\n            }\n          }\n        }\n      )\n    } catch (err) {\n      this._log(err)\n    }\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerConnect (peerId) {\n    this._bitswap._onPeerConnected(peerId)\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peerId\n   */\n  _onPeerDisconnect (peerId) {\n    this._bitswap._onPeerDisconnected(peerId)\n  }\n\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {number} maxProviders\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {AsyncIterable<Provider>}\n   */\n  findProviders (cid, maxProviders, options = {}) {\n    return this._libp2p.contentRouting.findProviders(\n      cid,\n      {\n        timeout: CONSTANTS.providerRequestTimeout,\n        maxNumProviders: maxProviders\n      }\n    )\n  }\n\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async findAndConnect (cid, options) {\n    const connectAttempts = []\n    for await (const provider of this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options)) {\n      this._log(`connecting to provider ${provider.id}`)\n      connectAttempts.push(\n        this.connectTo(provider.id, options)\n          .catch(err => {\n            // Prevent unhandled promise rejection\n            this._log.error(err)\n          })\n      )\n    }\n    await Promise.all(connectAttempts)\n  }\n\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async provide (cid, options) {\n    // @ts-expect-error - contentRouting takes no options\n    await this._libp2p.contentRouting.provide(cid, options)\n  }\n\n  /**\n   * Connect to the given peer\n   * Send the given msg (instance of Message) to the given peer\n   *\n   * @param {PeerId} peer\n   * @param {Message} msg\n   */\n  async sendMessage (peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running')\n\n    const stringId = peer.toB58String()\n    this._log('sendMessage to %s', stringId, msg)\n\n    const connection = await this._libp2p.dial(peer)\n    const { stream, protocol } = await connection.newStream([BITSWAP120, BITSWAP110, BITSWAP100])\n\n    /** @type {Uint8Array} */\n    let serialized\n    switch (protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100()\n        break\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110()\n        break\n      default:\n        throw new Error('Unknown protocol: ' + protocol)\n    }\n\n    // Note: Don't wait for writeMessage() to complete\n    writeMessage(stream, serialized, this._log)\n\n    this._updateSentStats(peer, msg.blocks)\n  }\n\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {Object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  async connectTo (peer, options) { // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running')\n    }\n\n    return this._libp2p.dial(peer, options)\n  }\n\n  /**\n   * @private\n   * @param {PeerId} peer\n   * @param {Map<string, Uint8Array>} blocks\n   */\n  _updateSentStats (peer, blocks) {\n    const peerId = peer.toB58String()\n\n    if (this._stats) {\n      for (const block of blocks.values()) {\n        this._stats.push(peerId, 'dataSent', block.length)\n      }\n\n      this._stats.push(peerId, 'blocksSent', blocks.size)\n    }\n  }\n}\n\n/**\n *\n * @param {MuxedStream} stream\n * @param {Uint8Array} msg\n * @param {*} log\n */\nasync function writeMessage (stream, msg, log) {\n  try {\n    await pipe(\n      [msg],\n      lp.encode(),\n      stream\n    )\n  } catch (err) {\n    log(err)\n  }\n}\n\nmodule.exports = Network\n"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,oBAAD,CAAlB;;AACA,MAAM;EAAEC;AAAF,IAAWD,OAAO,CAAC,SAAD,CAAxB;;AAEA,MAAME,kBAAkB,GAAGF,OAAO,CAAC,oDAAD,CAAlC;;AAEA,MAAMG,OAAO,GAAGH,OAAO,CAAC,iBAAD,CAAvB;;AACA,MAAMI,SAAS,GAAGJ,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,SAAD,CAAP,CAAmBK,MAAlC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMC,UAAU,GAAG,qBAAnB;AACA,MAAMC,UAAU,GAAG,qBAAnB;AACA,MAAMC,UAAU,GAAG,qBAAnB;;AAEA,MAAMC,OAAN,CAAc;EACZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAW,CAAEC,MAAF,EAAUC,OAAV,EAAmBC,KAAnB,EAAwC;IAAA,IAAdC,OAAc,uEAAJ,EAAI;IACjD,KAAKC,IAAL,GAAYV,MAAM,CAACM,MAAM,CAACK,MAAR,EAAgB,SAAhB,CAAlB;IACA,KAAKC,OAAL,GAAeN,MAAf;IACA,KAAKO,QAAL,GAAgBN,OAAhB;IACA,KAAKO,UAAL,GAAkB,CAACb,UAAD,CAAlB;;IAEA,IAAI,CAACQ,OAAO,CAACM,QAAb,EAAuB;MACrB;MACA,KAAKD,UAAL,CAAgBE,OAAhB,CAAwBd,UAAxB;;MACA,KAAKY,UAAL,CAAgBE,OAAhB,CAAwBb,UAAxB;IACD;;IAED,KAAKc,MAAL,GAAcT,KAAd;IACA,KAAKU,QAAL,GAAgB,KAAhB,CAbiD,CAejD;;IACA,KAAKC,cAAL,GAAsB,KAAKA,cAAL,CAAoBC,IAApB,CAAyB,IAAzB,CAAtB;IACA,KAAKC,iBAAL,GAAyB,KAAKA,iBAAL,CAAuBD,IAAvB,CAA4B,IAA5B,CAAzB;IACA,KAAKE,aAAL,GAAqB,KAAKA,aAAL,CAAmBF,IAAnB,CAAwB,IAAxB,CAArB;IACA,KAAKG,QAAL,GAAgBd,OAAO,CAACe,OAAR,IAAmB,EAAnC;EACD;;EAEDC,KAAK,GAAI;IACP,KAAKP,QAAL,GAAgB,IAAhB;;IACA,KAAKN,OAAL,CAAac,MAAb,CAAoB,KAAKZ,UAAzB,EAAqC,KAAKQ,aAA1C,EAFO,CAIP;;;IACA,MAAMK,QAAQ,GAAG,IAAI9B,kBAAJ,CAAuB;MACtC+B,WAAW,EAAE,KAAKd,UADoB;MAEtCe,QAAQ,EAAE;QACRC,SAAS,EAAE,KAAKX,cADR;QAERY,YAAY,EAAE,KAAKV;MAFX;IAF4B,CAAvB,CAAjB;IAOA,KAAKW,YAAL,GAAoB,KAAKpB,OAAL,CAAaqB,SAAb,CAAuBC,QAAvB,CAAgCP,QAAhC,CAApB,CAZO,CAcP;;IACA,KAAK,MAAMQ,IAAX,IAAmB,KAAKvB,OAAL,CAAawB,SAAb,CAAuBC,KAAvB,CAA6BC,MAA7B,EAAnB,EAA0D;MACxD,MAAMC,IAAI,GAAG,KAAK3B,OAAL,CAAa4B,iBAAb,CAA+BC,GAA/B,CAAmCN,IAAI,CAACO,EAAxC,CAAb;;MAEAH,IAAI,IAAI,KAAKpB,cAAL,CAAoBoB,IAAI,CAACI,UAAzB,CAAR;IACD;EACF;;EAEDC,IAAI,GAAI;IACN,KAAK1B,QAAL,GAAgB,KAAhB,CADM,CAGN;;IACA,KAAKN,OAAL,CAAaiC,QAAb,CAAsB,KAAK/B,UAA3B,EAJM,CAMN;;;IACA,IAAI,KAAKkB,YAAL,IAAqB,IAAzB,EAA+B;MAC7B,KAAKpB,OAAL,CAAaqB,SAAb,CAAuBa,UAAvB,CAAkC,KAAKd,YAAvC;IACD;EACF;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACqB,MAAbV,aAAa,OAAoC;IAAA,IAAlC;MAAEyB,QAAF;MAAYC,MAAZ;MAAoBC;IAApB,CAAkC;;IACrD,IAAI,CAAC,KAAK/B,QAAV,EAAoB;MAAE;IAAQ;;IAC9B,KAAKR,IAAL,CAAU,4CAAV,EAAwDqC,QAAxD,EAAkEE,UAAU,CAACN,UAAX,CAAsBO,WAAtB,EAAlE;;IAEA,IAAI;MACF,MAAMtD,IAAI,CACRoD,MADQ,EAERtD,EAAE,CAACyD,MAAH,EAFQ;MAGR;AACR;AACA;MACQ,MAAOC,MAAP,IAAkB;QAChB,WAAW,MAAMC,IAAjB,IAAyBD,MAAzB,EAAiC;UAC/B,IAAI;YACF,MAAME,OAAO,GAAG,MAAMxD,OAAO,CAACyD,WAAR,CAAoBF,IAAI,CAACG,KAAL,EAApB,EAAkC,KAAKjC,QAAvC,CAAtB;YACA,MAAM,KAAKV,QAAL,CAAc4C,eAAd,CAA8BR,UAAU,CAACN,UAAzC,EAAqDW,OAArD,CAAN;UACD,CAHD,CAGE,OAAOI,GAAP,EAAY;YACZ,KAAK7C,QAAL,CAAc8C,aAAd,CAA4BD,GAA5B;;YACA;UACD;QACF;MACF,CAhBO,CAAV;IAkBD,CAnBD,CAmBE,OAAOA,GAAP,EAAY;MACZ,KAAKhD,IAAL,CAAUgD,GAAV;IACD;EACF;EAED;AACF;AACA;AACA;;;EACEvC,cAAc,CAAER,MAAF,EAAU;IACtB,KAAKE,QAAL,CAAc+C,gBAAd,CAA+BjD,MAA/B;EACD;EAED;AACF;AACA;AACA;;;EACEU,iBAAiB,CAAEV,MAAF,EAAU;IACzB,KAAKE,QAAL,CAAcgD,mBAAd,CAAkClD,MAAlC;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEmD,aAAa,CAAEC,GAAF,EAAOC,YAAP,EAAmC;IAAA,IAAdvD,OAAc,uEAAJ,EAAI;IAC9C,OAAO,KAAKG,OAAL,CAAaqD,cAAb,CAA4BH,aAA5B,CACLC,GADK,EAEL;MACEG,OAAO,EAAEnE,SAAS,CAACoE,sBADrB;MAEEC,eAAe,EAAEJ;IAFnB,CAFK,CAAP;EAOD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACsB,MAAdK,cAAc,CAAEN,GAAF,EAAOtD,OAAP,EAAgB;IAClC,MAAM6D,eAAe,GAAG,EAAxB;;IACA,WAAW,MAAMC,QAAjB,IAA6B,KAAKT,aAAL,CAAmBC,GAAnB,EAAwBhE,SAAS,CAACyE,sBAAlC,EAA0D/D,OAA1D,CAA7B,EAAiG;MAC/F,KAAKC,IAAL,CAAW,0BAAyB6D,QAAQ,CAAC7B,EAAG,EAAhD;;MACA4B,eAAe,CAACG,IAAhB,CACE,KAAKC,SAAL,CAAeH,QAAQ,CAAC7B,EAAxB,EAA4BjC,OAA5B,EACGkE,KADH,CACSjB,GAAG,IAAI;QACZ;QACA,KAAKhD,IAAL,CAAUkE,KAAV,CAAgBlB,GAAhB;MACD,CAJH,CADF;IAOD;;IACD,MAAMmB,OAAO,CAACC,GAAR,CAAYR,eAAZ,CAAN;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACe,MAAPS,OAAO,CAAEhB,GAAF,EAAOtD,OAAP,EAAgB;IAC3B;IACA,MAAM,KAAKG,OAAL,CAAaqD,cAAb,CAA4Bc,OAA5B,CAAoChB,GAApC,EAAyCtD,OAAzC,CAAN;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACmB,MAAXuE,WAAW,CAAE7C,IAAF,EAAQ8C,GAAR,EAAa;IAC5B,IAAI,CAAC,KAAK/D,QAAV,EAAoB,MAAM,IAAIgE,KAAJ,CAAU,wBAAV,CAAN;IAEpB,MAAMC,QAAQ,GAAGhD,IAAI,CAACe,WAAL,EAAjB;;IACA,KAAKxC,IAAL,CAAU,mBAAV,EAA+ByE,QAA/B,EAAyCF,GAAzC;;IAEA,MAAMhC,UAAU,GAAG,MAAM,KAAKrC,OAAL,CAAawE,IAAb,CAAkBjD,IAAlB,CAAzB;IACA,MAAM;MAAEa,MAAF;MAAUD;IAAV,IAAuB,MAAME,UAAU,CAACoC,SAAX,CAAqB,CAAClF,UAAD,EAAaD,UAAb,EAAyBD,UAAzB,CAArB,CAAnC;IAEA;;IACA,IAAIqF,UAAJ;;IACA,QAAQvC,QAAR;MACE,KAAK9C,UAAL;QACEqF,UAAU,GAAGL,GAAG,CAACM,qBAAJ,EAAb;QACA;;MACF,KAAKrF,UAAL;MACA,KAAKC,UAAL;QACEmF,UAAU,GAAGL,GAAG,CAACO,qBAAJ,EAAb;QACA;;MACF;QACE,MAAM,IAAIN,KAAJ,CAAU,uBAAuBnC,QAAjC,CAAN;IATJ,CAX4B,CAuB5B;;;IACA0C,YAAY,CAACzC,MAAD,EAASsC,UAAT,EAAqB,KAAK5E,IAA1B,CAAZ;;IAEA,KAAKgF,gBAAL,CAAsBvD,IAAtB,EAA4B8C,GAAG,CAACU,MAAhC;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACiB,MAATjB,SAAS,CAAEvC,IAAF,EAAQ1B,OAAR,EAAiB;IAAE;IAChC,IAAI,CAAC,KAAKS,QAAV,EAAoB;MAClB,MAAM,IAAIgE,KAAJ,CAAU,wBAAV,CAAN;IACD;;IAED,OAAO,KAAKtE,OAAL,CAAawE,IAAb,CAAkBjD,IAAlB,EAAwB1B,OAAxB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEiF,gBAAgB,CAAEvD,IAAF,EAAQwD,MAAR,EAAgB;IAC9B,MAAMhF,MAAM,GAAGwB,IAAI,CAACe,WAAL,EAAf;;IAEA,IAAI,KAAKjC,MAAT,EAAiB;MACf,KAAK,MAAM2E,KAAX,IAAoBD,MAAM,CAACrD,MAAP,EAApB,EAAqC;QACnC,KAAKrB,MAAL,CAAYwD,IAAZ,CAAiB9D,MAAjB,EAAyB,UAAzB,EAAqCiF,KAAK,CAACC,MAA3C;MACD;;MAED,KAAK5E,MAAL,CAAYwD,IAAZ,CAAiB9D,MAAjB,EAAyB,YAAzB,EAAuCgF,MAAM,CAACG,IAA9C;IACD;EACF;;AA9OW;AAiPd;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAeL,YAAf,CAA6BzC,MAA7B,EAAqCiC,GAArC,EAA0Cc,GAA1C,EAA+C;EAC7C,IAAI;IACF,MAAMnG,IAAI,CACR,CAACqF,GAAD,CADQ,EAERvF,EAAE,CAACsG,MAAH,EAFQ,EAGRhD,MAHQ,CAAV;EAKD,CAND,CAME,OAAOU,GAAP,EAAY;IACZqC,GAAG,CAACrC,GAAD,CAAH;EACD;AACF;;AAEDuC,MAAM,CAACC,OAAP,GAAiB9F,OAAjB"},"metadata":{},"sourceType":"script"}