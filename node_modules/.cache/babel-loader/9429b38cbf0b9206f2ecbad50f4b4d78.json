{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require('../errors'),\n    NotStartedError = _require.NotStartedError,\n    AlreadyStartingError = _require.AlreadyStartingError,\n    AlreadyStartedError = _require.AlreadyStartedError;\n\nvar _require2 = require('../utils'),\n    withTimeout = _require2.withTimeout;\n/**\n * @template T\n * @typedef {import('ipfs-core-types/src/utils').Await<T>} Await\n */\n\n/**\n * @template {(options:any) => any} T\n * @typedef {Parameters<T>[0]} Options\n */\n\n/**\n * @template {(options:any) => any} T\n * @typedef {ReturnType<T> extends ? Promise<infer U> ? U : ReturnType<T>} State\n */\n\n/**\n * Represents service state which can be not started in which case\n * it is instance of `Error`. Pending in which case it's promise or\n * ready in which case it is the value itself.\n *\n * @template T\n * @typedef {{ status: 'stopped' }\n * | { status: 'starting', ready: Await<T> }\n * | { status: 'started', value: T }\n * | { status: 'stopping', ready: Await<void> }\n * } ServiceState\n */\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @template Options, T\n *\n * Allows you to create a handle to service that can be started or\n * stopped. It enables defining components that need to use service\n * functionality before service is started.\n *\n */\n\n\nvar Service = /*#__PURE__*/function () {\n  /**\n   * Takes `activation` function that takes `options` and (async) returns\n   * an implementation.\n   *\n   * @private\n   * @param {(options:Options) => Await<T>} activate\n   * @param {(state:T) => Await<void>} [deactivate]\n   */\n  function Service(activate, deactivate) {\n    _classCallCheck(this, Service);\n\n    this.activate = activate;\n    this.deactivate = deactivate;\n    /**\n     * A state machine for this service.\n     *\n     * @private\n     * @type {ServiceState<T>}\n     */\n\n    this.state = {\n      status: 'stopped'\n    };\n  }\n  /**\n   * Allows you to asynchronously obtain service implementation. If service\n   * is starting it will await for completion. If service is stopped or stopping\n   * this will (async) throw exception. This allows components that need to use\n   * this service convenient API to do it.\n   *\n   * @param {AbortOptions} [options] - Abort options.\n   * @returns {Promise<T>}\n   */\n\n\n  _createClass(Service, [{\n    key: \"use\",\n    value: function () {\n      var _use = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return Service.use(this, options);\n\n              case 2:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function use(_x) {\n        return _use.apply(this, arguments);\n      }\n\n      return use;\n    }()\n    /**\n     * @returns {T|null}\n     */\n\n  }, {\n    key: \"try\",\n    value: function _try() {\n      return Service.try(this);\n    }\n  }], [{\n    key: \"create\",\n    value:\n    /**\n     * Takes `activation` function that takes `options` and (async) returns\n     * an implementation.\n     *\n     * @template {(options:any) => Await<any>} T\n     *\n     * @param {Object} config\n     * @param {T} config.start\n     * @param {(state:State<T>) => Await<void>} [config.stop]\n     * @returns {Service<Parameters<T>[0], State<T>>}\n     */\n    function create(_ref) {\n      var start = _ref.start,\n          stop = _ref.stop;\n      return new Service(start, stop);\n    }\n    /**\n     * Starts the service (by running actiavtion function). Will (async) throw\n     * unless service is stopped.\n     *\n     * @template Options, T\n     * @param {Service<Options, T>} service\n     * @param {Options} options\n     * @returns {Promise<T>}\n     */\n\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(service, options) {\n        var state, activate, promise, result;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                state = service.state, activate = service.activate;\n                _context2.t0 = state.status;\n                _context2.next = _context2.t0 === 'stopped' ? 4 : _context2.t0 === 'starting' ? 18 : _context2.t0 === 'started' ? 19 : _context2.t0 === 'stopping' ? 20 : 25;\n                break;\n\n              case 4:\n                _context2.prev = 4;\n                promise = activate(options);\n                service.state = {\n                  status: 'starting',\n                  ready: promise\n                }; // Note: MUST await after state transition above otherwise race\n                // condition may occur.\n\n                _context2.next = 9;\n                return promise;\n\n              case 9:\n                result = _context2.sent;\n                service.state = {\n                  status: 'started',\n                  value: result\n                };\n                return _context2.abrupt(\"return\", result);\n\n              case 14:\n                _context2.prev = 14;\n                _context2.t1 = _context2[\"catch\"](4);\n                service.state = {\n                  status: 'stopped'\n                };\n                throw _context2.t1;\n\n              case 18:\n                throw new AlreadyStartingError();\n\n              case 19:\n                throw new AlreadyStartedError();\n\n              case 20:\n                _context2.next = 22;\n                return state.ready;\n\n              case 22:\n                _context2.next = 24;\n                return Service.start(service, options);\n\n              case 24:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 25:\n                return _context2.abrupt(\"return\", Service.panic(service));\n\n              case 26:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[4, 14]]);\n      }));\n\n      function start(_x2, _x3) {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * Stops the service by executing deactivation. If service is stopped\n     * or is stopping this is noop. If service is starting up when called\n     * it will await for start to complete and then retry stop afterwards.\n     * This may (async) throw if `deactivate` does.\n     *\n     * @template T\n     * @param {Service<any, T>} service\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(service) {\n        var state, deactivate;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                state = service.state, deactivate = service.deactivate;\n                _context3.t0 = state.status;\n                _context3.next = _context3.t0 === 'stopped' ? 4 : _context3.t0 === 'starting' ? 5 : _context3.t0 === 'stopping' ? 15 : _context3.t0 === 'started' ? 18 : 23;\n                break;\n\n              case 4:\n                return _context3.abrupt(\"break\", 24);\n\n              case 5:\n                _context3.prev = 5;\n                _context3.next = 8;\n                return state.ready;\n\n              case 8:\n                _context3.next = 12;\n                break;\n\n              case 10:\n                _context3.prev = 10;\n                _context3.t1 = _context3[\"catch\"](5);\n\n              case 12:\n                _context3.next = 14;\n                return Service.stop(service);\n\n              case 14:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 15:\n                _context3.next = 17;\n                return state.ready;\n\n              case 17:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 18:\n                if (!deactivate) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                _context3.next = 21;\n                return deactivate(state.value);\n\n              case 21:\n                service.state = {\n                  status: 'stopped'\n                };\n                return _context3.abrupt(\"break\", 24);\n\n              case 23:\n                Service.panic(state);\n\n              case 24:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[5, 10]]);\n      }));\n\n      function stop(_x4) {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * @template T\n     * @param {Service<any, T>} service\n     * @returns {T|null}\n     */\n\n  }, {\n    key: \"try\",\n    value: function _try(_ref2) {\n      var state = _ref2.state;\n\n      switch (state.status) {\n        case 'started':\n          return state.value;\n\n        default:\n          return null;\n      }\n    }\n    /**\n     * Unwraps state and returns underlying value. If state is in idle state it\n     * will throw an error. If state is pending it will wait and return the\n     * result or throw on failure. If state is ready returns result.\n     *\n     * @template T\n     * @param {Service<any, T>} service\n     * @param {AbortOptions} [options]\n     * @returns {Promise<T>}\n     */\n\n  }, {\n    key: \"use\",\n    value: function () {\n      var _use2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref3, options) {\n        var state;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                state = _ref3.state;\n                _context4.t0 = state.status;\n                _context4.next = _context4.t0 === 'started' ? 4 : _context4.t0 === 'starting' ? 5 : 8;\n                break;\n\n              case 4:\n                return _context4.abrupt(\"return\", state.value);\n\n              case 5:\n                _context4.next = 7;\n                return withTimeout(state.ready, options);\n\n              case 7:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 8:\n                throw new NotStartedError();\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function use(_x5, _x6) {\n        return _use2.apply(this, arguments);\n      }\n\n      return use;\n    }() // eslint-disable-next-line jsdoc/require-returns-check\n\n    /**\n     * @private\n     * @param {Service<any, any>} service\n     * @returns {never}\n     */\n\n  }, {\n    key: \"panic\",\n    value: function panic(_ref4) {\n      var state = _ref4.state;\n      var status = JSON.stringify({\n        status: state.status\n      });\n      throw RangeError(\"Service in invalid state \".concat(status, \", should never happen if you see this please report a bug\"));\n    }\n  }]);\n\n  return Service;\n}();\n\nmodule.exports = Service;","map":{"version":3,"names":["require","NotStartedError","AlreadyStartingError","AlreadyStartedError","withTimeout","Service","activate","deactivate","state","status","options","use","try","start","stop","service","promise","ready","result","value","panic","JSON","stringify","RangeError","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/utils/service.js"],"sourcesContent":["'use strict'\n\nconst { NotStartedError, AlreadyStartingError, AlreadyStartedError } = require('../errors')\nconst { withTimeout } = require('../utils')\n\n/**\n * @template T\n * @typedef {import('ipfs-core-types/src/utils').Await<T>} Await\n */\n/**\n * @template {(options:any) => any} T\n * @typedef {Parameters<T>[0]} Options\n */\n/**\n * @template {(options:any) => any} T\n * @typedef {ReturnType<T> extends ? Promise<infer U> ? U : ReturnType<T>} State\n */\n/**\n * Represents service state which can be not started in which case\n * it is instance of `Error`. Pending in which case it's promise or\n * ready in which case it is the value itself.\n *\n * @template T\n * @typedef {{ status: 'stopped' }\n * | { status: 'starting', ready: Await<T> }\n * | { status: 'started', value: T }\n * | { status: 'stopping', ready: Await<void> }\n * } ServiceState\n */\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @template Options, T\n *\n * Allows you to create a handle to service that can be started or\n * stopped. It enables defining components that need to use service\n * functionality before service is started.\n *\n */\nclass Service {\n  /**\n   * Takes `activation` function that takes `options` and (async) returns\n   * an implementation.\n   *\n   * @template {(options:any) => Await<any>} T\n   *\n   * @param {Object} config\n   * @param {T} config.start\n   * @param {(state:State<T>) => Await<void>} [config.stop]\n   * @returns {Service<Parameters<T>[0], State<T>>}\n   */\n  static create ({ start, stop }) {\n    return new Service(start, stop)\n  }\n\n  /**\n   * Starts the service (by running actiavtion function). Will (async) throw\n   * unless service is stopped.\n   *\n   * @template Options, T\n   * @param {Service<Options, T>} service\n   * @param {Options} options\n   * @returns {Promise<T>}\n   */\n  static async start (service, options) {\n    const { state, activate } = service\n    switch (state.status) {\n      // If service is in 'stopped' state we activate and transition to\n      // to 'pending' state. Once activation is complete transition state to\n      // 'started' state.\n      // Note: This is the only code that does state transitions from\n      // - stopped\n      // - started\n      // Which ensures no race conditions can occur.\n      case 'stopped': {\n        try {\n          const promise = activate(options)\n          service.state = { status: 'starting', ready: promise }\n          // Note: MUST await after state transition above otherwise race\n          // condition may occur.\n          const result = await promise\n          service.state = { status: 'started', value: result }\n          return result\n        // If failed to start, transiton from 'starting' to 'stopped'\n        // state.\n        } catch (error) {\n          service.state = { status: 'stopped' }\n          throw error\n        }\n      }\n      case 'starting': {\n        throw new AlreadyStartingError()\n      }\n      case 'started': {\n        throw new AlreadyStartedError()\n      }\n      // If service is stopping we just wait for that to complete\n      // and try again.\n      case 'stopping': {\n        await state.ready\n        return await Service.start(service, options)\n      }\n      default: {\n        return Service.panic(service)\n      }\n    }\n  }\n\n  /**\n   * Stops the service by executing deactivation. If service is stopped\n   * or is stopping this is noop. If service is starting up when called\n   * it will await for start to complete and then retry stop afterwards.\n   * This may (async) throw if `deactivate` does.\n   *\n   * @template T\n   * @param {Service<any, T>} service\n   * @returns {Promise<void>}\n   */\n  static async stop (service) {\n    const { state, deactivate } = service\n    switch (state.status) {\n      // If stopped there's nothing to do.\n      case 'stopped': {\n        break\n      }\n      // If service is starting we await for it to complete\n      // and try again. That way\n      case 'starting': {\n        // We do not want to error stop if start failed.\n        try { await state.ready } catch (_) {}\n        return await Service.stop(service)\n      }\n      // if service is stopping we just await for it to complete.\n      case 'stopping': {\n        return await state.ready\n      }\n      case 'started': {\n        if (deactivate) {\n          await deactivate(state.value)\n        }\n        service.state = { status: 'stopped' }\n        break\n      }\n      default: {\n        Service.panic(state)\n      }\n    }\n  }\n\n  /**\n   * @template T\n   * @param {Service<any, T>} service\n   * @returns {T|null}\n   */\n  static try ({ state }) {\n    switch (state.status) {\n      case 'started':\n        return state.value\n      default:\n        return null\n    }\n  }\n\n  /**\n   * Unwraps state and returns underlying value. If state is in idle state it\n   * will throw an error. If state is pending it will wait and return the\n   * result or throw on failure. If state is ready returns result.\n   *\n   * @template T\n   * @param {Service<any, T>} service\n   * @param {AbortOptions} [options]\n   * @returns {Promise<T>}\n   */\n  static async use ({ state }, options) {\n    switch (state.status) {\n      case 'started':\n        return state.value\n      case 'starting':\n        return await withTimeout(state.ready, options)\n      default:\n        throw new NotStartedError()\n    }\n  }\n\n  // eslint-disable-next-line jsdoc/require-returns-check\n  /**\n   * @private\n   * @param {Service<any, any>} service\n   * @returns {never}\n   */\n  static panic ({ state }) {\n    const status = JSON.stringify({ status: state.status })\n    throw RangeError(`Service in invalid state ${status}, should never happen if you see this please report a bug`)\n  }\n\n  /**\n   * Takes `activation` function that takes `options` and (async) returns\n   * an implementation.\n   *\n   * @private\n   * @param {(options:Options) => Await<T>} activate\n   * @param {(state:T) => Await<void>} [deactivate]\n   */\n  constructor (activate, deactivate) {\n    this.activate = activate\n    this.deactivate = deactivate\n\n    /**\n     * A state machine for this service.\n     *\n     * @private\n     * @type {ServiceState<T>}\n     */\n    this.state = { status: 'stopped' }\n  }\n\n  /**\n   * Allows you to asynchronously obtain service implementation. If service\n   * is starting it will await for completion. If service is stopped or stopping\n   * this will (async) throw exception. This allows components that need to use\n   * this service convenient API to do it.\n   *\n   * @param {AbortOptions} [options] - Abort options.\n   * @returns {Promise<T>}\n   */\n  async use (options) {\n    return await Service.use(this, options)\n  }\n\n  /**\n   * @returns {T|null}\n   */\n  try () {\n    return Service.try(this)\n  }\n}\n\nmodule.exports = Service\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}