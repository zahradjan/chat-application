{"ast":null,"code":"var _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar node = require('./node');\n\nvar browser = require('./browser');\n\nvar _require = require('p-queue'),\n    Queue = _require.default;\n\nvar _require2 = require('promise-timeout'),\n    timeout = _require2.timeout;\n\nvar observe = require('observable-webworkers');\n\nvar mutexes = {};\nvar implementation;\n\nfunction createReleaseable(queue, options) {\n  var res;\n  var p = new Promise(function (resolve) {\n    res = resolve;\n  });\n  queue.add(function () {\n    return timeout(function () {\n      return new Promise(function (resolve) {\n        res(function () {\n          resolve();\n        });\n      });\n    }(), options.timeout);\n  });\n  return p;\n}\n\nvar createMutex = function createMutex(name, options) {\n  if (implementation.isWorker) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options)\n    };\n  }\n\n  var masterQueue = new Queue({\n    concurrency: 1\n  });\n  var readQueue = null;\n  return {\n    readLock: function readLock() {\n      // If there's already a read queue, just add the task to it\n      if (readQueue) {\n        return createReleaseable(readQueue, options);\n      } // Create a new read queue\n\n\n      readQueue = new Queue({\n        concurrency: options.concurrency,\n        autoStart: false\n      });\n      var localReadQueue = readQueue; // Add the task to the read queue\n\n      var readPromise = createReleaseable(readQueue, options);\n      masterQueue.add(function () {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start(); // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n\n        return localReadQueue.onIdle().then(function () {\n          if (readQueue === localReadQueue) {\n            readQueue = null;\n          }\n        });\n      });\n      return readPromise;\n    },\n    writeLock: function writeLock() {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null;\n      return createReleaseable(masterQueue, options);\n    }\n  };\n};\n\nvar defaultOptions = {\n  concurrency: Infinity,\n  timeout: 84600000,\n  global: global,\n  singleProcess: false\n};\n\nmodule.exports = function (name, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof name === 'object') {\n    options = name;\n    name = 'lock';\n  }\n\n  if (!name) {\n    name = 'lock';\n  }\n\n  options = Object.assign({}, defaultOptions, options);\n\n  if (!implementation) {\n    implementation = node(options) || browser(options);\n\n    if (!implementation.isWorker) {\n      // we are master, set up worker requests\n      implementation.on('requestReadLock', function (name, fn) {\n        if (!mutexes[name]) {\n          return;\n        }\n\n        mutexes[name].readLock().then(function (release) {\n          return fn().finally(function () {\n            return release();\n          });\n        });\n      });\n      implementation.on('requestWriteLock', /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(name, fn) {\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (mutexes[name]) {\n                    _context.next = 2;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\");\n\n                case 2:\n                  mutexes[name].writeLock().then(function (release) {\n                    return fn().finally(function () {\n                      return release();\n                    });\n                  });\n\n                case 3:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n  }\n\n  if (!mutexes[name]) {\n    mutexes[name] = createMutex(name, options);\n  }\n\n  return mutexes[name];\n};\n\nmodule.exports.Worker = function (script, Impl) {\n  Impl = Impl || global.Worker;\n  var worker;\n\n  try {\n    worker = new Impl(script);\n  } catch (error) {\n    if (error.message.includes('not a constructor')) {\n      worker = Impl(script);\n    }\n  }\n\n  if (!worker) {\n    throw new Error('Could not create Worker from', Impl);\n  }\n\n  observe(worker);\n  return worker;\n};","map":{"version":3,"names":["node","require","browser","Queue","default","timeout","observe","mutexes","implementation","createReleaseable","queue","options","res","p","Promise","resolve","add","createMutex","name","isWorker","readLock","writeLock","masterQueue","concurrency","readQueue","autoStart","localReadQueue","readPromise","start","onIdle","then","defaultOptions","Infinity","global","singleProcess","module","exports","Object","assign","on","fn","release","finally","Worker","script","Impl","worker","error","message","includes","Error"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/mortice/lib/index.js"],"sourcesContent":["const node = require('./node')\nconst browser = require('./browser')\nconst { default: Queue } = require('p-queue')\nconst { timeout } = require('promise-timeout')\nconst observe = require('observable-webworkers')\n\nconst mutexes = {}\nlet implementation\n\nfunction createReleaseable (queue, options) {\n  let res\n\n  const p = new Promise((resolve) => {\n    res = resolve\n  })\n\n  queue.add(() => timeout((() => {\n    return new Promise((resolve) => {\n      res(() => {\n        resolve()\n      })\n    })\n  })(), options.timeout))\n\n  return p\n}\n\nconst createMutex = (name, options) => {\n  if (implementation.isWorker) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options)\n    }\n  }\n\n  const masterQueue = new Queue({ concurrency: 1 })\n  let readQueue = null\n\n  return {\n    readLock: () => {\n      // If there's already a read queue, just add the task to it\n      if (readQueue) {\n        return createReleaseable(readQueue, options)\n      }\n\n      // Create a new read queue\n      readQueue = new Queue({\n        concurrency: options.concurrency,\n        autoStart: false\n      })\n      const localReadQueue = readQueue\n\n      // Add the task to the read queue\n      const readPromise = createReleaseable(readQueue, options)\n\n      masterQueue.add(() => {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start()\n\n        // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n        return localReadQueue.onIdle()\n          .then(() => {\n            if (readQueue === localReadQueue) {\n              readQueue = null\n            }\n          })\n      })\n\n      return readPromise\n    },\n    writeLock: () => {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null\n\n      return createReleaseable(masterQueue, options)\n    }\n  }\n}\n\nconst defaultOptions = {\n  concurrency: Infinity,\n  timeout: 84600000,\n  global: global,\n  singleProcess: false\n}\n\nmodule.exports = (name, options) => {\n  if (!options) {\n    options = {}\n  }\n\n  if (typeof name === 'object') {\n    options = name\n    name = 'lock'\n  }\n\n  if (!name) {\n    name = 'lock'\n  }\n\n  options = Object.assign({}, defaultOptions, options)\n\n  if (!implementation) {\n    implementation = node(options) || browser(options)\n\n    if (!implementation.isWorker) {\n      // we are master, set up worker requests\n      implementation.on('requestReadLock', (name, fn) => {\n        if (!mutexes[name]) {\n          return\n        }\n\n        mutexes[name].readLock()\n          .then(release => fn().finally(() => release()))\n      })\n\n      implementation.on('requestWriteLock', async (name, fn) => {\n        if (!mutexes[name]) {\n          return\n        }\n\n        mutexes[name].writeLock()\n          .then(release => fn().finally(() => release()))\n      })\n    }\n  }\n\n  if (!mutexes[name]) {\n    mutexes[name] = createMutex(name, options)\n  }\n\n  return mutexes[name]\n}\n\nmodule.exports.Worker = function (script, Impl) {\n  Impl = Impl || global.Worker\n  let worker\n\n  try {\n    worker = new Impl(script)\n  } catch (error) {\n    if (error.message.includes('not a constructor')) {\n      worker = Impl(script)\n    }\n  }\n\n  if (!worker) {\n    throw new Error('Could not create Worker from', Impl)\n  }\n\n  observe(worker)\n\n  return worker\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}