{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar debug = require('debug');\n\nvar _require = require('parse-duration'),\n    parseDuration = _require.default;\n\nvar crypto = require('libp2p-crypto');\n\nvar errcode = require('err-code');\n\nvar _require2 = require('uint8arrays/from-string'),\n    uint8ArrayFromString = _require2.fromString;\n\nvar _require3 = require('uint8arrays/to-string'),\n    uint8ArrayToString = _require3.toString;\n\nvar log = Object.assign(debug('ipfs:name:publish'), {\n  error: debug('ipfs:name:publish:error')\n});\n\nvar _require4 = require('../../utils'),\n    OFFLINE_ERROR = _require4.OFFLINE_ERROR,\n    normalizePath = _require4.normalizePath;\n\nvar withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nvar _require5 = require('./utils'),\n    resolvePath = _require5.resolvePath;\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('../ipns')} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('libp2p/src/keychain')} config.keychain\n */\n\n\nmodule.exports = function (_ref) {\n  var ipns = _ref.ipns,\n      repo = _ref.repo,\n      codecs = _ref.codecs,\n      peerId = _ref.peerId,\n      isOnline = _ref.isOnline,\n      keychain = _ref.keychain;\n\n  /**\n   * @param {string} keyName\n   */\n  var lookupKey = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(keyName) {\n      var pem, privateKey;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(keyName === 'self')) {\n                _context.next = 2;\n                break;\n              }\n\n              return _context.abrupt(\"return\", peerId.privKey);\n\n            case 2:\n              _context.prev = 2;\n              _context.next = 5;\n              return keychain.exportKey(keyName, 'temp');\n\n            case 5:\n              pem = _context.sent;\n              _context.next = 8;\n              return crypto.keys.import(pem, 'temp');\n\n            case 8:\n              privateKey = _context.sent;\n              return _context.abrupt(\"return\", privateKey);\n\n            case 12:\n              _context.prev = 12;\n              _context.t0 = _context[\"catch\"](2);\n              log.error(_context.t0);\n              throw errcode(_context.t0, 'ERR_CANNOT_GET_KEY');\n\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 12]]);\n    }));\n\n    return function lookupKey(_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"publish\"]}\n   */\n\n\n  function publish(_x2) {\n    return _publish.apply(this, arguments);\n  }\n\n  function _publish() {\n    _publish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(value) {\n      var options,\n          resolve,\n          lifetime,\n          key,\n          pubLifetime,\n          results,\n          bytes,\n          result,\n          _args2 = arguments;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n              resolve = !(options.resolve === false);\n              lifetime = options.lifetime || '24h';\n              key = options.key || 'self';\n\n              if (isOnline()) {\n                _context2.next = 6;\n                break;\n              }\n\n              throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n\n            case 6:\n              _context2.prev = 6;\n              value = normalizePath(value);\n              _context2.next = 14;\n              break;\n\n            case 10:\n              _context2.prev = 10;\n              _context2.t0 = _context2[\"catch\"](6);\n              log.error(_context2.t0);\n              throw _context2.t0;\n\n            case 14:\n              pubLifetime = 0;\n              _context2.prev = 15;\n              pubLifetime = parseDuration(lifetime) || 0; // Calculate lifetime with nanoseconds precision\n\n              pubLifetime = parseFloat(pubLifetime.toFixed(6));\n              _context2.next = 24;\n              break;\n\n            case 20:\n              _context2.prev = 20;\n              _context2.t1 = _context2[\"catch\"](15);\n              log.error(_context2.t1);\n              throw _context2.t1;\n\n            case 24:\n              _context2.next = 26;\n              return Promise.all([// verify if the path exists, if not, an error will stop the execution\n              lookupKey(key), // if resolving, do a get so we make sure we have the blocks\n              resolve ? resolvePath({\n                ipns: ipns,\n                repo: repo,\n                codecs: codecs\n              }, value) : Promise.resolve()]);\n\n            case 26:\n              results = _context2.sent;\n              bytes = uint8ArrayFromString(value); // Start publishing process\n\n              _context2.next = 30;\n              return ipns.publish(results[0], bytes, pubLifetime);\n\n            case 30:\n              result = _context2.sent;\n              return _context2.abrupt(\"return\", {\n                name: result.name,\n                value: uint8ArrayToString(result.value)\n              });\n\n            case 32:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[6, 10], [15, 20]]);\n    }));\n    return _publish.apply(this, arguments);\n  }\n\n  return withTimeoutOption(publish);\n};","map":{"version":3,"names":["debug","require","parseDuration","default","crypto","errcode","uint8ArrayFromString","fromString","uint8ArrayToString","toString","log","Object","assign","error","OFFLINE_ERROR","normalizePath","withTimeoutOption","resolvePath","module","exports","ipns","repo","codecs","peerId","isOnline","keychain","lookupKey","keyName","privKey","exportKey","pem","keys","import","privateKey","publish","value","options","resolve","lifetime","key","Error","pubLifetime","parseFloat","toFixed","Promise","all","results","bytes","result","name"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/ipfs-core/src/components/name/publish.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst { default: parseDuration } = require('parse-duration')\nconst crypto = require('libp2p-crypto')\nconst errcode = require('err-code')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst log = Object.assign(debug('ipfs:name:publish'), {\n  error: debug('ipfs:name:publish:error')\n})\n\nconst { OFFLINE_ERROR, normalizePath } = require('../../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { resolvePath } = require('./utils')\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('../ipns')} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('libp2p/src/keychain')} config.keychain\n */\nmodule.exports = ({ ipns, repo, codecs, peerId, isOnline, keychain }) => {\n  /**\n   * @param {string} keyName\n   */\n  const lookupKey = async keyName => {\n    if (keyName === 'self') {\n      return peerId.privKey\n    }\n\n    try {\n      // We're exporting and immediately importing the key, so we can just use a throw away password\n      const pem = await keychain.exportKey(keyName, 'temp')\n      const privateKey = await crypto.keys.import(pem, 'temp')\n      return privateKey\n    } catch (err) {\n      log.error(err)\n      throw errcode(err, 'ERR_CANNOT_GET_KEY')\n    }\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"publish\"]}\n   */\n  async function publish (value, options = {}) {\n    const resolve = !(options.resolve === false)\n    const lifetime = options.lifetime || '24h'\n    const key = options.key || 'self'\n\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    // TODO: params related logic should be in the core implementation\n    // Normalize path value\n    try {\n      value = normalizePath(value)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    let pubLifetime = 0\n    try {\n      pubLifetime = parseDuration(lifetime) || 0\n\n      // Calculate lifetime with nanoseconds precision\n      pubLifetime = parseFloat(pubLifetime.toFixed(6))\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    // TODO: ttl human for cache\n    const results = await Promise.all([\n      // verify if the path exists, if not, an error will stop the execution\n      lookupKey(key),\n      // if resolving, do a get so we make sure we have the blocks\n      resolve ? resolvePath({ ipns, repo, codecs }, value) : Promise.resolve()\n    ])\n\n    const bytes = uint8ArrayFromString(value)\n\n    // Start publishing process\n    const result = await ipns.publish(results[0], bytes, pubLifetime)\n\n    return {\n      name: result.name,\n      value: uint8ArrayToString(result.value)\n    }\n  }\n\n  return withTimeoutOption(publish)\n}\n"],"mappings":"AAAA;;;;;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,eAAmCA,OAAO,CAAC,gBAAD,CAA1C;AAAA,IAAiBC,aAAjB,YAAQC,OAAR;;AACA,IAAMC,MAAM,GAAGH,OAAO,CAAC,eAAD,CAAtB;;AACA,IAAMI,OAAO,GAAGJ,OAAO,CAAC,UAAD,CAAvB;;AACA,gBAA6CA,OAAO,CAAC,yBAAD,CAApD;AAAA,IAAoBK,oBAApB,aAAQC,UAAR;;AACA,gBAAyCN,OAAO,CAAC,uBAAD,CAAhD;AAAA,IAAkBO,kBAAlB,aAAQC,QAAR;;AAEA,IAAMC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcZ,KAAK,CAAC,mBAAD,CAAnB,EAA0C;EACpDa,KAAK,EAAEb,KAAK,CAAC,yBAAD;AADwC,CAA1C,CAAZ;;AAIA,gBAAyCC,OAAO,CAAC,aAAD,CAAhD;AAAA,IAAQa,aAAR,aAAQA,aAAR;AAAA,IAAuBC,aAAvB,aAAuBA,aAAvB;;AACA,IAAMC,iBAAiB,GAAGf,OAAO,CAAC,yCAAD,CAAjC;;AACA,gBAAwBA,OAAO,CAAC,SAAD,CAA/B;AAAA,IAAQgB,WAAR,aAAQA,WAAR;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,gBAAwD;EAAA,IAArDC,IAAqD,QAArDA,IAAqD;EAAA,IAA/CC,IAA+C,QAA/CA,IAA+C;EAAA,IAAzCC,MAAyC,QAAzCA,MAAyC;EAAA,IAAjCC,MAAiC,QAAjCA,MAAiC;EAAA,IAAzBC,QAAyB,QAAzBA,QAAyB;EAAA,IAAfC,QAAe,QAAfA,QAAe;;EACvE;AACF;AACA;EACE,IAAMC,SAAS;IAAA,uEAAG,iBAAMC,OAAN;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA,MACZA,OAAO,KAAK,MADA;gBAAA;gBAAA;cAAA;;cAAA,iCAEPJ,MAAM,CAACK,OAFA;;YAAA;cAAA;cAAA;cAAA,OAOIH,QAAQ,CAACI,SAAT,CAAmBF,OAAnB,EAA4B,MAA5B,CAPJ;;YAAA;cAORG,GAPQ;cAAA;cAAA,OAQW1B,MAAM,CAAC2B,IAAP,CAAYC,MAAZ,CAAmBF,GAAnB,EAAwB,MAAxB,CARX;;YAAA;cAQRG,UARQ;cAAA,iCASPA,UATO;;YAAA;cAAA;cAAA;cAWdvB,GAAG,CAACG,KAAJ;cAXc,MAYRR,OAAO,cAAM,oBAAN,CAZC;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAAH;;IAAA,gBAATqB,SAAS;MAAA;IAAA;EAAA,GAAf;EAgBA;AACF;AACA;;;EAtByE,SAuBxDQ,OAvBwD;IAAA;EAAA;;EAAA;IAAA,sEAuBvE,kBAAwBC,KAAxB;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;QAAA;UAAA;YAAA;cAA+BC,OAA/B,8DAAyC,EAAzC;cACQC,OADR,GACkB,EAAED,OAAO,CAACC,OAAR,KAAoB,KAAtB,CADlB;cAEQC,QAFR,GAEmBF,OAAO,CAACE,QAAR,IAAoB,KAFvC;cAGQC,GAHR,GAGcH,OAAO,CAACG,GAAR,IAAe,MAH7B;;cAAA,IAKOf,QAAQ,EALf;gBAAA;gBAAA;cAAA;;cAAA,MAMUnB,OAAO,CAAC,IAAImC,KAAJ,CAAU1B,aAAV,CAAD,EAA2B,eAA3B,CANjB;;YAAA;cAAA;cAYIqB,KAAK,GAAGpB,aAAa,CAACoB,KAAD,CAArB;cAZJ;cAAA;;YAAA;cAAA;cAAA;cAcIzB,GAAG,CAACG,KAAJ;cAdJ;;YAAA;cAkBM4B,WAlBN,GAkBoB,CAlBpB;cAAA;cAoBIA,WAAW,GAAGvC,aAAa,CAACoC,QAAD,CAAb,IAA2B,CAAzC,CApBJ,CAsBI;;cACAG,WAAW,GAAGC,UAAU,CAACD,WAAW,CAACE,OAAZ,CAAoB,CAApB,CAAD,CAAxB;cAvBJ;cAAA;;YAAA;cAAA;cAAA;cAyBIjC,GAAG,CAACG,KAAJ;cAzBJ;;YAAA;cAAA;cAAA,OA8BwB+B,OAAO,CAACC,GAAR,CAAY,CAChC;cACAnB,SAAS,CAACa,GAAD,CAFuB,EAGhC;cACAF,OAAO,GAAGpB,WAAW,CAAC;gBAAEG,IAAI,EAAJA,IAAF;gBAAQC,IAAI,EAAJA,IAAR;gBAAcC,MAAM,EAANA;cAAd,CAAD,EAAyBa,KAAzB,CAAd,GAAgDS,OAAO,CAACP,OAAR,EAJvB,CAAZ,CA9BxB;;YAAA;cA8BQS,OA9BR;cAqCQC,KArCR,GAqCgBzC,oBAAoB,CAAC6B,KAAD,CArCpC,EAuCE;;cAvCF;cAAA,OAwCuBf,IAAI,CAACc,OAAL,CAAaY,OAAO,CAAC,CAAD,CAApB,EAAyBC,KAAzB,EAAgCN,WAAhC,CAxCvB;;YAAA;cAwCQO,MAxCR;cAAA,kCA0CS;gBACLC,IAAI,EAAED,MAAM,CAACC,IADR;gBAELd,KAAK,EAAE3B,kBAAkB,CAACwC,MAAM,CAACb,KAAR;cAFpB,CA1CT;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAvBuE;IAAA;EAAA;;EAuEvE,OAAOnB,iBAAiB,CAACkB,OAAD,CAAxB;AACD,CAxED"},"metadata":{},"sourceType":"script"}