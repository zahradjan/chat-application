{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _objectSpread = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar pipe = require('it-pipe');\n\nvar pushable = require('it-pushable');\n\nvar log = require('debug')('libp2p:mplex');\n\nvar abortable = require('abortable-iterator');\n\nvar Coder = require('./coder');\n\nvar restrictSize = require('./restrict-size');\n\nvar _require = require('./message-types'),\n    MessageTypes = _require.MessageTypes,\n    MessageTypeNames = _require.MessageTypeNames;\n\nvar createStream = require('./stream');\n\nvar Mplex = /*#__PURE__*/function () {\n  /**\n   * @class\n   * @param {object} options\n   * @param {function(*)} options.onStream - Called whenever an inbound stream is created\n   * @param {function(*)} options.onStreamEnd - Called whenever a stream ends\n   * @param {AbortSignal} options.signal - An AbortController signal\n   */\n  function Mplex(options) {\n    _classCallCheck(this, Mplex);\n\n    options = options || {};\n    options = typeof options === 'function' ? {\n      onStream: options\n    } : options;\n    this._streamId = 0;\n    this._streams = {\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      initiators: new Map(),\n\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      receivers: new Map()\n    };\n    this._options = options;\n    /**\n     * An iterable sink\n     */\n\n    this.sink = this._createSink();\n    /**\n     * An iterable source\n     */\n\n    this.source = this._createSource();\n    /**\n     * @property {Function} onStream\n     */\n\n    this.onStream = options.onStream;\n    /**\n     * @property {Function} onStreamEnd\n     */\n\n    this.onStreamEnd = options.onStreamEnd;\n  }\n  /**\n   * Returns a Map of streams and their ids\n   *\n   * @returns {Map<number,*>}\n   */\n\n\n  _createClass(Mplex, [{\n    key: \"streams\",\n    get: function get() {\n      // Inbound and Outbound streams may have the same ids, so we need to make those unique\n      var streams = [];\n\n      this._streams.initiators.forEach(function (stream) {\n        streams.push(stream);\n      });\n\n      this._streams.receivers.forEach(function (stream) {\n        streams.push(stream);\n      });\n\n      return streams;\n    }\n    /**\n     * Initiate a new stream with the given name. If no name is\n     * provided, the id of th stream will be used.\n     *\n     * @param {string} [name] - If name is not a string it will be cast to one\n     * @returns {Stream}\n     */\n\n  }, {\n    key: \"newStream\",\n    value: function newStream(name) {\n      var id = this._streamId++;\n      name = name == null ? id.toString() : String(name);\n      var registry = this._streams.initiators;\n      return this._newStream({\n        id: id,\n        name: name,\n        type: 'initiator',\n        registry: registry\n      });\n    }\n    /**\n     * Called whenever an inbound stream is created\n     *\n     * @private\n     * @param {*} options\n     * @param {number} options.id\n     * @param {string} options.name\n     * @returns {*} A muxed stream\n     */\n\n  }, {\n    key: \"_newReceiverStream\",\n    value: function _newReceiverStream(_ref) {\n      var id = _ref.id,\n          name = _ref.name;\n      var registry = this._streams.receivers;\n      return this._newStream({\n        id: id,\n        name: name,\n        type: 'receiver',\n        registry: registry\n      });\n    }\n    /**\n     * Creates a new stream\n     *\n     * @private\n     * @param {object} options\n     * @param {number} options.id\n     * @param {string} options.name\n     * @param {string} options.type\n     * @param {Map<number, *>} options.registry - A map of streams to their ids\n     * @returns {*} A muxed stream\n     */\n\n  }, {\n    key: \"_newStream\",\n    value: function _newStream(_ref2) {\n      var _this = this;\n\n      var id = _ref2.id,\n          name = _ref2.name,\n          type = _ref2.type,\n          registry = _ref2.registry;\n\n      if (registry.has(id)) {\n        throw new Error(\"\".concat(type, \" stream \").concat(id, \" already exists!\"));\n      }\n\n      log('new %s stream %s %s', type, id, name);\n\n      var send = function send(msg) {\n        if (log.enabled) {\n          log('%s stream %s %s send', type, id, name, _objectSpread(_objectSpread({}, msg), {}, {\n            type: MessageTypeNames[msg.type],\n            data: msg.data && msg.data.slice()\n          }));\n        }\n\n        return _this.source.push(msg);\n      };\n\n      var onEnd = function onEnd() {\n        log('%s stream %s %s ended', type, id, name);\n        registry.delete(id);\n        _this.onStreamEnd && _this.onStreamEnd(stream);\n      };\n\n      var stream = createStream({\n        id: id,\n        name: name,\n        send: send,\n        type: type,\n        onEnd: onEnd,\n        maxMsgSize: this._options.maxMsgSize\n      });\n      registry.set(id, stream);\n      return stream;\n    }\n    /**\n     * Creates a sink with an abortable source. Incoming messages will\n     * also have their size restricted. All messages will be varint decoded.\n     *\n     * @private\n     * @returns {*} Returns an iterable sink\n     */\n\n  }, {\n    key: \"_createSink\",\n    value: function _createSink() {\n      var _this2 = this;\n\n      return /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source) {\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (_this2._options.signal) {\n                    source = abortable(source, _this2._options.signal);\n                  }\n\n                  _context2.prev = 1;\n                  _context2.next = 4;\n                  return pipe(source, Coder.decode, restrictSize(_this2._options.maxMsgSize), /*#__PURE__*/function () {\n                    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n                      var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, msgs, _iterator2, _step2, msg;\n\n                      return _regeneratorRuntime().wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              _iteratorAbruptCompletion = false;\n                              _didIteratorError = false;\n                              _context.prev = 2;\n                              _iterator = _asyncIterator(source);\n\n                            case 4:\n                              _context.next = 6;\n                              return _iterator.next();\n\n                            case 6:\n                              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                                _context.next = 13;\n                                break;\n                              }\n\n                              msgs = _step.value;\n                              _iterator2 = _createForOfIteratorHelper(msgs);\n\n                              try {\n                                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                                  msg = _step2.value;\n\n                                  _this2._handleIncoming(msg);\n                                }\n                              } catch (err) {\n                                _iterator2.e(err);\n                              } finally {\n                                _iterator2.f();\n                              }\n\n                            case 10:\n                              _iteratorAbruptCompletion = false;\n                              _context.next = 4;\n                              break;\n\n                            case 13:\n                              _context.next = 19;\n                              break;\n\n                            case 15:\n                              _context.prev = 15;\n                              _context.t0 = _context[\"catch\"](2);\n                              _didIteratorError = true;\n                              _iteratorError = _context.t0;\n\n                            case 19:\n                              _context.prev = 19;\n                              _context.prev = 20;\n\n                              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                                _context.next = 24;\n                                break;\n                              }\n\n                              _context.next = 24;\n                              return _iterator.return();\n\n                            case 24:\n                              _context.prev = 24;\n\n                              if (!_didIteratorError) {\n                                _context.next = 27;\n                                break;\n                              }\n\n                              throw _iteratorError;\n\n                            case 27:\n                              return _context.finish(24);\n\n                            case 28:\n                              return _context.finish(19);\n\n                            case 29:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee, null, [[2, 15, 19, 29], [20,, 24, 28]]);\n                    }));\n\n                    return function (_x2) {\n                      return _ref4.apply(this, arguments);\n                    };\n                  }());\n\n                case 4:\n                  _context2.next = 10;\n                  break;\n\n                case 6:\n                  _context2.prev = 6;\n                  _context2.t0 = _context2[\"catch\"](1);\n                  log('error in sink', _context2.t0);\n                  return _context2.abrupt(\"return\", _this2.source.end(_context2.t0));\n\n                case 10:\n                  _this2.source.end();\n\n                case 11:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[1, 6]]);\n        }));\n\n        return function (_x) {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n    }\n    /**\n     * Creates a source that restricts outgoing message sizes\n     * and varint encodes them.\n     *\n     * @private\n     * @returns {*} An iterable source\n     */\n\n  }, {\n    key: \"_createSource\",\n    value: function _createSource() {\n      var _this3 = this;\n\n      var onEnd = function onEnd(err) {\n        var _this3$_streams = _this3._streams,\n            initiators = _this3$_streams.initiators,\n            receivers = _this3$_streams.receivers; // Abort all the things!\n\n        var _iterator3 = _createForOfIteratorHelper(initiators.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var s = _step3.value;\n            s.abort(err);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        var _iterator4 = _createForOfIteratorHelper(receivers.values()),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _s = _step4.value;\n\n            _s.abort(err);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      };\n\n      var source = pushable({\n        onEnd: onEnd,\n        writev: true\n      });\n      return Object.assign(Coder.encode(source), {\n        push: source.push,\n        end: source.end,\n        return: source.return\n      });\n    }\n    /**\n     * @private\n     * @param {object} options\n     * @param {number} options.id\n     * @param {string} options.type\n     * @param {Uint8Array|BufferList} options.data\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_handleIncoming\",\n    value: function _handleIncoming(_ref5) {\n      var id = _ref5.id,\n          type = _ref5.type,\n          data = _ref5.data;\n\n      if (log.enabled) {\n        log('incoming message', {\n          id: id,\n          type: MessageTypeNames[type],\n          data: data.slice()\n        });\n      } // Create a new stream?\n\n\n      if (type === MessageTypes.NEW_STREAM && this.onStream) {\n        var _stream = this._newReceiverStream({\n          id: id,\n          name: data.toString()\n        });\n\n        return this.onStream(_stream);\n      }\n\n      var list = type & 1 ? this._streams.initiators : this._streams.receivers;\n      var stream = list.get(id);\n      if (!stream) return log('missing stream %s', id);\n\n      switch (type) {\n        case MessageTypes.MESSAGE_INITIATOR:\n        case MessageTypes.MESSAGE_RECEIVER:\n          stream.source.push(data);\n          break;\n\n        case MessageTypes.CLOSE_INITIATOR:\n        case MessageTypes.CLOSE_RECEIVER:\n          stream.close();\n          break;\n\n        case MessageTypes.RESET_INITIATOR:\n        case MessageTypes.RESET_RECEIVER:\n          stream.reset();\n          break;\n\n        default:\n          log('unknown message type %s', type);\n      }\n    }\n  }]);\n\n  return Mplex;\n}();\n\nMplex.multicodec = '/mplex/6.7.0';\nmodule.exports = Mplex;","map":{"version":3,"names":["pipe","require","pushable","log","abortable","Coder","restrictSize","MessageTypes","MessageTypeNames","createStream","Mplex","options","onStream","_streamId","_streams","initiators","Map","receivers","_options","sink","_createSink","source","_createSource","onStreamEnd","streams","forEach","stream","push","name","id","toString","String","registry","_newStream","type","has","Error","send","msg","enabled","data","slice","onEnd","delete","maxMsgSize","set","signal","decode","msgs","_handleIncoming","end","err","values","s","abort","writev","Object","assign","encode","return","NEW_STREAM","_newReceiverStream","list","get","MESSAGE_INITIATOR","MESSAGE_RECEIVER","CLOSE_INITIATOR","CLOSE_RECEIVER","close","RESET_INITIATOR","RESET_RECEIVER","reset","multicodec","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-mplex/src/mplex.js"],"sourcesContent":["'use strict'\n\nconst pipe = require('it-pipe')\nconst pushable = require('it-pushable')\nconst log = require('debug')('libp2p:mplex')\nconst abortable = require('abortable-iterator')\nconst Coder = require('./coder')\nconst restrictSize = require('./restrict-size')\nconst { MessageTypes, MessageTypeNames } = require('./message-types')\nconst createStream = require('./stream')\n\nclass Mplex {\n  /**\n   * @class\n   * @param {object} options\n   * @param {function(*)} options.onStream - Called whenever an inbound stream is created\n   * @param {function(*)} options.onStreamEnd - Called whenever a stream ends\n   * @param {AbortSignal} options.signal - An AbortController signal\n   */\n  constructor (options) {\n    options = options || {}\n    options = typeof options === 'function' ? { onStream: options } : options\n\n    this._streamId = 0\n    this._streams = {\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      initiators: new Map(),\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      receivers: new Map()\n    }\n    this._options = options\n\n    /**\n     * An iterable sink\n     */\n    this.sink = this._createSink()\n\n    /**\n     * An iterable source\n     */\n    this.source = this._createSource()\n\n    /**\n     * @property {Function} onStream\n     */\n    this.onStream = options.onStream\n\n    /**\n     * @property {Function} onStreamEnd\n     */\n    this.onStreamEnd = options.onStreamEnd\n  }\n\n  /**\n   * Returns a Map of streams and their ids\n   *\n   * @returns {Map<number,*>}\n   */\n  get streams () {\n    // Inbound and Outbound streams may have the same ids, so we need to make those unique\n    const streams = []\n    this._streams.initiators.forEach(stream => {\n      streams.push(stream)\n    })\n    this._streams.receivers.forEach(stream => {\n      streams.push(stream)\n    })\n    return streams\n  }\n\n  /**\n   * Initiate a new stream with the given name. If no name is\n   * provided, the id of th stream will be used.\n   *\n   * @param {string} [name] - If name is not a string it will be cast to one\n   * @returns {Stream}\n   */\n  newStream (name) {\n    const id = this._streamId++\n    name = name == null ? id.toString() : String(name)\n    const registry = this._streams.initiators\n    return this._newStream({ id, name, type: 'initiator', registry })\n  }\n\n  /**\n   * Called whenever an inbound stream is created\n   *\n   * @private\n   * @param {*} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @returns {*} A muxed stream\n   */\n  _newReceiverStream ({ id, name }) {\n    const registry = this._streams.receivers\n    return this._newStream({ id, name, type: 'receiver', registry })\n  }\n\n  /**\n   * Creates a new stream\n   *\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @param {string} options.type\n   * @param {Map<number, *>} options.registry - A map of streams to their ids\n   * @returns {*} A muxed stream\n   */\n  _newStream ({ id, name, type, registry }) {\n    if (registry.has(id)) {\n      throw new Error(`${type} stream ${id} already exists!`)\n    }\n    log('new %s stream %s %s', type, id, name)\n    const send = msg => {\n      if (log.enabled) {\n        log('%s stream %s %s send', type, id, name, { ...msg, type: MessageTypeNames[msg.type], data: msg.data && msg.data.slice() })\n      }\n      return this.source.push(msg)\n    }\n    const onEnd = () => {\n      log('%s stream %s %s ended', type, id, name)\n      registry.delete(id)\n      this.onStreamEnd && this.onStreamEnd(stream)\n    }\n    const stream = createStream({ id, name, send, type, onEnd, maxMsgSize: this._options.maxMsgSize })\n    registry.set(id, stream)\n    return stream\n  }\n\n  /**\n   * Creates a sink with an abortable source. Incoming messages will\n   * also have their size restricted. All messages will be varint decoded.\n   *\n   * @private\n   * @returns {*} Returns an iterable sink\n   */\n  _createSink () {\n    return async source => {\n      if (this._options.signal) {\n        source = abortable(source, this._options.signal)\n      }\n\n      try {\n        await pipe(\n          source,\n          Coder.decode,\n          restrictSize(this._options.maxMsgSize),\n          async source => {\n            for await (const msgs of source) {\n              for (const msg of msgs) {\n                this._handleIncoming(msg)\n              }\n            }\n          }\n        )\n      } catch (err) {\n        log('error in sink', err)\n        return this.source.end(err) // End the source with an error\n      }\n\n      this.source.end()\n    }\n  }\n\n  /**\n   * Creates a source that restricts outgoing message sizes\n   * and varint encodes them.\n   *\n   * @private\n   * @returns {*} An iterable source\n   */\n  _createSource () {\n    const onEnd = err => {\n      const { initiators, receivers } = this._streams\n      // Abort all the things!\n      for (const s of initiators.values()) s.abort(err)\n      for (const s of receivers.values()) s.abort(err)\n    }\n    const source = pushable({ onEnd, writev: true })\n    return Object.assign(Coder.encode(source), {\n      push: source.push,\n      end: source.end,\n      return: source.return\n    })\n  }\n\n  /**\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.type\n   * @param {Uint8Array|BufferList} options.data\n   * @returns {void}\n   */\n  _handleIncoming ({ id, type, data }) {\n    if (log.enabled) {\n      log('incoming message', { id, type: MessageTypeNames[type], data: data.slice() })\n    }\n\n    // Create a new stream?\n    if (type === MessageTypes.NEW_STREAM && this.onStream) {\n      const stream = this._newReceiverStream({ id, name: data.toString() })\n      return this.onStream(stream)\n    }\n\n    const list = type & 1 ? this._streams.initiators : this._streams.receivers\n    const stream = list.get(id)\n\n    if (!stream) return log('missing stream %s', id)\n\n    switch (type) {\n      case MessageTypes.MESSAGE_INITIATOR:\n      case MessageTypes.MESSAGE_RECEIVER:\n        stream.source.push(data)\n        break\n      case MessageTypes.CLOSE_INITIATOR:\n      case MessageTypes.CLOSE_RECEIVER:\n        stream.close()\n        break\n      case MessageTypes.RESET_INITIATOR:\n      case MessageTypes.RESET_RECEIVER:\n        stream.reset()\n        break\n      default:\n        log('unknown message type %s', type)\n    }\n  }\n}\n\nMplex.multicodec = '/mplex/6.7.0'\n\nmodule.exports = Mplex\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}