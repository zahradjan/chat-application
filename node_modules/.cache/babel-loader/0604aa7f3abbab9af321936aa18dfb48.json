{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst {\n  Record\n} = require('libp2p-record');\n\nconst Proto = require('./dht');\n\nconst MESSAGE_TYPE = Proto.Message.MessageType;\nconst CONNECTION_TYPE = Proto.Message.ConnectionType;\n/**\n * @typedef {0|1|2|3|4} ConnectionType\n *\n * @typedef {object} PBPeer\n * @property {Uint8Array} id\n * @property {Uint8Array[]} addrs\n * @property {ConnectionType} connection\n *\n * @typedef {import('../index').PeerData} PeerData\n */\n\n/**\n * Represents a single DHT control message.\n */\n\nclass Message {\n  /**\n   * @param {import('./dht').Message.MessageType} type\n   * @param {Uint8Array} key\n   * @param {number} level\n   */\n  constructor(type, key, level) {\n    if (key && !(key instanceof Uint8Array)) {\n      throw new Error('Key must be a Uint8Array');\n    }\n\n    this.type = type;\n    this.key = key;\n    this._clusterLevelRaw = level;\n    /** @type {PeerData[]} */\n\n    this.closerPeers = [];\n    /** @type {PeerData[]} */\n\n    this.providerPeers = [];\n    /** @type {import('libp2p-record').Record | undefined} */\n\n    this.record = undefined;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  get clusterLevel() {\n    const level = this._clusterLevelRaw - 1;\n\n    if (level < 0) {\n      return 0;\n    }\n\n    return level;\n  }\n\n  set clusterLevel(level) {\n    this._clusterLevelRaw = level;\n  }\n  /**\n   * Encode into protobuf\n   */\n\n\n  serialize() {\n    const obj = {\n      key: this.key,\n      type: this.type,\n      clusterLevelRaw: this._clusterLevelRaw,\n      closerPeers: this.closerPeers.map(toPbPeer),\n      providerPeers: this.providerPeers.map(toPbPeer),\n\n      /** @type {Uint8Array | undefined} */\n      record: undefined\n    };\n\n    if (this.record) {\n      if (this.record instanceof Uint8Array) {\n        obj.record = this.record;\n      } else {\n        obj.record = this.record.serialize();\n      }\n    }\n\n    return Proto.Message.encode(obj).finish();\n  }\n  /**\n   * Decode from protobuf\n   *\n   * @param {Uint8Array} raw\n   */\n\n\n  static deserialize(raw) {\n    const dec = Proto.Message.decode(raw);\n    const msg = new Message(dec.type || 0, dec.key || Uint8Array.from([]), dec.clusterLevelRaw || 0);\n    msg.closerPeers = dec.closerPeers.map(fromPbPeer);\n    msg.providerPeers = dec.providerPeers.map(fromPbPeer);\n\n    if (dec.record && dec.record.length) {\n      msg.record = Record.deserialize(dec.record);\n    }\n\n    return msg;\n  }\n\n}\n\nMessage.TYPES = MESSAGE_TYPE;\nMessage.CONNECTION_TYPES = CONNECTION_TYPE;\n/**\n * @param {PeerData} peer\n */\n\nfunction toPbPeer(peer) {\n  /** @type {PBPeer} */\n  const output = {\n    id: peer.id.id,\n    addrs: (peer.multiaddrs || []).map(m => m.bytes),\n    connection: CONNECTION_TYPE.CONNECTED\n  };\n  return output;\n}\n/**\n * @param {import('./dht').Message.IPeer} peer\n */\n\n\nfunction fromPbPeer(peer) {\n  return {\n    // @ts-ignore id is optional on protobuf, but it will exist?\n    id: new PeerId(peer.id),\n    multiaddrs: (peer.addrs || []).map(a => new Multiaddr(a))\n  };\n}\n\nmodule.exports = Message;","map":{"version":3,"names":["PeerId","require","Multiaddr","Record","Proto","MESSAGE_TYPE","Message","MessageType","CONNECTION_TYPE","ConnectionType","constructor","type","key","level","Uint8Array","Error","_clusterLevelRaw","closerPeers","providerPeers","record","undefined","clusterLevel","serialize","obj","clusterLevelRaw","map","toPbPeer","encode","finish","deserialize","raw","dec","decode","msg","from","fromPbPeer","length","TYPES","CONNECTION_TYPES","peer","output","id","addrs","multiaddrs","m","bytes","connection","CONNECTED","a","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-kad-dht/src/message/index.js"],"sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { Multiaddr } = require('multiaddr')\nconst { Record } = require('libp2p-record')\nconst Proto = require('./dht')\n\nconst MESSAGE_TYPE = Proto.Message.MessageType\nconst CONNECTION_TYPE = Proto.Message.ConnectionType\n\n/**\n * @typedef {0|1|2|3|4} ConnectionType\n *\n * @typedef {object} PBPeer\n * @property {Uint8Array} id\n * @property {Uint8Array[]} addrs\n * @property {ConnectionType} connection\n *\n * @typedef {import('../index').PeerData} PeerData\n */\n\n/**\n * Represents a single DHT control message.\n */\nclass Message {\n  /**\n   * @param {import('./dht').Message.MessageType} type\n   * @param {Uint8Array} key\n   * @param {number} level\n   */\n  constructor (type, key, level) {\n    if (key && !(key instanceof Uint8Array)) {\n      throw new Error('Key must be a Uint8Array')\n    }\n\n    this.type = type\n    this.key = key\n    this._clusterLevelRaw = level\n\n    /** @type {PeerData[]} */\n    this.closerPeers = []\n    /** @type {PeerData[]} */\n    this.providerPeers = []\n    /** @type {import('libp2p-record').Record | undefined} */\n    this.record = undefined\n  }\n\n  /**\n   * @type {number}\n   */\n  get clusterLevel () {\n    const level = this._clusterLevelRaw - 1\n    if (level < 0) {\n      return 0\n    }\n\n    return level\n  }\n\n  set clusterLevel (level) {\n    this._clusterLevelRaw = level\n  }\n\n  /**\n   * Encode into protobuf\n   */\n  serialize () {\n    const obj = {\n      key: this.key,\n      type: this.type,\n      clusterLevelRaw: this._clusterLevelRaw,\n      closerPeers: this.closerPeers.map(toPbPeer),\n      providerPeers: this.providerPeers.map(toPbPeer),\n\n      /** @type {Uint8Array | undefined} */\n      record: undefined\n    }\n\n    if (this.record) {\n      if (this.record instanceof Uint8Array) {\n        obj.record = this.record\n      } else {\n        obj.record = this.record.serialize()\n      }\n    }\n\n    return Proto.Message.encode(obj).finish()\n  }\n\n  /**\n   * Decode from protobuf\n   *\n   * @param {Uint8Array} raw\n   */\n  static deserialize (raw) {\n    const dec = Proto.Message.decode(raw)\n\n    const msg = new Message(dec.type || 0, dec.key || Uint8Array.from([]), dec.clusterLevelRaw || 0)\n\n    msg.closerPeers = dec.closerPeers.map(fromPbPeer)\n    msg.providerPeers = dec.providerPeers.map(fromPbPeer)\n\n    if (dec.record && dec.record.length) {\n      msg.record = Record.deserialize(dec.record)\n    }\n\n    return msg\n  }\n}\n\nMessage.TYPES = MESSAGE_TYPE\nMessage.CONNECTION_TYPES = CONNECTION_TYPE\n\n/**\n * @param {PeerData} peer\n */\nfunction toPbPeer (peer) {\n  /** @type {PBPeer} */\n  const output = {\n    id: peer.id.id,\n    addrs: (peer.multiaddrs || []).map((m) => m.bytes),\n    connection: CONNECTION_TYPE.CONNECTED\n  }\n\n  return output\n}\n\n/**\n * @param {import('./dht').Message.IPeer} peer\n */\nfunction fromPbPeer (peer) {\n  return {\n    // @ts-ignore id is optional on protobuf, but it will exist?\n    id: new PeerId(peer.id),\n    multiaddrs: (peer.addrs || []).map((a) => new Multiaddr(a))\n  }\n}\n\nmodule.exports = Message\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}