{"ast":null,"code":"/* eslint consistent-this: 0, no-shadow:0, no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */\n// Support for asynchronous functions\n\"use strict\";\n\nvar aFrom = require(\"es5-ext/array/from\"),\n    objectMap = require(\"es5-ext/object/map\"),\n    mixin = require(\"es5-ext/object/mixin\"),\n    defineLength = require(\"es5-ext/function/_define-length\"),\n    nextTick = require(\"next-tick\");\n\nvar slice = Array.prototype.slice,\n    apply = Function.prototype.apply,\n    create = Object.create;\n\nrequire(\"../lib/registered-extensions\").async = function (tbi, conf) {\n  var waiting = create(null),\n      cache = create(null),\n      base = conf.memoized,\n      original = conf.original,\n      currentCallback,\n      currentContext,\n      currentArgs; // Initial\n\n  conf.memoized = defineLength(function (arg) {\n    var args = arguments,\n        last = args[args.length - 1];\n\n    if (typeof last === \"function\") {\n      currentCallback = last;\n      args = slice.call(args, 0, -1);\n    }\n\n    return base.apply(currentContext = this, currentArgs = args);\n  }, base);\n\n  try {\n    mixin(conf.memoized, base);\n  } catch (ignore) {} // From cache (sync)\n\n\n  conf.on(\"get\", function (id) {\n    var cb, context, args;\n    if (!currentCallback) return; // Unresolved\n\n    if (waiting[id]) {\n      if (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback];else waiting[id].push(currentCallback);\n      currentCallback = null;\n      return;\n    } // Resolved, assure next tick invocation\n\n\n    cb = currentCallback;\n    context = currentContext;\n    args = currentArgs;\n    currentCallback = currentContext = currentArgs = null;\n    nextTick(function () {\n      var data;\n\n      if (hasOwnProperty.call(cache, id)) {\n        data = cache[id];\n        conf.emit(\"getasync\", id, args, context);\n        apply.call(cb, data.context, data.args);\n      } else {\n        // Purged in a meantime, we shouldn't rely on cached value, recall\n        currentCallback = cb;\n        currentContext = context;\n        currentArgs = args;\n        base.apply(context, args);\n      }\n    });\n  }); // Not from cache\n\n  conf.original = function () {\n    var args, cb, origCb, result;\n    if (!currentCallback) return apply.call(original, this, arguments);\n    args = aFrom(arguments);\n\n    cb = function self(err) {\n      var cb,\n          args,\n          id = self.id;\n\n      if (id == null) {\n        // Shouldn't happen, means async callback was called sync way\n        nextTick(apply.bind(self, this, arguments));\n        return undefined;\n      }\n\n      delete self.id;\n      cb = waiting[id];\n      delete waiting[id];\n\n      if (!cb) {\n        // Already processed,\n        // outcome of race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n        return undefined;\n      }\n\n      args = aFrom(arguments);\n\n      if (conf.has(id)) {\n        if (err) {\n          conf.delete(id);\n        } else {\n          cache[id] = {\n            context: this,\n            args: args\n          };\n          conf.emit(\"setasync\", id, typeof cb === \"function\" ? 1 : cb.length);\n        }\n      }\n\n      if (typeof cb === \"function\") {\n        result = apply.call(cb, this, args);\n      } else {\n        cb.forEach(function (cb) {\n          result = apply.call(cb, this, args);\n        }, this);\n      }\n\n      return result;\n    };\n\n    origCb = currentCallback;\n    currentCallback = currentContext = currentArgs = null;\n    args.push(cb);\n    result = apply.call(original, this, args);\n    cb.cb = origCb;\n    currentCallback = cb;\n    return result;\n  }; // After not from cache call\n\n\n  conf.on(\"set\", function (id) {\n    if (!currentCallback) {\n      conf.delete(id);\n      return;\n    }\n\n    if (waiting[id]) {\n      // Race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n      if (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback.cb];else waiting[id].push(currentCallback.cb);\n    } else {\n      waiting[id] = currentCallback.cb;\n    }\n\n    delete currentCallback.cb;\n    currentCallback.id = id;\n    currentCallback = null;\n  }); // On delete\n\n  conf.on(\"delete\", function (id) {\n    var result; // If false, we don't have value yet, so we assume that intention is not\n    // to memoize this call. After value is obtained we don't cache it but\n    // gracefully pass to callback\n\n    if (hasOwnProperty.call(waiting, id)) return;\n    if (!cache[id]) return;\n    result = cache[id];\n    delete cache[id];\n    conf.emit(\"deleteasync\", id, slice.call(result.args, 1));\n  }); // On clear\n\n  conf.on(\"clear\", function () {\n    var oldCache = cache;\n    cache = create(null);\n    conf.emit(\"clearasync\", objectMap(oldCache, function (data) {\n      return slice.call(data.args, 1);\n    }));\n  });\n};","map":{"version":3,"names":["aFrom","require","objectMap","mixin","defineLength","nextTick","slice","Array","prototype","apply","Function","create","Object","async","tbi","conf","waiting","cache","base","memoized","original","currentCallback","currentContext","currentArgs","arg","args","arguments","last","length","call","ignore","on","id","cb","context","push","data","hasOwnProperty","emit","origCb","result","self","err","bind","undefined","has","delete","forEach","oldCache"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/memoizee/ext/async.js"],"sourcesContent":["/* eslint consistent-this: 0, no-shadow:0, no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */\n\n// Support for asynchronous functions\n\n\"use strict\";\n\nvar aFrom        = require(\"es5-ext/array/from\")\n  , objectMap    = require(\"es5-ext/object/map\")\n  , mixin        = require(\"es5-ext/object/mixin\")\n  , defineLength = require(\"es5-ext/function/_define-length\")\n  , nextTick     = require(\"next-tick\");\n\nvar slice = Array.prototype.slice, apply = Function.prototype.apply, create = Object.create;\n\nrequire(\"../lib/registered-extensions\").async = function (tbi, conf) {\n\tvar waiting = create(null)\n\t  , cache = create(null)\n\t  , base = conf.memoized\n\t  , original = conf.original\n\t  , currentCallback\n\t  , currentContext\n\t  , currentArgs;\n\n\t// Initial\n\tconf.memoized = defineLength(function (arg) {\n\t\tvar args = arguments, last = args[args.length - 1];\n\t\tif (typeof last === \"function\") {\n\t\t\tcurrentCallback = last;\n\t\t\targs = slice.call(args, 0, -1);\n\t\t}\n\t\treturn base.apply(currentContext = this, currentArgs = args);\n\t}, base);\n\ttry { mixin(conf.memoized, base); }\n\tcatch (ignore) {}\n\n\t// From cache (sync)\n\tconf.on(\"get\", function (id) {\n\t\tvar cb, context, args;\n\t\tif (!currentCallback) return;\n\n\t\t// Unresolved\n\t\tif (waiting[id]) {\n\t\t\tif (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback];\n\t\t\telse waiting[id].push(currentCallback);\n\t\t\tcurrentCallback = null;\n\t\t\treturn;\n\t\t}\n\n\t\t// Resolved, assure next tick invocation\n\t\tcb = currentCallback;\n\t\tcontext = currentContext;\n\t\targs = currentArgs;\n\t\tcurrentCallback = currentContext = currentArgs = null;\n\t\tnextTick(function () {\n\t\t\tvar data;\n\t\t\tif (hasOwnProperty.call(cache, id)) {\n\t\t\t\tdata = cache[id];\n\t\t\t\tconf.emit(\"getasync\", id, args, context);\n\t\t\t\tapply.call(cb, data.context, data.args);\n\t\t\t} else {\n\t\t\t\t// Purged in a meantime, we shouldn't rely on cached value, recall\n\t\t\t\tcurrentCallback = cb;\n\t\t\t\tcurrentContext = context;\n\t\t\t\tcurrentArgs = args;\n\t\t\t\tbase.apply(context, args);\n\t\t\t}\n\t\t});\n\t});\n\n\t// Not from cache\n\tconf.original = function () {\n\t\tvar args, cb, origCb, result;\n\t\tif (!currentCallback) return apply.call(original, this, arguments);\n\t\targs = aFrom(arguments);\n\t\tcb = function self(err) {\n\t\t\tvar cb, args, id = self.id;\n\t\t\tif (id == null) {\n\t\t\t\t// Shouldn't happen, means async callback was called sync way\n\t\t\t\tnextTick(apply.bind(self, this, arguments));\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tdelete self.id;\n\t\t\tcb = waiting[id];\n\t\t\tdelete waiting[id];\n\t\t\tif (!cb) {\n\t\t\t\t// Already processed,\n\t\t\t\t// outcome of race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\targs = aFrom(arguments);\n\t\t\tif (conf.has(id)) {\n\t\t\t\tif (err) {\n\t\t\t\t\tconf.delete(id);\n\t\t\t\t} else {\n\t\t\t\t\tcache[id] = { context: this, args: args };\n\t\t\t\t\tconf.emit(\"setasync\", id, typeof cb === \"function\" ? 1 : cb.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof cb === \"function\") {\n\t\t\t\tresult = apply.call(cb, this, args);\n\t\t\t} else {\n\t\t\t\tcb.forEach(function (cb) { result = apply.call(cb, this, args); }, this);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\torigCb = currentCallback;\n\t\tcurrentCallback = currentContext = currentArgs = null;\n\t\targs.push(cb);\n\t\tresult = apply.call(original, this, args);\n\t\tcb.cb = origCb;\n\t\tcurrentCallback = cb;\n\t\treturn result;\n\t};\n\n\t// After not from cache call\n\tconf.on(\"set\", function (id) {\n\t\tif (!currentCallback) {\n\t\t\tconf.delete(id);\n\t\t\treturn;\n\t\t}\n\t\tif (waiting[id]) {\n\t\t\t// Race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n\t\t\tif (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback.cb];\n\t\t\telse waiting[id].push(currentCallback.cb);\n\t\t} else {\n\t\t\twaiting[id] = currentCallback.cb;\n\t\t}\n\t\tdelete currentCallback.cb;\n\t\tcurrentCallback.id = id;\n\t\tcurrentCallback = null;\n\t});\n\n\t// On delete\n\tconf.on(\"delete\", function (id) {\n\t\tvar result;\n\t\t// If false, we don't have value yet, so we assume that intention is not\n\t\t// to memoize this call. After value is obtained we don't cache it but\n\t\t// gracefully pass to callback\n\t\tif (hasOwnProperty.call(waiting, id)) return;\n\t\tif (!cache[id]) return;\n\t\tresult = cache[id];\n\t\tdelete cache[id];\n\t\tconf.emit(\"deleteasync\", id, slice.call(result.args, 1));\n\t});\n\n\t// On clear\n\tconf.on(\"clear\", function () {\n\t\tvar oldCache = cache;\n\t\tcache = create(null);\n\t\tconf.emit(\n\t\t\t\"clearasync\", objectMap(oldCache, function (data) { return slice.call(data.args, 1); })\n\t\t);\n\t});\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}