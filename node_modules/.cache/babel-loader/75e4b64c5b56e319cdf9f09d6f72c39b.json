{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _require = require('interface-datastore'),\n    Adapter = _require.Adapter,\n    Key = _require.Key,\n    Errors = _require.Errors,\n    _require$utils = _require.utils,\n    sortAll = _require$utils.sortAll,\n    replaceStartWith = _require$utils.replaceStartWith;\n\nvar filter = require('it-filter');\n\nvar take = require('it-take');\n\nvar merge = require('it-merge');\n\nvar Keytransform = require('./keytransform');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('./types').KeyTransform} KeyTransform\n */\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixes\n *\n * @implements {Datastore}\n */\n\n\nvar MountDatastore = /*#__PURE__*/function (_Adapter) {\n  _inherits(MountDatastore, _Adapter);\n\n  var _super = _createSuper(MountDatastore);\n\n  /**\n   * @param {Array<{prefix: Key, datastore: Datastore}>} mounts\n   */\n  function MountDatastore(mounts) {\n    var _this;\n\n    _classCallCheck(this, MountDatastore);\n\n    _this = _super.call(this);\n    _this.mounts = mounts.slice();\n    return _this;\n  }\n\n  _createClass(MountDatastore, [{\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return Promise.all(this.mounts.map(function (m) {\n                  return m.datastore.open();\n                }));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function open() {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n    /**\n     * Lookup the matching datastore for the given key\n     *\n     * @private\n     * @param {Key} key\n     * @returns {{datastore: Datastore, mountpoint: Key, rest: Key} | undefined}\n     */\n\n  }, {\n    key: \"_lookup\",\n    value: function _lookup(key) {\n      var _iterator = _createForOfIteratorHelper(this.mounts),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var mount = _step.value;\n\n          if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n            var s = replaceStartWith(key.toString(), mount.prefix.toString());\n            return {\n              datastore: mount.datastore,\n              mountpoint: mount.prefix,\n              rest: new Key(s)\n            };\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * @param {Key} key\n     * @param {Uint8Array} value\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(key, value, options) {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'));\n      }\n\n      return match.datastore.put(match.rest, value, options);\n    }\n    /**\n     * @param {Key} key\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, options) {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        throw Errors.notFoundError(new Error('No datastore mounted for this key'));\n      }\n\n      return match.datastore.get(match.rest, options);\n    }\n    /**\n     * @param {Key} key\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(key, options) {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        return Promise.resolve(false);\n      }\n\n      return match.datastore.has(match.rest, options);\n    }\n    /**\n     * @param {Key} key\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(key, options) {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));\n      }\n\n      return match.datastore.delete(match.rest, options);\n    }\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return Promise.all(this.mounts.map(function (m) {\n                  return m.datastore.close();\n                }));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * @returns {Batch}\n     */\n\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      var _this2 = this;\n\n      /** @type {Record<string, Batch>} */\n      var batchMounts = {};\n      /**\n       * @param {Key} key\n       */\n\n      var lookup = function lookup(key) {\n        var match = _this2._lookup(key);\n\n        if (match == null) {\n          throw new Error('No datastore mounted for this key');\n        }\n\n        var m = match.mountpoint.toString();\n\n        if (batchMounts[m] == null) {\n          batchMounts[m] = match.datastore.batch();\n        }\n\n        return {\n          batch: batchMounts[m],\n          rest: match.rest\n        };\n      };\n\n      return {\n        put: function put(key, value) {\n          var match = lookup(key);\n          match.batch.put(match.rest, value);\n        },\n        delete: function _delete(key) {\n          var match = lookup(key);\n          match.batch.delete(match.rest);\n        },\n        commit: function () {\n          var _commit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options) {\n            return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n              while (1) {\n                switch (_context3.prev = _context3.next) {\n                  case 0:\n                    _context3.next = 2;\n                    return Promise.all(Object.keys(batchMounts).map(function (p) {\n                      return batchMounts[p].commit(options);\n                    }));\n\n                  case 2:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }\n            }, _callee3);\n          }));\n\n          function commit(_x) {\n            return _commit.apply(this, arguments);\n          }\n\n          return commit;\n        }()\n      };\n    }\n    /**\n     * @param {Query} q\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"query\",\n    value: function query(q, options) {\n      var qs = this.mounts.map(function (m) {\n        var ks = new Keytransform(m.datastore, {\n          convert: function convert(key) {\n            throw new Error('should never be called');\n          },\n          invert: function invert(key) {\n            return m.prefix.child(key);\n          }\n        });\n        var prefix;\n\n        if (q.prefix != null) {\n          prefix = replaceStartWith(q.prefix, m.prefix.toString());\n        }\n\n        return ks.query({\n          prefix: prefix,\n          filters: q.filters\n        }, options);\n      });\n      var it = merge.apply(void 0, _toConsumableArray(qs));\n      if (q.filters) q.filters.forEach(function (f) {\n        it = filter(it, f);\n      });\n      if (q.orders) q.orders.forEach(function (o) {\n        it = sortAll(it, o);\n      });\n\n      if (q.offset != null) {\n        var i = 0;\n        it = filter(it, function () {\n          return i++ >=\n          /** @type {number} */\n          q.offset;\n        });\n      }\n\n      if (q.limit != null) it = take(it, q.limit);\n      return it;\n    }\n    /**\n     * @param {KeyQuery} q\n     * @param {Options} [options]\n     */\n\n  }, {\n    key: \"queryKeys\",\n    value: function queryKeys(q, options) {\n      var qs = this.mounts.map(function (m) {\n        var ks = new Keytransform(m.datastore, {\n          convert: function convert(key) {\n            throw new Error('should never be called');\n          },\n          invert: function invert(key) {\n            return m.prefix.child(key);\n          }\n        });\n        var prefix;\n\n        if (q.prefix != null) {\n          prefix = replaceStartWith(q.prefix, m.prefix.toString());\n        }\n\n        return ks.queryKeys({\n          prefix: prefix,\n          filters: q.filters\n        }, options);\n      });\n      var it = merge.apply(void 0, _toConsumableArray(qs));\n      if (q.filters) q.filters.forEach(function (f) {\n        it = filter(it, f);\n      });\n      if (q.orders) q.orders.forEach(function (o) {\n        it = sortAll(it, o);\n      });\n\n      if (q.offset != null) {\n        var i = 0;\n        it = filter(it, function () {\n          return i++ >=\n          /** @type {number} */\n          q.offset;\n        });\n      }\n\n      if (q.limit != null) it = take(it, q.limit);\n      return it;\n    }\n  }]);\n\n  return MountDatastore;\n}(Adapter);\n\nmodule.exports = MountDatastore;","map":{"version":3,"names":["require","Adapter","Key","Errors","utils","sortAll","replaceStartWith","filter","take","merge","Keytransform","MountDatastore","mounts","slice","Promise","all","map","m","datastore","open","key","mount","prefix","toString","isAncestorOf","s","mountpoint","rest","value","options","match","_lookup","dbWriteFailedError","Error","put","notFoundError","get","resolve","has","dbDeleteFailedError","delete","close","batchMounts","lookup","batch","commit","Object","keys","p","q","qs","ks","convert","invert","child","query","filters","it","forEach","f","orders","o","offset","i","limit","queryKeys","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/datastore-core/src/mount.js"],"sourcesContent":["/* @flow */\n'use strict'\n\nconst {\n  Adapter, Key, Errors, utils: {\n    sortAll,\n    replaceStartWith\n  }\n} = require('interface-datastore')\nconst filter = require('it-filter')\nconst take = require('it-take')\nconst merge = require('it-merge')\n\nconst Keytransform = require('./keytransform')\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('./types').KeyTransform} KeyTransform\n */\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixes\n *\n * @implements {Datastore}\n */\nclass MountDatastore extends Adapter {\n  /**\n   * @param {Array<{prefix: Key, datastore: Datastore}>} mounts\n   */\n  constructor (mounts) {\n    super()\n\n    this.mounts = mounts.slice()\n  }\n\n  async open () {\n    await Promise.all(this.mounts.map((m) => m.datastore.open()))\n  }\n\n  /**\n   * Lookup the matching datastore for the given key\n   *\n   * @private\n   * @param {Key} key\n   * @returns {{datastore: Datastore, mountpoint: Key, rest: Key} | undefined}\n   */\n  _lookup (key) {\n    for (const mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        const s = replaceStartWith(key.toString(), mount.prefix.toString())\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix,\n          rest: new Key(s)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   * @param {Options} [options]\n   */\n  put (key, value, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'))\n    }\n\n    return match.datastore.put(match.rest, value, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  get (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.notFoundError(new Error('No datastore mounted for this key'))\n    }\n    return match.datastore.get(match.rest, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  has (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      return Promise.resolve(false)\n    }\n    return match.datastore.has(match.rest, options)\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n  delete (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'))\n    }\n\n    return match.datastore.delete(match.rest, options)\n  }\n\n  async close () {\n    await Promise.all(this.mounts.map((m) => {\n      return m.datastore.close()\n    }))\n  }\n\n  /**\n   * @returns {Batch}\n   */\n  batch () {\n    /** @type {Record<string, Batch>} */\n    const batchMounts = {}\n    /**\n     * @param {Key} key\n     */\n    const lookup = (key) => {\n      const match = this._lookup(key)\n      if (match == null) {\n        throw new Error('No datastore mounted for this key')\n      }\n\n      const m = match.mountpoint.toString()\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch()\n      }\n\n      return {\n        batch: batchMounts[m],\n        rest: match.rest\n      }\n    }\n\n    return {\n      put: (key, value) => {\n        const match = lookup(key)\n        match.batch.put(match.rest, value)\n      },\n      delete: (key) => {\n        const match = lookup(key)\n        match.batch.delete(match.rest)\n      },\n      commit: async (options) => {\n        await Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)))\n      }\n    }\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query (q, options) {\n    const qs = this.mounts.map(m => {\n      const ks = new Keytransform(m.datastore, {\n        convert: (key) => {\n          throw new Error('should never be called')\n        },\n        invert: (key) => {\n          return m.prefix.child(key)\n        }\n      })\n\n      let prefix\n      if (q.prefix != null) {\n        prefix = replaceStartWith(q.prefix, m.prefix.toString())\n      }\n\n      return ks.query({\n        prefix: prefix,\n        filters: q.filters\n      }, options)\n    })\n\n    let it = merge(...qs)\n    if (q.filters) q.filters.forEach(f => { it = filter(it, f) })\n    if (q.orders) q.orders.forEach(o => { it = sortAll(it, o) })\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= /** @type {number} */ (q.offset))\n    }\n    if (q.limit != null) it = take(it, q.limit)\n\n    return it\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys (q, options) {\n    const qs = this.mounts.map(m => {\n      const ks = new Keytransform(m.datastore, {\n        convert: (key) => {\n          throw new Error('should never be called')\n        },\n        invert: (key) => {\n          return m.prefix.child(key)\n        }\n      })\n\n      let prefix\n      if (q.prefix != null) {\n        prefix = replaceStartWith(q.prefix, m.prefix.toString())\n      }\n\n      return ks.queryKeys({\n        prefix: prefix,\n        filters: q.filters\n      }, options)\n    })\n\n    let it = merge(...qs)\n    if (q.filters) q.filters.forEach(f => { it = filter(it, f) })\n    if (q.orders) q.orders.forEach(o => { it = sortAll(it, o) })\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= /** @type {number} */ (q.offset))\n    }\n    if (q.limit != null) it = take(it, q.limit)\n\n    return it\n  }\n}\n\nmodule.exports = MountDatastore\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}