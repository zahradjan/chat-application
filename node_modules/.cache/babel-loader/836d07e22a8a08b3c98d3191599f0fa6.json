{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/zajan/GitHub/chatApplication/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar connect = require('it-ws/client');\n\nvar withIs = require('class-is');\n\nvar toUri = require('multiaddr-to-uri');\n\nvar _require = require('abortable-iterator'),\n    AbortError = _require.AbortError;\n\nvar pDefer = require('p-defer');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:websockets');\nlog.error = debug('libp2p:websockets:error');\n\nvar env = require('ipfs-utils/src/env');\n\nvar _createListener = require('./listener');\n\nvar toConnection = require('./socket-to-conn');\n\nvar filters = require('./filters');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @class WebSockets\n */\n\n\nvar WebSockets = /*#__PURE__*/function () {\n  /**\n   * @class\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   * @param {(multiaddrs: Array<Multiaddr>) => Array<Multiaddr>} options.filter - override transport addresses filter\n   */\n  function WebSockets(_ref) {\n    var upgrader = _ref.upgrader,\n        filter = _ref.filter;\n\n    _classCallCheck(this, WebSockets);\n\n    if (!upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.');\n    }\n\n    this._upgrader = upgrader;\n    this._filter = filter;\n  }\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n\n\n  _createClass(WebSockets, [{\n    key: \"dial\",\n    value: function () {\n      var _dial = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ma) {\n        var options,\n            socket,\n            maConn,\n            conn,\n            _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                log('dialing %s', ma);\n                _context.next = 4;\n                return this._connect(ma, options);\n\n              case 4:\n                socket = _context.sent;\n                maConn = toConnection(socket, {\n                  remoteAddr: ma,\n                  signal: options.signal\n                });\n                log('new outbound connection %s', maConn.remoteAddr);\n                _context.next = 9;\n                return this._upgrader.upgradeOutbound(maConn);\n\n              case 9:\n                conn = _context.sent;\n                log('outbound connection %s upgraded', maConn.remoteAddr);\n                return _context.abrupt(\"return\", conn);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function dial(_x) {\n        return _dial.apply(this, arguments);\n      }\n\n      return dial;\n    }()\n    /**\n     * @private\n     * @param {Multiaddr} ma\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal] - Used to abort dial requests\n     * @returns {Promise<WebSocket>} Resolves a extended duplex iterable on top of a WebSocket\n     */\n\n  }, {\n    key: \"_connect\",\n    value: function () {\n      var _connect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(ma) {\n        var options,\n            cOpts,\n            errorPromise,\n            errfn,\n            rawSocket,\n            onAbort,\n            abort,\n            _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n\n                if (!(options.signal && options.signal.aborted)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new AbortError();\n\n              case 3:\n                cOpts = ma.toOptions();\n                log('dialing %s:%s', cOpts.host, cOpts.port);\n                errorPromise = pDefer();\n\n                errfn = function errfn(err) {\n                  var msg = \"connection error: \".concat(err.message);\n                  log.error(msg);\n                  errorPromise.reject(err);\n                };\n\n                rawSocket = connect(toUri(ma), Object.assign({\n                  binary: true\n                }, options));\n\n                if (rawSocket.socket.on) {\n                  rawSocket.socket.on('error', errfn);\n                } else {\n                  rawSocket.socket.onerror = errfn;\n                }\n\n                if (options.signal) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                _context2.next = 12;\n                return Promise.race([rawSocket.connected(), errorPromise.promise]);\n\n              case 12:\n                log('connected %s', ma);\n                return _context2.abrupt(\"return\", rawSocket);\n\n              case 14:\n                abort = new Promise(function (resolve, reject) {\n                  onAbort = function onAbort() {\n                    reject(new AbortError()); // FIXME: https://github.com/libp2p/js-libp2p-websockets/issues/121\n\n                    setTimeout(function () {\n                      rawSocket.close();\n                    });\n                  }; // Already aborted?\n\n\n                  if (options.signal.aborted) return onAbort();\n                  options.signal.addEventListener('abort', onAbort);\n                });\n                _context2.prev = 15;\n                _context2.next = 18;\n                return Promise.race([abort, errorPromise.promise, rawSocket.connected()]);\n\n              case 18:\n                _context2.prev = 18;\n                options.signal.removeEventListener('abort', onAbort);\n                return _context2.finish(18);\n\n              case 21:\n                log('connected %s', ma);\n                return _context2.abrupt(\"return\", rawSocket);\n\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[15,, 18, 21]]);\n      }));\n\n      function _connect(_x2) {\n        return _connect2.apply(this, arguments);\n      }\n\n      return _connect;\n    }()\n    /**\n     * Creates a Websockets listener. The provided `handler` function will be called\n     * anytime a new incoming Connection has been successfully upgraded via\n     * `upgrader.upgradeInbound`.\n     *\n     * @param {object} [options]\n     * @param {http.Server} [options.server] - A pre-created Node.js HTTP/S server.\n     * @param {function (Connection)} handler\n     * @returns {Listener} A Websockets listener\n     */\n\n  }, {\n    key: \"createListener\",\n    value: function createListener() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var handler = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (typeof options === 'function') {\n        handler = options;\n        options = {};\n      }\n\n      return _createListener({\n        handler: handler,\n        upgrader: this._upgrader\n      }, options);\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n     * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n     * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n     *\n     * @param {Multiaddr[]} multiaddrs\n     * @returns {Multiaddr[]} Valid Websockets multiaddrs\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(multiaddrs) {\n      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n\n      if (this._filter) {\n        return this._filter(multiaddrs);\n      } // Browser\n\n\n      if (env.isBrowser || env.isWebWorker) {\n        return filters.dnsWss(multiaddrs);\n      }\n\n      return filters.all(multiaddrs);\n    }\n  }]);\n\n  return WebSockets;\n}();\n\nmodule.exports = withIs(WebSockets, {\n  className: 'WebSockets',\n  symbolName: '@libp2p/js-libp2p-websockets/websockets'\n});","map":{"version":3,"names":["connect","require","withIs","toUri","AbortError","pDefer","debug","log","error","env","createListener","toConnection","filters","WebSockets","upgrader","filter","Error","_upgrader","_filter","ma","options","_connect","socket","maConn","remoteAddr","signal","upgradeOutbound","conn","aborted","cOpts","toOptions","host","port","errorPromise","errfn","err","msg","message","reject","rawSocket","Object","assign","binary","on","onerror","Promise","race","connected","promise","abort","resolve","onAbort","setTimeout","close","addEventListener","removeEventListener","handler","multiaddrs","Array","isArray","isBrowser","isWebWorker","dnsWss","all","module","exports","className","symbolName"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p-websockets/src/index.js"],"sourcesContent":["'use strict'\n\nconst connect = require('it-ws/client')\nconst withIs = require('class-is')\nconst toUri = require('multiaddr-to-uri')\nconst { AbortError } = require('abortable-iterator')\nconst pDefer = require('p-defer')\n\nconst debug = require('debug')\nconst log = debug('libp2p:websockets')\nlog.error = debug('libp2p:websockets:error')\nconst env = require('ipfs-utils/src/env')\n\nconst createListener = require('./listener')\nconst toConnection = require('./socket-to-conn')\nconst filters = require('./filters')\n\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @class WebSockets\n */\nclass WebSockets {\n  /**\n   * @class\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   * @param {(multiaddrs: Array<Multiaddr>) => Array<Multiaddr>} options.filter - override transport addresses filter\n   */\n  constructor ({ upgrader, filter }) {\n    if (!upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.')\n    }\n    this._upgrader = upgrader\n    this._filter = filter\n  }\n\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n  async dial (ma, options = {}) {\n    log('dialing %s', ma)\n\n    const socket = await this._connect(ma, options)\n    const maConn = toConnection(socket, { remoteAddr: ma, signal: options.signal })\n    log('new outbound connection %s', maConn.remoteAddr)\n\n    const conn = await this._upgrader.upgradeOutbound(maConn)\n    log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  /**\n   * @private\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - Used to abort dial requests\n   * @returns {Promise<WebSocket>} Resolves a extended duplex iterable on top of a WebSocket\n   */\n  async _connect (ma, options = {}) {\n    if (options.signal && options.signal.aborted) {\n      throw new AbortError()\n    }\n    const cOpts = ma.toOptions()\n    log('dialing %s:%s', cOpts.host, cOpts.port)\n\n    const errorPromise = pDefer()\n    const errfn = (err) => {\n      const msg = `connection error: ${err.message}`\n      log.error(msg)\n\n      errorPromise.reject(err)\n    }\n\n    const rawSocket = connect(toUri(ma), Object.assign({ binary: true }, options))\n\n    if (rawSocket.socket.on) {\n      rawSocket.socket.on('error', errfn)\n    } else {\n      rawSocket.socket.onerror = errfn\n    }\n\n    if (!options.signal) {\n      await Promise.race([rawSocket.connected(), errorPromise.promise])\n\n      log('connected %s', ma)\n      return rawSocket\n    }\n\n    // Allow abort via signal during connect\n    let onAbort\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError())\n        // FIXME: https://github.com/libp2p/js-libp2p-websockets/issues/121\n        setTimeout(() => {\n          rawSocket.close()\n        })\n      }\n\n      // Already aborted?\n      if (options.signal.aborted) return onAbort()\n      options.signal.addEventListener('abort', onAbort)\n    })\n\n    try {\n      await Promise.race([abort, errorPromise.promise, rawSocket.connected()])\n    } finally {\n      options.signal.removeEventListener('abort', onAbort)\n    }\n\n    log('connected %s', ma)\n    return rawSocket\n  }\n\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   *\n   * @param {object} [options]\n   * @param {http.Server} [options.server] - A pre-created Node.js HTTP/S server.\n   * @param {function (Connection)} handler\n   * @returns {Listener} A Websockets listener\n   */\n  createListener (options = {}, handler) {\n    if (typeof options === 'function') {\n      handler = options\n      options = {}\n    }\n\n    return createListener({ handler, upgrader: this._upgrader }, options)\n  }\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n   * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n   *\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]} Valid Websockets multiaddrs\n   */\n  filter (multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    if (this._filter) {\n      return this._filter(multiaddrs)\n    }\n\n    // Browser\n    if (env.isBrowser || env.isWebWorker) {\n      return filters.dnsWss(multiaddrs)\n    }\n\n    return filters.all(multiaddrs)\n  }\n}\n\nmodule.exports = withIs(WebSockets, {\n  className: 'WebSockets',\n  symbolName: '@libp2p/js-libp2p-websockets/websockets'\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}