{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst mergeOptions = require('merge-options');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  tap\n} = require('streaming-iterables');\n\nconst oldPeerLRU = require('./old-peers');\n\nconst {\n  METRICS: defaultOptions\n} = require('../constants');\n\nconst Stats = require('./stats');\n\nconst initialCounters = ['dataReceived', 'dataSent'];\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n};\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n */\n\n/**\n * @typedef MetricsProperties\n * @property {import('../connection-manager')} connectionManager\n *\n * @typedef MetricsOptions\n * @property {number} [computeThrottleMaxQueueSize = defaultOptions.computeThrottleMaxQueueSize]\n * @property {number} [computeThrottleTimeout = defaultOptions.computeThrottleTimeout]\n * @property {number[]} [movingAverageIntervals = defaultOptions.movingAverageIntervals]\n * @property {number} [maxOldPeersRetention = defaultOptions.maxOldPeersRetention]\n */\n\nclass Metrics {\n  /**\n   * @class\n   * @param {MetricsProperties & MetricsOptions} options\n   */\n  constructor(options) {\n    this._options = mergeOptions(defaultOptions, options);\n    this._globalStats = new Stats(initialCounters, this._options);\n    this._peerStats = new Map();\n    this._protocolStats = new Map();\n    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention);\n    this._running = false;\n    this._onMessage = this._onMessage.bind(this);\n    this._connectionManager = options.connectionManager;\n\n    this._connectionManager.on('peer:disconnect', connection => {\n      this.onPeerDisconnected(connection.remotePeer);\n    });\n  }\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n\n\n  start() {\n    this._running = true;\n  }\n  /**\n   * Stops all averages timers and prevents new data from being tracked.\n   * Once `stop` is called, `start` must be called to resume stats tracking.\n   */\n\n\n  stop() {\n    this._running = false;\n\n    this._globalStats.stop();\n\n    for (const stats of this._peerStats.values()) {\n      stats.stop();\n    }\n\n    for (const stats of this._protocolStats.values()) {\n      stats.stop();\n    }\n  }\n  /**\n   * Gets the global `Stats` object\n   *\n   * @returns {Stats}\n   */\n\n\n  get global() {\n    return this._globalStats;\n  }\n  /**\n   * Returns a list of `PeerId` strings currently being tracked\n   *\n   * @returns {string[]}\n   */\n\n\n  get peers() {\n    return Array.from(this._peerStats.keys());\n  }\n  /**\n   * Returns the `Stats` object for the given `PeerId` whether it\n   * is a live peer, or in the disconnected peer LRU cache.\n   *\n   * @param {PeerId} peerId\n   * @returns {Stats}\n   */\n\n\n  forPeer(peerId) {\n    const idString = peerId.toB58String();\n    return this._peerStats.get(idString) || this._oldPeers.get(idString);\n  }\n  /**\n   * Returns a list of all protocol strings currently being tracked.\n   *\n   * @returns {string[]}\n   */\n\n\n  get protocols() {\n    return Array.from(this._protocolStats.keys());\n  }\n  /**\n   * Returns the `Stats` object for the given `protocol`.\n   *\n   * @param {string} protocol\n   * @returns {Stats}\n   */\n\n\n  forProtocol(protocol) {\n    return this._protocolStats.get(protocol);\n  }\n  /**\n   * Should be called when all connections to a given peer\n   * have closed. The `Stats` collection for the peer will\n   * be stopped and moved to an LRU for temporary retention.\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  onPeerDisconnected(peerId) {\n    const idString = peerId.toB58String();\n\n    const peerStats = this._peerStats.get(idString);\n\n    if (peerStats) {\n      peerStats.stop();\n\n      this._peerStats.delete(idString);\n\n      this._oldPeers.set(idString, peerStats);\n    }\n  }\n  /**\n   * Takes the metadata for a message and tracks it in the\n   * appropriate categories. If the protocol is present, protocol\n   * stats will also be tracked.\n   *\n   * @private\n   * @param {object} params\n   * @param {PeerId} params.remotePeer - Remote peer\n   * @param {string} [params.protocol] - Protocol string the stream is running\n   * @param {string} params.direction - One of ['in','out']\n   * @param {number} params.dataLength - Size of the message\n   * @returns {void}\n   */\n\n\n  _onMessage(_ref) {\n    let {\n      remotePeer,\n      protocol,\n      direction,\n      dataLength\n    } = _ref;\n    if (!this._running) return;\n    const key = directionToEvent[direction];\n    let peerStats = this.forPeer(remotePeer);\n\n    if (!peerStats) {\n      peerStats = new Stats(initialCounters, this._options);\n\n      this._peerStats.set(remotePeer.toB58String(), peerStats);\n    } // Peer and global stats\n\n\n    peerStats.push(key, dataLength);\n\n    this._globalStats.push(key, dataLength); // Protocol specific stats\n\n\n    if (protocol) {\n      let protocolStats = this.forProtocol(protocol);\n\n      if (!protocolStats) {\n        protocolStats = new Stats(initialCounters, this._options);\n\n        this._protocolStats.set(protocol, protocolStats);\n      }\n\n      protocolStats.push(key, dataLength);\n    }\n  }\n  /**\n   * Replaces the `PeerId` string with the given `peerId`.\n   * If stats are already being tracked for the given `peerId`, the\n   * placeholder stats will be merged with the existing stats.\n   *\n   * @param {PeerId} placeholder - A peerId string\n   * @param {PeerId} peerId\n   * @returns {void}\n   */\n\n\n  updatePlaceholder(placeholder, peerId) {\n    if (!this._running) return;\n    const placeholderStats = this.forPeer(placeholder);\n    const peerIdString = peerId.toB58String();\n    const existingStats = this.forPeer(peerId);\n    let mergedStats = placeholderStats; // If we already have stats, merge the two\n\n    if (existingStats) {\n      // If existing, merge\n      mergedStats = Metrics.mergeStats(existingStats, mergedStats); // Attempt to delete from the old peers list just in case it was tracked there\n\n      this._oldPeers.delete(peerIdString);\n    }\n\n    this._peerStats.delete(placeholder.toB58String());\n\n    this._peerStats.set(peerIdString, mergedStats);\n\n    mergedStats.start();\n  }\n  /**\n   * Tracks data running through a given Duplex Iterable `stream`. If\n   * the `peerId` is not provided, a placeholder string will be created and\n   * returned. This allows lazy tracking of a peer when the peer is not yet known.\n   * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n   * with the placeholder string returned from here, and the known `PeerId`.\n   *\n   * @param {Object} options\n   * @param {MultiaddrConnection} options.stream - A duplex iterable stream\n   * @param {PeerId} [options.remotePeer] - The id of the remote peer that's connected\n   * @param {string} [options.protocol] - The protocol the stream is running\n   * @returns {MultiaddrConnection} The peerId string or placeholder string\n   */\n\n\n  trackStream(_ref2) {\n    let {\n      stream,\n      remotePeer,\n      protocol\n    } = _ref2;\n    const metrics = this;\n    const _source = stream.source;\n    stream.source = tap(chunk => metrics._onMessage({\n      remotePeer,\n      protocol,\n      direction: 'in',\n      dataLength: chunk.length\n    }))(_source);\n    const _sink = stream.sink;\n\n    stream.sink = source => {\n      return pipe(source, tap(chunk => metrics._onMessage({\n        remotePeer,\n        protocol,\n        direction: 'out',\n        dataLength: chunk.length\n      })), _sink);\n    };\n\n    return stream;\n  }\n  /**\n   * Merges `other` into `target`. `target` will be modified\n   * and returned.\n   *\n   * @param {Stats} target\n   * @param {Stats} other\n   * @returns {Stats}\n   */\n\n\n  static mergeStats(target, other) {\n    target.stop();\n    other.stop(); // Merge queues\n\n    target._queue = [...target._queue, ...other._queue]; // TODO: how to merge moving averages?\n\n    return target;\n  }\n\n}\n\nmodule.exports = Metrics;","map":{"version":3,"names":["mergeOptions","require","pipe","tap","oldPeerLRU","METRICS","defaultOptions","Stats","initialCounters","directionToEvent","in","out","Metrics","constructor","options","_options","_globalStats","_peerStats","Map","_protocolStats","_oldPeers","maxOldPeersRetention","_running","_onMessage","bind","_connectionManager","connectionManager","on","connection","onPeerDisconnected","remotePeer","start","stop","stats","values","global","peers","Array","from","keys","forPeer","peerId","idString","toB58String","get","protocols","forProtocol","protocol","peerStats","delete","set","direction","dataLength","key","push","protocolStats","updatePlaceholder","placeholder","placeholderStats","peerIdString","existingStats","mergedStats","mergeStats","trackStream","stream","metrics","_source","source","chunk","length","_sink","sink","target","other","_queue","module","exports"],"sources":["C:/Users/zajan/GitHub/chatApplication/node_modules/libp2p/src/metrics/index.js"],"sourcesContent":["// @ts-nocheck\n'use strict'\n\nconst mergeOptions = require('merge-options')\nconst { pipe } = require('it-pipe')\nconst { tap } = require('streaming-iterables')\nconst oldPeerLRU = require('./old-peers')\nconst { METRICS: defaultOptions } = require('../constants')\nconst Stats = require('./stats')\n\nconst initialCounters = [\n  'dataReceived',\n  'dataSent'\n]\n\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n}\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n */\n\n/**\n * @typedef MetricsProperties\n * @property {import('../connection-manager')} connectionManager\n *\n * @typedef MetricsOptions\n * @property {number} [computeThrottleMaxQueueSize = defaultOptions.computeThrottleMaxQueueSize]\n * @property {number} [computeThrottleTimeout = defaultOptions.computeThrottleTimeout]\n * @property {number[]} [movingAverageIntervals = defaultOptions.movingAverageIntervals]\n * @property {number} [maxOldPeersRetention = defaultOptions.maxOldPeersRetention]\n */\n\nclass Metrics {\n  /**\n   * @class\n   * @param {MetricsProperties & MetricsOptions} options\n   */\n  constructor (options) {\n    this._options = mergeOptions(defaultOptions, options)\n    this._globalStats = new Stats(initialCounters, this._options)\n    this._peerStats = new Map()\n    this._protocolStats = new Map()\n    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention)\n    this._running = false\n    this._onMessage = this._onMessage.bind(this)\n    this._connectionManager = options.connectionManager\n    this._connectionManager.on('peer:disconnect', (connection) => {\n      this.onPeerDisconnected(connection.remotePeer)\n    })\n  }\n\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n  start () {\n    this._running = true\n  }\n\n  /**\n   * Stops all averages timers and prevents new data from being tracked.\n   * Once `stop` is called, `start` must be called to resume stats tracking.\n   */\n  stop () {\n    this._running = false\n    this._globalStats.stop()\n    for (const stats of this._peerStats.values()) {\n      stats.stop()\n    }\n    for (const stats of this._protocolStats.values()) {\n      stats.stop()\n    }\n  }\n\n  /**\n   * Gets the global `Stats` object\n   *\n   * @returns {Stats}\n   */\n  get global () {\n    return this._globalStats\n  }\n\n  /**\n   * Returns a list of `PeerId` strings currently being tracked\n   *\n   * @returns {string[]}\n   */\n  get peers () {\n    return Array.from(this._peerStats.keys())\n  }\n\n  /**\n   * Returns the `Stats` object for the given `PeerId` whether it\n   * is a live peer, or in the disconnected peer LRU cache.\n   *\n   * @param {PeerId} peerId\n   * @returns {Stats}\n   */\n  forPeer (peerId) {\n    const idString = peerId.toB58String()\n    return this._peerStats.get(idString) || this._oldPeers.get(idString)\n  }\n\n  /**\n   * Returns a list of all protocol strings currently being tracked.\n   *\n   * @returns {string[]}\n   */\n  get protocols () {\n    return Array.from(this._protocolStats.keys())\n  }\n\n  /**\n   * Returns the `Stats` object for the given `protocol`.\n   *\n   * @param {string} protocol\n   * @returns {Stats}\n   */\n  forProtocol (protocol) {\n    return this._protocolStats.get(protocol)\n  }\n\n  /**\n   * Should be called when all connections to a given peer\n   * have closed. The `Stats` collection for the peer will\n   * be stopped and moved to an LRU for temporary retention.\n   *\n   * @param {PeerId} peerId\n   */\n  onPeerDisconnected (peerId) {\n    const idString = peerId.toB58String()\n    const peerStats = this._peerStats.get(idString)\n    if (peerStats) {\n      peerStats.stop()\n      this._peerStats.delete(idString)\n      this._oldPeers.set(idString, peerStats)\n    }\n  }\n\n  /**\n   * Takes the metadata for a message and tracks it in the\n   * appropriate categories. If the protocol is present, protocol\n   * stats will also be tracked.\n   *\n   * @private\n   * @param {object} params\n   * @param {PeerId} params.remotePeer - Remote peer\n   * @param {string} [params.protocol] - Protocol string the stream is running\n   * @param {string} params.direction - One of ['in','out']\n   * @param {number} params.dataLength - Size of the message\n   * @returns {void}\n   */\n  _onMessage ({ remotePeer, protocol, direction, dataLength }) {\n    if (!this._running) return\n\n    const key = directionToEvent[direction]\n\n    let peerStats = this.forPeer(remotePeer)\n    if (!peerStats) {\n      peerStats = new Stats(initialCounters, this._options)\n      this._peerStats.set(remotePeer.toB58String(), peerStats)\n    }\n\n    // Peer and global stats\n    peerStats.push(key, dataLength)\n    this._globalStats.push(key, dataLength)\n\n    // Protocol specific stats\n    if (protocol) {\n      let protocolStats = this.forProtocol(protocol)\n      if (!protocolStats) {\n        protocolStats = new Stats(initialCounters, this._options)\n        this._protocolStats.set(protocol, protocolStats)\n      }\n      protocolStats.push(key, dataLength)\n    }\n  }\n\n  /**\n   * Replaces the `PeerId` string with the given `peerId`.\n   * If stats are already being tracked for the given `peerId`, the\n   * placeholder stats will be merged with the existing stats.\n   *\n   * @param {PeerId} placeholder - A peerId string\n   * @param {PeerId} peerId\n   * @returns {void}\n   */\n  updatePlaceholder (placeholder, peerId) {\n    if (!this._running) return\n    const placeholderStats = this.forPeer(placeholder)\n    const peerIdString = peerId.toB58String()\n    const existingStats = this.forPeer(peerId)\n    let mergedStats = placeholderStats\n\n    // If we already have stats, merge the two\n    if (existingStats) {\n      // If existing, merge\n      mergedStats = Metrics.mergeStats(existingStats, mergedStats)\n      // Attempt to delete from the old peers list just in case it was tracked there\n      this._oldPeers.delete(peerIdString)\n    }\n\n    this._peerStats.delete(placeholder.toB58String())\n    this._peerStats.set(peerIdString, mergedStats)\n    mergedStats.start()\n  }\n\n  /**\n   * Tracks data running through a given Duplex Iterable `stream`. If\n   * the `peerId` is not provided, a placeholder string will be created and\n   * returned. This allows lazy tracking of a peer when the peer is not yet known.\n   * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n   * with the placeholder string returned from here, and the known `PeerId`.\n   *\n   * @param {Object} options\n   * @param {MultiaddrConnection} options.stream - A duplex iterable stream\n   * @param {PeerId} [options.remotePeer] - The id of the remote peer that's connected\n   * @param {string} [options.protocol] - The protocol the stream is running\n   * @returns {MultiaddrConnection} The peerId string or placeholder string\n   */\n  trackStream ({ stream, remotePeer, protocol }) {\n    const metrics = this\n    const _source = stream.source\n    stream.source = tap(chunk => metrics._onMessage({\n      remotePeer,\n      protocol,\n      direction: 'in',\n      dataLength: chunk.length\n    }))(_source)\n\n    const _sink = stream.sink\n    stream.sink = source => {\n      return pipe(\n        source,\n        tap(chunk => metrics._onMessage({\n          remotePeer,\n          protocol,\n          direction: 'out',\n          dataLength: chunk.length\n        })),\n        _sink\n      )\n    }\n\n    return stream\n  }\n\n  /**\n   * Merges `other` into `target`. `target` will be modified\n   * and returned.\n   *\n   * @param {Stats} target\n   * @param {Stats} other\n   * @returns {Stats}\n   */\n  static mergeStats (target, other) {\n    target.stop()\n    other.stop()\n\n    // Merge queues\n    target._queue = [...target._queue, ...other._queue]\n\n    // TODO: how to merge moving averages?\n    return target\n  }\n}\n\nmodule.exports = Metrics\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}