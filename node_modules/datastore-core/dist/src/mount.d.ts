export = MountDatastore;
/**
 * @typedef {import('interface-datastore').Datastore} Datastore
 * @typedef {import('interface-datastore').Options} Options
 * @typedef {import('interface-datastore').Batch} Batch
 * @typedef {import('interface-datastore').Query} Query
 * @typedef {import('interface-datastore').KeyQuery} KeyQuery
 * @typedef {import('./types').KeyTransform} KeyTransform
 */
/**
 * A datastore that can combine multiple stores inside various
 * key prefixes
 *
 * @implements {Datastore}
 */
declare class MountDatastore extends Adapter implements Datastore {
    /**
     * @param {Array<{prefix: Key, datastore: Datastore}>} mounts
     */
    constructor(mounts: Array<{
        prefix: Key;
        datastore: Datastore;
    }>);
    mounts: {
        prefix: Key;
        datastore: Datastore;
    }[];
    /**
     * Lookup the matching datastore for the given key
     *
     * @private
     * @param {Key} key
     * @returns {{datastore: Datastore, mountpoint: Key, rest: Key} | undefined}
     */
    private _lookup;
}
declare namespace MountDatastore {
    export { Datastore, Options, Batch, Query, KeyQuery, KeyTransform };
}
type Datastore = import('interface-datastore').Datastore;
import { Adapter } from "interface-datastore";
import { Key } from "interface-datastore";
type Options = import('interface-datastore').Options;
type Batch = import('interface-datastore').Batch;
type Query = import('interface-datastore').Query;
type KeyQuery = import('interface-datastore').KeyQuery;
type KeyTransform = import('./types').KeyTransform;
//# sourceMappingURL=mount.d.ts.map