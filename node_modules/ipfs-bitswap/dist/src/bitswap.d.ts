export = Bitswap;
/**
 * JavaScript implementation of the Bitswap 'data exchange' protocol
 * used by IPFS.
 *
 * @implements {IPFSBitswap}
 */
declare class Bitswap extends BlockstoreAdapter implements IPFSBitswap {
    /**
     * @param {import('libp2p')} libp2p
     * @param {Blockstore} blockstore
     * @param {Object} [options]
     * @param {boolean} [options.statsEnabled=false]
     * @param {number} [options.statsComputeThrottleTimeout=1000]
     * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]
     * @param {Record<number, MultihashHasher>} [options.hashers]
     */
    constructor(libp2p: import('libp2p'), blockstore: Blockstore, options?: {
        statsEnabled?: boolean | undefined;
        statsComputeThrottleTimeout?: number | undefined;
        statsComputeThrottleMaxQueueSize?: number | undefined;
        hashers?: Record<number, import("multiformats/hashes/interface").MultihashHasher> | undefined;
    } | undefined);
    _libp2p: import("libp2p");
    _log: debug.Debugger & {
        error: debug.Debugger;
    };
    _options: {
        statsEnabled: boolean;
        statsComputeThrottleTimeout: number;
        statsComputeThrottleMaxQueueSize: number;
    } & {
        statsEnabled?: boolean | undefined;
        statsComputeThrottleTimeout?: number | undefined;
        statsComputeThrottleMaxQueueSize?: number | undefined;
        hashers?: Record<number, import("multiformats/hashes/interface").MultihashHasher> | undefined;
    };
    _stats: Stats;
    network: Network;
    blockstore: import("interface-blockstore/dist/src/types").Blockstore;
    engine: DecisionEngine;
    wm: WantManager;
    notifications: Notifications;
    started: boolean;
    isStarted(): boolean;
    /**
     * @type {PeerId}
     */
    get peerId(): import("peer-id");
    /**
     * handle messages received through the network
     *
     * @param {PeerId} peerId
     * @param {BitswapMessage} incoming
     */
    _receiveMessage(peerId: PeerId, incoming: BitswapMessage): Promise<void>;
    /**
     * @private
     * @param {PeerId} peerId
     * @param {CID} cid
     * @param {Uint8Array} data
     * @param {boolean} wasWanted
     */
    private _handleReceivedBlock;
    /**
     * @private
     * @param {string} peerIdStr
     * @param {CID} cid
     * @param {Uint8Array} data
     * @param {boolean} exists
     */
    private _updateReceiveCounters;
    /**
     * handle errors on the receiving channel
     *
     * @param {Error} err
     */
    _receiveError(err: Error): void;
    /**
     * handle new peers
     *
     * @param {PeerId} peerId
     */
    _onPeerConnected(peerId: PeerId): void;
    /**
     * handle peers being disconnected
     *
     * @param {PeerId} peerId
     */
    _onPeerDisconnected(peerId: PeerId): void;
    enableStats(): void;
    disableStats(): void;
    /**
     * Return the current wantlist for a given `peerId`
     *
     * @param {PeerId} peerId
     * @param {any} [_options]
     */
    wantlistForPeer(peerId: PeerId, _options?: any): Map<string, import("./types/wantlist/entry")>;
    /**
     * Return ledger information for a given `peerId`
     *
     * @param {PeerId} peerId
     */
    ledgerForPeer(peerId: PeerId): {
        peer: import("peer-id");
        value: number;
        sent: number;
        recv: number;
        exchanged: number;
    } | null;
    /**
     * Removes the given CIDs from the wantlist independent of any ref counts.
     *
     * This will cause all outstanding promises for a given block to reject.
     *
     * If you want to cancel the want for a block without doing that, pass an
     * AbortSignal in to `.get` or `.getMany` and abort it.
     *
     * @param {CID[]|CID} cids
     */
    unwant(cids: CID[] | CID): void;
    /**
     * Removes the given keys from the want list. This may cause pending promises
     * for blocks to never resolve.  If you wish these promises to abort instead
     * call `unwant(cids)` instead.
     *
     * @param {CID[]|CID} cids
     */
    cancelWants(cids: CID[] | CID): void;
    /**
     * Sends notifications about the arrival of a block
     *
     * @private
     * @param {CID} cid
     * @param {Uint8Array} data
     */
    private _sendHaveBlockNotifications;
    /**
     * Get the current list of wants
     */
    getWantlist(): IterableIterator<[string, import("./types/wantlist/entry")]>;
    /**
     * Get the current list of partners
     */
    peers(): import("peer-id")[];
    /**
     * Get stats about the bitswap node
     */
    stat(): Stats;
    /**
     * Start the bitswap node
     */
    start(): void;
    /**
     * Stop the bitswap node
     */
    stop(): void;
    unwrap(): import("interface-blockstore/dist/src/types").Blockstore;
}
declare namespace Bitswap {
    export { IPFSBitswap, PeerId, BitswapMessage, Blockstore, Pair, Options, MultihashHasher };
}
type IPFSBitswap = import('./types').IPFSBitswap;
import { BlockstoreAdapter } from "interface-blockstore";
import Stats = require("./stats");
import Network = require("./network");
import DecisionEngine = require("./decision-engine");
import WantManager = require("./want-manager");
import Notifications = require("./notifications");
type PeerId = import('peer-id');
type BitswapMessage = import('./types/message');
import { CID } from "multiformats";
type Blockstore = import('interface-blockstore').Blockstore;
type Pair = import('interface-blockstore').Pair;
type Options = import('interface-blockstore').Options;
type MultihashHasher = import('multiformats/hashes/interface').MultihashHasher;
//# sourceMappingURL=bitswap.d.ts.map